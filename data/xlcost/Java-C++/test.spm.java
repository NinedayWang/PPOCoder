▁class ▁Test ▁{ ▁static ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁20 ▁, ▁30 ▁, ▁50 ▁, ▁10 ▁, ▁70 ▁, ▁30 ▁} ▁; ▁static ▁void ▁print Max Of Min ▁( ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁k ▁= ▁1 ▁; ▁k ▁<= ▁n ▁; ▁k ▁++ ▁) ▁{ ▁int ▁max Of Min ▁= ▁Integer ▁. ▁MIN _ VALUE ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁n ▁- ▁k ▁; ▁i ▁++ ▁) ▁{ ▁int ▁min ▁= ▁arr ▁[ ▁i ▁] ▁; ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁< ▁k ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁+ ▁j ▁] ▁< ▁min ▁) ▁min ▁= ▁arr ▁[ ▁i ▁+ ▁j ▁] ▁; ▁} ▁if ▁( ▁min ▁> ▁max Of Min ▁) ▁max Of Min ▁= ▁min ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁max Of Min ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁print Max Of Min ▁( ▁arr ▁. ▁length ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁Stack ▁; ▁class ▁Test ▁{ ▁static ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁20 ▁, ▁30 ▁, ▁50 ▁, ▁10 ▁, ▁70 ▁, ▁30 ▁} ▁; ▁static ▁void ▁print Max Of Min ▁( ▁int ▁n ▁) ▁{ ▁Stack ▁< ▁Integer ▁> ▁s ▁= ▁new ▁Stack ▁< ▁> ▁( ▁) ▁; ▁int ▁left ▁[ ▁] ▁= ▁new ▁int ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁int ▁right ▁[ ▁] ▁= ▁new ▁int ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁left ▁[ ▁i ▁] ▁= ▁- ▁1 ▁; ▁right ▁[ ▁i ▁] ▁= ▁n ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁while ▁( ▁! ▁s ▁. ▁empty ▁( ▁) ▁&& ▁arr ▁[ ▁s ▁. ▁peek ▁( ▁) ▁] ▁>= ▁arr ▁[ ▁i ▁] ▁) ▁s ▁. ▁pop ▁( ▁) ▁; ▁if ▁( ▁! ▁s ▁. ▁empty ▁( ▁) ▁) ▁left ▁[ ▁i ▁] ▁= ▁s ▁. ▁peek ▁( ▁) ▁; ▁s ▁. ▁push ▁( ▁i ▁) ▁; ▁} ▁while ▁( ▁! ▁s ▁. ▁empty ▁( ▁) ▁) ▁s ▁. ▁pop ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁while ▁( ▁! ▁s ▁. ▁empty ▁( ▁) ▁&& ▁arr ▁[ ▁s ▁. ▁peek ▁( ▁) ▁] ▁>= ▁arr ▁[ ▁i ▁] ▁) ▁s ▁. ▁pop ▁( ▁) ▁; ▁if ▁( ▁! ▁s ▁. ▁empty ▁( ▁) ▁) ▁right ▁[ ▁i ▁] ▁= ▁s ▁. ▁peek ▁( ▁) ▁; ▁s ▁. ▁push ▁( ▁i ▁) ▁; ▁} ▁int ▁ans ▁[ ▁] ▁= ▁new ▁int ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁ans ▁[ ▁i ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁len ▁= ▁right ▁[ ▁i ▁] ▁- ▁left ▁[ ▁i ▁] ▁- ▁1 ▁; ▁ans ▁[ ▁len ▁] ▁= ▁Math ▁. ▁max ▁( ▁ans ▁[ ▁len ▁] ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁1 ▁; ▁i ▁-- ▁) ▁ans ▁[ ▁i ▁] ▁= ▁Math ▁. ▁max ▁( ▁ans ▁[ ▁i ▁] ▁, ▁ans ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁ans ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁print Max Of Min ▁( ▁arr ▁. ▁length ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁sum Between Two K th ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁k 1 ▁, ▁int ▁k 2 ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁arr ▁) ▁; ▁int ▁result ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁k 1 ▁; ▁i ▁< ▁k 2 ▁- ▁1 ▁; ▁i ▁++ ▁) ▁result ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁return ▁result ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁20 ▁, ▁8 ▁, ▁22 ▁, ▁4 ▁, ▁12 ▁, ▁10 ▁, ▁14 ▁} ▁; ▁int ▁k 1 ▁= ▁3 ▁, ▁k 2 ▁= ▁6 ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁sum Between Two K th ▁( ▁arr ▁, ▁k 1 ▁, ▁k 2 ▁) ▁) ▁; ▁} ▁}
▁class ▁Node ▁{ ▁int ▁key ▁; ▁Node ▁left ▁, ▁right ▁; ▁public ▁Node ▁( ▁int ▁key ▁) ▁{ ▁this ▁. ▁key ▁= ▁key ▁; ▁left ▁= ▁right ▁= ▁null ▁; ▁} ▁} ▁class ▁Res ▁{ ▁boolean ▁res ▁= ▁false ▁; ▁} ▁class ▁Binary Tree ▁{ ▁Node ▁root ▁; ▁int ▁count ▁( ▁Node ▁node ▁) ▁{ ▁if ▁( ▁node ▁== ▁null ▁) ▁return ▁0 ▁; ▁return ▁count ▁( ▁node ▁. ▁left ▁) ▁+ ▁count ▁( ▁node ▁. ▁right ▁) ▁+ ▁1 ▁; ▁} ▁int ▁check Rec ▁( ▁Node ▁root ▁, ▁int ▁n ▁, ▁Res ▁res ▁) ▁{ ▁if ▁( ▁root ▁== ▁null ▁) ▁return ▁0 ▁; ▁int ▁c ▁= ▁check Rec ▁( ▁root ▁. ▁left ▁, ▁n ▁, ▁res ▁) ▁+ ▁1 ▁+ ▁check Rec ▁( ▁root ▁. ▁right ▁, ▁n ▁, ▁res ▁) ▁; ▁if ▁( ▁c ▁== ▁n ▁- ▁c ▁) ▁res ▁. ▁res ▁= ▁true ▁; ▁return ▁c ▁; ▁} ▁boolean ▁check ▁( ▁Node ▁root ▁) ▁{ ▁int ▁n ▁= ▁count ▁( ▁root ▁) ▁; ▁Res ▁res ▁= ▁new ▁Res ▁( ▁) ▁; ▁check Rec ▁( ▁root ▁, ▁n ▁, ▁res ▁) ▁; ▁return ▁res ▁. ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Binary Tree ▁tree ▁= ▁new ▁Binary Tree ▁( ▁) ▁; ▁tree ▁. ▁root ▁= ▁new ▁Node ▁( ▁5 ▁) ▁; ▁tree ▁. ▁root ▁. ▁left ▁= ▁new ▁Node ▁( ▁1 ▁) ▁; ▁tree ▁. ▁root ▁. ▁right ▁= ▁new ▁Node ▁( ▁6 ▁) ▁; ▁tree ▁. ▁root ▁. ▁left ▁. ▁left ▁= ▁new ▁Node ▁( ▁3 ▁) ▁; ▁tree ▁. ▁root ▁. ▁right ▁. ▁left ▁= ▁new ▁Node ▁( ▁7 ▁) ▁; ▁tree ▁. ▁root ▁. ▁right ▁. ▁right ▁= ▁new ▁Node ▁( ▁4 ▁) ▁; ▁if ▁( ▁tree ▁. ▁check ▁( ▁tree ▁. ▁root ▁) ▁== ▁true ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁YES ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁NO ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁HashMap ▁; ▁class ▁Sym metric Pairs ▁{ ▁static ▁void ▁find Sym Pairs ▁( ▁int ▁arr ▁[ ▁] ▁[ ▁] ▁) ▁{ ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁h M ▁= ▁new ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁arr ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁int ▁first ▁= ▁arr ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁; ▁int ▁sec ▁= ▁arr ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁; ▁Integer ▁val ▁= ▁h M ▁. ▁get ▁( ▁sec ▁) ▁; ▁if ▁( ▁val ▁!= ▁null ▁&& ▁val ▁== ▁first ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁( ▁" ▁+ ▁sec ▁+ ▁" ▁, ▁" ▁+ ▁first ▁+ ▁" ▁) ▁" ▁) ▁; ▁else ▁h M ▁. ▁put ▁( ▁first ▁, ▁sec ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁arg ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁[ ▁] ▁= ▁new ▁int ▁[ ▁5 ▁] ▁[ ▁2 ▁] ▁; ▁arr ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁= ▁11 ▁; ▁arr ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁= ▁20 ▁; ▁arr ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁= ▁30 ▁; ▁arr ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁= ▁40 ▁; ▁arr ▁[ ▁2 ▁] ▁[ ▁0 ▁] ▁= ▁5 ▁; ▁arr ▁[ ▁2 ▁] ▁[ ▁1 ▁] ▁= ▁10 ▁; ▁arr ▁[ ▁3 ▁] ▁[ ▁0 ▁] ▁= ▁40 ▁; ▁arr ▁[ ▁3 ▁] ▁[ ▁1 ▁] ▁= ▁30 ▁; ▁arr ▁[ ▁4 ▁] ▁[ ▁0 ▁] ▁= ▁10 ▁; ▁arr ▁[ ▁4 ▁] ▁[ ▁1 ▁] ▁= ▁5 ▁; ▁find Sym Pairs ▁( ▁arr ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁class ▁item ▁{ ▁String ▁name ▁; ▁int ▁price ▁; ▁public ▁item ▁( ▁String ▁name ▁, ▁int ▁price ▁) ▁{ ▁this ▁. ▁name ▁= ▁name ▁; ▁this ▁. ▁price ▁= ▁price ▁; ▁} ▁} ▁; ▁static ▁int ▁count Items ▁( ▁item ▁list 1 ▁[ ▁] ▁, ▁int ▁m ▁, ▁item ▁list 2 ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁m ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁if ▁( ▁( ▁list 1 ▁[ ▁i ▁] ▁. ▁name ▁. ▁compareTo ▁( ▁list 2 ▁[ ▁j ▁] ▁. ▁name ▁) ▁== ▁0 ▁) ▁&& ▁( ▁list 1 ▁[ ▁i ▁] ▁. ▁price ▁!= ▁list 2 ▁[ ▁j ▁] ▁. ▁price ▁) ▁) ▁count ▁++ ▁; ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁item ▁list 1 ▁[ ▁] ▁= ▁{ ▁new ▁item ▁( ▁" ▁apple ▁" ▁, ▁60 ▁) ▁, ▁new ▁item ▁( ▁" ▁b read ▁" ▁, ▁20 ▁) ▁, ▁new ▁item ▁( ▁" ▁wh eat ▁" ▁, ▁50 ▁) ▁, ▁new ▁item ▁( ▁" ▁o il ▁" ▁, ▁30 ▁) ▁} ▁; ▁item ▁list 2 ▁[ ▁] ▁= ▁{ ▁new ▁item ▁( ▁" ▁mil k ▁" ▁, ▁20 ▁) ▁, ▁new ▁item ▁( ▁" ▁b read ▁" ▁, ▁15 ▁) ▁, ▁new ▁item ▁( ▁" ▁wh eat ▁" ▁, ▁40 ▁) ▁, ▁new ▁item ▁( ▁" ▁apple ▁" ▁, ▁60 ▁) ▁} ▁; ▁int ▁m ▁= ▁list 1 ▁. ▁length ▁; ▁int ▁n ▁= ▁list 2 ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Count ▁= ▁" ▁+ ▁count Items ▁( ▁list 1 ▁, ▁m ▁, ▁list 2 ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁HashMap ▁; ▁import ▁java ▁. ▁util ▁. ▁Map ▁; ▁public ▁class ▁G f G ▁{ ▁static ▁int ▁find Sub array Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁sum ▁) ▁{ ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁prev Sum ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁int ▁res ▁= ▁0 ▁; ▁int ▁curr sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁curr sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁if ▁( ▁curr sum ▁== ▁sum ▁) ▁res ▁++ ▁; ▁if ▁( ▁prev Sum ▁. ▁containsKey ▁( ▁curr sum ▁- ▁sum ▁) ▁) ▁res ▁+= ▁prev Sum ▁. ▁get ▁( ▁curr sum ▁- ▁sum ▁) ▁; ▁Integer ▁count ▁= ▁prev Sum ▁. ▁get ▁( ▁curr sum ▁) ▁; ▁if ▁( ▁count ▁== ▁null ▁) ▁prev Sum ▁. ▁put ▁( ▁curr sum ▁, ▁1 ▁) ▁; ▁else ▁prev Sum ▁. ▁put ▁( ▁curr sum ▁, ▁count ▁+ ▁1 ▁) ▁; ▁} ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁2 ▁, ▁- ▁2 ▁, ▁- ▁20 ▁, ▁10 ▁} ▁; ▁int ▁sum ▁= ▁- ▁10 ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Sub array Sum ▁( ▁arr ▁, ▁n ▁, ▁sum ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁count Pairs ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁arr ▁[ ▁j ▁] ▁) ▁ans ▁++ ▁; ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁1 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Pairs ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁ArrayList ▁; ▁class ▁Graph ▁{ ▁static ▁final ▁int ▁MAX _ PATH _ SIZE ▁= ▁1000 ▁; ▁static ▁class ▁Node ▁{ ▁char ▁data ▁; ▁Node ▁left ▁, ▁right ▁; ▁} ▁; ▁static ▁Node ▁newNode ▁( ▁char ▁data ▁) ▁{ ▁Node ▁temp ▁= ▁new ▁Node ▁( ▁) ▁; ▁temp ▁. ▁data ▁= ▁data ▁; ▁temp ▁. ▁left ▁= ▁temp ▁. ▁right ▁= ▁null ▁; ▁return ▁temp ▁; ▁} ▁static ▁class ▁PATH ▁{ ▁int ▁H d ▁; ▁char ▁key ▁; ▁public ▁PATH ▁( ▁int ▁H d ▁, ▁char ▁key ▁) ▁{ ▁this ▁. ▁H d ▁= ▁H d ▁; ▁this ▁. ▁key ▁= ▁key ▁; ▁} ▁public ▁PATH ▁( ▁) ▁{ ▁} ▁} ▁; ▁static ▁void ▁print Path ▁( ▁ArrayList ▁< ▁PATH ▁> ▁path ▁, ▁int ▁size ▁) ▁{ ▁int ▁minimum _ H d ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁PATH ▁p ▁; ▁for ▁( ▁int ▁it ▁= ▁0 ▁; ▁it ▁< ▁size ▁; ▁it ▁++ ▁) ▁{ ▁p ▁= ▁path ▁. ▁get ▁( ▁it ▁) ▁; ▁minimum _ H d ▁= ▁Math ▁. ▁min ▁( ▁minimum _ H d ▁, ▁p ▁. ▁H d ▁) ▁; ▁} ▁for ▁( ▁int ▁it ▁= ▁0 ▁; ▁it ▁< ▁size ▁; ▁it ▁++ ▁) ▁{ ▁p ▁= ▁path ▁. ▁get ▁( ▁it ▁) ▁; ▁int ▁no Of Under Scores ▁= ▁Math ▁. ▁abs ▁( ▁p ▁. ▁H d ▁- ▁minimum _ H d ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁no Of Under Scores ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁_ ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁p ▁. ▁key ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁" ▁) ▁; ▁} ▁static ▁void ▁print All Paths Util ▁( ▁Node ▁root ▁, ▁ArrayList ▁< ▁PATH ▁> ▁All Path ▁, ▁int ▁HD ▁, ▁int ▁order ▁) ▁{ ▁if ▁( ▁root ▁== ▁null ▁) ▁return ▁; ▁if ▁( ▁root ▁. ▁left ▁== ▁null ▁&& ▁root ▁. ▁right ▁== ▁null ▁) ▁{ ▁All Path ▁. ▁set ▁( ▁order ▁, ▁new ▁PATH ▁( ▁HD ▁, ▁root ▁. ▁data ▁) ▁) ▁; ▁print Path ▁( ▁All Path ▁, ▁order ▁+ ▁1 ▁) ▁; ▁return ▁; ▁} ▁All Path ▁. ▁set ▁( ▁order ▁, ▁new ▁PATH ▁( ▁HD ▁, ▁root ▁. ▁data ▁) ▁) ▁; ▁print All Paths Util ▁( ▁root ▁. ▁left ▁, ▁All Path ▁, ▁HD ▁- ▁1 ▁, ▁order ▁+ ▁1 ▁) ▁; ▁print All Paths Util ▁( ▁root ▁. ▁right ▁, ▁All Path ▁, ▁HD ▁+ ▁1 ▁, ▁order ▁+ ▁1 ▁) ▁; ▁} ▁static ▁void ▁print All Paths ▁( ▁Node ▁root ▁) ▁{ ▁if ▁( ▁root ▁== ▁null ▁) ▁return ▁; ▁ArrayList ▁< ▁PATH ▁> ▁All paths ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁MAX _ PATH _ SIZE ▁; ▁i ▁++ ▁) ▁{ ▁All paths ▁. ▁add ▁( ▁new ▁PATH ▁( ▁) ▁) ▁; ▁} ▁print All Paths Util ▁( ▁root ▁, ▁All paths ▁, ▁0 ▁, ▁0 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Node ▁root ▁= ▁newNode ▁( ▁' ▁A ▁' ▁) ▁; ▁root ▁. ▁left ▁= ▁newNode ▁( ▁' ▁B ▁' ▁) ▁; ▁root ▁. ▁right ▁= ▁newNode ▁( ▁' ▁C ▁' ▁) ▁; ▁root ▁. ▁left ▁. ▁left ▁= ▁newNode ▁( ▁' ▁D ▁' ▁) ▁; ▁root ▁. ▁left ▁. ▁right ▁= ▁newNode ▁( ▁' ▁E ▁' ▁) ▁; ▁root ▁. ▁right ▁. ▁left ▁= ▁newNode ▁( ▁' ▁F ▁' ▁) ▁; ▁root ▁. ▁right ▁. ▁right ▁= ▁newNode ▁( ▁' ▁G ▁' ▁) ▁; ▁print All Paths ▁( ▁root ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁int ▁find Min ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁low ▁, ▁int ▁high ▁) ▁{ ▁while ▁( ▁low ▁< ▁high ▁) ▁{ ▁int ▁mid ▁= ▁low ▁+ ▁( ▁high ▁- ▁low ▁) ▁/ ▁2 ▁; ▁if ▁( ▁arr ▁[ ▁mid ▁] ▁== ▁arr ▁[ ▁high ▁] ▁) ▁high ▁-- ▁; ▁else ▁if ▁( ▁arr ▁[ ▁mid ▁] ▁> ▁arr ▁[ ▁high ▁] ▁) ▁low ▁= ▁mid ▁+ ▁1 ▁; ▁else ▁high ▁= ▁mid ▁; ▁} ▁return ▁arr ▁[ ▁high ▁] ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr 1 ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁6 ▁, ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁n 1 ▁= ▁arr 1 ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁The ▁minimum ▁element ▁is ▁" ▁+ ▁find Min ▁( ▁arr 1 ▁, ▁0 ▁, ▁n 1 ▁- ▁1 ▁) ▁) ▁; ▁int ▁arr 2 ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁n 2 ▁= ▁arr 2 ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁The ▁minimum ▁element ▁is ▁" ▁+ ▁find Min ▁( ▁arr 2 ▁, ▁0 ▁, ▁n 2 ▁- ▁1 ▁) ▁) ▁; ▁int ▁arr 3 ▁[ ▁] ▁= ▁{ ▁1 ▁} ▁; ▁int ▁n 3 ▁= ▁arr 3 ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁The ▁minimum ▁element ▁is ▁" ▁+ ▁find Min ▁( ▁arr 3 ▁, ▁0 ▁, ▁n 3 ▁- ▁1 ▁) ▁) ▁; ▁int ▁arr 4 ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁} ▁; ▁int ▁n 4 ▁= ▁arr 4 ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁The ▁minimum ▁element ▁is ▁" ▁+ ▁find Min ▁( ▁arr 4 ▁, ▁0 ▁, ▁n 4 ▁- ▁1 ▁) ▁) ▁; ▁int ▁arr 5 ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁1 ▁} ▁; ▁int ▁n 5 ▁= ▁arr 5 ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁The ▁minimum ▁element ▁is ▁" ▁+ ▁find Min ▁( ▁arr 5 ▁, ▁0 ▁, ▁n 5 ▁- ▁1 ▁) ▁) ▁; ▁int ▁arr 6 ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁6 ▁, ▁7 ▁, ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁n 6 ▁= ▁arr 6 ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁The ▁minimum ▁element ▁is ▁" ▁+ ▁find Min ▁( ▁arr 6 ▁, ▁0 ▁, ▁n 6 ▁- ▁1 ▁) ▁) ▁; ▁int ▁arr 7 ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁, ▁7 ▁} ▁; ▁int ▁n 7 ▁= ▁arr 7 ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁The ▁minimum ▁element ▁is ▁" ▁+ ▁find Min ▁( ▁arr 7 ▁, ▁0 ▁, ▁n 7 ▁- ▁1 ▁) ▁) ▁; ▁int ▁arr 8 ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁, ▁7 ▁, ▁8 ▁, ▁1 ▁} ▁; ▁int ▁n 8 ▁= ▁arr 8 ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁The ▁minimum ▁element ▁is ▁" ▁+ ▁find Min ▁( ▁arr 8 ▁, ▁0 ▁, ▁n 8 ▁- ▁1 ▁) ▁) ▁; ▁int ▁arr 9 ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁1 ▁, ▁2 ▁} ▁; ▁int ▁n 9 ▁= ▁arr 9 ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁The ▁minimum ▁element ▁is ▁" ▁+ ▁find Min ▁( ▁arr 9 ▁, ▁0 ▁, ▁n 9 ▁- ▁1 ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁print Array ▁( ▁int ▁[ ▁] ▁array ▁, ▁int ▁length ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁[ ▁" ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁length ▁; ▁i ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁array ▁[ ▁i ▁] ▁) ▁; ▁if ▁( ▁i ▁< ▁( ▁length ▁- ▁1 ▁) ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁, ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" ] NEW _ LINE "); ▁} ▁} ▁static ▁void ▁reverse ▁( ▁int ▁[ ▁] ▁array ▁, ▁int ▁start ▁, ▁int ▁end ▁) ▁{ ▁while ▁( ▁start ▁< ▁end ▁) ▁{ ▁int ▁temp ▁= ▁array ▁[ ▁start ▁] ▁; ▁array ▁[ ▁start ▁] ▁= ▁array ▁[ ▁end ▁] ▁; ▁array ▁[ ▁end ▁] ▁= ▁temp ▁; ▁start ▁++ ▁; ▁end ▁-- ▁; ▁} ▁} ▁static ▁void ▁re arrange ▁( ▁int ▁[ ▁] ▁array ▁, ▁int ▁start ▁, ▁int ▁end ▁) ▁{ ▁if ▁( ▁start ▁== ▁end ▁) ▁return ▁; ▁re arrange ▁( ▁array ▁, ▁( ▁start ▁+ ▁1 ▁) ▁, ▁end ▁) ▁; ▁if ▁( ▁array ▁[ ▁start ▁] ▁>= ▁0 ▁) ▁{ ▁reverse ▁( ▁array ▁, ▁( ▁start ▁+ ▁1 ▁) ▁, ▁end ▁) ▁; ▁reverse ▁( ▁array ▁, ▁start ▁, ▁end ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁array ▁= ▁{ ▁- ▁12 ▁, ▁- ▁11 ▁, ▁- ▁13 ▁, ▁- ▁5 ▁, ▁- ▁6 ▁, ▁7 ▁, ▁5 ▁, ▁3 ▁, ▁6 ▁} ▁; ▁int ▁length ▁= ▁array ▁. ▁length ▁; ▁int ▁count Negative ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁length ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁array ▁[ ▁i ▁] ▁< ▁0 ▁) ▁count Negative ▁++ ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁array ▁: ▁" ▁) ▁; ▁print Array ▁( ▁array ▁, ▁length ▁) ▁; ▁re arrange ▁( ▁array ▁, ▁0 ▁, ▁( ▁length ▁- ▁1 ▁) ▁) ▁; ▁reverse ▁( ▁array ▁, ▁count Negative ▁, ▁( ▁length ▁- ▁1 ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁re arr anged ▁array ▁: ▁" ▁) ▁; ▁print Array ▁( ▁array ▁, ▁length ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁re arrange ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁size ▁) ▁{ ▁int ▁positive ▁= ▁0 ▁, ▁negative ▁= ▁1 ▁, ▁temp ▁; ▁while ▁( ▁true ▁) ▁{ ▁while ▁( ▁positive ▁< ▁size ▁&& ▁a ▁[ ▁positive ▁] ▁>= ▁0 ▁) ▁positive ▁+= ▁2 ▁; ▁while ▁( ▁negative ▁< ▁size ▁&& ▁a ▁[ ▁negative ▁] ▁<= ▁0 ▁) ▁negative ▁+= ▁2 ▁; ▁if ▁( ▁positive ▁< ▁size ▁&& ▁negative ▁< ▁size ▁) ▁{ ▁temp ▁= ▁a ▁[ ▁positive ▁] ▁; ▁a ▁[ ▁positive ▁] ▁= ▁a ▁[ ▁negative ▁] ▁; ▁a ▁[ ▁negative ▁] ▁= ▁temp ▁; ▁} ▁else ▁break ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁- ▁3 ▁, ▁5 ▁, ▁6 ▁, ▁- ▁3 ▁, ▁6 ▁, ▁7 ▁, ▁- ▁4 ▁, ▁9 ▁, ▁10 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁re arrange ▁( ▁arr ▁, ▁n ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁class ▁G F G ▁{ ▁void ▁find 3 l argest ▁( ▁int ▁[ ▁] ▁arr ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁arr ▁) ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁int ▁check ▁= ▁0 ▁, ▁count ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁count ▁< ▁4 ▁) ▁{ ▁if ▁( ▁check ▁!= ▁arr ▁[ ▁n ▁- ▁i ▁] ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁n ▁- ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁check ▁= ▁arr ▁[ ▁n ▁- ▁i ▁] ▁; ▁count ▁++ ▁; ▁} ▁} ▁else ▁break ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁G F G ▁obj ▁= ▁new ▁G F G ▁( ▁) ▁; ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁12 ▁, ▁45 ▁, ▁1 ▁, ▁- ▁1 ▁, ▁45 ▁, ▁54 ▁, ▁23 ▁, ▁5 ▁, ▁0 ▁, ▁- ▁10 ▁} ▁; ▁obj ▁. ▁find 3 l argest ▁( ▁arr ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁Second Small est ▁{ ▁static ▁void ▁print 2 Small est ▁( ▁int ▁arr ▁[ ▁] ▁) ▁{ ▁int ▁first ▁, ▁second ▁, ▁arr _ size ▁= ▁arr ▁. ▁length ▁; ▁if ▁( ▁arr _ size ▁< ▁2 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Invalid ▁Input ▁" ▁) ▁; ▁return ▁; ▁} ▁first ▁= ▁second ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁arr _ size ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁first ▁) ▁{ ▁second ▁= ▁first ▁; ▁first ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁else ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁second ▁&& ▁arr ▁[ ▁i ▁] ▁!= ▁first ▁) ▁second ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁if ▁( ▁second ▁== ▁Integer ▁. ▁MAX _ VALUE ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁There ▁is ▁no ▁second ▁" ▁+ ▁" ▁smallest ▁element ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁The ▁smallest ▁element ▁is ▁" ▁+ ▁first ▁+ ▁" ▁and ▁second ▁Small est ▁" ▁+ ▁" ▁element ▁is ▁" ▁+ ▁second ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁12 ▁, ▁13 ▁, ▁1 ▁, ▁10 ▁, ▁34 ▁, ▁1 ▁} ▁; ▁print 2 Small est ▁( ▁arr ▁) ▁; ▁} ▁}
▁class ▁Small est Missing ▁{ ▁int ▁findFirst Missing ▁( ▁int ▁array ▁[ ▁] ▁, ▁int ▁start ▁, ▁int ▁end ▁) ▁{ ▁if ▁( ▁start ▁> ▁end ▁) ▁return ▁end ▁+ ▁1 ▁; ▁if ▁( ▁start ▁!= ▁array ▁[ ▁start ▁] ▁) ▁return ▁start ▁; ▁int ▁mid ▁= ▁( ▁start ▁+ ▁end ▁) ▁/ ▁2 ▁; ▁if ▁( ▁array ▁[ ▁mid ▁] ▁== ▁mid ▁) ▁return ▁findFirst Missing ▁( ▁array ▁, ▁mid ▁+ ▁1 ▁, ▁end ▁) ▁; ▁return ▁findFirst Missing ▁( ▁array ▁, ▁start ▁, ▁mid ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Small est Missing ▁small ▁= ▁new ▁Small est Missing ▁( ▁) ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁, ▁7 ▁, ▁10 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁First ▁Missing ▁element ▁is ▁: ▁" ▁+ ▁small ▁. ▁findFirst Missing ▁( ▁arr ▁, ▁0 ▁, ▁n ▁- ▁1 ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁final ▁int ▁MAX ▁= ▁1000 ▁; ▁static ▁int ▁tree ▁[ ▁] ▁= ▁new ▁int ▁[ ▁4 ▁* ▁MAX ▁] ▁; ▁static ▁int ▁arr ▁[ ▁] ▁= ▁new ▁int ▁[ ▁MAX ▁] ▁; ▁static ▁int ▁gcd ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁if ▁( ▁a ▁== ▁0 ▁) ▁{ ▁return ▁b ▁; ▁} ▁return ▁gcd ▁( ▁b ▁% ▁a ▁, ▁a ▁) ▁; ▁} ▁static ▁int ▁l cm ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁return ▁a ▁* ▁b ▁/ ▁gcd ▁( ▁a ▁, ▁b ▁) ▁; ▁} ▁static ▁void ▁build ▁( ▁int ▁node ▁, ▁int ▁start ▁, ▁int ▁end ▁) ▁{ ▁if ▁( ▁start ▁== ▁end ▁) ▁{ ▁tree ▁[ ▁node ▁] ▁= ▁arr ▁[ ▁start ▁] ▁; ▁return ▁; ▁} ▁int ▁mid ▁= ▁( ▁start ▁+ ▁end ▁) ▁/ ▁2 ▁; ▁build ▁( ▁2 ▁* ▁node ▁, ▁start ▁, ▁mid ▁) ▁; ▁build ▁( ▁2 ▁* ▁node ▁+ ▁1 ▁, ▁mid ▁+ ▁1 ▁, ▁end ▁) ▁; ▁int ▁left _ l cm ▁= ▁tree ▁[ ▁2 ▁* ▁node ▁] ▁; ▁int ▁right _ l cm ▁= ▁tree ▁[ ▁2 ▁* ▁node ▁+ ▁1 ▁] ▁; ▁tree ▁[ ▁node ▁] ▁= ▁l cm ▁( ▁left _ l cm ▁, ▁right _ l cm ▁) ▁; ▁} ▁static ▁int ▁query ▁( ▁int ▁node ▁, ▁int ▁start ▁, ▁int ▁end ▁, ▁int ▁l ▁, ▁int ▁r ▁) ▁{ ▁if ▁( ▁end ▁< ▁l ▁start ▁> ▁r ▁) ▁{ ▁return ▁1 ▁; ▁} ▁if ▁( ▁l ▁<= ▁start ▁&& ▁r ▁>= ▁end ▁) ▁{ ▁return ▁tree ▁[ ▁node ▁] ▁; ▁} ▁int ▁mid ▁= ▁( ▁start ▁+ ▁end ▁) ▁/ ▁2 ▁; ▁int ▁left _ l cm ▁= ▁query ▁( ▁2 ▁* ▁node ▁, ▁start ▁, ▁mid ▁, ▁l ▁, ▁r ▁) ▁; ▁int ▁right _ l cm ▁= ▁query ▁( ▁2 ▁* ▁node ▁+ ▁1 ▁, ▁mid ▁+ ▁1 ▁, ▁end ▁, ▁l ▁, ▁r ▁) ▁; ▁return ▁l cm ▁( ▁left _ l cm ▁, ▁right _ l cm ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁arr ▁[ ▁0 ▁] ▁= ▁5 ▁; ▁arr ▁[ ▁1 ▁] ▁= ▁7 ▁; ▁arr ▁[ ▁2 ▁] ▁= ▁5 ▁; ▁arr ▁[ ▁3 ▁] ▁= ▁2 ▁; ▁arr ▁[ ▁4 ▁] ▁= ▁10 ▁; ▁arr ▁[ ▁5 ▁] ▁= ▁12 ▁; ▁arr ▁[ ▁6 ▁] ▁= ▁11 ▁; ▁arr ▁[ ▁7 ▁] ▁= ▁17 ▁; ▁arr ▁[ ▁8 ▁] ▁= ▁14 ▁; ▁arr ▁[ ▁9 ▁] ▁= ▁1 ▁; ▁arr ▁[ ▁10 ▁] ▁= ▁44 ▁; ▁build ▁( ▁1 ▁, ▁0 ▁, ▁10 ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁query ▁( ▁1 ▁, ▁0 ▁, ▁10 ▁, ▁2 ▁, ▁5 ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁query ▁( ▁1 ▁, ▁0 ▁, ▁10 ▁, ▁5 ▁, ▁10 ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁query ▁( ▁1 ▁, ▁0 ▁, ▁10 ▁, ▁0 ▁, ▁10 ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁lower Index ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁x ▁) ▁{ ▁int ▁l ▁= ▁0 ▁, ▁h ▁= ▁n ▁- ▁1 ▁; ▁while ▁( ▁l ▁<= ▁h ▁) ▁{ ▁int ▁mid ▁= ▁( ▁l ▁+ ▁h ▁) ▁/ ▁2 ▁; ▁if ▁( ▁arr ▁[ ▁mid ▁] ▁>= ▁x ▁) ▁h ▁= ▁mid ▁- ▁1 ▁; ▁else ▁l ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁return ▁l ▁; ▁} ▁static ▁int ▁upper Index ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁y ▁) ▁{ ▁int ▁l ▁= ▁0 ▁, ▁h ▁= ▁n ▁- ▁1 ▁; ▁while ▁( ▁l ▁<= ▁h ▁) ▁{ ▁int ▁mid ▁= ▁( ▁l ▁+ ▁h ▁) ▁/ ▁2 ▁; ▁if ▁( ▁arr ▁[ ▁mid ▁] ▁<= ▁y ▁) ▁l ▁= ▁mid ▁+ ▁1 ▁; ▁else ▁h ▁= ▁mid ▁- ▁1 ▁; ▁} ▁return ▁h ▁; ▁} ▁static ▁int ▁count In Range ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁count ▁= ▁upper Index ▁( ▁arr ▁, ▁n ▁, ▁y ▁) ▁- ▁lower Index ▁( ▁arr ▁, ▁n ▁, ▁x ▁) ▁+ ▁1 ▁; ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁4 ▁, ▁4 ▁, ▁9 ▁, ▁10 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁Arrays ▁. ▁sort ▁( ▁arr ▁) ▁; ▁int ▁i ▁= ▁1 ▁, ▁j ▁= ▁4 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count In Range ▁( ▁arr ▁, ▁n ▁, ▁i ▁, ▁j ▁) ▁) ▁; ▁; ▁i ▁= ▁9 ▁; ▁j ▁= ▁12 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count In Range ▁( ▁arr ▁, ▁n ▁, ▁i ▁, ▁j ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁type 1 ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁start ▁, ▁int ▁limit ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁start ▁; ▁i ▁<= ▁limit ▁; ▁i ▁++ ▁) ▁arr ▁[ ▁i ▁] ▁++ ▁; ▁} ▁static ▁void ▁type 2 ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁[ ▁] ▁[ ▁] ▁query ▁, ▁int ▁start ▁, ▁int ▁limit ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁start ▁; ▁i ▁<= ▁limit ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁query ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁== ▁1 ▁) ▁type 1 ▁( ▁arr ▁, ▁query ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁, ▁query ▁[ ▁i ▁] ▁[ ▁2 ▁] ▁) ▁; ▁else ▁if ▁( ▁query ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁== ▁2 ▁) ▁type 2 ▁( ▁arr ▁, ▁query ▁, ▁query ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁, ▁query ▁[ ▁i ▁] ▁[ ▁2 ▁] ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁5 ▁, ▁m ▁= ▁5 ▁; ▁int ▁[ ▁] ▁arr ▁= ▁new ▁int ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁int ▁[ ▁] ▁temp ▁= ▁{ ▁1 ▁, ▁1 ▁, ▁2 ▁, ▁1 ▁, ▁4 ▁, ▁5 ▁, ▁2 ▁, ▁1 ▁, ▁2 ▁, ▁2 ▁, ▁1 ▁, ▁3 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁[ ▁] ▁[ ▁] ▁query ▁= ▁new ▁int ▁[ ▁6 ▁] ▁[ ▁4 ▁] ▁; ▁int ▁j ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁m ▁; ▁i ▁++ ▁) ▁{ ▁query ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁= ▁temp ▁[ ▁j ▁++ ▁] ▁; ▁query ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁= ▁temp ▁[ ▁j ▁++ ▁] ▁; ▁query ▁[ ▁i ▁] ▁[ ▁2 ▁] ▁= ▁temp ▁[ ▁j ▁++ ▁] ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁m ▁; ▁i ▁++ ▁) ▁if ▁( ▁query ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁== ▁1 ▁) ▁type 1 ▁( ▁arr ▁, ▁query ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁, ▁query ▁[ ▁i ▁] ▁[ ▁2 ▁] ▁) ▁; ▁else ▁if ▁( ▁query ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁== ▁2 ▁) ▁type 2 ▁( ▁arr ▁, ▁query ▁, ▁query ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁, ▁query ▁[ ▁i ▁] ▁[ ▁2 ▁] ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁Sort Wave ▁{ ▁void ▁swap ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁int ▁temp ▁= ▁arr ▁[ ▁a ▁] ▁; ▁arr ▁[ ▁a ▁] ▁= ▁arr ▁[ ▁b ▁] ▁; ▁arr ▁[ ▁b ▁] ▁= ▁temp ▁; ▁} ▁void ▁sort In Wave ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁arr ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁+= ▁2 ▁) ▁swap ▁( ▁arr ▁, ▁i ▁, ▁i ▁+ ▁1 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁Sort Wave ▁ob ▁= ▁new ▁Sort Wave ▁( ▁) ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁90 ▁, ▁49 ▁, ▁2 ▁, ▁1 ▁, ▁5 ▁, ▁23 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁ob ▁. ▁sort In Wave ▁( ▁arr ▁, ▁n ▁) ▁; ▁for ▁( ▁int ▁i ▁: ▁arr ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁i ▁+ ▁" ▁" ▁) ▁; ▁} ▁}
▁class ▁Merge Arrays ▁{ ▁void ▁moveTo End ▁( ▁int ▁m Plus N ▁[ ▁] ▁, ▁int ▁size ▁) ▁{ ▁int ▁i ▁, ▁j ▁= ▁size ▁- ▁1 ▁; ▁for ▁( ▁i ▁= ▁size ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁m Plus N ▁[ ▁i ▁] ▁!= ▁- ▁1 ▁) ▁{ ▁m Plus N ▁[ ▁j ▁] ▁= ▁m Plus N ▁[ ▁i ▁] ▁; ▁j ▁-- ▁; ▁} ▁} ▁} ▁void ▁merge ▁( ▁int ▁m Plus N ▁[ ▁] ▁, ▁int ▁N ▁[ ▁] ▁, ▁int ▁m ▁, ▁int ▁n ▁) ▁{ ▁int ▁i ▁= ▁n ▁; ▁int ▁j ▁= ▁0 ▁; ▁int ▁k ▁= ▁0 ▁; ▁while ▁( ▁k ▁< ▁( ▁m ▁+ ▁n ▁) ▁) ▁{ ▁if ▁( ▁( ▁i ▁< ▁( ▁m ▁+ ▁n ▁) ▁&& ▁m Plus N ▁[ ▁i ▁] ▁<= ▁N ▁[ ▁j ▁] ▁) ▁|| ▁( ▁j ▁== ▁n ▁) ▁) ▁{ ▁m Plus N ▁[ ▁k ▁] ▁= ▁m Plus N ▁[ ▁i ▁] ▁; ▁k ▁++ ▁; ▁i ▁++ ▁; ▁} ▁else ▁{ ▁m Plus N ▁[ ▁k ▁] ▁= ▁N ▁[ ▁j ▁] ▁; ▁k ▁++ ▁; ▁j ▁++ ▁; ▁} ▁} ▁} ▁void ▁print Array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁size ▁) ▁{ ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Merge Arrays ▁merge array ▁= ▁new ▁Merge Arrays ▁( ▁) ▁; ▁int ▁m Plus N ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁8 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁13 ▁, ▁- ▁1 ▁, ▁15 ▁, ▁20 ▁} ▁; ▁int ▁N ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁7 ▁, ▁9 ▁, ▁25 ▁} ▁; ▁int ▁n ▁= ▁N ▁. ▁length ▁; ▁int ▁m ▁= ▁m Plus N ▁. ▁length ▁- ▁n ▁; ▁merge array ▁. ▁moveTo End ▁( ▁m Plus N ▁, ▁m ▁+ ▁n ▁) ▁; ▁merge array ▁. ▁merge ▁( ▁m Plus N ▁, ▁N ▁, ▁m ▁, ▁n ▁) ▁; ▁merge array ▁. ▁print Array ▁( ▁m Plus N ▁, ▁m ▁+ ▁n ▁) ▁; ▁} ▁}
▁class ▁Test ▁{ ▁static ▁int ▁arr ▁[ ▁] ▁= ▁new ▁int ▁[ ▁] ▁{ ▁1 ▁, ▁20 ▁, ▁6 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁static ▁int ▁getIn v Count ▁( ▁int ▁n ▁) ▁{ ▁int ▁inv _ count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁arr ▁[ ▁j ▁] ▁) ▁inv _ count ▁++ ▁; ▁return ▁inv _ count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Number ▁of ▁in versions ▁are ▁" ▁+ ▁getIn v Count ▁( ▁arr ▁. ▁length ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁class ▁Main ▁{ ▁static ▁void ▁min Abs Sum Pair ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁arr _ size ▁) ▁{ ▁int ▁inv _ count ▁= ▁0 ▁; ▁int ▁l ▁, ▁r ▁, ▁min _ sum ▁, ▁sum ▁, ▁min _ l ▁, ▁min _ r ▁; ▁if ▁( ▁arr _ size ▁< ▁2 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Invalid ▁Input ▁" ▁) ▁; ▁return ▁; ▁} ▁min _ l ▁= ▁0 ▁; ▁min _ r ▁= ▁1 ▁; ▁min _ sum ▁= ▁arr ▁[ ▁0 ▁] ▁+ ▁arr ▁[ ▁1 ▁] ▁; ▁for ▁( ▁l ▁= ▁0 ▁; ▁l ▁< ▁arr _ size ▁- ▁1 ▁; ▁l ▁++ ▁) ▁{ ▁for ▁( ▁r ▁= ▁l ▁+ ▁1 ▁; ▁r ▁< ▁arr _ size ▁; ▁r ▁++ ▁) ▁{ ▁sum ▁= ▁arr ▁[ ▁l ▁] ▁+ ▁arr ▁[ ▁r ▁] ▁; ▁if ▁( ▁Math ▁. ▁abs ▁( ▁min _ sum ▁) ▁> ▁Math ▁. ▁abs ▁( ▁sum ▁) ▁) ▁{ ▁min _ sum ▁= ▁sum ▁; ▁min _ l ▁= ▁l ▁; ▁min _ r ▁= ▁r ▁; ▁} ▁} ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁The ▁two ▁elements ▁whose ▁" ▁+ ▁" ▁sum ▁is ▁minimum ▁are ▁" ▁+ ▁arr ▁[ ▁min _ l ▁] ▁+ ▁" ▁and ▁" ▁+ ▁arr ▁[ ▁min _ r ▁] ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁60 ▁, ▁- ▁10 ▁, ▁70 ▁, ▁- ▁80 ▁, ▁85 ▁} ▁; ▁min Abs Sum Pair ▁( ▁arr ▁, ▁6 ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁count z ot ▁{ ▁static ▁void ▁sort 012 ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁arr _ size ▁) ▁{ ▁int ▁lo ▁= ▁0 ▁; ▁int ▁hi ▁= ▁arr _ size ▁- ▁1 ▁; ▁int ▁mid ▁= ▁0 ▁, ▁temp ▁= ▁0 ▁; ▁while ▁( ▁mid ▁<= ▁hi ▁) ▁{ ▁switch ▁( ▁a ▁[ ▁mid ▁] ▁) ▁{ ▁case ▁0 ▁: ▁{ ▁temp ▁= ▁a ▁[ ▁lo ▁] ▁; ▁a ▁[ ▁lo ▁] ▁= ▁a ▁[ ▁mid ▁] ▁; ▁a ▁[ ▁mid ▁] ▁= ▁temp ▁; ▁lo ▁++ ▁; ▁mid ▁++ ▁; ▁break ▁; ▁} ▁case ▁1 ▁: ▁mid ▁++ ▁; ▁break ▁; ▁case ▁2 ▁: ▁{ ▁temp ▁= ▁a ▁[ ▁mid ▁] ▁; ▁a ▁[ ▁mid ▁] ▁= ▁a ▁[ ▁hi ▁] ▁; ▁a ▁[ ▁hi ▁] ▁= ▁temp ▁; ▁hi ▁-- ▁; ▁break ▁; ▁} ▁} ▁} ▁} ▁static ▁void ▁print Array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁arr _ size ▁) ▁{ ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁arr _ size ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁2 ▁, ▁1 ▁, ▁2 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁} ▁; ▁int ▁arr _ size ▁= ▁arr ▁. ▁length ▁; ▁sort 012 ▁( ▁arr ▁, ▁arr _ size ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Array ▁after ▁seg g reg ation ▁" ▁) ▁; ▁print Array ▁( ▁arr ▁, ▁arr _ size ▁) ▁; ▁} ▁}
▁class ▁Main ▁{ ▁static ▁void ▁print Un sorted ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁s ▁= ▁0 ▁, ▁e ▁= ▁n ▁- ▁1 ▁, ▁i ▁, ▁max ▁, ▁min ▁; ▁for ▁( ▁s ▁= ▁0 ▁; ▁s ▁< ▁n ▁- ▁1 ▁; ▁s ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁s ▁] ▁> ▁arr ▁[ ▁s ▁+ ▁1 ▁] ▁) ▁break ▁; ▁} ▁if ▁( ▁s ▁== ▁n ▁- ▁1 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁The ▁complete ▁array ▁is ▁sorted ▁" ▁) ▁; ▁return ▁; ▁} ▁for ▁( ▁e ▁= ▁n ▁- ▁1 ▁; ▁e ▁> ▁0 ▁; ▁e ▁-- ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁e ▁] ▁< ▁arr ▁[ ▁e ▁- ▁1 ▁] ▁) ▁break ▁; ▁} ▁max ▁= ▁arr ▁[ ▁s ▁] ▁; ▁min ▁= ▁arr ▁[ ▁s ▁] ▁; ▁for ▁( ▁i ▁= ▁s ▁+ ▁1 ▁; ▁i ▁<= ▁e ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁max ▁) ▁max ▁= ▁arr ▁[ ▁i ▁] ▁; ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁min ▁) ▁min ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁min ▁) ▁{ ▁s ▁= ▁i ▁; ▁break ▁; ▁} ▁} ▁for ▁( ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁e ▁+ ▁1 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁max ▁) ▁{ ▁e ▁= ▁i ▁; ▁break ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁The ▁unsorted ▁sub array ▁which ▁" ▁+ ▁" ▁makes ▁the ▁given ▁array ▁sorted ▁lies ▁" ▁+ ▁" ▁between ▁the ▁indices ▁" ▁+ ▁s ▁+ ▁" ▁and ▁" ▁+ ▁e ▁) ▁; ▁return ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁12 ▁, ▁20 ▁, ▁30 ▁, ▁25 ▁, ▁40 ▁, ▁32 ▁, ▁31 ▁, ▁35 ▁, ▁50 ▁, ▁60 ▁} ▁; ▁int ▁arr _ size ▁= ▁arr ▁. ▁length ▁; ▁print Un sorted ▁( ▁arr ▁, ▁arr _ size ▁) ▁; ▁} ▁}
▁class ▁Main ▁{ ▁static ▁int ▁findElement ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁key ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁key ▁) ▁return ▁i ▁; ▁return ▁- ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁12 ▁, ▁34 ▁, ▁10 ▁, ▁6 ▁, ▁40 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁int ▁key ▁= ▁40 ▁; ▁int ▁position ▁= ▁findElement ▁( ▁arr ▁, ▁n ▁, ▁key ▁) ▁; ▁if ▁( ▁position ▁== ▁- ▁1 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Element ▁not ▁found ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Element ▁Found ▁at ▁Position ▁: ▁" ▁+ ▁( ▁position ▁+ ▁1 ▁) ▁) ▁; ▁} ▁}
▁class ▁Main ▁{ ▁static ▁int ▁binarySearch ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁low ▁, ▁int ▁high ▁, ▁int ▁key ▁) ▁{ ▁if ▁( ▁high ▁< ▁low ▁) ▁return ▁- ▁1 ▁; ▁int ▁mid ▁= ▁( ▁low ▁+ ▁high ▁) ▁/ ▁2 ▁; ▁if ▁( ▁key ▁== ▁arr ▁[ ▁mid ▁] ▁) ▁return ▁mid ▁; ▁if ▁( ▁key ▁> ▁arr ▁[ ▁mid ▁] ▁) ▁return ▁binarySearch ▁( ▁arr ▁, ▁( ▁mid ▁+ ▁1 ▁) ▁, ▁high ▁, ▁key ▁) ▁; ▁return ▁binarySearch ▁( ▁arr ▁, ▁low ▁, ▁( ▁mid ▁- ▁1 ▁) ▁, ▁key ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁6 ▁, ▁7 ▁, ▁8 ▁, ▁9 ▁, ▁10 ▁} ▁; ▁int ▁n ▁, ▁key ▁; ▁n ▁= ▁arr ▁. ▁length ▁- ▁1 ▁; ▁key ▁= ▁10 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Index ▁: ▁" ▁+ ▁binarySearch ▁( ▁arr ▁, ▁0 ▁, ▁n ▁, ▁key ▁) ▁) ▁; ▁} ▁}
▁class ▁Equ il ib ri um Index ▁{ ▁int ▁equ il ib ri um ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁int ▁left sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁{ ▁sum ▁-= ▁arr ▁[ ▁i ▁] ▁; ▁if ▁( ▁left sum ▁== ▁sum ▁) ▁return ▁i ▁; ▁left sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁return ▁- ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Equ il ib ri um Index ▁equ i ▁= ▁new ▁Equ il ib ri um Index ▁( ▁) ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁- ▁7 ▁, ▁1 ▁, ▁5 ▁, ▁2 ▁, ▁- ▁4 ▁, ▁3 ▁, ▁0 ▁} ▁; ▁int ▁arr _ size ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁First ▁equ il ib ri um ▁index ▁is ▁" ▁+ ▁equ i ▁. ▁equ il ib ri um ▁( ▁arr ▁, ▁arr _ size ▁) ▁) ▁; ▁} ▁}
▁class ▁Main ▁{ ▁static ▁int ▁ceil Search ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁low ▁, ▁int ▁high ▁, ▁int ▁x ▁) ▁{ ▁int ▁mid ▁; ▁if ▁( ▁x ▁<= ▁arr ▁[ ▁low ▁] ▁) ▁return ▁low ▁; ▁if ▁( ▁x ▁> ▁arr ▁[ ▁high ▁] ▁) ▁return ▁- ▁1 ▁; ▁mid ▁= ▁( ▁low ▁+ ▁high ▁) ▁/ ▁2 ▁; ▁if ▁( ▁arr ▁[ ▁mid ▁] ▁== ▁x ▁) ▁return ▁mid ▁; ▁else ▁if ▁( ▁arr ▁[ ▁mid ▁] ▁< ▁x ▁) ▁{ ▁if ▁( ▁mid ▁+ ▁1 ▁<= ▁high ▁&& ▁x ▁<= ▁arr ▁[ ▁mid ▁+ ▁1 ▁] ▁) ▁return ▁mid ▁+ ▁1 ▁; ▁else ▁return ▁ceil Search ▁( ▁arr ▁, ▁mid ▁+ ▁1 ▁, ▁high ▁, ▁x ▁) ▁; ▁} ▁else ▁{ ▁if ▁( ▁mid ▁- ▁1 ▁>= ▁low ▁&& ▁x ▁> ▁arr ▁[ ▁mid ▁- ▁1 ▁] ▁) ▁return ▁mid ▁; ▁else ▁return ▁ceil Search ▁( ▁arr ▁, ▁low ▁, ▁mid ▁- ▁1 ▁, ▁x ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁8 ▁, ▁10 ▁, ▁10 ▁, ▁12 ▁, ▁19 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁int ▁x ▁= ▁8 ▁; ▁int ▁index ▁= ▁ceil Search ▁( ▁arr ▁, ▁0 ▁, ▁n ▁- ▁1 ▁, ▁x ▁) ▁; ▁if ▁( ▁index ▁== ▁- ▁1 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁C e iling ▁of ▁" ▁+ ▁x ▁+ ▁" ▁doesn ▁' ▁t ▁exist ▁in ▁array ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁ceiling ▁of ▁" ▁+ ▁x ▁+ ▁" ▁is ▁" ▁+ ▁arr ▁[ ▁index ▁] ▁) ▁; ▁} ▁}
▁class ▁G f G ▁{ ▁static ▁class ▁Node ▁{ ▁int ▁data ▁; ▁Node ▁left ▁; ▁Node ▁right ▁; ▁} ▁static ▁int ▁getHeight ▁( ▁Node ▁Node ▁) ▁{ ▁if ▁( ▁Node ▁== ▁null ▁) ▁return ▁0 ▁; ▁else ▁{ ▁int ▁l Height ▁= ▁getHeight ▁( ▁Node ▁. ▁left ▁) ▁; ▁int ▁r Height ▁= ▁getHeight ▁( ▁Node ▁. ▁right ▁) ▁; ▁if ▁( ▁l Height ▁> ▁r Height ▁) ▁return ▁( ▁l Height ▁+ ▁1 ▁) ▁; ▁else ▁return ▁( ▁r Height ▁+ ▁1 ▁) ▁; ▁} ▁} ▁static ▁Node ▁newNode ▁( ▁int ▁data ▁) ▁{ ▁Node ▁Node ▁= ▁new ▁Node ▁( ▁) ▁; ▁Node ▁. ▁data ▁= ▁data ▁; ▁Node ▁. ▁left ▁= ▁null ▁; ▁Node ▁. ▁right ▁= ▁null ▁; ▁return ▁( ▁Node ▁) ▁; ▁} ▁static ▁int ▁getTotal Height ▁( ▁Node ▁root ▁) ▁{ ▁if ▁( ▁root ▁== ▁null ▁) ▁return ▁0 ▁; ▁return ▁getTotal Height ▁( ▁root ▁. ▁left ▁) ▁+ ▁getHeight ▁( ▁root ▁) ▁+ ▁getTotal Height ▁( ▁root ▁. ▁right ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Node ▁root ▁= ▁newNode ▁( ▁1 ▁) ▁; ▁root ▁. ▁left ▁= ▁newNode ▁( ▁2 ▁) ▁; ▁root ▁. ▁right ▁= ▁newNode ▁( ▁3 ▁) ▁; ▁root ▁. ▁left ▁. ▁left ▁= ▁newNode ▁( ▁4 ▁) ▁; ▁root ▁. ▁left ▁. ▁right ▁= ▁newNode ▁( ▁5 ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Sum ▁of ▁heights ▁of ▁all ▁Nodes ▁= ▁" ▁+ ▁getTotal Height ▁( ▁root ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁int ▁majority Element ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁n ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁arr ▁) ▁; ▁int ▁count ▁= ▁1 ▁, ▁max _ ele ▁= ▁- ▁1 ▁, ▁temp ▁= ▁arr ▁[ ▁0 ▁] ▁, ▁ele ▁= ▁0 ▁, ▁f ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁temp ▁== ▁arr ▁[ ▁i ▁] ▁) ▁{ ▁count ▁++ ▁; ▁} ▁else ▁{ ▁count ▁= ▁1 ▁; ▁temp ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁if ▁( ▁max _ ele ▁< ▁count ▁) ▁{ ▁max _ ele ▁= ▁count ▁; ▁ele ▁= ▁arr ▁[ ▁i ▁] ▁; ▁if ▁( ▁max _ ele ▁> ▁( ▁n ▁/ ▁2 ▁) ▁) ▁{ ▁f ▁= ▁1 ▁; ▁break ▁; ▁} ▁} ▁} ▁return ▁( ▁f ▁== ▁1 ▁? ▁ele ▁: ▁- ▁1 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁1 ▁, ▁2 ▁, ▁1 ▁, ▁3 ▁, ▁5 ▁, ▁1 ▁} ▁; ▁int ▁n ▁= ▁7 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁majority Element ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁M ajor ity ▁{ ▁static ▁boolean ▁is Major ity ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁x ▁) ▁{ ▁int ▁i ▁, ▁last _ index ▁= ▁0 ▁; ▁last _ index ▁= ▁( ▁n ▁% ▁2 ▁== ▁0 ▁) ▁? ▁n ▁/ ▁2 ▁: ▁n ▁/ ▁2 ▁+ ▁1 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁last _ index ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁x ▁&& ▁arr ▁[ ▁i ▁+ ▁n ▁/ ▁2 ▁] ▁== ▁x ▁) ▁return ▁true ▁; ▁} ▁return ▁false ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁4 ▁, ▁4 ▁, ▁4 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁int ▁x ▁= ▁4 ▁; ▁if ▁( ▁is Major ity ▁( ▁arr ▁, ▁n ▁, ▁x ▁) ▁== ▁true ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁x ▁+ ▁" ▁appears ▁more ▁than ▁" ▁+ ▁n ▁/ ▁2 ▁+ ▁" ▁times ▁in ▁arr ▁[ ▁] ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁x ▁+ ▁" ▁does ▁not ▁appear ▁more ▁than ▁" ▁+ ▁n ▁/ ▁2 ▁+ ▁" ▁times ▁in ▁arr ▁[ ▁] ▁" ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁class ▁Node ▁{ ▁int ▁data ▁; ▁Node ▁left ▁; ▁Node ▁right ▁; ▁} ▁; ▁static ▁int ▁sum ▁; ▁static ▁Node ▁newNode ▁( ▁int ▁data ▁) ▁{ ▁Node ▁Node ▁= ▁new ▁Node ▁( ▁) ▁; ▁Node ▁. ▁data ▁= ▁data ▁; ▁Node ▁. ▁left ▁= ▁null ▁; ▁Node ▁. ▁right ▁= ▁null ▁; ▁return ▁( ▁Node ▁) ▁; ▁} ▁static ▁int ▁getTotal Height Util ▁( ▁Node ▁root ▁) ▁{ ▁if ▁( ▁root ▁== ▁null ▁) ▁{ ▁return ▁0 ▁; ▁} ▁int ▁lh ▁= ▁getTotal Height Util ▁( ▁root ▁. ▁left ▁) ▁; ▁int ▁rh ▁= ▁getTotal Height Util ▁( ▁root ▁. ▁right ▁) ▁; ▁int ▁h ▁= ▁Math ▁. ▁max ▁( ▁lh ▁, ▁rh ▁) ▁+ ▁1 ▁; ▁sum ▁= ▁sum ▁+ ▁h ▁; ▁return ▁h ▁; ▁} ▁static ▁int ▁getTotal Height ▁( ▁Node ▁root ▁) ▁{ ▁sum ▁= ▁0 ▁; ▁getTotal Height Util ▁( ▁root ▁) ▁; ▁return ▁sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Node ▁root ▁= ▁newNode ▁( ▁1 ▁) ▁; ▁root ▁. ▁left ▁= ▁newNode ▁( ▁2 ▁) ▁; ▁root ▁. ▁right ▁= ▁newNode ▁( ▁3 ▁) ▁; ▁root ▁. ▁left ▁. ▁left ▁= ▁newNode ▁( ▁4 ▁) ▁; ▁root ▁. ▁left ▁. ▁right ▁= ▁newNode ▁( ▁5 ▁) ▁; ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁Sum ▁of ▁heights ▁of ▁all ▁Nodes ▁= ▁% ▁d ▁" ▁, ▁getTotal Height ▁( ▁root ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁Main ▁{ ▁public ▁static ▁void ▁b fs ▁( ▁int ▁n ▁, ▁int ▁m ▁, ▁int ▁num ▁) ▁{ ▁Queue ▁< ▁Integer ▁> ▁q ▁= ▁new ▁LinkedList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁q ▁. ▁add ▁( ▁num ▁) ▁; ▁while ▁( ▁! ▁q ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁int ▁step Num ▁= ▁q ▁. ▁poll ▁( ▁) ▁; ▁if ▁( ▁step Num ▁<= ▁m ▁&& ▁step Num ▁>= ▁n ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁step Num ▁+ ▁" ▁" ▁) ▁; ▁} ▁if ▁( ▁step Num ▁== ▁0 ▁step Num ▁> ▁m ▁) ▁continue ▁; ▁int ▁last Digit ▁= ▁step Num ▁% ▁10 ▁; ▁int ▁step Num A ▁= ▁step Num ▁* ▁10 ▁+ ▁( ▁last Digit ▁- ▁1 ▁) ▁; ▁int ▁step Num B ▁= ▁step Num ▁* ▁10 ▁+ ▁( ▁last Digit ▁+ ▁1 ▁) ▁; ▁if ▁( ▁last Digit ▁== ▁0 ▁) ▁q ▁. ▁add ▁( ▁step Num B ▁) ▁; ▁else ▁if ▁( ▁last Digit ▁== ▁9 ▁) ▁q ▁. ▁add ▁( ▁step Num A ▁) ▁; ▁else ▁{ ▁q ▁. ▁add ▁( ▁step Num A ▁) ▁; ▁q ▁. ▁add ▁( ▁step Num B ▁) ▁; ▁} ▁} ▁} ▁public ▁static ▁void ▁display St e pping Numbers ▁( ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁9 ▁; ▁i ▁++ ▁) ▁b fs ▁( ▁n ▁, ▁m ▁, ▁i ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁0 ▁, ▁m ▁= ▁21 ▁; ▁display St e pping Numbers ▁( ▁n ▁, ▁m ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁LinkedList ▁; ▁import ▁java ▁. ▁util ▁. ▁Queue ▁; ▁public ▁class ▁G F G ▁{ ▁static ▁class ▁Node ▁{ ▁int ▁data ▁; ▁Node ▁left ▁; ▁Node ▁right ▁; ▁Node ▁( ▁int ▁data ▁) ▁{ ▁this ▁. ▁data ▁= ▁data ▁; ▁left ▁= ▁null ▁; ▁right ▁= ▁null ▁; ▁} ▁} ▁static ▁void ▁level Order ▁( ▁Node ▁root ▁) ▁{ ▁if ▁( ▁root ▁== ▁null ▁) ▁return ▁; ▁Queue ▁< ▁Node ▁> ▁q ▁= ▁new ▁LinkedList ▁< ▁> ▁( ▁) ▁; ▁q ▁. ▁add ▁( ▁root ▁) ▁; ▁q ▁. ▁add ▁( ▁null ▁) ▁; ▁while ▁( ▁! ▁q ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁Node ▁curr ▁= ▁q ▁. ▁poll ▁( ▁) ▁; ▁if ▁( ▁curr ▁== ▁null ▁) ▁{ ▁if ▁( ▁! ▁q ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁q ▁. ▁add ▁( ▁null ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁} ▁} ▁else ▁{ ▁if ▁( ▁curr ▁. ▁left ▁!= ▁null ▁) ▁q ▁. ▁add ▁( ▁curr ▁. ▁left ▁) ▁; ▁if ▁( ▁curr ▁. ▁right ▁!= ▁null ▁) ▁q ▁. ▁add ▁( ▁curr ▁. ▁right ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁curr ▁. ▁data ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Node ▁root ▁= ▁new ▁Node ▁( ▁1 ▁) ▁; ▁root ▁. ▁left ▁= ▁new ▁Node ▁( ▁2 ▁) ▁; ▁root ▁. ▁right ▁= ▁new ▁Node ▁( ▁3 ▁) ▁; ▁root ▁. ▁left ▁. ▁left ▁= ▁new ▁Node ▁( ▁4 ▁) ▁; ▁root ▁. ▁left ▁. ▁right ▁= ▁new ▁Node ▁( ▁5 ▁) ▁; ▁root ▁. ▁right ▁. ▁right ▁= ▁new ▁Node ▁( ▁6 ▁) ▁; ▁level Order ▁( ▁root ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁shortest Chain Len ▁( ▁String ▁start ▁, ▁String ▁target ▁, ▁Set ▁< ▁String ▁> ▁D ▁) ▁{ ▁if ▁( ▁start ▁== ▁target ▁) ▁return ▁0 ▁; ▁if ▁( ▁! ▁D ▁. ▁contains ▁( ▁target ▁) ▁) ▁return ▁0 ▁; ▁int ▁level ▁= ▁0 ▁, ▁word length ▁= ▁start ▁. ▁length ▁( ▁) ▁; ▁Queue ▁< ▁String ▁> ▁Q ▁= ▁new ▁LinkedList ▁< ▁> ▁( ▁) ▁; ▁Q ▁. ▁add ▁( ▁start ▁) ▁; ▁while ▁( ▁! ▁Q ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁++ ▁level ▁; ▁int ▁sizeof Q ▁= ▁Q ▁. ▁size ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁sizeof Q ▁; ▁++ ▁i ▁) ▁{ ▁char ▁[ ▁] ▁word ▁= ▁Q ▁. ▁peek ▁( ▁) ▁. ▁toCharArray ▁( ▁) ▁; ▁Q ▁. ▁remove ▁( ▁) ▁; ▁for ▁( ▁int ▁pos ▁= ▁0 ▁; ▁pos ▁< ▁word length ▁; ▁++ ▁pos ▁) ▁{ ▁char ▁orig _ char ▁= ▁word ▁[ ▁pos ▁] ▁; ▁for ▁( ▁char ▁c ▁= ▁' ▁a ▁' ▁; ▁c ▁<= ▁' ▁z ▁' ▁; ▁++ ▁c ▁) ▁{ ▁word ▁[ ▁pos ▁] ▁= ▁c ▁; ▁if ▁( ▁String ▁. ▁valueOf ▁( ▁word ▁) ▁. ▁equals ▁( ▁target ▁) ▁) ▁return ▁level ▁+ ▁1 ▁; ▁if ▁( ▁! ▁D ▁. ▁contains ▁( ▁String ▁. ▁valueOf ▁( ▁word ▁) ▁) ▁) ▁continue ▁; ▁D ▁. ▁remove ▁( ▁String ▁. ▁valueOf ▁( ▁word ▁) ▁) ▁; ▁Q ▁. ▁add ▁( ▁String ▁. ▁valueOf ▁( ▁word ▁) ▁) ▁; ▁} ▁word ▁[ ▁pos ▁] ▁= ▁orig _ char ▁; ▁} ▁} ▁} ▁return ▁0 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Set ▁< ▁String ▁> ▁D ▁= ▁new ▁HashSet ▁< ▁String ▁> ▁( ▁) ▁; ▁D ▁. ▁add ▁( ▁" ▁po on ▁" ▁) ▁; ▁D ▁. ▁add ▁( ▁" ▁p lee ▁" ▁) ▁; ▁D ▁. ▁add ▁( ▁" ▁same ▁" ▁) ▁; ▁D ▁. ▁add ▁( ▁" ▁po ie ▁" ▁) ▁; ▁D ▁. ▁add ▁( ▁" ▁p lie ▁" ▁) ▁; ▁D ▁. ▁add ▁( ▁" ▁p oin ▁" ▁) ▁; ▁D ▁. ▁add ▁( ▁" ▁p le a ▁" ▁) ▁; ▁String ▁start ▁= ▁" ▁to on ▁" ▁; ▁String ▁target ▁= ▁" ▁p le a ▁" ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Length ▁of ▁shortest ▁chain ▁is ▁: ▁" ▁+ ▁shortest Chain Len ▁( ▁start ▁, ▁target ▁, ▁D ▁) ▁) ▁; ▁} ▁}
▁class ▁Node ▁{ ▁int ▁data ▁; ▁Node ▁next ▁; ▁Node ▁( ▁int ▁d ▁) ▁{ ▁data ▁= ▁d ▁; ▁next ▁= ▁null ▁; ▁} ▁} ▁class ▁LinkedList ▁{ ▁Node ▁head ▁; ▁void ▁push ▁( ▁int ▁new _ data ▁) ▁{ ▁Node ▁new _ node ▁= ▁new ▁Node ▁( ▁new _ data ▁) ▁; ▁new _ node ▁. ▁next ▁= ▁head ▁; ▁head ▁= ▁new _ node ▁; ▁} ▁void ▁print List ▁( ▁) ▁{ ▁Node ▁node ▁= ▁head ▁; ▁while ▁( ▁node ▁!= ▁null ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁node ▁. ▁data ▁+ ▁" ▁" ▁) ▁; ▁node ▁= ▁node ▁. ▁next ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁" ▁) ▁; ▁} ▁int ▁count Nodes ▁( ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁Node ▁s ▁= ▁head ▁; ▁while ▁( ▁s ▁!= ▁null ▁) ▁{ ▁count ▁++ ▁; ▁s ▁= ▁s ▁. ▁next ▁; ▁} ▁return ▁count ▁; ▁} ▁void ▁swap K th ▁( ▁int ▁k ▁) ▁{ ▁int ▁n ▁= ▁count Nodes ▁( ▁) ▁; ▁if ▁( ▁n ▁< ▁k ▁) ▁return ▁; ▁if ▁( ▁2 ▁* ▁k ▁- ▁1 ▁== ▁n ▁) ▁return ▁; ▁Node ▁x ▁= ▁head ▁; ▁Node ▁x _ prev ▁= ▁null ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁k ▁; ▁i ▁++ ▁) ▁{ ▁x _ prev ▁= ▁x ▁; ▁x ▁= ▁x ▁. ▁next ▁; ▁} ▁Node ▁y ▁= ▁head ▁; ▁Node ▁y _ prev ▁= ▁null ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁- ▁k ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁y _ prev ▁= ▁y ▁; ▁y ▁= ▁y ▁. ▁next ▁; ▁} ▁if ▁( ▁x _ prev ▁!= ▁null ▁) ▁x _ prev ▁. ▁next ▁= ▁y ▁; ▁if ▁( ▁y _ prev ▁!= ▁null ▁) ▁y _ prev ▁. ▁next ▁= ▁x ▁; ▁Node ▁temp ▁= ▁x ▁. ▁next ▁; ▁x ▁. ▁next ▁= ▁y ▁. ▁next ▁; ▁y ▁. ▁next ▁= ▁temp ▁; ▁if ▁( ▁k ▁== ▁1 ▁) ▁head ▁= ▁y ▁; ▁if ▁( ▁k ▁== ▁n ▁) ▁head ▁= ▁x ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁LinkedList ▁l list ▁= ▁new ▁LinkedList ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁8 ▁; ▁i ▁>= ▁1 ▁; ▁i ▁-- ▁) ▁l list ▁. ▁push ▁( ▁i ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Original ▁linked ▁list ▁: ▁" ▁) ▁; ▁l list ▁. ▁print List ▁( ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁" ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁9 ▁; ▁i ▁++ ▁) ▁{ ▁l list ▁. ▁swap K th ▁( ▁i ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Modified ▁List ▁for ▁k ▁= ▁" ▁+ ▁i ▁) ▁; ▁l list ▁. ▁print List ▁( ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁" ▁) ▁; ▁} ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁class ▁Node ▁{ ▁int ▁data ▁; ▁Node ▁next ▁, ▁prev ▁; ▁} ▁; ▁static ▁int ▁count Pairs ▁( ▁Node ▁first ▁, ▁Node ▁second ▁, ▁int ▁value ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁while ▁( ▁first ▁!= ▁null ▁&& ▁second ▁!= ▁null ▁&& ▁first ▁!= ▁second ▁&& ▁second ▁. ▁next ▁!= ▁first ▁) ▁{ ▁if ▁( ▁( ▁first ▁. ▁data ▁+ ▁second ▁. ▁data ▁) ▁== ▁value ▁) ▁{ ▁count ▁++ ▁; ▁first ▁= ▁first ▁. ▁next ▁; ▁second ▁= ▁second ▁. ▁prev ▁; ▁} ▁else ▁if ▁( ▁( ▁first ▁. ▁data ▁+ ▁second ▁. ▁data ▁) ▁> ▁value ▁) ▁second ▁= ▁second ▁. ▁prev ▁; ▁else ▁first ▁= ▁first ▁. ▁next ▁; ▁} ▁return ▁count ▁; ▁} ▁static ▁int ▁count Tri pl ets ▁( ▁Node ▁head ▁, ▁int ▁x ▁) ▁{ ▁if ▁( ▁head ▁== ▁null ▁) ▁return ▁0 ▁; ▁Node ▁current ▁, ▁first ▁, ▁last ▁; ▁int ▁count ▁= ▁0 ▁; ▁last ▁= ▁head ▁; ▁while ▁( ▁last ▁. ▁next ▁!= ▁null ▁) ▁last ▁= ▁last ▁. ▁next ▁; ▁for ▁( ▁current ▁= ▁head ▁; ▁current ▁!= ▁null ▁; ▁current ▁= ▁current ▁. ▁next ▁) ▁{ ▁first ▁= ▁current ▁. ▁next ▁; ▁count ▁+= ▁count Pairs ▁( ▁first ▁, ▁last ▁, ▁x ▁- ▁current ▁. ▁data ▁) ▁; ▁} ▁return ▁count ▁; ▁} ▁static ▁Node ▁insert ▁( ▁Node ▁head ▁, ▁int ▁data ▁) ▁{ ▁Node ▁temp ▁= ▁new ▁Node ▁( ▁) ▁; ▁temp ▁. ▁data ▁= ▁data ▁; ▁temp ▁. ▁next ▁= ▁temp ▁. ▁prev ▁= ▁null ▁; ▁if ▁( ▁( ▁head ▁) ▁== ▁null ▁) ▁( ▁head ▁) ▁= ▁temp ▁; ▁else ▁{ ▁temp ▁. ▁next ▁= ▁head ▁; ▁( ▁head ▁) ▁. ▁prev ▁= ▁temp ▁; ▁( ▁head ▁) ▁= ▁temp ▁; ▁} ▁return ▁head ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Node ▁head ▁= ▁null ▁; ▁head ▁= ▁insert ▁( ▁head ▁, ▁9 ▁) ▁; ▁head ▁= ▁insert ▁( ▁head ▁, ▁8 ▁) ▁; ▁head ▁= ▁insert ▁( ▁head ▁, ▁6 ▁) ▁; ▁head ▁= ▁insert ▁( ▁head ▁, ▁5 ▁) ▁; ▁head ▁= ▁insert ▁( ▁head ▁, ▁4 ▁) ▁; ▁head ▁= ▁insert ▁( ▁head ▁, ▁2 ▁) ▁; ▁head ▁= ▁insert ▁( ▁head ▁, ▁1 ▁) ▁; ▁int ▁x ▁= ▁17 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Count ▁= ▁" ▁+ ▁count Tri pl ets ▁( ▁head ▁, ▁x ▁) ▁) ▁; ▁} ▁}
▁class ▁G f G ▁{ ▁static ▁class ▁Node ▁{ ▁char ▁data ▁; ▁Node ▁next ▁; ▁} ▁static ▁Node ▁newNode ▁( ▁char ▁key ▁) ▁{ ▁Node ▁temp ▁= ▁new ▁Node ▁( ▁) ▁; ▁temp ▁. ▁data ▁= ▁key ▁; ▁temp ▁. ▁next ▁= ▁null ▁; ▁return ▁temp ▁; ▁} ▁static ▁void ▁print list ▁( ▁Node ▁head ▁) ▁{ ▁if ▁( ▁head ▁== ▁null ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Empty ▁List ▁" ▁) ▁; ▁return ▁; ▁} ▁while ▁( ▁head ▁!= ▁null ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁head ▁. ▁data ▁+ ▁" ▁" ▁) ▁; ▁if ▁( ▁head ▁. ▁next ▁!= ▁null ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁- ▁> ▁" ▁) ▁; ▁head ▁= ▁head ▁. ▁next ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁} ▁static ▁boolean ▁is V ow el ▁( ▁char ▁x ▁) ▁{ ▁return ▁( ▁x ▁== ▁' ▁a ▁' ▁x ▁== ▁' ▁e ▁' ▁x ▁== ▁' ▁i ▁' ▁x ▁== ▁' ▁o ▁' ▁x ▁== ▁' ▁u ▁' ▁) ▁; ▁} ▁static ▁Node ▁arrange ▁( ▁Node ▁head ▁) ▁{ ▁Node ▁new Head ▁= ▁head ▁; ▁Node ▁latest V ow el ▁; ▁Node ▁curr ▁= ▁head ▁; ▁if ▁( ▁head ▁== ▁null ▁) ▁return ▁null ▁; ▁if ▁( ▁is V ow el ▁( ▁head ▁. ▁data ▁) ▁== ▁true ▁) ▁latest V ow el ▁= ▁head ▁; ▁else ▁{ ▁while ▁( ▁curr ▁. ▁next ▁!= ▁null ▁&& ▁! ▁is V ow el ▁( ▁curr ▁. ▁next ▁. ▁data ▁) ▁) ▁curr ▁= ▁curr ▁. ▁next ▁; ▁if ▁( ▁curr ▁. ▁next ▁== ▁null ▁) ▁return ▁head ▁; ▁latest V ow el ▁= ▁new Head ▁= ▁curr ▁. ▁next ▁; ▁curr ▁. ▁next ▁= ▁curr ▁. ▁next ▁. ▁next ▁; ▁latest V ow el ▁. ▁next ▁= ▁head ▁; ▁} ▁while ▁( ▁curr ▁!= ▁null ▁&& ▁curr ▁. ▁next ▁!= ▁null ▁) ▁{ ▁if ▁( ▁is V ow el ▁( ▁curr ▁. ▁next ▁. ▁data ▁) ▁== ▁true ▁) ▁{ ▁if ▁( ▁curr ▁== ▁latest V ow el ▁) ▁{ ▁latest V ow el ▁= ▁curr ▁= ▁curr ▁. ▁next ▁; ▁} ▁else ▁{ ▁Node ▁temp ▁= ▁latest V ow el ▁. ▁next ▁; ▁latest V ow el ▁. ▁next ▁= ▁curr ▁. ▁next ▁; ▁latest V ow el ▁= ▁latest V ow el ▁. ▁next ▁; ▁curr ▁. ▁next ▁= ▁curr ▁. ▁next ▁. ▁next ▁; ▁latest V ow el ▁. ▁next ▁= ▁temp ▁; ▁} ▁} ▁else ▁{ ▁curr ▁= ▁curr ▁. ▁next ▁; ▁} ▁} ▁return ▁new Head ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Node ▁head ▁= ▁newNode ▁( ▁' ▁a ▁' ▁) ▁; ▁head ▁. ▁next ▁= ▁newNode ▁( ▁' ▁b ▁' ▁) ▁; ▁head ▁. ▁next ▁. ▁next ▁= ▁newNode ▁( ▁' ▁c ▁' ▁) ▁; ▁head ▁. ▁next ▁. ▁next ▁. ▁next ▁= ▁newNode ▁( ▁' ▁e ▁' ▁) ▁; ▁head ▁. ▁next ▁. ▁next ▁. ▁next ▁. ▁next ▁= ▁newNode ▁( ▁' ▁d ▁' ▁) ▁; ▁head ▁. ▁next ▁. ▁next ▁. ▁next ▁. ▁next ▁. ▁next ▁= ▁newNode ▁( ▁' ▁o ▁' ▁) ▁; ▁head ▁. ▁next ▁. ▁next ▁. ▁next ▁. ▁next ▁. ▁next ▁. ▁next ▁= ▁newNode ▁( ▁' ▁x ▁' ▁) ▁; ▁head ▁. ▁next ▁. ▁next ▁. ▁next ▁. ▁next ▁. ▁next ▁. ▁next ▁. ▁next ▁= ▁newNode ▁( ▁' ▁i ▁' ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Linked ▁list ▁before ▁: ▁" ▁) ▁; ▁print list ▁( ▁head ▁) ▁; ▁head ▁= ▁arrange ▁( ▁head ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Linked ▁list ▁after ▁: ▁" ▁) ▁; ▁print list ▁( ▁head ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁Node ▁{ ▁int ▁data ▁; ▁Node ▁left ▁, ▁right ▁; ▁Node ▁( ▁int ▁x ▁) ▁{ ▁data ▁= ▁x ▁; ▁left ▁= ▁right ▁= ▁null ▁; ▁} ▁} ▁class ▁G F G ▁{ ▁static ▁int ▁count ▁= ▁0 ▁; ▁public ▁static ▁Node ▁insert ▁( ▁Node ▁root ▁, ▁int ▁x ▁) ▁{ ▁if ▁( ▁root ▁== ▁null ▁) ▁return ▁new ▁Node ▁( ▁x ▁) ▁; ▁if ▁( ▁x ▁< ▁root ▁. ▁data ▁) ▁root ▁. ▁left ▁= ▁insert ▁( ▁root ▁. ▁left ▁, ▁x ▁) ▁; ▁else ▁if ▁( ▁x ▁> ▁root ▁. ▁data ▁) ▁root ▁. ▁right ▁= ▁insert ▁( ▁root ▁. ▁right ▁, ▁x ▁) ▁; ▁return ▁root ▁; ▁} ▁public ▁static ▁Node ▁k th Small est ▁( ▁Node ▁root ▁, ▁int ▁k ▁) ▁{ ▁if ▁( ▁root ▁== ▁null ▁) ▁return ▁null ▁; ▁Node ▁left ▁= ▁k th Small est ▁( ▁root ▁. ▁left ▁, ▁k ▁) ▁; ▁if ▁( ▁left ▁!= ▁null ▁) ▁return ▁left ▁; ▁count ▁++ ▁; ▁if ▁( ▁count ▁== ▁k ▁) ▁return ▁root ▁; ▁return ▁k th Small est ▁( ▁root ▁. ▁right ▁, ▁k ▁) ▁; ▁} ▁public ▁static ▁void ▁print K th Small est ▁( ▁Node ▁root ▁, ▁int ▁k ▁) ▁{ ▁count ▁= ▁0 ▁; ▁Node ▁res ▁= ▁k th Small est ▁( ▁root ▁, ▁k ▁) ▁; ▁if ▁( ▁res ▁== ▁null ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁There ▁are ▁less ▁" ▁+ ▁" ▁than ▁k ▁nodes ▁in ▁the ▁B ST ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁K ▁- ▁th ▁Small est ▁" ▁+ ▁" ▁Element ▁is ▁" ▁+ ▁res ▁. ▁data ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Node ▁root ▁= ▁null ▁; ▁int ▁keys ▁[ ▁] ▁= ▁{ ▁20 ▁, ▁8 ▁, ▁22 ▁, ▁4 ▁, ▁12 ▁, ▁10 ▁, ▁14 ▁} ▁; ▁for ▁( ▁int ▁x ▁: ▁keys ▁) ▁root ▁= ▁insert ▁( ▁root ▁, ▁x ▁) ▁; ▁int ▁k ▁= ▁3 ▁; ▁print K th Small est ▁( ▁root ▁, ▁k ▁) ▁; ▁} ▁}
▁class ▁G f G ▁{ ▁static ▁class ▁Node ▁{ ▁Node ▁left ▁, ▁right ▁; ▁int ▁key ▁; ▁} ▁static ▁Node ▁newNode ▁( ▁int ▁key ▁) ▁{ ▁Node ▁ptr ▁= ▁new ▁Node ▁( ▁) ▁; ▁ptr ▁. ▁key ▁= ▁key ▁; ▁ptr ▁. ▁left ▁= ▁null ▁; ▁ptr ▁. ▁right ▁= ▁null ▁; ▁return ▁ptr ▁; ▁} ▁static ▁Node ▁insert ▁( ▁Node ▁root ▁, ▁int ▁key ▁) ▁{ ▁if ▁( ▁root ▁== ▁null ▁) ▁root ▁= ▁newNode ▁( ▁key ▁) ▁; ▁else ▁if ▁( ▁root ▁. ▁key ▁> ▁key ▁) ▁root ▁. ▁left ▁= ▁insert ▁( ▁root ▁. ▁left ▁, ▁key ▁) ▁; ▁else ▁if ▁( ▁root ▁. ▁key ▁< ▁key ▁) ▁root ▁. ▁right ▁= ▁insert ▁( ▁root ▁. ▁right ▁, ▁key ▁) ▁; ▁return ▁root ▁; ▁} ▁static ▁int ▁distance From Root ▁( ▁Node ▁root ▁, ▁int ▁x ▁) ▁{ ▁if ▁( ▁root ▁. ▁key ▁== ▁x ▁) ▁return ▁0 ▁; ▁else ▁if ▁( ▁root ▁. ▁key ▁> ▁x ▁) ▁return ▁1 ▁+ ▁distance From Root ▁( ▁root ▁. ▁left ▁, ▁x ▁) ▁; ▁return ▁1 ▁+ ▁distance From Root ▁( ▁root ▁. ▁right ▁, ▁x ▁) ▁; ▁} ▁static ▁int ▁distance Between 2 ▁( ▁Node ▁root ▁, ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁if ▁( ▁root ▁== ▁null ▁) ▁return ▁0 ▁; ▁if ▁( ▁root ▁. ▁key ▁> ▁a ▁&& ▁root ▁. ▁key ▁> ▁b ▁) ▁return ▁distance Between 2 ▁( ▁root ▁. ▁left ▁, ▁a ▁, ▁b ▁) ▁; ▁if ▁( ▁root ▁. ▁key ▁< ▁a ▁&& ▁root ▁. ▁key ▁< ▁b ▁) ▁return ▁distance Between 2 ▁( ▁root ▁. ▁right ▁, ▁a ▁, ▁b ▁) ▁; ▁if ▁( ▁root ▁. ▁key ▁>= ▁a ▁&& ▁root ▁. ▁key ▁<= ▁b ▁) ▁return ▁distance From Root ▁( ▁root ▁, ▁a ▁) ▁+ ▁distance From Root ▁( ▁root ▁, ▁b ▁) ▁; ▁return ▁0 ▁; ▁} ▁static ▁int ▁find Dist Wrapper ▁( ▁Node ▁root ▁, ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁int ▁temp ▁= ▁0 ▁; ▁if ▁( ▁a ▁> ▁b ▁) ▁{ ▁temp ▁= ▁a ▁; ▁a ▁= ▁b ▁; ▁b ▁= ▁temp ▁; ▁} ▁return ▁distance Between 2 ▁( ▁root ▁, ▁a ▁, ▁b ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Node ▁root ▁= ▁null ▁; ▁root ▁= ▁insert ▁( ▁root ▁, ▁20 ▁) ▁; ▁insert ▁( ▁root ▁, ▁10 ▁) ▁; ▁insert ▁( ▁root ▁, ▁5 ▁) ▁; ▁insert ▁( ▁root ▁, ▁15 ▁) ▁; ▁insert ▁( ▁root ▁, ▁30 ▁) ▁; ▁insert ▁( ▁root ▁, ▁25 ▁) ▁; ▁insert ▁( ▁root ▁, ▁35 ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Dist Wrapper ▁( ▁root ▁, ▁5 ▁, ▁35 ▁) ▁) ▁; ▁} ▁}
▁class ▁G f G ▁{ ▁static ▁class ▁node ▁{ ▁int ▁data ▁; ▁node ▁left ▁, ▁right ▁; ▁} ▁; ▁static ▁class ▁INT ▁{ ▁int ▁a ▁; ▁} ▁static ▁boolean ▁in Range ▁( ▁node ▁root ▁, ▁int ▁low ▁, ▁int ▁high ▁) ▁{ ▁return ▁root ▁. ▁data ▁>= ▁low ▁&& ▁root ▁. ▁data ▁<= ▁high ▁; ▁} ▁static ▁boolean ▁getCount Util ▁( ▁node ▁root ▁, ▁int ▁low ▁, ▁int ▁high ▁, ▁INT ▁count ▁) ▁{ ▁if ▁( ▁root ▁== ▁null ▁) ▁return ▁true ▁; ▁boolean ▁l ▁= ▁getCount Util ▁( ▁root ▁. ▁left ▁, ▁low ▁, ▁high ▁, ▁count ▁) ▁; ▁boolean ▁r ▁= ▁getCount Util ▁( ▁root ▁. ▁right ▁, ▁low ▁, ▁high ▁, ▁count ▁) ▁; ▁if ▁( ▁l ▁&& ▁r ▁&& ▁in Range ▁( ▁root ▁, ▁low ▁, ▁high ▁) ▁) ▁{ ▁++ ▁count ▁. ▁a ▁; ▁return ▁true ▁; ▁} ▁return ▁false ▁; ▁} ▁static ▁INT ▁getCount ▁( ▁node ▁root ▁, ▁int ▁low ▁, ▁int ▁high ▁) ▁{ ▁INT ▁count ▁= ▁new ▁INT ▁( ▁) ▁; ▁count ▁. ▁a ▁= ▁0 ▁; ▁getCount Util ▁( ▁root ▁, ▁low ▁, ▁high ▁, ▁count ▁) ▁; ▁return ▁count ▁; ▁} ▁static ▁node ▁newNode ▁( ▁int ▁data ▁) ▁{ ▁node ▁temp ▁= ▁new ▁node ▁( ▁) ▁; ▁temp ▁. ▁data ▁= ▁data ▁; ▁temp ▁. ▁left ▁= ▁temp ▁. ▁right ▁= ▁null ▁; ▁return ▁( ▁temp ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁node ▁root ▁= ▁newNode ▁( ▁10 ▁) ▁; ▁root ▁. ▁left ▁= ▁newNode ▁( ▁5 ▁) ▁; ▁root ▁. ▁right ▁= ▁newNode ▁( ▁50 ▁) ▁; ▁root ▁. ▁left ▁. ▁left ▁= ▁newNode ▁( ▁1 ▁) ▁; ▁root ▁. ▁right ▁. ▁left ▁= ▁newNode ▁( ▁40 ▁) ▁; ▁root ▁. ▁right ▁. ▁right ▁= ▁newNode ▁( ▁100 ▁) ▁; ▁int ▁l ▁= ▁5 ▁; ▁int ▁h ▁= ▁45 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Count ▁of ▁sub trees ▁in ▁[ ▁" ▁+ ▁l ▁+ ▁" ▁, ▁" ▁+ ▁h ▁+ ▁" ▁] ▁is ▁" ▁+ ▁getCount ▁( ▁root ▁, ▁l ▁, ▁h ▁) ▁. ▁a ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁private ▁static ▁void ▁print Sorted ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁start ▁, ▁int ▁end ▁) ▁{ ▁if ▁( ▁start ▁> ▁end ▁) ▁return ▁; ▁print Sorted ▁( ▁arr ▁, ▁start ▁* ▁2 ▁+ ▁1 ▁, ▁end ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁start ▁] ▁+ ▁" ▁" ▁) ▁; ▁print Sorted ▁( ▁arr ▁, ▁start ▁* ▁2 ▁+ ▁2 ▁, ▁end ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁2 ▁, ▁5 ▁, ▁1 ▁, ▁3 ▁} ▁; ▁print Sorted ▁( ▁arr ▁, ▁0 ▁, ▁arr ▁. ▁length ▁- ▁1 ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁find Min O pe art ion ▁( ▁int ▁matrix ▁[ ▁] ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁[ ▁] ▁sum Row ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁int ▁[ ▁] ▁sum Col ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁++ ▁j ▁) ▁{ ▁sum Row ▁[ ▁i ▁] ▁+= ▁matrix ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁sum Col ▁[ ▁j ▁] ▁+= ▁matrix ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁} ▁int ▁max Sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁{ ▁max Sum ▁= ▁Math ▁. ▁max ▁( ▁max Sum ▁, ▁sum Row ▁[ ▁i ▁] ▁) ▁; ▁max Sum ▁= ▁Math ▁. ▁max ▁( ▁max Sum ▁, ▁sum Col ▁[ ▁i ▁] ▁) ▁; ▁} ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁, ▁j ▁= ▁0 ▁; ▁i ▁< ▁n ▁&& ▁j ▁< ▁n ▁; ▁) ▁{ ▁int ▁diff ▁= ▁Math ▁. ▁min ▁( ▁max Sum ▁- ▁sum Row ▁[ ▁i ▁] ▁, ▁max Sum ▁- ▁sum Col ▁[ ▁j ▁] ▁) ▁; ▁matrix ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+= ▁diff ▁; ▁sum Row ▁[ ▁i ▁] ▁+= ▁diff ▁; ▁sum Col ▁[ ▁j ▁] ▁+= ▁diff ▁; ▁count ▁+= ▁diff ▁; ▁if ▁( ▁sum Row ▁[ ▁i ▁] ▁== ▁max Sum ▁) ▁++ ▁i ▁; ▁if ▁( ▁sum Col ▁[ ▁j ▁] ▁== ▁max Sum ▁) ▁++ ▁j ▁; ▁} ▁return ▁count ▁; ▁} ▁static ▁void ▁print Matrix ▁( ▁int ▁matrix ▁[ ▁] ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁++ ▁j ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁matrix ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+ ▁" ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁matrix ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁} ▁, ▁{ ▁3 ▁, ▁4 ▁} ▁} ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Min O pe art ion ▁( ▁matrix ▁, ▁2 ▁) ▁) ▁; ▁print Matrix ▁( ▁matrix ▁, ▁2 ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁private ▁static ▁void ▁search ▁( ▁int ▁[ ▁] ▁[ ▁] ▁mat ▁, ▁int ▁n ▁, ▁int ▁x ▁) ▁{ ▁int ▁i ▁= ▁0 ▁, ▁j ▁= ▁n ▁- ▁1 ▁; ▁while ▁( ▁i ▁< ▁n ▁&& ▁j ▁>= ▁0 ▁) ▁{ ▁if ▁( ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁== ▁x ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁n ▁Found ▁at ▁" ▁+ ▁i ▁+ ▁" ▁" ▁+ ▁j ▁) ▁; ▁return ▁; ▁} ▁if ▁( ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁> ▁x ▁) ▁j ▁-- ▁; ▁else ▁i ▁++ ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁n ▁Element ▁not ▁found ▁" ▁) ▁; ▁return ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁mat ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁10 ▁, ▁20 ▁, ▁30 ▁, ▁40 ▁} ▁, ▁{ ▁15 ▁, ▁25 ▁, ▁35 ▁, ▁45 ▁} ▁, ▁{ ▁27 ▁, ▁29 ▁, ▁37 ▁, ▁48 ▁} ▁, ▁{ ▁32 ▁, ▁33 ▁, ▁39 ▁, ▁50 ▁} ▁} ▁; ▁search ▁( ▁mat ▁, ▁4 ▁, ▁29 ▁) ▁; ▁} ▁}
▁public ▁class ▁G F G ▁{ ▁static ▁boolean ▁are Sum Same ▁( ▁int ▁a ▁[ ▁] ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁int ▁sum 1 ▁= ▁0 ▁, ▁sum 2 ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁sum 1 ▁= ▁0 ▁; ▁sum 2 ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁m ▁; ▁j ▁++ ▁) ▁{ ▁sum 1 ▁+= ▁a ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁sum 2 ▁+= ▁a ▁[ ▁j ▁] ▁[ ▁i ▁] ▁; ▁} ▁if ▁( ▁sum 1 ▁== ▁sum 2 ▁) ▁return ▁true ▁; ▁} ▁return ▁false ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁4 ▁; ▁int ▁m ▁= ▁4 ▁; ▁int ▁M ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁, ▁{ ▁9 ▁, ▁5 ▁, ▁3 ▁, ▁1 ▁} ▁, ▁{ ▁0 ▁, ▁3 ▁, ▁5 ▁, ▁6 ▁} ▁, ▁{ ▁0 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁} ▁} ▁; ▁if ▁( ▁are Sum Same ▁( ▁M ▁, ▁n ▁, ▁m ▁) ▁== ▁true ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁"1 NEW _ LINE "); ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁"0 NEW _ LINE "); ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁final ▁int ▁N ▁= ▁5 ▁; ▁static ▁final ▁int ▁M ▁= ▁5 ▁; ▁static ▁int ▁min Operation ▁( ▁boolean ▁arr ▁[ ▁] ▁[ ▁] ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁N ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁M ▁- ▁1 ▁; ▁j ▁>= ▁0 ▁; ▁j ▁-- ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁[ ▁j ▁] ▁== ▁false ▁) ▁{ ▁ans ▁++ ▁; ▁for ▁( ▁int ▁k ▁= ▁0 ▁; ▁k ▁<= ▁i ▁; ▁k ▁++ ▁) ▁{ ▁for ▁( ▁int ▁h ▁= ▁0 ▁; ▁h ▁<= ▁j ▁; ▁h ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁k ▁] ▁[ ▁h ▁] ▁== ▁true ▁) ▁{ ▁arr ▁[ ▁k ▁] ▁[ ▁h ▁] ▁= ▁false ▁; ▁} ▁else ▁{ ▁arr ▁[ ▁k ▁] ▁[ ▁h ▁] ▁= ▁true ▁; ▁} ▁} ▁} ▁} ▁} ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁boolean ▁mat ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁false ▁, ▁false ▁, ▁true ▁, ▁true ▁, ▁true ▁} ▁, ▁{ ▁false ▁, ▁false ▁, ▁false ▁, ▁true ▁, ▁true ▁} ▁, ▁{ ▁false ▁, ▁false ▁, ▁false ▁, ▁true ▁, ▁true ▁} ▁, ▁{ ▁true ▁, ▁true ▁, ▁true ▁, ▁true ▁, ▁true ▁} ▁, ▁{ ▁true ▁, ▁true ▁, ▁true ▁, ▁true ▁, ▁true ▁} ▁} ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁min Operation ▁( ▁mat ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁sp ir al D ia Sum ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁1 ▁) ▁return ▁1 ▁; ▁return ▁( ▁4 ▁* ▁n ▁* ▁n ▁- ▁6 ▁* ▁n ▁+ ▁6 ▁+ ▁sp ir al D ia Sum ▁( ▁n ▁- ▁2 ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁7 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁sp ir al D ia Sum ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁final ▁int ▁MAX ▁= ▁100 ▁; ▁static ▁void ▁print Matrix Diag onal ▁( ▁int ▁mat ▁[ ▁] ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁i ▁= ▁0 ▁, ▁j ▁= ▁0 ▁; ▁boolean ▁is Up ▁= ▁true ▁; ▁for ▁( ▁int ▁k ▁= ▁0 ▁; ▁k ▁< ▁n ▁* ▁n ▁; ▁) ▁{ ▁if ▁( ▁is Up ▁) ▁{ ▁for ▁( ▁; ▁i ▁>= ▁0 ▁&& ▁j ▁< ▁n ▁; ▁j ▁++ ▁, ▁i ▁-- ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+ ▁" ▁" ▁) ▁; ▁k ▁++ ▁; ▁} ▁if ▁( ▁i ▁< ▁0 ▁&& ▁j ▁<= ▁n ▁- ▁1 ▁) ▁i ▁= ▁0 ▁; ▁if ▁( ▁j ▁== ▁n ▁) ▁{ ▁i ▁= ▁i ▁+ ▁2 ▁; ▁j ▁-- ▁; ▁} ▁} ▁else ▁{ ▁for ▁( ▁; ▁j ▁>= ▁0 ▁&& ▁i ▁< ▁n ▁; ▁i ▁++ ▁, ▁j ▁-- ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+ ▁" ▁" ▁) ▁; ▁k ▁++ ▁; ▁} ▁if ▁( ▁j ▁< ▁0 ▁&& ▁i ▁<= ▁n ▁- ▁1 ▁) ▁j ▁= ▁0 ▁; ▁if ▁( ▁i ▁== ▁n ▁) ▁{ ▁j ▁= ▁j ▁+ ▁2 ▁; ▁i ▁-- ▁; ▁} ▁} ▁is Up ▁= ▁! ▁is Up ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁mat ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁, ▁{ ▁4 ▁, ▁5 ▁, ▁6 ▁} ▁, ▁{ ▁7 ▁, ▁8 ▁, ▁9 ▁} ▁} ▁; ▁int ▁n ▁= ▁3 ▁; ▁print Matrix Diag onal ▁( ▁mat ▁, ▁n ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁R ▁= ▁3 ▁; ▁static ▁int ▁C ▁= ▁4 ▁; ▁static ▁int ▁gcd ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁if ▁( ▁b ▁== ▁0 ▁) ▁return ▁a ▁; ▁return ▁gcd ▁( ▁b ▁, ▁a ▁% ▁b ▁) ▁; ▁} ▁static ▁void ▁replace matrix ▁( ▁int ▁[ ▁] ▁[ ▁] ▁mat ▁, ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁int ▁[ ▁] ▁rg cd ▁= ▁new ▁int ▁[ ▁R ▁] ▁; ▁int ▁[ ▁] ▁cg cd ▁= ▁new ▁int ▁[ ▁C ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁m ▁; ▁j ▁++ ▁) ▁{ ▁rg cd ▁[ ▁i ▁] ▁= ▁gcd ▁( ▁rg cd ▁[ ▁i ▁] ▁, ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁; ▁cg cd ▁[ ▁j ▁] ▁= ▁gcd ▁( ▁cg cd ▁[ ▁j ▁] ▁, ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁m ▁; ▁j ▁++ ▁) ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁Math ▁. ▁max ▁( ▁rg cd ▁[ ▁i ▁] ▁, ▁cg cd ▁[ ▁j ▁] ▁) ▁; ▁} ▁static ▁public ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁[ ▁] ▁m ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁3 ▁} ▁, ▁{ ▁4 ▁, ▁5 ▁, ▁6 ▁, ▁6 ▁} ▁, ▁{ ▁7 ▁, ▁8 ▁, ▁9 ▁, ▁9 ▁} ▁, ▁} ▁; ▁replace matrix ▁( ▁m ▁, ▁R ▁, ▁C ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁R ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁C ▁; ▁j ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁m ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+ ▁" ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁} ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁MAX ▁= ▁100 ▁; ▁static ▁int ▁sorted Count ▁( ▁int ▁mat ▁[ ▁] ▁[ ▁] ▁, ▁int ▁r ▁, ▁int ▁c ▁) ▁{ ▁int ▁result ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁r ▁; ▁i ▁++ ▁) ▁{ ▁int ▁j ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁c ▁- ▁1 ▁; ▁j ▁++ ▁) ▁if ▁( ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁+ ▁1 ▁] ▁<= ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁break ▁; ▁if ▁( ▁j ▁== ▁c ▁- ▁1 ▁) ▁result ▁++ ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁r ▁; ▁i ▁++ ▁) ▁{ ▁int ▁j ▁; ▁for ▁( ▁j ▁= ▁c ▁- ▁1 ▁; ▁j ▁> ▁0 ▁; ▁j ▁-- ▁) ▁if ▁( ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁<= ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁break ▁; ▁if ▁( ▁c ▁> ▁1 ▁&& ▁j ▁== ▁0 ▁) ▁result ▁++ ▁; ▁} ▁return ▁result ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁arg ▁[ ▁] ▁) ▁{ ▁int ▁m ▁= ▁4 ▁, ▁n ▁= ▁5 ▁; ▁int ▁mat ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁, ▁{ ▁4 ▁, ▁3 ▁, ▁1 ▁, ▁2 ▁, ▁6 ▁} ▁, ▁{ ▁8 ▁, ▁7 ▁, ▁6 ▁, ▁5 ▁, ▁4 ▁} ▁, ▁{ ▁5 ▁, ▁7 ▁, ▁8 ▁, ▁9 ▁, ▁10 ▁} ▁} ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁sorted Count ▁( ▁mat ▁, ▁m ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁find Max Value ▁( ▁int ▁N ▁, ▁int ▁mat ▁[ ▁] ▁[ ▁] ▁) ▁{ ▁int ▁maxValue ▁= ▁Integer ▁. ▁MIN _ VALUE ▁; ▁int ▁max Arr ▁[ ▁] ▁[ ▁] ▁= ▁new ▁int ▁[ ▁N ▁] ▁[ ▁N ▁] ▁; ▁max Arr ▁[ ▁N ▁- ▁1 ▁] ▁[ ▁N ▁- ▁1 ▁] ▁= ▁mat ▁[ ▁N ▁- ▁1 ▁] ▁[ ▁N ▁- ▁1 ▁] ▁; ▁int ▁max v ▁= ▁mat ▁[ ▁N ▁- ▁1 ▁] ▁[ ▁N ▁- ▁1 ▁] ▁; ▁for ▁( ▁int ▁j ▁= ▁N ▁- ▁2 ▁; ▁j ▁>= ▁0 ▁; ▁j ▁-- ▁) ▁{ ▁if ▁( ▁mat ▁[ ▁N ▁- ▁1 ▁] ▁[ ▁j ▁] ▁> ▁max v ▁) ▁max v ▁= ▁mat ▁[ ▁N ▁- ▁1 ▁] ▁[ ▁j ▁] ▁; ▁max Arr ▁[ ▁N ▁- ▁1 ▁] ▁[ ▁j ▁] ▁= ▁max v ▁; ▁} ▁max v ▁= ▁mat ▁[ ▁N ▁- ▁1 ▁] ▁[ ▁N ▁- ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁N ▁- ▁2 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁mat ▁[ ▁i ▁] ▁[ ▁N ▁- ▁1 ▁] ▁> ▁max v ▁) ▁max v ▁= ▁mat ▁[ ▁i ▁] ▁[ ▁N ▁- ▁1 ▁] ▁; ▁max Arr ▁[ ▁i ▁] ▁[ ▁N ▁- ▁1 ▁] ▁= ▁max v ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁N ▁- ▁2 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁N ▁- ▁2 ▁; ▁j ▁>= ▁0 ▁; ▁j ▁-- ▁) ▁{ ▁if ▁( ▁max Arr ▁[ ▁i ▁+ ▁1 ▁] ▁[ ▁j ▁+ ▁1 ▁] ▁- ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁> ▁maxValue ▁) ▁maxValue ▁= ▁max Arr ▁[ ▁i ▁+ ▁1 ▁] ▁[ ▁j ▁+ ▁1 ▁] ▁- ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁max Arr ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁Math ▁. ▁max ▁( ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁, ▁Math ▁. ▁max ▁( ▁max Arr ▁[ ▁i ▁] ▁[ ▁j ▁+ ▁1 ▁] ▁, ▁max Arr ▁[ ▁i ▁+ ▁1 ▁] ▁[ ▁j ▁] ▁) ▁) ▁; ▁} ▁} ▁return ▁maxValue ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁5 ▁; ▁int ▁mat ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁, ▁- ▁1 ▁, ▁- ▁4 ▁, ▁- ▁20 ▁} ▁, ▁{ ▁- ▁8 ▁, ▁- ▁3 ▁, ▁4 ▁, ▁2 ▁, ▁1 ▁} ▁, ▁{ ▁3 ▁, ▁8 ▁, ▁6 ▁, ▁1 ▁, ▁3 ▁} ▁, ▁{ ▁- ▁4 ▁, ▁- ▁1 ▁, ▁1 ▁, ▁7 ▁, ▁- ▁6 ▁} ▁, ▁{ ▁0 ▁, ▁- ▁4 ▁, ▁10 ▁, ▁- ▁5 ▁, ▁1 ▁} ▁} ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Maximum ▁Value ▁is ▁" ▁+ ▁find Max Value ▁( ▁N ▁, ▁mat ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁ROW ▁= ▁4 ▁; ▁static ▁int ▁COL ▁= ▁5 ▁; ▁static ▁void ▁find Unique Rows ▁( ▁int ▁M ▁[ ▁] ▁[ ▁] ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁ROW ▁; ▁i ▁++ ▁) ▁{ ▁int ▁flag ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁i ▁; ▁j ▁++ ▁) ▁{ ▁flag ▁= ▁1 ▁; ▁for ▁( ▁int ▁k ▁= ▁0 ▁; ▁k ▁< ▁COL ▁; ▁k ▁++ ▁) ▁if ▁( ▁M ▁[ ▁i ▁] ▁[ ▁k ▁] ▁!= ▁M ▁[ ▁j ▁] ▁[ ▁k ▁] ▁) ▁flag ▁= ▁0 ▁; ▁if ▁( ▁flag ▁== ▁1 ▁) ▁break ▁; ▁} ▁if ▁( ▁flag ▁== ▁0 ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁COL ▁; ▁j ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁M ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+ ▁" ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁} ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁M ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁0 ▁} ▁, ▁{ ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁0 ▁} ▁} ▁; ▁find Unique Rows ▁( ▁M ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁R ▁= ▁3 ▁; ▁static ▁int ▁C ▁= ▁3 ▁; ▁static ▁class ▁Cell ▁{ ▁int ▁r ▁; ▁int ▁c ▁; ▁public ▁Cell ▁( ▁int ▁r ▁, ▁int ▁c ▁) ▁{ ▁this ▁. ▁r ▁= ▁r ▁; ▁this ▁. ▁c ▁= ▁c ▁; ▁} ▁} ▁; ▁static ▁void ▁print Sum s ▁( ▁int ▁mat ▁[ ▁] ▁[ ▁] ▁, ▁Cell ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁, ▁r ▁= ▁arr ▁[ ▁i ▁] ▁. ▁r ▁, ▁c ▁= ▁arr ▁[ ▁i ▁] ▁. ▁c ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁R ▁; ▁j ▁++ ▁) ▁{ ▁for ▁( ▁int ▁k ▁= ▁0 ▁; ▁k ▁< ▁C ▁; ▁k ▁++ ▁) ▁{ ▁if ▁( ▁j ▁!= ▁r ▁&& ▁k ▁!= ▁c ▁) ▁{ ▁sum ▁+= ▁mat ▁[ ▁j ▁] ▁[ ▁k ▁] ▁; ▁} ▁} ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁sum ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁mat ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁1 ▁, ▁2 ▁} ▁, ▁{ ▁3 ▁, ▁4 ▁, ▁6 ▁} ▁, ▁{ ▁5 ▁, ▁3 ▁, ▁2 ▁} ▁} ▁; ▁Cell ▁arr ▁[ ▁] ▁= ▁{ ▁new ▁Cell ▁( ▁0 ▁, ▁0 ▁) ▁, ▁new ▁Cell ▁( ▁1 ▁, ▁1 ▁) ▁, ▁new ▁Cell ▁( ▁0 ▁, ▁1 ▁) ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁print Sum s ▁( ▁mat ▁, ▁arr ▁, ▁n ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁n ▁= ▁5 ▁; ▁static ▁void ▁print Sum Tr icky ▁( ▁int ▁mat ▁[ ▁] ▁[ ▁] ▁, ▁int ▁k ▁) ▁{ ▁if ▁( ▁k ▁> ▁n ▁) ▁return ▁; ▁int ▁strip Sum ▁[ ▁] ▁[ ▁] ▁= ▁new ▁int ▁[ ▁n ▁] ▁[ ▁n ▁] ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁k ▁; ▁i ▁++ ▁) ▁sum ▁+= ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁strip Sum ▁[ ▁0 ▁] ▁[ ▁j ▁] ▁= ▁sum ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁- ▁k ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁( ▁mat ▁[ ▁i ▁+ ▁k ▁- ▁1 ▁] ▁[ ▁j ▁] ▁- ▁mat ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁) ▁; ▁strip Sum ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁sum ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁k ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁k ▁; ▁j ▁++ ▁) ▁sum ▁+= ▁strip Sum ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁sum ▁+ ▁" ▁" ▁) ▁; ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁< ▁n ▁- ▁k ▁+ ▁1 ▁; ▁j ▁++ ▁) ▁{ ▁sum ▁+= ▁( ▁strip Sum ▁[ ▁i ▁] ▁[ ▁j ▁+ ▁k ▁- ▁1 ▁] ▁- ▁strip Sum ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁sum ▁+ ▁" ▁" ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁mat ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁} ▁, ▁{ ▁2 ▁, ▁2 ▁, ▁2 ▁, ▁2 ▁, ▁2 ▁} ▁, ▁{ ▁3 ▁, ▁3 ▁, ▁3 ▁, ▁3 ▁, ▁3 ▁} ▁, ▁{ ▁4 ▁, ▁4 ▁, ▁4 ▁, ▁4 ▁, ▁4 ▁} ▁, ▁{ ▁5 ▁, ▁5 ▁, ▁5 ▁, ▁5 ▁, ▁5 ▁} ▁, ▁} ▁; ▁int ▁k ▁= ▁3 ▁; ▁print Sum Tr icky ▁( ▁mat ▁, ▁k ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁final ▁int ▁R ▁= ▁3 ▁; ▁static ▁final ▁int ▁C ▁= ▁3 ▁; ▁static ▁final ▁int ▁MAX _ K ▁= ▁100 ▁; ▁static ▁int ▁[ ▁] ▁[ ▁] ▁[ ▁] ▁dp ▁= ▁new ▁int ▁[ ▁R ▁] ▁[ ▁C ▁] ▁[ ▁MAX _ K ▁] ▁; ▁static ▁int ▁path Count DP Rec DP ▁( ▁int ▁[ ▁] ▁[ ▁] ▁mat ▁, ▁int ▁m ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁if ▁( ▁m ▁< ▁0 ▁n ▁< ▁0 ▁) ▁return ▁0 ▁; ▁if ▁( ▁m ▁== ▁0 ▁&& ▁n ▁== ▁0 ▁) ▁return ▁( ▁k ▁== ▁mat ▁[ ▁m ▁] ▁[ ▁n ▁] ▁? ▁1 ▁: ▁0 ▁) ▁; ▁if ▁( ▁dp ▁[ ▁m ▁] ▁[ ▁n ▁] ▁[ ▁k ▁] ▁!= ▁- ▁1 ▁) ▁return ▁dp ▁[ ▁m ▁] ▁[ ▁n ▁] ▁[ ▁k ▁] ▁; ▁dp ▁[ ▁m ▁] ▁[ ▁n ▁] ▁[ ▁k ▁] ▁= ▁path Count DP Rec DP ▁( ▁mat ▁, ▁m ▁- ▁1 ▁, ▁n ▁, ▁k ▁- ▁mat ▁[ ▁m ▁] ▁[ ▁n ▁] ▁) ▁+ ▁path Count DP Rec DP ▁( ▁mat ▁, ▁m ▁, ▁n ▁- ▁1 ▁, ▁k ▁- ▁mat ▁[ ▁m ▁] ▁[ ▁n ▁] ▁) ▁; ▁return ▁dp ▁[ ▁m ▁] ▁[ ▁n ▁] ▁[ ▁k ▁] ▁; ▁} ▁static ▁int ▁path Count DP ▁( ▁int ▁[ ▁] ▁[ ▁] ▁mat ▁, ▁int ▁k ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁R ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁C ▁; ▁j ▁++ ▁) ▁for ▁( ▁int ▁l ▁= ▁0 ▁; ▁l ▁< ▁MAX _ K ▁; ▁l ▁++ ▁) ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁[ ▁l ▁] ▁= ▁- ▁1 ▁; ▁return ▁path Count DP Rec DP ▁( ▁mat ▁, ▁R ▁- ▁1 ▁, ▁C ▁- ▁1 ▁, ▁k ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁k ▁= ▁12 ▁; ▁int ▁[ ▁] ▁[ ▁] ▁mat ▁= ▁new ▁int ▁[ ▁] ▁[ ▁] ▁{ ▁new ▁int ▁[ ▁] ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁, ▁new ▁int ▁[ ▁] ▁{ ▁4 ▁, ▁6 ▁, ▁5 ▁} ▁, ▁new ▁int ▁[ ▁] ▁{ ▁3 ▁, ▁2 ▁, ▁1 ▁} ▁} ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁path Count DP ▁( ▁mat ▁, ▁k ▁) ▁) ▁; ▁} ▁}
▁class ▁path ▁{ ▁static ▁int ▁x ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁- ▁1 ▁, ▁1 ▁, ▁0 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁} ▁; ▁static ▁int ▁y ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁0 ▁, ▁- ▁1 ▁} ▁; ▁static ▁int ▁R ▁= ▁3 ▁; ▁static ▁int ▁C ▁= ▁3 ▁; ▁static ▁int ▁dp ▁[ ▁] ▁[ ▁] ▁= ▁new ▁int ▁[ ▁R ▁] ▁[ ▁C ▁] ▁; ▁static ▁boolean ▁is valid ▁( ▁int ▁i ▁, ▁int ▁j ▁) ▁{ ▁if ▁( ▁i ▁< ▁0 ▁j ▁< ▁0 ▁i ▁>= ▁R ▁j ▁>= ▁C ▁) ▁return ▁false ▁; ▁return ▁true ▁; ▁} ▁static ▁boolean ▁is ad jacent ▁( ▁char ▁prev ▁, ▁char ▁curr ▁) ▁{ ▁return ▁( ▁( ▁curr ▁- ▁prev ▁) ▁== ▁1 ▁) ▁; ▁} ▁static ▁int ▁getL en Util ▁( ▁char ▁mat ▁[ ▁] ▁[ ▁] ▁, ▁int ▁i ▁, ▁int ▁j ▁, ▁char ▁prev ▁) ▁{ ▁if ▁( ▁! ▁is valid ▁( ▁i ▁, ▁j ▁) ▁|| ▁! ▁is ad jacent ▁( ▁prev ▁, ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁) ▁return ▁0 ▁; ▁if ▁( ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁!= ▁- ▁1 ▁) ▁return ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁k ▁= ▁0 ▁; ▁k ▁< ▁8 ▁; ▁k ▁++ ▁) ▁ans ▁= ▁Math ▁. ▁max ▁( ▁ans ▁, ▁1 ▁+ ▁getL en Util ▁( ▁mat ▁, ▁i ▁+ ▁x ▁[ ▁k ▁] ▁, ▁j ▁+ ▁y ▁[ ▁k ▁] ▁, ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁) ▁; ▁return ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁ans ▁; ▁} ▁static ▁int ▁getL en ▁( ▁char ▁mat ▁[ ▁] ▁[ ▁] ▁, ▁char ▁s ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁R ▁; ▁++ ▁i ▁) ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁C ▁; ▁++ ▁j ▁) ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁- ▁1 ▁; ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁R ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁C ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁== ▁s ▁) ▁{ ▁for ▁( ▁int ▁k ▁= ▁0 ▁; ▁k ▁< ▁8 ▁; ▁k ▁++ ▁) ▁ans ▁= ▁Math ▁. ▁max ▁( ▁ans ▁, ▁1 ▁+ ▁getL en Util ▁( ▁mat ▁, ▁i ▁+ ▁x ▁[ ▁k ▁] ▁, ▁j ▁+ ▁y ▁[ ▁k ▁] ▁, ▁s ▁) ▁) ▁; ▁} ▁} ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁char ▁mat ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁' ▁a ▁' ▁, ▁' ▁c ▁' ▁, ▁' ▁d ▁' ▁} ▁, ▁{ ▁' ▁h ▁' ▁, ▁' ▁b ▁' ▁, ▁' ▁a ▁' ▁} ▁, ▁{ ▁' ▁i ▁' ▁, ▁' ▁g ▁' ▁, ▁' ▁f ▁' ▁} ▁} ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁getL en ▁( ▁mat ▁, ▁' ▁a ▁' ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁getL en ▁( ▁mat ▁, ▁' ▁e ▁' ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁getL en ▁( ▁mat ▁, ▁' ▁b ▁' ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁getL en ▁( ▁mat ▁, ▁' ▁f ▁' ▁) ▁) ▁; ▁} ▁}
▁class ▁Repeat Element ▁{ ▁void ▁print Repe ating ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁size ▁) ▁{ ▁int ▁count ▁[ ▁] ▁= ▁new ▁int ▁[ ▁size ▁] ▁; ▁int ▁i ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Repeated ▁elements ▁are ▁: ▁" ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁count ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁== ▁1 ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁else ▁count ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁++ ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Repeat Element ▁repeat ▁= ▁new ▁Repeat Element ▁( ▁) ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁2 ▁, ▁4 ▁, ▁5 ▁, ▁2 ▁, ▁3 ▁, ▁1 ▁} ▁; ▁int ▁arr _ size ▁= ▁arr ▁. ▁length ▁; ▁repeat ▁. ▁print Repe ating ▁( ▁arr ▁, ▁arr _ size ▁) ▁; ▁} ▁}
▁class ▁Repeat Element ▁{ ▁void ▁print Repe ating ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁size ▁) ▁{ ▁int ▁i ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁The ▁repeating ▁elements ▁are ▁: ▁" ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁Math ▁. ▁abs ▁( ▁arr ▁[ ▁i ▁] ▁) ▁] ▁> ▁0 ▁) ▁arr ▁[ ▁Math ▁. ▁abs ▁( ▁arr ▁[ ▁i ▁] ▁) ▁] ▁= ▁- ▁arr ▁[ ▁Math ▁. ▁abs ▁( ▁arr ▁[ ▁i ▁] ▁) ▁] ▁; ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁Math ▁. ▁abs ▁( ▁arr ▁[ ▁i ▁] ▁) ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Repeat Element ▁repeat ▁= ▁new ▁Repeat Element ▁( ▁) ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁2 ▁, ▁4 ▁, ▁5 ▁, ▁2 ▁, ▁3 ▁, ▁1 ▁} ▁; ▁int ▁arr _ size ▁= ▁arr ▁. ▁length ▁; ▁repeat ▁. ▁print Repe ating ▁( ▁arr ▁, ▁arr _ size ▁) ▁; ▁} ▁}
▁class ▁Main ▁{ ▁static ▁int ▁binarySearch ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁low ▁, ▁int ▁high ▁) ▁{ ▁if ▁( ▁high ▁>= ▁low ▁) ▁{ ▁int ▁mid ▁= ▁( ▁low ▁+ ▁high ▁) ▁/ ▁2 ▁; ▁if ▁( ▁mid ▁== ▁arr ▁[ ▁mid ▁] ▁) ▁return ▁mid ▁; ▁if ▁( ▁mid ▁> ▁arr ▁[ ▁mid ▁] ▁) ▁return ▁binarySearch ▁( ▁arr ▁, ▁( ▁mid ▁+ ▁1 ▁) ▁, ▁high ▁) ▁; ▁else ▁return ▁binarySearch ▁( ▁arr ▁, ▁low ▁, ▁( ▁mid ▁- ▁1 ▁) ▁) ▁; ▁} ▁return ▁- ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁- ▁10 ▁, ▁- ▁1 ▁, ▁0 ▁, ▁3 ▁, ▁10 ▁, ▁11 ▁, ▁30 ▁, ▁50 ▁, ▁100 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Fixed ▁Point ▁is ▁" ▁+ ▁binarySearch ▁( ▁arr ▁, ▁0 ▁, ▁n ▁- ▁1 ▁) ▁) ▁; ▁} ▁}
▁class ▁Sub array Sum ▁{ ▁int ▁sub Array Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁sum ▁) ▁{ ▁int ▁curr _ sum ▁, ▁i ▁, ▁j ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁curr _ sum ▁= ▁arr ▁[ ▁i ▁] ▁; ▁for ▁( ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁<= ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁curr _ sum ▁== ▁sum ▁) ▁{ ▁int ▁p ▁= ▁j ▁- ▁1 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Sum ▁found ▁between ▁indexes ▁" ▁+ ▁i ▁+ ▁" ▁and ▁" ▁+ ▁p ▁) ▁; ▁return ▁1 ▁; ▁} ▁if ▁( ▁curr _ sum ▁> ▁sum ▁j ▁== ▁n ▁) ▁break ▁; ▁curr _ sum ▁= ▁curr _ sum ▁+ ▁arr ▁[ ▁j ▁] ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁sub array ▁found ▁" ▁) ▁; ▁return ▁0 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Sub array Sum ▁array sum ▁= ▁new ▁Sub array Sum ▁( ▁) ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁15 ▁, ▁2 ▁, ▁4 ▁, ▁8 ▁, ▁9 ▁, ▁5 ▁, ▁10 ▁, ▁23 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁int ▁sum ▁= ▁23 ▁; ▁array sum ▁. ▁sub Array Sum ▁( ▁arr ▁, ▁n ▁, ▁sum ▁) ▁; ▁} ▁}
▁public ▁class ▁G F G ▁{ ▁static ▁int ▁min ▁( ▁int ▁x ▁, ▁int ▁y ▁, ▁int ▁z ▁) ▁{ ▁if ▁( ▁x ▁< ▁y ▁) ▁return ▁( ▁x ▁< ▁z ▁) ▁? ▁x ▁: ▁z ▁; ▁else ▁return ▁( ▁y ▁< ▁z ▁) ▁? ▁y ▁: ▁z ▁; ▁} ▁static ▁int ▁min Cost ▁( ▁int ▁cost ▁[ ▁] ▁[ ▁] ▁, ▁int ▁m ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁< ▁0 ▁m ▁< ▁0 ▁) ▁return ▁Integer ▁. ▁MAX _ VALUE ▁; ▁else ▁if ▁( ▁m ▁== ▁0 ▁&& ▁n ▁== ▁0 ▁) ▁return ▁cost ▁[ ▁m ▁] ▁[ ▁n ▁] ▁; ▁else ▁return ▁cost ▁[ ▁m ▁] ▁[ ▁n ▁] ▁+ ▁min ▁( ▁min Cost ▁( ▁cost ▁, ▁m ▁- ▁1 ▁, ▁n ▁- ▁1 ▁) ▁, ▁min Cost ▁( ▁cost ▁, ▁m ▁- ▁1 ▁, ▁n ▁) ▁, ▁min Cost ▁( ▁cost ▁, ▁m ▁, ▁n ▁- ▁1 ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁cost ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁, ▁{ ▁4 ▁, ▁8 ▁, ▁2 ▁} ▁, ▁{ ▁1 ▁, ▁5 ▁, ▁3 ▁} ▁} ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁min Cost ▁( ▁cost ▁, ▁2 ▁, ▁2 ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁Minimum Cost Path ▁{ ▁private ▁static ▁int ▁min Cost ▁( ▁int ▁cost ▁[ ▁] ▁[ ▁] ▁, ▁int ▁m ▁, ▁int ▁n ▁) ▁{ ▁int ▁i ▁, ▁j ▁; ▁int ▁tc ▁[ ▁] ▁[ ▁] ▁= ▁new ▁int ▁[ ▁m ▁+ ▁1 ▁] ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁tc ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁= ▁cost ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁<= ▁m ▁; ▁i ▁++ ▁) ▁tc ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁= ▁tc ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁0 ▁] ▁+ ▁cost ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁; ▁for ▁( ▁j ▁= ▁1 ▁; ▁j ▁<= ▁n ▁; ▁j ▁++ ▁) ▁tc ▁[ ▁0 ▁] ▁[ ▁j ▁] ▁= ▁tc ▁[ ▁0 ▁] ▁[ ▁j ▁- ▁1 ▁] ▁+ ▁cost ▁[ ▁0 ▁] ▁[ ▁j ▁] ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁<= ▁m ▁; ▁i ▁++ ▁) ▁for ▁( ▁j ▁= ▁1 ▁; ▁j ▁<= ▁n ▁; ▁j ▁++ ▁) ▁tc ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁min ▁( ▁tc ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁- ▁1 ▁] ▁, ▁tc ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁, ▁tc ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁) ▁+ ▁cost ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁return ▁tc ▁[ ▁m ▁] ▁[ ▁n ▁] ▁; ▁} ▁private ▁static ▁int ▁min ▁( ▁int ▁x ▁, ▁int ▁y ▁, ▁int ▁z ▁) ▁{ ▁if ▁( ▁x ▁< ▁y ▁) ▁return ▁( ▁x ▁< ▁z ▁) ▁? ▁x ▁: ▁z ▁; ▁else ▁return ▁( ▁y ▁< ▁z ▁) ▁? ▁y ▁: ▁z ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁cost ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁, ▁{ ▁4 ▁, ▁8 ▁, ▁2 ▁} ▁, ▁{ ▁1 ▁, ▁5 ▁, ▁3 ▁} ▁} ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁min Cost ▁( ▁cost ▁, ▁2 ▁, ▁2 ▁) ▁) ▁; ▁} ▁}
▁class ▁Matrix Chain Multip lication ▁{ ▁static ▁int ▁Matrix Chain Order ▁( ▁int ▁p ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁m ▁[ ▁] ▁[ ▁] ▁= ▁new ▁int ▁[ ▁n ▁] ▁[ ▁n ▁] ▁; ▁int ▁i ▁, ▁j ▁, ▁k ▁, ▁L ▁, ▁q ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁m ▁[ ▁i ▁] ▁[ ▁i ▁] ▁= ▁0 ▁; ▁for ▁( ▁L ▁= ▁2 ▁; ▁L ▁< ▁n ▁; ▁L ▁++ ▁) ▁{ ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁- ▁L ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁j ▁= ▁i ▁+ ▁L ▁- ▁1 ▁; ▁if ▁( ▁j ▁== ▁n ▁) ▁continue ▁; ▁m ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁for ▁( ▁k ▁= ▁i ▁; ▁k ▁<= ▁j ▁- ▁1 ▁; ▁k ▁++ ▁) ▁{ ▁q ▁= ▁m ▁[ ▁i ▁] ▁[ ▁k ▁] ▁+ ▁m ▁[ ▁k ▁+ ▁1 ▁] ▁[ ▁j ▁] ▁+ ▁p ▁[ ▁i ▁- ▁1 ▁] ▁* ▁p ▁[ ▁k ▁] ▁* ▁p ▁[ ▁j ▁] ▁; ▁if ▁( ▁q ▁< ▁m ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁m ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁q ▁; ▁} ▁} ▁} ▁return ▁m ▁[ ▁1 ▁] ▁[ ▁n ▁- ▁1 ▁] ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁new ▁int ▁[ ▁] ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁size ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Minimum ▁number ▁of ▁multiplication s ▁is ▁" ▁+ ▁Matrix Chain Order ▁( ▁arr ▁, ▁size ▁) ▁) ▁; ▁} ▁}
▁class ▁K n aps ack ▁{ ▁static ▁int ▁max ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁return ▁( ▁a ▁> ▁b ▁) ▁? ▁a ▁: ▁b ▁; ▁} ▁static ▁int ▁kn ap S ack ▁( ▁int ▁W ▁, ▁int ▁wt ▁[ ▁] ▁, ▁int ▁val ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁0 ▁W ▁== ▁0 ▁) ▁return ▁0 ▁; ▁if ▁( ▁wt ▁[ ▁n ▁- ▁1 ▁] ▁> ▁W ▁) ▁return ▁kn ap S ack ▁( ▁W ▁, ▁wt ▁, ▁val ▁, ▁n ▁- ▁1 ▁) ▁; ▁else ▁return ▁max ▁( ▁val ▁[ ▁n ▁- ▁1 ▁] ▁+ ▁kn ap S ack ▁( ▁W ▁- ▁wt ▁[ ▁n ▁- ▁1 ▁] ▁, ▁wt ▁, ▁val ▁, ▁n ▁- ▁1 ▁) ▁, ▁kn ap S ack ▁( ▁W ▁, ▁wt ▁, ▁val ▁, ▁n ▁- ▁1 ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁val ▁[ ▁] ▁= ▁new ▁int ▁[ ▁] ▁{ ▁60 ▁, ▁100 ▁, ▁120 ▁} ▁; ▁int ▁wt ▁[ ▁] ▁= ▁new ▁int ▁[ ▁] ▁{ ▁10 ▁, ▁20 ▁, ▁30 ▁} ▁; ▁int ▁W ▁= ▁50 ▁; ▁int ▁n ▁= ▁val ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁kn ap S ack ▁( ▁W ▁, ▁wt ▁, ▁val ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁K n aps ack ▁{ ▁static ▁int ▁max ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁return ▁( ▁a ▁> ▁b ▁) ▁? ▁a ▁: ▁b ▁; ▁} ▁static ▁int ▁kn ap S ack ▁( ▁int ▁W ▁, ▁int ▁wt ▁[ ▁] ▁, ▁int ▁val ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁i ▁, ▁w ▁; ▁int ▁K ▁[ ▁] ▁[ ▁] ▁= ▁new ▁int ▁[ ▁n ▁+ ▁1 ▁] ▁[ ▁W ▁+ ▁1 ▁] ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁w ▁= ▁0 ▁; ▁w ▁<= ▁W ▁; ▁w ▁++ ▁) ▁{ ▁if ▁( ▁i ▁== ▁0 ▁w ▁== ▁0 ▁) ▁K ▁[ ▁i ▁] ▁[ ▁w ▁] ▁= ▁0 ▁; ▁else ▁if ▁( ▁wt ▁[ ▁i ▁- ▁1 ▁] ▁<= ▁w ▁) ▁K ▁[ ▁i ▁] ▁[ ▁w ▁] ▁= ▁max ▁( ▁val ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁K ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁w ▁- ▁wt ▁[ ▁i ▁- ▁1 ▁] ▁] ▁, ▁K ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁w ▁] ▁) ▁; ▁else ▁K ▁[ ▁i ▁] ▁[ ▁w ▁] ▁= ▁K ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁w ▁] ▁; ▁} ▁} ▁return ▁K ▁[ ▁n ▁] ▁[ ▁W ▁] ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁val ▁[ ▁] ▁= ▁new ▁int ▁[ ▁] ▁{ ▁60 ▁, ▁100 ▁, ▁120 ▁} ▁; ▁int ▁wt ▁[ ▁] ▁= ▁new ▁int ▁[ ▁] ▁{ ▁10 ▁, ▁20 ▁, ▁30 ▁} ▁; ▁int ▁W ▁= ▁50 ▁; ▁int ▁n ▁= ▁val ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁kn ap S ack ▁( ▁W ▁, ▁wt ▁, ▁val ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁max ▁( ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁return ▁( ▁x ▁> ▁y ▁) ▁? ▁x ▁: ▁y ▁; ▁} ▁static ▁int ▁l ps ▁( ▁char ▁seq ▁[ ▁] ▁, ▁int ▁i ▁, ▁int ▁j ▁) ▁{ ▁if ▁( ▁i ▁== ▁j ▁) ▁{ ▁return ▁1 ▁; ▁} ▁if ▁( ▁seq ▁[ ▁i ▁] ▁== ▁seq ▁[ ▁j ▁] ▁&& ▁i ▁+ ▁1 ▁== ▁j ▁) ▁{ ▁return ▁2 ▁; ▁} ▁if ▁( ▁seq ▁[ ▁i ▁] ▁== ▁seq ▁[ ▁j ▁] ▁) ▁{ ▁return ▁l ps ▁( ▁seq ▁, ▁i ▁+ ▁1 ▁, ▁j ▁- ▁1 ▁) ▁+ ▁2 ▁; ▁} ▁return ▁max ▁( ▁l ps ▁( ▁seq ▁, ▁i ▁, ▁j ▁- ▁1 ▁) ▁, ▁l ps ▁( ▁seq ▁, ▁i ▁+ ▁1 ▁, ▁j ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁seq ▁= ▁" ▁G EEK S FOR GE EK S ▁" ▁; ▁int ▁n ▁= ▁seq ▁. ▁length ▁( ▁) ▁; ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁The ▁length ▁of ▁the ▁L PS ▁is ▁% ▁d ▁" ▁, ▁l ps ▁( ▁seq ▁. ▁toCharArray ▁( ▁) ▁, ▁0 ▁, ▁n ▁- ▁1 ▁) ▁) ▁; ▁} ▁}
▁class ▁R od Cut ting ▁{ ▁static ▁int ▁cut R od ▁( ▁int ▁price ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁val ▁[ ▁] ▁= ▁new ▁int ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁val ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁max _ val ▁= ▁Integer ▁. ▁MIN _ VALUE ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁i ▁; ▁j ▁++ ▁) ▁max _ val ▁= ▁Math ▁. ▁max ▁( ▁max _ val ▁, ▁price ▁[ ▁j ▁] ▁+ ▁val ▁[ ▁i ▁- ▁j ▁- ▁1 ▁] ▁) ▁; ▁val ▁[ ▁i ▁] ▁= ▁max _ val ▁; ▁} ▁return ▁val ▁[ ▁n ▁] ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁new ▁int ▁[ ▁] ▁{ ▁1 ▁, ▁5 ▁, ▁8 ▁, ▁9 ▁, ▁10 ▁, ▁17 ▁, ▁17 ▁, ▁20 ▁} ▁; ▁int ▁size ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Maximum ▁Ob tain able ▁Value ▁is ▁" ▁+ ▁cut R od ▁( ▁arr ▁, ▁size ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁count ▁( ▁int ▁n ▁) ▁{ ▁int ▁table ▁[ ▁] ▁= ▁new ▁int ▁[ ▁n ▁+ ▁1 ▁] ▁, ▁i ▁; ▁Arrays ▁. ▁fill ▁( ▁table ▁, ▁0 ▁) ▁; ▁table ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁for ▁( ▁i ▁= ▁3 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁table ▁[ ▁i ▁] ▁+= ▁table ▁[ ▁i ▁- ▁3 ▁] ▁; ▁for ▁( ▁i ▁= ▁5 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁table ▁[ ▁i ▁] ▁+= ▁table ▁[ ▁i ▁- ▁5 ▁] ▁; ▁for ▁( ▁i ▁= ▁10 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁table ▁[ ▁i ▁] ▁+= ▁table ▁[ ▁i ▁- ▁10 ▁] ▁; ▁return ▁table ▁[ ▁n ▁] ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁20 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Count ▁for ▁" ▁+ ▁n ▁+ ▁" ▁is ▁" ▁+ ▁count ▁( ▁n ▁) ▁) ▁; ▁n ▁= ▁13 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Count ▁for ▁" ▁+ ▁n ▁+ ▁" ▁is ▁" ▁+ ▁count ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁Na ive Search ▁{ ▁public ▁static ▁void ▁search ▁( ▁String ▁txt ▁, ▁String ▁pat ▁) ▁{ ▁int ▁M ▁= ▁pat ▁. ▁length ▁( ▁) ▁; ▁int ▁N ▁= ▁txt ▁. ▁length ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁N ▁- ▁M ▁; ▁i ▁++ ▁) ▁{ ▁int ▁j ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁M ▁; ▁j ▁++ ▁) ▁if ▁( ▁txt ▁. ▁charAt ▁( ▁i ▁+ ▁j ▁) ▁!= ▁pat ▁. ▁charAt ▁( ▁j ▁) ▁) ▁break ▁; ▁if ▁( ▁j ▁== ▁M ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Pattern ▁found ▁at ▁index ▁" ▁+ ▁i ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁txt ▁= ▁" ▁A AB A AC A AD A AB AA AB AA ▁" ▁; ▁String ▁pat ▁= ▁" ▁A AB A ▁" ▁; ▁search ▁( ▁txt ▁, ▁pat ▁) ▁; ▁} ▁}
▁public ▁class ▁Main ▁{ ▁public ▁final ▁static ▁int ▁d ▁= ▁256 ▁; ▁static ▁void ▁search ▁( ▁String ▁pat ▁, ▁String ▁txt ▁, ▁int ▁q ▁) ▁{ ▁int ▁M ▁= ▁pat ▁. ▁length ▁( ▁) ▁; ▁int ▁N ▁= ▁txt ▁. ▁length ▁( ▁) ▁; ▁int ▁i ▁, ▁j ▁; ▁int ▁p ▁= ▁0 ▁; ▁int ▁t ▁= ▁0 ▁; ▁int ▁h ▁= ▁1 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁M ▁- ▁1 ▁; ▁i ▁++ ▁) ▁h ▁= ▁( ▁h ▁* ▁d ▁) ▁% ▁q ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁M ▁; ▁i ▁++ ▁) ▁{ ▁p ▁= ▁( ▁d ▁* ▁p ▁+ ▁pat ▁. ▁charAt ▁( ▁i ▁) ▁) ▁% ▁q ▁; ▁t ▁= ▁( ▁d ▁* ▁t ▁+ ▁txt ▁. ▁charAt ▁( ▁i ▁) ▁) ▁% ▁q ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁<= ▁N ▁- ▁M ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁p ▁== ▁t ▁) ▁{ ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁M ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁txt ▁. ▁charAt ▁( ▁i ▁+ ▁j ▁) ▁!= ▁pat ▁. ▁charAt ▁( ▁j ▁) ▁) ▁break ▁; ▁} ▁if ▁( ▁j ▁== ▁M ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Pattern ▁found ▁at ▁index ▁" ▁+ ▁i ▁) ▁; ▁} ▁if ▁( ▁i ▁< ▁N ▁- ▁M ▁) ▁{ ▁t ▁= ▁( ▁d ▁* ▁( ▁t ▁- ▁txt ▁. ▁charAt ▁( ▁i ▁) ▁* ▁h ▁) ▁+ ▁txt ▁. ▁charAt ▁( ▁i ▁+ ▁M ▁) ▁) ▁% ▁q ▁; ▁if ▁( ▁t ▁< ▁0 ▁) ▁t ▁= ▁( ▁t ▁+ ▁q ▁) ▁; ▁} ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁txt ▁= ▁" ▁G EEK S ▁FOR ▁G EEK S ▁" ▁; ▁String ▁pat ▁= ▁" ▁G EEK ▁" ▁; ▁int ▁q ▁= ▁101 ▁; ▁search ▁( ▁pat ▁, ▁txt ▁, ▁q ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁power ▁( ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁if ▁( ▁y ▁== ▁0 ▁) ▁return ▁1 ▁; ▁else ▁if ▁( ▁y ▁% ▁2 ▁== ▁0 ▁) ▁return ▁power ▁( ▁x ▁, ▁y ▁/ ▁2 ▁) ▁* ▁power ▁( ▁x ▁, ▁y ▁/ ▁2 ▁) ▁; ▁else ▁return ▁x ▁* ▁power ▁( ▁x ▁, ▁y ▁/ ▁2 ▁) ▁* ▁power ▁( ▁x ▁, ▁y ▁/ ▁2 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁x ▁= ▁2 ▁; ▁int ▁y ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁% ▁d ▁" ▁, ▁power ▁( ▁x ▁, ▁y ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁double ▁area ▁( ▁int ▁x 1 ▁, ▁int ▁y 1 ▁, ▁int ▁x 2 ▁, ▁int ▁y 2 ▁, ▁int ▁x 3 ▁, ▁int ▁y 3 ▁) ▁{ ▁return ▁Math ▁. ▁abs ▁( ▁( ▁x 1 ▁* ▁( ▁y 2 ▁- ▁y 3 ▁) ▁+ ▁x 2 ▁* ▁( ▁y 3 ▁- ▁y 1 ▁) ▁+ ▁x 3 ▁* ▁( ▁y 1 ▁- ▁y 2 ▁) ▁) ▁/ ▁2.0 ▁) ▁; ▁} ▁static ▁boolean ▁isIn side ▁( ▁int ▁x 1 ▁, ▁int ▁y 1 ▁, ▁int ▁x 2 ▁, ▁int ▁y 2 ▁, ▁int ▁x 3 ▁, ▁int ▁y 3 ▁, ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁double ▁A ▁= ▁area ▁( ▁x 1 ▁, ▁y 1 ▁, ▁x 2 ▁, ▁y 2 ▁, ▁x 3 ▁, ▁y 3 ▁) ▁; ▁double ▁A 1 ▁= ▁area ▁( ▁x ▁, ▁y ▁, ▁x 2 ▁, ▁y 2 ▁, ▁x 3 ▁, ▁y 3 ▁) ▁; ▁double ▁A 2 ▁= ▁area ▁( ▁x 1 ▁, ▁y 1 ▁, ▁x ▁, ▁y ▁, ▁x 3 ▁, ▁y 3 ▁) ▁; ▁double ▁A 3 ▁= ▁area ▁( ▁x 1 ▁, ▁y 1 ▁, ▁x 2 ▁, ▁y 2 ▁, ▁x ▁, ▁y ▁) ▁; ▁return ▁( ▁A ▁== ▁A 1 ▁+ ▁A 2 ▁+ ▁A 3 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁if ▁( ▁isIn side ▁( ▁0 ▁, ▁0 ▁, ▁20 ▁, ▁0 ▁, ▁10 ▁, ▁30 ▁, ▁10 ▁, ▁15 ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Inside ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Not ▁Inside ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁int ▁counter ▁= ▁2 ▁; ▁static ▁boolean ▁is L uck y ▁( ▁int ▁n ▁) ▁{ ▁int ▁next _ position ▁= ▁n ▁; ▁if ▁( ▁counter ▁> ▁n ▁) ▁return ▁true ▁; ▁if ▁( ▁n ▁% ▁counter ▁== ▁0 ▁) ▁return ▁false ▁; ▁next _ position ▁-= ▁next _ position ▁/ ▁counter ▁; ▁counter ▁++ ▁; ▁return ▁is L uck y ▁( ▁next _ position ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁x ▁= ▁5 ▁; ▁if ▁( ▁is L uck y ▁( ▁x ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁x ▁+ ▁" ▁is ▁a ▁luck y ▁no ▁. ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁x ▁+ ▁" ▁is ▁not ▁a ▁luck y ▁no ▁. ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁fact ▁( ▁int ▁n ▁) ▁{ ▁return ▁( ▁n ▁<= ▁1 ▁) ▁? ▁1 ▁: ▁n ▁* ▁fact ▁( ▁n ▁- ▁1 ▁) ▁; ▁} ▁static ▁int ▁find Small er In Right ▁( ▁String ▁str ▁, ▁int ▁low ▁, ▁int ▁high ▁) ▁{ ▁int ▁count Right ▁= ▁0 ▁, ▁i ▁; ▁for ▁( ▁i ▁= ▁low ▁+ ▁1 ▁; ▁i ▁<= ▁high ▁; ▁++ ▁i ▁) ▁if ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁< ▁str ▁. ▁charAt ▁( ▁low ▁) ▁) ▁++ ▁count Right ▁; ▁return ▁count Right ▁; ▁} ▁static ▁int ▁find Rank ▁( ▁String ▁str ▁) ▁{ ▁int ▁len ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁int ▁mul ▁= ▁fact ▁( ▁len ▁) ▁; ▁int ▁rank ▁= ▁1 ▁; ▁int ▁count Right ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁len ▁; ▁++ ▁i ▁) ▁{ ▁mul ▁/= ▁len ▁- ▁i ▁; ▁count Right ▁= ▁find Small er In Right ▁( ▁str ▁, ▁i ▁, ▁len ▁- ▁1 ▁) ▁; ▁rank ▁+= ▁count Right ▁* ▁mul ▁; ▁} ▁return ▁rank ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁" ▁string ▁" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Rank ▁( ▁str ▁) ▁) ▁; ▁} ▁}
▁class ▁Bin omial Co efficient ▁{ ▁static ▁int ▁bin omial Co eff ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁res ▁= ▁1 ▁; ▁if ▁( ▁k ▁> ▁n ▁- ▁k ▁) ▁k ▁= ▁n ▁- ▁k ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁k ▁; ▁++ ▁i ▁) ▁{ ▁res ▁*= ▁( ▁n ▁- ▁i ▁) ▁; ▁res ▁/= ▁( ▁i ▁+ ▁1 ▁) ▁; ▁} ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁8 ▁; ▁int ▁k ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Value ▁of ▁C ▁( ▁" ▁+ ▁n ▁+ ▁" ▁, ▁" ▁+ ▁k ▁+ ▁" ▁) ▁" ▁+ ▁" ▁is ▁" ▁+ ▁" ▁" ▁+ ▁bin omial Co eff ▁( ▁n ▁, ▁k ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁void ▁print P as cal ▁( ▁int ▁n ▁) ▁{ ▁int ▁[ ▁] ▁[ ▁] ▁arr ▁= ▁new ▁int ▁[ ▁n ▁] ▁[ ▁n ▁] ▁; ▁for ▁( ▁int ▁line ▁= ▁0 ▁; ▁line ▁< ▁n ▁; ▁line ▁++ ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁line ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁line ▁== ▁i ▁i ▁== ▁0 ▁) ▁arr ▁[ ▁line ▁] ▁[ ▁i ▁] ▁= ▁1 ▁; ▁else ▁arr ▁[ ▁line ▁] ▁[ ▁i ▁] ▁= ▁arr ▁[ ▁line ▁- ▁1 ▁] ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁arr ▁[ ▁line ▁- ▁1 ▁] ▁[ ▁i ▁] ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁line ▁] ▁[ ▁i ▁] ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁" ▁) ▁; ▁} ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁5 ▁; ▁print P as cal ▁( ▁n ▁) ▁; ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁float ▁exponential ▁( ▁int ▁n ▁, ▁float ▁x ▁) ▁{ ▁float ▁sum ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁> ▁0 ▁; ▁-- ▁i ▁) ▁sum ▁= ▁1 ▁+ ▁x ▁* ▁sum ▁/ ▁i ▁; ▁return ▁sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁10 ▁; ▁float ▁x ▁= ▁1 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁e ▁^ ▁x ▁= ▁" ▁+ ▁exponential ▁( ▁n ▁, ▁x ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁Math ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁void ▁prime Fact ors ▁( ▁int ▁n ▁) ▁{ ▁while ▁( ▁n ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁2 ▁+ ▁" ▁" ▁) ▁; ▁n ▁/= ▁2 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁3 ▁; ▁i ▁<= ▁Math ▁. ▁sqrt ▁( ▁n ▁) ▁; ▁i ▁+= ▁2 ▁) ▁{ ▁while ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁i ▁+ ▁" ▁" ▁) ▁; ▁n ▁/= ▁i ▁; ▁} ▁} ▁if ▁( ▁n ▁> ▁2 ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁n ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁3 15 ▁; ▁prime Fact ors ▁( ▁n ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁Comb ination ▁{ ▁static ▁void ▁print Comb ination ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁r ▁) ▁{ ▁int ▁data ▁[ ▁] ▁= ▁new ▁int ▁[ ▁r ▁] ▁; ▁combination Util ▁( ▁arr ▁, ▁n ▁, ▁r ▁, ▁0 ▁, ▁data ▁, ▁0 ▁) ▁; ▁} ▁static ▁void ▁combination Util ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁r ▁, ▁int ▁index ▁, ▁int ▁data ▁[ ▁] ▁, ▁int ▁i ▁) ▁{ ▁if ▁( ▁index ▁== ▁r ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁r ▁; ▁j ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁data ▁[ ▁j ▁] ▁+ ▁" ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁" ▁) ▁; ▁return ▁; ▁} ▁if ▁( ▁i ▁>= ▁n ▁) ▁return ▁; ▁data ▁[ ▁index ▁] ▁= ▁arr ▁[ ▁i ▁] ▁; ▁combination Util ▁( ▁arr ▁, ▁n ▁, ▁r ▁, ▁index ▁+ ▁1 ▁, ▁data ▁, ▁i ▁+ ▁1 ▁) ▁; ▁combination Util ▁( ▁arr ▁, ▁n ▁, ▁r ▁, ▁index ▁, ▁data ▁, ▁i ▁+ ▁1 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁r ▁= ▁3 ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁print Comb ination ▁( ▁arr ▁, ▁n ▁, ▁r ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁getSingle ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁ones ▁= ▁0 ▁, ▁tw os ▁= ▁0 ▁; ▁int ▁common _ bit _ mask ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁tw os ▁= ▁tw os ▁| ▁( ▁ones ▁& ▁arr ▁[ ▁i ▁] ▁) ▁; ▁ones ▁= ▁ones ▁^ ▁arr ▁[ ▁i ▁] ▁; ▁common _ bit _ mask ▁= ▁~ ▁( ▁ones ▁& ▁tw os ▁) ▁; ▁ones ▁&= ▁common _ bit _ mask ▁; ▁tw os ▁&= ▁common _ bit _ mask ▁; ▁} ▁return ▁ones ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁3 ▁, ▁2 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁The ▁element ▁with ▁single ▁occurrence ▁is ▁" ▁+ ▁getSingle ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁final ▁int ▁INT _ SIZE ▁= ▁32 ▁; ▁static ▁int ▁getSingle ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁result ▁= ▁0 ▁; ▁int ▁x ▁, ▁sum ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁INT _ SIZE ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁= ▁0 ▁; ▁x ▁= ▁( ▁1 ▁<< ▁i ▁) ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁( ▁arr ▁[ ▁j ▁] ▁& ▁x ▁) ▁== ▁0 ▁) ▁sum ▁++ ▁; ▁} ▁if ▁( ▁( ▁sum ▁% ▁3 ▁) ▁!= ▁0 ▁) ▁result ▁|= ▁x ▁; ▁} ▁return ▁result ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁12 ▁, ▁1 ▁, ▁12 ▁, ▁3 ▁, ▁12 ▁, ▁1 ▁, ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁2 ▁, ▁2 ▁, ▁3 ▁, ▁7 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁The ▁element ▁with ▁single ▁occurrence ▁is ▁" ▁+ ▁getSingle ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁G F G ▁{ ▁static ▁int ▁count Set Bits ▁( ▁int ▁n ▁) ▁{ ▁int ▁i ▁= ▁0 ▁; ▁int ▁ans ▁= ▁0 ▁; ▁while ▁( ▁( ▁1 ▁<< ▁i ▁) ▁<= ▁n ▁) ▁{ ▁boolean ▁k ▁= ▁false ▁; ▁int ▁change ▁= ▁1 ▁<< ▁i ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁<= ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁k ▁== ▁true ▁) ▁ans ▁+= ▁1 ▁; ▁else ▁ans ▁+= ▁0 ▁; ▁if ▁( ▁change ▁== ▁1 ▁) ▁{ ▁k ▁= ▁! ▁k ▁; ▁change ▁= ▁1 ▁<< ▁i ▁; ▁} ▁else ▁{ ▁change ▁-- ▁; ▁} ▁} ▁i ▁++ ▁; ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁17 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Set Bits ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁Add ▁( ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁while ▁( ▁y ▁!= ▁0 ▁) ▁{ ▁int ▁carry ▁= ▁x ▁& ▁y ▁; ▁x ▁= ▁x ▁^ ▁y ▁; ▁y ▁= ▁carry ▁<< ▁1 ▁; ▁} ▁return ▁x ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁arg ▁[ ▁] ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁Add ▁( ▁15 ▁, ▁32 ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁smallest ▁( ▁int ▁x ▁, ▁int ▁y ▁, ▁int ▁z ▁) ▁{ ▁int ▁c ▁= ▁0 ▁; ▁while ▁( ▁x ▁!= ▁0 ▁&& ▁y ▁!= ▁0 ▁&& ▁z ▁!= ▁0 ▁) ▁{ ▁x ▁-- ▁; ▁y ▁-- ▁; ▁z ▁-- ▁; ▁c ▁++ ▁; ▁} ▁return ▁c ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁x ▁= ▁12 ▁, ▁y ▁= ▁15 ▁, ▁z ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁Minimum ▁of ▁3" ▁+ ▁" ▁numbers ▁is ▁% ▁d ▁" ▁, ▁smallest ▁( ▁x ▁, ▁y ▁, ▁z ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁add One ▁( ▁int ▁x ▁) ▁{ ▁int ▁m ▁= ▁1 ▁; ▁while ▁( ▁( ▁int ▁) ▁( ▁x ▁& ▁m ▁) ▁>= ▁1 ▁) ▁{ ▁x ▁= ▁x ▁^ ▁m ▁; ▁m ▁<<= ▁1 ▁; ▁} ▁x ▁= ▁x ▁^ ▁m ▁; ▁return ▁x ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁add One ▁( ▁13 ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁add One ▁( ▁int ▁x ▁) ▁{ ▁return ▁( ▁- ▁( ▁~ ▁x ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁% ▁d ▁" ▁, ▁add One ▁( ▁13 ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁is Power Of Four ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁0 ▁) ▁return ▁0 ▁; ▁while ▁( ▁n ▁!= ▁1 ▁) ▁{ ▁if ▁( ▁n ▁% ▁4 ▁!= ▁0 ▁) ▁return ▁0 ▁; ▁n ▁= ▁n ▁/ ▁4 ▁; ▁} ▁return ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁test _ no ▁= ▁64 ▁; ▁if ▁( ▁is Power Of Four ▁( ▁test _ no ▁) ▁== ▁1 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁test _ no ▁+ ▁" ▁is ▁a ▁power ▁of ▁4" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁test _ no ▁+ ▁" ▁is ▁not ▁a ▁power ▁of ▁4" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁int ▁abs bit 32 ▁( ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁int ▁sub ▁= ▁x ▁- ▁y ▁; ▁int ▁mask ▁= ▁( ▁sub ▁>> ▁31 ▁) ▁; ▁return ▁( ▁sub ▁^ ▁mask ▁) ▁- ▁mask ▁; ▁} ▁public ▁static ▁int ▁max ▁( ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁int ▁abs ▁= ▁abs bit 32 ▁( ▁x ▁, ▁y ▁) ▁; ▁return ▁( ▁x ▁+ ▁y ▁+ ▁abs ▁) ▁/ ▁2 ▁; ▁} ▁public ▁static ▁int ▁min ▁( ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁int ▁abs ▁= ▁abs bit 32 ▁( ▁x ▁, ▁y ▁) ▁; ▁return ▁( ▁x ▁+ ▁y ▁- ▁abs ▁) ▁/ ▁2 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁max ▁( ▁2 ▁, ▁3 ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁max ▁( ▁2 ▁, ▁- ▁3 ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁max ▁( ▁- ▁2 ▁, ▁- ▁3 ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁min ▁( ▁2 ▁, ▁3 ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁min ▁( ▁2 ▁, ▁- ▁3 ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁min ▁( ▁- ▁2 ▁, ▁- ▁3 ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁count Set Bits ▁{ ▁static ▁int ▁count Set Bits ▁( ▁int ▁n ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁while ▁( ▁n ▁> ▁0 ▁) ▁{ ▁count ▁+= ▁n ▁& ▁1 ▁; ▁n ▁>>= ▁1 ▁; ▁} ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁i ▁= ▁9 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Set Bits ▁( ▁i ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁[ ▁] ▁Bits Set Table 256 ▁= ▁new ▁int ▁[ ▁256 ▁] ▁; ▁public ▁static ▁void ▁initialize ▁( ▁) ▁{ ▁Bits Set Table 256 ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁256 ▁; ▁i ▁++ ▁) ▁{ ▁Bits Set Table 256 ▁[ ▁i ▁] ▁= ▁( ▁i ▁& ▁1 ▁) ▁+ ▁Bits Set Table 256 ▁[ ▁i ▁/ ▁2 ▁] ▁; ▁} ▁} ▁public ▁static ▁int ▁count Set Bits ▁( ▁int ▁n ▁) ▁{ ▁return ▁( ▁Bits Set Table 256 ▁[ ▁n ▁& ▁0 xff ▁] ▁+ ▁Bits Set Table 256 ▁[ ▁( ▁n ▁>> ▁8 ▁) ▁& ▁0 xff ▁] ▁+ ▁Bits Set Table 256 ▁[ ▁( ▁n ▁>> ▁16 ▁) ▁& ▁0 xff ▁] ▁+ ▁Bits Set Table 256 ▁[ ▁n ▁>> ▁24 ▁] ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁initialize ▁( ▁) ▁; ▁int ▁n ▁= ▁9 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁count Set Bits ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁next Power Of 2 ▁( ▁int ▁n ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁if ▁( ▁n ▁> ▁0 ▁&& ▁( ▁n ▁& ▁( ▁n ▁- ▁1 ▁) ▁) ▁== ▁0 ▁) ▁return ▁n ▁; ▁while ▁( ▁n ▁!= ▁0 ▁) ▁{ ▁n ▁>>= ▁1 ▁; ▁count ▁+= ▁1 ▁; ▁} ▁return ▁1 ▁<< ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁0 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁next Power Of 2 ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁next Power Of 2 ▁( ▁int ▁n ▁) ▁{ ▁int ▁p ▁= ▁1 ▁; ▁if ▁( ▁n ▁> ▁0 ▁&& ▁( ▁n ▁& ▁( ▁n ▁- ▁1 ▁) ▁) ▁== ▁0 ▁) ▁return ▁n ▁; ▁while ▁( ▁p ▁< ▁n ▁) ▁p ▁<<= ▁1 ▁; ▁return ▁p ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁next Power Of 2 ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁math ▁. ▁BigInteger ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁get Par ity ▁( ▁int ▁n ▁) ▁{ ▁boolean ▁par ity ▁= ▁false ▁; ▁while ▁( ▁n ▁!= ▁0 ▁) ▁{ ▁par ity ▁= ▁! ▁par ity ▁; ▁n ▁= ▁n ▁& ▁( ▁n ▁- ▁1 ▁) ▁; ▁} ▁return ▁par ity ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁12 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Par ity ▁of ▁no ▁" ▁+ ▁n ▁+ ▁" ▁= ▁" ▁+ ▁( ▁get Par ity ▁( ▁n ▁) ▁? ▁" ▁odd ▁" ▁: ▁" ▁even ▁" ▁) ▁) ▁; ▁} ▁}
▁class ▁Test ▁{ ▁static ▁boolean ▁is Power Of Two ▁( ▁int ▁x ▁) ▁{ ▁return ▁x ▁!= ▁0 ▁&& ▁( ▁( ▁x ▁& ▁( ▁x ▁- ▁1 ▁) ▁) ▁== ▁0 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁is Power Of Two ▁( ▁31 ▁) ▁? ▁" ▁Yes ▁" ▁: ▁" ▁No ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁is Power Of Two ▁( ▁64 ▁) ▁? ▁" ▁Yes ▁" ▁: ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁int ▁Last _ set _ bit ▁( ▁int ▁n ▁) ▁{ ▁int ▁p ▁= ▁1 ▁; ▁while ▁( ▁n ▁> ▁0 ▁) ▁{ ▁if ▁( ▁( ▁n ▁& ▁1 ▁) ▁> ▁0 ▁) ▁{ ▁return ▁p ▁; ▁} ▁p ▁++ ▁; ▁n ▁= ▁n ▁>> ▁1 ▁; ▁} ▁return ▁- ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁18 ▁; ▁int ▁pos ▁= ▁Last _ set _ bit ▁( ▁n ▁) ▁; ▁if ▁( ▁pos ▁!= ▁- ▁1 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁pos ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁"0" ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁boolean ▁is Power Of Two ▁( ▁int ▁n ▁) ▁{ ▁return ▁( ▁n ▁> ▁0 ▁&& ▁( ▁( ▁n ▁& ▁( ▁n ▁- ▁1 ▁) ▁) ▁== ▁0 ▁) ▁) ▁? ▁true ▁: ▁false ▁; ▁} ▁static ▁int ▁find Position ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁! ▁is Power Of Two ▁( ▁n ▁) ▁) ▁return ▁- ▁1 ▁; ▁int ▁i ▁= ▁1 ▁, ▁pos ▁= ▁1 ▁; ▁while ▁( ▁( ▁i ▁& ▁n ▁) ▁== ▁0 ▁) ▁{ ▁i ▁= ▁i ▁<< ▁1 ▁; ▁++ ▁pos ▁; ▁} ▁return ▁pos ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁16 ▁; ▁int ▁pos ▁= ▁find Position ▁( ▁n ▁) ▁; ▁if ▁( ▁pos ▁== ▁- ▁1 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁n ▁= ▁" ▁+ ▁n ▁+ ▁" ▁, ▁Invalid ▁number ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁n ▁= ▁" ▁+ ▁n ▁+ ▁" ▁, ▁Position ▁" ▁+ ▁pos ▁) ▁; ▁n ▁= ▁12 ▁; ▁pos ▁= ▁find Position ▁( ▁n ▁) ▁; ▁if ▁( ▁pos ▁== ▁- ▁1 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁n ▁= ▁" ▁+ ▁n ▁+ ▁" ▁, ▁Invalid ▁number ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁n ▁= ▁" ▁+ ▁n ▁+ ▁" ▁, ▁Position ▁" ▁+ ▁pos ▁) ▁; ▁n ▁= ▁128 ▁; ▁pos ▁= ▁find Position ▁( ▁n ▁) ▁; ▁if ▁( ▁pos ▁== ▁- ▁1 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁n ▁= ▁" ▁+ ▁n ▁+ ▁" ▁, ▁Invalid ▁number ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁n ▁= ▁" ▁+ ▁n ▁+ ▁" ▁, ▁Position ▁" ▁+ ▁pos ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁x ▁= ▁10 ▁; ▁int ▁y ▁= ▁5 ▁; ▁x ▁= ▁x ▁* ▁y ▁; ▁y ▁= ▁x ▁/ ▁y ▁; ▁x ▁= ▁x ▁/ ▁y ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁After ▁swap ing ▁: ▁" ▁+ ▁" ▁x ▁= ▁" ▁+ ▁x ▁+ ▁" ▁, ▁y ▁= ▁" ▁+ ▁y ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁public ▁class ▁G F G ▁{ ▁public ▁static ▁void ▁main ▁( ▁String ▁a ▁[ ▁] ▁) ▁{ ▁int ▁x ▁= ▁10 ▁; ▁int ▁y ▁= ▁5 ▁; ▁x ▁= ▁x ▁^ ▁y ▁; ▁y ▁= ▁x ▁^ ▁y ▁; ▁x ▁= ▁x ▁^ ▁y ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁After ▁swap ▁: ▁x ▁= ▁" ▁+ ▁x ▁+ ▁" ▁, ▁y ▁= ▁" ▁+ ▁y ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁swap ▁( ▁int ▁[ ▁] ▁xp ▁, ▁int ▁[ ▁] ▁y p ▁) ▁{ ▁xp ▁[ ▁0 ▁] ▁= ▁xp ▁[ ▁0 ▁] ▁^ ▁y p ▁[ ▁0 ▁] ▁; ▁y p ▁[ ▁0 ▁] ▁= ▁xp ▁[ ▁0 ▁] ▁^ ▁y p ▁[ ▁0 ▁] ▁; ▁xp ▁[ ▁0 ▁] ▁= ▁xp ▁[ ▁0 ▁] ▁^ ▁y p ▁[ ▁0 ▁] ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁x ▁= ▁{ ▁10 ▁} ▁; ▁swap ▁( ▁x ▁, ▁x ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁After ▁swap ▁( ▁& ▁x ▁, ▁& ▁x ▁) ▁: ▁x ▁= ▁" ▁+ ▁x ▁[ ▁0 ▁] ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁void ▁swap ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁a ▁= ▁( ▁a ▁& ▁b ▁) ▁+ ▁( ▁a ▁b ▁) ▁; ▁b ▁= ▁a ▁+ ▁( ▁~ ▁b ▁) ▁+ ▁1 ▁; ▁a ▁= ▁a ▁+ ▁( ▁~ ▁b ▁) ▁+ ▁1 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁After ▁swapping ▁: ▁a ▁= ▁" ▁+ ▁a ▁+ ▁" ▁, ▁b ▁= ▁" ▁+ ▁b ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁= ▁5 ▁, ▁b ▁= ▁10 ▁; ▁swap ▁( ▁a ▁, ▁b ▁) ▁; ▁} ▁}
▁class ▁S eg reg ate ▁{ ▁void ▁seg reg ate 0 and 1 ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁size ▁) ▁{ ▁int ▁left ▁= ▁0 ▁, ▁right ▁= ▁size ▁- ▁1 ▁; ▁while ▁( ▁left ▁< ▁right ▁) ▁{ ▁while ▁( ▁arr ▁[ ▁left ▁] ▁== ▁0 ▁&& ▁left ▁< ▁right ▁) ▁left ▁++ ▁; ▁while ▁( ▁arr ▁[ ▁right ▁] ▁== ▁1 ▁&& ▁left ▁< ▁right ▁) ▁right ▁-- ▁; ▁if ▁( ▁left ▁< ▁right ▁) ▁{ ▁arr ▁[ ▁left ▁] ▁= ▁0 ▁; ▁arr ▁[ ▁right ▁] ▁= ▁1 ▁; ▁left ▁++ ▁; ▁right ▁-- ▁; ▁} ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁S eg reg ate ▁seg ▁= ▁new ▁S eg reg ate ▁( ▁) ▁; ▁int ▁arr ▁[ ▁] ▁= ▁new ▁int ▁[ ▁] ▁{ ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁} ▁; ▁int ▁i ▁, ▁arr _ size ▁= ▁arr ▁. ▁length ▁; ▁seg ▁. ▁seg reg ate 0 and 1 ▁( ▁arr ▁, ▁arr _ size ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Array ▁after ▁seg reg ation ▁is ▁" ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁6 ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁}
▁class ▁Find Maximum ▁{ ▁int ▁max Index Diff ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁max Diff ▁= ▁- ▁1 ▁; ▁int ▁i ▁, ▁j ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁{ ▁for ▁( ▁j ▁= ▁n ▁- ▁1 ▁; ▁j ▁> ▁i ▁; ▁-- ▁j ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁j ▁] ▁> ▁arr ▁[ ▁i ▁] ▁&& ▁max Diff ▁< ▁( ▁j ▁- ▁i ▁) ▁) ▁max Diff ▁= ▁j ▁- ▁i ▁; ▁} ▁} ▁return ▁max Diff ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Find Maximum ▁max ▁= ▁new ▁Find Maximum ▁( ▁) ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁9 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁, ▁7 ▁, ▁8 ▁, ▁18 ▁, ▁0 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁int ▁max Diff ▁= ▁max ▁. ▁max Index Diff ▁( ▁arr ▁, ▁n ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁max Diff ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁v ▁= ▁{ ▁34 ▁, ▁8 ▁, ▁10 ▁, ▁3 ▁, ▁2 ▁, ▁80 ▁, ▁30 ▁, ▁33 ▁, ▁1 ▁} ▁; ▁int ▁n ▁= ▁v ▁. ▁length ▁; ▁int ▁[ ▁] ▁max From End ▁= ▁new ▁int ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁Arrays ▁. ▁fill ▁( ▁max From End ▁, ▁Integer ▁. ▁MIN _ VALUE ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁v ▁. ▁length ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁max From End ▁[ ▁i ▁] ▁= ▁Math ▁. ▁max ▁( ▁max From End ▁[ ▁i ▁+ ▁1 ▁] ▁, ▁v ▁[ ▁i ▁] ▁) ▁; ▁} ▁int ▁result ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁v ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁int ▁low ▁= ▁i ▁+ ▁1 ▁, ▁high ▁= ▁v ▁. ▁length ▁- ▁1 ▁, ▁ans ▁= ▁i ▁; ▁while ▁( ▁low ▁<= ▁high ▁) ▁{ ▁int ▁mid ▁= ▁( ▁low ▁+ ▁high ▁) ▁/ ▁2 ▁; ▁if ▁( ▁v ▁[ ▁i ▁] ▁<= ▁max From End ▁[ ▁mid ▁] ▁) ▁{ ▁ans ▁= ▁Math ▁. ▁max ▁( ▁ans ▁, ▁mid ▁) ▁; ▁low ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁else ▁{ ▁high ▁= ▁mid ▁- ▁1 ▁; ▁} ▁} ▁result ▁= ▁Math ▁. ▁max ▁( ▁result ▁, ▁ans ▁- ▁i ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁result ▁+ ▁" NEW _ LINE "); ▁} ▁}
▁class ▁Main ▁{ ▁static ▁int ▁find Maximum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁low ▁, ▁int ▁high ▁) ▁{ ▁int ▁max ▁= ▁arr ▁[ ▁low ▁] ▁; ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁low ▁; ▁i ▁<= ▁high ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁max ▁) ▁max ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁return ▁max ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁30 ▁, ▁40 ▁, ▁50 ▁, ▁60 ▁, ▁70 ▁, ▁23 ▁, ▁20 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁The ▁maximum ▁element ▁is ▁" ▁+ ▁find Maximum ▁( ▁arr ▁, ▁0 ▁, ▁n ▁- ▁1 ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁fun ▁( ▁int ▁x ▁) ▁{ ▁int ▁y ▁= ▁( ▁x ▁/ ▁4 ▁) ▁* ▁4 ▁; ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁y ▁; ▁i ▁<= ▁x ▁; ▁i ▁++ ▁) ▁ans ▁^= ▁i ▁; ▁return ▁ans ▁; ▁} ▁static ▁int ▁query ▁( ▁int ▁x ▁) ▁{ ▁if ▁( ▁x ▁== ▁0 ▁) ▁return ▁0 ▁; ▁int ▁k ▁= ▁( ▁x ▁+ ▁1 ▁) ▁/ ▁2 ▁; ▁return ▁( ▁( ▁x ▁% = ▁2 ▁) ▁!= ▁0 ▁) ▁? ▁2 ▁* ▁fun ▁( ▁k ▁) ▁: ▁( ▁( ▁fun ▁( ▁k ▁- ▁1 ▁) ▁* ▁2 ▁) ▁^ ▁( ▁k ▁& ▁1 ▁) ▁) ▁; ▁} ▁static ▁void ▁all Queries ▁( ▁int ▁q ▁, ▁int ▁l ▁[ ▁] ▁, ▁int ▁r ▁[ ▁] ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁q ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁( ▁query ▁( ▁r ▁[ ▁i ▁] ▁) ▁^ ▁query ▁( ▁l ▁[ ▁i ▁] ▁- ▁1 ▁) ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁q ▁= ▁3 ▁; ▁int ▁[ ▁] ▁l ▁= ▁{ ▁2 ▁, ▁2 ▁, ▁5 ▁} ▁; ▁int ▁[ ▁] ▁r ▁= ▁{ ▁4 ▁, ▁8 ▁, ▁9 ▁} ▁; ▁all Queries ▁( ▁q ▁, ▁l ▁, ▁r ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁double ▁probability ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁b ▁[ ▁] ▁, ▁int ▁size 1 ▁, ▁int ▁size 2 ▁) ▁{ ▁int ▁max 1 ▁= ▁Integer ▁. ▁MIN _ VALUE ▁, ▁count 1 ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁size 1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁> ▁max 1 ▁) ▁{ ▁max 1 ▁= ▁a ▁[ ▁i ▁] ▁; ▁count 1 ▁= ▁1 ▁; ▁} ▁else ▁if ▁( ▁a ▁[ ▁i ▁] ▁== ▁max 1 ▁) ▁{ ▁count 1 ▁++ ▁; ▁} ▁} ▁int ▁max 2 ▁= ▁Integer ▁. ▁MIN _ VALUE ▁, ▁count 2 ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁size 2 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁b ▁[ ▁i ▁] ▁> ▁max 2 ▁) ▁{ ▁max 2 ▁= ▁b ▁[ ▁i ▁] ▁; ▁count 2 ▁= ▁1 ▁; ▁} ▁else ▁if ▁( ▁b ▁[ ▁i ▁] ▁== ▁max 2 ▁) ▁{ ▁count 2 ▁++ ▁; ▁} ▁} ▁return ▁( ▁double ▁) ▁( ▁count 1 ▁* ▁count 2 ▁) ▁/ ▁( ▁size 1 ▁* ▁size 2 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁; ▁int ▁b ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁3 ▁} ▁; ▁int ▁size 1 ▁= ▁a ▁. ▁length ▁; ▁int ▁size 2 ▁= ▁b ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁probability ▁( ▁a ▁, ▁b ▁, ▁size 1 ▁, ▁size 2 ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁int ▁min sw aps ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁int ▁num _ un pla ced _ zeros ▁= ▁0 ▁; ▁for ▁( ▁int ▁index ▁= ▁n ▁- ▁1 ▁; ▁index ▁>= ▁0 ▁; ▁index ▁-- ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁index ▁] ▁== ▁0 ▁) ▁num _ un pla ced _ zeros ▁+= ▁1 ▁; ▁else ▁count ▁+= ▁num _ un pla ced _ zeros ▁; ▁} ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁0 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁} ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁min sw aps ▁( ▁arr ▁, ▁9 ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁void ▁sorted Merge ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁b ▁[ ▁] ▁, ▁int ▁res ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁a ▁) ▁; ▁Arrays ▁. ▁sort ▁( ▁b ▁) ▁; ▁int ▁i ▁= ▁0 ▁, ▁j ▁= ▁0 ▁, ▁k ▁= ▁0 ▁; ▁while ▁( ▁i ▁< ▁n ▁&& ▁j ▁< ▁m ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁<= ▁b ▁[ ▁j ▁] ▁) ▁{ ▁res ▁[ ▁k ▁] ▁= ▁a ▁[ ▁i ▁] ▁; ▁i ▁+= ▁1 ▁; ▁k ▁+= ▁1 ▁; ▁} ▁else ▁{ ▁res ▁[ ▁k ▁] ▁= ▁b ▁[ ▁j ▁] ▁; ▁j ▁+= ▁1 ▁; ▁k ▁+= ▁1 ▁; ▁} ▁} ▁while ▁( ▁i ▁< ▁n ▁) ▁{ ▁res ▁[ ▁k ▁] ▁= ▁a ▁[ ▁i ▁] ▁; ▁i ▁+= ▁1 ▁; ▁k ▁+= ▁1 ▁; ▁} ▁while ▁( ▁j ▁< ▁m ▁) ▁{ ▁res ▁[ ▁k ▁] ▁= ▁b ▁[ ▁j ▁] ▁; ▁j ▁+= ▁1 ▁; ▁k ▁+= ▁1 ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁5 ▁, ▁15 ▁} ▁; ▁int ▁b ▁[ ▁] ▁= ▁{ ▁20 ▁, ▁3 ▁, ▁2 ▁, ▁12 ▁} ▁; ▁int ▁n ▁= ▁a ▁. ▁length ▁; ▁int ▁m ▁= ▁b ▁. ▁length ▁; ▁int ▁res ▁[ ▁] ▁= ▁new ▁int ▁[ ▁n ▁+ ▁m ▁] ▁; ▁sorted Merge ▁( ▁a ▁, ▁b ▁, ▁res ▁, ▁n ▁, ▁m ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Sorted ▁merged ▁list ▁: ▁" ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁+ ▁m ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁" ▁+ ▁res ▁[ ▁i ▁] ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁single element ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁low ▁= ▁0 ▁, ▁high ▁= ▁n ▁- ▁2 ▁; ▁int ▁mid ▁; ▁while ▁( ▁low ▁<= ▁high ▁) ▁{ ▁mid ▁= ▁( ▁low ▁+ ▁high ▁) ▁/ ▁2 ▁; ▁if ▁( ▁arr ▁[ ▁mid ▁] ▁== ▁arr ▁[ ▁mid ▁^ ▁1 ▁] ▁) ▁{ ▁low ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁else ▁{ ▁high ▁= ▁mid ▁- ▁1 ▁; ▁} ▁} ▁return ▁arr ▁[ ▁low ▁] ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁5 ▁, ▁4 ▁, ▁5 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁size ▁= ▁7 ▁; ▁Arrays ▁. ▁sort ▁( ▁arr ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁single element ▁( ▁arr ▁, ▁size ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁List ▁< ▁Integer ▁> ▁find Dis appe ared Numbers ▁( ▁int ▁[ ▁] ▁nums ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁nums ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁int ▁index ▁= ▁Math ▁. ▁abs ▁( ▁nums ▁[ ▁i ▁] ▁) ▁; ▁if ▁( ▁nums ▁[ ▁index ▁- ▁1 ▁] ▁> ▁0 ▁) ▁{ ▁nums ▁[ ▁index ▁- ▁1 ▁] ▁*= ▁- ▁1 ▁; ▁} ▁} ▁List ▁< ▁Integer ▁> ▁res ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁nums ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁nums ▁[ ▁i ▁] ▁> ▁0 ▁) ▁{ ▁res ▁. ▁add ▁( ▁i ▁+ ▁1 ▁) ▁; ▁} ▁} ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁a ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Dis appe ared Numbers ▁( ▁a ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁getM issing No ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁total ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁( ▁n ▁+ ▁1 ▁) ▁; ▁i ▁++ ▁) ▁{ ▁total ▁+= ▁i ▁; ▁total ▁-= ▁a ▁[ ▁i ▁- ▁2 ▁] ▁; ▁} ▁return ▁total ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁5 ▁} ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁getM issing No ▁( ▁arr ▁, ▁arr ▁. ▁length ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁getM issing No ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁n _ elements _ sum ▁= ▁n ▁* ▁( ▁n ▁+ ▁1 ▁) ▁/ ▁2 ▁; ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁sum ▁+= ▁a ▁[ ▁i ▁] ▁; ▁return ▁n _ elements _ sum ▁- ▁sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁a ▁. ▁length ▁+ ▁1 ▁; ▁int ▁miss ▁= ▁getM issing No ▁( ▁a ▁, ▁n ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁miss ▁) ▁; ▁} ▁}
▁class ▁Find Four Elements ▁{ ▁void ▁find Four Elements ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁X ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁3 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁- ▁2 ▁; ▁j ▁++ ▁) ▁{ ▁for ▁( ▁int ▁k ▁= ▁j ▁+ ▁1 ▁; ▁k ▁< ▁n ▁- ▁1 ▁; ▁k ▁++ ▁) ▁{ ▁for ▁( ▁int ▁l ▁= ▁k ▁+ ▁1 ▁; ▁l ▁< ▁n ▁; ▁l ▁++ ▁) ▁{ ▁if ▁( ▁A ▁[ ▁i ▁] ▁+ ▁A ▁[ ▁j ▁] ▁+ ▁A ▁[ ▁k ▁] ▁+ ▁A ▁[ ▁l ▁] ▁== ▁X ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁A ▁[ ▁i ▁] ▁+ ▁" ▁" ▁+ ▁A ▁[ ▁j ▁] ▁+ ▁" ▁" ▁+ ▁A ▁[ ▁k ▁] ▁+ ▁" ▁" ▁+ ▁A ▁[ ▁l ▁] ▁) ▁; ▁} ▁} ▁} ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Find Four Elements ▁find four ▁= ▁new ▁Find Four Elements ▁( ▁) ▁; ▁int ▁A ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁20 ▁, ▁30 ▁, ▁40 ▁, ▁1 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁A ▁. ▁length ▁; ▁int ▁X ▁= ▁91 ▁; ▁find four ▁. ▁find Four Elements ▁( ▁A ▁, ▁n ▁, ▁X ▁) ▁; ▁} ▁}
▁public ▁class ▁Test ▁{ ▁public ▁static ▁int ▁find Major ity ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁return ▁arr ▁[ ▁n ▁/ ▁2 ▁] ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁2 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Major ity ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁least F requ ent ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁arr ▁) ▁; ▁int ▁min _ count ▁= ▁n ▁+ ▁1 ▁, ▁res ▁= ▁- ▁1 ▁; ▁int ▁curr _ count ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁) ▁curr _ count ▁++ ▁; ▁else ▁{ ▁if ▁( ▁curr _ count ▁< ▁min _ count ▁) ▁{ ▁min _ count ▁= ▁curr _ count ▁; ▁res ▁= ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁; ▁} ▁curr _ count ▁= ▁1 ▁; ▁} ▁} ▁if ▁( ▁curr _ count ▁< ▁min _ count ▁) ▁{ ▁min _ count ▁= ▁curr _ count ▁; ▁res ▁= ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁; ▁} ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁2 ▁, ▁1 ▁, ▁2 ▁, ▁2 ▁, ▁3 ▁, ▁1 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁least F requ ent ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁HashMap ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁print missing k ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁d ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁d ▁. ▁put ▁( ▁arr ▁[ ▁i ▁] ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁int ▁cnt ▁= ▁1 ▁; ▁int ▁fl ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁( ▁n ▁+ ▁k ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁! ▁d ▁. ▁containsKey ▁( ▁cnt ▁) ▁) ▁{ ▁fl ▁+= ▁1 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁cnt ▁+ ▁" ▁" ▁) ▁; ▁if ▁( ▁fl ▁== ▁k ▁) ▁break ▁; ▁} ▁cnt ▁+= ▁1 ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁4 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁int ▁k ▁= ▁3 ▁; ▁print missing k ▁( ▁arr ▁, ▁n ▁, ▁k ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁min Product Subset ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁1 ▁) ▁return ▁a ▁[ ▁0 ▁] ▁; ▁int ▁neg max ▁= ▁Integer ▁. ▁MIN _ VALUE ▁; ▁int ▁pos min ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁int ▁count _ neg ▁= ▁0 ▁, ▁count _ zero ▁= ▁0 ▁; ▁int ▁product ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁count _ zero ▁++ ▁; ▁continue ▁; ▁} ▁if ▁( ▁a ▁[ ▁i ▁] ▁< ▁0 ▁) ▁{ ▁count _ neg ▁++ ▁; ▁neg max ▁= ▁Math ▁. ▁max ▁( ▁neg max ▁, ▁a ▁[ ▁i ▁] ▁) ▁; ▁} ▁if ▁( ▁a ▁[ ▁i ▁] ▁> ▁0 ▁&& ▁a ▁[ ▁i ▁] ▁< ▁pos min ▁) ▁pos min ▁= ▁a ▁[ ▁i ▁] ▁; ▁product ▁*= ▁a ▁[ ▁i ▁] ▁; ▁} ▁if ▁( ▁count _ zero ▁== ▁n ▁|| ▁( ▁count _ neg ▁== ▁0 ▁&& ▁count _ zero ▁> ▁0 ▁) ▁) ▁return ▁0 ▁; ▁if ▁( ▁count _ neg ▁== ▁0 ▁) ▁return ▁pos min ▁; ▁if ▁( ▁count _ neg ▁% ▁2 ▁== ▁0 ▁&& ▁count _ neg ▁!= ▁0 ▁) ▁{ ▁product ▁= ▁product ▁/ ▁neg max ▁; ▁} ▁return ▁product ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁- ▁1 ▁, ▁- ▁1 ▁, ▁- ▁2 ▁, ▁4 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁min Product Subset ▁( ▁a ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G f G ▁{ ▁static ▁class ▁Node ▁{ ▁int ▁data ▁; ▁Node ▁next ▁; ▁} ▁static ▁int ▁count Common ▁( ▁Node ▁a ▁, ▁Node ▁b ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁; ▁a ▁!= ▁null ▁&& ▁b ▁!= ▁null ▁; ▁a ▁= ▁a ▁. ▁next ▁, ▁b ▁= ▁b ▁. ▁next ▁) ▁if ▁( ▁a ▁. ▁data ▁== ▁b ▁. ▁data ▁) ▁++ ▁count ▁; ▁else ▁break ▁; ▁return ▁count ▁; ▁} ▁static ▁int ▁max Pal indrome ▁( ▁Node ▁head ▁) ▁{ ▁int ▁result ▁= ▁0 ▁; ▁Node ▁prev ▁= ▁null ▁, ▁curr ▁= ▁head ▁; ▁while ▁( ▁curr ▁!= ▁null ▁) ▁{ ▁Node ▁next ▁= ▁curr ▁. ▁next ▁; ▁curr ▁. ▁next ▁= ▁prev ▁; ▁result ▁= ▁Math ▁. ▁max ▁( ▁result ▁, ▁2 ▁* ▁count Common ▁( ▁prev ▁, ▁next ▁) ▁+ ▁1 ▁) ▁; ▁result ▁= ▁Math ▁. ▁max ▁( ▁result ▁, ▁2 ▁* ▁count Common ▁( ▁curr ▁, ▁next ▁) ▁) ▁; ▁prev ▁= ▁curr ▁; ▁curr ▁= ▁next ▁; ▁} ▁return ▁result ▁; ▁} ▁static ▁Node ▁newNode ▁( ▁int ▁key ▁) ▁{ ▁Node ▁temp ▁= ▁new ▁Node ▁( ▁) ▁; ▁temp ▁. ▁data ▁= ▁key ▁; ▁temp ▁. ▁next ▁= ▁null ▁; ▁return ▁temp ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Node ▁head ▁= ▁newNode ▁( ▁2 ▁) ▁; ▁head ▁. ▁next ▁= ▁newNode ▁( ▁4 ▁) ▁; ▁head ▁. ▁next ▁. ▁next ▁= ▁newNode ▁( ▁3 ▁) ▁; ▁head ▁. ▁next ▁. ▁next ▁. ▁next ▁= ▁newNode ▁( ▁4 ▁) ▁; ▁head ▁. ▁next ▁. ▁next ▁. ▁next ▁. ▁next ▁= ▁newNode ▁( ▁2 ▁) ▁; ▁head ▁. ▁next ▁. ▁next ▁. ▁next ▁. ▁next ▁. ▁next ▁= ▁newNode ▁( ▁15 ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁max Pal indrome ▁( ▁head ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁class ▁Node ▁{ ▁int ▁data ▁; ▁Node ▁next ▁; ▁} ▁static ▁Node ▁free List ▁( ▁Node ▁node ▁) ▁{ ▁while ▁( ▁node ▁!= ▁null ▁) ▁{ ▁Node ▁next ▁= ▁node ▁. ▁next ▁; ▁node ▁= ▁next ▁; ▁} ▁return ▁node ▁; ▁} ▁static ▁Node ▁delete K th Node ▁( ▁Node ▁head ▁, ▁int ▁k ▁) ▁{ ▁if ▁( ▁head ▁== ▁null ▁) ▁return ▁null ▁; ▁if ▁( ▁k ▁== ▁1 ▁) ▁{ ▁head ▁= ▁free List ▁( ▁head ▁) ▁; ▁return ▁null ▁; ▁} ▁Node ▁ptr ▁= ▁head ▁, ▁prev ▁= ▁null ▁; ▁int ▁count ▁= ▁0 ▁; ▁while ▁( ▁ptr ▁!= ▁null ▁) ▁{ ▁count ▁++ ▁; ▁if ▁( ▁k ▁== ▁count ▁) ▁{ ▁prev ▁. ▁next ▁= ▁ptr ▁. ▁next ▁; ▁count ▁= ▁0 ▁; ▁} ▁if ▁( ▁count ▁!= ▁0 ▁) ▁prev ▁= ▁ptr ▁; ▁ptr ▁= ▁prev ▁. ▁next ▁; ▁} ▁return ▁head ▁; ▁} ▁static ▁void ▁display List ▁( ▁Node ▁head ▁) ▁{ ▁Node ▁temp ▁= ▁head ▁; ▁while ▁( ▁temp ▁!= ▁null ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁temp ▁. ▁data ▁+ ▁" ▁" ▁) ▁; ▁temp ▁= ▁temp ▁. ▁next ▁; ▁} ▁} ▁static ▁Node ▁newNode ▁( ▁int ▁x ▁) ▁{ ▁Node ▁temp ▁= ▁new ▁Node ▁( ▁) ▁; ▁temp ▁. ▁data ▁= ▁x ▁; ▁temp ▁. ▁next ▁= ▁null ▁; ▁return ▁temp ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁Node ▁head ▁= ▁newNode ▁( ▁1 ▁) ▁; ▁head ▁. ▁next ▁= ▁newNode ▁( ▁2 ▁) ▁; ▁head ▁. ▁next ▁. ▁next ▁= ▁newNode ▁( ▁3 ▁) ▁; ▁head ▁. ▁next ▁. ▁next ▁. ▁next ▁= ▁newNode ▁( ▁4 ▁) ▁; ▁head ▁. ▁next ▁. ▁next ▁. ▁next ▁. ▁next ▁= ▁newNode ▁( ▁5 ▁) ▁; ▁head ▁. ▁next ▁. ▁next ▁. ▁next ▁. ▁next ▁. ▁next ▁= ▁newNode ▁( ▁6 ▁) ▁; ▁head ▁. ▁next ▁. ▁next ▁. ▁next ▁. ▁next ▁. ▁next ▁. ▁next ▁= ▁newNode ▁( ▁7 ▁) ▁; ▁head ▁. ▁next ▁. ▁next ▁. ▁next ▁. ▁next ▁. ▁next ▁. ▁next ▁. ▁next ▁= ▁newNode ▁( ▁8 ▁) ▁; ▁int ▁k ▁= ▁3 ▁; ▁head ▁= ▁delete K th Node ▁( ▁head ▁, ▁k ▁) ▁; ▁display List ▁( ▁head ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁class ▁Node ▁{ ▁int ▁data ▁; ▁Node ▁next ▁; ▁} ▁; ▁static ▁Node ▁head ▁; ▁static ▁int ▁n ▁, ▁sum ▁; ▁static ▁void ▁push ▁( ▁Node ▁head _ ref ▁, ▁int ▁new _ data ▁) ▁{ ▁Node ▁new _ node ▁= ▁new ▁Node ▁( ▁) ▁; ▁new _ node ▁. ▁data ▁= ▁new _ data ▁; ▁new _ node ▁. ▁next ▁= ▁head _ ref ▁; ▁head _ ref ▁= ▁new _ node ▁; ▁head ▁= ▁head _ ref ▁; ▁} ▁static ▁void ▁sum Of Last N _ Nodes ▁( ▁Node ▁head ▁) ▁{ ▁if ▁( ▁head ▁== ▁null ▁) ▁return ▁; ▁sum Of Last N _ Nodes ▁( ▁head ▁. ▁next ▁) ▁; ▁if ▁( ▁n ▁> ▁0 ▁) ▁{ ▁sum ▁= ▁sum ▁+ ▁head ▁. ▁data ▁; ▁-- ▁n ▁; ▁} ▁} ▁static ▁int ▁sum Of Last N _ Nodes Util ▁( ▁Node ▁head ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁<= ▁0 ▁) ▁return ▁0 ▁; ▁sum ▁= ▁0 ▁; ▁sum Of Last N _ Nodes ▁( ▁head ▁) ▁; ▁return ▁sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁head ▁= ▁null ▁; ▁push ▁( ▁head ▁, ▁12 ▁) ▁; ▁push ▁( ▁head ▁, ▁4 ▁) ▁; ▁push ▁( ▁head ▁, ▁8 ▁) ▁; ▁push ▁( ▁head ▁, ▁6 ▁) ▁; ▁push ▁( ▁head ▁, ▁10 ▁) ▁; ▁n ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Sum ▁of ▁last ▁" ▁+ ▁n ▁+ ▁" ▁nodes ▁= ▁" ▁+ ▁sum Of Last N _ Nodes Util ▁( ▁head ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁class ▁Node ▁{ ▁char ▁data ▁; ▁Node ▁next ▁; ▁Node ▁prev ▁; ▁} ▁; ▁static ▁Node ▁push ▁( ▁Node ▁head _ ref ▁, ▁char ▁new _ data ▁) ▁{ ▁Node ▁new _ node ▁= ▁new ▁Node ▁( ▁) ▁; ▁new _ node ▁. ▁data ▁= ▁new _ data ▁; ▁new _ node ▁. ▁next ▁= ▁head _ ref ▁; ▁new _ node ▁. ▁prev ▁= ▁null ▁; ▁if ▁( ▁head _ ref ▁!= ▁null ▁) ▁head _ ref ▁. ▁prev ▁= ▁new _ node ▁; ▁head _ ref ▁= ▁new _ node ▁; ▁return ▁head _ ref ▁; ▁} ▁static ▁boolean ▁isP al indrome ▁( ▁Node ▁left ▁) ▁{ ▁if ▁( ▁left ▁== ▁null ▁) ▁return ▁true ▁; ▁Node ▁right ▁= ▁left ▁; ▁while ▁( ▁right ▁. ▁next ▁!= ▁null ▁) ▁right ▁= ▁right ▁. ▁next ▁; ▁while ▁( ▁left ▁!= ▁right ▁) ▁{ ▁if ▁( ▁left ▁. ▁data ▁!= ▁right ▁. ▁data ▁) ▁return ▁false ▁; ▁left ▁= ▁left ▁. ▁next ▁; ▁right ▁= ▁right ▁. ▁prev ▁; ▁} ▁return ▁true ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Node ▁head ▁= ▁null ▁; ▁head ▁= ▁push ▁( ▁head ▁, ▁' ▁l ▁' ▁) ▁; ▁head ▁= ▁push ▁( ▁head ▁, ▁' ▁e ▁' ▁) ▁; ▁head ▁= ▁push ▁( ▁head ▁, ▁' ▁v ▁' ▁) ▁; ▁head ▁= ▁push ▁( ▁head ▁, ▁' ▁e ▁' ▁) ▁; ▁head ▁= ▁push ▁( ▁head ▁, ▁' ▁l ▁' ▁) ▁; ▁if ▁( ▁isP al indrome ▁( ▁head ▁) ▁) ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁It ▁is ▁P al indrome ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁Not ▁P al indrome ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁class ▁Node ▁{ ▁public ▁int ▁data ▁; ▁public ▁Node ▁left ▁, ▁right ▁; ▁} ▁; ▁static ▁void ▁print Leaf Nodes ▁( ▁Node ▁root ▁) ▁{ ▁if ▁( ▁root ▁== ▁null ▁) ▁return ▁; ▁if ▁( ▁root ▁. ▁left ▁== ▁null ▁&& ▁root ▁. ▁right ▁== ▁null ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁root ▁. ▁data ▁+ ▁" ▁" ▁) ▁; ▁return ▁; ▁} ▁if ▁( ▁root ▁. ▁left ▁!= ▁null ▁) ▁print Leaf Nodes ▁( ▁root ▁. ▁left ▁) ▁; ▁if ▁( ▁root ▁. ▁right ▁!= ▁null ▁) ▁print Leaf Nodes ▁( ▁root ▁. ▁right ▁) ▁; ▁} ▁static ▁Node ▁newNode ▁( ▁int ▁data ▁) ▁{ ▁Node ▁temp ▁= ▁new ▁Node ▁( ▁) ▁; ▁temp ▁. ▁data ▁= ▁data ▁; ▁temp ▁. ▁left ▁= ▁null ▁; ▁temp ▁. ▁right ▁= ▁null ▁; ▁return ▁temp ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Node ▁root ▁= ▁newNode ▁( ▁1 ▁) ▁; ▁root ▁. ▁left ▁= ▁newNode ▁( ▁2 ▁) ▁; ▁root ▁. ▁right ▁= ▁newNode ▁( ▁3 ▁) ▁; ▁root ▁. ▁left ▁. ▁left ▁= ▁newNode ▁( ▁4 ▁) ▁; ▁root ▁. ▁right ▁. ▁left ▁= ▁newNode ▁( ▁5 ▁) ▁; ▁root ▁. ▁right ▁. ▁right ▁= ▁newNode ▁( ▁8 ▁) ▁; ▁root ▁. ▁right ▁. ▁left ▁. ▁left ▁= ▁newNode ▁( ▁6 ▁) ▁; ▁root ▁. ▁right ▁. ▁left ▁. ▁right ▁= ▁newNode ▁( ▁7 ▁) ▁; ▁root ▁. ▁right ▁. ▁right ▁. ▁left ▁= ▁newNode ▁( ▁9 ▁) ▁; ▁root ▁. ▁right ▁. ▁right ▁. ▁right ▁= ▁newNode ▁( ▁10 ▁) ▁; ▁print Leaf Nodes ▁( ▁root ▁) ▁; ▁} ▁}
▁class ▁Node ▁{ ▁int ▁data ▁; ▁Node ▁left ▁, ▁right ▁; ▁Node ▁( ▁int ▁item ▁) ▁{ ▁data ▁= ▁item ▁; ▁left ▁= ▁right ▁= ▁null ▁; ▁} ▁} ▁class ▁Binary Tree ▁{ ▁Node ▁root ▁; ▁void ▁print k distance Node Down ▁( ▁Node ▁node ▁, ▁int ▁k ▁) ▁{ ▁if ▁( ▁node ▁== ▁null ▁k ▁< ▁0 ▁) ▁return ▁; ▁if ▁( ▁k ▁== ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁node ▁. ▁data ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁" ▁) ▁; ▁return ▁; ▁} ▁print k distance Node Down ▁( ▁node ▁. ▁left ▁, ▁k ▁- ▁1 ▁) ▁; ▁print k distance Node Down ▁( ▁node ▁. ▁right ▁, ▁k ▁- ▁1 ▁) ▁; ▁} ▁int ▁print k distance Node ▁( ▁Node ▁node ▁, ▁Node ▁target ▁, ▁int ▁k ▁) ▁{ ▁if ▁( ▁node ▁== ▁null ▁) ▁return ▁- ▁1 ▁; ▁if ▁( ▁node ▁== ▁target ▁) ▁{ ▁print k distance Node Down ▁( ▁node ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁} ▁int ▁dl ▁= ▁print k distance Node ▁( ▁node ▁. ▁left ▁, ▁target ▁, ▁k ▁) ▁; ▁if ▁( ▁dl ▁!= ▁- ▁1 ▁) ▁{ ▁if ▁( ▁dl ▁+ ▁1 ▁== ▁k ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁node ▁. ▁data ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁" ▁) ▁; ▁} ▁else ▁print k distance Node Down ▁( ▁node ▁. ▁right ▁, ▁k ▁- ▁dl ▁- ▁2 ▁) ▁; ▁return ▁1 ▁+ ▁dl ▁; ▁} ▁int ▁dr ▁= ▁print k distance Node ▁( ▁node ▁. ▁right ▁, ▁target ▁, ▁k ▁) ▁; ▁if ▁( ▁dr ▁!= ▁- ▁1 ▁) ▁{ ▁if ▁( ▁dr ▁+ ▁1 ▁== ▁k ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁node ▁. ▁data ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁" ▁) ▁; ▁} ▁else ▁print k distance Node Down ▁( ▁node ▁. ▁left ▁, ▁k ▁- ▁dr ▁- ▁2 ▁) ▁; ▁return ▁1 ▁+ ▁dr ▁; ▁} ▁return ▁- ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁Binary Tree ▁tree ▁= ▁new ▁Binary Tree ▁( ▁) ▁; ▁tree ▁. ▁root ▁= ▁new ▁Node ▁( ▁20 ▁) ▁; ▁tree ▁. ▁root ▁. ▁left ▁= ▁new ▁Node ▁( ▁8 ▁) ▁; ▁tree ▁. ▁root ▁. ▁right ▁= ▁new ▁Node ▁( ▁22 ▁) ▁; ▁tree ▁. ▁root ▁. ▁left ▁. ▁left ▁= ▁new ▁Node ▁( ▁4 ▁) ▁; ▁tree ▁. ▁root ▁. ▁left ▁. ▁right ▁= ▁new ▁Node ▁( ▁12 ▁) ▁; ▁tree ▁. ▁root ▁. ▁left ▁. ▁right ▁. ▁left ▁= ▁new ▁Node ▁( ▁10 ▁) ▁; ▁tree ▁. ▁root ▁. ▁left ▁. ▁right ▁. ▁right ▁= ▁new ▁Node ▁( ▁14 ▁) ▁; ▁Node ▁target ▁= ▁tree ▁. ▁root ▁. ▁left ▁. ▁right ▁; ▁tree ▁. ▁print k distance Node ▁( ▁tree ▁. ▁root ▁, ▁target ▁, ▁2 ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁N ▁= ▁3 ▁; ▁static ▁int ▁find Maximum Diag onal Sum OM atrix f ▁( ▁int ▁A ▁[ ▁] ▁[ ▁] ▁) ▁{ ▁int ▁max Diag onal Sum ▁= ▁Integer ▁. ▁MIN _ VALUE ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁int ▁curr ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁curr ▁+= ▁A ▁[ ▁j ▁] ▁[ ▁( ▁i ▁+ ▁j ▁) ▁% ▁N ▁] ▁; ▁} ▁max Diag onal Sum ▁= ▁Math ▁. ▁max ▁( ▁max Diag onal Sum ▁, ▁curr ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁int ▁curr ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁curr ▁+= ▁A ▁[ ▁( ▁i ▁+ ▁j ▁) ▁% ▁N ▁] ▁[ ▁j ▁] ▁; ▁} ▁max Diag onal Sum ▁= ▁Math ▁. ▁max ▁( ▁max Diag onal Sum ▁, ▁curr ▁) ▁; ▁} ▁return ▁max Diag onal Sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁[ ▁] ▁mat ▁= ▁{ ▁{ ▁1 ▁, ▁1 ▁, ▁2 ▁} ▁, ▁{ ▁2 ▁, ▁1 ▁, ▁2 ▁} ▁, ▁{ ▁1 ▁, ▁2 ▁, ▁2 ▁} ▁} ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Maximum Diag onal Sum OM atrix f ▁( ▁mat ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁left _ rotate ▁( ▁int ▁[ ▁] ▁arr ▁) ▁{ ▁int ▁last ▁= ▁arr ▁[ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁3 ▁; ▁i ▁< ▁arr ▁. ▁length ▁; ▁i ▁= ▁i ▁+ ▁2 ▁) ▁{ ▁arr ▁[ ▁i ▁- ▁2 ▁] ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁arr ▁[ ▁arr ▁. ▁length ▁- ▁1 ▁] ▁= ▁last ▁; ▁} ▁static ▁void ▁right _ rotate ▁( ▁int ▁[ ▁] ▁arr ▁) ▁{ ▁int ▁start ▁= ▁arr ▁[ ▁arr ▁. ▁length ▁- ▁2 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁arr ▁. ▁length ▁- ▁4 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁= ▁i ▁- ▁2 ▁) ▁{ ▁arr ▁[ ▁i ▁+ ▁2 ▁] ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁arr ▁[ ▁0 ▁] ▁= ▁start ▁; ▁} ▁public ▁static ▁void ▁rotate ▁( ▁int ▁arr ▁[ ▁] ▁) ▁{ ▁left _ rotate ▁( ▁arr ▁) ▁; ▁right _ rotate ▁( ▁arr ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁arr ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁rotate ▁( ▁arr ▁) ▁; ▁} ▁}
▁public ▁class ▁G F G ▁{ ▁public ▁static ▁int ▁count Rotation ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁low ▁, ▁int ▁high ▁) ▁{ ▁if ▁( ▁low ▁> ▁high ▁) ▁{ ▁return ▁0 ▁; ▁} ▁int ▁mid ▁= ▁low ▁+ ▁( ▁high ▁- ▁low ▁) ▁/ ▁2 ▁; ▁if ▁( ▁mid ▁< ▁high ▁&& ▁arr ▁[ ▁mid ▁] ▁> ▁arr ▁[ ▁mid ▁+ ▁1 ▁] ▁) ▁{ ▁return ▁mid ▁+ ▁1 ▁; ▁} ▁if ▁( ▁mid ▁> ▁low ▁&& ▁arr ▁[ ▁mid ▁] ▁< ▁arr ▁[ ▁mid ▁- ▁1 ▁] ▁) ▁{ ▁return ▁mid ▁; ▁} ▁if ▁( ▁arr ▁[ ▁mid ▁] ▁> ▁arr ▁[ ▁low ▁] ▁) ▁{ ▁return ▁count Rotation ▁( ▁arr ▁, ▁mid ▁+ ▁1 ▁, ▁high ▁) ▁; ▁} ▁if ▁( ▁arr ▁[ ▁mid ▁] ▁< ▁arr ▁[ ▁high ▁] ▁) ▁{ ▁return ▁count Rotation ▁( ▁arr ▁, ▁low ▁, ▁mid ▁- ▁1 ▁) ▁; ▁} ▁else ▁{ ▁int ▁right Index ▁= ▁count Rotation ▁( ▁arr ▁, ▁mid ▁+ ▁1 ▁, ▁high ▁) ▁; ▁int ▁left Index ▁= ▁count Rotation ▁( ▁arr ▁, ▁low ▁, ▁mid ▁- ▁1 ▁) ▁; ▁if ▁( ▁right Index ▁== ▁0 ▁) ▁{ ▁return ▁left Index ▁; ▁} ▁return ▁right Index ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr 1 ▁= ▁{ ▁4 ▁, ▁5 ▁, ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Rotation ▁( ▁arr 1 ▁, ▁0 ▁, ▁arr 1 ▁. ▁length ▁- ▁1 ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁MAX ▁= ▁10000 5 ▁; ▁static ▁int ▁[ ▁] ▁seg ▁= ▁new ▁int ▁[ ▁4 ▁* ▁MAX ▁] ▁; ▁static ▁void ▁build ▁( ▁int ▁node ▁, ▁int ▁l ▁, ▁int ▁r ▁, ▁int ▁a ▁[ ▁] ▁) ▁{ ▁if ▁( ▁l ▁== ▁r ▁) ▁seg ▁[ ▁node ▁] ▁= ▁a ▁[ ▁l ▁] ▁; ▁else ▁{ ▁int ▁mid ▁= ▁( ▁l ▁+ ▁r ▁) ▁/ ▁2 ▁; ▁build ▁( ▁2 ▁* ▁node ▁, ▁l ▁, ▁mid ▁, ▁a ▁) ▁; ▁build ▁( ▁2 ▁* ▁node ▁+ ▁1 ▁, ▁mid ▁+ ▁1 ▁, ▁r ▁, ▁a ▁) ▁; ▁seg ▁[ ▁node ▁] ▁= ▁( ▁seg ▁[ ▁2 ▁* ▁node ▁] ▁seg ▁[ ▁2 ▁* ▁node ▁+ ▁1 ▁] ▁) ▁; ▁} ▁} ▁static ▁int ▁query ▁( ▁int ▁node ▁, ▁int ▁l ▁, ▁int ▁r ▁, ▁int ▁start ▁, ▁int ▁end ▁, ▁int ▁a ▁[ ▁] ▁) ▁{ ▁if ▁( ▁l ▁> ▁end ▁r ▁< ▁start ▁) ▁return ▁0 ▁; ▁if ▁( ▁start ▁<= ▁l ▁&& ▁r ▁<= ▁end ▁) ▁return ▁seg ▁[ ▁node ▁] ▁; ▁int ▁mid ▁= ▁( ▁l ▁+ ▁r ▁) ▁/ ▁2 ▁; ▁return ▁( ▁( ▁query ▁( ▁2 ▁* ▁node ▁, ▁l ▁, ▁mid ▁, ▁start ▁, ▁end ▁, ▁a ▁) ▁) ▁| ▁( ▁query ▁( ▁2 ▁* ▁node ▁+ ▁1 ▁, ▁mid ▁+ ▁1 ▁, ▁r ▁, ▁start ▁, ▁end ▁, ▁a ▁) ▁) ▁) ▁; ▁} ▁static ▁void ▁or sum ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁q ▁, ▁int ▁k ▁[ ▁] ▁) ▁{ ▁build ▁( ▁1 ▁, ▁0 ▁, ▁n ▁- ▁1 ▁, ▁a ▁) ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁q ▁; ▁j ▁++ ▁) ▁{ ▁int ▁i ▁= ▁k ▁[ ▁j ▁] ▁% ▁( ▁n ▁/ ▁2 ▁) ▁; ▁int ▁sec ▁= ▁query ▁( ▁1 ▁, ▁0 ▁, ▁n ▁- ▁1 ▁, ▁n ▁/ ▁2 ▁- ▁i ▁, ▁n ▁- ▁i ▁- ▁1 ▁, ▁a ▁) ▁; ▁int ▁first ▁= ▁( ▁query ▁( ▁1 ▁, ▁0 ▁, ▁n ▁- ▁1 ▁, ▁0 ▁, ▁n ▁/ ▁2 ▁- ▁1 ▁- ▁i ▁, ▁a ▁) ▁| ▁query ▁( ▁1 ▁, ▁0 ▁, ▁n ▁- ▁1 ▁, ▁n ▁- ▁i ▁, ▁n ▁- ▁1 ▁, ▁a ▁) ▁) ▁; ▁int ▁temp ▁= ▁sec ▁+ ▁first ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁temp ▁+ ▁" NEW _ LINE "); ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁7 ▁, ▁44 ▁, ▁19 ▁, ▁86 ▁, ▁65 ▁, ▁39 ▁, ▁75 ▁, ▁101 ▁} ▁; ▁int ▁n ▁= ▁a ▁. ▁length ▁; ▁int ▁q ▁= ▁2 ▁; ▁int ▁k ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁2 ▁} ▁; ▁or sum ▁( ▁a ▁, ▁n ▁, ▁q ▁, ▁k ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁maximum Equal ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁b ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁store ▁[ ▁] ▁= ▁new ▁int ▁[ ▁( ▁int ▁) ▁1 e 5 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁store ▁[ ▁b ▁[ ▁i ▁] ▁] ▁= ▁i ▁+ ▁1 ▁; ▁} ▁int ▁ans ▁[ ▁] ▁= ▁new ▁int ▁[ ▁( ▁int ▁) ▁1 e 5 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁d ▁= ▁Math ▁. ▁abs ▁( ▁store ▁[ ▁a ▁[ ▁i ▁] ▁] ▁- ▁( ▁i ▁+ ▁1 ▁) ▁) ▁; ▁if ▁( ▁store ▁[ ▁a ▁[ ▁i ▁] ▁] ▁< ▁i ▁+ ▁1 ▁) ▁{ ▁d ▁= ▁n ▁- ▁d ▁; ▁} ▁ans ▁[ ▁d ▁] ▁++ ▁; ▁} ▁int ▁final ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁1 e 5 ▁; ▁i ▁++ ▁) ▁final ans ▁= ▁Math ▁. ▁max ▁( ▁final ans ▁, ▁ans ▁[ ▁i ▁] ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁final ans ▁+ ▁" NEW _ LINE "); ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁6 ▁, ▁7 ▁, ▁3 ▁, ▁9 ▁, ▁5 ▁} ▁; ▁int ▁B ▁[ ▁] ▁= ▁{ ▁7 ▁, ▁3 ▁, ▁9 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁int ▁size ▁= ▁A ▁. ▁length ▁; ▁maximum Equal ▁( ▁A ▁, ▁B ▁, ▁size ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁count Rotation ▁( ▁int ▁n ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁do ▁{ ▁int ▁digit ▁= ▁n ▁% ▁10 ▁; ▁if ▁( ▁digit ▁== ▁0 ▁) ▁count ▁++ ▁; ▁n ▁= ▁n ▁/ ▁10 ▁; ▁} ▁while ▁( ▁n ▁!= ▁0 ▁) ▁; ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁10 203 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Rotation ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁boolean ▁isP ossible ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁<= ▁2 ▁) ▁return ▁true ▁; ▁int ▁flag ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁! ▁( ▁a ▁[ ▁i ▁] ▁> ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁&& ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁> ▁a ▁[ ▁i ▁+ ▁2 ▁] ▁) ▁) ▁{ ▁flag ▁= ▁1 ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁flag ▁== ▁0 ▁) ▁return ▁true ▁; ▁flag ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁! ▁( ▁a ▁[ ▁i ▁] ▁< ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁&& ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁< ▁a ▁[ ▁i ▁+ ▁2 ▁] ▁) ▁) ▁{ ▁flag ▁= ▁1 ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁flag ▁== ▁0 ▁) ▁return ▁true ▁; ▁int ▁val 1 ▁= ▁Integer ▁. ▁MAX _ VALUE ▁, ▁mini ▁= ▁- ▁1 ▁, ▁val 2 ▁= ▁Integer ▁. ▁MIN _ VALUE ▁, ▁max i ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁< ▁val 1 ▁) ▁{ ▁mini ▁= ▁i ▁; ▁val 1 ▁= ▁a ▁[ ▁i ▁] ▁; ▁} ▁if ▁( ▁a ▁[ ▁i ▁] ▁> ▁val 2 ▁) ▁{ ▁max i ▁= ▁i ▁; ▁val 2 ▁= ▁a ▁[ ▁i ▁] ▁; ▁} ▁} ▁flag ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁max i ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁> ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁{ ▁flag ▁= ▁0 ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁flag ▁== ▁1 ▁&& ▁max i ▁+ ▁1 ▁== ▁mini ▁) ▁{ ▁flag ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁mini ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁> ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁{ ▁flag ▁= ▁0 ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁flag ▁== ▁1 ▁) ▁return ▁true ▁; ▁} ▁flag ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁mini ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁< ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁{ ▁flag ▁= ▁0 ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁flag ▁== ▁1 ▁&& ▁max i ▁- ▁1 ▁== ▁mini ▁) ▁{ ▁flag ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁max i ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁< ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁{ ▁flag ▁= ▁0 ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁flag ▁== ▁1 ▁) ▁return ▁true ▁; ▁} ▁return ▁false ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁5 ▁, ▁6 ▁, ▁2 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁a ▁. ▁length ▁; ▁if ▁( ▁isP ossible ▁( ▁a ▁, ▁n ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁numberOf Digits ▁( ▁int ▁n ▁) ▁{ ▁int ▁cnt ▁= ▁0 ▁; ▁while ▁( ▁n ▁> ▁0 ▁) ▁{ ▁cnt ▁++ ▁; ▁n ▁/= ▁10 ▁; ▁} ▁return ▁cnt ▁; ▁} ▁static ▁void ▁cal ▁( ▁int ▁num ▁) ▁{ ▁int ▁digits ▁= ▁numberOf Digits ▁( ▁num ▁) ▁; ▁int ▁pow Ten ▁= ▁( ▁int ▁) ▁Math ▁. ▁pow ▁( ▁10 ▁, ▁digits ▁- ▁1 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁digits ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁int ▁first Digit ▁= ▁num ▁/ ▁pow Ten ▁; ▁int ▁left ▁= ▁( ▁( ▁num ▁* ▁10 ▁) ▁+ ▁first Digit ▁) ▁- ▁( ▁first Digit ▁* ▁pow Ten ▁* ▁10 ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁left ▁+ ▁" ▁" ▁) ▁; ▁num ▁= ▁left ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁num ▁= ▁14 45 ▁; ▁cal ▁( ▁num ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁Check K C ycles ▁( ▁int ▁n ▁, ▁String ▁s ▁) ▁{ ▁boolean ▁ff ▁= ▁true ▁; ▁int ▁x ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁x ▁= ▁( ▁s ▁. ▁substring ▁( ▁i ▁) ▁+ ▁s ▁. ▁substring ▁( ▁0 ▁, ▁i ▁) ▁) ▁. ▁length ▁( ▁) ▁; ▁if ▁( ▁x ▁>= ▁s ▁. ▁length ▁( ▁) ▁) ▁{ ▁continue ▁; ▁} ▁ff ▁= ▁false ▁; ▁break ▁; ▁} ▁if ▁( ▁ff ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁3 ▁; ▁String ▁s ▁= ▁"123" ▁; ▁Check K C ycles ▁( ▁n ▁, ▁s ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁generate Numbers ▁( ▁int ▁m ▁) ▁{ ▁ArrayList ▁< ▁Integer ▁> ▁numbers ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁int ▁k _ max ▁, ▁x ▁; ▁for ▁( ▁int ▁y ▁= ▁0 ▁; ▁y ▁< ▁10 ▁; ▁y ▁++ ▁) ▁{ ▁k _ max ▁= ▁( ▁int ▁) ▁( ▁Math ▁. ▁pow ▁( ▁10 ▁, ▁m ▁- ▁2 ▁) ▁* ▁( ▁10 ▁* ▁y ▁+ ▁1 ▁) ▁) ▁/ ▁( ▁int ▁) ▁( ▁Math ▁. ▁pow ▁( ▁10 ▁, ▁m ▁- ▁1 ▁) ▁+ ▁y ▁) ▁; ▁for ▁( ▁int ▁k ▁= ▁1 ▁; ▁k ▁<= ▁k _ max ▁; ▁k ▁++ ▁) ▁{ ▁x ▁= ▁( ▁int ▁) ▁( ▁y ▁* ▁( ▁Math ▁. ▁pow ▁( ▁10 ▁, ▁m ▁- ▁1 ▁) ▁- ▁k ▁) ▁) ▁/ ▁( ▁10 ▁* ▁k ▁- ▁1 ▁) ▁; ▁if ▁( ▁( ▁int ▁) ▁( ▁y ▁* ▁( ▁Math ▁. ▁pow ▁( ▁10 ▁, ▁m ▁- ▁1 ▁) ▁- ▁k ▁) ▁) ▁% ▁( ▁10 ▁* ▁k ▁- ▁1 ▁) ▁== ▁0 ▁) ▁numbers ▁. ▁add ▁( ▁10 ▁* ▁x ▁+ ▁y ▁) ▁; ▁} ▁} ▁Collections ▁. ▁sort ▁( ▁numbers ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁numbers ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁numbers ▁. ▁get ▁( ▁i ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁m ▁= ▁3 ▁; ▁generate Numbers ▁( ▁m ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁N ▁= ▁4 ▁; ▁static ▁void ▁rotate 90 Clock wise ▁( ▁int ▁arr ▁[ ▁] ▁[ ▁] ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁N ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+ ▁" ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁, ▁{ ▁5 ▁, ▁6 ▁, ▁7 ▁, ▁8 ▁} ▁, ▁{ ▁9 ▁, ▁10 ▁, ▁11 ▁, ▁12 ▁} ▁, ▁{ ▁13 ▁, ▁14 ▁, ▁15 ▁, ▁16 ▁} ▁} ▁; ▁rotate 90 Clock wise ▁( ▁arr ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁find Start IndexOf Array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁low ▁, ▁int ▁high ▁) ▁{ ▁if ▁( ▁low ▁> ▁high ▁) ▁{ ▁return ▁- ▁1 ▁; ▁} ▁if ▁( ▁low ▁== ▁high ▁) ▁{ ▁return ▁low ▁; ▁} ▁int ▁mid ▁= ▁low ▁+ ▁( ▁high ▁- ▁low ▁) ▁/ ▁2 ▁; ▁if ▁( ▁arr ▁[ ▁mid ▁] ▁> ▁arr ▁[ ▁mid ▁+ ▁1 ▁] ▁) ▁{ ▁return ▁mid ▁+ ▁1 ▁; ▁} ▁if ▁( ▁arr ▁[ ▁mid ▁- ▁1 ▁] ▁> ▁arr ▁[ ▁mid ▁] ▁) ▁{ ▁return ▁mid ▁; ▁} ▁if ▁( ▁arr ▁[ ▁low ▁] ▁> ▁arr ▁[ ▁mid ▁] ▁) ▁{ ▁return ▁find Start IndexOf Array ▁( ▁arr ▁, ▁low ▁, ▁mid ▁- ▁1 ▁) ▁; ▁} ▁else ▁{ ▁return ▁find Start IndexOf Array ▁( ▁arr ▁, ▁mid ▁+ ▁1 ▁, ▁high ▁) ▁; ▁} ▁} ▁static ▁void ▁restore Sorted Array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁0 ▁] ▁< ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁) ▁{ ▁return ▁; ▁} ▁int ▁start ▁= ▁find Start IndexOf Array ▁( ▁arr ▁, ▁0 ▁, ▁n ▁- ▁1 ▁) ▁; ▁Arrays ▁. ▁sort ▁( ▁arr ▁, ▁0 ▁, ▁start ▁) ▁; ▁Arrays ▁. ▁sort ▁( ▁arr ▁, ▁start ▁, ▁n ▁) ▁; ▁Arrays ▁. ▁sort ▁( ▁arr ▁) ▁; ▁} ▁static ▁void ▁print Array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁size ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁restore Sorted Array ▁( ▁arr ▁, ▁n ▁) ▁; ▁print Array ▁( ▁arr ▁, ▁n ▁) ▁; ▁} ▁}
▁static ▁class ▁Node ▁{ ▁int ▁data ▁; ▁Node ▁next ▁; ▁} ▁;
▁class ▁G F G ▁{ ▁static ▁class ▁Node ▁{ ▁int ▁data ▁; ▁Node ▁next ▁; ▁} ▁; ▁static ▁Node ▁push ▁( ▁Node ▁head _ ref ▁, ▁int ▁data ▁) ▁{ ▁Node ▁ptr 1 ▁= ▁new ▁Node ▁( ▁) ▁; ▁Node ▁temp ▁= ▁head _ ref ▁; ▁ptr 1 ▁. ▁data ▁= ▁data ▁; ▁ptr 1 ▁. ▁next ▁= ▁head _ ref ▁; ▁if ▁( ▁head _ ref ▁!= ▁null ▁) ▁{ ▁while ▁( ▁temp ▁. ▁next ▁!= ▁head _ ref ▁) ▁temp ▁= ▁temp ▁. ▁next ▁; ▁temp ▁. ▁next ▁= ▁ptr 1 ▁; ▁} ▁else ▁ptr 1 ▁. ▁next ▁= ▁ptr 1 ▁; ▁head _ ref ▁= ▁ptr 1 ▁; ▁return ▁head _ ref ▁; ▁} ▁static ▁void ▁delete Node ▁( ▁Node ▁head _ ref ▁, ▁Node ▁del ▁) ▁{ ▁if ▁( ▁head _ ref ▁== ▁del ▁) ▁head _ ref ▁= ▁del ▁. ▁next ▁; ▁Node ▁temp ▁= ▁head _ ref ▁; ▁while ▁( ▁temp ▁. ▁next ▁!= ▁del ▁) ▁{ ▁temp ▁= ▁temp ▁. ▁next ▁; ▁} ▁temp ▁. ▁next ▁= ▁del ▁. ▁next ▁; ▁System ▁. ▁gc ▁( ▁) ▁; ▁return ▁; ▁} ▁static ▁boolean ▁is Even Par ity ▁( ▁int ▁x ▁) ▁{ ▁int ▁par ity ▁= ▁0 ▁; ▁while ▁( ▁x ▁!= ▁0 ▁) ▁{ ▁if ▁( ▁( ▁x ▁& ▁1 ▁) ▁!= ▁0 ▁) ▁par ity ▁++ ▁; ▁x ▁= ▁x ▁>> ▁1 ▁; ▁} ▁if ▁( ▁par ity ▁% ▁2 ▁== ▁0 ▁) ▁return ▁true ▁; ▁else ▁return ▁false ▁; ▁} ▁static ▁void ▁delete Even Par ity Nodes ▁( ▁Node ▁head ▁) ▁{ ▁if ▁( ▁head ▁== ▁null ▁) ▁return ▁; ▁if ▁( ▁head ▁== ▁head ▁. ▁next ▁) ▁{ ▁if ▁( ▁is Even Par ity ▁( ▁head ▁. ▁data ▁) ▁) ▁head ▁= ▁null ▁; ▁return ▁; ▁} ▁Node ▁ptr ▁= ▁head ▁; ▁Node ▁next ▁; ▁do ▁{ ▁next ▁= ▁ptr ▁. ▁next ▁; ▁if ▁( ▁is Even Par ity ▁( ▁ptr ▁. ▁data ▁) ▁) ▁delete Node ▁( ▁head ▁, ▁ptr ▁) ▁; ▁ptr ▁= ▁next ▁; ▁} ▁while ▁( ▁ptr ▁!= ▁head ▁) ▁; ▁if ▁( ▁head ▁== ▁head ▁. ▁next ▁) ▁{ ▁if ▁( ▁is Even Par ity ▁( ▁head ▁. ▁data ▁) ▁) ▁head ▁= ▁null ▁; ▁return ▁; ▁} ▁} ▁static ▁void ▁print List ▁( ▁Node ▁head ▁) ▁{ ▁if ▁( ▁head ▁== ▁null ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" Empty ▁List NEW _ LINE "); ▁return ▁; ▁} ▁Node ▁temp ▁= ▁head ▁; ▁if ▁( ▁head ▁!= ▁null ▁) ▁{ ▁do ▁{ ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁% ▁d ▁" ▁, ▁temp ▁. ▁data ▁) ▁; ▁temp ▁= ▁temp ▁. ▁next ▁; ▁} ▁while ▁( ▁temp ▁!= ▁head ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Node ▁head ▁= ▁null ▁; ▁head ▁= ▁push ▁( ▁head ▁, ▁21 ▁) ▁; ▁head ▁= ▁push ▁( ▁head ▁, ▁13 ▁) ▁; ▁head ▁= ▁push ▁( ▁head ▁, ▁6 ▁) ▁; ▁head ▁= ▁push ▁( ▁head ▁, ▁34 ▁) ▁; ▁head ▁= ▁push ▁( ▁head ▁, ▁9 ▁) ▁; ▁head ▁= ▁push ▁( ▁head ▁, ▁11 ▁) ▁; ▁delete Even Par ity Nodes ▁( ▁head ▁) ▁; ▁print List ▁( ▁head ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁class ▁Node ▁{ ▁int ▁data ▁; ▁Node ▁next ▁; ▁} ▁; ▁static ▁Node ▁push ▁( ▁Node ▁head _ ref ▁, ▁int ▁data ▁) ▁{ ▁Node ▁ptr 1 ▁= ▁new ▁Node ▁( ▁) ▁; ▁Node ▁temp ▁= ▁head _ ref ▁; ▁ptr 1 ▁. ▁data ▁= ▁data ▁; ▁ptr 1 ▁. ▁next ▁= ▁head _ ref ▁; ▁if ▁( ▁head _ ref ▁!= ▁null ▁) ▁{ ▁while ▁( ▁temp ▁. ▁next ▁!= ▁head _ ref ▁) ▁temp ▁= ▁temp ▁. ▁next ▁; ▁temp ▁. ▁next ▁= ▁ptr 1 ▁; ▁} ▁else ▁ptr 1 ▁. ▁next ▁= ▁ptr 1 ▁; ▁head _ ref ▁= ▁ptr 1 ▁; ▁return ▁head _ ref ▁; ▁} ▁static ▁void ▁delete Node ▁( ▁Node ▁head _ ref ▁, ▁Node ▁del ▁) ▁{ ▁Node ▁temp ▁= ▁head _ ref ▁; ▁if ▁( ▁head _ ref ▁== ▁del ▁) ▁head _ ref ▁= ▁del ▁. ▁next ▁; ▁while ▁( ▁temp ▁. ▁next ▁!= ▁del ▁) ▁{ ▁temp ▁= ▁temp ▁. ▁next ▁; ▁} ▁temp ▁. ▁next ▁= ▁del ▁. ▁next ▁; ▁del ▁= ▁null ▁; ▁return ▁; ▁} ▁static ▁int ▁digit Sum ▁( ▁int ▁num ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁while ▁( ▁num ▁> ▁0 ▁) ▁{ ▁sum ▁+= ▁( ▁num ▁% ▁10 ▁) ▁; ▁num ▁/= ▁10 ▁; ▁} ▁return ▁sum ▁; ▁} ▁static ▁void ▁delete Even Digit Sum Nodes ▁( ▁Node ▁head ▁) ▁{ ▁Node ▁ptr ▁= ▁head ▁; ▁Node ▁next ▁; ▁do ▁{ ▁if ▁( ▁! ▁( ▁digit Sum ▁( ▁ptr ▁. ▁data ▁) ▁% ▁2 ▁== ▁1 ▁) ▁) ▁delete Node ▁( ▁head ▁, ▁ptr ▁) ▁; ▁next ▁= ▁ptr ▁. ▁next ▁; ▁ptr ▁= ▁next ▁; ▁} ▁while ▁( ▁ptr ▁!= ▁head ▁) ▁; ▁} ▁static ▁void ▁print List ▁( ▁Node ▁head ▁) ▁{ ▁Node ▁temp ▁= ▁head ▁; ▁if ▁( ▁head ▁!= ▁null ▁) ▁{ ▁do ▁{ ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁% ▁d ▁" ▁, ▁temp ▁. ▁data ▁) ▁; ▁temp ▁= ▁temp ▁. ▁next ▁; ▁} ▁while ▁( ▁temp ▁!= ▁head ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Node ▁head ▁= ▁null ▁; ▁head ▁= ▁push ▁( ▁head ▁, ▁21 ▁) ▁; ▁head ▁= ▁push ▁( ▁head ▁, ▁13 ▁) ▁; ▁head ▁= ▁push ▁( ▁head ▁, ▁6 ▁) ▁; ▁head ▁= ▁push ▁( ▁head ▁, ▁34 ▁) ▁; ▁head ▁= ▁push ▁( ▁head ▁, ▁11 ▁) ▁; ▁head ▁= ▁push ▁( ▁head ▁, ▁9 ▁) ▁; ▁delete Even Digit Sum Nodes ▁( ▁head ▁) ▁; ▁print List ▁( ▁head ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁class ▁Node ▁{ ▁int ▁data ▁; ▁Node ▁next ▁; ▁Node ▁prev ▁; ▁} ▁; ▁static ▁Node ▁insert Node ▁( ▁Node ▁start ▁, ▁int ▁value ▁) ▁{ ▁if ▁( ▁start ▁== ▁null ▁) ▁{ ▁Node ▁new _ node ▁= ▁new ▁Node ▁( ▁) ▁; ▁new _ node ▁. ▁data ▁= ▁value ▁; ▁new _ node ▁. ▁next ▁= ▁new _ node ▁. ▁prev ▁= ▁new _ node ▁; ▁start ▁= ▁new _ node ▁; ▁return ▁new _ node ▁; ▁} ▁Node ▁last ▁= ▁( ▁start ▁) ▁. ▁prev ▁; ▁Node ▁new _ node ▁= ▁new ▁Node ▁( ▁) ▁; ▁new _ node ▁. ▁data ▁= ▁value ▁; ▁new _ node ▁. ▁next ▁= ▁start ▁; ▁( ▁start ▁) ▁. ▁prev ▁= ▁new _ node ▁; ▁new _ node ▁. ▁prev ▁= ▁last ▁; ▁last ▁. ▁next ▁= ▁new _ node ▁; ▁return ▁start ▁; ▁} ▁static ▁void ▁display List ▁( ▁Node ▁start ▁) ▁{ ▁Node ▁temp ▁= ▁start ▁; ▁while ▁( ▁temp ▁. ▁next ▁!= ▁start ▁) ▁{ ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁% ▁d ▁" ▁, ▁temp ▁. ▁data ▁) ▁; ▁temp ▁= ▁temp ▁. ▁next ▁; ▁} ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁% ▁d ▁" ▁, ▁temp ▁. ▁data ▁) ▁; ▁} ▁static ▁int ▁search List ▁( ▁Node ▁start ▁, ▁int ▁search ▁) ▁{ ▁Node ▁temp ▁= ▁start ▁; ▁int ▁count ▁= ▁0 ▁, ▁flag ▁= ▁0 ▁, ▁value ▁; ▁if ▁( ▁temp ▁== ▁null ▁) ▁return ▁- ▁1 ▁; ▁else ▁{ ▁while ▁( ▁temp ▁. ▁next ▁!= ▁start ▁) ▁{ ▁count ▁++ ▁; ▁if ▁( ▁temp ▁. ▁data ▁== ▁search ▁) ▁{ ▁flag ▁= ▁1 ▁; ▁count ▁-- ▁; ▁break ▁; ▁} ▁temp ▁= ▁temp ▁. ▁next ▁; ▁} ▁if ▁( ▁temp ▁. ▁data ▁== ▁search ▁) ▁{ ▁count ▁++ ▁; ▁flag ▁= ▁1 ▁; ▁} ▁if ▁( ▁flag ▁== ▁1 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁" ▁+ ▁search ▁+ ▁" ▁found ▁at ▁location ▁"+ ▁count ); ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁" ▁+ ▁search ▁+ ▁" ▁not ▁found ▁"); ▁} ▁return ▁- ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁Node ▁start ▁= ▁null ▁; ▁start ▁= ▁insert Node ▁( ▁start ▁, ▁4 ▁) ▁; ▁start ▁= ▁insert Node ▁( ▁start ▁, ▁5 ▁) ▁; ▁start ▁= ▁insert Node ▁( ▁start ▁, ▁7 ▁) ▁; ▁start ▁= ▁insert Node ▁( ▁start ▁, ▁8 ▁) ▁; ▁start ▁= ▁insert Node ▁( ▁start ▁, ▁6 ▁) ▁; ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁Created ▁circular ▁doub ly ▁linked ▁list ▁is ▁: ▁" ▁) ▁; ▁display List ▁( ▁start ▁) ▁; ▁search List ▁( ▁start ▁, ▁5 ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁final ▁int ▁MAX ▁= ▁1000 ▁; ▁static ▁int ▁[ ▁] ▁weight ▁= ▁new ▁int ▁[ ▁MAX ▁] ▁; ▁static ▁int ▁[ ▁] ▁level ▁= ▁new ▁int ▁[ ▁MAX ▁] ▁; ▁static ▁int ▁[ ▁] ▁par ▁= ▁new ▁int ▁[ ▁MAX ▁] ▁; ▁static ▁boolean ▁[ ▁] ▁prime ▁= ▁new ▁boolean ▁[ ▁MAX ▁+ ▁1 ▁] ▁; ▁static ▁Vector ▁< ▁Integer ▁> ▁[ ▁] ▁graph ▁= ▁new ▁Vector ▁[ ▁MAX ▁] ▁; ▁static ▁void ▁S ieve Of E rat ost hen es ▁( ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁prime ▁. ▁length ▁; ▁i ▁++ ▁) ▁prime ▁[ ▁i ▁] ▁= ▁true ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁* ▁p ▁<= ▁MAX ▁; ▁p ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁p ▁] ▁== ▁true ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁p ▁* ▁p ▁; ▁i ▁<= ▁MAX ▁; ▁i ▁+= ▁p ▁) ▁prime ▁[ ▁i ▁] ▁= ▁false ▁; ▁} ▁} ▁} ▁static ▁void ▁dfs ▁( ▁int ▁node ▁, ▁int ▁parent ▁, ▁int ▁h ▁) ▁{ ▁par ▁[ ▁node ▁] ▁= ▁parent ▁; ▁level ▁[ ▁node ▁] ▁= ▁h ▁; ▁for ▁( ▁int ▁child ▁: ▁graph ▁[ ▁node ▁] ▁) ▁{ ▁if ▁( ▁child ▁== ▁parent ▁) ▁continue ▁; ▁dfs ▁( ▁child ▁, ▁node ▁, ▁h ▁+ ▁1 ▁) ▁; ▁} ▁} ▁static ▁int ▁find Prime On Path ▁( ▁int ▁u ▁, ▁int ▁v ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁if ▁( ▁level ▁[ ▁u ▁] ▁> ▁level ▁[ ▁v ▁] ▁) ▁{ ▁int ▁temp ▁= ▁v ▁; ▁v ▁= ▁u ▁; ▁u ▁= ▁temp ▁; ▁} ▁int ▁d ▁= ▁level ▁[ ▁v ▁] ▁- ▁level ▁[ ▁u ▁] ▁; ▁while ▁( ▁d ▁-- ▁> ▁0 ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁weight ▁[ ▁v ▁] ▁] ▁) ▁count ▁++ ▁; ▁v ▁= ▁par ▁[ ▁v ▁] ▁; ▁} ▁if ▁( ▁v ▁== ▁u ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁weight ▁[ ▁v ▁] ▁] ▁) ▁count ▁++ ▁; ▁return ▁count ▁; ▁} ▁while ▁( ▁v ▁!= ▁u ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁weight ▁[ ▁v ▁] ▁] ▁) ▁count ▁++ ▁; ▁if ▁( ▁prime ▁[ ▁weight ▁[ ▁u ▁] ▁] ▁) ▁count ▁++ ▁; ▁u ▁= ▁par ▁[ ▁u ▁] ▁; ▁v ▁= ▁par ▁[ ▁v ▁] ▁; ▁} ▁if ▁( ▁prime ▁[ ▁weight ▁[ ▁v ▁] ▁] ▁) ▁count ▁++ ▁; ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁graph ▁. ▁length ▁; ▁i ▁++ ▁) ▁graph ▁[ ▁i ▁] ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁S ieve Of E rat ost hen es ▁( ▁) ▁; ▁weight ▁[ ▁1 ▁] ▁= ▁5 ▁; ▁weight ▁[ ▁2 ▁] ▁= ▁10 ▁; ▁weight ▁[ ▁3 ▁] ▁= ▁11 ▁; ▁weight ▁[ ▁4 ▁] ▁= ▁8 ▁; ▁weight ▁[ ▁5 ▁] ▁= ▁6 ▁; ▁graph ▁[ ▁1 ▁] ▁. ▁add ▁( ▁2 ▁) ▁; ▁graph ▁[ ▁2 ▁] ▁. ▁add ▁( ▁3 ▁) ▁; ▁graph ▁[ ▁2 ▁] ▁. ▁add ▁( ▁4 ▁) ▁; ▁graph ▁[ ▁1 ▁] ▁. ▁add ▁( ▁5 ▁) ▁; ▁dfs ▁( ▁1 ▁, ▁- ▁1 ▁, ▁0 ▁) ▁; ▁int ▁u ▁= ▁3 ▁, ▁v ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁find Prime On Path ▁( ▁u ▁, ▁v ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁class ▁Node ▁{ ▁Node ▁left ▁; ▁Node ▁right ▁; ▁int ▁data ▁; ▁} ▁; ▁static ▁Node ▁newNode ▁( ▁int ▁key ▁) ▁{ ▁Node ▁node ▁= ▁new ▁Node ▁( ▁) ▁; ▁node ▁. ▁left ▁= ▁node ▁. ▁right ▁= ▁null ▁; ▁node ▁. ▁data ▁= ▁key ▁; ▁return ▁node ▁; ▁} ▁static ▁Vector ▁< ▁Integer ▁> ▁path ▁; ▁static ▁boolean ▁Find Path ▁( ▁Node ▁root ▁, ▁int ▁key ▁) ▁{ ▁if ▁( ▁root ▁== ▁null ▁) ▁return ▁false ▁; ▁path ▁. ▁add ▁( ▁root ▁. ▁data ▁) ▁; ▁if ▁( ▁root ▁. ▁data ▁== ▁key ▁) ▁return ▁true ▁; ▁if ▁( ▁Find Path ▁( ▁root ▁. ▁left ▁, ▁key ▁) ▁|| ▁Find Path ▁( ▁root ▁. ▁right ▁, ▁key ▁) ▁) ▁return ▁true ▁; ▁path ▁. ▁remove ▁( ▁path ▁. ▁size ▁( ▁) ▁- ▁1 ▁) ▁; ▁return ▁false ▁; ▁} ▁static ▁int ▁min Max Node In Path ▁( ▁Node ▁root ▁, ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁path ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁boolean ▁flag ▁= ▁true ▁; ▁Vector ▁< ▁Integer ▁> ▁Path 2 ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁, ▁Path 1 ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁int ▁min 1 ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁int ▁max 1 ▁= ▁Integer ▁. ▁MIN _ VALUE ▁; ▁int ▁min 2 ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁int ▁max 2 ▁= ▁Integer ▁. ▁MIN _ VALUE ▁; ▁int ▁i ▁= ▁0 ▁; ▁int ▁j ▁= ▁0 ▁; ▁flag ▁= ▁Find Path ▁( ▁root ▁, ▁a ▁) ▁; ▁Path 1 ▁= ▁path ▁; ▁path ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁flag ▁&= ▁Find Path ▁( ▁root ▁, ▁b ▁) ▁; ▁Path 2 ▁= ▁path ▁; ▁if ▁( ▁flag ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁Path 1 ▁. ▁size ▁( ▁) ▁&& ▁i ▁< ▁Path 2 ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁if ▁( ▁Path 1 ▁. ▁get ▁( ▁i ▁) ▁!= ▁Path 2 ▁. ▁get ▁( ▁i ▁) ▁) ▁break ▁; ▁i ▁-- ▁; ▁j ▁= ▁i ▁; ▁for ▁( ▁; ▁i ▁< ▁Path 1 ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁min 1 ▁> ▁Path 1 ▁. ▁get ▁( ▁i ▁) ▁) ▁min 1 ▁= ▁Path 1 ▁. ▁get ▁( ▁i ▁) ▁; ▁if ▁( ▁max 1 ▁< ▁Path 1 ▁. ▁get ▁( ▁i ▁) ▁) ▁max 1 ▁= ▁Path 1 ▁. ▁get ▁( ▁i ▁) ▁; ▁} ▁for ▁( ▁; ▁j ▁< ▁Path 2 ▁. ▁size ▁( ▁) ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁min 2 ▁> ▁Path 2 ▁. ▁get ▁( ▁j ▁) ▁) ▁min 2 ▁= ▁Path 2 ▁. ▁get ▁( ▁j ▁) ▁; ▁if ▁( ▁max 2 ▁< ▁Path 2 ▁. ▁get ▁( ▁j ▁) ▁) ▁max 2 ▁= ▁Path 2 ▁. ▁get ▁( ▁j ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Min ▁= ▁" ▁+ ▁Math ▁. ▁min ▁( ▁min 1 ▁, ▁min 2 ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Max ▁= ▁" ▁+ ▁Math ▁. ▁max ▁( ▁max 1 ▁, ▁max 2 ▁) ▁) ▁; ▁} ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" Min ▁= ▁-1 ▁Max ▁= ▁- ▁1 ▁"); ▁return ▁0 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁Node ▁root ▁= ▁newNode ▁( ▁20 ▁) ▁; ▁root ▁. ▁left ▁= ▁newNode ▁( ▁8 ▁) ▁; ▁root ▁. ▁right ▁= ▁newNode ▁( ▁22 ▁) ▁; ▁root ▁. ▁left ▁. ▁left ▁= ▁newNode ▁( ▁5 ▁) ▁; ▁root ▁. ▁left ▁. ▁right ▁= ▁newNode ▁( ▁3 ▁) ▁; ▁root ▁. ▁right ▁. ▁left ▁= ▁newNode ▁( ▁4 ▁) ▁; ▁root ▁. ▁right ▁. ▁right ▁= ▁newNode ▁( ▁25 ▁) ▁; ▁root ▁. ▁left ▁. ▁right ▁. ▁left ▁= ▁newNode ▁( ▁10 ▁) ▁; ▁root ▁. ▁left ▁. ▁right ▁. ▁right ▁= ▁newNode ▁( ▁14 ▁) ▁; ▁int ▁a ▁= ▁5 ▁; ▁int ▁b ▁= ▁14 ▁; ▁min Max Node In Path ▁( ▁root ▁, ▁a ▁, ▁b ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁final ▁int ▁MAX N ▁= ▁10000 1 ▁; ▁static ▁Vector ▁< ▁Integer ▁> ▁[ ▁] ▁tree ▁= ▁new ▁Vector ▁[ ▁MAX N ▁] ▁; ▁static ▁int ▁[ ▁] ▁[ ▁] ▁path ▁= ▁new ▁int ▁[ ▁3 ▁] ▁[ ▁MAX N ▁] ▁; ▁static ▁boolean ▁flag ▁; ▁static ▁void ▁dfs ▁( ▁int ▁cur ▁, ▁int ▁prev ▁, ▁int ▁path Number ▁, ▁int ▁ptr ▁, ▁int ▁node ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁tree ▁[ ▁cur ▁] ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁tree ▁[ ▁cur ▁] ▁. ▁get ▁( ▁i ▁) ▁!= ▁prev ▁&& ▁! ▁flag ▁) ▁{ ▁path ▁[ ▁path Number ▁] ▁[ ▁ptr ▁] ▁= ▁tree ▁[ ▁cur ▁] ▁. ▁get ▁( ▁i ▁) ▁; ▁if ▁( ▁tree ▁[ ▁cur ▁] ▁. ▁get ▁( ▁i ▁) ▁== ▁node ▁) ▁{ ▁flag ▁= ▁true ▁; ▁path ▁[ ▁path Number ▁] ▁[ ▁ptr ▁+ ▁1 ▁] ▁= ▁- ▁1 ▁; ▁return ▁; ▁} ▁dfs ▁( ▁tree ▁[ ▁cur ▁] ▁. ▁get ▁( ▁i ▁) ▁, ▁cur ▁, ▁path Number ▁, ▁ptr ▁+ ▁1 ▁, ▁node ▁) ▁; ▁} ▁} ▁} ▁static ▁int ▁L CA ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁if ▁( ▁a ▁== ▁b ▁) ▁return ▁a ▁; ▁path ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁= ▁path ▁[ ▁2 ▁] ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁flag ▁= ▁false ▁; ▁dfs ▁( ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁a ▁) ▁; ▁flag ▁= ▁false ▁; ▁dfs ▁( ▁1 ▁, ▁0 ▁, ▁2 ▁, ▁1 ▁, ▁b ▁) ▁; ▁int ▁i ▁= ▁0 ▁; ▁while ▁( ▁i ▁< ▁MAX N ▁&& ▁path ▁[ ▁1 ▁] ▁[ ▁i ▁] ▁== ▁path ▁[ ▁2 ▁] ▁[ ▁i ▁] ▁) ▁i ▁++ ▁; ▁return ▁path ▁[ ▁1 ▁] ▁[ ▁i ▁- ▁1 ▁] ▁; ▁} ▁static ▁void ▁addEdge ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁tree ▁[ ▁a ▁] ▁. ▁add ▁( ▁b ▁) ▁; ▁tree ▁[ ▁b ▁] ▁. ▁add ▁( ▁a ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁MAX N ▁; ▁i ▁++ ▁) ▁tree ▁[ ▁i ▁] ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁addEdge ▁( ▁1 ▁, ▁2 ▁) ▁; ▁addEdge ▁( ▁1 ▁, ▁3 ▁) ▁; ▁addEdge ▁( ▁2 ▁, ▁4 ▁) ▁; ▁addEdge ▁( ▁2 ▁, ▁5 ▁) ▁; ▁addEdge ▁( ▁2 ▁, ▁6 ▁) ▁; ▁addEdge ▁( ▁3 ▁, ▁7 ▁) ▁; ▁addEdge ▁( ▁3 ▁, ▁8 ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁L CA ▁( ▁4 ▁, ▁7 ▁) ▁= ▁" ▁+ ▁L CA ▁( ▁4 ▁, ▁7 ▁) ▁+ ▁" NEW _ LINE "); ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁L CA ▁( ▁4 ▁, ▁6 ▁) ▁= ▁" ▁+ ▁L CA ▁( ▁4 ▁, ▁6 ▁) ▁+ ▁" NEW _ LINE "); ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁boolean ▁checkIf Div isible ▁( ▁String ▁str ▁, ▁long ▁num ▁) ▁{ ▁long ▁power Of 2 ▁= ▁( ▁int ▁) ▁( ▁Math ▁. ▁log ▁( ▁num ▁) ▁/ ▁Math ▁. ▁log ▁( ▁2 ▁) ▁) ▁; ▁if ▁( ▁str ▁. ▁length ▁( ▁) ▁< ▁power Of 2 ▁) ▁return ▁false ▁; ▁if ▁( ▁power Of 2 ▁== ▁0 ▁) ▁return ▁true ▁; ▁long ▁i ▁, ▁number ▁= ▁0 ▁; ▁int ▁len ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁for ▁( ▁i ▁= ▁len ▁- ▁power Of 2 ▁; ▁i ▁< ▁len ▁; ▁i ▁++ ▁) ▁{ ▁number ▁+= ▁( ▁str ▁. ▁charAt ▁( ▁( ▁int ▁) ▁i ▁) ▁- ▁'0' ▁) ▁* ▁Math ▁. ▁pow ▁( ▁10 ▁, ▁power Of 2 ▁- ▁1 ▁) ▁; ▁power Of 2 ▁-- ▁; ▁} ▁if ▁( ▁number ▁% ▁num ▁!= ▁0 ▁) ▁return ▁false ▁; ▁else ▁return ▁true ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁" 21 346 77 565 64" ▁; ▁long ▁num ▁= ▁4 ▁; ▁if ▁( ▁checkIf Div isible ▁( ▁str ▁, ▁num ▁) ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁longest _ sub array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁d ▁) ▁{ ▁int ▁i ▁= ▁0 ▁, ▁j ▁= ▁1 ▁, ▁e ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁d ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁arr ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁{ ▁j ▁= ▁j ▁+ ▁1 ▁; ▁} ▁else ▁{ ▁j ▁= ▁1 ▁; ▁} ▁if ▁( ▁e ▁< ▁j ▁) ▁{ ▁e ▁= ▁j ▁; ▁} ▁} ▁return ▁e ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁longest _ sub array ▁( ▁arr ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁n ▁= ▁1000 5 ▁; ▁static ▁boolean ▁[ ▁] ▁Prime ▁= ▁new ▁boolean ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁static ▁void ▁S ieve Of E rat ost hen es ▁( ▁) ▁{ ▁int ▁i ▁, ▁j ▁; ▁Prime ▁[ ▁0 ▁] ▁= ▁Prime ▁[ ▁1 ▁] ▁= ▁false ▁; ▁for ▁( ▁i ▁= ▁2 ▁; ▁i ▁* ▁i ▁<= ▁1000 5 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁Prime ▁[ ▁i ▁] ▁) ▁{ ▁for ▁( ▁j ▁= ▁2 ▁* ▁i ▁; ▁j ▁< ▁1000 5 ▁; ▁j ▁+= ▁i ▁) ▁{ ▁Prime ▁[ ▁j ▁] ▁= ▁false ▁; ▁} ▁} ▁} ▁} ▁static ▁void ▁prime Degree Nodes ▁( ▁int ▁N ▁, ▁int ▁M ▁, ▁int ▁edges ▁[ ▁] ▁[ ▁] ▁) ▁{ ▁Vector ▁< ▁Integer ▁> ▁[ ▁] ▁Ad j ▁= ▁new ▁Vector ▁[ ▁N ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁Ad j ▁. ▁length ▁; ▁i ▁++ ▁) ▁Ad j ▁[ ▁i ▁] ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁M ▁; ▁i ▁++ ▁) ▁{ ▁int ▁x ▁= ▁edges ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁; ▁int ▁y ▁= ▁edges ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁; ▁Ad j ▁[ ▁x ▁] ▁. ▁add ▁( ▁y ▁) ▁; ▁Ad j ▁[ ▁y ▁] ▁. ▁add ▁( ▁x ▁) ▁; ▁} ▁S ieve Of E rat ost hen es ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁int ▁x ▁= ▁Ad j ▁[ ▁i ▁] ▁. ▁size ▁( ▁) ▁; ▁if ▁( ▁Prime ▁[ ▁x ▁] ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁i ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁4 ▁, ▁M ▁= ▁6 ▁; ▁int ▁edges ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁} ▁, ▁{ ▁1 ▁, ▁3 ▁} ▁, ▁{ ▁1 ▁, ▁4 ▁} ▁, ▁{ ▁2 ▁, ▁3 ▁} ▁, ▁{ ▁2 ▁, ▁4 ▁} ▁, ▁{ ▁3 ▁, ▁4 ▁} ▁} ▁; ▁Arrays ▁. ▁fill ▁( ▁Prime ▁, ▁true ▁) ▁; ▁prime Degree Nodes ▁( ▁N ▁, ▁M ▁, ▁edges ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁mod ▁= ▁100 000000 7 ▁; ▁static ▁int ▁count W ays ▁( ▁int ▁colored ▁[ ▁] ▁, ▁int ▁count ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁count ▁== ▁n ▁) ▁{ ▁return ▁1 ▁; ▁} ▁int ▁answer ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁colored ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁if ▁( ▁colored ▁[ ▁i ▁- ▁1 ▁] ▁== ▁1 ▁colored ▁[ ▁i ▁+ ▁1 ▁] ▁== ▁1 ▁) ▁{ ▁colored ▁[ ▁i ▁] ▁= ▁1 ▁; ▁answer ▁= ▁( ▁answer ▁+ ▁count W ays ▁( ▁colored ▁, ▁count ▁+ ▁1 ▁, ▁n ▁) ▁) ▁% ▁mod ▁; ▁colored ▁[ ▁i ▁] ▁= ▁0 ▁; ▁} ▁} ▁} ▁return ▁answer ▁; ▁} ▁static ▁int ▁ways To Color ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁colored ▁[ ▁] ▁= ▁new ▁int ▁[ ▁n ▁+ ▁2 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁k ▁; ▁i ▁++ ▁) ▁{ ▁colored ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁= ▁1 ▁; ▁} ▁return ▁count W ays ▁( ▁colored ▁, ▁k ▁, ▁n ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁6 ▁; ▁int ▁K ▁= ▁3 ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁6 ▁} ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁ways To Color ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁check Perm utation ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁int ▁[ ▁] ▁prefix ▁= ▁new ▁int ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁Arrays ▁. ▁fill ▁( ▁prefix ▁, ▁0 ▁) ▁; ▁prefix ▁[ ▁0 ▁] ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁prefix ▁[ ▁i ▁] ▁= ▁prefix ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁arr ▁[ ▁i ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁int ▁l sum ▁= ▁prefix ▁[ ▁i ▁] ▁; ▁int ▁r sum ▁= ▁sum ▁- ▁prefix ▁[ ▁i ▁] ▁; ▁int ▁l _ len ▁= ▁i ▁+ ▁1 ▁, ▁r _ len ▁= ▁n ▁- ▁i ▁- ▁1 ▁; ▁if ▁( ▁( ▁( ▁2 ▁* ▁l sum ▁) ▁== ▁( ▁l _ len ▁* ▁( ▁l _ len ▁+ ▁1 ▁) ▁) ▁) ▁&& ▁( ▁( ▁2 ▁* ▁r sum ▁) ▁== ▁( ▁r _ len ▁* ▁( ▁r _ len ▁+ ▁1 ▁) ▁) ▁) ▁) ▁return ▁true ▁; ▁} ▁return ▁false ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁5 ▁, ▁3 ▁, ▁4 ▁, ▁1 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁if ▁( ▁check Perm utation ▁( ▁arr ▁, ▁n ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁find Next Number ▁( ▁int ▁n ▁) ▁{ ▁int ▁h ▁[ ▁] ▁= ▁new ▁int ▁[ ▁10 ▁] ▁; ▁int ▁i ▁= ▁0 ▁, ▁ms b ▁= ▁n ▁, ▁rem ▁= ▁0 ▁; ▁int ▁next _ num ▁= ▁- ▁1 ▁, ▁count ▁= ▁0 ▁; ▁while ▁( ▁ms b ▁> ▁9 ▁) ▁{ ▁rem ▁= ▁ms b ▁% ▁10 ▁; ▁h ▁[ ▁rem ▁] ▁= ▁1 ▁; ▁ms b ▁/= ▁10 ▁; ▁count ▁++ ▁; ▁} ▁h ▁[ ▁ms b ▁] ▁= ▁1 ▁; ▁count ▁++ ▁; ▁for ▁( ▁i ▁= ▁ms b ▁+ ▁1 ▁; ▁i ▁< ▁10 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁h ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁next _ num ▁= ▁i ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁next _ num ▁== ▁- ▁1 ▁) ▁{ ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁ms b ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁h ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁next _ num ▁= ▁i ▁; ▁count ▁++ ▁; ▁break ▁; ▁} ▁} ▁} ▁if ▁( ▁next _ num ▁> ▁0 ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁10 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁h ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁ms b ▁= ▁i ▁; ▁break ▁; ▁} ▁} ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁count ▁; ▁i ▁++ ▁) ▁{ ▁next _ num ▁= ▁( ▁( ▁next _ num ▁* ▁10 ▁) ▁+ ▁ms b ▁) ▁; ▁} ▁if ▁( ▁next _ num ▁> ▁n ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁next _ num ▁+ ▁" NEW _ LINE "); ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" Not ▁Possible ▁NEW _ LINE "); ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" Not ▁Possible ▁NEW _ LINE "); ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁2019 ▁; ▁find Next Number ▁( ▁n ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁find The Number ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁1 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Imp ossible ▁" ▁+ ▁" NEW _ LINE "); ▁return ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁"5" ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁"4" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁12 ▁; ▁find The Number ▁( ▁n ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁final ▁int ▁MAX N ▁= ▁100000 5 ▁; ▁static ▁int ▁even ▁[ ▁] ▁= ▁new ▁int ▁[ ▁MAX N ▁] ▁; ▁static ▁int ▁odd ▁[ ▁] ▁= ▁new ▁int ▁[ ▁MAX N ▁] ▁; ▁static ▁void ▁pre compute ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁% ▁2 ▁== ▁1 ▁) ▁odd ▁[ ▁i ▁] ▁= ▁1 ▁; ▁if ▁( ▁arr ▁[ ▁i ▁] ▁% ▁2 ▁== ▁0 ▁) ▁even ▁[ ▁i ▁] ▁= ▁1 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁even ▁[ ▁i ▁] ▁= ▁even ▁[ ▁i ▁] ▁+ ▁even ▁[ ▁i ▁- ▁1 ▁] ▁; ▁odd ▁[ ▁i ▁] ▁= ▁odd ▁[ ▁i ▁] ▁+ ▁odd ▁[ ▁i ▁- ▁1 ▁] ▁; ▁} ▁} ▁static ▁boolean ▁is Odd ▁( ▁int ▁L ▁, ▁int ▁R ▁) ▁{ ▁int ▁cnt ▁= ▁odd ▁[ ▁R ▁] ▁; ▁if ▁( ▁L ▁> ▁0 ▁) ▁cnt ▁-= ▁odd ▁[ ▁L ▁- ▁1 ▁] ▁; ▁if ▁( ▁cnt ▁== ▁R ▁- ▁L ▁+ ▁1 ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁static ▁void ▁perform Queries ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁q ▁[ ▁] ▁[ ▁] ▁, ▁int ▁m ▁) ▁{ ▁pre compute ▁( ▁a ▁, ▁n ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁m ▁; ▁i ▁++ ▁) ▁{ ▁int ▁L ▁= ▁q ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁, ▁R ▁= ▁q ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁; ▁if ▁( ▁is Odd ▁( ▁L ▁, ▁R ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁O dd ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Even ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁[ ▁] ▁a ▁= ▁{ ▁2 ▁, ▁1 ▁, ▁5 ▁, ▁7 ▁, ▁6 ▁, ▁8 ▁, ▁9 ▁} ▁; ▁int ▁n ▁= ▁a ▁. ▁length ▁; ▁int ▁q ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁0 ▁, ▁2 ▁} ▁, ▁{ ▁1 ▁, ▁2 ▁} ▁, ▁{ ▁2 ▁, ▁3 ▁} ▁, ▁{ ▁3 ▁, ▁6 ▁} ▁} ▁; ▁int ▁m ▁= ▁q ▁. ▁length ▁; ▁perform Queries ▁( ▁a ▁, ▁n ▁, ▁q ▁, ▁m ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁String ▁getW inner ▁( ▁String ▁str ▁, ▁int ▁len ▁) ▁{ ▁int ▁total ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁len ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁== ▁' ▁S ▁' ▁) ▁{ ▁total ▁++ ▁; ▁} ▁} ▁if ▁( ▁( ▁total ▁% ▁2 ▁) ▁== ▁1 ▁) ▁return ▁" ▁First ▁" ▁; ▁return ▁" ▁Second ▁" ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁" ▁GSS S ▁" ▁; ▁int ▁len ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁getW inner ▁( ▁str ▁, ▁len ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁print Arr ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁static ▁void ▁find Arr angement ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁< ▁2 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁- ▁1" ▁) ▁; ▁return ▁; ▁} ▁int ▁min Val ▁= ▁Arrays ▁. ▁stream ▁( ▁arr ▁) ▁. ▁min ▁( ▁) ▁. ▁getAs Int ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁min Val ▁) ▁{ ▁swap ▁( ▁arr ▁, ▁i ▁, ▁n ▁- ▁1 ▁) ▁; ▁break ▁; ▁} ▁} ▁int ▁and Val ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁and Val ▁&= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁if ▁( ▁and Val ▁== ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁) ▁print Arr ▁( ▁arr ▁, ▁n ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁- ▁1" ▁) ▁; ▁} ▁static ▁int ▁[ ▁] ▁swap ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁i ▁, ▁int ▁j ▁) ▁{ ▁int ▁temp ▁= ▁arr ▁[ ▁i ▁] ▁; ▁arr ▁[ ▁i ▁] ▁= ▁arr ▁[ ▁j ▁] ▁; ▁arr ▁[ ▁j ▁] ▁= ▁temp ▁; ▁return ▁arr ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁5 ▁, ▁3 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁find Arr angement ▁( ▁arr ▁, ▁n ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁max Operations ▁( ▁int ▁X ▁, ▁int ▁Y ▁) ▁{ ▁if ▁( ▁X ▁> ▁Y ▁) ▁return ▁- ▁1 ▁; ▁int ▁diff ▁= ▁Y ▁- ▁X ▁; ▁if ▁( ▁diff ▁== ▁1 ▁) ▁return ▁- ▁1 ▁; ▁if ▁( ▁diff ▁% ▁2 ▁== ▁0 ▁) ▁return ▁( ▁diff ▁/ ▁2 ▁) ▁; ▁return ▁( ▁1 ▁+ ▁( ▁( ▁diff ▁- ▁3 ▁) ▁/ ▁2 ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁X ▁= ▁5 ▁, ▁Y ▁= ▁16 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁max Operations ▁( ▁X ▁, ▁Y ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁print Arr ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁static ▁void ▁random List ▁( ▁int ▁m ▁, ▁int ▁n ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁new ▁int ▁[ ▁m ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁arr ▁[ ▁( ▁int ▁) ▁( ▁Math ▁. ▁random ▁( ▁) ▁* ▁m ▁) ▁] ▁++ ▁; ▁} ▁print Arr ▁( ▁arr ▁, ▁m ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁m ▁= ▁4 ▁, ▁n ▁= ▁8 ▁; ▁random List ▁( ▁m ▁, ▁n ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁find _ maximum _ value ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁int ▁minimum ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁int ▁pos ▁= ▁0 ▁, ▁neg ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁minimum ▁= ▁Math ▁. ▁min ▁( ▁minimum ▁, ▁Math ▁. ▁abs ▁( ▁a ▁[ ▁i ▁] ▁) ▁) ▁; ▁sum ▁+= ▁Math ▁. ▁abs ▁( ▁a ▁[ ▁i ▁] ▁) ▁; ▁if ▁( ▁a ▁[ ▁i ▁] ▁>= ▁0 ▁) ▁pos ▁+= ▁1 ▁; ▁else ▁neg ▁+= ▁1 ▁; ▁} ▁if ▁( ▁pos ▁> ▁0 ▁&& ▁neg ▁> ▁0 ▁) ▁return ▁sum ▁; ▁return ▁( ▁sum ▁- ▁2 ▁* ▁minimum ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁a ▁= ▁{ ▁5 ▁, ▁4 ▁, ▁6 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁a ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find _ maximum _ value ▁( ▁a ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁getMin Val ▁( ▁int ▁p ▁, ▁int ▁q ▁) ▁{ ▁if ▁( ▁q ▁% ▁p ▁== ▁0 ▁) ▁return ▁p ▁; ▁return ▁- ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁p ▁= ▁24 ▁, ▁q ▁= ▁48 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁getMin Val ▁( ▁p ▁, ▁q ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁is _ prefix ▁( ▁String ▁temp ▁, ▁String ▁str ▁) ▁{ ▁if ▁( ▁temp ▁. ▁length ▁( ▁) ▁< ▁str ▁. ▁length ▁( ▁) ▁) ▁return ▁false ▁; ▁else ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁str ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁!= ▁temp ▁. ▁charAt ▁( ▁i ▁) ▁) ▁return ▁false ▁; ▁} ▁return ▁true ▁; ▁} ▁} ▁static ▁String ▁lex ic ograph ically String ▁( ▁String ▁[ ▁] ▁input ▁, ▁int ▁n ▁, ▁String ▁str ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁input ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁String ▁temp ▁= ▁input ▁[ ▁i ▁] ▁; ▁if ▁( ▁is _ prefix ▁( ▁temp ▁, ▁str ▁) ▁) ▁{ ▁return ▁temp ▁; ▁} ▁} ▁return ▁" ▁- ▁1" ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁String ▁[ ▁] ▁arr ▁= ▁{ ▁" ▁apple ▁" ▁, ▁" ▁appe ▁" ▁, ▁" ▁a pl ▁" ▁, ▁" ▁a ap l ▁" ▁, ▁" ▁app ax ▁" ▁} ▁; ▁String ▁S ▁= ▁" ▁app ▁" ▁; ▁int ▁N ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁lex ic ograph ically String ▁( ▁arr ▁, ▁N ▁, ▁S ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁min Sum Pair ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁if ▁( ▁N ▁< ▁5 ▁) ▁{ ▁return ▁- ▁1 ▁; ▁} ▁int ▁[ ▁] ▁prefix Min ▁= ▁new ▁int ▁[ ▁N ▁] ▁; ▁prefix Min ▁[ ▁0 ▁] ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁prefix Min ▁[ ▁i ▁] ▁= ▁Math ▁. ▁min ▁( ▁arr ▁[ ▁i ▁] ▁, ▁prefix Min ▁[ ▁i ▁- ▁1 ▁] ▁) ▁; ▁} ▁int ▁ans ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁for ▁( ▁int ▁i ▁= ▁3 ▁; ▁i ▁< ▁N ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁ans ▁= ▁Math ▁. ▁min ▁( ▁ans ▁, ▁arr ▁[ ▁i ▁] ▁+ ▁prefix Min ▁[ ▁i ▁- ▁2 ▁] ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁2 ▁, ▁4 ▁, ▁6 ▁, ▁3 ▁, ▁7 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁min Sum Pair ▁( ▁arr ▁, ▁N ▁) ▁+ ▁" NEW _ LINE "); ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁void ▁find Count ▁( ▁String ▁number ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁number ▁. ▁length ▁( ▁) ▁; ▁++ ▁i ▁) ▁{ ▁sum ▁+= ▁number ▁. ▁charAt ▁( ▁i ▁) ▁- ▁48 ▁; ▁} ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁number ▁. ▁length ▁( ▁) ▁; ▁++ ▁i ▁) ▁{ ▁int ▁remaining _ sum ▁= ▁sum ▁- ▁( ▁number ▁. ▁charAt ▁( ▁i ▁) ▁- ▁48 ▁) ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁<= ▁9 ▁; ▁++ ▁j ▁) ▁{ ▁if ▁( ▁( ▁remaining _ sum ▁+ ▁j ▁) ▁% ▁3 ▁== ▁0 ▁&& ▁j ▁!= ▁number ▁. ▁charAt ▁( ▁i ▁) ▁- ▁48 ▁) ▁{ ▁++ ▁count ▁; ▁} ▁} ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁count ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁number ▁= ▁"2 35 " ▁; ▁find Count ▁( ▁number ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁long ▁n ▁, ▁m ▁, ▁k ▁, ▁l ▁, ▁r ▁, ▁i ▁; ▁static ▁boolean ▁check ▁( ▁long ▁v ▁, ▁long ▁[ ▁] ▁a ▁) ▁{ ▁long ▁t ec ▁= ▁0 ▁, ▁ans ▁= ▁0 ▁; ▁long ▁[ ▁] ▁b ▁= ▁new ▁long ▁[ ▁( ▁int ▁) ▁( ▁n ▁+ ▁k ▁+ ▁1 ▁) ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁t ec ▁-= ▁b ▁[ ▁i ▁] ▁; ▁if ▁( ▁a ▁[ ▁i ▁] ▁+ ▁t ec ▁< ▁v ▁) ▁{ ▁long ▁mov ▁= ▁v ▁- ▁a ▁[ ▁i ▁] ▁- ▁t ec ▁; ▁ans ▁= ▁ans ▁+ ▁mov ▁; ▁t ec ▁+= ▁mov ▁; ▁b ▁[ ▁i ▁+ ▁( ▁int ▁) ▁k ▁] ▁= ▁mov ▁; ▁} ▁} ▁return ▁ans ▁<= ▁m ▁; ▁} ▁static ▁long ▁Find L argest ▁( ▁long ▁[ ▁] ▁a ▁) ▁{ ▁l ▁= ▁1 ▁; ▁r ▁= ▁( ▁long ▁) ▁Math ▁. ▁pow ▁( ▁10 ▁, ▁10 ▁) ▁; ▁while ▁( ▁r ▁- ▁l ▁> ▁0 ▁) ▁{ ▁long ▁tm ▁= ▁( ▁l ▁+ ▁r ▁+ ▁1 ▁) ▁/ ▁2 ▁; ▁if ▁( ▁check ▁( ▁tm ▁, ▁a ▁) ▁) ▁l ▁= ▁tm ▁; ▁else ▁r ▁= ▁tm ▁- ▁1 ▁; ▁} ▁return ▁l ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁long ▁[ ▁] ▁a ▁= ▁{ ▁2 ▁, ▁2 ▁, ▁2 ▁, ▁2 ▁, ▁1 ▁, ▁1 ▁} ▁; ▁m ▁= ▁2 ▁; ▁k ▁= ▁3 ▁; ▁n ▁= ▁a ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁Find L argest ▁( ▁a ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁number of Boxes ▁( ▁int ▁W ▁, ▁int ▁B ▁, ▁int ▁O ▁) ▁{ ▁int ▁low ▁= ▁0 ▁, ▁high ▁= ▁Math ▁. ▁min ▁( ▁W ▁, ▁B ▁) ▁; ▁int ▁ans ▁= ▁0 ▁; ▁while ▁( ▁low ▁<= ▁high ▁) ▁{ ▁int ▁mid ▁= ▁low ▁+ ▁( ▁high ▁- ▁low ▁) ▁/ ▁2 ▁; ▁if ▁( ▁( ▁( ▁W ▁>= ▁mid ▁) ▁&& ▁( ▁B ▁>= ▁mid ▁) ▁) ▁&& ▁( ▁( ▁W ▁- ▁mid ▁) ▁+ ▁( ▁B ▁- ▁mid ▁) ▁+ ▁O ▁) ▁>= ▁mid ▁) ▁{ ▁ans ▁= ▁mid ▁; ▁low ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁else ▁high ▁= ▁mid ▁- ▁1 ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁ans ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁W ▁= ▁3 ▁, ▁B ▁= ▁3 ▁, ▁O ▁= ▁1 ▁; ▁number of Boxes ▁( ▁W ▁, ▁B ▁, ▁O ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁find Pairs ▁( ▁int ▁A ▁, ▁int ▁B ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁B ▁; ▁i ▁++ ▁) ▁{ ▁int ▁y ▁= ▁A ▁^ ▁i ▁; ▁if ▁( ▁y ▁> ▁0 ▁&& ▁( ▁i ▁y ▁) ▁== ▁B ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁i ▁+ ▁" ▁" ▁+ ▁y ▁) ▁; ▁} ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁A ▁= ▁8 ▁, ▁B ▁= ▁10 ▁; ▁find Pairs ▁( ▁A ▁, ▁B ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁is char ▁( ▁char ▁x ▁) ▁{ ▁if ▁( ▁( ▁x ▁>= ▁' ▁A ▁' ▁&& ▁x ▁<= ▁' ▁Z ▁' ▁) ▁|| ▁( ▁x ▁>= ▁' ▁a ▁' ▁&& ▁x ▁<= ▁' ▁z ▁' ▁) ▁) ▁{ ▁return ▁true ▁; ▁} ▁return ▁false ▁; ▁} ▁static ▁boolean ▁is num ▁( ▁char ▁x ▁) ▁{ ▁if ▁( ▁x ▁>= ▁'0' ▁&& ▁x ▁<= ▁'9' ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁static ▁void ▁find Id and Domain ▁( ▁String ▁S ▁, ▁int ▁N ▁) ▁{ ▁String ▁ID ▁= ▁" ▁" ▁, ▁Domain ▁= ▁" ▁" ▁; ▁Vector ▁< ▁String ▁> ▁words ▁= ▁new ▁Vector ▁< ▁String ▁> ▁( ▁) ▁; ▁String ▁curr ▁= ▁" ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁S ▁. ▁charAt ▁( ▁i ▁) ▁== ▁' ▁' ▁) ▁{ ▁words ▁. ▁add ▁( ▁curr ▁) ▁; ▁curr ▁= ▁" ▁" ▁; ▁} ▁else ▁{ ▁if ▁( ▁S ▁. ▁charAt ▁( ▁i ▁) ▁== ▁' ▁. ▁' ▁) ▁{ ▁if ▁( ▁i ▁+ ▁1 ▁== ▁N ▁|| ▁( ▁i ▁+ ▁1 ▁< ▁N ▁&& ▁S ▁. ▁charAt ▁( ▁i ▁+ ▁1 ▁) ▁== ▁' ▁' ▁) ▁) ▁continue ▁; ▁} ▁curr ▁+= ▁S ▁. ▁charAt ▁( ▁i ▁) ▁; ▁} ▁} ▁if ▁( ▁curr ▁. ▁length ▁( ▁) ▁> ▁0 ▁) ▁words ▁. ▁add ▁( ▁curr ▁) ▁; ▁for ▁( ▁String ▁ss ▁: ▁words ▁) ▁{ ▁if ▁( ▁ss ▁. ▁length ▁( ▁) ▁== ▁10 ▁) ▁{ ▁boolean ▁flag ▁= ▁false ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁<= ▁9 ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁j ▁>= ▁5 ▁&& ▁j ▁< ▁9 ▁) ▁{ ▁if ▁( ▁is num ▁( ▁ss ▁. ▁charAt ▁( ▁j ▁) ▁) ▁== ▁false ▁) ▁flag ▁= ▁true ▁; ▁} ▁else ▁{ ▁if ▁( ▁is char ▁( ▁ss ▁. ▁charAt ▁( ▁j ▁) ▁) ▁== ▁false ▁) ▁flag ▁= ▁true ▁; ▁} ▁} ▁if ▁( ▁! ▁flag ▁) ▁{ ▁ID ▁= ▁ss ▁; ▁} ▁} ▁if ▁( ▁ss ▁. ▁length ▁( ▁) ▁> ▁2 ▁&& ▁ss ▁. ▁substring ▁( ▁0 ▁, ▁3 ▁) ▁. ▁equals ▁( ▁" ▁www ▁" ▁) ▁&& ▁ss ▁. ▁substring ▁( ▁ss ▁. ▁length ▁( ▁) ▁- ▁3 ▁) ▁. ▁equals ▁( ▁" ▁com ▁" ▁) ▁) ▁{ ▁Domain ▁= ▁ss ▁. ▁substring ▁( ▁4 ▁, ▁ss ▁. ▁length ▁( ▁) ▁) ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁ID ▁= ▁" ▁+ ▁ID ▁+ ▁" NEW _ LINE "); ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Domain ▁= ▁" ▁+ ▁Domain ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁S ▁= ▁" ▁We ▁thank ▁ABC DE 1234 F ▁for ▁visiting ▁" ▁+ ▁" ▁us ▁and ▁bu ying ▁products ▁item ▁AM Z rr ▁@ ▁! ▁k ▁. ▁" ▁+ ▁" ▁For ▁more ▁offers ▁, ▁visit ▁us ▁at ▁www ▁. ▁amazon ▁. ▁com ▁" ▁; ▁int ▁N ▁= ▁S ▁. ▁length ▁( ▁) ▁; ▁find Id and Domain ▁( ▁S ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁count Tri pl ets ▁( ▁int ▁D ▁, ▁int ▁[ ▁] ▁arr ▁) ▁{ ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁freq ▁= ▁new ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁( ▁) ▁; ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁arr ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁freq ▁. ▁containsKey ▁( ▁arr ▁[ ▁i ▁] ▁- ▁D ▁) ▁&& ▁freq ▁. ▁containsKey ▁( ▁arr ▁[ ▁i ▁] ▁- ▁2 ▁* ▁D ▁) ▁) ▁{ ▁ans ▁+= ▁freq ▁. ▁get ▁( ▁arr ▁[ ▁i ▁] ▁- ▁D ▁) ▁* ▁freq ▁. ▁get ▁( ▁arr ▁[ ▁i ▁] ▁- ▁2 ▁* ▁D ▁) ▁; ▁} ▁if ▁( ▁freq ▁. ▁containsKey ▁( ▁arr ▁[ ▁i ▁] ▁) ▁) ▁{ ▁freq ▁. ▁put ▁( ▁arr ▁[ ▁i ▁] ▁, ▁freq ▁. ▁get ▁( ▁arr ▁[ ▁i ▁] ▁) ▁+ ▁1 ▁) ▁; ▁} ▁else ▁{ ▁freq ▁. ▁put ▁( ▁arr ▁[ ▁i ▁] ▁, ▁1 ▁) ▁; ▁} ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁4 ▁, ▁5 ▁, ▁7 ▁, ▁8 ▁, ▁10 ▁} ▁; ▁int ▁D ▁= ▁1 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁count Tri pl ets ▁( ▁D ▁, ▁arr ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁boolean ▁bound ▁( ▁int ▁w ▁, ▁int ▁h ▁, ▁int ▁N ▁, ▁int ▁x ▁) ▁{ ▁int ▁val ▁= ▁( ▁x ▁/ ▁w ▁) ▁* ▁( ▁x ▁/ ▁h ▁) ▁; ▁if ▁( ▁val ▁>= ▁N ▁) ▁return ▁true ▁; ▁else ▁return ▁false ▁; ▁} ▁static ▁int ▁Find Square ▁( ▁int ▁N ▁, ▁int ▁W ▁, ▁int ▁H ▁) ▁{ ▁int ▁i ▁= ▁1 ▁; ▁int ▁j ▁= ▁W ▁* ▁H ▁* ▁N ▁; ▁while ▁( ▁i ▁< ▁j ▁) ▁{ ▁int ▁mid ▁= ▁i ▁+ ▁( ▁j ▁- ▁i ▁) ▁/ ▁2 ▁; ▁if ▁( ▁bound ▁( ▁W ▁, ▁H ▁, ▁N ▁, ▁mid ▁) ▁) ▁j ▁= ▁mid ▁; ▁else ▁i ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁return ▁j ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁W ▁= ▁2 ▁; ▁int ▁H ▁= ▁3 ▁; ▁int ▁N ▁= ▁10 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁Find Square ▁( ▁N ▁, ▁W ▁, ▁H ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁S ieve Of E rat ost hen es ▁( ▁boolean ▁prime ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁prime ▁[ ▁0 ▁] ▁= ▁false ▁; ▁prime ▁[ ▁1 ▁] ▁= ▁false ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁* ▁p ▁<= ▁n ▁; ▁p ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁p ▁] ▁== ▁true ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁p ▁* ▁p ▁; ▁i ▁<= ▁n ▁; ▁i ▁+= ▁p ▁) ▁{ ▁prime ▁[ ▁i ▁] ▁= ▁false ▁; ▁} ▁} ▁} ▁} ▁static ▁void ▁sum Of Prime Square ▁( ▁int ▁n ▁) ▁{ ▁boolean ▁flag ▁= ▁false ▁; ▁boolean ▁[ ▁] ▁prime ▁= ▁new ▁boolean ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁prime ▁. ▁length ▁; ▁i ▁++ ▁) ▁prime ▁[ ▁i ▁] ▁= ▁true ▁; ▁S ieve Of E rat ost hen es ▁( ▁prime ▁, ▁n ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁! ▁prime ▁[ ▁i ▁] ▁) ▁continue ▁; ▁int ▁dif ▁= ▁n ▁- ▁i ▁; ▁if ▁( ▁Math ▁. ▁ceil ▁( ▁( ▁double ▁) ▁Math ▁. ▁sqrt ▁( ▁dif ▁) ▁) ▁== ▁Math ▁. ▁floor ▁( ▁( ▁double ▁) ▁Math ▁. ▁sqrt ▁( ▁dif ▁) ▁) ▁) ▁{ ▁flag ▁= ▁true ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁flag ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Yes ▁" ▁) ▁; ▁} ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁27 ▁; ▁sum Of Prime Square ▁( ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁check ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁M ▁, ▁int ▁K ▁, ▁int ▁ind ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁M ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁< ▁K ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁ind ▁+ ▁i ▁] ▁!= ▁arr ▁[ ▁ind ▁+ ▁i ▁+ ▁j ▁* ▁M ▁] ▁) ▁{ ▁return ▁false ▁; ▁} ▁} ▁} ▁return ▁true ▁; ▁} ▁static ▁boolean ▁Sub array Repe ats K or More ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁M ▁, ▁int ▁K ▁) ▁{ ▁for ▁( ▁int ▁ind ▁= ▁0 ▁; ▁ind ▁<= ▁N ▁- ▁M ▁* ▁K ▁; ▁ind ▁++ ▁) ▁{ ▁if ▁( ▁check ▁( ▁arr ▁, ▁M ▁, ▁K ▁, ▁ind ▁) ▁) ▁{ ▁return ▁true ▁; ▁} ▁} ▁return ▁false ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁1 ▁, ▁2 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁3 ▁} ▁; ▁int ▁M ▁= ▁2 ▁, ▁K ▁= ▁2 ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁if ▁( ▁Sub array Repe ats K or More ▁( ▁arr ▁, ▁N ▁, ▁M ▁, ▁K ▁) ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁minimum Number ▁( ▁int ▁K ▁, ▁int ▁X ▁) ▁{ ▁if ▁( ▁K ▁> ▁X ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁- ▁1" ▁) ▁; ▁return ▁; ▁} ▁int ▁ans ▁= ▁0 ▁; ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁K ▁; ▁i ▁<= ▁X ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁i ▁; ▁if ▁( ▁sum ▁>= ▁X ▁) ▁{ ▁ans ▁= ▁i ▁; ▁break ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁ans ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁K ▁= ▁5 ▁, ▁X ▁= ▁13 ▁; ▁minimum Number ▁( ▁K ▁, ▁X ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁int ▁peak Index ▁( ▁int ▁[ ▁] ▁arr ▁) ▁{ ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁if ▁( ▁arr ▁. ▁length ▁< ▁3 ▁) ▁return ▁- ▁1 ▁; ▁int ▁i ▁= ▁0 ▁; ▁while ▁( ▁i ▁+ ▁1 ▁< ▁N ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁+ ▁1 ▁] ▁< ▁arr ▁[ ▁i ▁] ▁arr ▁[ ▁i ▁] ▁== ▁arr ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁break ▁; ▁i ▁++ ▁; ▁} ▁if ▁( ▁i ▁== ▁0 ▁i ▁== ▁N ▁- ▁1 ▁) ▁return ▁- ▁1 ▁; ▁int ▁ans ▁= ▁i ▁; ▁while ▁( ▁i ▁< ▁N ▁- ▁1 ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁arr ▁[ ▁i ▁+ ▁1 ▁] ▁arr ▁[ ▁i ▁] ▁== ▁arr ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁break ▁; ▁i ▁++ ▁; ▁} ▁if ▁( ▁i ▁== ▁N ▁- ▁1 ▁) ▁return ▁ans ▁; ▁return ▁- ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁0 ▁, ▁1 ▁, ▁0 ▁} ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁peak Index ▁( ▁arr ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁find Pairs ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁arr ▁[ ▁i ▁] ▁= ▁Math ▁. ▁abs ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁Arrays ▁. ▁sort ▁( ▁arr ▁) ▁; ▁int ▁left ▁= ▁0 ▁; ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁right ▁= ▁0 ▁; ▁right ▁< ▁N ▁; ▁right ▁++ ▁) ▁{ ▁while ▁( ▁2 ▁* ▁arr ▁[ ▁left ▁] ▁< ▁arr ▁[ ▁right ▁] ▁) ▁left ▁++ ▁; ▁ans ▁+= ▁( ▁right ▁- ▁left ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁ans ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁5 ▁, ▁7 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁find Pairs ▁( ▁arr ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁even product ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁length ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁arr ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁int ▁product ▁= ▁1 ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁< ▁arr ▁. ▁length ▁; ▁j ▁++ ▁) ▁{ ▁product ▁*= ▁arr ▁[ ▁j ▁] ▁; ▁if ▁( ▁product ▁% ▁2 ▁== ▁0 ▁) ▁++ ▁count ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁count ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁7 ▁, ▁5 ▁, ▁4 ▁, ▁9 ▁} ▁; ▁int ▁length ▁= ▁arr ▁. ▁length ▁- ▁1 ▁; ▁even product ▁( ▁arr ▁, ▁length ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁total W ays ▁( ▁int ▁n ▁, ▁String ▁str ▁) ▁{ ▁ArrayList ▁< ▁Integer ▁> ▁Id x Of 0 s ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁int ▁cnt W ays ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'0' ▁) ▁{ ▁Id x Of 0 s ▁. ▁add ▁( ▁i ▁) ▁; ▁} ▁} ▁int ▁M ▁= ▁Id x Of 0 s ▁. ▁size ▁( ▁) ▁; ▁if ▁( ▁( ▁M ▁== ▁0 ▁) ▁|| ▁( ▁( ▁M ▁% ▁2 ▁) ▁!= ▁0 ▁) ▁) ▁{ ▁return ▁0 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁< ▁M ▁; ▁i ▁+= ▁2 ▁) ▁{ ▁cnt W ays ▁= ▁cnt W ays ▁* ▁( ▁Id x Of 0 s ▁. ▁get ▁( ▁i ▁) ▁- ▁Id x Of 0 s ▁. ▁get ▁( ▁i ▁- ▁1 ▁) ▁) ▁; ▁} ▁return ▁cnt W ays ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁"00 100 " ▁; ▁int ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁total W ays ▁( ▁n ▁, ▁str ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁Count Sub array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁temp ▁= ▁k ▁, ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁temp ▁) ▁{ ▁if ▁( ▁temp ▁== ▁1 ▁) ▁{ ▁count ▁++ ▁; ▁temp ▁= ▁k ▁; ▁} ▁else ▁temp ▁-- ▁; ▁} ▁else ▁{ ▁temp ▁= ▁k ▁; ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁k ▁) ▁i ▁-- ▁; ▁} ▁} ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁7 ▁, ▁9 ▁, ▁3 ▁, ▁2 ▁, ▁1 ▁, ▁8 ▁, ▁3 ▁, ▁2 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁int ▁K ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁Count Sub array ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁count Div is ors ▁( ▁int ▁n ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁int ▁j ▁= ▁0 ▁; ▁int ▁divisor ▁[ ▁] ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁Math ▁. ▁sqrt ▁( ▁n ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁{ ▁if ▁( ▁n ▁/ ▁i ▁== ▁i ▁) ▁{ ▁divisor ▁[ ▁j ▁] ▁= ▁i ▁; ▁j ▁+= ▁1 ▁; ▁} ▁else ▁{ ▁divisor ▁[ ▁j ▁] ▁= ▁i ▁; ▁divisor ▁[ ▁j ▁+ ▁1 ▁] ▁= ▁n ▁/ ▁i ▁; ▁j ▁+= ▁2 ▁; ▁} ▁} ▁} ▁divisor ▁[ ▁j ▁] ▁= ▁n ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁j ▁; ▁i ▁++ ▁) ▁{ ▁int ▁x ▁= ▁divisor ▁[ ▁i ▁] ▁; ▁x ▁-= ▁1 ▁; ▁if ▁( ▁( ▁n ▁/ ▁x ▁) ▁== ▁( ▁n ▁% ▁x ▁) ▁) ▁count ▁++ ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁count ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁10000 000 ▁; ▁count Div is ors ▁( ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁find Max Length ▁( ▁int ▁N ▁, ▁int ▁[ ▁] ▁arr ▁) ▁{ ▁int ▁[ ▁] ▁dp ▁= ▁new ▁int ▁[ ▁N ▁+ ▁1 ▁] ▁; ▁Arrays ▁. ▁fill ▁( ▁dp ▁, ▁1 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁2 ▁* ▁i ▁; ▁j ▁<= ▁N ▁; ▁j ▁+= ▁i ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁< ▁arr ▁[ ▁j ▁- ▁1 ▁] ▁) ▁{ ▁dp ▁[ ▁j ▁] ▁= ▁Math ▁. ▁max ▁( ▁dp ▁[ ▁j ▁] ▁, ▁dp ▁[ ▁i ▁] ▁+ ▁1 ▁) ▁; ▁} ▁} ▁} ▁return ▁Arrays ▁. ▁stream ▁( ▁dp ▁) ▁. ▁max ▁( ▁) ▁. ▁getAs Int ▁( ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁, ▁7 ▁, ▁8 ▁, ▁9 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁find Max Length ▁( ▁N ▁, ▁arr ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁power ▁( ▁int ▁x ▁, ▁int ▁N ▁) ▁{ ▁int ▁res ▁= ▁1 ▁; ▁while ▁( ▁N ▁> ▁0 ▁) ▁{ ▁if ▁( ▁( ▁N ▁& ▁1 ▁) ▁!= ▁0 ▁) ▁{ ▁res ▁= ▁( ▁res ▁* ▁x ▁) ▁; ▁} ▁x ▁= ▁( ▁x ▁* ▁x ▁) ▁; ▁N ▁= ▁N ▁>> ▁1 ▁; ▁} ▁return ▁res ▁; ▁} ▁static ▁void ▁find Val X _ Y ▁( ▁int ▁N ▁) ▁{ ▁if ▁( ▁N ▁<= ▁1 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁- ▁1 ▁) ▁; ▁return ▁; ▁} ▁int ▁x Max ▁; ▁x Max ▁= ▁( ▁int ▁) ▁Math ▁. ▁log ▁( ▁N ▁) ▁; ▁int ▁y Max ▁; ▁y Max ▁= ▁( ▁int ▁) ▁( ▁Math ▁. ▁log ▁( ▁N ▁) ▁/ ▁Math ▁. ▁log ▁( ▁5.0 ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁x Max ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁<= ▁y Max ▁; ▁j ▁++ ▁) ▁{ ▁int ▁a ▁= ▁power ▁( ▁2 ▁, ▁i ▁) ▁; ▁int ▁b ▁= ▁power ▁( ▁5 ▁, ▁j ▁) ▁; ▁if ▁( ▁a ▁+ ▁b ▁== ▁N ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁i ▁+ ▁" ▁" ▁+ ▁j ▁) ▁; ▁return ▁; ▁} ▁} ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁- ▁1" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁N ▁= ▁12 9 ▁; ▁find Val X _ Y ▁( ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁String ▁toggle Query ▁( ▁char ▁[ ▁] ▁str ▁, ▁int ▁Q ▁[ ▁] ▁[ ▁] ▁, ▁int ▁M ▁) ▁{ ▁int ▁N ▁= ▁str ▁. ▁length ▁; ▁int ▁prefix Cnt ▁[ ▁] ▁= ▁new ▁int ▁[ ▁N ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁M ▁; ▁i ▁++ ▁) ▁{ ▁prefix Cnt ▁[ ▁Q ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁] ▁+= ▁1 ▁; ▁prefix Cnt ▁[ ▁Q ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁+ ▁1 ▁] ▁-= ▁1 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁prefix Cnt ▁[ ▁i ▁] ▁+= ▁prefix Cnt ▁[ ▁i ▁- ▁1 ▁] ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁prefix Cnt ▁[ ▁i ▁] ▁% ▁2 ▁== ▁1 ▁) ▁{ ▁str ▁[ ▁i ▁] ▁= ▁( ▁char ▁) ▁( ▁'1' ▁- ▁str ▁[ ▁i ▁] ▁+ ▁'0' ▁) ▁; ▁} ▁} ▁return ▁String ▁. ▁valueOf ▁( ▁str ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁"1 0101 0" ▁; ▁int ▁Q ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁0 ▁, ▁1 ▁} ▁, ▁{ ▁2 ▁, ▁5 ▁} ▁, ▁{ ▁2 ▁, ▁3 ▁} ▁, ▁{ ▁1 ▁, ▁4 ▁} ▁, ▁{ ▁0 ▁, ▁5 ▁} ▁} ▁; ▁int ▁M ▁= ▁Q ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁toggle Query ▁( ▁str ▁. ▁toCharArray ▁( ▁) ▁, ▁Q ▁, ▁M ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁int ▁max i Con secutive Sub array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁max i ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁int ▁cnt ▁= ▁1 ▁, ▁j ▁; ▁for ▁( ▁j ▁= ▁i ▁; ▁j ▁< ▁N ▁- ▁1 ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁j ▁+ ▁1 ▁] ▁== ▁arr ▁[ ▁j ▁] ▁+ ▁1 ▁) ▁{ ▁cnt ▁++ ▁; ▁} ▁else ▁{ ▁break ▁; ▁} ▁} ▁max i ▁= ▁Math ▁. ▁max ▁( ▁max i ▁, ▁cnt ▁) ▁; ▁i ▁= ▁j ▁; ▁} ▁return ▁max i ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁N ▁= ▁11 ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁4 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁2 ▁, ▁3 ▁, ▁5 ▁, ▁6 ▁, ▁7 ▁} ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁max i Con secutive Sub array ▁( ▁arr ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁count Rem ov able Elem ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁N ▁) ▁{ ▁int ▁[ ▁] ▁hash ▁= ▁new ▁int ▁[ ▁N ▁+ ▁1 ▁] ▁; ▁Arrays ▁. ▁fill ▁( ▁hash ▁, ▁0 ▁) ▁; ▁int ▁m ex ▁= ▁N ▁+ ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁<= ▁N ▁) ▁hash ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁= ▁1 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁hash ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁m ex ▁= ▁i ▁; ▁break ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁N ▁- ▁( ▁m ex ▁- ▁1 ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁5 ▁, ▁1 ▁, ▁6 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁count Rem ov able Elem ▁( ▁arr ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁print Indexes ▁( ▁char ▁[ ▁] ▁str ▁) ▁{ ▁int ▁N ▁= ▁str ▁. ▁length ▁; ▁int ▁[ ▁] ▁cnt Freq ▁= ▁new ▁int ▁[ ▁256 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁cnt Freq ▁[ ▁str ▁[ ▁i ▁] ▁] ▁++ ▁; ▁} ▁int ▁[ ▁] ▁cnt Left Freq ▁= ▁new ▁int ▁[ ▁256 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁int ▁cnt Left ▁= ▁0 ▁; ▁int ▁cnt Right ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁str ▁[ ▁i ▁] ▁- ▁1 ▁; ▁j ▁>= ▁0 ▁; ▁j ▁-- ▁) ▁{ ▁cnt Left ▁+= ▁cnt Left Freq ▁[ ▁j ▁] ▁; ▁cnt Right ▁+= ▁cnt Freq ▁[ ▁j ▁] ▁- ▁cnt Left Freq ▁[ ▁j ▁] ▁; ▁} ▁cnt Left Freq ▁[ ▁str ▁[ ▁i ▁] ▁] ▁++ ▁; ▁if ▁( ▁cnt Left ▁== ▁cnt Right ▁&& ▁cnt Left ▁!= ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁i ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁" ▁a ab ac d ab bb ▁" ▁; ▁print Indexes ▁( ▁str ▁. ▁toCharArray ▁( ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁check Concat ▁( ▁String ▁str 1 ▁, ▁String ▁str 2 ▁) ▁{ ▁int ▁N ▁= ▁str 1 ▁. ▁length ▁( ▁) ▁; ▁int ▁M ▁= ▁str 2 ▁. ▁length ▁( ▁) ▁; ▁if ▁( ▁N ▁% ▁M ▁!= ▁0 ▁) ▁{ ▁return ▁false ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁str 1 ▁. ▁charAt ▁( ▁i ▁) ▁!= ▁str 2 ▁. ▁charAt ▁( ▁i ▁% ▁M ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁} ▁return ▁true ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str 1 ▁= ▁" ▁abc abc abc ▁" ▁; ▁String ▁str 2 ▁= ▁" ▁abc ▁" ▁; ▁if ▁( ▁check Concat ▁( ▁str 1 ▁, ▁str 2 ▁) ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Yes ▁" ▁) ▁; ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁count Position ▁( ▁int ▁[ ▁] ▁[ ▁] ▁mat ▁) ▁{ ▁int ▁n ▁= ▁mat ▁. ▁length ▁; ▁int ▁m ▁= ▁mat ▁[ ▁0 ▁] ▁. ▁length ▁; ▁int ▁[ ▁] ▁row ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁int ▁[ ▁] ▁col ▁= ▁new ▁int ▁[ ▁m ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁m ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁== ▁1 ▁) ▁{ ▁col ▁[ ▁j ▁] ▁++ ▁; ▁row ▁[ ▁i ▁] ▁++ ▁; ▁} ▁} ▁} ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁m ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁row ▁[ ▁i ▁] ▁== ▁col ▁[ ▁j ▁] ▁) ▁{ ▁count ▁++ ▁; ▁} ▁} ▁} ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁mat ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁0 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁1 ▁} ▁} ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Position ▁( ▁mat ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁position ▁( ▁int ▁arr ▁[ ▁] ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁pos ▁= ▁- ▁1 ▁; ▁int ▁count ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁<= ▁arr ▁[ ▁j ▁] ▁[ ▁0 ▁] ▁&& ▁arr ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁>= ▁arr ▁[ ▁j ▁] ▁[ ▁1 ▁] ▁) ▁{ ▁count ▁++ ▁; ▁} ▁} ▁if ▁( ▁count ▁== ▁N ▁) ▁{ ▁pos ▁= ▁i ▁; ▁} ▁} ▁if ▁( ▁pos ▁== ▁- ▁1 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁pos ▁) ▁; ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁pos ▁+ ▁1 ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁3 ▁, ▁3 ▁} ▁, ▁{ ▁1 ▁, ▁3 ▁} ▁, ▁{ ▁2 ▁, ▁2 ▁} ▁, ▁{ ▁2 ▁, ▁3 ▁} ▁, ▁{ ▁1 ▁, ▁2 ▁} ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁position ▁( ▁arr ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁mini ▁= ▁105 ▁, ▁ans ▁, ▁n ▁; ▁static ▁Vector ▁< ▁Integer ▁> ▁[ ▁] ▁g ▁= ▁new ▁Vector ▁[ ▁100 ▁] ▁; ▁static ▁int ▁[ ▁] ▁size ▁= ▁new ▁int ▁[ ▁100 ▁] ▁; ▁static ▁void ▁create _ graph ▁( ▁) ▁{ ▁g ▁[ ▁1 ▁] ▁. ▁add ▁( ▁2 ▁) ▁; ▁g ▁[ ▁2 ▁] ▁. ▁add ▁( ▁1 ▁) ▁; ▁g ▁[ ▁1 ▁] ▁. ▁add ▁( ▁3 ▁) ▁; ▁g ▁[ ▁3 ▁] ▁. ▁add ▁( ▁1 ▁) ▁; ▁g ▁[ ▁1 ▁] ▁. ▁add ▁( ▁4 ▁) ▁; ▁g ▁[ ▁4 ▁] ▁. ▁add ▁( ▁1 ▁) ▁; ▁g ▁[ ▁2 ▁] ▁. ▁add ▁( ▁5 ▁) ▁; ▁g ▁[ ▁5 ▁] ▁. ▁add ▁( ▁2 ▁) ▁; ▁g ▁[ ▁2 ▁] ▁. ▁add ▁( ▁6 ▁) ▁; ▁g ▁[ ▁6 ▁] ▁. ▁add ▁( ▁2 ▁) ▁; ▁} ▁static ▁void ▁dfs ▁( ▁int ▁node ▁, ▁int ▁parent ▁) ▁{ ▁size ▁[ ▁node ▁] ▁= ▁1 ▁; ▁int ▁mx ▁= ▁0 ▁; ▁for ▁( ▁int ▁y ▁: ▁g ▁[ ▁node ▁] ▁) ▁{ ▁if ▁( ▁y ▁== ▁parent ▁) ▁continue ▁; ▁dfs ▁( ▁y ▁, ▁node ▁) ▁; ▁size ▁[ ▁node ▁] ▁+= ▁size ▁[ ▁y ▁] ▁; ▁mx ▁= ▁Math ▁. ▁max ▁( ▁mx ▁, ▁size ▁[ ▁y ▁] ▁) ▁; ▁} ▁mx ▁= ▁Math ▁. ▁max ▁( ▁mx ▁, ▁n ▁- ▁size ▁[ ▁node ▁] ▁) ▁; ▁if ▁( ▁mx ▁< ▁mini ▁) ▁{ ▁mini ▁= ▁mx ▁; ▁ans ▁= ▁node ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁n ▁= ▁6 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁g ▁. ▁length ▁; ▁i ▁++ ▁) ▁g ▁[ ▁i ▁] ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁create _ graph ▁( ▁) ▁; ▁dfs ▁( ▁1 ▁, ▁- ▁1 ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁ans ▁+ ▁" NEW _ LINE "); ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁isP ossible ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁mn ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁int ▁[ ▁] ▁B ▁= ▁new ▁int ▁[ ▁N ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁mn ▁= ▁Math ▁. ▁min ▁( ▁mn ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁B ▁[ ▁i ▁] ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁Arrays ▁. ▁sort ▁( ▁arr ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁!= ▁B ▁[ ▁i ▁] ▁) ▁{ ▁if ▁( ▁B ▁[ ▁i ▁] ▁% ▁mn ▁!= ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁No ▁" ▁) ▁; ▁return ▁; ▁} ▁} ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Yes ▁" ▁) ▁; ▁return ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁6 ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁3 ▁, ▁6 ▁, ▁6 ▁, ▁2 ▁, ▁9 ▁} ▁; ▁isP ossible ▁( ▁arr ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁check Arr In Stack ▁( ▁Stack ▁< ▁Integer ▁> ▁s ▁, ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁freq ▁= ▁new ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁freq ▁. ▁containsKey ▁( ▁arr ▁[ ▁i ▁] ▁) ▁) ▁freq ▁. ▁put ▁( ▁arr ▁[ ▁i ▁] ▁, ▁freq ▁. ▁get ▁( ▁arr ▁[ ▁i ▁] ▁) ▁+ ▁1 ▁) ▁; ▁else ▁freq ▁. ▁put ▁( ▁arr ▁[ ▁i ▁] ▁, ▁1 ▁) ▁; ▁while ▁( ▁! ▁s ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁int ▁po pped Ele ▁= ▁s ▁. ▁peek ▁( ▁) ▁; ▁s ▁. ▁pop ▁( ▁) ▁; ▁if ▁( ▁freq ▁. ▁containsKey ▁( ▁po pped Ele ▁) ▁) ▁freq ▁. ▁put ▁( ▁po pped Ele ▁, ▁freq ▁. ▁get ▁( ▁po pped Ele ▁) ▁- ▁1 ▁) ▁; ▁} ▁if ▁( ▁freq ▁. ▁size ▁( ▁) ▁== ▁0 ▁) ▁return ▁false ▁; ▁return ▁true ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Stack ▁< ▁Integer ▁> ▁s ▁= ▁new ▁Stack ▁< ▁Integer ▁> ▁( ▁) ▁; ▁s ▁. ▁add ▁( ▁10 ▁) ▁; ▁s ▁. ▁add ▁( ▁20 ▁) ▁; ▁s ▁. ▁add ▁( ▁30 ▁) ▁; ▁s ▁. ▁add ▁( ▁40 ▁) ▁; ▁s ▁. ▁add ▁( ▁50 ▁) ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁20 ▁, ▁30 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁if ▁( ▁check Arr In Stack ▁( ▁s ▁, ▁arr ▁, ▁n ▁) ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" YES NEW _ LINE "); ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" NO NEW _ LINE "); ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁String ▁pal indrome Prefix ▁( ▁String ▁S ▁) ▁{ ▁int ▁n ▁= ▁S ▁. ▁length ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁String ▁curr ▁= ▁S ▁. ▁substring ▁( ▁0 ▁, ▁i ▁+ ▁1 ▁) ▁; ▁int ▁l ▁= ▁0 ▁, ▁r ▁= ▁curr ▁. ▁length ▁( ▁) ▁- ▁1 ▁; ▁boolean ▁is _ pal indrome ▁= ▁true ▁; ▁while ▁( ▁l ▁< ▁r ▁) ▁{ ▁if ▁( ▁curr ▁. ▁charAt ▁( ▁l ▁) ▁!= ▁curr ▁. ▁charAt ▁( ▁r ▁) ▁) ▁{ ▁is _ pal indrome ▁= ▁false ▁; ▁break ▁; ▁} ▁l ▁++ ▁; ▁r ▁-- ▁; ▁} ▁if ▁( ▁is _ pal indrome ▁) ▁return ▁curr ▁; ▁} ▁return ▁" ▁" ▁; ▁} ▁static ▁String ▁max Pal indrome ▁( ▁String ▁S ▁) ▁{ ▁int ▁n ▁= ▁S ▁. ▁length ▁( ▁) ▁; ▁if ▁( ▁n ▁<= ▁1 ▁) ▁{ ▁return ▁S ▁; ▁} ▁String ▁pre ▁= ▁" ▁" ▁, ▁suff ▁= ▁" ▁" ▁; ▁int ▁i ▁= ▁0 ▁, ▁j ▁= ▁n ▁- ▁1 ▁; ▁while ▁( ▁S ▁. ▁charAt ▁( ▁i ▁) ▁== ▁S ▁. ▁charAt ▁( ▁j ▁) ▁&& ▁i ▁< ▁j ▁) ▁{ ▁i ▁++ ▁; ▁j ▁-- ▁; ▁} ▁i ▁-- ▁; ▁j ▁++ ▁; ▁pre ▁= ▁S ▁. ▁substring ▁( ▁0 ▁, ▁i ▁+ ▁1 ▁) ▁; ▁suff ▁= ▁S ▁. ▁substring ▁( ▁j ▁) ▁; ▁if ▁( ▁j ▁- ▁i ▁== ▁1 ▁) ▁{ ▁return ▁pre ▁+ ▁suff ▁; ▁} ▁if ▁( ▁j ▁- ▁i ▁== ▁2 ▁) ▁{ ▁String ▁mid _ char ▁= ▁S ▁. ▁substring ▁( ▁i ▁+ ▁1 ▁, ▁i ▁+ ▁2 ▁) ▁; ▁return ▁pre ▁+ ▁mid _ char ▁+ ▁suff ▁; ▁} ▁String ▁rem _ str ▁= ▁S ▁. ▁substring ▁( ▁i ▁+ ▁1 ▁, ▁j ▁) ▁; ▁String ▁pre _ of _ rem _ str ▁= ▁pal indrome Prefix ▁( ▁rem _ str ▁) ▁; ▁rem _ str ▁= ▁reverse ▁( ▁rem _ str ▁) ▁; ▁String ▁suff _ of _ rem _ str ▁= ▁pal indrome Prefix ▁( ▁rem _ str ▁) ▁; ▁if ▁( ▁pre _ of _ rem _ str ▁. ▁length ▁( ▁) ▁>= ▁suff _ of _ rem _ str ▁. ▁length ▁( ▁) ▁) ▁{ ▁return ▁pre ▁+ ▁pre _ of _ rem _ str ▁+ ▁suff ▁; ▁} ▁else ▁{ ▁return ▁pre ▁+ ▁suff _ of _ rem _ str ▁+ ▁suff ▁; ▁} ▁} ▁static ▁String ▁reverse ▁( ▁String ▁input ▁) ▁{ ▁char ▁[ ▁] ▁a ▁= ▁input ▁. ▁toCharArray ▁( ▁) ▁; ▁int ▁l ▁, ▁r ▁= ▁a ▁. ▁length ▁- ▁1 ▁; ▁for ▁( ▁l ▁= ▁0 ▁; ▁l ▁< ▁r ▁; ▁l ▁++ ▁, ▁r ▁-- ▁) ▁{ ▁char ▁temp ▁= ▁a ▁[ ▁l ▁] ▁; ▁a ▁[ ▁l ▁] ▁= ▁a ▁[ ▁r ▁] ▁; ▁a ▁[ ▁r ▁] ▁= ▁temp ▁; ▁} ▁return ▁String ▁. ▁valueOf ▁( ▁a ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁S ▁= ▁" ▁g eek s for s ke eg ▁" ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁max Pal indrome ▁( ▁S ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁find Sum ▁( ▁String ▁s ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁s ▁. ▁length ▁( ▁) ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁== ▁s ▁. ▁charAt ▁( ▁j ▁) ▁) ▁{ ▁sum ▁+= ▁( ▁j ▁- ▁i ▁) ▁; ▁} ▁} ▁} ▁return ▁sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁s ▁= ▁" ▁tt t ▁" ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁find Sum ▁( ▁s ▁) ▁+ ▁" NEW _ LINE "); ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁min _ f lips ▁( ▁String ▁str ▁, ▁int ▁k ▁) ▁{ ▁if ▁( ▁str ▁. ▁length ▁( ▁) ▁== ▁0 ▁) ▁return ▁0 ▁; ▁int ▁ans ▁= ▁0 ▁; ▁int ▁cnt _ zeros ▁= ▁0 ▁; ▁for ▁( ▁char ▁ch ▁: ▁str ▁. ▁toCharArray ▁( ▁) ▁) ▁{ ▁if ▁( ▁ch ▁== ▁'0' ▁) ▁{ ▁++ ▁cnt _ zeros ▁; ▁} ▁else ▁{ ▁cnt _ zeros ▁= ▁0 ▁; ▁} ▁if ▁( ▁cnt _ zeros ▁== ▁k ▁) ▁{ ▁++ ▁ans ▁; ▁cnt _ zeros ▁= ▁0 ▁; ▁} ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁" 111 000000 11" ▁; ▁int ▁k ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁min _ f lips ▁( ▁str ▁, ▁k ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁void ▁count ▁( ▁int ▁N ▁) ▁{ ▁if ▁( ▁N ▁== ▁1 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁10 ▁) ▁; ▁return ▁; ▁} ▁int ▁dp ▁[ ▁] ▁[ ▁] ▁= ▁new ▁int ▁[ ▁N ▁] ▁[ ▁10 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁10 ▁; ▁i ▁++ ▁) ▁dp ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁int ▁temp ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁10 ▁; ▁j ▁++ ▁) ▁temp ▁+= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁10 ▁; ▁j ▁++ ▁) ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁temp ▁- ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁; ▁} ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁10 ▁; ▁i ▁++ ▁) ▁ans ▁+= ▁dp ▁[ ▁N ▁- ▁1 ▁] ▁[ ▁i ▁] ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁ans ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁2 ▁; ▁count ▁( ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁ctr ▁= ▁0 ▁; ▁static ▁int ▁find ▁( ▁int ▁[ ▁] ▁parent ▁, ▁int ▁x ▁) ▁{ ▁if ▁( ▁parent ▁[ ▁x ▁] ▁== ▁x ▁) ▁return ▁x ▁; ▁parent ▁[ ▁x ▁] ▁= ▁find ▁( ▁parent ▁, ▁parent ▁[ ▁x ▁] ▁) ▁; ▁return ▁parent ▁[ ▁x ▁] ▁; ▁} ▁static ▁void ▁set Union ▁( ▁int ▁[ ▁] ▁parent ▁, ▁int ▁[ ▁] ▁rank ▁, ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁int ▁parent x ▁= ▁find ▁( ▁parent ▁, ▁x ▁) ▁; ▁int ▁parent y ▁= ▁find ▁( ▁parent ▁, ▁y ▁) ▁; ▁if ▁( ▁parent y ▁== ▁parent x ▁) ▁return ▁; ▁ctr ▁-- ▁; ▁if ▁( ▁rank ▁[ ▁parent x ▁] ▁< ▁rank ▁[ ▁parent y ▁] ▁) ▁{ ▁parent ▁[ ▁parent x ▁] ▁= ▁parent y ▁; ▁} ▁else ▁if ▁( ▁rank ▁[ ▁parent x ▁] ▁> ▁rank ▁[ ▁parent y ▁] ▁) ▁{ ▁parent ▁[ ▁parent y ▁] ▁= ▁parent x ▁; ▁} ▁else ▁{ ▁parent ▁[ ▁parent x ▁] ▁= ▁parent y ▁; ▁rank ▁[ ▁parent y ▁] ▁++ ▁; ▁} ▁} ▁static ▁int ▁[ ▁] ▁solve ▁( ▁int ▁n ▁, ▁int ▁m ▁, ▁int ▁[ ▁] ▁[ ▁] ▁query ▁) ▁{ ▁int ▁[ ▁] ▁result ▁= ▁new ▁int ▁[ ▁query ▁. ▁length ▁] ▁; ▁int ▁[ ▁] ▁parent ▁= ▁new ▁int ▁[ ▁n ▁* ▁m ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁* ▁m ▁; ▁i ▁++ ▁) ▁parent ▁[ ▁i ▁] ▁= ▁i ▁; ▁int ▁[ ▁] ▁rank ▁= ▁new ▁int ▁[ ▁n ▁* ▁m ▁] ▁; ▁Arrays ▁. ▁fill ▁( ▁rank ▁, ▁1 ▁) ▁; ▁boolean ▁[ ▁] ▁grid ▁= ▁new ▁boolean ▁[ ▁n ▁* ▁m ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁query ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁int ▁x ▁= ▁query ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁; ▁int ▁y ▁= ▁query ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁; ▁if ▁( ▁grid ▁[ ▁m ▁* ▁x ▁+ ▁y ▁] ▁== ▁true ▁) ▁{ ▁result ▁[ ▁i ▁] ▁= ▁ctr ▁; ▁continue ▁; ▁} ▁grid ▁[ ▁m ▁* ▁x ▁+ ▁y ▁] ▁= ▁true ▁; ▁ctr ▁++ ▁; ▁if ▁( ▁x ▁> ▁0 ▁&& ▁grid ▁[ ▁m ▁* ▁( ▁x ▁- ▁1 ▁) ▁+ ▁y ▁] ▁== ▁true ▁) ▁set Union ▁( ▁parent ▁, ▁rank ▁, ▁m ▁* ▁x ▁+ ▁y ▁, ▁m ▁* ▁( ▁x ▁- ▁1 ▁) ▁+ ▁y ▁) ▁; ▁if ▁( ▁y ▁> ▁0 ▁&& ▁grid ▁[ ▁m ▁* ▁( ▁x ▁) ▁+ ▁y ▁- ▁1 ▁] ▁== ▁true ▁) ▁set Union ▁( ▁parent ▁, ▁rank ▁, ▁m ▁* ▁x ▁+ ▁y ▁, ▁m ▁* ▁( ▁x ▁) ▁+ ▁y ▁- ▁1 ▁) ▁; ▁if ▁( ▁x ▁< ▁n ▁- ▁1 ▁&& ▁grid ▁[ ▁m ▁* ▁( ▁x ▁+ ▁1 ▁) ▁+ ▁y ▁] ▁== ▁true ▁) ▁set Union ▁( ▁parent ▁, ▁rank ▁, ▁m ▁* ▁x ▁+ ▁y ▁, ▁m ▁* ▁( ▁x ▁+ ▁1 ▁) ▁+ ▁y ▁) ▁; ▁if ▁( ▁y ▁< ▁m ▁- ▁1 ▁&& ▁grid ▁[ ▁m ▁* ▁( ▁x ▁) ▁+ ▁y ▁+ ▁1 ▁] ▁== ▁true ▁) ▁set Union ▁( ▁parent ▁, ▁rank ▁, ▁m ▁* ▁x ▁+ ▁y ▁, ▁m ▁* ▁( ▁x ▁) ▁+ ▁y ▁+ ▁1 ▁) ▁; ▁result ▁[ ▁i ▁] ▁= ▁ctr ▁; ▁} ▁return ▁result ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁3 ▁, ▁M ▁= ▁3 ▁, ▁K ▁= ▁4 ▁; ▁int ▁[ ▁] ▁[ ▁] ▁query ▁= ▁{ ▁{ ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁1 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁0 ▁} ▁, ▁{ ▁1 ▁, ▁2 ▁} ▁} ▁; ▁int ▁[ ▁] ▁result ▁= ▁solve ▁( ▁N ▁, ▁M ▁, ▁query ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁K ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁result ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁cnt ▁= ▁0 ▁; ▁static ▁void ▁dfs ▁( ▁int ▁[ ▁] ▁val ▁, ▁int ▁[ ▁] ▁cost ▁, ▁Vector ▁< ▁Integer ▁> ▁[ ▁] ▁tr ▁, ▁int ▁u ▁, ▁int ▁s ▁) ▁{ ▁s ▁= ▁s ▁+ ▁cost ▁[ ▁u ▁] ▁; ▁if ▁( ▁s ▁< ▁0 ▁) ▁s ▁= ▁0 ▁; ▁if ▁( ▁s ▁> ▁val ▁[ ▁u ▁] ▁) ▁return ▁; ▁cnt ▁++ ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁tr ▁[ ▁u ▁] ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁dfs ▁( ▁val ▁, ▁cost ▁, ▁tr ▁, ▁tr ▁[ ▁u ▁] ▁. ▁get ▁( ▁i ▁) ▁, ▁s ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁9 ▁; ▁int ▁val ▁[ ▁] ▁= ▁{ ▁88 ▁, ▁22 ▁, ▁83 ▁, ▁14 ▁, ▁95 ▁, ▁91 ▁, ▁98 ▁, ▁53 ▁, ▁11 ▁} ▁; ▁int ▁cost ▁[ ▁] ▁= ▁{ ▁- ▁1 ▁, ▁24 ▁, ▁- ▁8 ▁, ▁67 ▁, ▁64 ▁, ▁65 ▁, ▁12 ▁, ▁- ▁80 ▁, ▁8 ▁} ▁; ▁@ ▁Suppress Warnings ▁( ▁" ▁unchecked ▁" ▁) ▁Vector ▁< ▁Integer ▁> ▁[ ▁] ▁tr ▁= ▁new ▁Vector ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁tr ▁. ▁length ▁; ▁i ▁++ ▁) ▁tr ▁[ ▁i ▁] ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁tr ▁[ ▁0 ▁] ▁. ▁add ▁( ▁3 ▁) ▁; ▁tr ▁[ ▁0 ▁] ▁. ▁add ▁( ▁4 ▁) ▁; ▁tr ▁[ ▁4 ▁] ▁. ▁add ▁( ▁6 ▁) ▁; ▁tr ▁[ ▁6 ▁] ▁. ▁add ▁( ▁2 ▁) ▁; ▁tr ▁[ ▁2 ▁] ▁. ▁add ▁( ▁1 ▁) ▁; ▁tr ▁[ ▁2 ▁] ▁. ▁add ▁( ▁8 ▁) ▁; ▁tr ▁[ ▁8 ▁] ▁. ▁add ▁( ▁5 ▁) ▁; ▁tr ▁[ ▁5 ▁] ▁. ▁add ▁( ▁7 ▁) ▁; ▁dfs ▁( ▁val ▁, ▁cost ▁, ▁tr ▁, ▁0 ▁, ▁0 ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁n ▁- ▁cnt ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁[ ▁] ▁find L argest ▁( ▁int ▁beg ▁, ▁int ▁end ▁, ▁int ▁[ ▁] ▁arr ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁beg ▁== ▁end ▁) ▁{ ▁int ▁[ ▁] ▁compared ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁compared ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁compared ▁[ ▁1 ▁] ▁= ▁arr ▁[ ▁beg ▁] ▁; ▁return ▁compared ▁; ▁} ▁int ▁[ ▁] ▁compared 1 ▁= ▁find L argest ▁( ▁beg ▁, ▁( ▁beg ▁+ ▁end ▁) ▁/ ▁2 ▁, ▁arr ▁, ▁n ▁) ▁; ▁int ▁[ ▁] ▁compared 2 ▁= ▁find L argest ▁( ▁( ▁beg ▁+ ▁end ▁) ▁/ ▁2 ▁+ ▁1 ▁, ▁end ▁, ▁arr ▁, ▁n ▁) ▁; ▁if ▁( ▁compared 1 ▁[ ▁1 ▁] ▁> ▁compared 2 ▁[ ▁1 ▁] ▁) ▁{ ▁int ▁k ▁= ▁compared 1 ▁[ ▁0 ▁] ▁+ ▁1 ▁; ▁compared 1 ▁[ ▁0 ▁] ▁= ▁k ▁; ▁compared 1 ▁[ ▁k ▁] ▁= ▁compared 2 ▁[ ▁1 ▁] ▁; ▁return ▁compared 1 ▁; ▁} ▁else ▁{ ▁int ▁k ▁= ▁compared 2 ▁[ ▁0 ▁] ▁+ ▁1 ▁; ▁compared 2 ▁[ ▁0 ▁] ▁= ▁k ▁; ▁compared 2 ▁[ ▁k ▁] ▁= ▁compared 1 ▁[ ▁1 ▁] ▁; ▁return ▁compared 2 ▁; ▁} ▁} ▁static ▁void ▁find Second L argest ▁( ▁int ▁end ▁, ▁int ▁[ ▁] ▁arr ▁) ▁{ ▁int ▁[ ▁] ▁compared 1 ▁= ▁find L argest ▁( ▁0 ▁, ▁end ▁- ▁1 ▁, ▁arr ▁, ▁end ▁) ▁; ▁int ▁[ ▁] ▁compared 2 ▁= ▁find L argest ▁( ▁2 ▁, ▁compared 1 ▁[ ▁0 ▁] ▁+ ▁2 ▁, ▁compared 1 ▁, ▁compared 1 ▁[ ▁0 ▁] ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁compared 2 ▁[ ▁1 ▁] ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁10 ▁; ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁20 ▁, ▁199 0 ▁, ▁12 ▁, ▁11 10 ▁, ▁1 ▁, ▁59 ▁, ▁12 ▁, ▁15 ▁, ▁120 ▁, ▁11 10 ▁} ▁; ▁find Second L argest ▁( ▁N ▁, ▁arr ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁public ▁static ▁int ▁Count sub String ▁( ▁char ▁[ ▁] ▁str ▁, ▁int ▁n ▁) ▁{ ▁int ▁c ▁= ▁0 ▁; ▁for ▁( ▁int ▁len ▁= ▁1 ▁; ▁len ▁<= ▁n ▁; ▁len ▁++ ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁n ▁- ▁len ▁; ▁i ▁++ ▁) ▁{ ▁int ▁j ▁= ▁i ▁+ ▁len ▁- ▁1 ▁; ▁char ▁temp ▁= ▁str ▁[ ▁i ▁] ▁, ▁f ▁= ▁0 ▁; ▁if ▁( ▁j ▁== ▁i ▁) ▁{ ▁c ▁++ ▁; ▁continue ▁; ▁} ▁int ▁k ▁= ▁i ▁+ ▁1 ▁; ▁while ▁( ▁temp ▁> ▁str ▁[ ▁k ▁] ▁&& ▁k ▁<= ▁j ▁) ▁{ ▁temp ▁= ▁str ▁[ ▁k ▁] ▁; ▁k ▁++ ▁; ▁} ▁if ▁( ▁k ▁> ▁j ▁) ▁{ ▁c ▁++ ▁; ▁f ▁= ▁2 ▁; ▁} ▁while ▁( ▁k ▁<= ▁j ▁&& ▁temp ▁< ▁str ▁[ ▁k ▁] ▁&& ▁f ▁!= ▁2 ▁) ▁{ ▁temp ▁= ▁str ▁[ ▁k ▁] ▁; ▁k ▁++ ▁; ▁} ▁if ▁( ▁k ▁> ▁j ▁&& ▁f ▁!= ▁2 ▁) ▁{ ▁c ▁++ ▁; ▁f ▁= ▁0 ▁; ▁} ▁} ▁} ▁return ▁c ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁char ▁str ▁[ ▁] ▁= ▁{ ▁' ▁b ▁' ▁, ▁' ▁a ▁' ▁, ▁' ▁d ▁' ▁, ▁' ▁e ▁' ▁} ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁Count sub String ▁( ▁str ▁, ▁str ▁. ▁length ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁Vector ▁< ▁Integer ▁> ▁generate Sequence ▁( ▁int ▁[ ▁] ▁freq ▁, ▁int ▁n ▁) ▁{ ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁m ▁= ▁new ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁( ▁) ▁; ▁int ▁total ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁m ▁. ▁put ▁( ▁i ▁, ▁freq ▁[ ▁i ▁] ▁) ▁; ▁total ▁+= ▁freq ▁[ ▁i ▁] ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁m ▁. ▁containsKey ▁( ▁i ▁) ▁) ▁{ ▁Vector ▁< ▁Integer ▁> ▁sequence ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁@ ▁Suppress Warnings ▁( ▁" ▁unchecked ▁" ▁) ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁m copy ▁= ▁( ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁) ▁m ▁. ▁clone ▁( ▁) ▁; ▁if ▁( ▁m copy ▁. ▁containsKey ▁( ▁i ▁) ▁&& ▁m copy ▁. ▁get ▁( ▁i ▁) ▁> ▁0 ▁) ▁m copy ▁. ▁put ▁( ▁i ▁, ▁m copy ▁. ▁get ▁( ▁i ▁) ▁- ▁1 ▁) ▁; ▁sequence ▁. ▁add ▁( ▁i ▁) ▁; ▁int ▁last ▁= ▁i ▁; ▁for ▁( ▁int ▁i 1 ▁= ▁0 ▁; ▁i 1 ▁< ▁total ▁- ▁1 ▁; ▁i 1 ▁++ ▁) ▁{ ▁if ▁( ▁m copy ▁. ▁containsKey ▁( ▁last ▁- ▁1 ▁) ▁&& ▁m copy ▁. ▁get ▁( ▁last ▁- ▁1 ▁) ▁> ▁0 ▁) ▁{ ▁m copy ▁. ▁put ▁( ▁last ▁- ▁1 ▁, ▁m copy ▁. ▁get ▁( ▁last ▁- ▁1 ▁) ▁- ▁1 ▁) ▁; ▁sequence ▁. ▁add ▁( ▁last ▁- ▁1 ▁) ▁; ▁last ▁-- ▁; ▁} ▁else ▁if ▁( ▁m copy ▁. ▁containsKey ▁( ▁last ▁+ ▁1 ▁) ▁) ▁{ ▁m copy ▁. ▁put ▁( ▁last ▁+ ▁1 ▁, ▁m copy ▁. ▁get ▁( ▁last ▁+ ▁1 ▁) ▁- ▁1 ▁) ▁; ▁sequence ▁. ▁add ▁( ▁last ▁+ ▁1 ▁) ▁; ▁last ▁++ ▁; ▁} ▁else ▁break ▁; ▁} ▁if ▁( ▁sequence ▁. ▁size ▁( ▁) ▁== ▁total ▁) ▁{ ▁return ▁sequence ▁; ▁} ▁} ▁} ▁Vector ▁< ▁Integer ▁> ▁empty ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁return ▁empty ▁; ▁} ▁static ▁void ▁Print Sequence ▁( ▁int ▁freq ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁Vector ▁< ▁Integer ▁> ▁sequence ▁= ▁generate Sequence ▁( ▁freq ▁, ▁n ▁) ▁; ▁if ▁( ▁sequence ▁. ▁size ▁( ▁) ▁== ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁- ▁1" ▁) ▁; ▁} ▁else ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁sequence ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁sequence ▁. ▁get ▁( ▁i ▁) ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁freq ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁2 ▁, ▁2 ▁, ▁3 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁5 ▁; ▁Print Sequence ▁( ▁freq ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁void ▁median Change ▁( ▁List ▁< ▁Integer ▁> ▁arr 1 ▁, ▁List ▁< ▁Integer ▁> ▁arr 2 ▁) ▁{ ▁int ▁N ▁= ▁arr 1 ▁. ▁size ▁( ▁) ▁; ▁List ▁< ▁Integer ▁> ▁median ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁if ▁( ▁( ▁N ▁& ▁1 ▁) ▁!= ▁0 ▁) ▁median ▁. ▁add ▁( ▁arr 1 ▁. ▁get ▁( ▁N ▁/ ▁2 ▁) ▁* ▁1 ▁) ▁; ▁else ▁median ▁. ▁add ▁( ▁( ▁arr 1 ▁. ▁get ▁( ▁N ▁/ ▁2 ▁) ▁+ ▁arr 1 ▁. ▁get ▁( ▁( ▁N ▁- ▁1 ▁) ▁/ ▁2 ▁) ▁) ▁/ ▁2 ▁) ▁; ▁for ▁( ▁int ▁x ▁= ▁0 ▁; ▁x ▁< ▁arr 2 ▁. ▁size ▁( ▁) ▁; ▁x ▁++ ▁) ▁{ ▁int ▁it ▁= ▁arr 1 ▁. ▁indexOf ▁( ▁arr 2 ▁. ▁get ▁( ▁x ▁) ▁) ▁; ▁arr 1 ▁. ▁remove ▁( ▁it ▁) ▁; ▁N ▁-- ▁; ▁if ▁( ▁( ▁N ▁& ▁1 ▁) ▁!= ▁0 ▁) ▁{ ▁median ▁. ▁add ▁( ▁arr 1 ▁. ▁get ▁( ▁N ▁/ ▁2 ▁) ▁* ▁1 ▁) ▁; ▁} ▁else ▁{ ▁median ▁. ▁add ▁( ▁( ▁arr 1 ▁. ▁get ▁( ▁N ▁/ ▁2 ▁) ▁+ ▁arr 1 ▁. ▁get ▁( ▁( ▁N ▁- ▁1 ▁) ▁/ ▁2 ▁) ▁) ▁/ ▁2 ▁) ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁median ▁. ▁size ▁( ▁) ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁median ▁. ▁get ▁( ▁i ▁+ ▁1 ▁) ▁- ▁median ▁. ▁get ▁( ▁i ▁) ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁List ▁< ▁Integer ▁> ▁arr 1 ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁{ ▁{ ▁add ▁( ▁2 ▁) ▁; ▁add ▁( ▁4 ▁) ▁; ▁add ▁( ▁6 ▁) ▁; ▁add ▁( ▁8 ▁) ▁; ▁add ▁( ▁10 ▁) ▁; ▁} ▁} ▁; ▁List ▁< ▁Integer ▁> ▁arr 2 ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁{ ▁{ ▁add ▁( ▁4 ▁) ▁; ▁add ▁( ▁6 ▁) ▁; ▁} ▁} ▁; ▁median Change ▁( ▁arr 1 ▁, ▁arr 2 ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁count Fac ▁( ▁int ▁n ▁) ▁{ ▁int ▁m ▁= ▁n ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁( ▁i ▁* ▁i ▁) ▁<= ▁m ▁; ▁++ ▁i ▁) ▁{ ▁int ▁total ▁= ▁0 ▁; ▁while ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁{ ▁n ▁/= ▁i ▁; ▁++ ▁total ▁; ▁} ▁int ▁temp ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁( ▁temp ▁+ ▁j ▁) ▁<= ▁total ▁; ▁++ ▁j ▁) ▁{ ▁temp ▁+= ▁j ▁; ▁++ ▁count ▁; ▁} ▁} ▁if ▁( ▁n ▁!= ▁1 ▁) ▁++ ▁count ▁; ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁24 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Fac ▁( ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁find Missing ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁left ▁, ▁int ▁right ▁, ▁int ▁diff ▁) ▁{ ▁if ▁( ▁right ▁<= ▁left ▁) ▁return ▁0 ▁; ▁int ▁mid ▁= ▁left ▁+ ▁( ▁right ▁- ▁left ▁) ▁/ ▁2 ▁; ▁if ▁( ▁arr ▁[ ▁mid ▁+ ▁1 ▁] ▁- ▁arr ▁[ ▁mid ▁] ▁!= ▁diff ▁) ▁return ▁( ▁arr ▁[ ▁mid ▁] ▁+ ▁diff ▁) ▁; ▁if ▁( ▁mid ▁> ▁0 ▁&& ▁arr ▁[ ▁mid ▁] ▁- ▁arr ▁[ ▁mid ▁- ▁1 ▁] ▁!= ▁diff ▁) ▁return ▁( ▁arr ▁[ ▁mid ▁- ▁1 ▁] ▁+ ▁diff ▁) ▁; ▁if ▁( ▁arr ▁[ ▁mid ▁] ▁== ▁arr ▁[ ▁0 ▁] ▁+ ▁mid ▁* ▁diff ▁) ▁return ▁find Missing ▁( ▁arr ▁, ▁mid ▁+ ▁1 ▁, ▁right ▁, ▁diff ▁) ▁; ▁return ▁find Missing ▁( ▁arr ▁, ▁left ▁, ▁mid ▁- ▁1 ▁, ▁diff ▁) ▁; ▁} ▁static ▁int ▁missing Element ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁arr ▁) ▁; ▁int ▁diff ▁= ▁( ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁- ▁arr ▁[ ▁0 ▁] ▁) ▁/ ▁n ▁; ▁return ▁find Missing ▁( ▁arr ▁, ▁0 ▁, ▁n ▁- ▁1 ▁, ▁diff ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁new ▁int ▁[ ▁] ▁{ ▁2 ▁, ▁8 ▁, ▁6 ▁, ▁10 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁missing Element ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁naive _ find _ x ▁( ▁int ▁N ▁) ▁{ ▁int ▁c ▁= ▁0 ▁, ▁i ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁c ▁+= ▁i ▁* ▁i ▁* ▁i ▁; ▁if ▁( ▁c ▁>= ▁N ▁) ▁break ▁; ▁} ▁return ▁i ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁100 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁naive _ find _ x ▁( ▁N ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁xor Of Sum ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁answer ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁answer ▁^= ▁( ▁a ▁[ ▁i ▁] ▁+ ▁a ▁[ ▁j ▁] ▁) ▁; ▁} ▁return ▁answer ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁3 ▁; ▁int ▁A ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁xor Of Sum ▁( ▁A ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁create Hash ▁( ▁HashSet ▁< ▁Integer ▁> ▁hash ▁, ▁int ▁max Element ▁) ▁{ ▁int ▁prev ▁= ▁0 ▁, ▁curr ▁= ▁1 ▁; ▁hash ▁. ▁add ▁( ▁prev ▁) ▁; ▁hash ▁. ▁add ▁( ▁curr ▁) ▁; ▁while ▁( ▁curr ▁<= ▁max Element ▁) ▁{ ▁int ▁temp ▁= ▁curr ▁+ ▁prev ▁; ▁hash ▁. ▁add ▁( ▁temp ▁) ▁; ▁prev ▁= ▁curr ▁; ▁curr ▁= ▁temp ▁; ▁} ▁} ▁static ▁void ▁fib onacci ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁max _ val ▁= ▁Arrays ▁. ▁stream ▁( ▁arr ▁) ▁. ▁max ▁( ▁) ▁. ▁getAs Int ▁( ▁) ▁; ▁HashSet ▁< ▁Integer ▁> ▁hash ▁= ▁new ▁HashSet ▁< ▁Integer ▁> ▁( ▁) ▁; ▁create Hash ▁( ▁hash ▁, ▁max _ val ▁) ▁; ▁int ▁minimum ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁int ▁maximum ▁= ▁Integer ▁. ▁MIN _ VALUE ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁hash ▁. ▁contains ▁( ▁arr ▁[ ▁i ▁] ▁) ▁) ▁{ ▁minimum ▁= ▁Math ▁. ▁min ▁( ▁minimum ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁maximum ▁= ▁Math ▁. ▁max ▁( ▁maximum ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁minimum ▁+ ▁" ▁, ▁" ▁+ ▁maximum ▁+ ▁" NEW _ LINE "); ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁, ▁7 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁fib onacci ▁( ▁arr ▁, ▁n ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁permutation ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁n ▁) ▁{ ▁Set ▁< ▁Integer ▁> ▁hash ▁= ▁new ▁HashSet ▁< ▁Integer ▁> ▁( ▁) ▁; ▁int ▁max Ele ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁hash ▁. ▁add ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁max Ele ▁= ▁Math ▁. ▁max ▁( ▁max Ele ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁if ▁( ▁max Ele ▁!= ▁n ▁) ▁return ▁false ▁; ▁if ▁( ▁hash ▁. ▁size ▁( ▁) ▁== ▁n ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁5 ▁, ▁3 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁if ▁( ▁permutation ▁( ▁arr ▁, ▁n ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁check ▁( ▁int ▁m ▁, ▁int ▁n ▁, ▁int ▁arr ▁[ ▁] ▁) ▁{ ▁int ▁[ ▁] ▁desired ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁desired ▁[ ▁i ▁] ▁= ▁m ▁; ▁m ▁-- ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁desired ▁[ ▁i ▁] ▁desired ▁[ ▁i ▁] ▁< ▁1 ▁) ▁{ ▁return ▁false ▁; ▁} ▁} ▁return ▁true ▁; ▁} ▁static ▁int ▁min Operations ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁start ▁= ▁( ▁int ▁) ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁; ▁int ▁end ▁= ▁Arrays ▁. ▁stream ▁( ▁arr ▁) ▁. ▁max ▁( ▁) ▁. ▁getAs Int ▁( ▁) ▁+ ▁n ▁; ▁int ▁max _ arr ▁= ▁0 ▁; ▁while ▁( ▁start ▁<= ▁end ▁) ▁{ ▁int ▁mid ▁= ▁( ▁start ▁+ ▁end ▁) ▁/ ▁2 ▁; ▁if ▁( ▁check ▁( ▁mid ▁, ▁n ▁, ▁arr ▁) ▁) ▁{ ▁max _ arr ▁= ▁mid ▁; ▁end ▁= ▁mid ▁- ▁1 ▁; ▁} ▁else ▁{ ▁start ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁} ▁int ▁[ ▁] ▁desired ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁desired ▁[ ▁i ▁] ▁= ▁max _ arr ▁; ▁max _ arr ▁-- ▁; ▁} ▁int ▁operations ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁operations ▁+= ▁( ▁desired ▁[ ▁i ▁] ▁- ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁return ▁operations ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁4 ▁, ▁5 ▁, ▁5 ▁, ▁7 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁min Operations ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁G F G ▁{ ▁static ▁int ▁cost To P anag ram ▁( ▁String ▁str ▁, ▁int ▁cost ▁[ ▁] ▁) ▁{ ▁int ▁i ▁, ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁int ▁occurrences ▁[ ▁] ▁= ▁new ▁int ▁[ ▁26 ▁] ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁occurrences ▁[ ▁str ▁. ▁charAt ▁( ▁i ▁) ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁int ▁gain ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁26 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁occurrences ▁[ ▁i ▁] ▁== ▁0 ▁) ▁gain ▁-= ▁( ▁2 ▁* ▁cost ▁[ ▁i ▁] ▁) ▁; ▁else ▁if ▁( ▁occurrences ▁[ ▁i ▁] ▁> ▁1 ▁) ▁gain ▁+= ▁( ▁cost ▁[ ▁i ▁] ▁* ▁( ▁occurrences ▁[ ▁i ▁] ▁- ▁1 ▁) ▁) ▁; ▁} ▁if ▁( ▁gain ▁>= ▁0 ▁) ▁return ▁0 ▁; ▁return ▁( ▁gain ▁* ▁- ▁1 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁cost ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁} ▁; ▁String ▁str ▁= ▁" ▁g eek s forge ek s ▁" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁cost To P anag ram ▁( ▁str ▁, ▁cost ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁HashMap ▁; ▁import ▁java ▁. ▁util ▁. ▁Map ▁; ▁class ▁G f G ▁{ ▁static ▁int ▁str Score ▁( ▁String ▁str ▁[ ▁] ▁, ▁String ▁s ▁, ▁int ▁n ▁) ▁{ ▁HashMap ▁< ▁String ▁, ▁Integer ▁> ▁m ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁m ▁. ▁put ▁( ▁str ▁[ ▁i ▁] ▁, ▁i ▁+ ▁1 ▁) ▁; ▁if ▁( ▁! ▁m ▁. ▁containsKey ▁( ▁s ▁) ▁) ▁return ▁0 ▁; ▁int ▁score ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁score ▁+= ▁s ▁. ▁charAt ▁( ▁i ▁) ▁- ▁' ▁a ▁' ▁+ ▁1 ▁; ▁score ▁= ▁score ▁* ▁m ▁. ▁get ▁( ▁s ▁) ▁; ▁return ▁score ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁[ ▁] ▁= ▁{ ▁" ▁g eek s forge ek s ▁" ▁, ▁" ▁algorithms ▁" ▁, ▁" ▁stack ▁" ▁} ▁; ▁String ▁s ▁= ▁" ▁algorithms ▁" ▁; ▁int ▁n ▁= ▁str ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁str Score ▁( ▁str ▁, ▁s ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁public ▁String ▁replace Pi ▁( ▁String ▁input ▁) ▁{ ▁String ▁output ▁= ▁" ▁" ▁; ▁int ▁size ▁= ▁input ▁. ▁length ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁i ▁+ ▁1 ▁< ▁size ▁&& ▁input ▁. ▁charAt ▁( ▁i ▁) ▁== ▁' ▁p ▁' ▁&& ▁input ▁. ▁charAt ▁( ▁i ▁+ ▁1 ▁) ▁== ▁' ▁i ▁' ▁) ▁{ ▁output ▁+= ▁" 3.1 4" ▁; ▁i ▁++ ▁; ▁} ▁else ▁{ ▁output ▁+= ▁input ▁. ▁charAt ▁( ▁i ▁) ▁; ▁} ▁} ▁return ▁output ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁G F G ▁g ▁= ▁new ▁G F G ▁( ▁) ▁; ▁String ▁input ▁= ▁"2 ▁* ▁pi ▁+ ▁3 ▁* ▁pi ▁= ▁5 ▁* ▁pi ▁" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁g ▁. ▁replace Pi ▁( ▁input ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁Solution ▁{ ▁static ▁int ▁numberOf Elements ▁( ▁int ▁height ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁max _ so _ far ▁= ▁0 ▁; ▁int ▁c oun ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁height ▁[ ▁i ▁] ▁> ▁max _ so _ far ▁) ▁{ ▁max _ so _ far ▁= ▁height ▁[ ▁i ▁] ▁; ▁c oun ▁++ ▁; ▁} ▁} ▁return ▁c oun ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁6 ▁; ▁int ▁height ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁8 ▁, ▁2 ▁, ▁0 ▁, ▁0 ▁, ▁5 ▁} ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁numberOf Elements ▁( ▁height ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁getMin ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁res ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁res ▁= ▁Math ▁. ▁min ▁( ▁res ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁return ▁res ▁; ▁} ▁static ▁int ▁getMax ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁res ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁res ▁= ▁Math ▁. ▁max ▁( ▁res ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁return ▁res ▁; ▁} ▁static ▁int ▁find Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁min ▁= ▁getMin ▁( ▁arr ▁, ▁n ▁) ▁; ▁int ▁max ▁= ▁getMax ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁min ▁+ ▁max ▁; ▁} ▁static ▁int ▁find Product ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁min ▁= ▁getMin ▁( ▁arr ▁, ▁n ▁) ▁; ▁int ▁max ▁= ▁getMax ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁min ▁* ▁max ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁12 ▁, ▁1234 ▁, ▁45 ▁, ▁67 ▁, ▁1 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Sum ▁= ▁" ▁+ ▁find Sum ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Product ▁= ▁" ▁+ ▁find Product ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁String ▁sort String ▁( ▁String ▁str ▁, ▁int ▁n ▁) ▁{ ▁String ▁new _ str ▁= ▁" ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁' ▁a ▁' ▁; ▁i ▁<= ▁' ▁z ▁' ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁if ▁( ▁str ▁. ▁charAt ▁( ▁j ▁) ▁== ▁i ▁) ▁new _ str ▁+= ▁str ▁. ▁charAt ▁( ▁j ▁) ▁; ▁return ▁new _ str ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁" ▁g eek s forge ek s ▁" ▁; ▁int ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁sort String ▁( ▁str ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁public ▁class ▁G f G ▁{ ▁public ▁static ▁void ▁occurrence Days ▁( ▁int ▁n ▁, ▁String ▁first day ▁) ▁{ ▁String ▁[ ▁] ▁days ▁= ▁new ▁String ▁[ ▁] ▁{ ▁" ▁Monday ▁" ▁, ▁" ▁T uesday ▁" ▁, ▁" ▁Wed nesday ▁" ▁, ▁" ▁Th ursday ▁" ▁, ▁" ▁F riday ▁" ▁, ▁" ▁S aturday ▁" ▁, ▁" ▁Sunday ▁" ▁} ▁; ▁int ▁[ ▁] ▁count ▁= ▁new ▁int ▁[ ▁7 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁7 ▁; ▁i ▁++ ▁) ▁count ▁[ ▁i ▁] ▁= ▁4 ▁; ▁int ▁pos ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁7 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁first day ▁== ▁days ▁[ ▁i ▁] ▁) ▁{ ▁pos ▁= ▁i ▁; ▁break ▁; ▁} ▁} ▁int ▁inc ▁= ▁n ▁- ▁28 ▁; ▁for ▁( ▁int ▁i ▁= ▁pos ▁; ▁i ▁< ▁pos ▁+ ▁inc ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁> ▁6 ▁) ▁count ▁[ ▁i ▁% ▁7 ▁] ▁= ▁5 ▁; ▁else ▁count ▁[ ▁i ▁] ▁= ▁5 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁7 ▁; ▁i ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁days ▁[ ▁i ▁] ▁+ ▁" ▁" ▁+ ▁count ▁[ ▁i ▁] ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁arg c ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁31 ▁; ▁String ▁first day ▁= ▁" ▁T uesday ▁" ▁; ▁occurrence Days ▁( ▁n ▁, ▁first day ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁getRandom ▁( ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁return ▁( ▁int ▁) ▁( ▁x ▁+ ▁Math ▁. ▁random ▁( ▁) ▁* ▁10 ▁% ▁( ▁y ▁- ▁x ▁+ ▁1 ▁) ▁) ▁; ▁} ▁static ▁int ▁random ized Binary Search ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁l ▁, ▁int ▁r ▁, ▁int ▁x ▁) ▁{ ▁while ▁( ▁l ▁<= ▁r ▁) ▁{ ▁int ▁m ▁= ▁getRandom ▁( ▁l ▁, ▁r ▁) ▁; ▁if ▁( ▁arr ▁[ ▁m ▁] ▁== ▁x ▁) ▁return ▁m ▁; ▁if ▁( ▁arr ▁[ ▁m ▁] ▁< ▁x ▁) ▁l ▁= ▁m ▁+ ▁1 ▁; ▁else ▁r ▁= ▁m ▁- ▁1 ▁; ▁} ▁return ▁- ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁10 ▁, ▁40 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁int ▁x ▁= ▁10 ▁; ▁int ▁result ▁= ▁random ized Binary Search ▁( ▁arr ▁, ▁0 ▁, ▁n ▁- ▁1 ▁, ▁x ▁) ▁; ▁if ▁( ▁result ▁== ▁- ▁1 ▁) ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁Element ▁is ▁not ▁present ▁in ▁array ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁Element ▁is ▁present ▁at ▁index ▁% ▁d ▁" ▁, ▁result ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁public ▁class ▁G F G ▁{ ▁static ▁boolean ▁is Sorted ▁( ▁int ▁[ ▁] ▁[ ▁] ▁arr ▁, ▁int ▁N ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁> ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁0 ▁] ▁) ▁{ ▁return ▁false ▁; ▁} ▁} ▁return ▁true ▁; ▁} ▁static ▁String ▁isP ossible To Sort ▁( ▁int ▁[ ▁] ▁[ ▁] ▁arr ▁, ▁int ▁N ▁) ▁{ ▁int ▁group ▁= ▁arr ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁!= ▁group ▁) ▁{ ▁return ▁" ▁Yes ▁" ▁; ▁} ▁} ▁if ▁( ▁is Sorted ▁( ▁arr ▁, ▁N ▁) ▁) ▁{ ▁return ▁" ▁Yes ▁" ▁; ▁} ▁else ▁{ ▁return ▁" ▁No ▁" ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁34 0000 ▁, ▁2 ▁} ▁, ▁{ ▁45 000 ▁, ▁1 ▁} ▁, ▁{ ▁30000 ▁, ▁2 ▁} ▁, ▁{ ▁50000 ▁, ▁4 ▁} ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁isP ossible To Sort ▁( ▁arr ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁max Len Subset ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁a ▁) ▁; ▁int ▁index ▁= ▁0 ▁, ▁maxlen ▁= ▁- ▁1 ▁; ▁int ▁i ▁= ▁0 ▁; ▁while ▁( ▁i ▁< ▁n ▁) ▁{ ▁int ▁j ▁= ▁i ▁; ▁int ▁len ▁= ▁1 ▁; ▁while ▁( ▁j ▁< ▁n ▁- ▁1 ▁) ▁{ ▁if ▁( ▁2 ▁* ▁a ▁[ ▁j ▁] ▁>= ▁a ▁[ ▁j ▁+ ▁1 ▁] ▁) ▁{ ▁len ▁++ ▁; ▁} ▁else ▁break ▁; ▁j ▁++ ▁; ▁} ▁if ▁( ▁maxlen ▁< ▁len ▁) ▁{ ▁maxlen ▁= ▁len ▁; ▁index ▁= ▁i ▁; ▁} ▁j ▁++ ▁; ▁i ▁= ▁j ▁; ▁} ▁i ▁= ▁index ▁; ▁while ▁( ▁maxlen ▁> ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁a ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁maxlen ▁-- ▁; ▁i ▁++ ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁1 ▁, ▁5 ▁, ▁11 ▁} ▁; ▁int ▁n ▁= ▁a ▁. ▁length ▁; ▁max Len Subset ▁( ▁a ▁, ▁n ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁maximum Sum ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁N ▁) ▁{ ▁int ▁sum ▁; ▁Arrays ▁. ▁sort ▁( ▁arr ▁) ▁; ▁sum ▁= ▁( ▁arr ▁[ ▁N ▁- ▁1 ▁] ▁- ▁arr ▁[ ▁0 ▁] ▁) ▁+ ▁( ▁arr ▁[ ▁N ▁- ▁2 ▁] ▁- ▁arr ▁[ ▁0 ▁] ▁) ▁+ ▁( ▁arr ▁[ ▁N ▁- ▁1 ▁] ▁- ▁arr ▁[ ▁N ▁- ▁2 ▁] ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁sum ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁4 ▁, ▁2 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁maximum Sum ▁( ▁arr ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁min Operation ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁tot Ops ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁tot Ops ▁+= ▁Math ▁. ▁abs ▁( ▁a ▁[ ▁i ▁] ▁- ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁; ▁} ▁int ▁max Ops ▁= ▁Math ▁. ▁max ▁( ▁Math ▁. ▁abs ▁( ▁a ▁[ ▁0 ▁] ▁- ▁a ▁[ ▁1 ▁] ▁) ▁, ▁Math ▁. ▁abs ▁( ▁a ▁[ ▁N ▁- ▁1 ▁] ▁- ▁a ▁[ ▁N ▁- ▁2 ▁] ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁max Ops ▁= ▁Math ▁. ▁max ▁( ▁max Ops ▁, ▁Math ▁. ▁abs ▁( ▁a ▁[ ▁i ▁] ▁- ▁a ▁[ ▁i ▁- ▁1 ▁] ▁) ▁+ ▁Math ▁. ▁abs ▁( ▁a ▁[ ▁i ▁] ▁- ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁- ▁Math ▁. ▁abs ▁( ▁a ▁[ ▁i ▁- ▁1 ▁] ▁- ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁tot Ops ▁- ▁max Ops ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁1 ▁, ▁- ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁min Operation ▁( ▁arr ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁num Operation ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁D ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁arr ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁arr ▁[ ▁i ▁+ ▁1 ▁] ▁- ▁arr ▁[ ▁i ▁] ▁) ▁% ▁D ▁!= ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁- ▁1" ▁) ▁; ▁return ▁; ▁} ▁} ▁int ▁count ▁= ▁0 ▁; ▁int ▁mid ▁= ▁arr ▁[ ▁N ▁/ ▁2 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁count ▁+= ▁Math ▁. ▁abs ▁( ▁mid ▁- ▁arr ▁[ ▁i ▁] ▁) ▁/ ▁D ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁count ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁4 ▁, ▁D ▁= ▁2 ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁4 ▁, ▁6 ▁, ▁8 ▁} ▁; ▁num Operation ▁( ▁arr ▁, ▁N ▁, ▁D ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁find Sum ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁A ▁) ▁; ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁N ▁/ ▁K ▁; ▁i ▁< ▁N ▁; ▁i ▁+= ▁K ▁- ▁1 ▁) ▁{ ▁sum ▁+= ▁A ▁[ ▁i ▁] ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁sum ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁K ▁= ▁4 ▁; ▁int ▁A ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁1 ▁, ▁4 ▁, ▁7 ▁, ▁5 ▁, ▁6 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁A ▁. ▁length ▁; ▁find Sum ▁( ▁A ▁, ▁N ▁, ▁K ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁merge ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁temp ▁[ ▁] ▁, ▁int ▁l ▁, ▁int ▁m ▁, ▁int ▁r ▁, ▁int ▁K ▁) ▁{ ▁int ▁i ▁= ▁l ▁; ▁int ▁j ▁= ▁m ▁+ ▁1 ▁; ▁int ▁cnt ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁l ▁; ▁i ▁<= ▁m ▁; ▁i ▁++ ▁) ▁{ ▁boolean ▁found ▁= ▁false ▁; ▁while ▁( ▁j ▁<= ▁r ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁>= ▁K ▁* ▁arr ▁[ ▁j ▁] ▁) ▁{ ▁found ▁= ▁true ▁; ▁} ▁else ▁break ▁; ▁j ▁++ ▁; ▁} ▁if ▁( ▁found ▁== ▁true ▁) ▁{ ▁cnt ▁+= ▁j ▁- ▁( ▁m ▁+ ▁1 ▁) ▁; ▁j ▁-- ▁; ▁} ▁} ▁int ▁k ▁= ▁l ▁; ▁i ▁= ▁l ▁; ▁j ▁= ▁m ▁+ ▁1 ▁; ▁while ▁( ▁i ▁<= ▁m ▁&& ▁j ▁<= ▁r ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁<= ▁arr ▁[ ▁j ▁] ▁) ▁temp ▁[ ▁k ▁++ ▁] ▁= ▁arr ▁[ ▁i ▁++ ▁] ▁; ▁else ▁temp ▁[ ▁k ▁++ ▁] ▁= ▁arr ▁[ ▁j ▁++ ▁] ▁; ▁} ▁while ▁( ▁i ▁<= ▁m ▁) ▁temp ▁[ ▁k ▁++ ▁] ▁= ▁arr ▁[ ▁i ▁++ ▁] ▁; ▁while ▁( ▁j ▁<= ▁r ▁) ▁temp ▁[ ▁k ▁++ ▁] ▁= ▁arr ▁[ ▁j ▁++ ▁] ▁; ▁for ▁( ▁i ▁= ▁l ▁; ▁i ▁<= ▁r ▁; ▁i ▁++ ▁) ▁arr ▁[ ▁i ▁] ▁= ▁temp ▁[ ▁i ▁] ▁; ▁return ▁cnt ▁; ▁} ▁static ▁int ▁merge Sort Util ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁temp ▁[ ▁] ▁, ▁int ▁l ▁, ▁int ▁r ▁, ▁int ▁K ▁) ▁{ ▁int ▁cnt ▁= ▁0 ▁; ▁if ▁( ▁l ▁< ▁r ▁) ▁{ ▁int ▁m ▁= ▁( ▁l ▁+ ▁r ▁) ▁/ ▁2 ▁; ▁cnt ▁+= ▁merge Sort Util ▁( ▁arr ▁, ▁temp ▁, ▁l ▁, ▁m ▁, ▁K ▁) ▁; ▁cnt ▁+= ▁merge Sort Util ▁( ▁arr ▁, ▁temp ▁, ▁m ▁+ ▁1 ▁, ▁r ▁, ▁K ▁) ▁; ▁cnt ▁+= ▁merge ▁( ▁arr ▁, ▁temp ▁, ▁l ▁, ▁m ▁, ▁r ▁, ▁K ▁) ▁; ▁} ▁return ▁cnt ▁; ▁} ▁static ▁void ▁merge Sort ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁int ▁temp ▁[ ▁] ▁= ▁new ▁int ▁[ ▁N ▁] ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁merge Sort Util ▁( ▁arr ▁, ▁temp ▁, ▁0 ▁, ▁N ▁- ▁1 ▁, ▁K ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁6 ▁, ▁2 ▁, ▁5 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁int ▁K ▁= ▁2 ▁; ▁merge Sort ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁B ubble _ Sort ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁n ▁) ▁{ ▁boolean ▁flag ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁{ ▁flag ▁= ▁false ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁<= ▁( ▁n ▁- ▁i ▁- ▁1 ▁) ▁; ▁++ ▁j ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁j ▁] ▁> ▁arr ▁[ ▁j ▁+ ▁1 ▁] ▁) ▁{ ▁int ▁temp ▁= ▁arr ▁[ ▁j ▁] ▁; ▁arr ▁[ ▁j ▁] ▁= ▁arr ▁[ ▁j ▁+ ▁1 ▁] ▁; ▁arr ▁[ ▁j ▁+ ▁1 ▁] ▁= ▁temp ▁; ▁flag ▁= ▁true ▁; ▁} ▁} ▁if ▁( ▁flag ▁== ▁false ▁) ▁break ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁5 ▁; ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁2 ▁, ▁0 ▁, ▁1 ▁, ▁4 ▁, ▁3 ▁} ▁; ▁B ubble _ Sort ▁( ▁arr ▁, ▁n ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁The ▁Sorted ▁Array ▁by ▁" ▁+ ▁" ▁using ▁B ubble ▁Sort ▁is ▁: ▁" ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁min Rem ovals ▁( ▁int ▁[ ▁] ▁A ▁, ▁int ▁N ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁A ▁) ▁; ▁int ▁mx ▁= ▁A ▁[ ▁N ▁- ▁1 ▁] ▁; ▁int ▁sum ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁A ▁[ ▁i ▁] ▁; ▁} ▁if ▁( ▁sum ▁- ▁mx ▁>= ▁mx ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁0 ▁) ▁; ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁2 ▁* ▁mx ▁- ▁sum ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁A ▁= ▁{ ▁3 ▁, ▁3 ▁, ▁2 ▁} ▁; ▁int ▁N ▁= ▁A ▁. ▁length ▁; ▁min Rem ovals ▁( ▁A ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁max Rectangle ▁( ▁int ▁[ ▁] ▁[ ▁] ▁sequence ▁, ▁int ▁size ▁) ▁{ ▁int ▁[ ▁] ▁X _ C ord ▁= ▁new ▁int ▁[ ▁size ▁] ▁; ▁int ▁[ ▁] ▁Y _ C ord ▁= ▁new ▁int ▁[ ▁size ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁{ ▁X _ C ord ▁[ ▁i ▁] ▁= ▁sequence ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁; ▁Y _ C ord ▁[ ▁i ▁] ▁= ▁sequence ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁; ▁} ▁Arrays ▁. ▁sort ▁( ▁X _ C ord ▁) ▁; ▁Arrays ▁. ▁sort ▁( ▁Y _ C ord ▁) ▁; ▁int ▁X _ Max ▁= ▁0 ▁, ▁Y _ Max ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁X _ Max ▁= ▁Math ▁. ▁max ▁( ▁X _ Max ▁, ▁X _ C ord ▁[ ▁i ▁+ ▁1 ▁] ▁- ▁X _ C ord ▁[ ▁i ▁] ▁) ▁; ▁Y _ Max ▁= ▁Math ▁. ▁max ▁( ▁Y _ Max ▁, ▁Y _ C ord ▁[ ▁i ▁+ ▁1 ▁] ▁- ▁Y _ C ord ▁[ ▁i ▁] ▁) ▁; ▁} ▁return ▁X _ Max ▁* ▁Y _ Max ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁[ ▁] ▁point ▁= ▁{ ▁{ ▁- ▁2 ▁, ▁0 ▁} ▁, ▁{ ▁2 ▁, ▁0 ▁} ▁, ▁{ ▁4 ▁, ▁0 ▁} ▁, ▁{ ▁4 ▁, ▁2 ▁} ▁} ▁; ▁int ▁n ▁= ▁point ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁max Rectangle ▁( ▁point ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁check Arr angement ▁( ▁Integer ▁[ ▁] ▁A 1 ▁, ▁Integer ▁[ ▁] ▁A 2 ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁A 1 ▁) ▁; ▁Arrays ▁. ▁sort ▁( ▁A 2 ▁, ▁Collections ▁. ▁reverse Order ▁( ▁) ▁) ▁; ▁int ▁flag ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁A 1 ▁[ ▁i ▁] ▁+ ▁A 2 ▁[ ▁i ▁] ▁> ▁k ▁) ▁|| ▁( ▁A 1 ▁[ ▁i ▁] ▁+ ▁A 2 ▁[ ▁i ▁] ▁< ▁k ▁/ ▁2 ▁) ▁) ▁{ ▁flag ▁= ▁1 ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁flag ▁== ▁1 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Integer ▁[ ▁] ▁arr 1 ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁Integer ▁[ ▁] ▁arr 2 ▁= ▁{ ▁2 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁} ▁; ▁int ▁K ▁= ▁6 ▁; ▁int ▁N ▁= ▁arr 1 ▁. ▁length ▁; ▁check Arr angement ▁( ▁arr 1 ▁, ▁arr 2 ▁, ▁N ▁, ▁K ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁sort array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁if ▁( ▁N ▁== ▁3 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁NO ▁" ▁) ▁; ▁else ▁if ▁( ▁N ▁% ▁4 ▁== ▁0 ▁N ▁% ▁4 ▁== ▁1 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁YES ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁N ▁/ ▁2 ▁) ▁; ▁int ▁k ▁= ▁1 ▁, ▁l ▁; ▁for ▁( ▁l ▁= ▁0 ▁; ▁l ▁< ▁( ▁N ▁/ ▁4 ▁) ▁; ▁l ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁k ▁+ ▁" ▁" ▁+ ▁( ▁k ▁+ ▁1 ▁) ▁+ ▁" ▁" ▁+ ▁N ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁k ▁+ ▁1 ▁+ ▁" ▁" ▁+ ▁N ▁+ ▁" ▁" ▁+ ▁( ▁N ▁- ▁1 ▁) ▁) ▁; ▁k ▁= ▁k ▁+ ▁2 ▁; ▁N ▁= ▁N ▁- ▁2 ▁; ▁} ▁} ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁NO ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁5 ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁4 ▁, ▁3 ▁, ▁2 ▁, ▁1 ▁} ▁; ▁sort array ▁( ▁arr ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁find Min Sum ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁K ▁, ▁int ▁L ▁, ▁int ▁size ▁) ▁{ ▁if ▁( ▁K ▁* ▁L ▁> ▁size ▁) ▁return ▁- ▁1 ▁; ▁int ▁min sum ▁= ▁0 ▁; ▁Arrays ▁. ▁sort ▁( ▁arr ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁K ▁; ▁i ▁++ ▁) ▁min sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁return ▁min sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁15 ▁, ▁5 ▁, ▁1 ▁, ▁35 ▁, ▁16 ▁, ▁67 ▁, ▁10 ▁} ▁; ▁int ▁K ▁= ▁3 ▁; ▁int ▁L ▁= ▁2 ▁; ▁int ▁length ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁find Min Sum ▁( ▁arr ▁, ▁K ▁, ▁L ▁, ▁length ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁find K th Small est ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁max ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁max ▁) ▁max ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁int ▁[ ▁] ▁counter ▁= ▁new ▁int ▁[ ▁max ▁+ ▁1 ▁] ▁; ▁int ▁smallest ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁counter ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁++ ▁; ▁} ▁for ▁( ▁int ▁num ▁= ▁1 ▁; ▁num ▁<= ▁max ▁; ▁num ▁++ ▁) ▁{ ▁if ▁( ▁counter ▁[ ▁num ▁] ▁> ▁0 ▁) ▁{ ▁smallest ▁+= ▁counter ▁[ ▁num ▁] ▁; ▁} ▁if ▁( ▁smallest ▁>= ▁k ▁) ▁{ ▁return ▁num ▁; ▁} ▁} ▁return ▁- ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁7 ▁, ▁1 ▁, ▁4 ▁, ▁4 ▁, ▁20 ▁, ▁15 ▁, ▁8 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁int ▁K ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁find K th Small est ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁N ▁= ▁4 ▁; ▁static ▁void ▁func ▁( ▁int ▁a ▁[ ▁] ▁[ ▁] ▁) ▁{ ▁int ▁i ▁, ▁j ▁, ▁k ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁for ▁( ▁k ▁= ▁j ▁+ ▁1 ▁; ▁k ▁< ▁N ▁; ▁++ ▁k ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁[ ▁j ▁] ▁> ▁a ▁[ ▁i ▁] ▁[ ▁k ▁] ▁) ▁{ ▁int ▁temp ▁= ▁a ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁a ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁a ▁[ ▁i ▁] ▁[ ▁k ▁] ▁; ▁a ▁[ ▁i ▁] ▁[ ▁k ▁] ▁= ▁temp ▁; ▁} ▁} ▁} ▁} ▁else ▁{ ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁for ▁( ▁k ▁= ▁j ▁+ ▁1 ▁; ▁k ▁< ▁N ▁; ▁++ ▁k ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁[ ▁j ▁] ▁< ▁a ▁[ ▁i ▁] ▁[ ▁k ▁] ▁) ▁{ ▁int ▁temp ▁= ▁a ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁a ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁a ▁[ ▁i ▁] ▁[ ▁k ▁] ▁; ▁a ▁[ ▁i ▁] ▁[ ▁k ▁] ▁= ▁temp ▁; ▁} ▁} ▁} ▁} ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁a ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁" NEW _ LINE "); ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁5 ▁, ▁7 ▁, ▁3 ▁, ▁4 ▁} ▁, ▁{ ▁9 ▁, ▁5 ▁, ▁8 ▁, ▁2 ▁} ▁, ▁{ ▁6 ▁, ▁3 ▁, ▁8 ▁, ▁1 ▁} ▁, ▁{ ▁5 ▁, ▁8 ▁, ▁9 ▁, ▁3 ▁} ▁} ▁; ▁func ▁( ▁a ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁[ ▁] ▁g ▁= ▁new ▁HashMap ▁[ ▁20000 5 ▁] ▁; ▁static ▁HashSet ▁< ▁Integer ▁> ▁s ▁= ▁new ▁HashSet ▁< ▁> ▁( ▁) ▁; ▁static ▁HashSet ▁< ▁Integer ▁> ▁ns ▁= ▁new ▁HashSet ▁< ▁> ▁( ▁) ▁; ▁static ▁void ▁dfs ▁( ▁int ▁x ▁) ▁{ ▁Vector ▁< ▁Integer ▁> ▁v ▁= ▁new ▁Vector ▁< ▁> ▁( ▁) ▁; ▁v ▁. ▁clear ▁( ▁) ▁; ▁ns ▁. ▁clear ▁( ▁) ▁; ▁for ▁( ▁int ▁it ▁: ▁s ▁) ▁{ ▁if ▁( ▁g ▁[ ▁x ▁] ▁. ▁get ▁( ▁it ▁) ▁!= ▁null ▁) ▁{ ▁v ▁. ▁add ▁( ▁it ▁) ▁; ▁} ▁else ▁{ ▁ns ▁. ▁add ▁( ▁it ▁) ▁; ▁} ▁} ▁s ▁= ▁ns ▁; ▁for ▁( ▁int ▁i ▁: ▁v ▁) ▁{ ▁dfs ▁( ▁i ▁) ▁; ▁} ▁} ▁static ▁void ▁weight Of M ST ▁( ▁int ▁N ▁) ▁{ ▁int ▁cnt ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁N ▁; ▁++ ▁i ▁) ▁{ ▁s ▁. ▁add ▁( ▁i ▁) ▁; ▁} ▁Vector ▁< ▁Integer ▁> ▁qt ▁= ▁new ▁Vector ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁t ▁: ▁s ▁) ▁qt ▁. ▁add ▁( ▁t ▁) ▁; ▁while ▁( ▁! ▁qt ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁++ ▁cnt ▁; ▁int ▁t ▁= ▁qt ▁. ▁get ▁( ▁0 ▁) ▁; ▁qt ▁. ▁remove ▁( ▁0 ▁) ▁; ▁dfs ▁( ▁t ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁cnt ▁- ▁4 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁6 ▁, ▁M ▁= ▁11 ▁; ▁int ▁edges ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁3 ▁} ▁, ▁{ ▁1 ▁, ▁4 ▁} ▁, ▁{ ▁1 ▁, ▁5 ▁} ▁, ▁{ ▁1 ▁, ▁6 ▁} ▁, ▁{ ▁2 ▁, ▁3 ▁} ▁, ▁{ ▁2 ▁, ▁4 ▁} ▁, ▁{ ▁2 ▁, ▁5 ▁} ▁, ▁{ ▁2 ▁, ▁6 ▁} ▁, ▁{ ▁3 ▁, ▁4 ▁} ▁, ▁{ ▁3 ▁, ▁5 ▁} ▁, ▁{ ▁3 ▁, ▁6 ▁} ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁g ▁. ▁length ▁; ▁i ▁++ ▁) ▁g ▁[ ▁i ▁] ▁= ▁new ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁M ▁; ▁++ ▁i ▁) ▁{ ▁int ▁u ▁= ▁edges ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁; ▁int ▁v ▁= ▁edges ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁; ▁g ▁[ ▁u ▁] ▁. ▁put ▁( ▁v ▁, ▁1 ▁) ▁; ▁g ▁[ ▁v ▁] ▁. ▁put ▁( ▁u ▁, ▁1 ▁) ▁; ▁} ▁weight Of M ST ▁( ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁sort Diff ▁( ▁Vector ▁< ▁Integer ▁> ▁arr ▁, ▁int ▁n ▁) ▁{ ▁Collections ▁. ▁sort ▁( ▁arr ▁) ▁; ▁Vector ▁< ▁Integer ▁> ▁out ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁while ▁( ▁n ▁> ▁0 ▁) ▁{ ▁out ▁. ▁add ▁( ▁arr ▁. ▁get ▁( ▁n ▁/ ▁2 ▁) ▁) ▁; ▁arr ▁. ▁remove ▁( ▁n ▁/ ▁2 ▁) ▁; ▁n ▁= ▁n ▁- ▁1 ▁; ▁} ▁for ▁( ▁int ▁i ▁: ▁out ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁i ▁+ ▁" ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Integer ▁[ ▁] ▁a ▁= ▁{ ▁8 ▁, ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁0 ▁} ▁; ▁Vector ▁< ▁Integer ▁> ▁arr ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁Arrays ▁. ▁asList ▁( ▁a ▁) ▁) ▁; ▁int ▁n ▁= ▁5 ▁; ▁sort Diff ▁( ▁arr ▁, ▁n ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁count Pairs ▁( ▁int ▁[ ▁] ▁A ▁, ▁int ▁[ ▁] ▁B ▁) ▁{ ▁int ▁n ▁= ▁A ▁. ▁length ▁; ▁int ▁ans ▁= ▁0 ▁; ▁Arrays ▁. ▁sort ▁( ▁A ▁) ▁; ▁Arrays ▁. ▁sort ▁( ▁B ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁A ▁[ ▁i ▁] ▁> ▁B ▁[ ▁ans ▁] ▁) ▁{ ▁ans ▁++ ▁; ▁} ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁A ▁= ▁{ ▁30 ▁, ▁28 ▁, ▁45 ▁, ▁22 ▁} ▁; ▁int ▁[ ▁] ▁B ▁= ▁{ ▁35 ▁, ▁25 ▁, ▁22 ▁, ▁48 ▁} ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁count Pairs ▁( ▁A ▁, ▁B ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁re vers Digits ▁( ▁int ▁num ▁) ▁{ ▁int ▁rev _ num ▁= ▁0 ▁; ▁while ▁( ▁num ▁> ▁0 ▁) ▁{ ▁rev _ num ▁= ▁rev _ num ▁* ▁10 ▁+ ▁num ▁% ▁10 ▁; ▁num ▁= ▁num ▁/ ▁10 ▁; ▁} ▁return ▁rev _ num ▁; ▁} ▁static ▁void ▁sort Arr ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁ArrayList ▁< ▁int ▁[ ▁] ▁> ▁vp ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁vp ▁. ▁add ▁( ▁new ▁int ▁[ ▁] ▁{ ▁re vers Digits ▁( ▁arr ▁[ ▁i ▁] ▁) ▁, ▁arr ▁[ ▁i ▁] ▁} ▁) ▁; ▁} ▁Collections ▁. ▁sort ▁( ▁vp ▁, ▁( ▁a ▁, ▁b ▁) ▁-> ▁a ▁[ ▁0 ▁] ▁- ▁b ▁[ ▁0 ▁] ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁vp ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁vp ▁. ▁get ▁( ▁i ▁) ▁[ ▁1 ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁12 ▁, ▁10 ▁, ▁102 ▁, ▁31 ▁, ▁15 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁sort Arr ▁( ▁arr ▁, ▁n ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁[ ▁] ▁org az ine InOrder ▁( ▁int ▁[ ▁] ▁vec ▁, ▁int ▁[ ▁] ▁op ▁, ▁int ▁n ▁) ▁{ ▁int ▁[ ▁] ▁result ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁Arrays ▁. ▁sort ▁( ▁vec ▁) ▁; ▁int ▁i ▁= ▁0 ▁, ▁j ▁= ▁n ▁- ▁1 ▁, ▁k ▁= ▁0 ▁; ▁while ▁( ▁i ▁<= ▁j ▁&& ▁k ▁<= ▁n ▁- ▁2 ▁) ▁{ ▁if ▁( ▁op ▁[ ▁k ▁] ▁== ▁' ▁< ▁' ▁) ▁{ ▁result ▁[ ▁k ▁] ▁= ▁vec ▁[ ▁i ▁++ ▁] ▁; ▁} ▁else ▁{ ▁result ▁[ ▁k ▁] ▁= ▁vec ▁[ ▁j ▁-- ▁] ▁; ▁} ▁k ▁++ ▁; ▁} ▁result ▁[ ▁n ▁- ▁1 ▁] ▁= ▁vec ▁[ ▁i ▁] ▁; ▁return ▁result ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁vec ▁= ▁{ ▁8 ▁, ▁2 ▁, ▁7 ▁, ▁1 ▁, ▁5 ▁, ▁9 ▁} ▁; ▁int ▁[ ▁] ▁op ▁= ▁{ ▁' ▁> ▁' ▁, ▁' ▁> ▁' ▁, ▁' ▁< ▁' ▁, ▁' ▁> ▁' ▁, ▁' ▁< ▁' ▁} ▁; ▁int ▁[ ▁] ▁result ▁= ▁org az ine InOrder ▁( ▁vec ▁, ▁op ▁, ▁vec ▁. ▁length ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁result ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁result ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁MAX ▁= ▁1000 ▁; ▁static ▁boolean ▁line Exists ▁( ▁int ▁x ▁[ ▁] ▁, ▁int ▁y ▁[ ▁] ▁, ▁int ▁v ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁size ▁= ▁( ▁2 ▁* ▁MAX ▁) ▁+ ▁1 ▁; ▁long ▁[ ▁] ▁arr ▁= ▁new ▁long ▁[ ▁size ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁arr ▁[ ▁x ▁[ ▁i ▁] ▁+ ▁MAX ▁] ▁+= ▁v ▁[ ▁i ▁] ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁arr ▁[ ▁i ▁] ▁+= ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁; ▁if ▁( ▁arr ▁[ ▁size ▁- ▁1 ▁] ▁== ▁0 ▁) ▁return ▁true ▁; ▁if ▁( ▁arr ▁[ ▁size ▁- ▁1 ▁] ▁- ▁arr ▁[ ▁0 ▁] ▁== ▁0 ▁) ▁return ▁true ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁size ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁== ▁arr ▁[ ▁size ▁- ▁1 ▁] ▁- ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁) ▁return ▁true ▁; ▁if ▁( ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁== ▁arr ▁[ ▁size ▁- ▁1 ▁] ▁- ▁arr ▁[ ▁i ▁] ▁) ▁return ▁true ▁; ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁arr ▁[ ▁size ▁- ▁1 ▁] ▁- ▁arr ▁[ ▁i ▁] ▁) ▁return ▁true ▁; ▁} ▁if ▁( ▁arr ▁[ ▁size ▁- ▁2 ▁] ▁== ▁0 ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁x ▁[ ▁] ▁= ▁{ ▁- ▁3 ▁, ▁5 ▁, ▁8 ▁} ▁; ▁int ▁y ▁[ ▁] ▁= ▁{ ▁8 ▁, ▁7 ▁, ▁9 ▁} ▁; ▁int ▁v ▁[ ▁] ▁= ▁{ ▁8 ▁, ▁2 ▁, ▁10 ▁} ▁; ▁int ▁n ▁= ▁x ▁. ▁length ▁; ▁if ▁( ▁line Exists ▁( ▁x ▁, ▁y ▁, ▁v ▁, ▁n ▁) ▁) ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁max Sum ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁a ▁) ▁; ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁+= ▁2 ▁) ▁{ ▁sum ▁+= ▁a ▁[ ▁i ▁] ▁; ▁} ▁return ▁sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁2 ▁, ▁1 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁max Sum ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁class ▁g eek s forge ek s ▁{ ▁static ▁int ▁min Operations ▁( ▁int ▁ar ▁[ ▁] ▁, ▁int ▁k ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁ar ▁) ▁; ▁int ▁ops Needed ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁k ▁; ▁i ▁++ ▁) ▁{ ▁ops Needed ▁+= ▁ar ▁[ ▁k ▁- ▁1 ▁] ▁- ▁ar ▁[ ▁i ▁] ▁; ▁} ▁int ▁ans ▁= ▁ops Needed ▁; ▁for ▁( ▁int ▁i ▁= ▁k ▁; ▁i ▁< ▁ar ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁ops Needed ▁= ▁ops Needed ▁- ▁( ▁ar ▁[ ▁i ▁- ▁1 ▁] ▁- ▁ar ▁[ ▁i ▁- ▁k ▁] ▁) ▁; ▁ops Needed ▁+= ▁( ▁k ▁- ▁1 ▁) ▁* ▁( ▁ar ▁[ ▁i ▁] ▁- ▁ar ▁[ ▁i ▁- ▁1 ▁] ▁) ▁; ▁ans ▁= ▁Math ▁. ▁min ▁( ▁ans ▁, ▁ops Needed ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁3 ▁, ▁1 ▁, ▁9 ▁, ▁100 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁int ▁k ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁% ▁d ▁" ▁, ▁min Operations ▁( ▁arr ▁, ▁k ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁float ▁kn ap S ack ▁( ▁int ▁W ▁, ▁float ▁wt ▁[ ▁] ▁, ▁float ▁val ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁float ▁max ratio ▁= ▁Integer ▁. ▁MIN _ VALUE ▁; ▁int ▁max index ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁val ▁[ ▁i ▁] ▁/ ▁wt ▁[ ▁i ▁] ▁) ▁> ▁max ratio ▁) ▁{ ▁max ratio ▁= ▁( ▁val ▁[ ▁i ▁] ▁/ ▁wt ▁[ ▁i ▁] ▁) ▁; ▁max index ▁= ▁i ▁; ▁} ▁} ▁return ▁( ▁W ▁* ▁max ratio ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁float ▁val ▁[ ▁] ▁= ▁{ ▁14 ▁, ▁27 ▁, ▁44 ▁, ▁19 ▁} ▁; ▁float ▁wt ▁[ ▁] ▁= ▁{ ▁6 ▁, ▁7 ▁, ▁9 ▁, ▁8 ▁} ▁; ▁int ▁n ▁= ▁val ▁. ▁length ▁; ▁int ▁W ▁= ▁50 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁kn ap S ack ▁( ▁W ▁, ▁wt ▁, ▁val ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁class ▁Node ▁{ ▁int ▁data ▁; ▁Node ▁left ▁; ▁Node ▁right ▁; ▁} ▁; ▁static ▁Node ▁newNode ▁( ▁int ▁num ▁) ▁{ ▁Node ▁temp ▁= ▁new ▁Node ▁( ▁) ▁; ▁temp ▁. ▁data ▁= ▁num ▁; ▁temp ▁. ▁left ▁= ▁temp ▁. ▁right ▁= ▁null ▁; ▁return ▁temp ▁; ▁} ▁static ▁void ▁in order ▁( ▁Node ▁root ▁) ▁{ ▁if ▁( ▁root ▁!= ▁null ▁) ▁{ ▁in order ▁( ▁root ▁. ▁left ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁root ▁. ▁data ▁+ ▁" ▁" ▁) ▁; ▁in order ▁( ▁root ▁. ▁right ▁) ▁; ▁} ▁} ▁static ▁void ▁merge ▁( ▁Node ▁root 1 ▁, ▁Node ▁root 2 ▁) ▁{ ▁if ▁( ▁root 1 ▁== ▁null ▁&& ▁root 2 ▁== ▁null ▁) ▁return ▁; ▁if ▁( ▁root 1 ▁== ▁null ▁) ▁{ ▁in order ▁( ▁root 2 ▁) ▁; ▁return ▁; ▁} ▁if ▁( ▁root 2 ▁== ▁null ▁) ▁{ ▁in order ▁( ▁root 1 ▁) ▁; ▁return ▁; ▁} ▁Node ▁temp 1 ▁= ▁root 1 ▁; ▁Node ▁prev 1 ▁= ▁null ▁; ▁while ▁( ▁temp 1 ▁. ▁left ▁!= ▁null ▁) ▁{ ▁prev 1 ▁= ▁temp 1 ▁; ▁temp 1 ▁= ▁temp 1 ▁. ▁left ▁; ▁} ▁Node ▁temp 2 ▁= ▁root 2 ▁; ▁Node ▁prev 2 ▁= ▁null ▁; ▁while ▁( ▁temp 2 ▁. ▁left ▁!= ▁null ▁) ▁{ ▁prev 2 ▁= ▁temp 2 ▁; ▁temp 2 ▁= ▁temp 2 ▁. ▁left ▁; ▁} ▁if ▁( ▁temp 1 ▁. ▁data ▁<= ▁temp 2 ▁. ▁data ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁temp 1 ▁. ▁data ▁+ ▁" ▁" ▁) ▁; ▁if ▁( ▁prev 1 ▁== ▁null ▁) ▁{ ▁merge ▁( ▁root 1 ▁. ▁right ▁, ▁root 2 ▁) ▁; ▁} ▁else ▁{ ▁prev 1 ▁. ▁left ▁= ▁temp 1 ▁. ▁right ▁; ▁merge ▁( ▁root 1 ▁, ▁root 2 ▁) ▁; ▁} ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁temp 2 ▁. ▁data ▁+ ▁" ▁" ▁) ▁; ▁if ▁( ▁prev 2 ▁== ▁null ▁) ▁{ ▁merge ▁( ▁root 1 ▁, ▁root 2 ▁. ▁right ▁) ▁; ▁} ▁else ▁{ ▁prev 2 ▁. ▁left ▁= ▁temp 2 ▁. ▁right ▁; ▁merge ▁( ▁root 1 ▁, ▁root 2 ▁) ▁; ▁} ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁Node ▁root 1 ▁= ▁null ▁, ▁root 2 ▁= ▁null ▁; ▁root 1 ▁= ▁newNode ▁( ▁3 ▁) ▁; ▁root 1 ▁. ▁left ▁= ▁newNode ▁( ▁1 ▁) ▁; ▁root 1 ▁. ▁right ▁= ▁newNode ▁( ▁5 ▁) ▁; ▁root 2 ▁= ▁newNode ▁( ▁4 ▁) ▁; ▁root 2 ▁. ▁left ▁= ▁newNode ▁( ▁2 ▁) ▁; ▁root 2 ▁. ▁right ▁= ▁newNode ▁( ▁6 ▁) ▁; ▁merge ▁( ▁root 1 ▁, ▁root 2 ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁class ▁G F G ▁{ ▁static ▁long ▁mod ▁= ▁100 000000 7 ▁; ▁static ▁long ▁[ ▁] ▁[ ▁] ▁arr ▁= ▁new ▁long ▁[ ▁1001 ▁] ▁[ ▁1001 ▁] ▁; ▁static ▁void ▁Pre process ▁( ▁) ▁{ ▁arr ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁1000 ▁; ▁++ ▁i ▁) ▁{ ▁arr ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁< ▁i ▁; ▁++ ▁j ▁) ▁{ ▁arr ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁( ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁- ▁1 ▁] ▁+ ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁) ▁% ▁mod ▁; ▁} ▁arr ▁[ ▁i ▁] ▁[ ▁i ▁] ▁= ▁1 ▁; ▁} ▁} ▁static ▁long ▁pow mod ▁( ▁long ▁a ▁, ▁long ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁0 ▁) ▁{ ▁return ▁1 ▁; ▁} ▁long ▁pt ▁= ▁pow mod ▁( ▁a ▁, ▁n ▁/ ▁2 ▁) ▁; ▁pt ▁= ▁( ▁pt ▁* ▁pt ▁) ▁% ▁mod ▁; ▁if ▁( ▁n ▁% ▁2 ▁== ▁1 ▁) ▁{ ▁return ▁( ▁pt ▁* ▁a ▁) ▁% ▁mod ▁; ▁} ▁else ▁{ ▁return ▁pt ▁; ▁} ▁} ▁static ▁long ▁Count Subset ▁( ▁int ▁[ ▁] ▁val ▁, ▁int ▁n ▁) ▁{ ▁long ▁ans ▁= ▁pow mod ▁( ▁2 ▁, ▁n ▁- ▁1 ▁) ▁; ▁Arrays ▁. ▁sort ▁( ▁val ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁{ ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁while ▁( ▁j ▁< ▁n ▁&& ▁val ▁[ ▁j ▁] ▁== ▁val ▁[ ▁i ▁] ▁) ▁{ ▁int ▁r ▁= ▁n ▁- ▁1 ▁- ▁j ▁; ▁int ▁l ▁= ▁i ▁; ▁ans ▁= ▁( ▁ans ▁+ ▁arr ▁[ ▁l ▁+ ▁r ▁] ▁[ ▁l ▁] ▁) ▁% ▁mod ▁; ▁j ▁++ ▁; ▁} ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Pre process ▁( ▁) ▁; ▁int ▁val ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁val ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁Count Subset ▁( ▁val ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁re Ar range ▁( ▁String ▁words ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁HashMap ▁< ▁String ▁, ▁Integer ▁> ▁freq ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁freq ▁. ▁put ▁( ▁words ▁[ ▁i ▁] ▁, ▁( ▁i ▁+ ▁1 ▁) ▁) ▁; ▁} ▁Arrays ▁. ▁sort ▁( ▁words ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁freq ▁. ▁get ▁( ▁words ▁[ ▁i ▁] ▁) ▁+ ▁" ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁words ▁[ ▁] ▁= ▁{ ▁" ▁live ▁" ▁, ▁" ▁place ▁" ▁, ▁" ▁travel ▁" ▁, ▁" ▁word ▁" ▁, ▁" ▁sky ▁" ▁} ▁; ▁int ▁n ▁= ▁words ▁. ▁length ▁; ▁re Ar range ▁( ▁words ▁, ▁n ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁Min im iz el eft Over Sum ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁Vector ▁< ▁Integer ▁> ▁v 1 ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁, ▁v 2 ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁% ▁2 ▁== ▁1 ▁) ▁v 1 ▁. ▁add ▁( ▁a ▁[ ▁i ▁] ▁) ▁; ▁else ▁v 2 ▁. ▁add ▁( ▁a ▁[ ▁i ▁] ▁) ▁; ▁} ▁if ▁( ▁v 1 ▁. ▁size ▁( ▁) ▁> ▁v 2 ▁. ▁size ▁( ▁) ▁) ▁{ ▁Collections ▁. ▁sort ▁( ▁v 1 ▁) ▁; ▁Collections ▁. ▁sort ▁( ▁v 2 ▁) ▁; ▁int ▁x ▁= ▁v 1 ▁. ▁size ▁( ▁) ▁- ▁v 2 ▁. ▁size ▁( ▁) ▁- ▁1 ▁; ▁int ▁sum ▁= ▁0 ▁; ▁int ▁i ▁= ▁0 ▁; ▁while ▁( ▁i ▁< ▁x ▁) ▁{ ▁sum ▁+= ▁v 1 ▁. ▁get ▁( ▁i ▁++ ▁) ▁; ▁} ▁return ▁sum ▁; ▁} ▁else ▁if ▁( ▁v 2 ▁. ▁size ▁( ▁) ▁> ▁v 1 ▁. ▁size ▁( ▁) ▁) ▁{ ▁Collections ▁. ▁sort ▁( ▁v 1 ▁) ▁; ▁Collections ▁. ▁sort ▁( ▁v 2 ▁) ▁; ▁int ▁x ▁= ▁v 2 ▁. ▁size ▁( ▁) ▁- ▁v 1 ▁. ▁size ▁( ▁) ▁- ▁1 ▁; ▁int ▁sum ▁= ▁0 ▁; ▁int ▁i ▁= ▁0 ▁; ▁while ▁( ▁i ▁< ▁x ▁) ▁{ ▁sum ▁+= ▁v 2 ▁. ▁get ▁( ▁i ▁++ ▁) ▁; ▁} ▁return ▁sum ▁; ▁} ▁else ▁return ▁0 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁2 ▁, ▁2 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁a ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁Min im iz el eft Over Sum ▁( ▁a ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G f G ▁{ ▁static ▁void ▁print Numbers ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁arr ▁) ▁; ▁int ▁A ▁= ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁, ▁B ▁= ▁- ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁2 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁A ▁% ▁arr ▁[ ▁i ▁] ▁!= ▁0 ▁) ▁{ ▁B ▁= ▁arr ▁[ ▁i ▁] ▁; ▁break ▁; ▁} ▁if ▁( ▁i ▁- ▁1 ▁>= ▁0 ▁&& ▁arr ▁[ ▁i ▁] ▁== ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁) ▁{ ▁B ▁= ▁arr ▁[ ▁i ▁] ▁; ▁break ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁A ▁= ▁" ▁+ ▁A ▁+ ▁" ▁, ▁B ▁= ▁" ▁+ ▁B ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁4 ▁, ▁8 ▁, ▁16 ▁, ▁1 ▁, ▁2 ▁, ▁4 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁print Numbers ▁( ▁arr ▁, ▁n ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁print Array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁static ▁void ▁remove Min ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁i ▁, ▁min Val ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁min Val ▁= ▁Math ▁. ▁min ▁( ▁min Val ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁arr ▁[ ▁i ▁] ▁= ▁arr ▁[ ▁i ▁] ▁- ▁min Val ▁; ▁} ▁static ▁void ▁removeFrom Max ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁i ▁, ▁max Val ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁max Val ▁= ▁Math ▁. ▁max ▁( ▁max Val ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁arr ▁[ ▁i ▁] ▁= ▁max Val ▁- ▁arr ▁[ ▁i ▁] ▁; ▁} ▁static ▁void ▁modify Array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁if ▁( ▁k ▁% ▁2 ▁== ▁0 ▁) ▁remove Min ▁( ▁arr ▁, ▁n ▁) ▁; ▁else ▁removeFrom Max ▁( ▁arr ▁, ▁n ▁) ▁; ▁print Array ▁( ▁arr ▁, ▁n ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁8 ▁, ▁12 ▁, ▁16 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁int ▁k ▁= ▁2 ▁; ▁modify Array ▁( ▁arr ▁, ▁n ▁, ▁k ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁find Product ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁arr ▁) ▁; ▁int ▁prod ▁= ▁1 ▁* ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁!= ▁arr ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁{ ▁prod ▁= ▁prod ▁* ▁arr ▁[ ▁i ▁+ ▁1 ▁] ▁; ▁} ▁} ▁return ▁prod ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁1 ▁, ▁1 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Product ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁12 ▁, ▁5 ▁} ▁; ▁Arrays ▁. ▁sort ▁( ▁a ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁3 ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁a ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁operations ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁arr ▁) ▁; ▁int ▁i ▁= ▁0 ▁, ▁sum ▁= ▁0 ▁; ▁while ▁( ▁k ▁-- ▁> ▁0 ▁) ▁{ ▁while ▁( ▁i ▁< ▁n ▁&& ▁arr ▁[ ▁i ▁] ▁- ▁sum ▁== ▁0 ▁) ▁i ▁++ ▁; ▁if ▁( ▁i ▁< ▁n ▁&& ▁arr ▁[ ▁i ▁] ▁- ▁sum ▁> ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁i ▁] ▁- ▁sum ▁+ ▁" ▁" ▁) ▁; ▁sum ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁"0" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁k ▁= ▁5 ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁6 ▁, ▁4 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁operations ▁( ▁arr ▁, ▁n ▁, ▁k ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁import ▁java ▁. ▁util ▁. ▁Collections ▁; ▁import ▁java ▁. ▁util ▁. ▁Comparator ▁; ▁import ▁java ▁. ▁util ▁. ▁Vector ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁min Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁Vector ▁< ▁Integer ▁> ▁even Arr ▁= ▁new ▁Vector ▁< ▁> ▁( ▁) ▁; ▁Vector ▁< ▁Integer ▁> ▁odd Arr ▁= ▁new ▁Vector ▁< ▁> ▁( ▁) ▁; ▁Arrays ▁. ▁sort ▁( ▁arr ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁< ▁n ▁/ ▁2 ▁) ▁{ ▁odd Arr ▁. ▁add ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁else ▁{ ▁even Arr ▁. ▁add ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁} ▁Comparator ▁comparator ▁= ▁Collections ▁. ▁reverse Order ▁( ▁) ▁; ▁Collections ▁. ▁sort ▁( ▁even Arr ▁, ▁comparator ▁) ▁; ▁int ▁i ▁= ▁0 ▁, ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁even Arr ▁. ▁size ▁( ▁) ▁; ▁j ▁++ ▁) ▁{ ▁arr ▁[ ▁i ▁++ ▁] ▁= ▁even Arr ▁. ▁get ▁( ▁j ▁) ▁; ▁arr ▁[ ▁i ▁++ ▁] ▁= ▁odd Arr ▁. ▁get ▁( ▁j ▁) ▁; ▁sum ▁+= ▁even Arr ▁. ▁get ▁( ▁j ▁) ▁* ▁odd Arr ▁. ▁get ▁( ▁j ▁) ▁; ▁} ▁return ▁sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁5 ▁, ▁8 ▁, ▁9 ▁, ▁6 ▁, ▁7 ▁, ▁3 ▁, ▁4 ▁, ▁2 ▁, ▁0 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Minimum ▁required ▁sum ▁= ▁" ▁+ ▁min Sum ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Sorted ▁array ▁in ▁required ▁format ▁: ▁" ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁bit onic Generator ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁Vector ▁< ▁Integer ▁> ▁even Arr ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁Vector ▁< ▁Integer ▁> ▁odd Arr ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁% ▁2 ▁!= ▁1 ▁) ▁{ ▁even Arr ▁. ▁add ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁else ▁{ ▁odd Arr ▁. ▁add ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁} ▁Collections ▁. ▁sort ▁( ▁even Arr ▁) ▁; ▁Collections ▁. ▁sort ▁( ▁odd Arr ▁, ▁Collections ▁. ▁reverse Order ▁( ▁) ▁) ▁; ▁int ▁i ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁even Arr ▁. ▁size ▁( ▁) ▁; ▁j ▁++ ▁) ▁{ ▁arr ▁[ ▁i ▁++ ▁] ▁= ▁even Arr ▁. ▁get ▁( ▁j ▁) ▁; ▁} ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁odd Arr ▁. ▁size ▁( ▁) ▁; ▁j ▁++ ▁) ▁{ ▁arr ▁[ ▁i ▁++ ▁] ▁= ▁odd Arr ▁. ▁get ▁( ▁j ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁5 ▁, ▁8 ▁, ▁9 ▁, ▁6 ▁, ▁7 ▁, ▁3 ▁, ▁4 ▁, ▁2 ▁, ▁0 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁bit onic Generator ▁( ▁arr ▁, ▁n ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁count Bits ▁( ▁int ▁a ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁while ▁( ▁a ▁> ▁0 ▁) ▁{ ▁if ▁( ▁( ▁a ▁& ▁1 ▁) ▁> ▁0 ▁) ▁count ▁+= ▁1 ▁; ▁a ▁= ▁a ▁>> ▁1 ▁; ▁} ▁return ▁count ▁; ▁} ▁static ▁void ▁sortBy Set Bit Count ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁Vector ▁< ▁Integer ▁> ▁[ ▁] ▁count ▁= ▁new ▁Vector ▁[ ▁32 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁count ▁. ▁length ▁; ▁i ▁++ ▁) ▁count ▁[ ▁i ▁] ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁int ▁set bit count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁set bit count ▁= ▁count Bits ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁count ▁[ ▁set bit count ▁] ▁. ▁add ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁int ▁j ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁31 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁Vector ▁< ▁Integer ▁> ▁v 1 ▁= ▁count ▁[ ▁i ▁] ▁; ▁for ▁( ▁int ▁p ▁= ▁0 ▁; ▁p ▁< ▁v 1 ▁. ▁size ▁( ▁) ▁; ▁p ▁++ ▁) ▁arr ▁[ ▁j ▁++ ▁] ▁= ▁v 1 ▁. ▁get ▁( ▁p ▁) ▁; ▁} ▁} ▁static ▁void ▁print Arr ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁sortBy Set Bit Count ▁( ▁arr ▁, ▁n ▁) ▁; ▁print Arr ▁( ▁arr ▁, ▁n ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁solve ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁arr ▁) ▁; ▁int ▁a ▁= ▁0 ▁, ▁b ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁% ▁2 ▁!= ▁0 ▁) ▁a ▁= ▁a ▁* ▁10 ▁+ ▁arr ▁[ ▁i ▁] ▁; ▁else ▁b ▁= ▁b ▁* ▁10 ▁+ ▁arr ▁[ ▁i ▁] ▁; ▁} ▁return ▁a ▁+ ▁b ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁6 ▁, ▁8 ▁, ▁4 ▁, ▁5 ▁, ▁2 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Sum ▁is ▁" ▁+ ▁solve ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁long ▁K th Solution ▁( ▁long ▁X ▁, ▁long ▁K ▁) ▁{ ▁long ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁64 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁X ▁& ▁( ▁1 ▁<< ▁i ▁) ▁) ▁== ▁0 ▁) ▁{ ▁if ▁( ▁( ▁K ▁& ▁1 ▁) ▁> ▁0 ▁) ▁{ ▁ans ▁|= ▁( ▁1 ▁<< ▁i ▁) ▁; ▁} ▁K ▁>>= ▁1 ▁; ▁if ▁( ▁K ▁== ▁0 ▁) ▁{ ▁break ▁; ▁} ▁} ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁long ▁X ▁= ▁5 ▁, ▁K ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁K th Solution ▁( ▁X ▁, ▁K ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁find An agram ▁( ▁String ▁s ▁) ▁{ ▁String ▁check ▁= ▁s ▁; ▁int ▁i ▁= ▁0 ▁, ▁j ▁= ▁s ▁. ▁length ▁( ▁) ▁- ▁1 ▁; ▁while ▁( ▁i ▁< ▁s ▁. ▁length ▁( ▁) ▁&& ▁j ▁>= ▁0 ▁) ▁{ ▁if ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁!= ▁s ▁. ▁charAt ▁( ▁j ▁) ▁&& ▁check ▁. ▁charAt ▁( ▁i ▁) ▁!= ▁s ▁. ▁charAt ▁( ▁j ▁) ▁&& ▁check ▁. ▁charAt ▁( ▁j ▁) ▁!= ▁s ▁. ▁charAt ▁( ▁i ▁) ▁) ▁{ ▁char ▁temp ▁= ▁s ▁. ▁charAt ▁( ▁i ▁) ▁; ▁s ▁= ▁s ▁. ▁substring ▁( ▁0 ▁, ▁i ▁) ▁+ ▁s ▁. ▁charAt ▁( ▁j ▁) ▁+ ▁s ▁. ▁substring ▁( ▁i ▁+ ▁1 ▁) ▁; ▁s ▁= ▁s ▁. ▁substring ▁( ▁0 ▁, ▁j ▁) ▁+ ▁temp ▁+ ▁s ▁. ▁substring ▁( ▁j ▁+ ▁1 ▁) ▁; ▁i ▁++ ▁; ▁j ▁= ▁s ▁. ▁length ▁( ▁) ▁- ▁1 ▁; ▁} ▁else ▁{ ▁j ▁-- ▁; ▁} ▁} ▁if ▁( ▁s ▁. ▁length ▁( ▁) ▁% ▁2 ▁!= ▁0 ▁) ▁{ ▁int ▁mid ▁= ▁s ▁. ▁length ▁( ▁) ▁/ ▁2 ▁; ▁if ▁( ▁check ▁. ▁charAt ▁( ▁mid ▁) ▁== ▁s ▁. ▁charAt ▁( ▁mid ▁) ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁check ▁. ▁charAt ▁( ▁i ▁) ▁!= ▁s ▁. ▁charAt ▁( ▁mid ▁) ▁&& ▁s ▁. ▁charAt ▁( ▁i ▁) ▁!= ▁s ▁. ▁charAt ▁( ▁mid ▁) ▁) ▁{ ▁char ▁temp ▁= ▁s ▁. ▁charAt ▁( ▁i ▁) ▁; ▁s ▁= ▁s ▁. ▁substring ▁( ▁0 ▁, ▁i ▁) ▁+ ▁s ▁. ▁charAt ▁( ▁mid ▁) ▁+ ▁s ▁. ▁substring ▁( ▁i ▁+ ▁1 ▁) ▁; ▁s ▁= ▁s ▁. ▁substring ▁( ▁0 ▁, ▁mid ▁) ▁+ ▁temp ▁+ ▁s ▁. ▁substring ▁( ▁mid ▁+ ▁1 ▁) ▁; ▁break ▁; ▁} ▁} ▁} ▁} ▁boolean ▁ok ▁= ▁true ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁check ▁. ▁charAt ▁( ▁i ▁) ▁== ▁s ▁. ▁charAt ▁( ▁i ▁) ▁) ▁{ ▁ok ▁= ▁false ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁ok ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁s ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁- ▁1 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁S ▁= ▁" ▁g eek ▁" ▁; ▁find An agram ▁( ▁S ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁min Time ▁( ▁String ▁word ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁int ▁curr ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁word ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁int ▁k ▁= ▁( ▁int ▁) ▁word ▁. ▁charAt ▁( ▁i ▁) ▁- ▁97 ▁; ▁int ▁a ▁= ▁Math ▁. ▁abs ▁( ▁curr ▁- ▁k ▁) ▁; ▁int ▁b ▁= ▁26 ▁- ▁Math ▁. ▁abs ▁( ▁curr ▁- ▁k ▁) ▁; ▁ans ▁+= ▁Math ▁. ▁min ▁( ▁a ▁, ▁b ▁) ▁; ▁ans ▁++ ▁; ▁curr ▁= ▁( ▁int ▁) ▁word ▁. ▁charAt ▁( ▁i ▁) ▁- ▁97 ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁ans ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁" ▁z j pc ▁" ▁; ▁min Time ▁( ▁str ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁maximum Sum Array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁[ ▁] ▁arr A ▁= ▁new ▁int ▁[ ▁( ▁N ▁) ▁] ▁; ▁int ▁[ ▁] ▁ans ▁= ▁new ▁int ▁[ ▁( ▁N ▁) ▁] ▁; ▁int ▁max Sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁arr A ▁[ ▁i ▁] ▁= ▁arr ▁[ ▁i ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁int ▁[ ▁] ▁arr B ▁= ▁new ▁int ▁[ ▁( ▁N ▁) ▁] ▁; ▁int ▁maximum ▁= ▁arr A ▁[ ▁i ▁] ▁; ▁arr B ▁[ ▁i ▁] ▁= ▁maximum ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁- ▁1 ▁; ▁j ▁>= ▁0 ▁; ▁j ▁-- ▁) ▁{ ▁arr B ▁[ ▁j ▁] ▁= ▁Math ▁. ▁min ▁( ▁maximum ▁, ▁arr A ▁[ ▁j ▁] ▁) ▁; ▁maximum ▁= ▁arr B ▁[ ▁j ▁] ▁; ▁} ▁maximum ▁= ▁arr A ▁[ ▁i ▁] ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁arr B ▁[ ▁j ▁] ▁= ▁Math ▁. ▁min ▁( ▁maximum ▁, ▁arr A ▁[ ▁j ▁] ▁) ▁; ▁maximum ▁= ▁arr B ▁[ ▁j ▁] ▁; ▁} ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁sum ▁+= ▁arr B ▁[ ▁j ▁] ▁; ▁if ▁( ▁sum ▁> ▁max Sum ▁) ▁{ ▁max Sum ▁= ▁sum ▁; ▁ans ▁= ▁arr B ▁; ▁} ▁} ▁for ▁( ▁int ▁val ▁: ▁ans ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁val ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁6 ▁, ▁8 ▁} ▁; ▁int ▁N ▁= ▁A ▁. ▁length ▁; ▁maximum Sum Array ▁( ▁A ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁String ▁largest Merge ▁( ▁String ▁word 1 ▁, ▁String ▁word 2 ▁) ▁{ ▁String ▁merge ▁= ▁" ▁" ▁; ▁while ▁( ▁word 1 ▁. ▁length ▁( ▁) ▁!= ▁0 ▁|| ▁word 2 ▁. ▁length ▁( ▁) ▁!= ▁0 ▁) ▁{ ▁if ▁( ▁word 1 ▁. ▁compareTo ▁( ▁word 2 ▁) ▁== ▁0 ▁|| ▁( ▁word 1 ▁. ▁compareTo ▁( ▁word 2 ▁) ▁> ▁0 ▁) ▁) ▁{ ▁merge ▁= ▁merge ▁+ ▁word 1 ▁. ▁charAt ▁( ▁0 ▁) ▁; ▁word 1 ▁= ▁word 1 ▁. ▁substring ▁( ▁1 ▁) ▁; ▁} ▁else ▁{ ▁merge ▁= ▁merge ▁+ ▁word 2 ▁. ▁charAt ▁( ▁0 ▁) ▁; ▁word 2 ▁= ▁word 2 ▁. ▁substring ▁( ▁1 ▁) ▁; ▁} ▁} ▁return ▁merge ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁S 1 ▁= ▁" ▁xyz xyz ▁" ▁; ▁String ▁S 2 ▁= ▁" ▁xy w z xy x ▁" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁largest Merge ▁( ▁S 1 ▁, ▁S 2 ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁sum Of Comb ination Of 4 OR 5 ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁N ▁) ▁{ ▁int ▁[ ▁] ▁ans ▁= ▁new ▁int ▁[ ▁N ▁] ▁; ▁Arrays ▁. ▁fill ▁( ▁ans ▁, ▁- ▁1 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁4 ▁) ▁{ ▁continue ▁; ▁} ▁int ▁sum ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁int ▁cnt ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁<= ▁arr ▁[ ▁i ▁] ▁; ▁j ▁+= ▁4 ▁) ▁{ ▁if ▁( ▁( ▁arr ▁[ ▁i ▁] ▁- ▁j ▁) ▁% ▁5 ▁== ▁0 ▁) ▁{ ▁sum ▁= ▁Math ▁. ▁min ▁( ▁sum ▁, ▁cnt ▁+ ▁( ▁arr ▁[ ▁i ▁] ▁- ▁j ▁) ▁/ ▁5 ▁) ▁; ▁} ▁cnt ▁++ ▁; ▁} ▁if ▁( ▁sum ▁!= ▁Integer ▁. ▁MAX _ VALUE ▁) ▁ans ▁[ ▁i ▁] ▁= ▁sum ▁; ▁} ▁for ▁( ▁int ▁num ▁: ▁ans ▁) ▁System ▁. ▁out ▁. ▁printf ▁( ▁num ▁+ ▁" ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁7 ▁, ▁15 ▁, ▁17 ▁, ▁22 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁sum Of Comb ination Of 4 OR 5 ▁( ▁arr ▁, ▁N ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁String ▁largest String ▁( ▁String ▁s ▁, ▁int ▁k ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁!= ▁' ▁z ▁' ▁&& ▁k ▁> ▁0 ▁) ▁{ ▁s ▁= ▁s ▁. ▁replace ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁, ▁' ▁z ▁' ▁) ▁; ▁k ▁-- ▁; ▁} ▁} ▁return ▁s ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁String ▁s ▁= ▁" ▁db za ▁" ▁; ▁int ▁k ▁= ▁1 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁largest String ▁( ▁s ▁, ▁k ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁Remove One Char ▁( ▁String ▁A ▁, ▁String ▁B ▁, ▁int ▁N ▁, ▁int ▁M ▁) ▁{ ▁int ▁X ▁= ▁0 ▁; ▁int ▁Y ▁= ▁N ▁- ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁M ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁A ▁. ▁charAt ▁( ▁X ▁) ▁!= ▁B ▁. ▁charAt ▁( ▁i ▁) ▁) ▁break ▁; ▁X ▁++ ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁M ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁A ▁. ▁charAt ▁( ▁Y ▁) ▁!= ▁B ▁. ▁charAt ▁( ▁i ▁) ▁) ▁break ▁; ▁Y ▁-- ▁; ▁} ▁if ▁( ▁N ▁- ▁M ▁== ▁1 ▁&& ▁Y ▁< ▁X ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁X ▁- ▁Y ▁+ ▁1 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁Y ▁; ▁i ▁<= ▁X ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁i ▁+ ▁1 ▁+ ▁" ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁} ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁- ▁1 ▁) ▁; ▁} ▁static ▁public ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁A ▁= ▁" ▁ab a ac ▁" ▁; ▁String ▁B ▁= ▁" ▁ab ac ▁" ▁; ▁int ▁N ▁= ▁A ▁. ▁length ▁( ▁) ▁; ▁int ▁M ▁= ▁B ▁. ▁length ▁( ▁) ▁; ▁Remove One Char ▁( ▁A ▁, ▁B ▁, ▁N ▁, ▁M ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁count Of Pairs ▁( ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁k ▁= ▁1 ▁; ▁k ▁* ▁k ▁<= ▁x ▁; ▁++ ▁k ▁) ▁{ ▁count ▁+= ▁Math ▁. ▁max ▁( ▁0 ▁, ▁Math ▁. ▁min ▁( ▁y ▁, ▁x ▁/ ▁k ▁- ▁1 ▁) ▁- ▁k ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁count ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁x ▁= ▁4 ▁; ▁int ▁y ▁= ▁5 ▁; ▁count Of Pairs ▁( ▁x ▁, ▁y ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁public ▁static ▁void ▁getDate ▁( ▁int ▁d ▁, ▁String ▁m ▁) ▁{ ▁int ▁[ ▁] ▁days ▁= ▁{ ▁31 ▁, ▁29 ▁, ▁31 ▁, ▁30 ▁, ▁31 ▁, ▁30 ▁, ▁31 ▁, ▁31 ▁, ▁30 ▁, ▁31 ▁, ▁30 ▁, ▁31 ▁} ▁; ▁String ▁[ ▁] ▁month ▁= ▁{ ▁" ▁January ▁" ▁, ▁" ▁Feb ruary ▁" ▁, ▁" ▁March ▁" ▁, ▁" ▁Apr il ▁" ▁, ▁" ▁May ▁" ▁, ▁" ▁J une ▁" ▁, ▁" ▁J uly ▁" ▁, ▁" ▁Aug ust ▁" ▁, ▁" ▁Se pt ember ▁" ▁, ▁" ▁Oct ober ▁" ▁, ▁" ▁Nov ember ▁" ▁, ▁" ▁De cember ▁" ▁} ▁; ▁int ▁cnt ▁= ▁18 3 ▁; ▁int ▁cur _ month ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁12 ▁; ▁i ▁++ ▁) ▁if ▁( ▁m ▁== ▁month ▁[ ▁i ▁] ▁) ▁cur _ month ▁= ▁i ▁; ▁int ▁cur _ date ▁= ▁d ▁; ▁while ▁( ▁true ▁) ▁{ ▁while ▁( ▁cnt ▁> ▁0 ▁&& ▁cur _ date ▁<= ▁days ▁[ ▁cur _ month ▁] ▁) ▁{ ▁cnt ▁-= ▁1 ▁; ▁cur _ date ▁+= ▁1 ▁; ▁} ▁if ▁( ▁cnt ▁== ▁0 ▁) ▁break ▁; ▁cur _ month ▁= ▁( ▁cur _ month ▁+ ▁1 ▁) ▁% ▁12 ▁; ▁cur _ date ▁= ▁1 ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁cur _ date ▁+ ▁" ▁" ▁+ ▁month ▁[ ▁cur _ month ▁] ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁D ▁= ▁15 ▁; ▁String ▁M ▁= ▁" ▁January ▁" ▁; ▁getDate ▁( ▁D ▁, ▁M ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁void ▁print Last Element ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁boolean ▁left Turn ▁= ▁true ▁; ▁int ▁remain Elements ▁= ▁N ▁; ▁int ▁step ▁= ▁1 ▁; ▁int ▁head ▁= ▁1 ▁; ▁while ▁( ▁remain Elements ▁> ▁1 ▁) ▁{ ▁if ▁( ▁left Turn ▁) ▁{ ▁head ▁= ▁head ▁+ ▁step ▁; ▁} ▁else ▁{ ▁if ▁( ▁remain Elements ▁% ▁2 ▁== ▁1 ▁) ▁head ▁= ▁head ▁+ ▁step ▁; ▁} ▁remain Elements ▁= ▁remain Elements ▁/ ▁2 ▁; ▁step ▁= ▁step ▁* ▁2 ▁; ▁left Turn ▁= ▁! ▁left Turn ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁head ▁- ▁1 ▁] ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁print Last Element ▁( ▁arr ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁String ▁freq Check ▁( ▁String ▁S ▁, ▁int ▁N ▁) ▁{ ▁int ▁hash ▁[ ▁] ▁= ▁new ▁int ▁[ ▁26 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁hash ▁[ ▁S ▁. ▁charAt ▁( ▁i ▁) ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁26 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁hash ▁[ ▁i ▁] ▁> ▁2 ▁) ▁{ ▁return ▁" ▁Yes ▁" ▁; ▁} ▁} ▁return ▁" ▁No ▁" ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁S ▁= ▁" ▁g eek seek forge ek s ▁" ▁; ▁int ▁N ▁= ▁S ▁. ▁length ▁( ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁freq Check ▁( ▁S ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁min steps ▁( ▁int ▁[ ▁] ▁A ▁) ▁{ ▁int ▁n ▁= ▁A ▁. ▁length ▁; ▁int ▁[ ▁] ▁left ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁Arrays ▁. ▁fill ▁( ▁left ▁, ▁0 ▁) ▁; ▁int ▁[ ▁] ▁right ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁Arrays ▁. ▁fill ▁( ▁right ▁, ▁0 ▁) ▁; ▁int ▁[ ▁] ▁res ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁Arrays ▁. ▁fill ▁( ▁res ▁, ▁0 ▁) ▁; ▁int ▁count ▁= ▁A ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁left ▁[ ▁i ▁] ▁= ▁left ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁count ▁; ▁count ▁+= ▁A ▁[ ▁i ▁] ▁; ▁} ▁count ▁= ▁A ▁[ ▁n ▁- ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁2 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁right ▁[ ▁i ▁] ▁= ▁right ▁[ ▁i ▁+ ▁1 ▁] ▁+ ▁count ▁; ▁count ▁+= ▁A ▁[ ▁i ▁] ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁res ▁[ ▁i ▁] ▁= ▁left ▁[ ▁i ▁] ▁+ ▁right ▁[ ▁i ▁] ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁res ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁A ▁= ▁{ ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁} ▁; ▁min steps ▁( ▁A ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁minimum Operations ▁( ▁int ▁[ ▁] ▁A ▁, ▁int ▁K ▁) ▁{ ▁int ▁[ ▁] ▁is fli pped ▁= ▁new ▁int ▁[ ▁A ▁. ▁length ▁+ ▁1 ▁] ▁; ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁A ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁> ▁0 ▁) ▁{ ▁is fli pped ▁[ ▁i ▁] ▁+= ▁is fli pped ▁[ ▁i ▁- ▁1 ▁] ▁; ▁is fli pped ▁[ ▁i ▁] ▁% = ▁2 ▁; ▁} ▁if ▁( ▁A ▁[ ▁i ▁] ▁== ▁0 ▁&& ▁is fli pped ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁if ▁( ▁( ▁A ▁. ▁length ▁- ▁i ▁+ ▁1 ▁) ▁<= ▁K ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁- ▁1 ▁) ▁; ▁return ▁; ▁} ▁ans ▁++ ▁; ▁is fli pped ▁[ ▁i ▁] ▁++ ▁; ▁is fli pped ▁[ ▁i ▁+ ▁K ▁] ▁-- ▁; ▁} ▁else ▁if ▁( ▁A ▁[ ▁i ▁] ▁== ▁1 ▁&& ▁is fli pped ▁[ ▁i ▁] ▁!= ▁0 ▁) ▁{ ▁if ▁( ▁( ▁A ▁. ▁length ▁- ▁i ▁+ ▁1 ▁) ▁<= ▁K ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁- ▁1 ▁) ▁; ▁return ▁; ▁} ▁ans ▁++ ▁; ▁is fli pped ▁[ ▁i ▁] ▁++ ▁; ▁is fli pped ▁[ ▁i ▁+ ▁K ▁] ▁-- ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁ans ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁0 ▁, ▁1 ▁, ▁0 ▁} ▁; ▁int ▁K ▁= ▁1 ▁; ▁minimum Operations ▁( ▁arr ▁, ▁K ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁Convert Array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁if ▁( ▁N ▁== ▁1 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Operation ▁1 ▁: ▁" ▁+ ▁1 ▁+ ▁" ▁" ▁+ ▁1 ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Added ▁elements ▁: ▁" ▁+ ▁- ▁1 ▁* ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Operation ▁2 ▁: ▁" ▁+ ▁1 ▁+ ▁" ▁" ▁+ ▁1 ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Added ▁elements ▁: ▁" ▁+ ▁1 ▁* ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Operation ▁3 ▁: ▁" ▁+ ▁1 ▁+ ▁" ▁" ▁+ ▁1 ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Added ▁elements ▁: ▁" ▁+ ▁- ▁1 ▁* ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Operation ▁1 ▁: ▁" ▁+ ▁1 ▁+ ▁" ▁" ▁+ ▁N ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Added ▁elements ▁: ▁" ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁- ▁1 ▁* ▁arr ▁[ ▁i ▁] ▁* ▁N ▁+ ▁" ▁" ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Operation ▁2 ▁: ▁" ▁+ ▁1 ▁+ ▁" ▁" ▁+ ▁( ▁N ▁- ▁1 ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Added ▁elements ▁: ▁" ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁i ▁] ▁* ▁( ▁N ▁- ▁1 ▁) ▁+ ▁" ▁" ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Operation ▁3 ▁: ▁" ▁+ ▁N ▁+ ▁" ▁" ▁+ ▁N ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Added ▁elements ▁: ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁arr ▁[ ▁N ▁- ▁1 ▁] ▁* ▁( ▁N ▁- ▁1 ▁) ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁2 ▁, ▁4 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁Convert Array ▁( ▁arr ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁MAX ▁= ▁1000000 ▁; ▁static ▁void ▁count Of Pr im ef act ors ▁( ▁int ▁[ ▁] ▁Count Distinct ▁) ▁{ ▁boolean ▁[ ▁] ▁prime ▁= ▁new ▁boolean ▁[ ▁MAX ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁MAX ▁; ▁i ▁++ ▁) ▁{ ▁Count Distinct ▁[ ▁i ▁] ▁= ▁0 ▁; ▁prime ▁[ ▁i ▁] ▁= ▁true ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁MAX ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁i ▁] ▁== ▁true ▁) ▁{ ▁Count Distinct ▁[ ▁i ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁* ▁2 ▁; ▁j ▁<= ▁MAX ▁; ▁j ▁+= ▁i ▁) ▁{ ▁Count Distinct ▁[ ▁j ▁] ▁++ ▁; ▁prime ▁[ ▁j ▁] ▁= ▁false ▁; ▁} ▁} ▁} ▁} ▁static ▁int ▁Count Even Pair ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁B ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁M ▁) ▁{ ▁int ▁[ ▁] ▁count Distinct ▁= ▁new ▁int ▁[ ▁( ▁MAX ▁+ ▁1 ▁) ▁] ▁; ▁count Of Pr im ef act ors ▁( ▁count Distinct ▁) ▁; ▁int ▁even Count ▁= ▁0 ▁; ▁int ▁odd Count ▁= ▁0 ▁; ▁int ▁even Pairs ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁M ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁count Distinct ▁[ ▁B ▁[ ▁i ▁] ▁] ▁== ▁0 ▁) ▁continue ▁; ▁if ▁( ▁( ▁count Distinct ▁[ ▁B ▁[ ▁i ▁] ▁] ▁& ▁1 ▁) ▁!= ▁0 ▁) ▁{ ▁odd Count ▁++ ▁; ▁} ▁else ▁{ ▁even Count ▁++ ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁count Distinct ▁[ ▁A ▁[ ▁i ▁] ▁] ▁== ▁0 ▁) ▁continue ▁; ▁if ▁( ▁( ▁count Distinct ▁[ ▁A ▁[ ▁i ▁] ▁] ▁& ▁1 ▁) ▁!= ▁0 ▁) ▁{ ▁even Pairs ▁+= ▁( ▁even Count ▁) ▁; ▁} ▁else ▁{ ▁even Pairs ▁+= ▁even Count ▁+ ▁odd Count ▁; ▁} ▁} ▁return ▁even Pairs ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁; ▁int ▁B ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁int ▁N ▁= ▁A ▁. ▁length ▁; ▁int ▁M ▁= ▁B ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁Count Even Pair ▁( ▁A ▁, ▁B ▁, ▁N ▁, ▁M ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁longest Sub array ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁um ▁= ▁new ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁( ▁) ▁; ▁int ▁sum ▁= ▁0 ▁, ▁max Len ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁if ▁( ▁sum ▁== ▁K ▁) ▁max Len ▁= ▁i ▁+ ▁1 ▁; ▁if ▁( ▁! ▁um ▁. ▁containsKey ▁( ▁sum ▁) ▁) ▁um ▁. ▁put ▁( ▁sum ▁, ▁i ▁) ▁; ▁if ▁( ▁um ▁. ▁containsKey ▁( ▁sum ▁- ▁K ▁) ▁) ▁{ ▁if ▁( ▁max Len ▁< ▁( ▁i ▁- ▁um ▁. ▁get ▁( ▁sum ▁- ▁K ▁) ▁) ▁) ▁max Len ▁= ▁i ▁- ▁um ▁. ▁get ▁( ▁sum ▁- ▁K ▁) ▁; ▁} ▁} ▁return ▁max Len ▁; ▁} ▁static ▁void ▁min Required Operation ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁int ▁Total Sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁Total Sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁int ▁max Len ▁= ▁longest Sub array ▁( ▁arr ▁, ▁N ▁, ▁Total Sum ▁- ▁K ▁) ▁; ▁if ▁( ▁max Len ▁== ▁- ▁1 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁- ▁1 ▁) ▁; ▁} ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁N ▁- ▁max Len ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁1 ▁, ▁1 ▁, ▁2 ▁} ▁; ▁int ▁K ▁= ▁4 ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁min Required Operation ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁count Even Odd ▁( ▁int ▁L ▁, ▁int ▁R ▁) ▁{ ▁int ▁range ▁= ▁R ▁- ▁L ▁+ ▁1 ▁; ▁int ▁even ▁= ▁( ▁range ▁/ ▁4 ▁) ▁* ▁2 ▁; ▁if ▁( ▁( ▁L ▁& ▁1 ▁) ▁!= ▁0 ▁&& ▁( ▁range ▁% ▁4 ▁== ▁3 ▁) ▁) ▁{ ▁even ▁++ ▁; ▁} ▁else ▁if ▁( ▁( ▁L ▁& ▁1 ▁) ▁== ▁0 ▁&& ▁( ▁range ▁% ▁4 ▁!= ▁0 ▁) ▁) ▁{ ▁even ▁++ ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Even ▁= ▁" ▁+ ▁even ▁+ ▁" ▁, ▁O dd ▁= ▁" ▁+ ▁( ▁range ▁- ▁even ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁L ▁= ▁2 ▁, ▁R ▁= ▁7 ▁; ▁count Even Odd ▁( ▁L ▁, ▁R ▁) ▁; ▁} ▁}
▁public ▁class ▁G F G ▁{ ▁static ▁int ▁maximum C and y ▁( ▁int ▁[ ▁] ▁cand ies ▁, ▁int ▁[ ▁] ▁safety ▁, ▁int ▁N ▁, ▁int ▁M ▁) ▁{ ▁int ▁total ▁= ▁0 ▁; ▁int ▁ans ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁boolean ▁all _ safe ▁= ▁true ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁cand ies ▁[ ▁i ▁] ▁+ ▁M ▁> ▁safety ▁[ ▁i ▁] ▁) ▁{ ▁all _ safe ▁= ▁false ▁; ▁ans ▁= ▁Math ▁. ▁min ▁( ▁ans ▁, ▁safety ▁[ ▁i ▁] ▁) ▁; ▁} ▁else ▁{ ▁ans ▁= ▁Math ▁. ▁min ▁( ▁ans ▁, ▁cand ies ▁[ ▁i ▁] ▁+ ▁M ▁) ▁; ▁} ▁total ▁+= ▁cand ies ▁[ ▁i ▁] ▁; ▁} ▁if ▁( ▁all _ safe ▁) ▁return ▁total ▁; ▁else ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁5 ▁, ▁2 ▁, ▁3 ▁} ▁; ▁int ▁B ▁[ ▁] ▁= ▁{ ▁8 ▁, ▁13 ▁, ▁6 ▁, ▁4 ▁} ▁; ▁int ▁M ▁= ▁5 ▁; ▁int ▁N ▁= ▁A ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁maximum C and y ▁( ▁A ▁, ▁B ▁, ▁N ▁, ▁M ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁construct _ Array ▁( ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁K ▁* ▁i ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁3 ▁, ▁K ▁= ▁3 ▁; ▁construct _ Array ▁( ▁N ▁, ▁K ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁Print ▁( ▁int ▁N ▁) ▁{ ▁if ▁( ▁( ▁N ▁/ ▁2 ▁) ▁% ▁2 ▁== ▁1 ▁|| ▁( ▁N ▁% ▁2 ▁== ▁1 ▁) ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁- ▁1 ▁) ▁; ▁return ▁; ▁} ▁int ▁Cur Even ▁= ▁2 ▁, ▁Cur Odd ▁= ▁1 ▁; ▁int ▁Sum Odd ▁= ▁0 ▁, ▁Sum Even ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁( ▁N ▁/ ▁2 ▁) ▁; ▁i ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁Cur Even ▁+ ▁" ▁" ▁) ▁; ▁Sum Even ▁+= ▁Cur Even ▁; ▁Cur Even ▁+= ▁2 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁/ ▁2 ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁Cur Odd ▁+ ▁" ▁" ▁) ▁; ▁Sum Odd ▁+= ▁Cur Odd ▁; ▁Cur Odd ▁+= ▁2 ▁; ▁} ▁Cur Odd ▁= ▁Sum Even ▁- ▁Sum Odd ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁Cur Odd ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁12 ▁; ▁Print ▁( ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁Minimum M oves ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁B ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁total Operations ▁= ▁0 ▁; ▁int ▁carry ▁= ▁0 ▁; ▁int ▁K ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁N ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁int ▁nearest Multiple ▁= ▁( ▁int ▁) ▁( ▁Math ▁. ▁ceil ▁( ▁( ▁double ▁) ▁( ▁A ▁[ ▁i ▁] ▁+ ▁carry ▁) ▁/ ▁( ▁double ▁) ▁( ▁B ▁[ ▁i ▁] ▁) ▁) ▁* ▁B ▁[ ▁i ▁] ▁) ▁; ▁K ▁= ▁nearest Multiple ▁- ▁( ▁A ▁[ ▁i ▁] ▁+ ▁carry ▁) ▁; ▁total Operations ▁+= ▁K ▁; ▁carry ▁+= ▁K ▁; ▁} ▁return ▁total Operations ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁2 ▁, ▁5 ▁, ▁5 ▁, ▁9 ▁} ▁; ▁int ▁B ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁1 ▁, ▁9 ▁, ▁6 ▁, ▁3 ▁, ▁8 ▁, ▁7 ▁} ▁; ▁int ▁N ▁= ▁A ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁Minimum M oves ▁( ▁A ▁, ▁B ▁, ▁N ▁) ▁+ ▁" NEW _ LINE "); ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁minimum Dev iation ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁TreeSet ▁< ▁Integer ▁> ▁s ▁= ▁new ▁TreeSet ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁A ▁[ ▁i ▁] ▁% ▁2 ▁== ▁0 ▁) ▁s ▁. ▁add ▁( ▁A ▁[ ▁i ▁] ▁) ▁; ▁else ▁s ▁. ▁add ▁( ▁2 ▁* ▁A ▁[ ▁i ▁] ▁) ▁; ▁} ▁int ▁diff ▁= ▁s ▁. ▁last ▁( ▁) ▁- ▁s ▁. ▁first ▁( ▁) ▁; ▁while ▁( ▁( ▁s ▁. ▁last ▁( ▁) ▁% ▁2 ▁== ▁0 ▁) ▁) ▁{ ▁int ▁max El ▁= ▁s ▁. ▁last ▁( ▁) ▁; ▁s ▁. ▁remove ▁( ▁max El ▁) ▁; ▁s ▁. ▁add ▁( ▁max El ▁/ ▁2 ▁) ▁; ▁diff ▁= ▁Math ▁. ▁min ▁( ▁diff ▁, ▁s ▁. ▁last ▁( ▁) ▁- ▁s ▁. ▁first ▁( ▁) ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁diff ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁1 ▁, ▁5 ▁, ▁20 ▁, ▁3 ▁} ▁; ▁int ▁N ▁= ▁A ▁. ▁length ▁; ▁minimum Dev iation ▁( ▁A ▁, ▁N ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁public ▁static ▁void ▁Find w inner Of Game ▁( ▁String ▁S ▁) ▁{ ▁int ▁cnt Zero ▁= ▁0 ▁; ▁int ▁cnt Con One ▁= ▁0 ▁; ▁int ▁nim Sum ▁= ▁0 ▁; ▁int ▁N ▁= ▁S ▁. ▁length ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁S ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'1' ▁) ▁{ ▁cnt Con One ▁+= ▁1 ▁; ▁} ▁else ▁{ ▁nim Sum ▁^= ▁cnt Con One ▁; ▁cnt Con One ▁= ▁0 ▁; ▁cnt Zero ▁++ ▁; ▁} ▁} ▁nim Sum ▁^= ▁cnt Con One ▁; ▁if ▁( ▁cnt Zero ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁T ie ▁" ▁) ▁; ▁} ▁else ▁if ▁( ▁nim Sum ▁!= ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁player ▁1" ▁) ▁; ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁player ▁2" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁S ▁= ▁"01 100 11" ▁; ▁Find w inner Of Game ▁( ▁S ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁min M oves ▁( ▁int ▁[ ▁] ▁arr ▁) ▁{ ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁if ▁( ▁N ▁<= ▁2 ▁) ▁return ▁0 ▁; ▁int ▁ans ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁for ▁( ▁int ▁i ▁= ▁- ▁1 ▁; ▁i ▁<= ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁- ▁1 ▁; ▁j ▁<= ▁1 ▁; ▁j ▁++ ▁) ▁{ ▁int ▁num 1 ▁= ▁arr ▁[ ▁0 ▁] ▁+ ▁i ▁; ▁int ▁num 2 ▁= ▁arr ▁[ ▁1 ▁] ▁+ ▁j ▁; ▁int ▁flag ▁= ▁1 ▁; ▁int ▁moves ▁= ▁Math ▁. ▁abs ▁( ▁i ▁) ▁+ ▁Math ▁. ▁abs ▁( ▁j ▁) ▁; ▁for ▁( ▁int ▁idx ▁= ▁2 ▁; ▁idx ▁< ▁N ▁; ▁idx ▁++ ▁) ▁{ ▁int ▁num ▁= ▁num 1 ▁+ ▁num 2 ▁; ▁if ▁( ▁Math ▁. ▁abs ▁( ▁arr ▁[ ▁idx ▁] ▁- ▁num ▁) ▁> ▁1 ▁) ▁flag ▁= ▁0 ▁; ▁else ▁moves ▁+= ▁Math ▁. ▁abs ▁( ▁arr ▁[ ▁idx ▁] ▁- ▁num ▁) ▁; ▁num 1 ▁= ▁num 2 ▁; ▁num 2 ▁= ▁num ▁; ▁} ▁if ▁( ▁flag ▁> ▁0 ▁) ▁ans ▁= ▁Math ▁. ▁min ▁( ▁ans ▁, ▁moves ▁) ▁; ▁} ▁} ▁if ▁( ▁ans ▁== ▁Integer ▁. ▁MAX _ VALUE ▁) ▁return ▁- ▁1 ▁; ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁4 ▁, ▁8 ▁, ▁9 ▁, ▁17 ▁, ▁27 ▁} ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁min M oves ▁( ▁arr ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁max k sum ▁( ▁int ▁L ▁, ▁int ▁R ▁, ▁int ▁K ▁) ▁{ ▁int ▁N ▁= ▁( ▁R ▁/ ▁10 ▁- ▁L ▁/ ▁10 ▁) ▁+ ▁1 ▁; ▁if ▁( ▁K ▁> ▁N ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁- ▁1" ▁) ▁; ▁return ▁; ▁} ▁R ▁= ▁R ▁/ ▁10 ▁; ▁int ▁X ▁= ▁R ▁- ▁K ▁; ▁int ▁sum ▁= ▁10 ▁* ▁( ▁( ▁R ▁* ▁( ▁R ▁+ ▁1 ▁) ▁) ▁/ ▁2 ▁- ▁( ▁X ▁* ▁( ▁X ▁+ ▁1 ▁) ▁) ▁/ ▁2 ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁sum ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁L ▁= ▁16 ▁, ▁R ▁= ▁60 ▁, ▁K ▁= ▁4 ▁; ▁max k sum ▁( ▁L ▁, ▁R ▁, ▁K ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁find Long est Non Dec re asing ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁res ▁= ▁0 ▁; ▁int ▁start ▁= ▁0 ▁; ▁int ▁end ▁= ▁N ▁- ▁1 ▁; ▁int ▁prev ▁= ▁- ▁1 ▁; ▁while ▁( ▁start ▁<= ▁end ▁) ▁{ ▁if ▁( ▁A ▁[ ▁start ▁] ▁<= ▁A ▁[ ▁end ▁] ▁) ▁{ ▁if ▁( ▁prev ▁== ▁- ▁1 ▁) ▁{ ▁prev ▁= ▁A ▁[ ▁start ▁] ▁; ▁res ▁++ ▁; ▁start ▁++ ▁; ▁} ▁else ▁{ ▁if ▁( ▁A ▁[ ▁start ▁] ▁>= ▁prev ▁) ▁{ ▁res ▁++ ▁; ▁prev ▁= ▁A ▁[ ▁start ▁] ▁; ▁start ▁++ ▁; ▁} ▁else ▁if ▁( ▁A ▁[ ▁end ▁] ▁>= ▁prev ▁) ▁{ ▁res ▁++ ▁; ▁prev ▁= ▁A ▁[ ▁end ▁] ▁; ▁end ▁-- ▁; ▁} ▁else ▁{ ▁break ▁; ▁} ▁} ▁} ▁else ▁{ ▁if ▁( ▁prev ▁== ▁- ▁1 ▁) ▁{ ▁prev ▁= ▁A ▁[ ▁end ▁] ▁; ▁res ▁++ ▁; ▁end ▁-- ▁; ▁} ▁else ▁{ ▁if ▁( ▁A ▁[ ▁end ▁] ▁>= ▁prev ▁) ▁{ ▁res ▁++ ▁; ▁prev ▁= ▁A ▁[ ▁end ▁] ▁; ▁end ▁-- ▁; ▁} ▁else ▁if ▁( ▁A ▁[ ▁start ▁] ▁>= ▁prev ▁) ▁{ ▁res ▁++ ▁; ▁prev ▁= ▁A ▁[ ▁start ▁] ▁; ▁start ▁++ ▁; ▁} ▁else ▁{ ▁break ▁; ▁} ▁} ▁} ▁} ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁1 ▁, ▁3 ▁, ▁5 ▁, ▁4 ▁, ▁3 ▁, ▁6 ▁, ▁2 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁A ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁find Long est Non Dec re asing ▁( ▁A ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁find Pairs ▁( ▁int ▁N ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁( ▁" ▁+ ▁i ▁+ ▁" ▁, ▁" ▁+ ▁( ▁N ▁- ▁i ▁) ▁+ ▁" ▁) ▁, ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁5 ▁; ▁find Pairs ▁( ▁N ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁public ▁static ▁int ▁Min Operation ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁int ▁cnt O pe ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁K ▁> ▁arr ▁[ ▁i ▁] ▁) ▁{ ▁if ▁( ▁( ▁K ▁- ▁arr ▁[ ▁i ▁] ▁) ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁cnt O pe ▁+= ▁2 ▁; ▁} ▁else ▁{ ▁cnt O pe ▁+= ▁1 ▁; ▁} ▁} ▁else ▁if ▁( ▁K ▁< ▁arr ▁[ ▁i ▁] ▁) ▁{ ▁if ▁( ▁( ▁K ▁- ▁arr ▁[ ▁i ▁] ▁) ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁cnt O pe ▁+= ▁1 ▁; ▁} ▁else ▁{ ▁cnt O pe ▁+= ▁2 ▁; ▁} ▁} ▁} ▁return ▁cnt O pe ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁8 ▁, ▁7 ▁, ▁2 ▁, ▁1 ▁, ▁3 ▁} ▁; ▁int ▁K ▁= ▁5 ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁Min Operation ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁cl st Num ▁( ▁int ▁N ▁) ▁{ ▁return ▁( ▁N ▁- ▁1 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁11 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁cl st Num ▁( ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁double ▁pair Product Mean ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁Vector ▁< ▁Integer ▁> ▁pair Array ▁= ▁new ▁Vector ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁int ▁pair Product ▁= ▁arr ▁[ ▁i ▁] ▁* ▁arr ▁[ ▁j ▁] ▁; ▁pair Array ▁. ▁add ▁( ▁pair Product ▁) ▁; ▁} ▁} ▁int ▁length ▁= ▁pair Array ▁. ▁size ▁( ▁) ▁; ▁float ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁length ▁; ▁i ▁++ ▁) ▁sum ▁+= ▁pair Array ▁. ▁get ▁( ▁i ▁) ▁; ▁float ▁mean ▁; ▁if ▁( ▁length ▁!= ▁0 ▁) ▁mean ▁= ▁sum ▁/ ▁length ▁; ▁else ▁mean ▁= ▁0 ▁; ▁return ▁mean ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁4 ▁, ▁8 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁format ▁( ▁" ▁% ▁.2 f ▁" ▁, ▁pair Product Mean ▁( ▁arr ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁min Prod ▁( ▁int ▁X ▁, ▁int ▁Y ▁, ▁int ▁N ▁) ▁{ ▁if ▁( ▁X ▁<= ▁Y ▁) ▁{ ▁if ▁( ▁N ▁< ▁X ▁) ▁return ▁( ▁X ▁- ▁N ▁) ▁* ▁Y ▁; ▁else ▁{ ▁return ▁Math ▁. ▁max ▁( ▁Y ▁- ▁( ▁N ▁- ▁X ▁+ ▁1 ▁) ▁, ▁1 ▁) ▁; ▁} ▁} ▁if ▁( ▁Y ▁>= ▁N ▁) ▁return ▁( ▁Y ▁- ▁N ▁) ▁* ▁X ▁; ▁return ▁Math ▁. ▁max ▁( ▁X ▁- ▁( ▁N ▁- ▁Y ▁+ ▁1 ▁) ▁, ▁1 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁X ▁= ▁47 ▁, ▁Y ▁= ▁42 ▁, ▁N ▁= ▁16 7 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁min Prod ▁( ▁X ▁, ▁Y ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁factors Of 3 ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁a ▁= ▁0 ▁, ▁b ▁= ▁0 ▁, ▁c ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁% ▁3 ▁== ▁0 ▁) ▁a ▁++ ▁; ▁else ▁if ▁( ▁arr ▁[ ▁i ▁] ▁% ▁3 ▁== ▁1 ▁) ▁b ▁++ ▁; ▁else ▁if ▁( ▁arr ▁[ ▁i ▁] ▁% ▁3 ▁== ▁2 ▁) ▁c ▁++ ▁; ▁} ▁if ▁( ▁a ▁>= ▁1 ▁&& ▁a ▁<= ▁b ▁+ ▁c ▁+ ▁1 ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Yes ▁" ▁+ ▁" NEW _ LINE "); ▁else ▁if ▁( ▁a ▁== ▁0 ▁&& ▁b ▁== ▁0 ▁&& ▁c ▁> ▁0 ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Yes ▁" ▁+ ▁" NEW _ LINE "); ▁else ▁if ▁( ▁a ▁== ▁0 ▁&& ▁c ▁== ▁0 ▁&& ▁b ▁> ▁0 ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Yes ▁" ▁+ ▁" NEW _ LINE "); ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁No ▁" ▁+ ▁" NEW _ LINE "); ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁3 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁factors Of 3 ▁( ▁arr ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁max B ott les ▁( ▁int ▁n ▁, ▁int ▁e ▁) ▁{ ▁int ▁s ▁= ▁0 ▁, ▁b ▁= ▁0 ▁; ▁int ▁a ▁= ▁n ▁; ▁while ▁( ▁a ▁!= ▁0 ▁) ▁{ ▁s ▁= ▁s ▁+ ▁a ▁; ▁a ▁= ▁( ▁a ▁+ ▁b ▁) ▁/ ▁e ▁; ▁b ▁= ▁n ▁- ▁( ▁a ▁* ▁e ▁) ▁; ▁n ▁= ▁a ▁+ ▁b ▁; ▁} ▁return ▁s ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁9 ▁, ▁e ▁= ▁3 ▁; ▁int ▁s ▁= ▁max B ott les ▁( ▁n ▁, ▁e ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁s ▁+ ▁" NEW _ LINE "); ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁power ▁( ▁int ▁x ▁, ▁int ▁n ▁) ▁{ ▁int ▁temp ▁; ▁if ▁( ▁n ▁== ▁0 ▁) ▁return ▁1 ▁; ▁temp ▁= ▁power ▁( ▁x ▁, ▁n ▁/ ▁2 ▁) ▁; ▁if ▁( ▁n ▁% ▁2 ▁== ▁0 ▁) ▁return ▁temp ▁* ▁temp ▁; ▁else ▁return ▁x ▁* ▁temp ▁* ▁temp ▁; ▁} ▁static ▁int ▁count _ Total _ Numbers ▁( ▁int ▁n ▁, ▁int ▁x ▁) ▁{ ▁int ▁total ▁, ▁multiples ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁10 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁% ▁x ▁== ▁0 ▁) ▁multiples ▁++ ▁; ▁} ▁if ▁( ▁n ▁== ▁1 ▁) ▁return ▁multiples ▁; ▁total ▁= ▁( ▁multiples ▁- ▁1 ▁) ▁* ▁power ▁( ▁multiples ▁, ▁n ▁- ▁1 ▁) ▁; ▁return ▁total ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁1 ▁, ▁X ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁% ▁d ▁" ▁, ▁count _ Total _ Numbers ▁( ▁N ▁, ▁X ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁min Length ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁elem ▁= ▁A ▁[ ▁0 ▁] ▁, ▁count ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁A ▁[ ▁i ▁] ▁== ▁elem ▁) ▁{ ▁count ▁++ ▁; ▁} ▁else ▁{ ▁break ▁; ▁} ▁} ▁if ▁( ▁count ▁== ▁N ▁) ▁return ▁N ▁; ▁else ▁return ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁1 ▁, ▁3 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁min Length ▁( ▁arr ▁, ▁N ▁) ▁+ ▁" NEW _ LINE "); ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁min Sub arrays ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁right ▁= ▁n ▁- ▁1 ▁; ▁int ▁left ▁= ▁0 ▁; ▁int ▁sub arrays ▁= ▁0 ▁; ▁while ▁( ▁right ▁>= ▁0 ▁) ▁{ ▁for ▁( ▁left ▁= ▁0 ▁; ▁left ▁<= ▁right ▁; ▁left ▁+= ▁1 ▁) ▁{ ▁if ▁( ▁__ g cd ▁( ▁arr ▁[ ▁left ▁] ▁, ▁arr ▁[ ▁right ▁] ▁) ▁> ▁1 ▁) ▁{ ▁sub arrays ▁+= ▁1 ▁; ▁right ▁= ▁left ▁- ▁1 ▁; ▁break ▁; ▁} ▁if ▁( ▁left ▁== ▁right ▁&& ▁__ g cd ▁( ▁arr ▁[ ▁left ▁] ▁, ▁arr ▁[ ▁right ▁] ▁) ▁== ▁1 ▁) ▁{ ▁return ▁0 ▁; ▁} ▁} ▁} ▁return ▁sub arrays ▁; ▁} ▁static ▁int ▁__ g cd ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁return ▁b ▁== ▁0 ▁? ▁a ▁: ▁__ g cd ▁( ▁b ▁, ▁a ▁% ▁b ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁6 ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁4 ▁, ▁4 ▁, ▁3 ▁} ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁min Sub arrays ▁( ▁arr ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁print Missing Elements ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁diff ▁= ▁arr ▁[ ▁0 ▁] ▁- ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁- ▁i ▁!= ▁diff ▁) ▁{ ▁while ▁( ▁diff ▁< ▁arr ▁[ ▁i ▁] ▁- ▁i ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁( ▁i ▁+ ▁diff ▁) ▁+ ▁" ▁" ▁) ▁; ▁diff ▁++ ▁; ▁} ▁} ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁6 ▁, ▁7 ▁, ▁10 ▁, ▁11 ▁, ▁13 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁print Missing Elements ▁( ▁arr ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁print Missing Elements ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁[ ▁] ▁b ▁= ▁new ▁int ▁[ ▁arr ▁[ ▁N ▁- ▁1 ▁] ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁b ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁= ▁1 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁i ▁<= ▁arr ▁[ ▁N ▁- ▁1 ▁] ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁b ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁i ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁6 ▁, ▁7 ▁, ▁10 ▁, ▁11 ▁, ▁13 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁print Missing Elements ▁( ▁arr ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁mod ▁= ▁( ▁int ▁) ▁1 e 9 ▁+ ▁7 ▁; ▁static ▁int ▁power ▁( ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁if ▁( ▁y ▁== ▁0 ▁) ▁return ▁1 ▁; ▁int ▁p ▁= ▁power ▁( ▁x ▁, ▁y ▁/ ▁2 ▁) ▁% ▁mod ▁; ▁p ▁= ▁( ▁p ▁* ▁p ▁) ▁% ▁mod ▁; ▁if ▁( ▁( ▁y ▁& ▁1 ▁) ▁!= ▁0 ▁) ▁p ▁= ▁( ▁x ▁* ▁p ▁) ▁% ▁mod ▁; ▁return ▁p ▁; ▁} ▁static ▁int ▁Number Of Trees ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁max Element ▁= ▁Arrays ▁. ▁stream ▁( ▁arr ▁) ▁. ▁max ▁( ▁) ▁. ▁getAs Int ▁( ▁) ▁; ▁int ▁[ ▁] ▁level ▁= ▁new ▁int ▁[ ▁max Element ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁level ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁++ ▁; ▁} ▁if ▁( ▁arr ▁[ ▁0 ▁] ▁!= ▁0 ▁level ▁[ ▁0 ▁] ▁!= ▁1 ▁) ▁{ ▁return ▁0 ▁; ▁} ▁int ▁ans ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁max Element ▁; ▁i ▁++ ▁) ▁{ ▁ans ▁= ▁( ▁ans ▁* ▁power ▁( ▁level ▁[ ▁i ▁] ▁, ▁level ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁) ▁% ▁mod ▁; ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁7 ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁3 ▁, ▁2 ▁, ▁1 ▁, ▁2 ▁, ▁2 ▁, ▁1 ▁} ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁Number Of Trees ▁( ▁arr ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁carry Count ▁( ▁int ▁num 1 ▁, ▁int ▁num 2 ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁while ▁( ▁num 2 ▁!= ▁0 ▁) ▁{ ▁int ▁carry ▁= ▁num 1 ▁& ▁num 2 ▁; ▁num 1 ▁= ▁num 1 ▁^ ▁num 2 ▁; ▁num 2 ▁= ▁carry ▁<< ▁1 ▁; ▁count ▁+= ▁Integer ▁. ▁bit Count ▁( ▁num 2 ▁) ▁; ▁} ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁A ▁= ▁15 ▁, ▁B ▁= ▁10 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁carry Count ▁( ▁A ▁, ▁B ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁calculate Pro fit ▁( ▁int ▁n ▁, ▁int ▁[ ▁] ▁e arning s ▁, ▁int ▁[ ▁] ▁cost ▁, ▁int ▁e ▁) ▁{ ▁int ▁profit ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁e arning _ per _ day ▁= ▁0 ▁; ▁int ▁daily _ sp ent _ food ▁= ▁0 ▁; ▁if ▁( ▁i ▁== ▁( ▁n ▁- ▁1 ▁) ▁) ▁{ ▁e arning _ per _ day ▁= ▁e arning s ▁[ ▁i ▁] ▁* ▁e ▁; ▁profit ▁= ▁profit ▁+ ▁e arning _ per _ day ▁; ▁break ▁; ▁} ▁if ▁( ▁cost ▁[ ▁i ▁] ▁< ▁e arning s ▁[ ▁i ▁] ▁) ▁{ ▁e arning _ per _ day ▁= ▁e arning s ▁[ ▁i ▁] ▁* ▁e ▁; ▁daily _ sp ent _ food ▁= ▁cost ▁[ ▁i ▁] ▁* ▁e ▁; ▁profit ▁= ▁profit ▁+ ▁e arning _ per _ day ▁- ▁daily _ sp ent _ food ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁profit ▁+ ▁" NEW _ LINE "); ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁4 ▁; ▁int ▁e arning s ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁8 ▁, ▁6 ▁, ▁7 ▁} ▁; ▁int ▁cost ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁4 ▁, ▁1 ▁} ▁; ▁int ▁e ▁= ▁5 ▁; ▁calculate Pro fit ▁( ▁n ▁, ▁e arning s ▁, ▁cost ▁, ▁e ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁find Pair ▁( ▁int ▁A ▁, ▁int ▁B ▁, ▁int ▁N ▁) ▁{ ▁int ▁X ▁, ▁Y ▁; ▁X ▁= ▁N ▁- ▁B ▁+ ▁A ▁; ▁if ▁( ▁X ▁% ▁2 ▁!= ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁- ▁1" ▁) ▁; ▁} ▁else ▁{ ▁X ▁= ▁X ▁/ ▁2 ▁; ▁Y ▁= ▁N ▁- ▁X ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁X ▁+ ▁" ▁" ▁+ ▁Y ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁A ▁= ▁1 ▁; ▁int ▁B ▁= ▁3 ▁; ▁int ▁N ▁= ▁4 ▁; ▁find Pair ▁( ▁A ▁, ▁B ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁check ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁ma ▁= ▁a ▁[ ▁1 ▁] ▁- ▁a ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁a ▁[ ▁i ▁] ▁> ▁a ▁[ ▁i ▁- ▁1 ▁] ▁&& ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁< ▁a ▁[ ▁i ▁] ▁) ▁|| ▁( ▁a ▁[ ▁i ▁] ▁< ▁a ▁[ ▁i ▁- ▁1 ▁] ▁&& ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁> ▁a ▁[ ▁i ▁] ▁) ▁) ▁ma ▁= ▁Math ▁. ▁max ▁( ▁ma ▁, ▁Math ▁. ▁abs ▁( ▁a ▁[ ▁i ▁] ▁- ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁) ▁; ▁else ▁return ▁false ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Am plitude ▁= ▁" ▁+ ▁ma ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁return ▁true ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁1 ▁, ▁5 ▁, ▁0 ▁, ▁7 ▁, ▁- ▁6 ▁} ▁; ▁int ▁n ▁= ▁a ▁. ▁length ▁; ▁int ▁wave ▁= ▁( ▁n ▁- ▁1 ▁) ▁/ ▁2 ▁; ▁if ▁( ▁check ▁( ▁a ▁, ▁n ▁) ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁W aves ▁= ▁" ▁+ ▁wave ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁- ▁1" ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁String ▁Construct Binary String ▁( ▁int ▁N ▁, ▁int ▁M ▁, ▁int ▁K ▁) ▁{ ▁if ▁( ▁M ▁< ▁( ▁N ▁- ▁1 ▁) ▁|| ▁M ▁> ▁K ▁* ▁( ▁N ▁+ ▁1 ▁) ▁) ▁return ▁" ▁- ▁1" ▁; ▁String ▁ans ▁= ▁" ▁" ▁; ▁int ▁l ▁= ▁Math ▁. ▁min ▁( ▁K ▁, ▁M ▁/ ▁( ▁N ▁- ▁1 ▁) ▁) ▁; ▁int ▁temp ▁= ▁N ▁; ▁while ▁( ▁temp ▁!= ▁0 ▁) ▁{ ▁temp ▁-- ▁; ▁ans ▁+= ▁'0' ▁; ▁if ▁( ▁temp ▁== ▁0 ▁) ▁break ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁l ▁; ▁i ▁++ ▁) ▁{ ▁ans ▁+= ▁'1' ▁; ▁} ▁} ▁M ▁-= ▁( ▁N ▁- ▁1 ▁) ▁* ▁l ▁; ▁if ▁( ▁M ▁== ▁0 ▁) ▁return ▁ans ▁; ▁l ▁= ▁Math ▁. ▁min ▁( ▁M ▁, ▁K ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁l ▁; ▁i ▁++ ▁) ▁ans ▁+= ▁'1' ▁; ▁M ▁-= ▁l ▁; ▁while ▁( ▁M ▁> ▁0 ▁) ▁{ ▁ans ▁= ▁'1' ▁+ ▁ans ▁; ▁M ▁-- ▁; ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁5 ▁, ▁M ▁= ▁9 ▁, ▁K ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁Construct Binary String ▁( ▁N ▁, ▁M ▁, ▁K ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁no Of Fact ors ▁( ▁int ▁N ▁) ▁{ ▁if ▁( ▁N ▁== ▁1 ▁) ▁return ▁1 ▁; ▁int ▁count ▁= ▁0 ▁; ▁int ▁ans ▁= ▁1 ▁; ▁while ▁( ▁N ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁count ▁++ ▁; ▁N ▁= ▁N ▁/ ▁2 ▁; ▁} ▁ans ▁*= ▁( ▁count ▁/ ▁2 ▁+ ▁1 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁3 ▁; ▁i ▁* ▁i ▁<= ▁N ▁; ▁i ▁= ▁i ▁+ ▁2 ▁) ▁{ ▁count ▁= ▁0 ▁; ▁while ▁( ▁N ▁% ▁i ▁== ▁0 ▁) ▁{ ▁count ▁++ ▁; ▁N ▁= ▁N ▁/ ▁i ▁; ▁} ▁ans ▁*= ▁( ▁count ▁/ ▁2 ▁+ ▁1 ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁100 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁no Of Fact ors ▁( ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁print _ path ▁( ▁int ▁N ▁, ▁int ▁jump ▁, ▁int ▁coin ▁) ▁{ ▁if ▁( ▁jump ▁> ▁coin ▁|| ▁jump ▁* ▁( ▁N ▁- ▁1 ▁) ▁< ▁coin ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁- ▁1" ▁) ▁; ▁} ▁else ▁{ ▁int ▁pos ▁= ▁1 ▁; ▁while ▁( ▁jump ▁> ▁0 ▁) ▁{ ▁int ▁tmp ▁= ▁Math ▁. ▁min ▁( ▁N ▁- ▁1 ▁, ▁coin ▁- ▁( ▁jump ▁- ▁1 ▁) ▁) ▁; ▁if ▁( ▁pos ▁+ ▁tmp ▁<= ▁N ▁) ▁{ ▁pos ▁+= ▁tmp ▁; ▁} ▁else ▁{ ▁pos ▁-= ▁tmp ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁pos ▁+ ▁" ▁" ▁) ▁; ▁; ▁coin ▁-= ▁tmp ▁; ▁jump ▁-= ▁1 ▁; ▁} ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁5 ▁, ▁K ▁= ▁4 ▁, ▁M ▁= ▁12 ▁; ▁print _ path ▁( ▁N ▁, ▁K ▁, ▁M ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁min Changes ▁( ▁String ▁str ▁, ▁int ▁N ▁) ▁{ ▁int ▁res ▁; ▁int ▁count 0 ▁= ▁0 ▁, ▁count 1 ▁= ▁0 ▁; ▁for ▁( ▁char ▁x ▁: ▁str ▁. ▁toCharArray ▁( ▁) ▁) ▁{ ▁if ▁( ▁x ▁== ▁'0' ▁) ▁count 0 ▁++ ▁; ▁} ▁res ▁= ▁count 0 ▁; ▁for ▁( ▁char ▁x ▁: ▁str ▁. ▁toCharArray ▁( ▁) ▁) ▁{ ▁if ▁( ▁x ▁== ▁'0' ▁) ▁count 0 ▁-- ▁; ▁if ▁( ▁x ▁== ▁'1' ▁) ▁count 1 ▁++ ▁; ▁res ▁= ▁Math ▁. ▁min ▁( ▁res ▁, ▁count 1 ▁+ ▁count 0 ▁) ▁; ▁} ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁9 ▁; ▁String ▁str ▁= ▁" 0001 0100 1" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁min Changes ▁( ▁str ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁Scanner ▁; ▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁int ▁count _ tri angles ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁int ▁c ▁, ▁int ▁d ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁x ▁= ▁a ▁; ▁x ▁<= ▁b ▁; ▁++ ▁x ▁) ▁{ ▁int ▁num _ greater _ than _ d ▁= ▁Math ▁. ▁max ▁( ▁d ▁, ▁c ▁+ ▁x ▁) ▁- ▁Math ▁. ▁max ▁( ▁d ▁, ▁b ▁+ ▁x ▁- ▁1 ▁) ▁; ▁ans ▁+= ▁num _ greater _ than _ d ▁* ▁( ▁d ▁- ▁c ▁+ ▁1 ▁) ▁; ▁int ▁r ▁= ▁Math ▁. ▁min ▁( ▁Math ▁. ▁max ▁( ▁c ▁, ▁c ▁+ ▁x ▁) ▁, ▁d ▁) ▁- ▁c ▁; ▁int ▁l ▁= ▁Math ▁. ▁min ▁( ▁Math ▁. ▁max ▁( ▁c ▁, ▁b ▁+ ▁x ▁- ▁1 ▁) ▁, ▁d ▁) ▁- ▁c ▁; ▁int ▁x 1 ▁= ▁( ▁r ▁* ▁( ▁r ▁+ ▁1 ▁) ▁) ▁/ ▁2 ▁; ▁int ▁x 2 ▁= ▁( ▁l ▁* ▁( ▁l ▁+ ▁1 ▁) ▁) ▁/ ▁2 ▁; ▁ans ▁+= ▁x 1 ▁- ▁x 2 ▁; ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁a ▁= ▁2 ▁, ▁b ▁= ▁3 ▁, ▁c ▁= ▁4 ▁, ▁d ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count _ tri angles ▁( ▁a ▁, ▁b ▁, ▁c ▁, ▁d ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁print K Parts ▁( ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁if ▁( ▁N ▁% ▁K ▁== ▁0 ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁K ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁"1 ▁, ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁N ▁- ▁( ▁K ▁- ▁1 ▁) ▁+ ▁" NEW _ LINE "); ▁} ▁else ▁{ ▁if ▁( ▁K ▁== ▁2 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Not ▁Possible ▁" ▁+ ▁" NEW _ LINE "); ▁return ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁K ▁- ▁1 ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁1 ▁+ ▁" ▁, ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁2 ▁+ ▁" ▁, ▁" ▁+ ▁( ▁N ▁- ▁K ▁) ▁+ ▁" NEW _ LINE "); ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁18 ▁, ▁K ▁= ▁5 ▁; ▁print K Parts ▁( ▁N ▁, ▁K ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁getL argest Sum ▁( ▁int ▁N ▁) ▁{ ▁int ▁max _ sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁<= ▁N ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁i ▁* ▁j ▁% ▁( ▁i ▁+ ▁j ▁) ▁== ▁0 ▁) ▁max _ sum ▁= ▁Math ▁. ▁max ▁( ▁max _ sum ▁, ▁i ▁+ ▁j ▁) ▁; ▁} ▁} ▁return ▁max _ sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁25 ▁; ▁int ▁max _ sum ▁= ▁getL argest Sum ▁( ▁N ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁max _ sum ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁long ▁getP airs ▁( ▁Vector ▁< ▁Integer ▁> ▁A ▁, ▁Vector ▁< ▁Integer ▁> ▁B ▁, ▁int ▁n ▁) ▁{ ▁int ▁[ ▁] ▁D ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁D ▁[ ▁i ▁] ▁= ▁A ▁. ▁get ▁( ▁i ▁) ▁- ▁B ▁. ▁get ▁( ▁i ▁) ▁; ▁} ▁Arrays ▁. ▁sort ▁( ▁D ▁) ▁; ▁long ▁total ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁D ▁[ ▁i ▁] ▁> ▁0 ▁) ▁{ ▁total ▁+= ▁n ▁- ▁i ▁- ▁1 ▁; ▁} ▁else ▁{ ▁int ▁k ▁= ▁upper _ bound ▁( ▁D ▁, ▁0 ▁, ▁D ▁. ▁length ▁, ▁- ▁D ▁[ ▁i ▁] ▁) ▁; ▁total ▁+= ▁n ▁- ▁k ▁; ▁} ▁} ▁return ▁total ▁; ▁} ▁static ▁int ▁upper _ bound ▁( ▁int ▁[ ▁] ▁a ▁, ▁int ▁low ▁, ▁int ▁high ▁, ▁int ▁element ▁) ▁{ ▁while ▁( ▁low ▁< ▁high ▁) ▁{ ▁int ▁middle ▁= ▁low ▁+ ▁( ▁high ▁- ▁low ▁) ▁/ ▁2 ▁; ▁if ▁( ▁a ▁[ ▁middle ▁] ▁> ▁element ▁) ▁high ▁= ▁middle ▁; ▁else ▁low ▁= ▁middle ▁+ ▁1 ▁; ▁} ▁return ▁low ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁5 ▁; ▁Vector ▁< ▁Integer ▁> ▁A ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁Vector ▁< ▁Integer ▁> ▁B ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁A ▁. ▁add ▁( ▁4 ▁) ▁; ▁A ▁. ▁add ▁( ▁8 ▁) ▁; ▁A ▁. ▁add ▁( ▁2 ▁) ▁; ▁A ▁. ▁add ▁( ▁6 ▁) ▁; ▁A ▁. ▁add ▁( ▁2 ▁) ▁; ▁B ▁. ▁add ▁( ▁4 ▁) ▁; ▁B ▁. ▁add ▁( ▁5 ▁) ▁; ▁B ▁. ▁add ▁( ▁4 ▁) ▁; ▁B ▁. ▁add ▁( ▁1 ▁) ▁; ▁B ▁. ▁add ▁( ▁3 ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁getP airs ▁( ▁A ▁, ▁B ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁[ ▁] ▁fact ▁= ▁new ▁int ▁[ ▁14 ▁] ▁; ▁static ▁int ▁size ▁= ▁1 ▁; ▁static ▁void ▁pre Compute ▁( ▁int ▁N ▁) ▁{ ▁fact ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁fact ▁[ ▁i ▁- ▁1 ▁] ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁fact ▁[ ▁i ▁] ▁= ▁( ▁fact ▁[ ▁i ▁- ▁1 ▁] ▁* ▁i ▁) ▁; ▁size ▁++ ▁; ▁} ▁} ▁static ▁void ▁find Min ▁( ▁int ▁N ▁) ▁{ ▁pre Compute ▁( ▁N ▁) ▁; ▁int ▁original N ▁= ▁N ▁; ▁Vector ▁< ▁Integer ▁> ▁ans ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁size ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁while ▁( ▁N ▁>= ▁fact ▁[ ▁i ▁] ▁) ▁{ ▁N ▁-= ▁fact ▁[ ▁i ▁] ▁; ▁ans ▁. ▁add ▁( ▁fact ▁[ ▁i ▁] ▁) ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁ans ▁. ▁size ▁( ▁) ▁+ ▁" NEW _ LINE "); ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁ans ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁ans ▁. ▁get ▁( ▁i ▁) ▁+ ▁" ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁27 ▁; ▁find Min ▁( ▁n ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁k _ sum ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁r ▁= ▁0 ▁, ▁sum ▁= ▁0 ▁; ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁l ▁= ▁0 ▁; ▁l ▁< ▁n ▁; ▁l ▁++ ▁) ▁{ ▁while ▁( ▁sum ▁< ▁k ▁) ▁{ ▁if ▁( ▁r ▁== ▁n ▁) ▁break ▁; ▁else ▁{ ▁sum ▁+= ▁a ▁[ ▁r ▁] ▁; ▁r ▁++ ▁; ▁} ▁} ▁if ▁( ▁sum ▁< ▁k ▁) ▁break ▁; ▁ans ▁+= ▁n ▁- ▁r ▁+ ▁1 ▁; ▁sum ▁-= ▁a ▁[ ▁l ▁] ▁; ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁6 ▁, ▁1 ▁, ▁2 ▁, ▁7 ▁} ▁, ▁k ▁= ▁10 ▁; ▁int ▁n ▁= ▁a ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁k _ sum ▁( ▁a ▁, ▁n ▁, ▁k ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁max Sum ▁( ▁int ▁arr 1 ▁[ ▁] ▁, ▁int ▁arr 2 ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁initial Par ity ▁= ▁0 ▁, ▁final Par ity ▁= ▁0 ▁; ▁int ▁sum ▁= ▁0 ▁, ▁min Positive ▁= ▁Integer ▁. ▁MAX _ VALUE ▁, ▁max Negative ▁= ▁Integer ▁. ▁MIN _ VALUE ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁initial Par ity ▁+= ▁arr 2 ▁[ ▁i ▁] ▁; ▁if ▁( ▁arr 1 ▁[ ▁i ▁] ▁>= ▁0 ▁) ▁{ ▁final Par ity ▁+= ▁1 ▁; ▁sum ▁+= ▁arr 1 ▁[ ▁i ▁] ▁; ▁min Positive ▁= ▁Math ▁. ▁min ▁( ▁min Positive ▁, ▁arr 1 ▁[ ▁i ▁] ▁) ▁; ▁} ▁else ▁{ ▁max Negative ▁= ▁Math ▁. ▁max ▁( ▁max Negative ▁, ▁arr 1 ▁[ ▁i ▁] ▁) ▁; ▁} ▁} ▁if ▁( ▁initial Par ity ▁% ▁2 ▁== ▁final Par ity ▁% ▁2 ▁) ▁{ ▁return ▁sum ▁; ▁} ▁else ▁{ ▁if ▁( ▁min Positive ▁+ ▁max Negative ▁>= ▁0 ▁) ▁{ ▁return ▁sum ▁+ ▁max Negative ▁; ▁} ▁else ▁{ ▁return ▁sum ▁- ▁min Positive ▁; ▁} ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr 1 ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁- ▁4 ▁, ▁5 ▁, ▁3 ▁} ▁; ▁int ▁arr 2 ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁} ▁; ▁int ▁n ▁= ▁arr 1 ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁max Sum ▁( ▁arr 1 ▁, ▁arr 2 ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁min Capacity ▁( ▁int ▁enter ▁[ ▁] ▁, ▁int ▁exit ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁min Cap ▁= ▁0 ▁; ▁int ▁curr Cap ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁curr Cap ▁= ▁curr Cap ▁+ ▁enter ▁[ ▁i ▁] ▁- ▁exit ▁[ ▁i ▁] ▁; ▁min Cap ▁= ▁Math ▁. ▁max ▁( ▁min Cap ▁, ▁curr Cap ▁) ▁; ▁} ▁return ▁min Cap ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁enter ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁5 ▁, ▁2 ▁, ▁0 ▁} ▁; ▁int ▁exit ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁2 ▁, ▁4 ▁, ▁4 ▁} ▁; ▁int ▁n ▁= ▁enter ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁min Capacity ▁( ▁enter ▁, ▁exit ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁getMin ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁min Val ▁= ▁Arrays ▁. ▁stream ▁( ▁arr ▁) ▁. ▁min ▁( ▁) ▁. ▁getAs Int ▁( ▁) ▁; ▁return ▁min Val ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁3 ▁, ▁1 ▁, ▁6 ▁, ▁9 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁getMin ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁longest Sub array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁max Mean ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁max Mean ▁= ▁Math ▁. ▁max ▁( ▁max Mean ▁, ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁) ▁/ ▁2 ▁) ▁; ▁int ▁ans ▁= ▁0 ▁; ▁int ▁sub array Length ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁arr ▁[ ▁i ▁] ▁>= ▁max Mean ▁) ▁ans ▁= ▁Math ▁. ▁max ▁( ▁ans ▁, ▁++ ▁sub array Length ▁) ▁; ▁else ▁sub array Length ▁= ▁0 ▁; ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁3 ▁, ▁3 ▁, ▁2 ▁, ▁1 ▁, ▁4 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁longest Sub array ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁MAX ▁= ▁24 ▁; ▁static ▁int ▁count Op ▁( ▁int ▁x ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁new ▁int ▁[ ▁MAX ▁] ▁; ▁arr ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁MAX ▁; ▁i ▁++ ▁) ▁arr ▁[ ▁i ▁] ▁= ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁* ▁2 ▁; ▁int ▁temp ▁= ▁x ▁; ▁boolean ▁flag ▁= ▁true ▁; ▁int ▁ans ▁= ▁0 ▁; ▁int ▁operations ▁= ▁0 ▁; ▁boolean ▁flag 2 ▁= ▁false ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁MAX ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁- ▁1 ▁== ▁x ▁) ▁flag 2 ▁= ▁true ▁; ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁x ▁) ▁{ ▁ans ▁= ▁i ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁flag 2 ▁) ▁return ▁0 ▁; ▁while ▁( ▁flag ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁ans ▁] ▁< ▁x ▁) ▁ans ▁++ ▁; ▁operations ▁++ ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁MAX ▁; ▁i ▁++ ▁) ▁{ ▁int ▁take ▁= ▁x ▁^ ▁( ▁arr ▁[ ▁i ▁] ▁- ▁1 ▁) ▁; ▁if ▁( ▁take ▁<= ▁arr ▁[ ▁ans ▁] ▁- ▁1 ▁) ▁{ ▁if ▁( ▁take ▁> ▁temp ▁) ▁temp ▁= ▁take ▁; ▁} ▁} ▁if ▁( ▁temp ▁== ▁arr ▁[ ▁ans ▁] ▁- ▁1 ▁) ▁{ ▁flag ▁= ▁false ▁; ▁break ▁; ▁} ▁temp ▁++ ▁; ▁operations ▁++ ▁; ▁x ▁= ▁temp ▁; ▁if ▁( ▁x ▁== ▁arr ▁[ ▁ans ▁] ▁- ▁1 ▁) ▁flag ▁= ▁false ▁; ▁} ▁return ▁operations ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁x ▁= ▁39 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Op ▁( ▁x ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁max Coin s ▁( ▁int ▁X ▁, ▁int ▁Y ▁) ▁{ ▁if ▁( ▁X ▁< ▁Y ▁) ▁{ ▁swap ▁( ▁X ▁, ▁Y ▁) ▁; ▁} ▁int ▁coins ▁= ▁X ▁; ▁X ▁-- ▁; ▁coins ▁+= ▁Math ▁. ▁max ▁( ▁X ▁, ▁Y ▁) ▁; ▁return ▁coins ▁; ▁} ▁static ▁void ▁swap ▁( ▁int ▁X ▁, ▁int ▁Y ▁) ▁{ ▁int ▁temp ▁= ▁X ▁; ▁X ▁= ▁Y ▁; ▁Y ▁= ▁temp ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁X ▁= ▁7 ▁, ▁Y ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁max Coin s ▁( ▁X ▁, ▁Y ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁print Array ▁( ▁int ▁N ▁, ▁int ▁[ ▁] ▁arr ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁} ▁static ▁void ▁replaced Array ▁( ▁int ▁N ▁, ▁int ▁[ ▁] ▁arr ▁) ▁{ ▁int ▁pos _ sum ▁, ▁neg _ sum ▁, ▁i ▁, ▁j ▁, ▁diff ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁pos _ sum ▁= ▁0 ▁; ▁neg _ sum ▁= ▁0 ▁; ▁for ▁( ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁j ▁] ▁> ▁0 ▁) ▁pos _ sum ▁+= ▁arr ▁[ ▁j ▁] ▁; ▁else ▁neg _ sum ▁+= ▁arr ▁[ ▁j ▁] ▁; ▁} ▁diff ▁= ▁Math ▁. ▁abs ▁( ▁pos _ sum ▁) ▁- ▁Math ▁. ▁abs ▁( ▁neg _ sum ▁) ▁; ▁arr ▁[ ▁i ▁] ▁= ▁Math ▁. ▁abs ▁( ▁diff ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁N ▁= ▁5 ▁; ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁1 ▁, ▁- ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁- ▁2 ▁} ▁; ▁replaced Array ▁( ▁N ▁, ▁arr ▁) ▁; ▁print Array ▁( ▁N ▁, ▁arr ▁) ▁; ▁N ▁= ▁6 ▁; ▁int ▁[ ▁] ▁arr 1 ▁= ▁{ ▁- ▁3 ▁, ▁- ▁4 ▁, ▁- ▁2 ▁, ▁5 ▁, ▁1 ▁, ▁- ▁2 ▁} ▁; ▁replaced Array ▁( ▁N ▁, ▁arr 1 ▁) ▁; ▁print Array ▁( ▁N ▁, ▁arr 1 ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁class ▁G F G ▁{ ▁static ▁long ▁max ▁( ▁long ▁a ▁, ▁long ▁b ▁) ▁{ ▁if ▁( ▁a ▁> ▁b ▁) ▁return ▁a ▁; ▁else ▁return ▁b ▁; ▁} ▁static ▁long ▁smallest Side ▁( ▁long ▁a ▁[ ▁] ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁a ▁) ▁; ▁long ▁side 1 ▁, ▁side 2 ▁, ▁side 3 ▁, ▁side 4 ▁, ▁side 11 ▁, ▁side 12 ▁, ▁side Of Square ▁; ▁side 1 ▁= ▁a ▁[ ▁0 ▁] ▁+ ▁a ▁[ ▁3 ▁] ▁; ▁side 2 ▁= ▁a ▁[ ▁1 ▁] ▁+ ▁a ▁[ ▁2 ▁] ▁; ▁side 3 ▁= ▁a ▁[ ▁0 ▁] ▁+ ▁a ▁[ ▁1 ▁] ▁; ▁side 4 ▁= ▁a ▁[ ▁2 ▁] ▁+ ▁a ▁[ ▁3 ▁] ▁; ▁side 11 ▁= ▁max ▁( ▁side 1 ▁, ▁side 2 ▁) ▁; ▁side 12 ▁= ▁max ▁( ▁side 3 ▁, ▁side 4 ▁) ▁; ▁side Of Square ▁= ▁max ▁( ▁side 11 ▁, ▁side 12 ▁) ▁; ▁return ▁side Of Square ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁long ▁side ▁[ ▁] ▁= ▁new ▁long ▁[ ▁4 ▁] ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Test ▁Case ▁1" ▁) ▁; ▁side ▁[ ▁0 ▁] ▁= ▁2 ▁; ▁side ▁[ ▁1 ▁] ▁= ▁2 ▁; ▁side ▁[ ▁2 ▁] ▁= ▁2 ▁; ▁side ▁[ ▁3 ▁] ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁smallest Side ▁( ▁side ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Test ▁Case ▁2 ▁"); ▁side ▁[ ▁0 ▁] ▁= ▁100 000000000000 L ▁; ▁side ▁[ ▁1 ▁] ▁= ▁12345 0000000000 L ▁; ▁side ▁[ ▁2 ▁] ▁= ▁98 765 0000000000 L ▁; ▁side ▁[ ▁3 ▁] ▁= ▁98 7654 321 000000 L ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁smallest Side ▁( ▁side ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁max Sub Array Sum ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁size ▁) ▁{ ▁int ▁max _ so _ far ▁= ▁Integer ▁. ▁MIN _ VALUE ▁, ▁max _ ending _ here ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁{ ▁max _ ending _ here ▁= ▁max _ ending _ here ▁+ ▁a ▁[ ▁i ▁] ▁; ▁if ▁( ▁max _ so _ far ▁< ▁max _ ending _ here ▁) ▁max _ so _ far ▁= ▁max _ ending _ here ▁; ▁if ▁( ▁max _ ending _ here ▁< ▁0 ▁) ▁max _ ending _ here ▁= ▁0 ▁; ▁} ▁return ▁max _ so _ far ▁; ▁} ▁static ▁int ▁max Sum ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁S ▁= ▁0 ▁; ▁int ▁S 1 ▁= ▁max Sub Array Sum ▁( ▁a ▁, ▁n ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁S ▁+= ▁a ▁[ ▁i ▁] ▁; ▁return ▁( ▁2 ▁* ▁S 1 ▁- ▁S ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁- ▁35 ▁, ▁32 ▁, ▁- ▁24 ▁, ▁0 ▁, ▁27 ▁, ▁- ▁10 ▁, ▁0 ▁, ▁- ▁19 ▁} ▁; ▁int ▁n ▁= ▁a ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁max Sum ▁( ▁a ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁n ▁= ▁3 ▁; ▁static ▁int ▁m ▁= ▁4 ▁; ▁static ▁int ▁max Matrix Score ▁( ▁int ▁A ▁[ ▁] ▁[ ▁] ▁, ▁int ▁K ▁) ▁{ ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁update ▁= ▁new ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁A ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁== ▁0 ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁< ▁m ▁; ▁++ ▁j ▁) ▁ans ▁= ▁( ▁int ▁) ▁( ▁ans ▁+ ▁A ▁[ ▁i ▁] ▁[ ▁j ▁] ▁* ▁Math ▁. ▁pow ▁( ▁2 ▁, ▁m ▁- ▁j ▁- ▁1 ▁) ▁) ▁; ▁update ▁. ▁put ▁( ▁ans ▁, ▁i ▁) ▁; ▁} ▁} ▁for ▁( ▁Map ▁. ▁Entry ▁< ▁Integer ▁, ▁Integer ▁> ▁it ▁: ▁update ▁. ▁entrySet ▁( ▁) ▁) ▁if ▁( ▁K ▁> ▁0 ▁) ▁{ ▁int ▁idx ▁= ▁it ▁. ▁getValue ▁( ▁) ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁m ▁; ▁++ ▁j ▁) ▁A ▁[ ▁idx ▁] ▁[ ▁j ▁] ▁= ▁( ▁A ▁[ ▁idx ▁] ▁[ ▁j ▁] ▁+ ▁1 ▁) ▁% ▁2 ▁; ▁K ▁-- ▁; ▁} ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁m ▁; ▁++ ▁j ▁) ▁{ ▁int ▁zero ▁= ▁0 ▁, ▁one ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁A ▁[ ▁i ▁] ▁[ ▁j ▁] ▁== ▁0 ▁) ▁zero ▁++ ▁; ▁else ▁one ▁++ ▁; ▁} ▁if ▁( ▁K ▁> ▁0 ▁&& ▁zero ▁> ▁one ▁) ▁{ ▁ans ▁+= ▁zero ▁* ▁Math ▁. ▁pow ▁( ▁2 ▁, ▁m ▁- ▁j ▁- ▁1 ▁) ▁; ▁K ▁-- ▁; ▁} ▁else ▁ans ▁+= ▁one ▁* ▁Math ▁. ▁pow ▁( ▁2 ▁, ▁m ▁- ▁j ▁- ▁1 ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁A ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁0 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁} ▁, ▁{ ▁1 ▁, ▁1 ▁, ▁0 ▁, ▁0 ▁} ▁} ▁; ▁int ▁K ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁max Matrix Score ▁( ▁A ▁, ▁K ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁public ▁class ▁G F G ▁{ ▁static ▁int ▁max imize And ▁( ▁int ▁i ▁, ▁int ▁mask ▁, ▁int ▁A ▁[ ▁] ▁, ▁int ▁B ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁[ ▁] ▁[ ▁] ▁dp ▁) ▁{ ▁if ▁( ▁i ▁== ▁N ▁) ▁return ▁0 ▁; ▁if ▁( ▁dp ▁[ ▁i ▁] ▁[ ▁mask ▁] ▁!= ▁- ▁1 ▁) ▁return ▁dp ▁[ ▁i ▁] ▁[ ▁mask ▁] ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁N ▁; ▁++ ▁j ▁) ▁{ ▁if ▁( ▁( ▁mask ▁& ▁( ▁1 ▁<< ▁j ▁) ▁) ▁== ▁0 ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁mask ▁] ▁= ▁Math ▁. ▁max ▁( ▁dp ▁[ ▁i ▁] ▁[ ▁mask ▁] ▁, ▁( ▁A ▁[ ▁i ▁] ▁& ▁B ▁[ ▁j ▁] ▁) ▁+ ▁max imize And ▁( ▁i ▁+ ▁1 ▁, ▁mask ▁| ▁( ▁1 ▁<< ▁j ▁) ▁, ▁A ▁, ▁B ▁, ▁N ▁, ▁dp ▁) ▁) ▁; ▁} ▁} ▁return ▁dp ▁[ ▁i ▁] ▁[ ▁mask ▁] ▁; ▁} ▁static ▁int ▁max imize And Util ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁B ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁dp ▁[ ▁] ▁[ ▁] ▁= ▁new ▁int ▁[ ▁N ▁] ▁[ ▁( ▁1 ▁<< ▁N ▁) ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁dd ▁[ ▁] ▁: ▁dp ▁) ▁Arrays ▁. ▁fill ▁( ▁dd ▁, ▁- ▁1 ▁) ▁; ▁return ▁max imize And ▁( ▁0 ▁, ▁0 ▁, ▁A ▁, ▁B ▁, ▁N ▁, ▁dp ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁5 ▁, ▁7 ▁, ▁11 ▁} ▁; ▁int ▁B ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁6 ▁, ▁10 ▁, ▁12 ▁} ▁; ▁int ▁N ▁= ▁A ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁max imize And Util ▁( ▁A ▁, ▁B ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁mn ▁= ▁- ▁214748364 8 ▁; ▁static ▁int ▁lis O tim ised ▁( ▁String ▁s ▁) ▁{ ▁int ▁[ ▁] ▁dp ▁= ▁new ▁int ▁[ ▁30 ▁] ▁; ▁Arrays ▁. ▁fill ▁( ▁dp ▁, ▁0 ▁) ▁; ▁int ▁N ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁int ▁lis ▁= ▁mn ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁int ▁val ▁= ▁( ▁int ▁) ▁s ▁. ▁charAt ▁( ▁i ▁) ▁- ▁97 ▁; ▁int ▁curr ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁val ▁; ▁j ▁++ ▁) ▁{ ▁curr ▁= ▁Math ▁. ▁max ▁( ▁curr ▁, ▁dp ▁[ ▁j ▁] ▁) ▁; ▁} ▁curr ▁++ ▁; ▁lis ▁= ▁Math ▁. ▁max ▁( ▁lis ▁, ▁curr ▁) ▁; ▁dp ▁[ ▁val ▁] ▁= ▁Math ▁. ▁max ▁( ▁dp ▁[ ▁val ▁] ▁, ▁curr ▁) ▁; ▁} ▁return ▁lis ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁s ▁= ▁" ▁fd ry ut iag h f se ▁" ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁lis O tim ised ▁( ▁s ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁MAX ▁= ▁( ▁int ▁) ▁( ▁1 e 9 ▁) ▁; ▁static ▁int ▁Minimum Length ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁A ▁) ▁; ▁int ▁suffix ▁[ ▁] ▁= ▁new ▁int ▁[ ▁N ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁N ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁suffix ▁[ ▁i ▁] ▁= ▁suffix ▁[ ▁i ▁+ ▁1 ▁] ▁+ ▁A ▁[ ▁i ▁] ▁; ▁int ▁dp ▁[ ▁] ▁[ ▁] ▁= ▁new ▁int ▁[ ▁N ▁+ ▁1 ▁] ▁[ ▁K ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁<= ▁K ▁; ▁j ▁++ ▁) ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁MAX ▁; ▁dp ▁[ ▁N ▁] ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁N ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁K ▁; ▁j ▁>= ▁0 ▁; ▁j ▁-- ▁) ▁{ ▁if ▁( ▁j ▁<= ▁A ▁[ ▁i ▁] ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁A ▁[ ▁i ▁] ▁; ▁continue ▁; ▁} ▁if ▁( ▁dp ▁[ ▁i ▁+ ▁1 ▁] ▁[ ▁j ▁- ▁A ▁[ ▁i ▁] ▁] ▁== ▁MAX ▁) ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁MAX ▁; ▁else ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁Math ▁. ▁min ▁( ▁dp ▁[ ▁i ▁+ ▁1 ▁] ▁[ ▁j ▁] ▁, ▁dp ▁[ ▁i ▁+ ▁1 ▁] ▁[ ▁j ▁- ▁A ▁[ ▁i ▁] ▁] ▁+ ▁A ▁[ ▁i ▁] ▁) ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁N ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁suffix ▁[ ▁i ▁] ▁- ▁dp ▁[ ▁i ▁] ▁[ ▁K ▁] ▁>= ▁K ▁) ▁{ ▁return ▁N ▁- ▁i ▁; ▁} ▁} ▁return ▁- ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁7 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁, ▁8 ▁} ▁; ▁int ▁K ▁= ▁13 ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁Minimum Length ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁float ▁[ ▁] ▁[ ▁] ▁dp ▁= ▁new ▁float ▁[ ▁105 ▁] ▁[ ▁60 5 ▁] ▁; ▁static ▁float ▁find ▁( ▁int ▁N ▁, ▁int ▁sum ▁) ▁{ ▁if ▁( ▁N ▁< ▁0 ▁sum ▁< ▁0 ▁) ▁return ▁0 ▁; ▁if ▁( ▁dp ▁[ ▁N ▁] ▁[ ▁sum ▁] ▁> ▁0 ▁) ▁return ▁dp ▁[ ▁N ▁] ▁[ ▁sum ▁] ▁; ▁if ▁( ▁sum ▁> ▁6 ▁* ▁N ▁sum ▁< ▁N ▁) ▁return ▁0 ▁; ▁if ▁( ▁N ▁== ▁1 ▁) ▁{ ▁if ▁( ▁sum ▁>= ▁1 ▁&& ▁sum ▁<= ▁6 ▁) ▁return ▁( ▁float ▁) ▁( ▁1.0 ▁/ ▁6 ▁) ▁; ▁else ▁return ▁0 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁6 ▁; ▁i ▁++ ▁) ▁dp ▁[ ▁N ▁] ▁[ ▁sum ▁] ▁= ▁dp ▁[ ▁N ▁] ▁[ ▁sum ▁] ▁+ ▁find ▁( ▁N ▁- ▁1 ▁, ▁sum ▁- ▁i ▁) ▁/ ▁6 ▁; ▁return ▁dp ▁[ ▁N ▁] ▁[ ▁sum ▁] ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁4 ▁, ▁a ▁= ▁13 ▁, ▁b ▁= ▁17 ▁; ▁float ▁probability ▁= ▁0.0 f ▁; ▁for ▁( ▁int ▁sum ▁= ▁a ▁; ▁sum ▁<= ▁b ▁; ▁sum ▁++ ▁) ▁probability ▁= ▁probability ▁+ ▁find ▁( ▁N ▁, ▁sum ▁) ▁; ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁% ▁. 6 f ▁" ▁, ▁probability ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁double ▁find Med X OR ▁( ▁int ▁mat ▁[ ▁] ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁M ▁) ▁{ ▁int ▁dp ▁[ ▁] ▁[ ▁] ▁= ▁new ▁int ▁[ ▁N ▁] ▁[ ▁M ▁] ▁; ▁int ▁med ▁[ ▁] ▁= ▁new ▁int ▁[ ▁N ▁* ▁M ▁] ▁; ▁dp ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁= ▁mat ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁; ▁med ▁[ ▁0 ▁] ▁= ▁dp ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁; ▁int ▁len ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁0 ▁] ▁^ ▁mat ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁; ▁med ▁[ ▁len ▁++ ▁] ▁= ▁dp ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁M ▁; ▁i ▁++ ▁) ▁{ ▁dp ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁= ▁dp ▁[ ▁0 ▁] ▁[ ▁i ▁- ▁1 ▁] ▁^ ▁mat ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁; ▁med ▁[ ▁len ▁++ ▁] ▁= ▁dp ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁< ▁M ▁; ▁j ▁++ ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁^ ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁^ ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁- ▁1 ▁] ▁^ ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁med ▁[ ▁len ▁++ ▁] ▁= ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁} ▁} ▁Arrays ▁. ▁sort ▁( ▁med ▁) ▁; ▁if ▁( ▁len ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁return ▁( ▁med ▁[ ▁( ▁len ▁/ ▁2 ▁) ▁] ▁+ ▁med ▁[ ▁( ▁len ▁/ ▁2 ▁) ▁- ▁1 ▁] ▁) ▁/ ▁2.0 ▁; ▁} ▁return ▁med ▁[ ▁len ▁/ ▁2 ▁] ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁mat ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁} ▁, ▁{ ▁2 ▁, ▁3 ▁} ▁} ▁; ▁int ▁N ▁= ▁mat ▁. ▁length ▁; ▁int ▁M ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Med X OR ▁( ▁mat ▁, ▁N ▁, ▁M ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁HashMap ▁< ▁String ▁, ▁Integer ▁> ▁dp ▁= ▁new ▁HashMap ▁< ▁String ▁, ▁Integer ▁> ▁( ▁) ▁; ▁static ▁int ▁check Equal Sum Util ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁sm 1 ▁, ▁int ▁sm 2 ▁, ▁int ▁sm 3 ▁, ▁int ▁j ▁) ▁{ ▁String ▁s ▁= ▁String ▁. ▁valueOf ▁( ▁sm 1 ▁) ▁+ ▁" ▁_ ▁" ▁+ ▁String ▁. ▁valueOf ▁( ▁sm 2 ▁) ▁+ ▁String ▁. ▁valueOf ▁( ▁j ▁) ▁; ▁if ▁( ▁j ▁== ▁N ▁) ▁{ ▁if ▁( ▁sm 1 ▁== ▁sm 2 ▁&& ▁sm 2 ▁== ▁sm 3 ▁) ▁return ▁1 ▁; ▁else ▁return ▁0 ▁; ▁} ▁if ▁( ▁dp ▁. ▁containsKey ▁( ▁s ▁) ▁) ▁return ▁dp ▁. ▁get ▁( ▁s ▁) ▁; ▁else ▁{ ▁int ▁l ▁= ▁check Equal Sum Util ▁( ▁arr ▁, ▁N ▁, ▁sm 1 ▁+ ▁arr ▁[ ▁j ▁] ▁, ▁sm 2 ▁, ▁sm 3 ▁, ▁j ▁+ ▁1 ▁) ▁; ▁int ▁m ▁= ▁check Equal Sum Util ▁( ▁arr ▁, ▁N ▁, ▁sm 1 ▁, ▁sm 2 ▁+ ▁arr ▁[ ▁j ▁] ▁, ▁sm 3 ▁, ▁j ▁+ ▁1 ▁) ▁; ▁int ▁r ▁= ▁check Equal Sum Util ▁( ▁arr ▁, ▁N ▁, ▁sm 1 ▁, ▁sm 2 ▁, ▁sm 3 ▁+ ▁arr ▁[ ▁j ▁] ▁, ▁j ▁+ ▁1 ▁) ▁; ▁dp ▁. ▁put ▁( ▁s ▁, ▁Math ▁. ▁max ▁( ▁Math ▁. ▁max ▁( ▁l ▁, ▁m ▁) ▁, ▁r ▁) ▁) ▁; ▁return ▁dp ▁. ▁get ▁( ▁s ▁) ▁; ▁} ▁} ▁static ▁void ▁check Equal Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁sum 1 ▁, ▁sum 2 ▁, ▁sum 3 ▁; ▁sum 1 ▁= ▁sum 2 ▁= ▁sum 3 ▁= ▁0 ▁; ▁if ▁( ▁check Equal Sum Util ▁( ▁arr ▁, ▁N ▁, ▁sum 1 ▁, ▁sum 2 ▁, ▁sum 3 ▁, ▁0 ▁) ▁== ▁1 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Yes ▁" ▁) ▁; ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁17 ▁, ▁34 ▁, ▁59 ▁, ▁23 ▁, ▁17 ▁, ▁67 ▁, ▁57 ▁, ▁2 ▁, ▁18 ▁, ▁59 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁check Equal Sum ▁( ▁arr ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁manipulation ▁( ▁int ▁[ ▁] ▁[ ▁] ▁matrix ▁, ▁int ▁[ ▁] ▁q ▁) ▁{ ▁int ▁x 1 ▁= ▁q ▁[ ▁0 ▁] ▁, ▁y 1 ▁= ▁q ▁[ ▁1 ▁] ▁, ▁x 2 ▁= ▁q ▁[ ▁2 ▁] ▁, ▁y 2 ▁= ▁q ▁[ ▁3 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁x 1 ▁- ▁1 ▁; ▁i ▁< ▁x 2 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁y 1 ▁- ▁1 ▁; ▁j ▁< ▁y 2 ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁matrix ▁[ ▁i ▁] ▁[ ▁j ▁] ▁== ▁1 ▁) ▁matrix ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁0 ▁; ▁else ▁matrix ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁1 ▁; ▁} ▁} ▁} ▁static ▁void ▁queries _ fx n ▁( ▁int ▁[ ▁] ▁[ ▁] ▁matrix ▁, ▁int ▁[ ▁] ▁[ ▁] ▁queries ▁) ▁{ ▁for ▁( ▁int ▁[ ▁] ▁q ▁: ▁queries ▁) ▁manipulation ▁( ▁matrix ▁, ▁q ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁[ ▁] ▁matrix ▁= ▁{ ▁{ ▁0 ▁, ▁1 ▁, ▁0 ▁} ▁, ▁{ ▁1 ▁, ▁1 ▁, ▁0 ▁} ▁} ▁; ▁int ▁[ ▁] ▁[ ▁] ▁queries ▁= ▁{ ▁{ ▁1 ▁, ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁, ▁{ ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁2 ▁, ▁2 ▁, ▁3 ▁} ▁} ▁; ▁queries _ fx n ▁( ▁matrix ▁, ▁queries ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁[ ▁" ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁matrix ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁[ ▁" ▁) ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁matrix ▁[ ▁i ▁] ▁. ▁length ▁; ▁j ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁matrix ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+ ▁" ▁" ▁) ▁; ▁if ▁( ▁i ▁== ▁matrix ▁. ▁length ▁- ▁1 ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁] ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁] ▁, ▁" ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁] ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁long ▁[ ▁] ▁fib ▁= ▁new ▁long ▁[ ▁101 ▁] ▁; ▁static ▁long ▁[ ▁] ▁dp 1 ▁= ▁new ▁long ▁[ ▁101 ▁] ▁; ▁static ▁long ▁[ ▁] ▁dp 2 ▁= ▁new ▁long ▁[ ▁101 ▁] ▁; ▁static ▁long ▁[ ▁] ▁v ▁= ▁new ▁long ▁[ ▁101 ▁] ▁; ▁static ▁void ▁fib onacci ▁( ▁) ▁{ ▁fib ▁[ ▁1 ▁] ▁= ▁1 ▁; ▁fib ▁[ ▁2 ▁] ▁= ▁2 ▁; ▁for ▁( ▁int ▁i ▁= ▁3 ▁; ▁i ▁<= ▁87 ▁; ▁i ▁++ ▁) ▁{ ▁fib ▁[ ▁i ▁] ▁= ▁fib ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁fib ▁[ ▁i ▁- ▁2 ▁] ▁; ▁} ▁} ▁static ▁long ▁find ▁( ▁int ▁num ▁) ▁{ ▁int ▁cnt ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁87 ▁; ▁i ▁> ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁num ▁>= ▁fib ▁[ ▁i ▁] ▁) ▁{ ▁v ▁[ ▁cnt ▁++ ▁] ▁= ▁i ▁; ▁num ▁-= ▁fib ▁[ ▁i ▁] ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁cnt ▁/ ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁long ▁t ▁= ▁v ▁[ ▁i ▁] ▁; ▁v ▁[ ▁i ▁] ▁= ▁v ▁[ ▁cnt ▁- ▁i ▁- ▁1 ▁] ▁; ▁v ▁[ ▁cnt ▁- ▁i ▁- ▁1 ▁] ▁= ▁t ▁; ▁} ▁dp 1 ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁dp 2 ▁[ ▁0 ▁] ▁= ▁( ▁v ▁[ ▁0 ▁] ▁- ▁1 ▁) ▁/ ▁2 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁cnt ▁; ▁i ▁++ ▁) ▁{ ▁dp 1 ▁[ ▁i ▁] ▁= ▁dp 1 ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁dp 2 ▁[ ▁i ▁- ▁1 ▁] ▁; ▁dp 2 ▁[ ▁i ▁] ▁= ▁( ▁( ▁v ▁[ ▁i ▁] ▁- ▁v ▁[ ▁i ▁- ▁1 ▁] ▁) ▁/ ▁2 ▁) ▁* ▁dp 2 ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁( ▁( ▁v ▁[ ▁i ▁] ▁- ▁v ▁[ ▁i ▁- ▁1 ▁] ▁- ▁1 ▁) ▁/ ▁2 ▁) ▁* ▁dp 1 ▁[ ▁i ▁- ▁1 ▁] ▁; ▁} ▁return ▁( ▁dp 1 ▁[ ▁cnt ▁- ▁1 ▁] ▁+ ▁dp 2 ▁[ ▁cnt ▁- ▁1 ▁] ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁fib onacci ▁( ▁) ▁; ▁int ▁num ▁= ▁13 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁find ▁( ▁num ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁public ▁static ▁void ▁count Num s ▁( ▁int ▁N ▁) ▁{ ▁int ▁l ▁= ▁( ▁int ▁) ▁Math ▁. ▁pow ▁( ▁10 ▁, ▁N ▁- ▁1 ▁) ▁, ▁r ▁= ▁( ▁int ▁) ▁Math ▁. ▁pow ▁( ▁10 ▁, ▁N ▁) ▁- ▁1 ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁l ▁; ▁i ▁<= ▁r ▁; ▁i ▁++ ▁) ▁{ ▁int ▁xor ▁= ▁0 ▁, ▁temp ▁= ▁i ▁; ▁while ▁( ▁temp ▁> ▁0 ▁) ▁{ ▁xor ▁= ▁xor ▁^ ▁( ▁temp ▁% ▁10 ▁) ▁; ▁temp ▁/= ▁10 ▁; ▁} ▁if ▁( ▁xor ▁<= ▁9 ▁) ▁count ▁++ ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁count ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁2 ▁; ▁count Num s ▁( ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁long ▁getCount ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁if ▁( ▁n ▁== ▁1 ▁) ▁return ▁10 ▁; ▁long ▁dp ▁[ ▁] ▁[ ▁] ▁= ▁new ▁long ▁[ ▁n ▁+ ▁1 ▁] ▁[ ▁11 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁9 ▁; ▁i ▁++ ▁) ▁dp ▁[ ▁1 ▁] ▁[ ▁i ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁<= ▁9 ▁; ▁j ▁++ ▁) ▁{ ▁int ▁l ▁= ▁Math ▁. ▁max ▁( ▁0 ▁, ▁j ▁- ▁k ▁) ▁; ▁int ▁r ▁= ▁Math ▁. ▁min ▁( ▁9 ▁, ▁j ▁+ ▁k ▁) ▁; ▁dp ▁[ ▁i ▁] ▁[ ▁l ▁] ▁+= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁; ▁dp ▁[ ▁i ▁] ▁[ ▁r ▁+ ▁1 ▁] ▁-= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁; ▁} ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁<= ▁9 ▁; ▁j ▁++ ▁) ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+= ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁; ▁} ▁long ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁9 ▁; ▁i ▁++ ▁) ▁count ▁+= ▁dp ▁[ ▁n ▁] ▁[ ▁i ▁] ▁; ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁2 ▁, ▁k ▁= ▁1 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁getCount ▁( ▁n ▁, ▁k ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁final ▁int ▁X ▁= ▁6 ▁; ▁static ▁final ▁int ▁Z ▁= ▁2 ▁; ▁static ▁boolean ▁exist Path ▁( ▁int ▁V ▁, ▁int ▁edges ▁[ ▁] ▁[ ▁] ▁, ▁int ▁u ▁, ▁int ▁v ▁) ▁{ ▁boolean ▁[ ▁] ▁[ ▁] ▁mat ▁= ▁new ▁boolean ▁[ ▁V ▁] ▁[ ▁V ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁X ▁; ▁i ▁++ ▁) ▁mat ▁[ ▁edges ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁] ▁[ ▁edges ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁] ▁= ▁true ▁; ▁for ▁( ▁int ▁k ▁= ▁0 ▁; ▁k ▁< ▁V ▁; ▁k ▁++ ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁V ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁V ▁; ▁j ▁++ ▁) ▁{ ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁|| ▁mat ▁[ ▁i ▁] ▁[ ▁k ▁] ▁&& ▁mat ▁[ ▁k ▁] ▁[ ▁j ▁] ▁; ▁} ▁} ▁} ▁if ▁( ▁u ▁>= ▁V ▁v ▁>= ▁V ▁) ▁{ ▁return ▁false ▁; ▁} ▁if ▁( ▁mat ▁[ ▁u ▁] ▁[ ▁v ▁] ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁V ▁= ▁4 ▁; ▁int ▁edges ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁0 ▁, ▁2 ▁} ▁, ▁{ ▁0 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁2 ▁} ▁, ▁{ ▁2 ▁, ▁3 ▁} ▁, ▁{ ▁2 ▁, ▁0 ▁} ▁, ▁{ ▁3 ▁, ▁3 ▁} ▁} ▁; ▁int ▁u ▁= ▁1 ▁, ▁v ▁= ▁3 ▁; ▁if ▁( ▁exist Path ▁( ▁V ▁, ▁edges ▁, ▁u ▁, ▁v ▁) ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" Yes NEW _ LINE "); ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" No NEW _ LINE "); ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁calculate _ maximum _ splits ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁pre ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁} ▁; ▁int ▁[ ▁] ▁dp ▁= ▁new ▁int ▁[ ▁N ▁] ▁; ▁Arrays ▁. ▁fill ▁( ▁dp ▁, ▁0 ▁) ▁; ▁int ▁C ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁C ▁= ▁C ▁+ ▁arr ▁[ ▁i ▁] ▁; ▁C ▁= ▁C ▁% ▁3 ▁; ▁if ▁( ▁pre ▁[ ▁C ▁] ▁== ▁- ▁1 ▁) ▁{ ▁if ▁( ▁1 ▁<= ▁i ▁) ▁dp ▁[ ▁i ▁] ▁= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁; ▁} ▁else ▁{ ▁dp ▁[ ▁i ▁] ▁= ▁Math ▁. ▁max ▁( ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁, ▁dp ▁[ ▁pre ▁[ ▁C ▁] ▁] ▁+ ▁1 ▁) ▁; ▁} ▁pre ▁[ ▁C ▁] ▁= ▁i ▁; ▁} ▁return ▁dp ▁[ ▁N ▁- ▁1 ▁] ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁36 ▁, ▁1 ▁, ▁9 ▁, ▁2 ▁, ▁0 ▁, ▁1 ▁, ▁8 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁calculate _ maximum _ splits ▁( ▁arr ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁pre compute ▁( ▁int ▁next pos ▁[ ▁] ▁, ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁next pos ▁[ ▁N ▁- ▁1 ▁] ▁= ▁N ▁; ▁for ▁( ▁int ▁i ▁= ▁N ▁- ▁2 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁arr ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁next pos ▁[ ▁i ▁] ▁= ▁next pos ▁[ ▁i ▁+ ▁1 ▁] ▁; ▁else ▁next pos ▁[ ▁i ▁] ▁= ▁i ▁+ ▁1 ▁; ▁} ▁} ▁static ▁void ▁find Index ▁( ▁int ▁query ▁[ ▁] ▁[ ▁] ▁, ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁Q ▁) ▁{ ▁int ▁[ ▁] ▁next pos ▁= ▁new ▁int ▁[ ▁N ▁] ▁; ▁pre compute ▁( ▁next pos ▁, ▁arr ▁, ▁N ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁Q ▁; ▁i ▁++ ▁) ▁{ ▁int ▁l ▁, ▁r ▁, ▁x ▁; ▁l ▁= ▁query ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁; ▁r ▁= ▁query ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁; ▁x ▁= ▁query ▁[ ▁i ▁] ▁[ ▁2 ▁] ▁; ▁int ▁ans ▁= ▁- ▁1 ▁; ▁if ▁( ▁arr ▁[ ▁l ▁] ▁!= ▁x ▁) ▁ans ▁= ▁l ▁; ▁else ▁{ ▁int ▁d ▁= ▁next pos ▁[ ▁l ▁] ▁; ▁if ▁( ▁d ▁<= ▁r ▁) ▁ans ▁= ▁d ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁ans ▁+ ▁" NEW _ LINE "); ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁, ▁Q ▁; ▁N ▁= ▁6 ▁; ▁Q ▁= ▁3 ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁1 ▁, ▁1 ▁, ▁3 ▁, ▁5 ▁} ▁; ▁int ▁query ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁0 ▁, ▁3 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁5 ▁, ▁2 ▁} ▁, ▁{ ▁2 ▁, ▁3 ▁, ▁1 ▁} ▁} ▁; ▁find Index ▁( ▁query ▁, ▁arr ▁, ▁N ▁, ▁Q ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁two Strings Equality ▁( ▁String ▁s ▁, ▁String ▁t ▁) ▁{ ▁int ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁int ▁[ ▁] ▁[ ▁] ▁dp ▁= ▁new ▁int ▁[ ▁n ▁] ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁if ▁( ▁s ▁. ▁charAt ▁( ▁n ▁- ▁1 ▁) ▁== ▁t ▁. ▁charAt ▁( ▁0 ▁) ▁) ▁dp ▁[ ▁n ▁- ▁1 ▁] ▁[ ▁1 ▁] ▁= ▁1 ▁; ▁if ▁( ▁s ▁. ▁charAt ▁( ▁n ▁- ▁1 ▁) ▁== ▁t ▁. ▁charAt ▁( ▁n ▁- ▁1 ▁) ▁) ▁dp ▁[ ▁n ▁- ▁1 ▁] ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁> ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁<= ▁n ▁- ▁i ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁> ▁0 ▁) ▁{ ▁if ▁( ▁s ▁. ▁charAt ▁( ▁i ▁- ▁1 ▁) ▁== ▁t ▁. ▁charAt ▁( ▁j ▁) ▁) ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁+ ▁1 ▁] ▁= ▁1 ▁; ▁if ▁( ▁s ▁. ▁charAt ▁( ▁i ▁- ▁1 ▁) ▁== ▁t ▁. ▁charAt ▁( ▁i ▁+ ▁j ▁- ▁1 ▁) ▁) ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁= ▁1 ▁; ▁} ▁} ▁} ▁boolean ▁ans ▁= ▁false ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁dp ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁== ▁1 ▁) ▁{ ▁ans ▁= ▁true ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁ans ▁== ▁true ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Yes ▁" ▁+ ▁" NEW _ LINE "); ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁No ▁" ▁+ ▁" NEW _ LINE "); ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁S ▁= ▁" ▁ab ab ▁" ▁; ▁String ▁T ▁= ▁" ▁ba ab ▁" ▁; ▁two Strings Equality ▁( ▁S ▁, ▁T ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁square Of Zero es ▁( ▁int ▁[ ▁] ▁[ ▁] ▁matrix ▁) ▁{ ▁int ▁last Idx ▁= ▁matrix ▁. ▁length ▁- ▁1 ▁; ▁Map ▁< ▁String ▁, ▁Boolean ▁> ▁cache ▁= ▁new ▁HashMap ▁< ▁String ▁, ▁Boolean ▁> ▁( ▁) ▁; ▁return ▁( ▁has Square Of Zero es ▁( ▁matrix ▁, ▁0 ▁, ▁0 ▁, ▁last Idx ▁, ▁last Idx ▁, ▁cache ▁) ▁) ▁? ▁1 ▁: ▁0 ▁; ▁} ▁static ▁boolean ▁has Square Of Zero es ▁( ▁int ▁[ ▁] ▁[ ▁] ▁matrix ▁, ▁int ▁r 1 ▁, ▁int ▁c 1 ▁, ▁int ▁r 2 ▁, ▁int ▁c 2 ▁, ▁Map ▁< ▁String ▁, ▁Boolean ▁> ▁cache ▁) ▁{ ▁if ▁( ▁r 1 ▁>= ▁r 2 ▁c 1 ▁>= ▁c 2 ▁) ▁return ▁false ▁; ▁String ▁key ▁= ▁r 1 ▁+ ▁" ▁- ▁" ▁+ ▁c 1 ▁+ ▁" ▁- ▁" ▁+ ▁r 2 ▁+ ▁" ▁- ▁" ▁+ ▁c 2 ▁; ▁if ▁( ▁cache ▁. ▁containsKey ▁( ▁key ▁) ▁) ▁return ▁cache ▁. ▁get ▁( ▁key ▁) ▁; ▁cache ▁. ▁put ▁( ▁key ▁, ▁is Square Of Zero es ▁( ▁matrix ▁, ▁r 1 ▁, ▁c 1 ▁, ▁r 2 ▁, ▁c 2 ▁) ▁|| ▁has Square Of Zero es ▁( ▁matrix ▁, ▁r 1 ▁+ ▁1 ▁, ▁c 1 ▁+ ▁1 ▁, ▁r 2 ▁- ▁1 ▁, ▁c 2 ▁- ▁1 ▁, ▁cache ▁) ▁|| ▁has Square Of Zero es ▁( ▁matrix ▁, ▁r 1 ▁, ▁c 1 ▁+ ▁1 ▁, ▁r 2 ▁- ▁1 ▁, ▁c 2 ▁, ▁cache ▁) ▁|| ▁has Square Of Zero es ▁( ▁matrix ▁, ▁r 1 ▁+ ▁1 ▁, ▁c 1 ▁, ▁r 2 ▁, ▁c 2 ▁- ▁1 ▁, ▁cache ▁) ▁|| ▁has Square Of Zero es ▁( ▁matrix ▁, ▁r 1 ▁+ ▁1 ▁, ▁c 1 ▁+ ▁1 ▁, ▁r 2 ▁, ▁c 2 ▁, ▁cache ▁) ▁|| ▁has Square Of Zero es ▁( ▁matrix ▁, ▁r 1 ▁, ▁c 1 ▁, ▁r 2 ▁- ▁1 ▁, ▁c 2 ▁- ▁1 ▁, ▁cache ▁) ▁) ▁; ▁return ▁cache ▁. ▁get ▁( ▁key ▁) ▁; ▁} ▁static ▁boolean ▁is Square Of Zero es ▁( ▁int ▁[ ▁] ▁[ ▁] ▁matrix ▁, ▁int ▁r 1 ▁, ▁int ▁c 1 ▁, ▁int ▁r 2 ▁, ▁int ▁c 2 ▁) ▁{ ▁for ▁( ▁int ▁row ▁= ▁r 1 ▁; ▁row ▁< ▁r 2 ▁+ ▁1 ▁; ▁row ▁++ ▁) ▁{ ▁if ▁( ▁matrix ▁[ ▁row ▁] ▁[ ▁c 1 ▁] ▁!= ▁0 ▁matrix ▁[ ▁row ▁] ▁[ ▁c 2 ▁] ▁!= ▁0 ▁) ▁return ▁false ▁; ▁} ▁for ▁( ▁int ▁col ▁= ▁c 1 ▁; ▁col ▁< ▁c 2 ▁+ ▁1 ▁; ▁col ▁++ ▁) ▁{ ▁if ▁( ▁matrix ▁[ ▁r 1 ▁] ▁[ ▁col ▁] ▁!= ▁0 ▁matrix ▁[ ▁r 2 ▁] ▁[ ▁col ▁] ▁!= ▁0 ▁) ▁return ▁false ▁; ▁} ▁return ▁true ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁[ ▁] ▁matrix ▁= ▁{ ▁{ ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁} ▁, ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁} ▁, ▁{ ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁} ▁, ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁} ▁, ▁{ ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁} ▁, ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁} ▁} ▁; ▁int ▁ans ▁; ▁ans ▁= ▁square Of Zero es ▁( ▁matrix ▁) ▁; ▁if ▁( ▁ans ▁== ▁1 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁True ▁" ▁) ▁; ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁False ▁" ▁) ▁; ▁} ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁can Make Pal i Queries ▁( ▁String ▁str ▁, ▁int ▁[ ▁] ▁[ ▁] ▁Q ▁) ▁{ ▁int ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁int ▁[ ▁] ▁[ ▁] ▁dp ▁= ▁new ▁int ▁[ ▁26 ▁] ▁[ ▁n ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁26 ▁; ▁i ▁++ ▁) ▁{ ▁char ▁current Char ▁= ▁( ▁char ▁) ▁( ▁i ▁+ ▁' ▁a ▁' ▁) ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁j ▁== ▁0 ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁( ▁str ▁. ▁charAt ▁( ▁j ▁) ▁== ▁current Char ▁) ▁? ▁1 ▁: ▁0 ▁; ▁} ▁else ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁+ ▁( ▁( ▁str ▁. ▁charAt ▁( ▁j ▁) ▁== ▁current Char ▁) ▁? ▁1 ▁: ▁0 ▁) ▁; ▁} ▁} ▁} ▁for ▁( ▁int ▁[ ▁] ▁query ▁: ▁Q ▁) ▁{ ▁int ▁left ▁= ▁query ▁[ ▁0 ▁] ▁; ▁int ▁right ▁= ▁query ▁[ ▁1 ▁] ▁; ▁int ▁k ▁= ▁query ▁[ ▁2 ▁] ▁; ▁int ▁un Matched Count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁26 ▁; ▁i ▁++ ▁) ▁{ ▁int ▁occurrence ▁= ▁dp ▁[ ▁i ▁] ▁[ ▁right ▁] ▁- ▁dp ▁[ ▁i ▁] ▁[ ▁left ▁] ▁+ ▁( ▁str ▁. ▁charAt ▁( ▁left ▁) ▁== ▁( ▁i ▁+ ▁' ▁a ▁' ▁) ▁? ▁1 ▁: ▁0 ▁) ▁; ▁if ▁( ▁occurrence ▁% ▁2 ▁== ▁1 ▁) ▁un Matched Count ▁++ ▁; ▁} ▁int ▁ans ▁= ▁un Matched Count ▁/ ▁2 ▁; ▁if ▁( ▁ans ▁<= ▁k ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" YES NEW _ LINE "); ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" NO NEW _ LINE "); ▁} ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁" ▁G eek s for G eek s ▁" ▁; ▁int ▁[ ▁] ▁[ ▁] ▁Q ▁= ▁{ ▁{ ▁1 ▁, ▁5 ▁, ▁3 ▁} ▁, ▁{ ▁5 ▁, ▁7 ▁, ▁0 ▁} ▁, ▁{ ▁8 ▁, ▁11 ▁, ▁3 ▁} ▁, ▁{ ▁3 ▁, ▁10 ▁, ▁5 ▁} ▁, ▁{ ▁0 ▁, ▁9 ▁, ▁5 ▁} ▁} ▁; ▁can Make Pal i Queries ▁( ▁str ▁, ▁Q ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁Maximum Sum ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁[ ▁] ▁[ ▁] ▁dp ▁= ▁new ▁int ▁[ ▁n ▁+ ▁1 ▁] ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁+ ▁1 ▁; ▁j ▁++ ▁) ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁Integer ▁. ▁MIN _ VALUE ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁dp ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁<= ▁i ▁; ▁j ▁++ ▁) ▁{ ▁int ▁val ▁= ▁Integer ▁. ▁MIN _ VALUE ▁; ▁if ▁( ▁( ▁i ▁- ▁2 ▁>= ▁0 ▁&& ▁dp ▁[ ▁i ▁- ▁2 ▁] ▁[ ▁j ▁- ▁1 ▁] ▁!= ▁Integer ▁. ▁MIN _ VALUE ▁) ▁i ▁- ▁2 ▁< ▁0 ▁) ▁{ ▁val ▁= ▁a ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁( ▁i ▁- ▁2 ▁>= ▁0 ▁? ▁dp ▁[ ▁i ▁- ▁2 ▁] ▁[ ▁j ▁- ▁1 ▁] ▁: ▁0 ▁) ▁; ▁} ▁if ▁( ▁i ▁- ▁1 ▁>= ▁j ▁) ▁{ ▁val ▁= ▁Math ▁. ▁max ▁( ▁val ▁, ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁) ▁; ▁} ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁val ▁; ▁} ▁} ▁return ▁dp ▁[ ▁n ▁] ▁[ ▁n ▁/ ▁2 ▁] ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁int ▁N ▁= ▁A ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁Maximum Sum ▁( ▁A ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁[ ▁] ▁[ ▁] ▁[ ▁] ▁dp ▁= ▁new ▁int ▁[ ▁500 ▁] ▁[ ▁500 ▁] ▁[ ▁500 ▁] ▁; ▁static ▁int ▁calculate ▁( ▁int ▁pos ▁, ▁int ▁prev ▁, ▁int ▁left ▁, ▁int ▁k ▁) ▁{ ▁if ▁( ▁pos ▁== ▁k ▁) ▁{ ▁if ▁( ▁left ▁== ▁0 ▁) ▁return ▁1 ▁; ▁else ▁return ▁0 ▁; ▁} ▁if ▁( ▁left ▁== ▁0 ▁) ▁return ▁0 ▁; ▁if ▁( ▁dp ▁[ ▁pos ▁] ▁[ ▁prev ▁] ▁[ ▁left ▁] ▁!= ▁- ▁1 ▁) ▁return ▁dp ▁[ ▁pos ▁] ▁[ ▁prev ▁] ▁[ ▁left ▁] ▁; ▁int ▁answer ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁prev ▁; ▁i ▁<= ▁left ▁; ▁i ▁++ ▁) ▁{ ▁answer ▁+= ▁calculate ▁( ▁pos ▁+ ▁1 ▁, ▁i ▁, ▁left ▁- ▁i ▁, ▁k ▁) ▁; ▁} ▁return ▁dp ▁[ ▁pos ▁] ▁[ ▁prev ▁] ▁[ ▁left ▁] ▁= ▁answer ▁; ▁} ▁static ▁int ▁count Way sto Div ide ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁500 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁500 ▁; ▁j ▁++ ▁) ▁{ ▁for ▁( ▁int ▁l ▁= ▁0 ▁; ▁l ▁< ▁500 ▁; ▁l ▁++ ▁) ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁[ ▁l ▁] ▁= ▁- ▁1 ▁; ▁} ▁} ▁return ▁calculate ▁( ▁0 ▁, ▁1 ▁, ▁n ▁, ▁k ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁8 ▁; ▁int ▁K ▁= ▁4 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁count Way sto Div ide ▁( ▁N ▁, ▁K ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁MAX ▁= ▁100000 ▁; ▁static ▁int ▁[ ▁] ▁div is ors ▁= ▁new ▁int ▁[ ▁MAX ▁] ▁; ▁static ▁void ▁generate Div is ors ▁( ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁Math ▁. ▁sqrt ▁( ▁n ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁{ ▁if ▁( ▁n ▁/ ▁i ▁== ▁i ▁) ▁{ ▁div is ors ▁[ ▁i ▁] ▁++ ▁; ▁} ▁else ▁{ ▁div is ors ▁[ ▁i ▁] ▁++ ▁; ▁div is ors ▁[ ▁n ▁/ ▁i ▁] ▁++ ▁; ▁} ▁} ▁} ▁} ▁static ▁int ▁find Max Multi ples ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁n ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁ans ▁= ▁Math ▁. ▁max ▁( ▁div is ors ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁, ▁ans ▁) ▁; ▁generate Div is ors ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁8 ▁, ▁1 ▁, ▁28 ▁, ▁4 ▁, ▁2 ▁, ▁6 ▁, ▁7 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁find Max Multi ples ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁egg Drop ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁dp ▁[ ▁] ▁[ ▁] ▁= ▁new ▁int ▁[ ▁k ▁+ ▁1 ▁] ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁int ▁x ▁= ▁0 ▁; ▁while ▁( ▁dp ▁[ ▁x ▁] ▁[ ▁n ▁] ▁< ▁k ▁) ▁{ ▁x ▁++ ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁dp ▁[ ▁x ▁] ▁[ ▁i ▁] ▁= ▁dp ▁[ ▁x ▁- ▁1 ▁] ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁dp ▁[ ▁x ▁- ▁1 ▁] ▁[ ▁i ▁] ▁+ ▁1 ▁; ▁} ▁return ▁x ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁2 ▁, ▁k ▁= ▁36 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁egg Drop ▁( ▁n ▁, ▁k ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁final ▁static ▁int ▁n ▁= ▁3 ▁; ▁final ▁static ▁int ▁m ▁= ▁3 ▁; ▁static ▁int ▁count Square Mat rices ▁( ▁int ▁a ▁[ ▁] ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁M ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁< ▁M ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁[ ▁j ▁] ▁== ▁0 ▁) ▁continue ▁; ▁a ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁Math ▁. ▁min ▁( ▁Math ▁. ▁min ▁( ▁a ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁, ▁a ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁) ▁, ▁a ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁- ▁1 ▁] ▁) ▁+ ▁1 ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁M ▁; ▁j ▁++ ▁) ▁count ▁+= ▁a ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁0 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁1 ▁, ▁0 ▁} ▁, ▁{ ▁1 ▁, ▁1 ▁, ▁0 ▁} ▁} ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Square Mat rices ▁( ▁arr ▁, ▁n ▁, ▁m ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁final ▁int ▁V _ SUM _ MAX ▁= ▁1000 ▁; ▁static ▁final ▁int ▁N _ MAX ▁= ▁100 ▁; ▁static ▁final ▁int ▁W _ MAX ▁= ▁10000 000 ▁; ▁static ▁int ▁dp ▁[ ▁] ▁[ ▁] ▁= ▁new ▁int ▁[ ▁V _ SUM _ MAX ▁+ ▁1 ▁] ▁[ ▁N _ MAX ▁] ▁; ▁static ▁boolean ▁v ▁[ ▁] ▁[ ▁] ▁= ▁new ▁boolean ▁[ ▁V _ SUM _ MAX ▁+ ▁1 ▁] ▁[ ▁N _ MAX ▁] ▁; ▁static ▁int ▁solve D p ▁( ▁int ▁r ▁, ▁int ▁i ▁, ▁int ▁w ▁[ ▁] ▁, ▁int ▁val ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁r ▁<= ▁0 ▁) ▁return ▁0 ▁; ▁if ▁( ▁i ▁== ▁n ▁) ▁return ▁W _ MAX ▁; ▁if ▁( ▁v ▁[ ▁r ▁] ▁[ ▁i ▁] ▁) ▁return ▁dp ▁[ ▁r ▁] ▁[ ▁i ▁] ▁; ▁v ▁[ ▁r ▁] ▁[ ▁i ▁] ▁= ▁true ▁; ▁dp ▁[ ▁r ▁] ▁[ ▁i ▁] ▁= ▁Math ▁. ▁min ▁( ▁solve D p ▁( ▁r ▁, ▁i ▁+ ▁1 ▁, ▁w ▁, ▁val ▁, ▁n ▁) ▁, ▁w ▁[ ▁i ▁] ▁+ ▁solve D p ▁( ▁r ▁- ▁val ▁[ ▁i ▁] ▁, ▁i ▁+ ▁1 ▁, ▁w ▁, ▁val ▁, ▁n ▁) ▁) ▁; ▁return ▁dp ▁[ ▁r ▁] ▁[ ▁i ▁] ▁; ▁} ▁static ▁int ▁max Weight ▁( ▁int ▁w ▁[ ▁] ▁, ▁int ▁val ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁c ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁V _ SUM _ MAX ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁solve D p ▁( ▁i ▁, ▁0 ▁, ▁w ▁, ▁val ▁, ▁n ▁) ▁<= ▁c ▁) ▁{ ▁return ▁i ▁; ▁} ▁} ▁return ▁0 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁w ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁val ▁[ ▁] ▁= ▁{ ▁30 ▁, ▁50 ▁, ▁60 ▁} ▁; ▁int ▁n ▁= ▁w ▁. ▁length ▁; ▁int ▁C ▁= ▁8 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁max Weight ▁( ▁w ▁, ▁val ▁, ▁n ▁, ▁C ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁max N ▁= ▁20 ▁; ▁static ▁int ▁max M ▁= ▁64 ▁; ▁static ▁int ▁[ ▁] ▁[ ▁] ▁dp 1 ▁= ▁new ▁int ▁[ ▁max N ▁] ▁[ ▁max M ▁] ▁; ▁static ▁boolean ▁[ ▁] ▁[ ▁] ▁v 1 ▁= ▁new ▁boolean ▁[ ▁max N ▁] ▁[ ▁max M ▁] ▁; ▁static ▁int ▁find Cnt ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁i ▁, ▁int ▁curr ▁, ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁if ▁( ▁i ▁== ▁n ▁) ▁{ ▁return ▁( ▁curr ▁== ▁m ▁? ▁1 ▁: ▁0 ▁) ▁; ▁} ▁if ▁( ▁v 1 ▁[ ▁i ▁] ▁[ ▁curr ▁] ▁) ▁return ▁dp 1 ▁[ ▁i ▁] ▁[ ▁curr ▁] ▁; ▁v 1 ▁[ ▁i ▁] ▁[ ▁curr ▁] ▁= ▁true ▁; ▁dp 1 ▁[ ▁i ▁] ▁[ ▁curr ▁] ▁= ▁find Cnt ▁( ▁arr ▁, ▁i ▁+ ▁1 ▁, ▁curr ▁, ▁n ▁, ▁m ▁) ▁+ ▁find Cnt ▁( ▁arr ▁, ▁i ▁+ ▁1 ▁, ▁( ▁curr ▁& ▁arr ▁[ ▁i ▁] ▁) ▁, ▁n ▁, ▁m ▁) ▁; ▁return ▁dp 1 ▁[ ▁i ▁] ▁[ ▁curr ▁] ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁int ▁m ▁= ▁0 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Cnt ▁( ▁arr ▁, ▁0 ▁, ▁( ▁( ▁1 ▁<< ▁6 ▁) ▁- ▁1 ▁) ▁, ▁n ▁, ▁m ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁mod ▁= ▁100 000000 7 ▁; ▁static ▁int ▁[ ▁] ▁[ ▁] ▁dp ▁= ▁new ▁int ▁[ ▁55 ▁] ▁[ ▁55 ▁] ▁; ▁static ▁int ▁N oof W ays ▁( ▁int ▁face ▁, ▁int ▁throws Val ▁, ▁int ▁sum ▁) ▁{ ▁if ▁( ▁sum ▁== ▁0 ▁&& ▁throws Val ▁== ▁0 ▁) ▁{ ▁return ▁1 ▁; ▁} ▁if ▁( ▁sum ▁< ▁0 ▁throws Val ▁== ▁0 ▁) ▁{ ▁return ▁0 ▁; ▁} ▁if ▁( ▁dp ▁[ ▁throws Val ▁] ▁[ ▁sum ▁] ▁!= ▁- ▁1 ▁) ▁{ ▁return ▁dp ▁[ ▁throws Val ▁] ▁[ ▁sum ▁] ▁; ▁} ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁face ▁; ▁i ▁++ ▁) ▁{ ▁ans ▁+= ▁N oof W ays ▁( ▁face ▁, ▁throws Val ▁- ▁1 ▁, ▁sum ▁- ▁i ▁) ▁; ▁} ▁return ▁dp ▁[ ▁throws Val ▁] ▁[ ▁sum ▁] ▁= ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁faces ▁= ▁6 ▁, ▁throws Val ▁= ▁3 ▁, ▁sum ▁= ▁12 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁55 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁55 ▁; ▁j ▁++ ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁- ▁1 ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁N oof W ays ▁( ▁faces ▁, ▁throws Val ▁, ▁sum ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁final ▁static ▁int ▁bits count ▁= ▁32 ▁; ▁final ▁static ▁int ▁n ▁= ▁3 ▁; ▁static ▁int ▁prefix _ count ▁[ ▁] ▁[ ▁] ▁[ ▁] ▁= ▁new ▁int ▁[ ▁bits count ▁] ▁[ ▁n ▁] ▁[ ▁n ▁] ▁; ▁static ▁void ▁find Prefix Count ▁( ▁int ▁arr ▁[ ▁] ▁[ ▁] ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁bits count ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁prefix _ count ▁[ ▁i ▁] ▁[ ▁j ▁] ▁[ ▁0 ▁] ▁= ▁( ▁( ▁arr ▁[ ▁j ▁] ▁[ ▁0 ▁] ▁>> ▁i ▁) ▁& ▁1 ▁) ▁; ▁for ▁( ▁int ▁k ▁= ▁1 ▁; ▁k ▁< ▁n ▁; ▁k ▁++ ▁) ▁{ ▁prefix _ count ▁[ ▁i ▁] ▁[ ▁j ▁] ▁[ ▁k ▁] ▁= ▁( ▁( ▁arr ▁[ ▁j ▁] ▁[ ▁k ▁] ▁>> ▁i ▁) ▁& ▁1 ▁) ▁; ▁prefix _ count ▁[ ▁i ▁] ▁[ ▁j ▁] ▁[ ▁k ▁] ▁+= ▁prefix _ count ▁[ ▁i ▁] ▁[ ▁j ▁] ▁[ ▁k ▁- ▁1 ▁] ▁; ▁} ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁bits count ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁for ▁( ▁int ▁k ▁= ▁0 ▁; ▁k ▁< ▁n ▁; ▁k ▁++ ▁) ▁prefix _ count ▁[ ▁i ▁] ▁[ ▁j ▁] ▁[ ▁k ▁] ▁+= ▁prefix _ count ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁[ ▁k ▁] ▁; ▁} ▁static ▁int ▁range And ▁( ▁int ▁x 1 ▁, ▁int ▁y 1 ▁, ▁int ▁x 2 ▁, ▁int ▁y 2 ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁bits count ▁; ▁i ▁++ ▁) ▁{ ▁int ▁p ▁; ▁if ▁( ▁x 1 ▁== ▁0 ▁&& ▁y 1 ▁== ▁0 ▁) ▁p ▁= ▁prefix _ count ▁[ ▁i ▁] ▁[ ▁x 2 ▁] ▁[ ▁y 2 ▁] ▁; ▁else ▁if ▁( ▁x 1 ▁== ▁0 ▁) ▁p ▁= ▁prefix _ count ▁[ ▁i ▁] ▁[ ▁x 2 ▁] ▁[ ▁y 2 ▁] ▁- ▁prefix _ count ▁[ ▁i ▁] ▁[ ▁x 2 ▁] ▁[ ▁y 1 ▁- ▁1 ▁] ▁; ▁else ▁if ▁( ▁y 1 ▁== ▁0 ▁) ▁p ▁= ▁prefix _ count ▁[ ▁i ▁] ▁[ ▁x 2 ▁] ▁[ ▁y 2 ▁] ▁- ▁prefix _ count ▁[ ▁i ▁] ▁[ ▁x 1 ▁- ▁1 ▁] ▁[ ▁y 2 ▁] ▁; ▁else ▁p ▁= ▁prefix _ count ▁[ ▁i ▁] ▁[ ▁x 2 ▁] ▁[ ▁y 2 ▁] ▁- ▁prefix _ count ▁[ ▁i ▁] ▁[ ▁x 1 ▁- ▁1 ▁] ▁[ ▁y 2 ▁] ▁- ▁prefix _ count ▁[ ▁i ▁] ▁[ ▁x 2 ▁] ▁[ ▁y 1 ▁- ▁1 ▁] ▁+ ▁prefix _ count ▁[ ▁i ▁] ▁[ ▁x 1 ▁- ▁1 ▁] ▁[ ▁y 1 ▁- ▁1 ▁] ▁; ▁if ▁( ▁p ▁== ▁( ▁x 2 ▁- ▁x 1 ▁+ ▁1 ▁) ▁* ▁( ▁y 2 ▁- ▁y 1 ▁+ ▁1 ▁) ▁) ▁ans ▁= ▁( ▁ans ▁| ▁( ▁1 ▁<< ▁i ▁) ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁, ▁{ ▁4 ▁, ▁5 ▁, ▁6 ▁} ▁, ▁{ ▁7 ▁, ▁8 ▁, ▁9 ▁} ▁} ▁; ▁find Prefix Count ▁( ▁arr ▁) ▁; ▁int ▁queries ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁2 ▁, ▁2 ▁, ▁2 ▁} ▁} ▁; ▁int ▁q ▁= ▁queries ▁. ▁length ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁q ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁range And ▁( ▁queries ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁, ▁queries ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁, ▁queries ▁[ ▁i ▁] ▁[ ▁2 ▁] ▁, ▁queries ▁[ ▁i ▁] ▁[ ▁3 ▁] ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁n ▁; ▁static ▁int ▁solve ▁( ▁int ▁i ▁, ▁int ▁x ▁, ▁int ▁dp ▁[ ▁] ▁[ ▁] ▁) ▁{ ▁if ▁( ▁i ▁< ▁0 ▁) ▁{ ▁return ▁x ▁== ▁3 ▁? ▁1 ▁: ▁0 ▁; ▁} ▁if ▁( ▁dp ▁[ ▁i ▁] ▁[ ▁x ▁] ▁!= ▁- ▁1 ▁) ▁{ ▁return ▁dp ▁[ ▁i ▁] ▁[ ▁x ▁] ▁; ▁} ▁dp ▁[ ▁i ▁] ▁[ ▁x ▁] ▁= ▁solve ▁( ▁i ▁- ▁1 ▁, ▁0 ▁, ▁dp ▁) ▁; ▁dp ▁[ ▁i ▁] ▁[ ▁x ▁] ▁+= ▁solve ▁( ▁i ▁- ▁1 ▁, ▁x ▁+ ▁1 ▁, ▁dp ▁) ▁; ▁return ▁dp ▁[ ▁i ▁] ▁[ ▁x ▁] ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁n ▁= ▁4 ▁; ▁int ▁dp ▁[ ▁] ▁[ ▁] ▁= ▁new ▁int ▁[ ▁n ▁] ▁[ ▁4 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁4 ▁; ▁j ▁++ ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁- ▁1 ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁3 ▁] ▁= ▁( ▁1 ▁<< ▁( ▁i ▁+ ▁1 ▁) ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁solve ▁( ▁n ▁- ▁1 ▁, ▁0 ▁, ▁dp ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁max Sub Array Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁size ▁) ▁{ ▁int ▁max _ so _ far ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁int ▁curr _ max ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁{ ▁curr _ max ▁= ▁Math ▁. ▁max ▁( ▁arr ▁[ ▁i ▁] ▁, ▁curr _ max ▁+ ▁arr ▁[ ▁i ▁] ▁) ▁; ▁max _ so _ far ▁= ▁Math ▁. ▁max ▁( ▁max _ so _ far ▁, ▁curr _ max ▁) ▁; ▁} ▁return ▁max _ so _ far ▁; ▁} ▁static ▁int ▁len Of Long Sub arr With Given Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁um ▁= ▁new ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁( ▁) ▁; ▁int ▁sum ▁= ▁0 ▁, ▁max Len ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁if ▁( ▁sum ▁== ▁k ▁) ▁max Len ▁= ▁i ▁+ ▁1 ▁; ▁if ▁( ▁um ▁. ▁containsKey ▁( ▁sum ▁) ▁) ▁um ▁. ▁put ▁( ▁sum ▁, ▁i ▁) ▁; ▁if ▁( ▁um ▁. ▁containsKey ▁( ▁sum ▁- ▁k ▁) ▁) ▁{ ▁if ▁( ▁max Len ▁< ▁( ▁i ▁- ▁um ▁. ▁get ▁( ▁sum ▁- ▁k ▁) ▁) ▁) ▁max Len ▁= ▁i ▁- ▁um ▁. ▁get ▁( ▁sum ▁- ▁k ▁) ▁; ▁} ▁} ▁return ▁max Len ▁; ▁} ▁static ▁int ▁len Long Sub arr With Max Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁max Sum ▁= ▁max Sub Array Sum ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁len Of Long Sub arr With Given Sum ▁( ▁arr ▁, ▁n ▁, ▁max Sum ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁- ▁2 ▁, ▁- ▁1 ▁, ▁3 ▁, ▁- ▁4 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Length ▁of ▁longest ▁sub array ▁" ▁+ ▁" ▁having ▁maximum ▁sum ▁= ▁" ▁+ ▁len Long Sub arr With Max Sum ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁class ▁data ▁{ ▁int ▁element ▁; ▁int ▁position ▁; ▁} ▁; ▁static ▁data ▁find Min Element ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁data ▁result ▁= ▁new ▁data ▁( ▁) ▁; ▁int ▁[ ▁] ▁prefix Sum ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁int ▁[ ▁] ▁suffix Sum ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁prefix Sum ▁[ ▁0 ▁] ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁prefix Sum ▁[ ▁i ▁] ▁= ▁prefix Sum ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁arr ▁[ ▁i ▁] ▁; ▁} ▁suffix Sum ▁[ ▁n ▁- ▁1 ▁] ▁= ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁2 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁suffix Sum ▁[ ▁i ▁] ▁= ▁suffix Sum ▁[ ▁i ▁+ ▁1 ▁] ▁+ ▁arr ▁[ ▁i ▁] ▁; ▁} ▁int ▁min ▁= ▁suffix Sum ▁[ ▁0 ▁] ▁; ▁int ▁pos ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁Math ▁. ▁abs ▁( ▁suffix Sum ▁[ ▁i ▁+ ▁1 ▁] ▁- ▁prefix Sum ▁[ ▁i ▁] ▁) ▁< ▁min ▁) ▁{ ▁min ▁= ▁Math ▁. ▁abs ▁( ▁suffix Sum ▁[ ▁i ▁+ ▁1 ▁] ▁- ▁prefix Sum ▁[ ▁i ▁] ▁) ▁; ▁if ▁( ▁suffix Sum ▁[ ▁i ▁+ ▁1 ▁] ▁< ▁prefix Sum ▁[ ▁i ▁] ▁) ▁pos ▁= ▁i ▁+ ▁1 ▁; ▁else ▁pos ▁= ▁i ▁; ▁} ▁} ▁result ▁. ▁element ▁= ▁min ▁; ▁result ▁. ▁position ▁= ▁pos ▁; ▁return ▁result ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁data ▁values ▁; ▁values ▁= ▁find Min Element ▁( ▁arr ▁, ▁n ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Minimum ▁element ▁: ▁" ▁+ ▁values ▁. ▁element ▁+ ▁" ▁Position ▁: ▁" ▁+ ▁values . position ); ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁find Ind ▁( ▁int ▁key ▁, ▁int ▁i ▁, ▁int ▁n ▁, ▁int ▁k ▁, ▁int ▁arr ▁[ ▁] ▁) ▁{ ▁int ▁start ▁, ▁end ▁, ▁mid ▁, ▁ind ▁= ▁- ▁1 ▁; ▁start ▁= ▁i ▁+ ▁1 ▁; ▁end ▁= ▁n ▁- ▁1 ▁; ▁while ▁( ▁start ▁< ▁end ▁) ▁{ ▁mid ▁= ▁start ▁+ ▁( ▁end ▁- ▁start ▁) ▁/ ▁2 ▁; ▁if ▁( ▁arr ▁[ ▁mid ▁] ▁- ▁key ▁<= ▁k ▁) ▁{ ▁ind ▁= ▁mid ▁; ▁start ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁else ▁{ ▁end ▁= ▁mid ▁; ▁} ▁} ▁return ▁ind ▁; ▁} ▁static ▁int ▁rem ovals ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁i ▁, ▁j ▁, ▁ans ▁= ▁n ▁- ▁1 ▁; ▁Arrays ▁. ▁sort ▁( ▁arr ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁j ▁= ▁find Ind ▁( ▁arr ▁[ ▁i ▁] ▁, ▁i ▁, ▁n ▁, ▁k ▁, ▁arr ▁) ▁; ▁if ▁( ▁j ▁!= ▁- ▁1 ▁) ▁{ ▁ans ▁= ▁Math ▁. ▁min ▁( ▁ans ▁, ▁n ▁- ▁( ▁j ▁- ▁i ▁+ ▁1 ▁) ▁) ▁; ▁} ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁4 ▁, ▁9 ▁, ▁10 ▁, ▁11 ▁, ▁12 ▁, ▁17 ▁, ▁20 ▁} ▁; ▁int ▁n ▁= ▁a ▁. ▁length ▁; ▁int ▁k ▁= ▁4 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁rem ovals ▁( ▁a ▁, ▁n ▁, ▁k ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁maxLength ▁( ▁String ▁s ▁, ▁int ▁n ▁) ▁{ ▁int ▁invalid Open Bra ces ▁= ▁0 ▁; ▁int ▁invalid Close Bra ces ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁== ▁' ▁( ▁' ▁) ▁{ ▁invalid Open Bra ces ▁++ ▁; ▁} ▁else ▁{ ▁if ▁( ▁invalid Open Bra ces ▁== ▁0 ▁) ▁{ ▁invalid Close Bra ces ▁++ ▁; ▁} ▁else ▁{ ▁invalid Open Bra ces ▁-- ▁; ▁} ▁} ▁} ▁return ▁( ▁n ▁- ▁( ▁invalid Open Bra ces ▁+ ▁invalid Close Bra ces ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁s ▁= ▁" ▁( ▁) ▁( ▁( ▁( ▁( ▁( ▁( ▁) ▁" ▁; ▁int ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁maxLength ▁( ▁s ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁MAX ▁= ▁10 ▁; ▁static ▁int ▁l cs ▁( ▁int ▁[ ▁] ▁[ ▁] ▁[ ▁] ▁dp ▁, ▁int ▁[ ▁] ▁arr 1 ▁, ▁int ▁n ▁, ▁int ▁[ ▁] ▁arr 2 ▁, ▁int ▁m ▁, ▁int ▁k ▁) ▁{ ▁if ▁( ▁k ▁< ▁0 ▁) ▁return ▁- ▁10000 000 ▁; ▁if ▁( ▁n ▁< ▁0 ▁m ▁< ▁0 ▁) ▁return ▁0 ▁; ▁int ▁ans ▁= ▁dp ▁[ ▁n ▁] ▁[ ▁m ▁] ▁[ ▁k ▁] ▁; ▁if ▁( ▁ans ▁!= ▁- ▁1 ▁) ▁return ▁ans ▁; ▁try ▁{ ▁ans ▁= ▁Math ▁. ▁max ▁( ▁l cs ▁( ▁dp ▁, ▁arr 1 ▁, ▁n ▁- ▁1 ▁, ▁arr 2 ▁, ▁m ▁, ▁k ▁) ▁, ▁l cs ▁( ▁dp ▁, ▁arr 1 ▁, ▁n ▁, ▁arr 2 ▁, ▁m ▁- ▁1 ▁, ▁k ▁) ▁) ▁; ▁if ▁( ▁arr 1 ▁[ ▁n ▁- ▁1 ▁] ▁== ▁arr 2 ▁[ ▁m ▁- ▁1 ▁] ▁) ▁ans ▁= ▁Math ▁. ▁max ▁( ▁ans ▁, ▁1 ▁+ ▁l cs ▁( ▁dp ▁, ▁arr 1 ▁, ▁n ▁- ▁1 ▁, ▁arr 2 ▁, ▁m ▁- ▁1 ▁, ▁k ▁) ▁) ▁; ▁ans ▁= ▁Math ▁. ▁max ▁( ▁ans ▁, ▁1 ▁+ ▁l cs ▁( ▁dp ▁, ▁arr 1 ▁, ▁n ▁- ▁1 ▁, ▁arr 2 ▁, ▁m ▁- ▁1 ▁, ▁k ▁- ▁1 ▁) ▁) ▁; ▁} ▁catch ▁( ▁Exception ▁e ▁) ▁{ ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁k ▁= ▁1 ▁; ▁int ▁[ ▁] ▁arr 1 ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁[ ▁] ▁arr 2 ▁= ▁{ ▁5 ▁, ▁3 ▁, ▁1 ▁, ▁4 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁arr 1 ▁. ▁length ▁; ▁int ▁m ▁= ▁arr 2 ▁. ▁length ▁; ▁int ▁[ ▁] ▁[ ▁] ▁[ ▁] ▁dp ▁= ▁new ▁int ▁[ ▁MAX ▁] ▁[ ▁MAX ▁] ▁[ ▁MAX ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁MAX ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁MAX ▁; ▁j ▁++ ▁) ▁for ▁( ▁int ▁l ▁= ▁0 ▁; ▁l ▁< ▁MAX ▁; ▁l ▁++ ▁) ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁[ ▁l ▁] ▁= ▁- ▁1 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁l cs ▁( ▁dp ▁, ▁arr 1 ▁, ▁n ▁, ▁arr 2 ▁, ▁m ▁, ▁k ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁int ▁max Len Sub ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁m ls ▁[ ▁] ▁= ▁new ▁int ▁[ ▁n ▁] ▁, ▁max ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁m ls ▁[ ▁i ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁i ▁; ▁j ▁++ ▁) ▁if ▁( ▁Math ▁. ▁abs ▁( ▁arr ▁[ ▁i ▁] ▁- ▁arr ▁[ ▁j ▁] ▁) ▁<= ▁1 ▁&& ▁m ls ▁[ ▁i ▁] ▁< ▁m ls ▁[ ▁j ▁] ▁+ ▁1 ▁) ▁m ls ▁[ ▁i ▁] ▁= ▁m ls ▁[ ▁j ▁] ▁+ ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁max ▁< ▁m ls ▁[ ▁i ▁] ▁) ▁max ▁= ▁m ls ▁[ ▁i ▁] ▁; ▁return ▁max ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁5 ▁, ▁6 ▁, ▁3 ▁, ▁7 ▁, ▁6 ▁, ▁5 ▁, ▁8 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Maximum ▁length ▁sub sequence ▁= ▁" ▁+ ▁max Len Sub ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁final ▁int ▁max ▁= ▁100000 ▁; ▁static ▁int ▁base conversion ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁num ▁, ▁int ▁base ▁) ▁{ ▁int ▁i ▁= ▁0 ▁, ▁rem ▁, ▁j ▁; ▁if ▁( ▁num ▁== ▁0 ▁) ▁{ ▁return ▁0 ▁; ▁} ▁while ▁( ▁num ▁> ▁0 ▁) ▁{ ▁rem ▁= ▁num ▁% ▁base ▁; ▁arr ▁[ ▁i ▁++ ▁] ▁= ▁rem ▁; ▁num ▁/= ▁base ▁; ▁} ▁return ▁i ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁new ▁int ▁[ ▁max ▁] ▁; ▁int ▁n ▁= ▁10 ▁; ▁int ▁size ▁= ▁base conversion ▁( ▁arr ▁, ▁n ▁- ▁1 ▁, ▁6 ▁) ▁; ▁if ▁( ▁size ▁== ▁0 ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁size ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁size ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁MAX ▁= ▁1000 ▁; ▁static ▁int ▁num of Array ▁( ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁int ▁[ ▁] ▁[ ▁] ▁dp ▁= ▁new ▁int ▁[ ▁MAX ▁] ▁[ ▁MAX ▁] ▁; ▁Vector ▁< ▁Integer ▁> ▁[ ▁] ▁di ▁= ▁new ▁Vector ▁[ ▁MAX ▁] ▁; ▁Vector ▁< ▁Integer ▁> ▁[ ▁] ▁mu ▁= ▁new ▁Vector ▁[ ▁MAX ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁MAX ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁MAX ▁; ▁j ▁++ ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁0 ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁MAX ▁; ▁i ▁++ ▁) ▁{ ▁di ▁[ ▁i ▁] ▁= ▁new ▁Vector ▁< ▁> ▁( ▁) ▁; ▁mu ▁[ ▁i ▁] ▁= ▁new ▁Vector ▁< ▁> ▁( ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁m ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁2 ▁* ▁i ▁; ▁j ▁<= ▁m ▁; ▁j ▁+= ▁i ▁) ▁{ ▁di ▁[ ▁j ▁] ▁. ▁add ▁( ▁i ▁) ▁; ▁mu ▁[ ▁i ▁] ▁. ▁add ▁( ▁j ▁) ▁; ▁} ▁di ▁[ ▁i ▁] ▁. ▁add ▁( ▁i ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁m ▁; ▁i ▁++ ▁) ▁dp ▁[ ▁1 ▁] ▁[ ▁i ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁<= ▁m ▁; ▁j ▁++ ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁0 ▁; ▁for ▁( ▁Integer ▁x ▁: ▁di ▁[ ▁j ▁] ▁) ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁x ▁] ▁; ▁for ▁( ▁Integer ▁x ▁: ▁mu ▁[ ▁j ▁] ▁) ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁x ▁] ▁; ▁} ▁} ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁m ▁; ▁i ▁++ ▁) ▁{ ▁ans ▁+= ▁dp ▁[ ▁n ▁] ▁[ ▁i ▁] ▁; ▁di ▁[ ▁i ▁] ▁. ▁clear ▁( ▁) ▁; ▁mu ▁[ ▁i ▁] ▁. ▁clear ▁( ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁3 ▁, ▁m ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁num of Array ▁( ▁n ▁, ▁m ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁Row ▁= ▁6 ▁, ▁Col ▁= ▁6 ▁; ▁static ▁int ▁largest K Sub matrix ▁( ▁int ▁[ ▁] ▁[ ▁] ▁a ▁) ▁{ ▁int ▁[ ▁] ▁[ ▁] ▁dp ▁= ▁new ▁int ▁[ ▁Row ▁] ▁[ ▁Col ▁] ▁; ▁int ▁result ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁Row ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁Col ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁i ▁== ▁0 ▁j ▁== ▁0 ▁) ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁1 ▁; ▁else ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁[ ▁j ▁] ▁== ▁a ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁&& ▁a ▁[ ▁i ▁] ▁[ ▁j ▁] ▁== ▁a ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁&& ▁a ▁[ ▁i ▁] ▁[ ▁j ▁] ▁== ▁a ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁- ▁1 ▁] ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁( ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁> ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁&& ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁> ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁- ▁1 ▁] ▁+ ▁1 ▁) ▁? ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁: ▁( ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁> ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁&& ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁> ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁- ▁1 ▁] ▁+ ▁1 ▁) ▁? ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁: ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁- ▁1 ▁] ▁+ ▁1 ▁; ▁} ▁else ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁1 ▁; ▁} ▁result ▁= ▁result ▁> ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁? ▁result ▁: ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁} ▁} ▁return ▁result ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁[ ▁] ▁a ▁= ▁{ ▁{ ▁2 ▁, ▁2 ▁, ▁3 ▁, ▁3 ▁, ▁4 ▁, ▁4 ▁} ▁, ▁{ ▁5 ▁, ▁5 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁4 ▁} ▁, ▁{ ▁1 ▁, ▁2 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁4 ▁} ▁, ▁{ ▁4 ▁, ▁4 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁4 ▁} ▁, ▁{ ▁5 ▁, ▁5 ▁, ▁5 ▁, ▁1 ▁, ▁2 ▁, ▁7 ▁} ▁, ▁{ ▁8 ▁, ▁7 ▁, ▁9 ▁, ▁4 ▁, ▁4 ▁, ▁4 ▁} ▁} ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁largest K Sub matrix ▁( ▁a ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁count Div isible Sub seq ▁( ▁String ▁str ▁, ▁int ▁n ▁) ▁{ ▁int ▁len ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁int ▁dp ▁[ ▁] ▁[ ▁] ▁= ▁new ▁int ▁[ ▁len ▁] ▁[ ▁n ▁] ▁; ▁dp ▁[ ▁0 ▁] ▁[ ▁( ▁str ▁. ▁charAt ▁( ▁0 ▁) ▁- ▁'0' ▁) ▁% ▁n ▁] ▁++ ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁len ▁; ▁i ▁++ ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁- ▁'0' ▁) ▁% ▁n ▁] ▁++ ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁; ▁dp ▁[ ▁i ▁] ▁[ ▁( ▁j ▁* ▁10 ▁+ ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁- ▁'0' ▁) ▁) ▁% ▁n ▁] ▁+= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁; ▁} ▁} ▁return ▁dp ▁[ ▁len ▁- ▁1 ▁] ▁[ ▁0 ▁] ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁"1234 " ▁; ▁int ▁n ▁= ▁4 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁count Div isible Sub seq ▁( ▁str ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁N ▁= ▁100 ▁; ▁static ▁int ▁[ ▁] ▁[ ▁] ▁L ▁= ▁new ▁int ▁[ ▁N ▁] ▁[ ▁N ▁] ▁; ▁static ▁Set ▁< ▁String ▁> ▁find L CS ▁( ▁String ▁X ▁, ▁String ▁Y ▁, ▁int ▁m ▁, ▁int ▁n ▁) ▁{ ▁Set ▁< ▁String ▁> ▁s ▁= ▁new ▁HashSet ▁< ▁> ▁( ▁) ▁; ▁if ▁( ▁m ▁== ▁0 ▁n ▁== ▁0 ▁) ▁{ ▁s ▁. ▁add ▁( ▁" ▁" ▁) ▁; ▁return ▁s ▁; ▁} ▁if ▁( ▁X ▁. ▁charAt ▁( ▁m ▁- ▁1 ▁) ▁== ▁Y ▁. ▁charAt ▁( ▁n ▁- ▁1 ▁) ▁) ▁{ ▁Set ▁< ▁String ▁> ▁tmp ▁= ▁find L CS ▁( ▁X ▁, ▁Y ▁, ▁m ▁- ▁1 ▁, ▁n ▁- ▁1 ▁) ▁; ▁for ▁( ▁String ▁str ▁: ▁tmp ▁) ▁s ▁. ▁add ▁( ▁str ▁+ ▁X ▁. ▁charAt ▁( ▁m ▁- ▁1 ▁) ▁) ▁; ▁} ▁else ▁{ ▁if ▁( ▁L ▁[ ▁m ▁- ▁1 ▁] ▁[ ▁n ▁] ▁>= ▁L ▁[ ▁m ▁] ▁[ ▁n ▁- ▁1 ▁] ▁) ▁s ▁= ▁find L CS ▁( ▁X ▁, ▁Y ▁, ▁m ▁- ▁1 ▁, ▁n ▁) ▁; ▁if ▁( ▁L ▁[ ▁m ▁] ▁[ ▁n ▁- ▁1 ▁] ▁>= ▁L ▁[ ▁m ▁- ▁1 ▁] ▁[ ▁n ▁] ▁) ▁{ ▁Set ▁< ▁String ▁> ▁tmp ▁= ▁find L CS ▁( ▁X ▁, ▁Y ▁, ▁m ▁, ▁n ▁- ▁1 ▁) ▁; ▁s ▁. ▁addAll ▁( ▁tmp ▁) ▁; ▁} ▁} ▁return ▁s ▁; ▁} ▁static ▁int ▁L CS ▁( ▁String ▁X ▁, ▁String ▁Y ▁, ▁int ▁m ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁m ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁<= ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁i ▁== ▁0 ▁j ▁== ▁0 ▁) ▁L ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁0 ▁; ▁else ▁if ▁( ▁X ▁. ▁charAt ▁( ▁i ▁- ▁1 ▁) ▁== ▁Y ▁. ▁charAt ▁( ▁j ▁- ▁1 ▁) ▁) ▁L ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁L ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁- ▁1 ▁] ▁+ ▁1 ▁; ▁else ▁L ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁Math ▁. ▁max ▁( ▁L ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁, ▁L ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁) ▁; ▁} ▁} ▁return ▁L ▁[ ▁m ▁] ▁[ ▁n ▁] ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁X ▁= ▁" ▁A GT G AT G ▁" ▁; ▁String ▁Y ▁= ▁" ▁GT TAG ▁" ▁; ▁int ▁m ▁= ▁X ▁. ▁length ▁( ▁) ▁; ▁int ▁n ▁= ▁Y ▁. ▁length ▁( ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁L CS ▁length ▁is ▁" ▁+ ▁L CS ▁( ▁X ▁, ▁Y ▁, ▁m ▁, ▁n ▁) ▁) ▁; ▁Set ▁< ▁String ▁> ▁s ▁= ▁find L CS ▁( ▁X ▁, ▁Y ▁, ▁m ▁, ▁n ▁) ▁; ▁for ▁( ▁String ▁str ▁: ▁s ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁str ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁count Integ ral Solution s ▁( ▁int ▁n ▁) ▁{ ▁return ▁( ▁( ▁n ▁+ ▁1 ▁) ▁* ▁( ▁n ▁+ ▁2 ▁) ▁) ▁/ ▁2 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Integ ral Solution s ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁Partition ▁{ ▁static ▁boolean ▁is Subset Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁sum ▁) ▁{ ▁if ▁( ▁sum ▁== ▁0 ▁) ▁return ▁true ▁; ▁if ▁( ▁n ▁== ▁0 ▁&& ▁sum ▁!= ▁0 ▁) ▁return ▁false ▁; ▁if ▁( ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁> ▁sum ▁) ▁return ▁is Subset Sum ▁( ▁arr ▁, ▁n ▁- ▁1 ▁, ▁sum ▁) ▁; ▁return ▁is Subset Sum ▁( ▁arr ▁, ▁n ▁- ▁1 ▁, ▁sum ▁) ▁|| ▁is Subset Sum ▁( ▁arr ▁, ▁n ▁- ▁1 ▁, ▁sum ▁- ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁) ▁; ▁} ▁static ▁boolean ▁find Partition ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁if ▁( ▁sum ▁% ▁2 ▁!= ▁0 ▁) ▁return ▁false ▁; ▁return ▁is Subset Sum ▁( ▁arr ▁, ▁n ▁, ▁sum ▁/ ▁2 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁1 ▁, ▁5 ▁, ▁9 ▁, ▁12 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁if ▁( ▁find Partition ▁( ▁arr ▁, ▁n ▁) ▁== ▁true ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Can ▁be ▁divided ▁into ▁two ▁" ▁+ ▁" ▁subsets ▁of ▁equal ▁sum ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Can ▁not ▁be ▁divided ▁into ▁" ▁+ ▁" ▁two ▁subsets ▁of ▁equal ▁sum ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁find ▁( ▁int ▁N ▁, ▁int ▁[ ▁] ▁[ ▁] ▁Arr ▁) ▁{ ▁int ▁amount ▁= ▁0 ▁; ▁ArrayList ▁< ▁Integer ▁> ▁mid _ odd ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁int ▁s iz ▁= ▁Arr ▁[ ▁i ▁] ▁. ▁length ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁s iz ▁/ ▁2 ▁; ▁j ▁++ ▁) ▁amount ▁= ▁amount ▁+ ▁Arr ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁if ▁( ▁s iz ▁% ▁2 ▁== ▁1 ▁) ▁mid _ odd ▁. ▁add ▁( ▁Arr ▁[ ▁i ▁] ▁[ ▁s iz ▁/ ▁2 ▁] ▁) ▁; ▁} ▁Collections ▁. ▁sort ▁( ▁mid _ odd ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁mid _ odd ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁% ▁2 ▁== ▁0 ▁) ▁amount ▁= ▁amount ▁+ ▁mid _ odd ▁. ▁get ▁( ▁i ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁amount ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁2 ▁; ▁int ▁[ ▁] ▁[ ▁] ▁Arr ▁= ▁{ ▁{ ▁5 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁, ▁{ ▁1 ▁, ▁6 ▁} ▁} ▁; ▁find ▁( ▁N ▁, ▁Arr ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁print Diag onal Traversal ▁( ▁int ▁[ ▁] ▁[ ▁] ▁nums ▁) ▁{ ▁int ▁max _ size ▁= ▁nums ▁[ ▁0 ▁] ▁. ▁length ▁; ▁ArrayList ▁< ▁ArrayList ▁< ▁Integer ▁> ▁> ▁v ▁= ▁new ▁ArrayList ▁< ▁ArrayList ▁< ▁Integer ▁> ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁2 ▁* ▁max _ size ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁v ▁. ▁add ▁( ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁nums ▁[ ▁0 ▁] ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁nums ▁[ ▁0 ▁] ▁. ▁length ▁; ▁j ▁++ ▁) ▁{ ▁v ▁. ▁get ▁( ▁i ▁+ ▁j ▁) ▁. ▁add ▁( ▁nums ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁v ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁v ▁. ▁get ▁( ▁i ▁) ▁. ▁size ▁( ▁) ▁- ▁1 ▁; ▁j ▁>= ▁0 ▁; ▁j ▁-- ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁v ▁. ▁get ▁( ▁i ▁) ▁. ▁get ▁( ▁j ▁) ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁[ ▁] ▁arr ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁, ▁{ ▁4 ▁, ▁5 ▁, ▁6 ▁} ▁, ▁{ ▁7 ▁, ▁8 ▁, ▁9 ▁} ▁} ▁; ▁print Diag onal Traversal ▁( ▁arr ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁O dd Length Sum ▁( ▁int ▁[ ▁] ▁arr ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁int ▁l ▁= ▁arr ▁. ▁length ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁l ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁< ▁l ▁; ▁j ▁+= ▁2 ▁) ▁{ ▁for ▁( ▁int ▁k ▁= ▁i ▁; ▁k ▁<= ▁j ▁; ▁k ▁++ ▁) ▁{ ▁sum ▁+= ▁arr ▁[ ▁k ▁] ▁; ▁} ▁} ▁} ▁return ▁sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁1 ▁, ▁5 ▁, ▁3 ▁, ▁1 ▁, ▁2 ▁} ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁O dd Length Sum ▁( ▁arr ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁long ▁[ ▁] ▁N _ bon acci ▁= ▁new ▁long ▁[ ▁100 ▁] ▁; ▁@ ▁Suppress Warnings ▁( ▁" ▁unchecked ▁" ▁) ▁public ▁static ▁void ▁N _ bon acci _ nums ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁N _ bon acci ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁50 ▁; ▁++ ▁i ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁- ▁1 ▁; ▁j ▁>= ▁i ▁- ▁k ▁&& ▁j ▁>= ▁0 ▁; ▁-- ▁j ▁) ▁N _ bon acci ▁[ ▁i ▁] ▁+= ▁N _ bon acci ▁[ ▁j ▁] ▁; ▁} ▁Vector ▁ans ▁= ▁new ▁Vector ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁50 ▁; ▁i ▁>= ▁0 ▁; ▁-- ▁i ▁) ▁if ▁( ▁n ▁- ▁N _ bon acci ▁[ ▁i ▁] ▁>= ▁0 ▁) ▁{ ▁ans ▁. ▁add ▁( ▁N _ bon acci ▁[ ▁i ▁] ▁) ▁; ▁n ▁-= ▁N _ bon acci ▁[ ▁i ▁] ▁; ▁} ▁if ▁( ▁ans ▁. ▁size ▁( ▁) ▁== ▁1 ▁) ▁ans ▁. ▁add ▁( ▁0 ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁ans ▁. ▁size ▁( ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁ans ▁. ▁size ▁( ▁) ▁; ▁++ ▁i ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁ans ▁. ▁get ▁( ▁i ▁) ▁+ ▁" ▁, ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁21 ▁, ▁k ▁= ▁5 ▁; ▁N _ bon acci _ nums ▁( ▁n ▁, ▁k ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁check Bit onic ▁( ▁char ▁[ ▁] ▁s ▁) ▁{ ▁int ▁i ▁, ▁j ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁s ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁[ ▁i ▁] ▁> ▁s ▁[ ▁i ▁- ▁1 ▁] ▁) ▁continue ▁; ▁if ▁( ▁s ▁[ ▁i ▁] ▁<= ▁s ▁[ ▁i ▁- ▁1 ▁] ▁) ▁break ▁; ▁} ▁if ▁( ▁i ▁== ▁s ▁. ▁length ▁- ▁1 ▁) ▁return ▁1 ▁; ▁for ▁( ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁s ▁. ▁length ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁s ▁[ ▁j ▁] ▁< ▁s ▁[ ▁j ▁- ▁1 ▁] ▁) ▁continue ▁; ▁if ▁( ▁s ▁[ ▁j ▁] ▁>= ▁s ▁[ ▁j ▁- ▁1 ▁] ▁) ▁break ▁; ▁} ▁i ▁= ▁j ▁; ▁if ▁( ▁i ▁!= ▁s ▁. ▁length ▁) ▁return ▁0 ▁; ▁return ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁s ▁= ▁" ▁abc df g cb a ▁" ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁( ▁check Bit onic ▁( ▁s ▁. ▁toCharArray ▁( ▁) ▁) ▁== ▁1 ▁) ▁? ▁" ▁YES ▁" ▁: ▁" ▁NO ▁" ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁make Array ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁i ▁* ▁n ▁+ ▁" ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁6 ▁; ▁int ▁arr ▁[ ▁] ▁= ▁new ▁int ▁[ ▁N ▁] ▁; ▁make Array ▁( ▁arr ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁check Q w erty Row ▁( ▁char ▁x ▁) ▁{ ▁Character ▁[ ▁] ▁first _ row 1 ▁= ▁{ ▁'1' ▁, ▁'2' ▁, ▁'3' ▁, ▁'4' ▁, ▁'5' ▁, ▁'6' ▁, ▁'7' ▁, ▁'8' ▁, ▁'9' ▁, ▁'0' ▁, ▁' ▁- ▁' ▁, ▁' ▁= ▁' ▁} ▁; ▁Set ▁< ▁Character ▁> ▁first _ row ▁= ▁new ▁HashSet ▁< ▁> ▁( ▁Arrays ▁. ▁asList ▁( ▁first _ row 1 ▁) ▁) ▁; ▁Character ▁[ ▁] ▁second _ row 1 ▁= ▁{ ▁' ▁Q ▁' ▁, ▁' ▁W ▁' ▁, ▁' ▁E ▁' ▁, ▁' ▁R ▁' ▁, ▁' ▁T ▁' ▁, ▁' ▁Y ▁' ▁, ▁' ▁U ▁' ▁, ▁' ▁I ▁' ▁, ▁' ▁O ▁' ▁, ▁' ▁P ▁' ▁, ▁' ▁[ ▁' ▁, ▁' ▁] ▁' ▁, ▁' ▁q ▁' ▁, ▁' ▁w ▁' ▁, ▁' ▁e ▁' ▁, ▁' ▁r ▁' ▁, ▁' ▁t ▁' ▁, ▁' ▁y ▁' ▁, ▁' ▁u ▁' ▁, ▁' ▁i ▁' ▁, ▁' ▁o ▁' ▁, ▁' ▁p ▁' ▁} ▁; ▁Set ▁< ▁Character ▁> ▁second _ row ▁= ▁new ▁HashSet ▁< ▁> ▁( ▁Arrays ▁. ▁asList ▁( ▁second _ row 1 ▁) ▁) ▁; ▁Character ▁[ ▁] ▁third _ row 1 ▁= ▁{ ▁' ▁A ▁' ▁, ▁' ▁S ▁' ▁, ▁' ▁D ▁' ▁, ▁' ▁F ▁' ▁, ▁' ▁G ▁' ▁, ▁' ▁H ▁' ▁, ▁' ▁J ▁' ▁, ▁' ▁K ▁' ▁, ▁' ▁L ▁' ▁, ▁' ▁; ▁' ▁, ▁' ▁: ▁' ▁, ▁' ▁a ▁' ▁, ▁' ▁s ▁' ▁, ▁' ▁d ▁' ▁, ▁' ▁f ▁' ▁, ▁' ▁g ▁' ▁, ▁' ▁h ▁' ▁, ▁' ▁j ▁' ▁, ▁' ▁k ▁' ▁, ▁' ▁l ▁' ▁} ▁; ▁Set ▁< ▁Character ▁> ▁third _ row ▁= ▁new ▁HashSet ▁< ▁> ▁( ▁Arrays ▁. ▁asList ▁( ▁third _ row 1 ▁) ▁) ▁; ▁Character ▁[ ▁] ▁fourth _ row 1 ▁= ▁{ ▁' ▁Z ▁' ▁, ▁' ▁X ▁' ▁, ▁' ▁C ▁' ▁, ▁' ▁V ▁' ▁, ▁' ▁B ▁' ▁, ▁' ▁N ▁' ▁, ▁' ▁M ▁' ▁, ▁' ▁, ▁' ▁, ▁' ▁. ▁' ▁, ▁' ▁/ ▁' ▁, ▁' ▁z ▁' ▁, ▁' ▁x ▁' ▁, ▁' ▁c ▁' ▁, ▁' ▁v ▁' ▁, ▁' ▁b ▁' ▁, ▁' ▁n ▁' ▁, ▁' ▁m ▁' ▁} ▁; ▁Set ▁< ▁Character ▁> ▁fourth _ row ▁= ▁new ▁HashSet ▁< ▁> ▁( ▁Arrays ▁. ▁asList ▁( ▁fourth _ row 1 ▁) ▁) ▁; ▁if ▁( ▁first _ row ▁. ▁contains ▁( ▁x ▁) ▁) ▁{ ▁return ▁1 ▁; ▁} ▁else ▁if ▁( ▁second _ row ▁. ▁contains ▁( ▁x ▁) ▁) ▁{ ▁return ▁2 ▁; ▁} ▁else ▁if ▁( ▁third _ row ▁. ▁contains ▁( ▁x ▁) ▁) ▁{ ▁return ▁3 ▁; ▁} ▁else ▁if ▁( ▁fourth _ row ▁. ▁contains ▁( ▁x ▁) ▁) ▁{ ▁return ▁4 ▁; ▁} ▁return ▁0 ▁; ▁} ▁static ▁boolean ▁check Validity ▁( ▁String ▁str ▁) ▁{ ▁char ▁x ▁= ▁str ▁. ▁charAt ▁( ▁0 ▁) ▁; ▁int ▁row ▁= ▁check Q w erty Row ▁( ▁x ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁str ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁x ▁= ▁str ▁. ▁charAt ▁( ▁i ▁) ▁; ▁if ▁( ▁row ▁!= ▁check Q w erty Row ▁( ▁x ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁} ▁return ▁true ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁" ▁G eek s for G eek s ▁" ▁; ▁if ▁( ▁check Validity ▁( ▁str ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁fib ▁( ▁long ▁n ▁) ▁{ ▁int ▁f 0 ▁= ▁0 ▁; ▁int ▁f 1 ▁= ▁1 ▁; ▁if ▁( ▁n ▁== ▁0 ▁) ▁return ▁0 ▁; ▁if ▁( ▁n ▁== ▁1 ▁) ▁return ▁1 ▁; ▁else ▁{ ▁int ▁rem ▁= ▁( ▁int ▁) ▁( ▁n ▁% ▁60 ▁) ▁; ▁if ▁( ▁rem ▁== ▁0 ▁) ▁return ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁< ▁rem ▁+ ▁3 ▁; ▁i ▁++ ▁) ▁{ ▁int ▁f ▁= ▁( ▁f 0 ▁+ ▁f 1 ▁) ▁% ▁60 ▁; ▁f 0 ▁= ▁f 1 ▁; ▁f 1 ▁= ▁f ▁; ▁} ▁int ▁s ▁= ▁f 1 ▁- ▁1 ▁; ▁return ▁s ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁m ▁= ▁100 8 78 87 ▁; ▁long ▁n ▁= ▁2 98 309 78 99 L ▁; ▁int ▁Final ▁= ▁( ▁int ▁) ▁Math ▁. ▁abs ▁( ▁fib ▁( ▁n ▁) ▁- ▁fib ▁( ▁m ▁- ▁1 ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁Final ▁% ▁10 ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁print Pattern ▁( ▁int ▁i ▁, ▁int ▁j ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁j ▁>= ▁n ▁) ▁{ ▁return ▁0 ▁; ▁} ▁if ▁( ▁i ▁>= ▁n ▁) ▁{ ▁return ▁1 ▁; ▁} ▁if ▁( ▁j ▁== ▁i ▁j ▁== ▁n ▁- ▁1 ▁- ▁i ▁) ▁{ ▁if ▁( ▁i ▁== ▁n ▁- ▁1 ▁- ▁j ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁/ ▁" ▁) ▁; ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁\ ▁\" ▁) ▁; ▁} ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁* ▁" ▁) ▁; ▁} ▁if ▁( ▁print Pattern ▁( ▁i ▁, ▁j ▁+ ▁1 ▁, ▁n ▁) ▁== ▁1 ▁) ▁{ ▁return ▁1 ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁return ▁print Pattern ▁( ▁i ▁+ ▁1 ▁, ▁0 ▁, ▁n ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁9 ▁; ▁print Pattern ▁( ▁0 ▁, ▁0 ▁, ▁N ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁String ▁s ▁; ▁static ▁void ▁reverse Str ▁( ▁int ▁l ▁, ▁int ▁h ▁) ▁{ ▁int ▁n ▁= ▁h ▁- ▁l ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁/ ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁s ▁= ▁swap ▁( ▁i ▁+ ▁l ▁, ▁n ▁- ▁i ▁- ▁1 ▁+ ▁l ▁) ▁; ▁} ▁} ▁static ▁void ▁reverse String ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁reverse Str ▁( ▁0 ▁, ▁A ▁[ ▁0 ▁] ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁reverse Str ▁( ▁A ▁[ ▁i ▁- ▁1 ▁] ▁, ▁A ▁[ ▁i ▁] ▁) ▁; ▁reverse Str ▁( ▁A ▁[ ▁n ▁- ▁1 ▁] ▁, ▁s ▁. ▁length ▁( ▁) ▁) ▁; ▁} ▁static ▁String ▁swap ▁( ▁int ▁i ▁, ▁int ▁j ▁) ▁{ ▁char ▁ch ▁[ ▁] ▁= ▁s ▁. ▁toCharArray ▁( ▁) ▁; ▁char ▁temp ▁= ▁ch ▁[ ▁i ▁] ▁; ▁ch ▁[ ▁i ▁] ▁= ▁ch ▁[ ▁j ▁] ▁; ▁ch ▁[ ▁j ▁] ▁= ▁temp ▁; ▁return ▁String ▁. ▁valueOf ▁( ▁ch ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁s ▁= ▁" ▁abcdef gh ▁" ▁; ▁int ▁A ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁4 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁A ▁. ▁length ▁; ▁reverse String ▁( ▁A ▁, ▁n ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁s ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁getElement ▁( ▁int ▁N ▁, ▁int ▁r ▁, ▁int ▁c ▁) ▁{ ▁if ▁( ▁r ▁> ▁c ▁) ▁return ▁0 ▁; ▁if ▁( ▁r ▁== ▁1 ▁) ▁{ ▁return ▁c ▁; ▁} ▁int ▁a ▁= ▁( ▁r ▁+ ▁1 ▁) ▁* ▁( ▁int ▁) ▁( ▁Math ▁. ▁pow ▁( ▁2 ▁, ▁( ▁r ▁- ▁2 ▁) ▁) ▁) ▁; ▁int ▁d ▁= ▁( ▁int ▁) ▁( ▁Math ▁. ▁pow ▁( ▁2 ▁, ▁( ▁r ▁- ▁1 ▁) ▁) ▁) ▁; ▁c ▁= ▁c ▁- ▁r ▁; ▁int ▁element ▁= ▁a ▁+ ▁d ▁* ▁c ▁; ▁return ▁element ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁4 ▁, ▁R ▁= ▁3 ▁, ▁C ▁= ▁4 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁getElement ▁( ▁N ▁, ▁R ▁, ▁C ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁check ▁( ▁String ▁S 1 ▁, ▁String ▁S 2 ▁) ▁{ ▁int ▁n 1 ▁= ▁S 1 ▁. ▁length ▁( ▁) ▁; ▁int ▁n 2 ▁= ▁S 2 ▁. ▁length ▁( ▁) ▁; ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁mp ▁= ▁new ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n 1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁mp ▁. ▁containsKey ▁( ▁( ▁int ▁) ▁S 1 ▁. ▁charAt ▁( ▁i ▁) ▁) ▁) ▁{ ▁mp ▁. ▁put ▁( ▁( ▁int ▁) ▁S 1 ▁. ▁charAt ▁( ▁i ▁) ▁, ▁mp ▁. ▁get ▁( ▁( ▁int ▁) ▁S 1 ▁. ▁charAt ▁( ▁i ▁) ▁) ▁+ ▁1 ▁) ▁; ▁} ▁else ▁{ ▁mp ▁. ▁put ▁( ▁( ▁int ▁) ▁S 1 ▁. ▁charAt ▁( ▁i ▁) ▁, ▁1 ▁) ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n 2 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁mp ▁. ▁containsKey ▁( ▁( ▁int ▁) ▁S 2 ▁. ▁charAt ▁( ▁i ▁) ▁) ▁) ▁{ ▁mp ▁. ▁put ▁( ▁( ▁int ▁) ▁S 2 ▁. ▁charAt ▁( ▁i ▁) ▁, ▁mp ▁. ▁get ▁( ▁( ▁int ▁) ▁S 2 ▁. ▁charAt ▁( ▁i ▁) ▁) ▁- ▁1 ▁) ▁; ▁} ▁else ▁if ▁( ▁mp ▁. ▁containsKey ▁( ▁S 2 ▁. ▁charAt ▁( ▁i ▁) ▁- ▁1 ▁) ▁&& ▁mp ▁. ▁containsKey ▁( ▁S 2 ▁. ▁charAt ▁( ▁i ▁) ▁- ▁2 ▁) ▁) ▁{ ▁mp ▁. ▁put ▁( ▁( ▁S 2 ▁. ▁charAt ▁( ▁i ▁) ▁- ▁1 ▁) ▁, ▁mp ▁. ▁get ▁( ▁S 2 ▁. ▁charAt ▁( ▁i ▁) ▁- ▁1 ▁) ▁- ▁1 ▁) ▁; ▁mp ▁. ▁put ▁( ▁( ▁S 2 ▁. ▁charAt ▁( ▁i ▁) ▁- ▁2 ▁) ▁, ▁mp ▁. ▁get ▁( ▁S 2 ▁. ▁charAt ▁( ▁i ▁) ▁- ▁2 ▁) ▁- ▁1 ▁) ▁; ▁} ▁else ▁{ ▁return ▁false ▁; ▁} ▁} ▁return ▁true ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁S 1 ▁= ▁" ▁ab bat ▁" ▁; ▁String ▁S 2 ▁= ▁" ▁cat ▁" ▁; ▁if ▁( ▁check ▁( ▁S 1 ▁, ▁S 2 ▁) ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁YES ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁NO ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁length N Pal indrome ▁( ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁int ▁half ▁= ▁N ▁/ ▁2 ▁; ▁if ▁( ▁N ▁% ▁2 ▁== ▁1 ▁) ▁{ ▁half ▁+= ▁1 ▁; ▁} ▁int ▁ans ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁half ▁; ▁i ▁++ ▁) ▁{ ▁ans ▁*= ▁K ▁; ▁K ▁-- ▁; ▁} ▁return ▁ans ▁; ▁} ▁static ▁int ▁pal ind rom ic Strings ▁( ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁if ▁( ▁N ▁== ▁1 ▁) ▁{ ▁return ▁K ▁; ▁} ▁if ▁( ▁N ▁== ▁2 ▁) ▁{ ▁return ▁2 ▁* ▁K ▁; ▁} ▁int ▁ans ▁= ▁0 ▁; ▁ans ▁+= ▁( ▁2 ▁* ▁K ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁3 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁ans ▁+= ▁length N Pal indrome ▁( ▁i ▁, ▁K ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁4 ▁, ▁K ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁pal ind rom ic Strings ▁( ▁N ▁, ▁K ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁L CS ▁( ▁String ▁S ▁, ▁int ▁N ▁, ▁String ▁T ▁, ▁int ▁M ▁, ▁int ▁dp ▁[ ▁] ▁[ ▁] ▁) ▁{ ▁if ▁( ▁N ▁== ▁0 ▁M ▁== ▁0 ▁) ▁return ▁0 ▁; ▁if ▁( ▁dp ▁[ ▁N ▁] ▁[ ▁M ▁] ▁!= ▁0 ▁) ▁return ▁dp ▁[ ▁N ▁] ▁[ ▁M ▁] ▁; ▁if ▁( ▁S ▁. ▁charAt ▁( ▁N ▁- ▁1 ▁) ▁== ▁T ▁. ▁charAt ▁( ▁M ▁- ▁1 ▁) ▁) ▁{ ▁return ▁dp ▁[ ▁N ▁] ▁[ ▁M ▁] ▁= ▁1 ▁+ ▁L CS ▁( ▁S ▁, ▁N ▁- ▁1 ▁, ▁T ▁, ▁M ▁- ▁1 ▁, ▁dp ▁) ▁; ▁} ▁return ▁dp ▁[ ▁N ▁] ▁[ ▁M ▁] ▁= ▁Math ▁. ▁max ▁( ▁L CS ▁( ▁S ▁, ▁N ▁- ▁1 ▁, ▁T ▁, ▁M ▁, ▁dp ▁) ▁, ▁L CS ▁( ▁S ▁, ▁N ▁, ▁T ▁, ▁M ▁- ▁1 ▁, ▁dp ▁) ▁) ▁; ▁} ▁static ▁int ▁minimum Character ▁( ▁String ▁S ▁) ▁{ ▁String ▁T ▁= ▁" ▁abcdef ghijklmnop qrstuvwxyz ▁" ▁; ▁int ▁N ▁= ▁S ▁. ▁length ▁( ▁) ▁, ▁M ▁= ▁T ▁. ▁length ▁( ▁) ▁; ▁int ▁dp ▁[ ▁] ▁[ ▁] ▁= ▁new ▁int ▁[ ▁N ▁+ ▁1 ▁] ▁[ ▁M ▁+ ▁1 ▁] ▁; ▁return ▁( ▁26 ▁- ▁L CS ▁( ▁S ▁, ▁N ▁, ▁T ▁, ▁M ▁, ▁dp ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁S ▁= ▁" ▁abcd ad c ▁" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁minimum Character ▁( ▁S ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁public ▁class ▁G F G ▁{ ▁static ▁String ▁Min Value ▁( ▁String ▁number ▁, ▁int ▁x ▁) ▁{ ▁int ▁length ▁= ▁number ▁. ▁length ▁( ▁) ▁; ▁int ▁position ▁= ▁length ▁+ ▁1 ▁; ▁if ▁( ▁number ▁. ▁charAt ▁( ▁0 ▁) ▁== ▁' ▁- ▁' ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁number ▁. ▁length ▁( ▁) ▁- ▁1 ▁; ▁i ▁>= ▁1 ▁; ▁-- ▁i ▁) ▁{ ▁if ▁( ▁( ▁number ▁. ▁charAt ▁( ▁i ▁) ▁- ▁48 ▁) ▁< ▁x ▁) ▁{ ▁position ▁= ▁i ▁; ▁} ▁} ▁} ▁else ▁{ ▁for ▁( ▁int ▁i ▁= ▁number ▁. ▁length ▁( ▁) ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁-- ▁i ▁) ▁{ ▁if ▁( ▁( ▁number ▁. ▁charAt ▁( ▁i ▁) ▁- ▁48 ▁) ▁> ▁x ▁) ▁{ ▁position ▁= ▁i ▁; ▁} ▁} ▁} ▁number ▁= ▁number ▁. ▁substring ▁( ▁0 ▁, ▁position ▁) ▁+ ▁x ▁+ ▁number ▁. ▁substring ▁( ▁position ▁, ▁number ▁. ▁length ▁( ▁) ▁) ▁; ▁return ▁number ▁. ▁toString ▁( ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁number ▁= ▁" 89 " ▁; ▁int ▁x ▁= ▁1 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁Min Value ▁( ▁number ▁, ▁x ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁void ▁count Operations ▁( ▁String ▁S ▁) ▁{ ▁int ▁n ▁= ▁S ▁. ▁length ▁( ▁) ▁; ▁int ▁ans ▁= ▁0 ▁; ▁int ▁cnt ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁S ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'0' ▁) ▁{ ▁cnt ▁++ ▁; ▁} ▁else ▁{ ▁if ▁( ▁cnt ▁> ▁0 ▁) ▁{ ▁cnt ▁-- ▁; ▁ans ▁++ ▁; ▁} ▁} ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁ans ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁S ▁= ▁"11 00 11 01 0" ▁; ▁count Operations ▁( ▁S ▁) ▁; ▁} ▁}
▁public ▁class ▁G F G ▁{ ▁private ▁static ▁boolean ▁is Prime ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁<= ▁1 ▁) ▁return ▁false ▁; ▁else ▁if ▁( ▁n ▁== ▁2 ▁) ▁return ▁true ▁; ▁else ▁if ▁( ▁n ▁% ▁2 ▁== ▁0 ▁) ▁return ▁false ▁; ▁for ▁( ▁int ▁i ▁= ▁3 ▁; ▁i ▁<= ▁Math ▁. ▁sqrt ▁( ▁n ▁) ▁; ▁i ▁+= ▁2 ▁) ▁{ ▁if ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁return ▁false ▁; ▁} ▁return ▁true ▁; ▁} ▁private ▁static ▁void ▁check Perm utation ▁( ▁String ▁s 1 ▁, ▁String ▁s 2 ▁) ▁{ ▁int ▁freq ▁[ ▁] ▁= ▁new ▁int ▁[ ▁26 ▁] ▁; ▁for ▁( ▁char ▁ch ▁: ▁s 1 ▁. ▁toCharArray ▁( ▁) ▁) ▁{ ▁freq ▁[ ▁ch ▁- ▁' ▁a ▁' ▁] ▁-- ▁; ▁} ▁for ▁( ▁char ▁ch ▁: ▁s 2 ▁. ▁toCharArray ▁( ▁) ▁) ▁{ ▁freq ▁[ ▁ch ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁} ▁boolean ▁is All Changes Prime ▁= ▁true ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁26 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁freq ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁continue ▁; ▁} ▁else ▁if ▁( ▁! ▁is Prime ▁( ▁Math ▁. ▁abs ▁( ▁freq ▁[ ▁i ▁] ▁) ▁) ▁) ▁{ ▁is All Changes Prime ▁= ▁false ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁is All Changes Prime ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁S 1 ▁= ▁" ▁g ek for g k ▁" ▁; ▁String ▁S 2 ▁= ▁" ▁g eek s forge ek s ▁" ▁; ▁check Perm utation ▁( ▁S 1 ▁, ▁S 2 ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁void ▁minimum Operations ▁( ▁String ▁S ▁, ▁int ▁N ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁int ▁cnt One ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁N ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁S ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'0' ▁) ▁{ ▁ans ▁+= ▁cnt One ▁; ▁cnt One ▁*= ▁2 ▁; ▁} ▁else ▁cnt One ▁++ ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁ans ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁S ▁= ▁"00 1" ▁; ▁int ▁N ▁= ▁S ▁. ▁length ▁( ▁) ▁; ▁minimum Operations ▁( ▁S ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁is Prime ▁( ▁int ▁num ▁) ▁{ ▁boolean ▁flag ▁= ▁false ▁; ▁if ▁( ▁num ▁> ▁1 ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁< ▁num ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁num ▁% ▁i ▁) ▁== ▁0 ▁) ▁{ ▁flag ▁= ▁true ▁; ▁break ▁; ▁} ▁} ▁} ▁if ▁( ▁flag ▁) ▁return ▁false ▁; ▁else ▁return ▁true ▁; ▁} ▁static ▁int ▁order ▁( ▁int ▁x ▁) ▁{ ▁int ▁n ▁= ▁0 ▁; ▁while ▁( ▁x ▁!= ▁0 ▁) ▁{ ▁n ▁= ▁n ▁+ ▁1 ▁; ▁x ▁= ▁x ▁/ ▁10 ▁; ▁} ▁return ▁n ▁; ▁} ▁static ▁boolean ▁is Ar m strong ▁( ▁int ▁x ▁) ▁{ ▁int ▁n ▁= ▁order ▁( ▁x ▁) ▁; ▁int ▁temp ▁= ▁x ▁; ▁int ▁sum 1 ▁= ▁0 ▁; ▁while ▁( ▁temp ▁!= ▁0 ▁) ▁{ ▁int ▁r ▁= ▁temp ▁% ▁10 ▁; ▁sum 1 ▁= ▁sum 1 ▁+ ▁( ▁int ▁) ▁( ▁Math ▁. ▁pow ▁( ▁r ▁, ▁n ▁) ▁) ▁; ▁temp ▁= ▁temp ▁/ ▁10 ▁; ▁} ▁return ▁( ▁sum 1 ▁== ▁x ▁) ▁; ▁} ▁static ▁int ▁count _ arm strong ▁( ▁String ▁[ ▁] ▁li ▁) ▁{ ▁int ▁c ▁= ▁0 ▁; ▁for ▁( ▁String ▁ele ▁: ▁li ▁) ▁{ ▁int ▁val ▁= ▁0 ▁; ▁for ▁( ▁char ▁che ▁: ▁ele ▁. ▁toCharArray ▁( ▁) ▁) ▁val ▁+= ▁che ▁; ▁if ▁( ▁is Ar m strong ▁( ▁val ▁) ▁) ▁c ▁+= ▁1 ▁; ▁} ▁return ▁c ▁; ▁} ▁static ▁int ▁count _ prime ▁( ▁String ▁[ ▁] ▁li ▁) ▁{ ▁int ▁c ▁= ▁0 ▁; ▁for ▁( ▁String ▁ele ▁: ▁li ▁) ▁{ ▁int ▁val ▁= ▁0 ▁; ▁for ▁( ▁char ▁che ▁: ▁ele ▁. ▁toCharArray ▁( ▁) ▁) ▁val ▁+= ▁che ▁; ▁if ▁( ▁is Prime ▁( ▁val ▁) ▁) ▁c ▁+= ▁1 ▁; ▁} ▁return ▁c ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁[ ▁] ▁arr ▁= ▁{ ▁" ▁g eek s forge ek s ▁" ▁, ▁" ▁a ▁" ▁, ▁" ▁computer ▁" ▁, ▁" ▁sc ience ▁" ▁, ▁" ▁portal ▁" ▁, ▁" ▁for ▁" ▁, ▁" ▁g eek s ▁" ▁} ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Number ▁of ▁Ar m strong ▁Strings ▁are ▁: ▁" ▁+ ▁count _ arm strong ▁( ▁arr ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Number ▁of ▁Prime ▁Strings ▁are ▁: ▁" ▁+ ▁count _ prime ▁( ▁arr ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁count ▁( ▁String ▁S ▁, ▁int ▁X ▁, ▁int ▁Y ▁) ▁{ ▁int ▁N ▁= ▁S ▁. ▁length ▁( ▁) ▁; ▁int ▁temp _ x ▁= ▁0 ▁, ▁temp _ y ▁= ▁0 ▁; ▁int ▁count ▁= ▁0 ▁; ▁HashSet ▁< ▁String ▁> ▁s ▁= ▁new ▁HashSet ▁< ▁> ▁( ▁) ▁; ▁s ▁. ▁add ▁( ▁( ▁X ▁+ ▁" ▁# ▁" ▁+ ▁Y ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁temp _ x ▁= ▁X ▁; ▁temp _ y ▁= ▁Y ▁; ▁if ▁( ▁S ▁. ▁charAt ▁( ▁i ▁) ▁== ▁' ▁U ▁' ▁) ▁{ ▁X ▁++ ▁; ▁} ▁else ▁if ▁( ▁S ▁. ▁charAt ▁( ▁i ▁) ▁== ▁' ▁D ▁' ▁) ▁{ ▁X ▁-- ▁; ▁} ▁else ▁if ▁( ▁S ▁. ▁charAt ▁( ▁i ▁) ▁== ▁' ▁R ▁' ▁) ▁{ ▁Y ▁++ ▁; ▁} ▁else ▁{ ▁Y ▁-- ▁; ▁} ▁if ▁( ▁s ▁. ▁contains ▁( ▁( ▁temp _ x ▁+ ▁X ▁) ▁+ ▁" ▁# ▁" ▁+ ▁( ▁temp _ y ▁+ ▁Y ▁) ▁) ▁) ▁{ ▁count ▁++ ▁; ▁} ▁else ▁{ ▁s ▁. ▁add ▁( ▁( ▁temp _ x ▁+ ▁X ▁) ▁+ ▁" ▁# ▁" ▁+ ▁( ▁temp _ y ▁+ ▁Y ▁) ▁) ▁; ▁} ▁} ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁S ▁= ▁" ▁RDD U DL ▁" ▁; ▁int ▁X ▁= ▁0 ▁, ▁Y ▁= ▁0 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁count ▁( ▁S ▁, ▁X ▁, ▁Y ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁count Min M oves ▁( ▁String ▁str ▁) ▁{ ▁int ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁int ▁a ▁[ ▁] ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁int ▁j ▁, ▁ans ▁= ▁0 ▁, ▁i ▁, ▁sum ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁== ▁' ▁) ▁' ▁) ▁{ ▁a ▁[ ▁i ▁] ▁+= ▁sum ▁- ▁1 ▁; ▁} ▁else ▁{ ▁a ▁[ ▁i ▁] ▁+= ▁sum ▁+ ▁1 ▁; ▁} ▁sum ▁= ▁a ▁[ ▁i ▁] ▁; ▁} ▁if ▁( ▁sum ▁== ▁0 ▁) ▁{ ▁i ▁= ▁1 ▁; ▁while ▁( ▁i ▁< ▁n ▁) ▁{ ▁j ▁= ▁i ▁- ▁1 ▁; ▁while ▁( ▁i ▁< ▁n ▁&& ▁a ▁[ ▁i ▁] ▁!= ▁0 ▁) ▁i ▁++ ▁; ▁if ▁( ▁i ▁< ▁n ▁&& ▁a ▁[ ▁i ▁- ▁1 ▁] ▁< ▁0 ▁) ▁{ ▁ans ▁+= ▁i ▁- ▁j ▁; ▁if ▁( ▁j ▁== ▁0 ▁) ▁ans ▁++ ▁; ▁} ▁i ▁++ ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁ans ▁) ▁; ▁} ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁- ▁1" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁" ▁) ▁( ▁( ▁) ▁" ▁; ▁count Min M oves ▁( ▁str ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁Print Stack ▁( ▁Stack ▁< ▁Character ▁> ▁s ▁) ▁{ ▁if ▁( ▁s ▁. ▁isEmpty ▁( ▁) ▁) ▁return ▁; ▁char ▁x ▁= ▁s ▁. ▁peek ▁( ▁) ▁; ▁s ▁. ▁pop ▁( ▁) ▁; ▁Print Stack ▁( ▁s ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁x ▁) ▁; ▁s ▁. ▁add ▁( ▁x ▁) ▁; ▁} ▁static ▁void ▁min String ▁( ▁String ▁s ▁) ▁{ ▁Stack ▁< ▁Character ▁> ▁Stack ▁= ▁new ▁Stack ▁< ▁Character ▁> ▁( ▁) ▁; ▁Stack ▁. ▁add ▁( ▁s ▁. ▁charAt ▁( ▁0 ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁s ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁Stack ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁Stack ▁. ▁add ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁) ▁; ▁} ▁else ▁{ ▁if ▁( ▁Stack ▁. ▁peek ▁( ▁) ▁== ▁s ▁. ▁charAt ▁( ▁i ▁) ▁) ▁{ ▁Stack ▁. ▁pop ▁( ▁) ▁; ▁} ▁else ▁{ ▁Stack ▁. ▁push ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁) ▁; ▁} ▁} ▁} ▁Print Stack ▁( ▁Stack ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁"1 0100 1" ▁; ▁min String ▁( ▁str ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁String ▁Short en String ▁( ▁String ▁str 1 ▁) ▁{ ▁Stack ▁< ▁Character ▁> ▁st ▁= ▁new ▁Stack ▁< ▁Character ▁> ▁( ▁) ▁; ▁int ▁i ▁= ▁0 ▁; ▁while ▁( ▁i ▁< ▁str 1 ▁. ▁length ▁( ▁) ▁) ▁{ ▁if ▁( ▁st ▁. ▁isEmpty ▁( ▁) ▁|| ▁str 1 ▁. ▁charAt ▁( ▁i ▁) ▁!= ▁st ▁. ▁peek ▁( ▁) ▁) ▁{ ▁st ▁. ▁add ▁( ▁str 1 ▁. ▁charAt ▁( ▁i ▁) ▁) ▁; ▁i ▁++ ▁; ▁} ▁else ▁{ ▁st ▁. ▁pop ▁( ▁) ▁; ▁i ▁++ ▁; ▁} ▁} ▁if ▁( ▁st ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁return ▁( ▁" ▁Empty ▁String ▁" ▁) ▁; ▁} ▁else ▁{ ▁String ▁short _ String ▁= ▁" ▁" ▁; ▁while ▁( ▁! ▁st ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁short _ String ▁= ▁st ▁. ▁peek ▁( ▁) ▁+ ▁short _ String ▁; ▁st ▁. ▁pop ▁( ▁) ▁; ▁} ▁return ▁( ▁short _ String ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str 1 ▁= ▁" ▁a zz x zy ▁" ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁Short en String ▁( ▁str 1 ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁print Rev ▁( ▁String ▁str ▁) ▁{ ▁Stack ▁< ▁String ▁> ▁st ▁= ▁new ▁Stack ▁< ▁String ▁> ▁( ▁) ▁; ▁String ▁[ ▁] ▁ss ▁= ▁str ▁. ▁split ▁( ▁" ▁" ▁) ▁; ▁for ▁( ▁String ▁temp ▁: ▁ss ▁) ▁{ ▁st ▁. ▁add ▁( ▁temp ▁) ▁; ▁} ▁while ▁( ▁! ▁st ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁st ▁. ▁peek ▁( ▁) ▁+ ▁" ▁" ▁) ▁; ▁st ▁. ▁pop ▁( ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁; ▁str ▁= ▁" ▁g eek s ▁quiz ▁practice ▁code ▁" ▁; ▁print Rev ▁( ▁str ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁max Set Bit Count ▁( ▁String ▁s ▁, ▁int ▁k ▁) ▁{ ▁int ▁max Count ▁= ▁0 ▁, ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁k ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'1' ▁) ▁count ▁++ ▁; ▁} ▁max Count ▁= ▁count ▁; ▁for ▁( ▁int ▁i ▁= ▁k ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁. ▁charAt ▁( ▁i ▁- ▁k ▁) ▁== ▁'1' ▁) ▁count ▁-- ▁; ▁if ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'1' ▁) ▁count ▁++ ▁; ▁max Count ▁= ▁Math ▁. ▁max ▁( ▁max Count ▁, ▁count ▁) ▁; ▁} ▁return ▁max Count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁s ▁= ▁"100 11 101 0" ▁; ▁int ▁k ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁max Set Bit Count ▁( ▁s ▁, ▁k ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁check ▁( ▁String ▁s ▁) ▁{ ▁boolean ▁ok ▁= ▁true ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁+ ▁1 ▁< ▁s ▁. ▁length ▁( ▁) ▁; ▁++ ▁i ▁) ▁ok ▁&= ▁( ▁Math ▁. ▁abs ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁- ▁s ▁. ▁charAt ▁( ▁i ▁+ ▁1 ▁) ▁) ▁!= ▁1 ▁) ▁; ▁return ▁ok ▁; ▁} ▁static ▁String ▁mon ot on ous String ▁( ▁String ▁s ▁) ▁{ ▁String ▁odd ▁= ▁" ▁" ▁, ▁even ▁= ▁" ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁length ▁( ▁) ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁% ▁2 ▁== ▁0 ▁) ▁odd ▁+= ▁s ▁. ▁charAt ▁( ▁i ▁) ▁; ▁else ▁even ▁+= ▁s ▁. ▁charAt ▁( ▁i ▁) ▁; ▁} ▁char ▁odd Array ▁[ ▁] ▁= ▁odd ▁. ▁toCharArray ▁( ▁) ▁; ▁Arrays ▁. ▁sort ▁( ▁odd Array ▁) ▁; ▁odd ▁= ▁new ▁String ▁( ▁odd Array ▁) ▁; ▁char ▁even Array ▁[ ▁] ▁= ▁even ▁. ▁toCharArray ▁( ▁) ▁; ▁Arrays ▁. ▁sort ▁( ▁even Array ▁) ▁; ▁even ▁= ▁new ▁String ▁( ▁even Array ▁) ▁; ▁if ▁( ▁check ▁( ▁odd ▁+ ▁even ▁) ▁) ▁return ▁" ▁Yes ▁" ▁; ▁else ▁if ▁( ▁check ▁( ▁even ▁+ ▁odd ▁) ▁) ▁return ▁" ▁Yes ▁" ▁; ▁return ▁" ▁No ▁" ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁" ▁abcd ▁" ▁; ▁String ▁ans ▁; ▁ans ▁= ▁mon ot on ous String ▁( ▁str ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁ans ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁String ▁find Str ▁( ▁String ▁S ▁) ▁{ ▁StringBuilder ▁sb ▁= ▁new ▁StringBuilder ▁( ▁S ▁) ▁; ▁int ▁n ▁= ▁sb ▁. ▁length ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁/ ▁2 ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁sb ▁. ▁charAt ▁( ▁i ▁) ▁!= ▁' ▁a ▁' ▁) ▁{ ▁sb ▁. ▁set Char At ▁( ▁i ▁, ▁' ▁a ▁' ▁) ▁; ▁return ▁sb ▁. ▁toString ▁( ▁) ▁; ▁} ▁} ▁sb ▁. ▁set Char At ▁( ▁n ▁- ▁1 ▁, ▁' ▁b ▁' ▁) ▁; ▁return ▁n ▁< ▁2 ▁? ▁" ▁- ▁1 ▁" ▁: ▁sb ▁. ▁toString ▁( ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁" ▁a ▁" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Str ▁( ▁str ▁) ▁) ▁; ▁String ▁str 1 ▁= ▁" ▁ab cc ba ▁" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Str ▁( ▁str 1 ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁convert String ▁( ▁String ▁str 1 ▁, ▁String ▁str 2 ▁, ▁String ▁str 3 ▁) ▁{ ▁HashMap ▁< ▁Character ▁, ▁Integer ▁> ▁freq ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁str 3 ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁freq ▁. ▁containsKey ▁( ▁str 3 ▁. ▁charAt ▁( ▁i ▁) ▁) ▁) ▁freq ▁. ▁put ▁( ▁str 3 ▁. ▁charAt ▁( ▁i ▁) ▁, ▁freq ▁. ▁get ▁( ▁str 3 ▁. ▁charAt ▁( ▁i ▁) ▁) ▁+ ▁1 ▁) ▁; ▁else ▁freq ▁. ▁put ▁( ▁str 3 ▁. ▁charAt ▁( ▁i ▁) ▁, ▁1 ▁) ▁; ▁} ▁int ▁ptr 1 ▁= ▁0 ▁; ▁int ▁ptr 2 ▁= ▁0 ▁; ▁boolean ▁flag ▁= ▁true ▁; ▁while ▁( ▁ptr 1 ▁< ▁str 1 ▁. ▁length ▁( ▁) ▁&& ▁ptr 2 ▁< ▁str 2 ▁. ▁length ▁( ▁) ▁) ▁{ ▁if ▁( ▁str 1 ▁. ▁charAt ▁( ▁ptr 1 ▁) ▁== ▁str 2 ▁. ▁charAt ▁( ▁ptr 2 ▁) ▁) ▁{ ▁ptr 1 ▁++ ▁; ▁ptr 2 ▁++ ▁; ▁} ▁else ▁{ ▁if ▁( ▁freq ▁. ▁containsKey ▁( ▁str 3 ▁. ▁charAt ▁( ▁ptr 2 ▁) ▁) ▁) ▁if ▁( ▁freq ▁. ▁get ▁( ▁str 3 ▁. ▁charAt ▁( ▁ptr 2 ▁) ▁) ▁> ▁0 ▁) ▁{ ▁freq ▁. ▁put ▁( ▁str 3 ▁. ▁charAt ▁( ▁ptr 2 ▁) ▁, ▁freq ▁. ▁get ▁( ▁str 3 ▁. ▁charAt ▁( ▁ptr 2 ▁) ▁) ▁- ▁1 ▁) ▁; ▁ptr 2 ▁++ ▁; ▁} ▁else ▁{ ▁flag ▁= ▁false ▁; ▁break ▁; ▁} ▁} ▁} ▁if ▁( ▁flag ▁&& ▁ptr 1 ▁== ▁str 1 ▁. ▁length ▁( ▁) ▁&& ▁ptr 2 ▁== ▁str 2 ▁. ▁length ▁( ▁) ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁YES ▁" ▁+ ▁" NEW _ LINE "); ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁NO ▁" ▁+ ▁" NEW _ LINE "); ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str 1 ▁= ▁" ▁ab yz fe ▁" ▁; ▁String ▁str 2 ▁= ▁" ▁abcd ey z f ▁" ▁; ▁String ▁str 3 ▁= ▁" ▁pop ode ▁" ▁; ▁convert String ▁( ▁str 1 ▁, ▁str 2 ▁, ▁str 3 ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁void ▁distinct ▁( ▁String ▁[ ▁] ▁S ▁, ▁int ▁M ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁S ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁Set ▁< ▁Character ▁> ▁set ▁= ▁new ▁HashSet ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁S ▁[ ▁i ▁] ▁. ▁length ▁( ▁) ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁! ▁set ▁. ▁contains ▁( ▁S ▁[ ▁i ▁] ▁. ▁charAt ▁( ▁j ▁) ▁) ▁) ▁set ▁. ▁add ▁( ▁S ▁[ ▁i ▁] ▁. ▁charAt ▁( ▁j ▁) ▁) ▁; ▁} ▁int ▁c ▁= ▁set ▁. ▁size ▁( ▁) ▁; ▁if ▁( ▁c ▁<= ▁M ▁) ▁count ▁+= ▁1 ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁count ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁S ▁[ ▁] ▁= ▁{ ▁" ▁H ER BI VO RES ▁" ▁, ▁" ▁A ER OP LA NE ▁" ▁, ▁" ▁G EEK S FOR GE EK S ▁" ▁} ▁; ▁int ▁M ▁= ▁7 ▁; ▁distinct ▁( ▁S ▁, ▁M ▁) ▁; ▁} ▁}
▁public ▁class ▁G F G ▁{ ▁static ▁void ▁string ▁( ▁int ▁l ▁, ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁int ▁p ▁= ▁97 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁l ▁; ▁j ▁++ ▁) ▁{ ▁char ▁ans ▁= ▁( ▁char ▁) ▁( ▁p ▁+ ▁( ▁j ▁% ▁y ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁ans ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁l ▁= ▁6 ▁; ▁int ▁x ▁= ▁5 ▁; ▁int ▁y ▁= ▁3 ▁; ▁string ▁( ▁l ▁, ▁x ▁, ▁y ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁find Period ic String ▁( ▁String ▁S ▁) ▁{ ▁int ▁l ▁= ▁2 ▁* ▁S ▁. ▁length ▁( ▁) ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁S ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁S ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'1' ▁) ▁count ▁++ ▁; ▁} ▁if ▁( ▁count ▁== ▁S ▁. ▁length ▁( ▁) ▁count ▁== ▁0 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁S ▁) ▁; ▁else ▁{ ▁char ▁arr ▁[ ▁] ▁= ▁new ▁char ▁[ ▁l ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁l ▁; ▁i ▁+= ▁2 ▁) ▁{ ▁arr ▁[ ▁i ▁] ▁= ▁'1' ▁; ▁arr ▁[ ▁i ▁+ ▁1 ▁] ▁= ▁'0' ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁l ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁S ▁= ▁" 1111 00 1" ▁; ▁find Period ic String ▁( ▁S ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁group _ formed ▁( ▁String ▁S ▁) ▁{ ▁int ▁count ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁S ▁. ▁length ▁( ▁) ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁S ▁. ▁charAt ▁( ▁i ▁) ▁!= ▁S ▁. ▁charAt ▁( ▁i ▁+ ▁1 ▁) ▁) ▁count ▁+= ▁1 ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁count ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁S ▁= ▁" ▁TT WW W ▁" ▁; ▁group _ formed ▁( ▁S ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁String ▁Reverse Com plement ▁( ▁char ▁[ ▁] ▁s ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁rev ▁= ▁( ▁k ▁+ ▁1 ▁) ▁/ ▁2 ▁; ▁int ▁complement ▁= ▁k ▁- ▁rev ▁; ▁if ▁( ▁rev ▁% ▁2 ▁== ▁1 ▁) ▁s ▁= ▁reverse ▁( ▁s ▁) ▁; ▁if ▁( ▁complement ▁% ▁2 ▁== ▁1 ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁[ ▁i ▁] ▁== ▁'0' ▁) ▁s ▁[ ▁i ▁] ▁= ▁'1' ▁; ▁else ▁s ▁[ ▁i ▁] ▁= ▁'0' ▁; ▁} ▁} ▁return ▁String ▁. ▁valueOf ▁( ▁s ▁) ▁; ▁} ▁static ▁char ▁[ ▁] ▁reverse ▁( ▁char ▁a ▁[ ▁] ▁) ▁{ ▁int ▁i ▁, ▁n ▁= ▁a ▁. ▁length ▁; ▁char ▁t ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁/ ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁t ▁= ▁a ▁[ ▁i ▁] ▁; ▁a ▁[ ▁i ▁] ▁= ▁a ▁[ ▁n ▁- ▁i ▁- ▁1 ▁] ▁; ▁a ▁[ ▁n ▁- ▁i ▁- ▁1 ▁] ▁= ▁t ▁; ▁} ▁return ▁a ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁"100 11" ▁; ▁int ▁k ▁= ▁5 ▁; ▁int ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁Reverse Com plement ▁( ▁str ▁. ▁toCharArray ▁( ▁) ▁, ▁n ▁, ▁k ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁boolean ▁repeating String ▁( ▁String ▁s ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁if ▁( ▁n ▁% ▁k ▁!= ▁0 ▁) ▁{ ▁return ▁false ▁; ▁} ▁int ▁[ ▁] ▁frequency ▁= ▁new ▁int ▁[ ▁123 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁123 ▁; ▁i ▁++ ▁) ▁{ ▁frequency ▁[ ▁i ▁] ▁= ▁0 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁frequency ▁[ ▁s ▁. ▁charAt ▁( ▁i ▁) ▁] ▁++ ▁; ▁} ▁int ▁repeat ▁= ▁n ▁/ ▁k ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁123 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁frequency ▁[ ▁i ▁] ▁% ▁repeat ▁!= ▁0 ▁) ▁{ ▁return ▁false ▁; ▁} ▁} ▁return ▁true ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁s ▁= ▁" ▁abcd cb a ▁" ▁; ▁int ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁int ▁k ▁= ▁3 ▁; ▁if ▁( ▁repeating String ▁( ▁s ▁, ▁n ▁, ▁k ▁) ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Yes ▁" ▁+ ▁" NEW _ LINE "); ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁No ▁" ▁+ ▁" NEW _ LINE "); ▁} ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁print Value ▁( ▁char ▁digit ▁) ▁{ ▁switch ▁( ▁digit ▁) ▁{ ▁case ▁'0' ▁: ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Zero ▁" ▁) ▁; ▁break ▁; ▁case ▁'1' ▁: ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁One ▁" ▁) ▁; ▁break ▁; ▁case ▁'2' ▁: ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Two ▁" ▁) ▁; ▁break ▁; ▁case ▁'3' ▁: ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Three ▁" ▁) ▁; ▁break ▁; ▁case ▁'4' ▁: ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Four ▁" ▁) ▁; ▁break ▁; ▁case ▁'5' ▁: ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁F ive ▁" ▁) ▁; ▁break ▁; ▁case ▁'6' ▁: ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁S ix ▁" ▁) ▁; ▁break ▁; ▁case ▁'7' ▁: ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁S even ▁" ▁) ▁; ▁break ▁; ▁case ▁'8' ▁: ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁E ight ▁" ▁) ▁; ▁break ▁; ▁case ▁'9' ▁: ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁N ine ▁" ▁) ▁; ▁break ▁; ▁} ▁} ▁static ▁void ▁print Word ▁( ▁String ▁N ▁) ▁{ ▁int ▁i ▁, ▁length ▁= ▁N ▁. ▁length ▁( ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁length ▁; ▁i ▁++ ▁) ▁{ ▁print Value ▁( ▁N ▁. ▁charAt ▁( ▁i ▁) ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁N ▁= ▁"123" ▁; ▁print Word ▁( ▁N ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁double ▁jar o _ distance ▁( ▁String ▁s 1 ▁, ▁String ▁s 2 ▁) ▁{ ▁if ▁( ▁s 1 ▁== ▁s 2 ▁) ▁return ▁1.0 ▁; ▁int ▁len 1 ▁= ▁s 1 ▁. ▁length ▁( ▁) ▁, ▁len 2 ▁= ▁s 2 ▁. ▁length ▁( ▁) ▁; ▁int ▁max _ dist ▁= ▁( ▁int ▁) ▁( ▁Math ▁. ▁floor ▁( ▁Math ▁. ▁max ▁( ▁len 1 ▁, ▁len 2 ▁) ▁/ ▁2 ▁) ▁- ▁1 ▁) ▁; ▁int ▁match ▁= ▁0 ▁; ▁int ▁hash _ s 1 ▁[ ▁] ▁= ▁new ▁int ▁[ ▁s 1 ▁. ▁length ▁( ▁) ▁] ▁; ▁int ▁hash _ s 2 ▁[ ▁] ▁= ▁new ▁int ▁[ ▁s 2 ▁. ▁length ▁( ▁) ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁len 1 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁Math ▁. ▁max ▁( ▁0 ▁, ▁i ▁- ▁max _ dist ▁) ▁; ▁j ▁< ▁Math ▁. ▁min ▁( ▁len 2 ▁, ▁i ▁+ ▁max _ dist ▁+ ▁1 ▁) ▁; ▁j ▁++ ▁) ▁if ▁( ▁s 1 ▁. ▁charAt ▁( ▁i ▁) ▁== ▁s 2 ▁. ▁charAt ▁( ▁j ▁) ▁&& ▁hash _ s 2 ▁[ ▁j ▁] ▁== ▁0 ▁) ▁{ ▁hash _ s 1 ▁[ ▁i ▁] ▁= ▁1 ▁; ▁hash _ s 2 ▁[ ▁j ▁] ▁= ▁1 ▁; ▁match ▁++ ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁match ▁== ▁0 ▁) ▁return ▁0.0 ▁; ▁double ▁t ▁= ▁0 ▁; ▁int ▁point ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁len 1 ▁; ▁i ▁++ ▁) ▁if ▁( ▁hash _ s 1 ▁[ ▁i ▁] ▁== ▁1 ▁) ▁{ ▁while ▁( ▁hash _ s 2 ▁[ ▁point ▁] ▁== ▁0 ▁) ▁point ▁++ ▁; ▁if ▁( ▁s 1 ▁. ▁charAt ▁( ▁i ▁) ▁!= ▁s 2 ▁. ▁charAt ▁( ▁point ▁++ ▁) ▁) ▁t ▁++ ▁; ▁} ▁t ▁/= ▁2 ▁; ▁return ▁( ▁( ▁( ▁double ▁) ▁match ▁) ▁/ ▁( ▁( ▁double ▁) ▁len 1 ▁) ▁+ ▁( ▁( ▁double ▁) ▁match ▁) ▁/ ▁( ▁( ▁double ▁) ▁len 2 ▁) ▁+ ▁( ▁( ▁double ▁) ▁match ▁- ▁t ▁) ▁/ ▁( ▁( ▁double ▁) ▁match ▁) ▁) ▁/ ▁3.0 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁s 1 ▁= ▁" ▁CR ATE ▁" ▁, ▁s 2 ▁= ▁" ▁TRACE ▁" ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁jar o _ distance ▁( ▁s 1 ▁, ▁s 2 ▁) ▁+ ▁" NEW _ LINE "); ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁find Min Sw aps ▁( ▁String ▁s ▁, ▁int ▁k ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁int ▁c _ one ▁= ▁0 ▁, ▁c _ zero ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁s ▁. ▁length ▁( ▁) ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'1' ▁) ▁c _ one ▁++ ▁; ▁if ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'0' ▁) ▁{ ▁c _ zero ▁++ ▁; ▁ans ▁+= ▁c _ one ▁; ▁} ▁if ▁( ▁c _ zero ▁== ▁k ▁) ▁break ▁; ▁} ▁if ▁( ▁c _ zero ▁< ▁k ▁) ▁return ▁- ▁1 ▁; ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁s ▁= ▁"100 11 1" ▁; ▁int ▁k ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Min Sw aps ▁( ▁s ▁, ▁k ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁class ▁Node ▁{ ▁char ▁data ▁; ▁Node ▁left ▁, ▁right ▁; ▁Node ▁( ▁char ▁_ val ▁) ▁{ ▁data ▁= ▁_ val ▁; ▁left ▁= ▁right ▁= ▁null ▁; ▁} ▁} ▁; ▁static ▁Node ▁add in BT ▁( ▁Node ▁root ▁, ▁char ▁data ▁) ▁{ ▁if ▁( ▁root ▁== ▁null ▁) ▁{ ▁root ▁= ▁new ▁Node ▁( ▁data ▁) ▁; ▁} ▁else ▁{ ▁Queue ▁< ▁Node ▁> ▁Q ▁= ▁new ▁LinkedList ▁< ▁Node ▁> ▁( ▁) ▁; ▁Q ▁. ▁add ▁( ▁root ▁) ▁; ▁while ▁( ▁! ▁Q ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁Node ▁temp ▁= ▁Q ▁. ▁peek ▁( ▁) ▁; ▁Q ▁. ▁remove ▁( ▁) ▁; ▁if ▁( ▁temp ▁. ▁left ▁== ▁null ▁) ▁{ ▁temp ▁. ▁left ▁= ▁new ▁Node ▁( ▁data ▁) ▁; ▁break ▁; ▁} ▁else ▁Q ▁. ▁add ▁( ▁temp ▁. ▁left ▁) ▁; ▁if ▁( ▁temp ▁. ▁right ▁== ▁null ▁) ▁{ ▁temp ▁. ▁right ▁= ▁new ▁Node ▁( ▁data ▁) ▁; ▁break ▁; ▁} ▁else ▁Q ▁. ▁add ▁( ▁temp ▁. ▁right ▁) ▁; ▁} ▁} ▁return ▁root ▁; ▁} ▁static ▁void ▁print ▁( ▁Node ▁root ▁) ▁{ ▁Queue ▁< ▁Node ▁> ▁Q ▁= ▁new ▁LinkedList ▁< ▁Node ▁> ▁( ▁) ▁; ▁Q ▁. ▁add ▁( ▁root ▁) ▁; ▁while ▁( ▁Q ▁. ▁size ▁( ▁) ▁> ▁0 ▁) ▁{ ▁Node ▁temp ▁= ▁Q ▁. ▁peek ▁( ▁) ▁; ▁Q ▁. ▁remove ▁( ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁temp ▁. ▁data ▁) ▁; ▁if ▁( ▁temp ▁. ▁left ▁!= ▁null ▁) ▁Q ▁. ▁add ▁( ▁temp ▁. ▁left ▁) ▁; ▁if ▁( ▁temp ▁. ▁right ▁!= ▁null ▁) ▁Q ▁. ▁add ▁( ▁temp ▁. ▁right ▁) ▁; ▁} ▁} ▁static ▁boolean ▁check v ow el ▁( ▁char ▁ch ▁) ▁{ ▁ch ▁= ▁Character ▁. ▁toLowerCase ▁( ▁ch ▁) ▁; ▁if ▁( ▁ch ▁== ▁' ▁a ▁' ▁ch ▁== ▁' ▁e ▁' ▁ch ▁== ▁' ▁i ▁' ▁ch ▁== ▁' ▁o ▁' ▁ch ▁== ▁' ▁u ▁' ▁) ▁{ ▁return ▁true ▁; ▁} ▁else ▁{ ▁return ▁false ▁; ▁} ▁} ▁static ▁Node ▁remove v ow els ▁( ▁Node ▁root ▁) ▁{ ▁Queue ▁< ▁Node ▁> ▁Q ▁= ▁new ▁LinkedList ▁< ▁Node ▁> ▁( ▁) ▁; ▁Q ▁. ▁add ▁( ▁root ▁) ▁; ▁Node ▁root 1 ▁= ▁null ▁; ▁while ▁( ▁! ▁Q ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁Node ▁temp ▁= ▁Q ▁. ▁peek ▁( ▁) ▁; ▁Q ▁. ▁remove ▁( ▁) ▁; ▁if ▁( ▁! ▁check v ow el ▁( ▁temp ▁. ▁data ▁) ▁) ▁{ ▁root 1 ▁= ▁add in BT ▁( ▁root 1 ▁, ▁temp ▁. ▁data ▁) ▁; ▁} ▁if ▁( ▁temp ▁. ▁left ▁!= ▁null ▁) ▁{ ▁Q ▁. ▁add ▁( ▁temp ▁. ▁left ▁) ▁; ▁} ▁if ▁( ▁temp ▁. ▁right ▁!= ▁null ▁) ▁{ ▁Q ▁. ▁add ▁( ▁temp ▁. ▁right ▁) ▁; ▁} ▁} ▁return ▁root 1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁s ▁= ▁" ▁g eek s ▁" ▁; ▁Node ▁root ▁= ▁null ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁root ▁= ▁add in BT ▁( ▁root ▁, ▁s ▁. ▁charAt ▁( ▁i ▁) ▁) ▁; ▁} ▁root ▁= ▁remove v ow els ▁( ▁root ▁) ▁; ▁print ▁( ▁root ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁final ▁int ▁N ▁= ▁2 ▁; ▁static ▁Boolean ▁is V ow el ▁( ▁char ▁ch ▁) ▁{ ▁return ▁( ▁ch ▁== ▁' ▁a ▁' ▁ch ▁== ▁' ▁e ▁' ▁ch ▁== ▁' ▁i ▁' ▁ch ▁== ▁' ▁o ▁' ▁ch ▁== ▁' ▁u ▁' ▁) ▁; ▁} ▁static ▁void ▁perform Queries ▁( ▁String ▁str ▁, ▁int ▁len ▁, ▁int ▁queries ▁[ ▁] ▁[ ▁] ▁, ▁int ▁q ▁) ▁{ ▁int ▁[ ▁] ▁pre ▁= ▁new ▁int ▁[ ▁len ▁] ▁; ▁if ▁( ▁is V ow el ▁( ▁str ▁. ▁charAt ▁( ▁0 ▁) ▁) ▁) ▁pre ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁else ▁pre ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁len ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁is V ow el ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁) ▁) ▁pre ▁[ ▁i ▁] ▁= ▁1 ▁+ ▁pre ▁[ ▁i ▁- ▁1 ▁] ▁; ▁else ▁pre ▁[ ▁i ▁] ▁= ▁pre ▁[ ▁i ▁- ▁1 ▁] ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁q ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁queries ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁== ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁pre ▁[ ▁queries ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁] ▁) ▁; ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁( ▁pre ▁[ ▁queries ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁] ▁- ▁pre ▁[ ▁queries ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁- ▁1 ▁] ▁) ▁) ▁; ▁} ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁" ▁g eek s forge ek s ▁" ▁; ▁int ▁len ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁int ▁queries ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁3 ▁} ▁, ▁{ ▁2 ▁, ▁4 ▁} ▁, ▁{ ▁1 ▁, ▁9 ▁} ▁} ▁; ▁int ▁q ▁= ▁queries ▁. ▁length ▁; ▁perform Queries ▁( ▁str ▁, ▁len ▁, ▁queries ▁, ▁q ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁max N ▁= ▁20 ▁; ▁static ▁int ▁max M ▁= ▁64 ▁; ▁static ▁int ▁cnt Splits ▁( ▁String ▁s ▁) ▁{ ▁if ▁( ▁s ▁. ▁charAt ▁( ▁s ▁. ▁length ▁( ▁) ▁- ▁1 ▁) ▁== ▁'1' ▁) ▁return ▁0 ▁; ▁int ▁c _ zero ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁c _ zero ▁+= ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'0' ▁) ▁? ▁1 ▁: ▁0 ▁; ▁return ▁( ▁int ▁) ▁Math ▁. ▁pow ▁( ▁2 ▁, ▁c _ zero ▁- ▁1 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁s ▁= ▁"100 10" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁cnt Splits ▁( ▁s ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁String ▁dec To Binary ▁( ▁int ▁n ▁) ▁{ ▁int ▁[ ▁] ▁binary Num ▁= ▁new ▁int ▁[ ▁32 ▁] ▁; ▁int ▁i ▁= ▁0 ▁; ▁while ▁( ▁n ▁> ▁0 ▁) ▁{ ▁binary Num ▁[ ▁i ▁] ▁= ▁n ▁% ▁2 ▁; ▁n ▁= ▁n ▁/ ▁2 ▁; ▁i ▁++ ▁; ▁} ▁String ▁binary ▁= ▁" ▁" ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁- ▁1 ▁; ▁j ▁>= ▁0 ▁; ▁j ▁-- ▁) ▁{ ▁binary ▁+= ▁String ▁. ▁valueOf ▁( ▁binary Num ▁[ ▁j ▁] ▁) ▁; ▁} ▁return ▁binary ▁; ▁} ▁static ▁int ▁count Freq ▁( ▁String ▁pat ▁, ▁String ▁txt ▁) ▁{ ▁int ▁M ▁= ▁pat ▁. ▁length ▁( ▁) ▁; ▁int ▁N ▁= ▁txt ▁. ▁length ▁( ▁) ▁; ▁int ▁res ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁N ▁- ▁M ▁; ▁i ▁++ ▁) ▁{ ▁int ▁j ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁M ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁txt ▁. ▁charAt ▁( ▁i ▁+ ▁j ▁) ▁!= ▁pat ▁. ▁charAt ▁( ▁j ▁) ▁) ▁{ ▁break ▁; ▁} ▁} ▁if ▁( ▁j ▁== ▁M ▁) ▁{ ▁res ▁++ ▁; ▁j ▁= ▁0 ▁; ▁} ▁} ▁return ▁res ▁; ▁} ▁static ▁void ▁find Occurrence ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁String ▁pattern ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁String ▁binary ▁= ▁dec To Binary ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁count Freq ▁( ▁pattern ▁, ▁binary ▁) ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁106 ▁, ▁7 ▁, ▁8 ▁} ▁; ▁String ▁pattern ▁= ▁"10" ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁find Occurrence ▁( ▁arr ▁, ▁n ▁, ▁pattern ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁find _ w inner ▁( ▁String ▁str ▁, ▁int ▁n ▁) ▁{ ▁String ▁str 1 ▁= ▁" ▁" ▁, ▁str 2 ▁= ▁" ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁str 1 ▁+= ▁str ▁. ▁charAt ▁( ▁i ▁) ▁; ▁} ▁else ▁{ ▁str 2 ▁+= ▁str ▁. ▁charAt ▁( ▁i ▁) ▁; ▁} ▁} ▁char ▁a ▁[ ▁] ▁= ▁str 1 ▁. ▁toCharArray ▁( ▁) ▁; ▁Arrays ▁. ▁sort ▁( ▁a ▁) ▁; ▁char ▁b ▁[ ▁] ▁= ▁str 2 ▁. ▁toCharArray ▁( ▁) ▁; ▁Arrays ▁. ▁sort ▁( ▁b ▁) ▁; ▁str 1 ▁= ▁new ▁String ▁( ▁a ▁) ▁; ▁str 2 ▁= ▁new ▁String ▁( ▁b ▁) ▁; ▁if ▁( ▁str 1 ▁. ▁compareTo ▁( ▁str 2 ▁) ▁< ▁0 ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁A ▁" ▁) ▁; ▁else ▁if ▁( ▁str 1 ▁. ▁compareTo ▁( ▁str 2 ▁) ▁> ▁0 ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁B ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁T ie ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁" ▁g eek s forge ek s ▁" ▁; ▁int ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁find _ w inner ▁( ▁str ▁, ▁n ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁is V ow el ▁( ▁char ▁ch ▁) ▁{ ▁ch ▁= ▁Character ▁. ▁toUpperCase ▁( ▁ch ▁) ▁; ▁return ▁( ▁ch ▁== ▁' ▁A ▁' ▁ch ▁== ▁' ▁E ▁' ▁ch ▁== ▁' ▁I ▁' ▁ch ▁== ▁' ▁O ▁' ▁ch ▁== ▁' ▁U ▁' ▁) ▁; ▁} ▁static ▁String ▁duplicate V ow els ▁( ▁String ▁str ▁) ▁{ ▁int ▁t ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁String ▁res ▁= ▁" ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁t ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁is V ow el ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁) ▁) ▁res ▁+= ▁str ▁. ▁charAt ▁( ▁i ▁) ▁; ▁res ▁+= ▁str ▁. ▁charAt ▁( ▁i ▁) ▁; ▁} ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁" ▁hel loworld ▁" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Original ▁String ▁: ▁" ▁+ ▁str ▁) ▁; ▁String ▁res ▁= ▁duplicate V ow els ▁( ▁str ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁String ▁with ▁V ow els ▁duplicated ▁: ▁" ▁+ ▁res ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁public ▁static ▁String ▁replace Pi ▁( ▁String ▁s ▁) ▁{ ▁if ▁( ▁s ▁. ▁length ▁( ▁) ▁== ▁0 ▁|| ▁s ▁. ▁length ▁( ▁) ▁== ▁1 ▁) ▁return ▁s ▁; ▁if ▁( ▁s ▁. ▁charAt ▁( ▁0 ▁) ▁== ▁' ▁p ▁' ▁&& ▁s ▁. ▁charAt ▁( ▁1 ▁) ▁== ▁' ▁i ▁' ▁) ▁{ ▁String ▁small Output ▁= ▁replace Pi ▁( ▁s ▁. ▁substring ▁( ▁2 ▁) ▁) ▁; ▁return ▁" 3.1 4" ▁+ ▁small Output ▁; ▁} ▁else ▁{ ▁String ▁small Output ▁= ▁replace Pi ▁( ▁s ▁. ▁substring ▁( ▁1 ▁) ▁) ▁; ▁return ▁s ▁. ▁charAt ▁( ▁0 ▁) ▁+ ▁small Output ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁s ▁= ▁" ▁pi pp pi i ip i ▁" ▁; ▁String ▁result ▁= ▁replace Pi ▁( ▁s ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁result ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁MAX ▁= ▁26 ▁; ▁static ▁int ▁largest Sub Seq ▁( ▁String ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁[ ▁] ▁count ▁= ▁new ▁int ▁[ ▁MAX ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁String ▁str ▁= ▁arr ▁[ ▁i ▁] ▁; ▁boolean ▁[ ▁] ▁hash ▁= ▁new ▁boolean ▁[ ▁MAX ▁] ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁str ▁. ▁length ▁( ▁) ▁; ▁j ▁++ ▁) ▁{ ▁hash ▁[ ▁str ▁. ▁charAt ▁( ▁j ▁) ▁- ▁' ▁a ▁' ▁] ▁= ▁true ▁; ▁} ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁MAX ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁hash ▁[ ▁j ▁] ▁) ▁count ▁[ ▁j ▁] ▁++ ▁; ▁} ▁} ▁int ▁max ▁= ▁- ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁MAX ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁max ▁< ▁count ▁[ ▁i ▁] ▁) ▁max ▁= ▁count ▁[ ▁i ▁] ▁; ▁} ▁return ▁max ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁arr ▁[ ▁] ▁= ▁{ ▁" ▁ab ▁" ▁, ▁" ▁bc ▁" ▁, ▁" ▁de ▁" ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁largest Sub Seq ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁HashSet ▁; ▁class ▁G F G ▁{ ▁static ▁HashSet ▁< ▁String ▁> ▁string Set ▁= ▁new ▁HashSet ▁< ▁> ▁( ▁) ▁; ▁public ▁static ▁void ▁find _ perm utation ▁( ▁String ▁str 1 ▁, ▁String ▁str 2 ▁, ▁int ▁len 1 ▁, ▁int ▁len 2 ▁, ▁int ▁i ▁, ▁int ▁j ▁, ▁String ▁res ▁) ▁{ ▁if ▁( ▁res ▁. ▁length ▁( ▁) ▁== ▁len 1 ▁+ ▁len 2 ▁) ▁{ ▁string Set ▁. ▁add ▁( ▁res ▁) ▁; ▁return ▁; ▁} ▁if ▁( ▁i ▁< ▁len 1 ▁) ▁find _ perm utation ▁( ▁str 1 ▁, ▁str 2 ▁, ▁len 1 ▁, ▁len 2 ▁, ▁i ▁+ ▁1 ▁, ▁j ▁, ▁res ▁+ ▁str 1 ▁. ▁charAt ▁( ▁i ▁) ▁) ▁; ▁if ▁( ▁j ▁< ▁len 2 ▁) ▁find _ perm utation ▁( ▁str 1 ▁, ▁str 2 ▁, ▁len 1 ▁, ▁len 2 ▁, ▁i ▁, ▁j ▁+ ▁1 ▁, ▁res ▁+ ▁str 2 ▁. ▁charAt ▁( ▁j ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁print _ set ▁( ▁) ▁{ ▁for ▁( ▁String ▁s ▁: ▁string Set ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁s ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str 1 ▁= ▁" ▁aa ▁" ▁, ▁str 2 ▁= ▁" ▁ab ▁" ▁; ▁int ▁len 1 ▁= ▁str 1 ▁. ▁length ▁( ▁) ▁; ▁int ▁len 2 ▁= ▁str 2 ▁. ▁length ▁( ▁) ▁; ▁find _ perm utation ▁( ▁str 1 ▁, ▁str 2 ▁, ▁len 1 ▁, ▁len 2 ▁, ▁0 ▁, ▁0 ▁, ▁" ▁" ▁) ▁; ▁print _ set ▁( ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁count Sub Str ▁( ▁char ▁[ ▁] ▁s ▁, ▁int ▁n ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁2 ▁{ ▁if ▁( ▁s ▁[ ▁i ▁] ▁== ▁'0' ▁&& ▁s ▁[ ▁i ▁+ ▁1 ▁] ▁== ▁'1' ▁&& ▁s ▁[ ▁i ▁+ ▁2 ▁] ▁== ▁'0' ▁) ▁{ ▁count ▁++ ▁; ▁i ▁+= ▁3 ▁; ▁} ▁else ▁if ▁( ▁s ▁[ ▁i ▁] ▁== ▁'1' ▁&& ▁s ▁[ ▁i ▁+ ▁1 ▁] ▁== ▁'0' ▁&& ▁s ▁[ ▁i ▁+ ▁2 ▁] ▁== ▁'1' ▁) ▁{ ▁count ▁++ ▁; ▁i ▁+= ▁3 ▁; ▁} ▁else ▁{ ▁i ▁++ ▁; ▁} ▁} ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁char ▁[ ▁] ▁s ▁= ▁"1 0101 0101 01" ▁. ▁toCharArray ▁( ▁) ▁; ▁int ▁n ▁= ▁s ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Sub Str ▁( ▁s ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁HashSet ▁; ▁class ▁g eek s ▁{ ▁public ▁static ▁int ▁count Total Distinct ▁( ▁String ▁str ▁) ▁{ ▁int ▁cnt ▁= ▁0 ▁; ▁HashSet ▁< ▁String ▁> ▁items ▁= ▁new ▁HashSet ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁str ▁. ▁length ▁( ▁) ▁; ▁++ ▁i ▁) ▁{ ▁String ▁temp ▁= ▁" ▁" ▁; ▁HashSet ▁< ▁Character ▁> ▁ans ▁= ▁new ▁HashSet ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁< ▁str ▁. ▁length ▁( ▁) ▁; ▁++ ▁j ▁) ▁{ ▁temp ▁= ▁temp ▁+ ▁str ▁. ▁charAt ▁( ▁j ▁) ▁; ▁ans ▁. ▁add ▁( ▁str ▁. ▁charAt ▁( ▁j ▁) ▁) ▁; ▁if ▁( ▁! ▁items ▁. ▁contains ▁( ▁temp ▁) ▁) ▁{ ▁items ▁. ▁add ▁( ▁temp ▁) ▁; ▁cnt ▁+= ▁ans ▁. ▁size ▁( ▁) ▁; ▁} ▁} ▁} ▁return ▁cnt ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁" ▁AB CA ▁" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Total Distinct ▁( ▁str ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁import ▁java ▁. ▁util ▁. ▁Stack ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁reverse ▁( ▁String ▁k ▁) ▁{ ▁Stack ▁< ▁String ▁> ▁s ▁= ▁new ▁Stack ▁< ▁> ▁( ▁) ▁; ▁String ▁[ ▁] ▁token ▁= ▁k ▁. ▁split ▁( ▁" ▁" ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁token ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁s ▁. ▁push ▁( ▁token ▁[ ▁i ▁] ▁) ▁; ▁} ▁while ▁( ▁! ▁s ▁. ▁empty ▁( ▁) ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁s ▁. ▁peek ▁( ▁) ▁+ ▁" ▁" ▁) ▁; ▁s ▁. ▁pop ▁( ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁k ▁= ▁" ▁g eek s ▁for ▁g eek s ▁" ▁; ▁reverse ▁( ▁k ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁boolean ▁isP al in ▁( ▁int ▁i ▁, ▁int ▁j ▁, ▁int ▁k ▁, ▁int ▁l ▁, ▁int ▁p ▁, ▁int ▁q ▁, ▁String ▁s ▁) ▁{ ▁int ▁start ▁= ▁i ▁, ▁end ▁= ▁q ▁; ▁while ▁( ▁start ▁< ▁end ▁) ▁{ ▁if ▁( ▁s ▁. ▁charAt ▁( ▁start ▁) ▁!= ▁s ▁. ▁charAt ▁( ▁end ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁start ▁++ ▁; ▁if ▁( ▁start ▁== ▁j ▁+ ▁1 ▁) ▁{ ▁start ▁= ▁k ▁; ▁} ▁end ▁-- ▁; ▁if ▁( ▁end ▁== ▁p ▁- ▁1 ▁) ▁{ ▁end ▁= ▁l ▁; ▁} ▁} ▁return ▁true ▁; ▁} ▁static ▁int ▁count Sub Str ▁( ▁String ▁s ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁int ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁< ▁n ▁- ▁2 ▁; ▁j ▁++ ▁) ▁{ ▁for ▁( ▁int ▁k ▁= ▁j ▁+ ▁1 ▁; ▁k ▁< ▁n ▁- ▁1 ▁; ▁k ▁++ ▁) ▁{ ▁for ▁( ▁int ▁l ▁= ▁k ▁; ▁l ▁< ▁n ▁- ▁1 ▁; ▁l ▁++ ▁) ▁{ ▁for ▁( ▁int ▁p ▁= ▁l ▁+ ▁1 ▁; ▁p ▁< ▁n ▁; ▁p ▁++ ▁) ▁{ ▁for ▁( ▁int ▁q ▁= ▁p ▁; ▁q ▁< ▁n ▁; ▁q ▁++ ▁) ▁{ ▁if ▁( ▁isP al in ▁( ▁i ▁, ▁j ▁, ▁k ▁, ▁l ▁, ▁p ▁, ▁q ▁, ▁s ▁) ▁) ▁{ ▁count ▁++ ▁; ▁} ▁} ▁} ▁} ▁} ▁} ▁} ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁s ▁= ▁" ▁ab ca ▁" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Sub Str ▁( ▁s ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁G F G ▁{ ▁static ▁final ▁int ▁MAX ▁= ▁256 ▁; ▁static ▁String ▁last Non Repe ating ▁( ▁String ▁str ▁, ▁int ▁n ▁) ▁{ ▁int ▁freq ▁[ ▁] ▁= ▁new ▁int ▁[ ▁MAX ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁freq ▁[ ▁str ▁. ▁charAt ▁( ▁i ▁) ▁] ▁++ ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁char ▁ch ▁= ▁str ▁. ▁charAt ▁( ▁i ▁) ▁; ▁if ▁( ▁freq ▁[ ▁ch ▁] ▁== ▁1 ▁) ▁return ▁( ▁" ▁" ▁+ ▁ch ▁) ▁; ▁} ▁return ▁" ▁- ▁1" ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁" ▁G eek s For G eek s ▁" ▁; ▁int ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁last Non Repe ating ▁( ▁str ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁N ▁= ▁4 ▁; ▁static ▁int ▁perform Queries ▁( ▁int ▁l ▁, ▁int ▁r ▁, ▁int ▁prefix ▁[ ▁] ▁[ ▁] ▁) ▁{ ▁l ▁-- ▁; ▁r ▁-- ▁; ▁boolean ▁flag ▁= ▁false ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁26 ▁; ▁i ▁++ ▁) ▁{ ▁int ▁cnt ▁= ▁prefix ▁[ ▁r ▁] ▁[ ▁i ▁] ▁; ▁if ▁( ▁l ▁> ▁0 ▁) ▁cnt ▁-= ▁prefix ▁[ ▁l ▁- ▁1 ▁] ▁[ ▁i ▁] ▁; ▁if ▁( ▁cnt ▁% ▁2 ▁== ▁1 ▁) ▁{ ▁flag ▁= ▁true ▁; ▁count ▁+= ▁cnt ▁- ▁1 ▁; ▁} ▁else ▁count ▁+= ▁cnt ▁; ▁} ▁if ▁( ▁flag ▁) ▁count ▁+= ▁1 ▁; ▁return ▁count ▁; ▁} ▁static ▁void ▁pre Calculate ▁( ▁String ▁s ▁, ▁int ▁prefix ▁[ ▁] ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁prefix ▁[ ▁i ▁] ▁[ ▁s ▁. ▁charAt ▁( ▁i ▁) ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁26 ▁; ▁j ▁++ ▁) ▁prefix ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+= ▁prefix ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁String ▁s ▁= ▁" ▁am im ▁" ▁; ▁int ▁prefix ▁[ ▁] ▁[ ▁] ▁= ▁new ▁int ▁[ ▁N ▁] ▁[ ▁26 ▁] ▁; ▁pre Calculate ▁( ▁s ▁, ▁prefix ▁) ▁; ▁int ▁queries ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁4 ▁} ▁, ▁{ ▁3 ▁, ▁4 ▁} ▁} ▁; ▁int ▁q ▁= ▁queries ▁. ▁length ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁q ▁; ▁i ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁perform Queries ▁( ▁queries ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁, ▁queries ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁, ▁prefix ▁) ▁) ▁; ▁} ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁String ▁First And Last ▁( ▁String ▁str ▁) ▁{ ▁char ▁[ ▁] ▁ch ▁= ▁str ▁. ▁toCharArray ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁ch ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁int ▁k ▁= ▁i ▁; ▁while ▁( ▁i ▁< ▁ch ▁. ▁length ▁&& ▁ch ▁[ ▁i ▁] ▁!= ▁' ▁' ▁) ▁i ▁++ ▁; ▁ch ▁[ ▁k ▁] ▁= ▁( ▁char ▁) ▁( ▁ch ▁[ ▁k ▁] ▁>= ▁' ▁a ▁' ▁&& ▁ch ▁[ ▁k ▁] ▁<= ▁' ▁z ▁' ▁? ▁( ▁( ▁int ▁) ▁ch ▁[ ▁k ▁] ▁- ▁32 ▁) ▁: ▁( ▁int ▁) ▁ch ▁[ ▁k ▁] ▁) ▁; ▁ch ▁[ ▁i ▁- ▁1 ▁] ▁= ▁( ▁char ▁) ▁( ▁ch ▁[ ▁i ▁- ▁1 ▁] ▁>= ▁' ▁a ▁' ▁&& ▁ch ▁[ ▁i ▁- ▁1 ▁] ▁<= ▁' ▁z ▁' ▁? ▁( ▁( ▁int ▁) ▁ch ▁[ ▁i ▁- ▁1 ▁] ▁- ▁32 ▁) ▁: ▁( ▁int ▁) ▁ch ▁[ ▁i ▁- ▁1 ▁] ▁) ▁; ▁} ▁return ▁new ▁String ▁( ▁ch ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁String ▁str ▁= ▁" ▁G eek s ▁for ▁G eek s ▁" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁str ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁First And Last ▁( ▁str ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁[ ▁] ▁compute _ l ps ▁( ▁String ▁s ▁) ▁{ ▁int ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁int ▁[ ▁] ▁l ps ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁int ▁len ▁= ▁0 ▁; ▁l ps ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁int ▁i ▁= ▁1 ▁; ▁while ▁( ▁i ▁< ▁n ▁) ▁{ ▁if ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁== ▁s ▁. ▁charAt ▁( ▁len ▁) ▁) ▁{ ▁len ▁++ ▁; ▁l ps ▁[ ▁i ▁] ▁= ▁len ▁; ▁i ▁++ ▁; ▁} ▁else ▁{ ▁if ▁( ▁len ▁!= ▁0 ▁) ▁len ▁= ▁l ps ▁[ ▁len ▁- ▁1 ▁] ▁; ▁else ▁{ ▁l ps ▁[ ▁i ▁] ▁= ▁0 ▁; ▁i ▁++ ▁; ▁} ▁} ▁} ▁return ▁l ps ▁; ▁} ▁static ▁void ▁Long est substring ▁( ▁String ▁s ▁) ▁{ ▁int ▁[ ▁] ▁l ps ▁= ▁compute _ l ps ▁( ▁s ▁) ▁; ▁int ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁if ▁( ▁l ps ▁[ ▁n ▁- ▁1 ▁] ▁== ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁- ▁1 ▁) ▁; ▁return ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁l ps ▁[ ▁i ▁] ▁== ▁l ps ▁[ ▁n ▁- ▁1 ▁] ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁s ▁. ▁substring ▁( ▁0 ▁, ▁l ps ▁[ ▁i ▁] ▁) ▁) ▁; ▁return ▁; ▁} ▁} ▁if ▁( ▁l ps ▁[ ▁l ps ▁[ ▁n ▁- ▁1 ▁] ▁- ▁1 ▁] ▁== ▁0 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁- ▁1 ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁s ▁. ▁substring ▁( ▁0 ▁, ▁l ps ▁[ ▁l ps ▁[ ▁n ▁- ▁1 ▁] ▁- ▁1 ▁] ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁s ▁= ▁" ▁fix prefix suffix ▁" ▁; ▁Long est substring ▁( ▁s ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁String ▁find Max Len Even ▁( ▁String ▁str ▁) ▁{ ▁int ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁int ▁i ▁= ▁0 ▁; ▁int ▁cur rl en ▁= ▁0 ▁; ▁int ▁maxlen ▁= ▁0 ▁; ▁int ▁st ▁= ▁- ▁1 ▁; ▁while ▁( ▁i ▁< ▁n ▁) ▁{ ▁if ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁== ▁' ▁' ▁) ▁{ ▁if ▁( ▁cur rl en ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁if ▁( ▁maxlen ▁< ▁cur rl en ▁) ▁{ ▁maxlen ▁= ▁cur rl en ▁; ▁st ▁= ▁i ▁- ▁cur rl en ▁; ▁} ▁} ▁cur rl en ▁= ▁0 ▁; ▁} ▁else ▁{ ▁cur rl en ▁++ ▁; ▁} ▁i ▁++ ▁; ▁} ▁if ▁( ▁cur rl en ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁if ▁( ▁maxlen ▁< ▁cur rl en ▁) ▁{ ▁maxlen ▁= ▁cur rl en ▁; ▁st ▁= ▁i ▁- ▁cur rl en ▁; ▁} ▁} ▁if ▁( ▁st ▁== ▁- ▁1 ▁) ▁return ▁" ▁- ▁1" ▁; ▁return ▁str ▁. ▁substring ▁( ▁st ▁, ▁st ▁+ ▁maxlen ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁String ▁str ▁= ▁" ▁this ▁is ▁a ▁test ▁string ▁" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Max Len Even ▁( ▁str ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁String ▁find Min Len Str ▁( ▁String ▁str ▁, ▁int ▁k ▁) ▁{ ▁int ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁int ▁st ▁= ▁0 ▁; ▁int ▁end ▁= ▁0 ▁; ▁int ▁cnt ▁[ ▁] ▁= ▁new ▁int ▁[ ▁26 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁26 ▁; ▁i ▁++ ▁) ▁cnt ▁[ ▁i ▁] ▁= ▁0 ▁; ▁int ▁dist Ele ▁= ▁0 ▁; ▁int ▁cur rl en ▁; ▁int ▁min len ▁= ▁n ▁; ▁int ▁start Ind ▁= ▁- ▁1 ▁; ▁while ▁( ▁end ▁< ▁n ▁) ▁{ ▁cnt ▁[ ▁str ▁. ▁charAt ▁( ▁end ▁) ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁if ▁( ▁cnt ▁[ ▁str ▁. ▁charAt ▁( ▁end ▁) ▁- ▁' ▁a ▁' ▁] ▁== ▁1 ▁) ▁dist Ele ▁++ ▁; ▁if ▁( ▁dist Ele ▁> ▁k ▁) ▁{ ▁while ▁( ▁st ▁< ▁end ▁&& ▁dist Ele ▁> ▁k ▁) ▁{ ▁if ▁( ▁cnt ▁[ ▁str ▁. ▁charAt ▁( ▁st ▁) ▁- ▁' ▁a ▁' ▁] ▁== ▁1 ▁) ▁dist Ele ▁-- ▁; ▁cnt ▁[ ▁str ▁. ▁charAt ▁( ▁st ▁) ▁- ▁' ▁a ▁' ▁] ▁-- ▁; ▁st ▁++ ▁; ▁} ▁} ▁if ▁( ▁dist Ele ▁== ▁k ▁) ▁{ ▁while ▁( ▁st ▁< ▁end ▁&& ▁cnt ▁[ ▁str ▁. ▁charAt ▁( ▁st ▁) ▁- ▁' ▁a ▁' ▁] ▁> ▁1 ▁) ▁{ ▁cnt ▁[ ▁str ▁. ▁charAt ▁( ▁st ▁) ▁- ▁' ▁a ▁' ▁] ▁-- ▁; ▁st ▁++ ▁; ▁} ▁cur rl en ▁= ▁end ▁- ▁st ▁+ ▁1 ▁; ▁if ▁( ▁cur rl en ▁< ▁min len ▁) ▁{ ▁min len ▁= ▁cur rl en ▁; ▁start Ind ▁= ▁st ▁; ▁} ▁} ▁end ▁++ ▁; ▁} ▁return ▁str ▁. ▁substring ▁( ▁start Ind ▁, ▁start Ind ▁+ ▁min len ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁String ▁str ▁= ▁" ▁ef ec f ef d ▁" ▁; ▁int ▁k ▁= ▁4 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Min Len Str ▁( ▁str ▁, ▁k ▁) ▁) ▁; ▁} ▁}
▁class ▁G f G ▁{ ▁static ▁int ▁total Pairs ▁( ▁String ▁s 1 ▁, ▁String ▁s 2 ▁) ▁{ ▁int ▁a 1 ▁= ▁0 ▁, ▁b 1 ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s 1 ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁int ▁) ▁s 1 ▁. ▁charAt ▁( ▁i ▁) ▁% ▁2 ▁!= ▁0 ▁) ▁a 1 ▁++ ▁; ▁else ▁b 1 ▁++ ▁; ▁} ▁int ▁a 2 ▁= ▁0 ▁, ▁b 2 ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s 2 ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁int ▁) ▁s 2 ▁. ▁charAt ▁( ▁i ▁) ▁% ▁2 ▁!= ▁0 ▁) ▁a 2 ▁++ ▁; ▁else ▁b 2 ▁++ ▁; ▁} ▁return ▁( ▁( ▁a 1 ▁* ▁a 2 ▁) ▁+ ▁( ▁b 1 ▁* ▁b 2 ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁s 1 ▁= ▁" ▁g eek s ▁" ▁, ▁s 2 ▁= ▁" ▁for ▁" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁total Pairs ▁( ▁s 1 ▁, ▁s 2 ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁Pre process ▁( ▁String ▁A ▁, ▁String ▁B ▁) ▁{ ▁int ▁n ▁= ▁A ▁. ▁length ▁( ▁) ▁; ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁/ ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁HashMap ▁< ▁Character ▁, ▁Integer ▁> ▁mp ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁if ▁( ▁mp ▁. ▁containsKey ▁( ▁A ▁. ▁charAt ▁( ▁i ▁) ▁) ▁) ▁mp ▁. ▁put ▁( ▁A ▁. ▁charAt ▁( ▁i ▁) ▁, ▁mp ▁. ▁get ▁( ▁A ▁. ▁charAt ▁( ▁i ▁) ▁) ▁+ ▁1 ▁) ▁; ▁else ▁mp ▁. ▁put ▁( ▁A ▁. ▁charAt ▁( ▁i ▁) ▁, ▁1 ▁) ▁; ▁if ▁( ▁mp ▁. ▁containsKey ▁( ▁A ▁. ▁charAt ▁( ▁n ▁- ▁i ▁- ▁1 ▁) ▁) ▁) ▁mp ▁. ▁put ▁( ▁A ▁. ▁charAt ▁( ▁n ▁- ▁i ▁- ▁1 ▁) ▁, ▁mp ▁. ▁get ▁( ▁A ▁. ▁charAt ▁( ▁n ▁- ▁i ▁- ▁1 ▁) ▁) ▁+ ▁1 ▁) ▁; ▁else ▁mp ▁. ▁put ▁( ▁A ▁. ▁charAt ▁( ▁n ▁- ▁i ▁- ▁1 ▁) ▁, ▁1 ▁) ▁; ▁if ▁( ▁mp ▁. ▁containsKey ▁( ▁B ▁. ▁charAt ▁( ▁i ▁) ▁) ▁) ▁mp ▁. ▁put ▁( ▁B ▁. ▁charAt ▁( ▁i ▁) ▁, ▁mp ▁. ▁get ▁( ▁B ▁. ▁charAt ▁( ▁i ▁) ▁) ▁+ ▁1 ▁) ▁; ▁else ▁mp ▁. ▁put ▁( ▁B ▁. ▁charAt ▁( ▁i ▁) ▁, ▁1 ▁) ▁; ▁if ▁( ▁mp ▁. ▁containsKey ▁( ▁B ▁. ▁charAt ▁( ▁n ▁- ▁i ▁- ▁1 ▁) ▁) ▁) ▁mp ▁. ▁put ▁( ▁B ▁. ▁charAt ▁( ▁n ▁- ▁i ▁- ▁1 ▁) ▁, ▁mp ▁. ▁get ▁( ▁B ▁. ▁charAt ▁( ▁n ▁- ▁i ▁- ▁1 ▁) ▁) ▁+ ▁1 ▁) ▁; ▁else ▁mp ▁. ▁put ▁( ▁B ▁. ▁charAt ▁( ▁n ▁- ▁i ▁- ▁1 ▁) ▁, ▁1 ▁) ▁; ▁int ▁sz ▁= ▁mp ▁. ▁size ▁( ▁) ▁; ▁if ▁( ▁sz ▁== ▁4 ▁) ▁ans ▁+= ▁2 ▁; ▁else ▁if ▁( ▁sz ▁== ▁3 ▁) ▁ans ▁+= ▁1 ▁+ ▁( ▁A ▁. ▁charAt ▁( ▁i ▁) ▁== ▁A ▁. ▁charAt ▁( ▁n ▁- ▁i ▁- ▁1 ▁) ▁? ▁1 ▁: ▁0 ▁) ▁; ▁else ▁if ▁( ▁sz ▁== ▁2 ▁) ▁ans ▁+= ▁mp ▁. ▁get ▁( ▁A ▁. ▁charAt ▁( ▁i ▁) ▁) ▁!= ▁2 ▁? ▁1 ▁: ▁0 ▁; ▁} ▁if ▁( ▁n ▁% ▁2 ▁== ▁1 ▁&& ▁A ▁. ▁charAt ▁( ▁n ▁/ ▁2 ▁) ▁!= ▁B ▁. ▁charAt ▁( ▁n ▁/ ▁2 ▁) ▁) ▁ans ▁++ ▁; ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁A ▁= ▁" ▁ab ac aba ▁" ▁, ▁B ▁= ▁" ▁b ac ab aa ▁" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁Pre process ▁( ▁A ▁, ▁B ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁print Pattern ▁( ▁char ▁[ ▁] ▁s ▁, ▁int ▁n ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁s ▁) ▁; ▁int ▁i ▁= ▁0 ▁, ▁j ▁= ▁n ▁- ▁1 ▁; ▁while ▁( ▁i ▁< ▁j ▁) ▁{ ▁char ▁c ▁= ▁s ▁[ ▁i ▁] ▁; ▁s ▁[ ▁i ▁] ▁= ▁s ▁[ ▁j ▁] ▁; ▁s ▁[ ▁j ▁] ▁= ▁c ▁; ▁i ▁++ ▁; ▁j ▁-- ▁; ▁} ▁i ▁= ▁0 ▁; ▁j ▁= ▁n ▁- ▁1 ▁; ▁while ▁( ▁j ▁- ▁i ▁> ▁1 ▁) ▁{ ▁s ▁[ ▁i ▁] ▁= ▁s ▁[ ▁j ▁] ▁= ▁' ▁* ▁' ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁s ▁) ▁; ▁i ▁++ ▁; ▁j ▁-- ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁char ▁[ ▁] ▁s ▁= ▁" ▁g eek s ▁" ▁. ▁toCharArray ▁( ▁) ▁; ▁int ▁n ▁= ▁s ▁. ▁length ▁; ▁print Pattern ▁( ▁s ▁, ▁n ▁) ▁; ▁} ▁}
▁class ▁G f G ▁{ ▁static ▁char ▁bit ToBe F li pped ▁( ▁String ▁s ▁) ▁{ ▁char ▁last ▁= ▁s ▁. ▁charAt ▁( ▁s ▁. ▁length ▁( ▁) ▁- ▁1 ▁) ▁; ▁char ▁first ▁= ▁s ▁. ▁charAt ▁( ▁0 ▁) ▁; ▁if ▁( ▁last ▁== ▁first ▁) ▁{ ▁if ▁( ▁last ▁== ▁'0' ▁) ▁{ ▁return ▁'1' ▁; ▁} ▁else ▁{ ▁return ▁'0' ▁; ▁} ▁} ▁else ▁if ▁( ▁last ▁!= ▁first ▁) ▁{ ▁return ▁last ▁; ▁} ▁return ▁last ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁s ▁= ▁"11 0101 1000 " ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁bit ToBe F li pped ▁( ▁s ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁boolean ▁check ▁( ▁String ▁s ▁) ▁{ ▁int ▁[ ▁] ▁freq ▁= ▁new ▁int ▁[ ▁26 ▁] ▁; ▁int ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁freq ▁[ ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁) ▁- ▁97 ▁] ▁+= ▁1 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁freq ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁freq ▁[ ▁i ▁] ▁% ▁2 ▁== ▁1 ▁) ▁{ ▁return ▁false ▁; ▁} ▁} ▁return ▁true ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁s ▁= ▁" ▁ab acc aba ▁" ▁; ▁if ▁( ▁check ▁( ▁s ▁) ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁solve ▁( ▁String ▁s ▁) ▁{ ▁HashMap ▁< ▁Character ▁, ▁Integer ▁> ▁m ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁m ▁. ▁containsKey ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁) ▁) ▁m ▁. ▁put ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁, ▁m ▁. ▁get ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁) ▁+ ▁1 ▁) ▁; ▁else ▁m ▁. ▁put ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁, ▁1 ▁) ▁; ▁} ▁String ▁new _ string ▁= ▁" ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁m ▁. ▁get ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁) ▁% ▁2 ▁== ▁0 ▁) ▁continue ▁; ▁new _ string ▁= ▁new _ string ▁+ ▁s ▁. ▁charAt ▁( ▁i ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁new _ string ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁s ▁= ▁" ▁a ab bb dd ee ec c ▁" ▁; ▁solve ▁( ▁s ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁minimum Length ▁( ▁String ▁s ▁) ▁{ ▁int ▁max Occ ▁= ▁0 ▁, ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁int ▁arr ▁[ ▁] ▁= ▁new ▁int ▁[ ▁26 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁arr ▁[ ▁s ▁. ▁charAt ▁( ▁i ▁) ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁26 ▁; ▁i ▁++ ▁) ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁max Occ ▁) ▁max Occ ▁= ▁arr ▁[ ▁i ▁] ▁; ▁return ▁( ▁n ▁- ▁max Occ ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁" ▁af dd ew q d ▁" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁minimum Length ▁( ▁str ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁final ▁int ▁MAX ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁static ▁int ▁min Operation ▁( ▁String ▁s ▁, ▁int ▁i ▁, ▁int ▁j ▁, ▁int ▁count ▁) ▁{ ▁if ▁( ▁( ▁i ▁>= ▁s ▁. ▁length ▁( ▁) ▁&& ▁j ▁< ▁0 ▁) ▁|| ▁( ▁i ▁== ▁j ▁) ▁) ▁return ▁MAX ▁; ▁if ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁== ▁s ▁. ▁charAt ▁( ▁j ▁) ▁) ▁return ▁count ▁; ▁if ▁( ▁i ▁>= ▁s ▁. ▁length ▁( ▁) ▁) ▁return ▁min Operation ▁( ▁s ▁, ▁i ▁, ▁j ▁- ▁1 ▁, ▁count ▁+ ▁1 ▁) ▁; ▁else ▁if ▁( ▁j ▁< ▁0 ▁) ▁return ▁min Operation ▁( ▁s ▁, ▁i ▁+ ▁1 ▁, ▁j ▁, ▁count ▁+ ▁1 ▁) ▁; ▁else ▁return ▁Math ▁. ▁min ▁( ▁min Operation ▁( ▁s ▁, ▁i ▁, ▁j ▁- ▁1 ▁, ▁count ▁+ ▁1 ▁) ▁, ▁min Operation ▁( ▁s ▁, ▁i ▁+ ▁1 ▁, ▁j ▁, ▁count ▁+ ▁1 ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁s ▁= ▁" ▁b ac def gh ip al op ▁" ▁; ▁int ▁ans ▁= ▁min Operation ▁( ▁s ▁, ▁0 ▁, ▁s ▁. ▁length ▁( ▁) ▁- ▁1 ▁, ▁0 ▁) ▁; ▁if ▁( ▁ans ▁== ▁MAX ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁- ▁1 ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁ans ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁final ▁int ▁MAX _ CHAR ▁= ▁26 ▁; ▁static ▁void ▁frequency ▁( ▁int ▁fre ▁[ ▁] ▁[ ▁] ▁, ▁String ▁s ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁String ▁str ▁= ▁s ▁[ ▁i ▁] ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁str ▁. ▁length ▁( ▁) ▁; ▁j ▁++ ▁) ▁fre ▁[ ▁i ▁] ▁[ ▁str ▁. ▁charAt ▁( ▁j ▁) ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁} ▁} ▁static ▁void ▁Long est Sequence ▁( ▁int ▁fre ▁[ ▁] ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁24 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁int ▁mi ▁= ▁fre ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁; ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁mi ▁= ▁Math ▁. ▁min ▁( ▁fre ▁[ ▁j ▁] ▁[ ▁i ▁] ▁, ▁mi ▁) ▁; ▁while ▁( ▁mi ▁-- ▁!= ▁0 ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁( ▁char ▁) ▁( ▁' ▁a ▁' ▁+ ▁i ▁) ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁String ▁s ▁[ ▁] ▁= ▁{ ▁" ▁loo ▁" ▁, ▁" ▁lol ▁" ▁, ▁" ▁o live ▁" ▁} ▁; ▁int ▁n ▁= ▁s ▁. ▁length ▁; ▁int ▁fre ▁[ ▁] ▁[ ▁] ▁= ▁new ▁int ▁[ ▁n ▁] ▁[ ▁26 ▁] ▁; ▁frequency ▁( ▁fre ▁, ▁s ▁, ▁n ▁) ▁; ▁Long est Sequence ▁( ▁fre ▁, ▁n ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁minimum F lip ▁( ▁String ▁s ▁, ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁s ▁= ▁s ▁+ ▁s ▁; ▁boolean ▁is O pp osite ▁= ▁false ▁; ▁if ▁( ▁x ▁> ▁y ▁) ▁{ ▁swap ▁( ▁x ▁, ▁y ▁) ▁; ▁is O pp osite ▁= ▁true ▁; ▁} ▁int ▁val Clock wise ▁= ▁0 ▁; ▁char ▁cur ▁= ▁s ▁. ▁charAt ▁( ▁x ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁x ▁; ▁i ▁<= ▁y ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁!= ▁cur ▁) ▁{ ▁cur ▁= ▁s ▁. ▁charAt ▁( ▁i ▁) ▁; ▁val Clock wise ▁++ ▁; ▁} ▁} ▁int ▁val Ant ic lock wise ▁= ▁0 ▁; ▁cur ▁= ▁s ▁. ▁charAt ▁( ▁y ▁) ▁; ▁x ▁+= ▁s ▁. ▁length ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁y ▁; ▁i ▁< ▁x ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁!= ▁cur ▁) ▁{ ▁cur ▁= ▁s ▁. ▁charAt ▁( ▁i ▁) ▁; ▁val Ant ic lock wise ▁++ ▁; ▁} ▁} ▁if ▁( ▁val Clock wise ▁<= ▁val Ant ic lock wise ▁) ▁{ ▁if ▁( ▁! ▁is O pp osite ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Clock wise ▁" ▁+ ▁val Clock wise ▁) ▁; ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Ant i ▁- ▁clock wise ▁" ▁+ ▁val Ant ic lock wise ▁) ▁; ▁} ▁} ▁else ▁if ▁( ▁! ▁is O pp osite ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Ant i ▁- ▁clock wise ▁" ▁+ ▁val Ant ic lock wise ▁) ▁; ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Clock wise ▁" ▁+ ▁val Clock wise ▁) ▁; ▁} ▁} ▁static ▁void ▁swap ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁int ▁c ▁= ▁a ▁; ▁a ▁= ▁b ▁; ▁b ▁= ▁c ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁x ▁= ▁0 ▁, ▁y ▁= ▁8 ▁; ▁String ▁s ▁= ▁" 0001 10" ▁; ▁minimum F lip ▁( ▁s ▁, ▁x ▁, ▁y ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁String ▁Lex ic ograph ical Max String ▁( ▁String ▁str ▁) ▁{ ▁char ▁max char ▁= ▁' ▁a ▁' ▁; ▁ArrayList ▁< ▁Integer ▁> ▁index ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁str ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁>= ▁max char ▁) ▁{ ▁max char ▁= ▁str ▁. ▁charAt ▁( ▁i ▁) ▁; ▁index ▁. ▁add ▁( ▁i ▁) ▁; ▁} ▁} ▁String ▁max string ▁= ▁" ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁index ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁str ▁. ▁substring ▁( ▁index ▁. ▁get ▁( ▁i ▁) ▁, ▁str ▁. ▁length ▁( ▁) ▁) ▁. ▁compareTo ▁( ▁max string ▁) ▁> ▁0 ▁) ▁{ ▁max string ▁= ▁str ▁. ▁substring ▁( ▁index ▁. ▁get ▁( ▁i ▁) ▁, ▁str ▁. ▁length ▁( ▁) ▁) ▁; ▁} ▁} ▁return ▁max string ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁" ▁ac b ac bc ▁" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁Lex ic ograph ical Max String ▁( ▁str ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁class ▁Node ▁{ ▁String ▁c ▁; ▁Node ▁next ▁; ▁} ▁; ▁static ▁Node ▁newNode ▁( ▁String ▁c ▁) ▁{ ▁Node ▁temp ▁= ▁new ▁Node ▁( ▁) ▁; ▁temp ▁. ▁c ▁= ▁c ▁; ▁temp ▁. ▁next ▁= ▁null ▁; ▁return ▁temp ▁; ▁} ▁; ▁static ▁String ▁reverse _ word ▁( ▁String ▁str ▁) ▁{ ▁String ▁s ▁= ▁" ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁str ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁s ▁= ▁str ▁. ▁charAt ▁( ▁i ▁) ▁+ ▁s ▁; ▁return ▁s ▁; ▁} ▁static ▁Node ▁reverse ▁( ▁Node ▁head ▁) ▁{ ▁Node ▁ptr ▁= ▁head ▁; ▁while ▁( ▁ptr ▁!= ▁null ▁) ▁{ ▁ptr ▁. ▁c ▁= ▁reverse _ word ▁( ▁ptr ▁. ▁c ▁) ▁; ▁ptr ▁= ▁ptr ▁. ▁next ▁; ▁} ▁return ▁head ▁; ▁} ▁static ▁void ▁print List ▁( ▁Node ▁head ▁) ▁{ ▁while ▁( ▁head ▁!= ▁null ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁head ▁. ▁c ▁+ ▁" ▁" ▁) ▁; ▁head ▁= ▁head ▁. ▁next ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁Node ▁head ▁= ▁newNode ▁( ▁" ▁G eek s forge ek s ▁" ▁) ▁; ▁head ▁. ▁next ▁= ▁newNode ▁( ▁" ▁a ▁" ▁) ▁; ▁head ▁. ▁next ▁. ▁next ▁= ▁newNode ▁( ▁" ▁computer ▁" ▁) ▁; ▁head ▁. ▁next ▁. ▁next ▁. ▁next ▁= ▁newNode ▁( ▁" ▁sc ience ▁" ▁) ▁; ▁head ▁. ▁next ▁. ▁next ▁. ▁next ▁. ▁next ▁= ▁newNode ▁( ▁" ▁portal ▁" ▁) ▁; ▁head ▁. ▁next ▁. ▁next ▁. ▁next ▁. ▁next ▁. ▁next ▁= ▁newNode ▁( ▁" ▁for ▁" ▁) ▁; ▁head ▁. ▁next ▁. ▁next ▁. ▁next ▁. ▁next ▁. ▁next ▁. ▁next ▁= ▁newNode ▁( ▁" ▁g eek s ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" List ▁before ▁reverse : ▁NEW _ LINE "); ▁print List ▁( ▁head ▁) ▁; ▁head ▁= ▁reverse ▁( ▁head ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁List ▁after ▁reverse ▁: ▁"); ▁print List ▁( ▁head ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁class ▁G F G ▁{ ▁static ▁String ▁s ▁= ▁" ▁" ▁; ▁static ▁String ▁Reverse String ▁( ▁String ▁s ▁) ▁{ ▁char ▁[ ▁] ▁arr ▁= ▁s ▁. ▁toCharArray ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁arr ▁. ▁length ▁/ ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁char ▁temp ▁= ▁arr ▁[ ▁i ▁] ▁; ▁arr ▁[ ▁i ▁] ▁= ▁arr ▁[ ▁arr ▁. ▁length ▁- ▁i ▁- ▁1 ▁] ▁; ▁arr ▁[ ▁arr ▁. ▁length ▁- ▁i ▁- ▁1 ▁] ▁= ▁temp ▁; ▁} ▁return ▁new ▁String ▁( ▁arr ▁) ▁; ▁} ▁static ▁void ▁binary _ conversion ▁( ▁int ▁m ▁) ▁{ ▁while ▁( ▁m ▁!= ▁0 ▁) ▁{ ▁int ▁tmp ▁= ▁m ▁% ▁2 ▁; ▁s ▁+= ▁Integer ▁. ▁toString ▁( ▁tmp ▁) ▁; ▁m ▁= ▁( ▁int ▁) ▁( ▁m ▁/ ▁2 ▁) ▁; ▁} ▁s ▁= ▁Reverse String ▁( ▁s ▁) ▁; ▁} ▁static ▁int ▁find _ character ▁( ▁int ▁n ▁, ▁int ▁m ▁, ▁int ▁i ▁) ▁{ ▁binary _ conversion ▁( ▁m ▁) ▁; ▁String ▁s 1 ▁= ▁" ▁" ▁; ▁for ▁( ▁int ▁x ▁= ▁0 ▁; ▁x ▁< ▁n ▁; ▁x ▁++ ▁) ▁{ ▁for ▁( ▁int ▁y ▁= ▁0 ▁; ▁y ▁< ▁s ▁. ▁length ▁( ▁) ▁; ▁y ▁++ ▁) ▁{ ▁if ▁( ▁s ▁. ▁charAt ▁( ▁y ▁) ▁== ▁'1' ▁) ▁s 1 ▁+= ▁"10" ▁; ▁else ▁s 1 ▁+= ▁" 01" ▁; ▁} ▁s ▁= ▁s 1 ▁; ▁s 1 ▁= ▁" ▁" ▁; ▁} ▁return ▁s ▁. ▁charAt ▁( ▁i ▁) ▁- ▁'0' ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁m ▁= ▁5 ▁, ▁n ▁= ▁2 ▁, ▁i ▁= ▁8 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁find _ character ▁( ▁n ▁, ▁m ▁, ▁i ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁find Sub Sequence ▁( ▁String ▁s ▁, ▁int ▁num ▁) ▁{ ▁int ▁res ▁= ▁0 ▁; ▁int ▁i ▁= ▁0 ▁; ▁while ▁( ▁num ▁> ▁0 ▁) ▁{ ▁if ▁( ▁( ▁num ▁& ▁1 ▁) ▁== ▁1 ▁) ▁res ▁+= ▁s ▁. ▁charAt ▁( ▁i ▁) ▁- ▁'0' ▁; ▁i ▁++ ▁; ▁num ▁= ▁num ▁>> ▁1 ▁; ▁} ▁return ▁res ▁; ▁} ▁static ▁int ▁combined Sum ▁( ▁String ▁s ▁) ▁{ ▁int ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁int ▁c _ sum ▁= ▁0 ▁; ▁int ▁range ▁= ▁( ▁1 ▁<< ▁n ▁) ▁- ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁range ▁; ▁i ▁++ ▁) ▁c _ sum ▁+= ▁find Sub Sequence ▁( ▁s ▁, ▁i ▁) ▁; ▁return ▁c _ sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁s ▁= ▁"123" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁combined Sum ▁( ▁s ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁void ▁solve ▁( ▁String ▁s ▁) ▁{ ▁int ▁l ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁int ▁x ▁= ▁l ▁/ ▁2 ▁; ▁int ▁y ▁= ▁l ▁; ▁String ▁p ▁= ▁" ▁" ▁; ▁while ▁( ▁x ▁> ▁0 ▁&& ▁y ▁> ▁l ▁/ ▁2 ▁) ▁{ ▁char ▁ch ▁= ▁s ▁. ▁charAt ▁( ▁x ▁- ▁1 ▁) ▁; ▁p ▁+= ▁ch ▁; ▁x ▁-- ▁; ▁ch ▁= ▁s ▁. ▁charAt ▁( ▁y ▁- ▁1 ▁) ▁; ▁p ▁+= ▁ch ▁; ▁y ▁-- ▁; ▁} ▁if ▁( ▁y ▁> ▁l ▁/ ▁2 ▁) ▁{ ▁char ▁ch ▁= ▁s ▁. ▁charAt ▁( ▁x ▁- ▁1 ▁) ▁; ▁p ▁+= ▁ch ▁; ▁y ▁-- ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁p ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁String ▁s ▁= ▁" ▁sun sh ine ▁" ▁; ▁solve ▁( ▁s ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁final ▁int ▁MAX ▁= ▁26 ▁; ▁static ▁void ▁print An agram And Changes ▁( ▁char ▁[ ▁] ▁X ▁, ▁char ▁[ ▁] ▁Y ▁) ▁{ ▁int ▁count x ▁[ ▁] ▁= ▁new ▁int ▁[ ▁MAX ▁] ▁, ▁county ▁[ ▁] ▁= ▁new ▁int ▁[ ▁MAX ▁] ▁, ▁ctr x ▁[ ▁] ▁= ▁new ▁int ▁[ ▁MAX ▁] ▁, ▁c try ▁[ ▁] ▁= ▁new ▁int ▁[ ▁MAX ▁] ▁; ▁int ▁change ▁= ▁0 ▁; ▁int ▁l ▁= ▁X ▁. ▁length ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁l ▁; ▁i ▁++ ▁) ▁{ ▁count x ▁[ ▁X ▁[ ▁i ▁] ▁- ▁' ▁A ▁' ▁] ▁++ ▁; ▁county ▁[ ▁Y ▁[ ▁i ▁] ▁- ▁' ▁A ▁' ▁] ▁++ ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁MAX ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁count x ▁[ ▁i ▁] ▁> ▁county ▁[ ▁i ▁] ▁) ▁{ ▁ctr x ▁[ ▁i ▁] ▁+= ▁( ▁count x ▁[ ▁i ▁] ▁- ▁county ▁[ ▁i ▁] ▁) ▁; ▁} ▁else ▁if ▁( ▁count x ▁[ ▁i ▁] ▁< ▁county ▁[ ▁i ▁] ▁) ▁{ ▁c try ▁[ ▁i ▁] ▁+= ▁( ▁county ▁[ ▁i ▁] ▁- ▁count x ▁[ ▁i ▁] ▁) ▁; ▁} ▁change ▁+= ▁Math ▁. ▁abs ▁( ▁county ▁[ ▁i ▁] ▁- ▁count x ▁[ ▁i ▁] ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁l ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁ctr x ▁[ ▁X ▁[ ▁i ▁] ▁- ▁' ▁A ▁' ▁] ▁== ▁0 ▁) ▁{ ▁continue ▁; ▁} ▁int ▁j ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁MAX ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁( ▁c try ▁[ ▁j ▁] ▁) ▁> ▁0 ▁) ▁{ ▁break ▁; ▁} ▁} ▁if ▁( ▁count x ▁[ ▁X ▁[ ▁i ▁] ▁- ▁' ▁A ▁' ▁] ▁== ▁ctr x ▁[ ▁X ▁[ ▁i ▁] ▁- ▁' ▁A ▁' ▁] ▁X ▁[ ▁i ▁] ▁- ▁' ▁A ▁' ▁> ▁j ▁) ▁{ ▁count x ▁[ ▁X ▁[ ▁i ▁] ▁- ▁' ▁A ▁' ▁] ▁-- ▁; ▁ctr x ▁[ ▁X ▁[ ▁i ▁] ▁- ▁' ▁A ▁' ▁] ▁-- ▁; ▁c try ▁[ ▁j ▁] ▁-- ▁; ▁X ▁[ ▁i ▁] ▁= ▁( ▁char ▁) ▁( ▁' ▁A ▁' ▁+ ▁j ▁) ▁; ▁} ▁else ▁{ ▁count x ▁[ ▁X ▁[ ▁i ▁] ▁- ▁' ▁A ▁' ▁] ▁-- ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁An agram ▁: ▁" ▁+ ▁String ▁. ▁valueOf ▁( ▁X ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Number ▁of ▁changes ▁made ▁: ▁" ▁+ ▁change ▁/ ▁2 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁x ▁= ▁" ▁C DB ABC ▁" ▁, ▁y ▁= ▁" ▁AD C AB D ▁" ▁; ▁print An agram And Changes ▁( ▁x ▁. ▁toCharArray ▁( ▁) ▁, ▁y ▁. ▁toCharArray ▁( ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁count Occurrences ▁( ▁String ▁str ▁, ▁String ▁word ▁) ▁{ ▁String ▁a ▁[ ▁] ▁= ▁str ▁. ▁split ▁( ▁" ▁" ▁) ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁a ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁word ▁. ▁equals ▁( ▁a ▁[ ▁i ▁] ▁) ▁) ▁count ▁++ ▁; ▁} ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁String ▁str ▁= ▁" ▁G eek s for G eek s ▁A ▁computer ▁sc ience ▁portal ▁for ▁g eek s ▁" ▁; ▁String ▁word ▁= ▁" ▁portal ▁" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Occurrences ▁( ▁str ▁, ▁word ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁Vector ▁< ▁String ▁> ▁split Strings ▁( ▁String ▁str ▁, ▁char ▁dl ▁) ▁{ ▁String ▁word ▁= ▁" ▁" ▁; ▁int ▁num ▁= ▁0 ▁; ▁str ▁= ▁str ▁+ ▁dl ▁; ▁int ▁l ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁Vector ▁< ▁String ▁> ▁substr _ list ▁= ▁new ▁Vector ▁< ▁String ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁l ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁!= ▁dl ▁) ▁{ ▁word ▁= ▁word ▁+ ▁str ▁. ▁charAt ▁( ▁i ▁) ▁; ▁} ▁else ▁{ ▁if ▁( ▁( ▁int ▁) ▁word ▁. ▁length ▁( ▁) ▁!= ▁0 ▁) ▁{ ▁substr _ list ▁. ▁add ▁( ▁word ▁) ▁; ▁} ▁word ▁= ▁" ▁" ▁; ▁} ▁} ▁return ▁substr _ list ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁" ▁g eek s ▁; ▁for ▁; ▁g eek s ▁" ▁; ▁char ▁dl ▁= ▁' ▁; ▁' ▁; ▁Vector ▁< ▁String ▁> ▁res ▁= ▁split Strings ▁( ▁str ▁, ▁dl ▁) ▁; ▁for ▁( ▁String ▁x ▁: ▁res ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁x ▁) ▁; ▁} ▁} ▁}
▁class ▁G F G ▁{ ▁public ▁static ▁int ▁longest Sub seq ▁( ▁String ▁s ▁) ▁{ ▁int ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁int ▁[ ▁] ▁pre _ count _0 ▁= ▁new ▁int ▁[ ▁n ▁+ ▁2 ▁] ▁; ▁int ▁[ ▁] ▁pre _ count _1 ▁= ▁new ▁int ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁int ▁[ ▁] ▁post _ count _0 ▁= ▁new ▁int ▁[ ▁n ▁+ ▁2 ▁] ▁; ▁pre _ count _0 ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁post _ count _0 ▁[ ▁n ▁+ ▁1 ▁] ▁= ▁0 ▁; ▁pre _ count _1 ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁<= ▁n ▁; ▁j ▁++ ▁) ▁{ ▁pre _ count _0 ▁[ ▁j ▁] ▁= ▁pre _ count _0 ▁[ ▁j ▁- ▁1 ▁] ▁; ▁pre _ count _1 ▁[ ▁j ▁] ▁= ▁pre _ count _1 ▁[ ▁j ▁- ▁1 ▁] ▁; ▁post _ count _0 ▁[ ▁n ▁- ▁j ▁+ ▁1 ▁] ▁= ▁post _ count _0 ▁[ ▁n ▁- ▁j ▁+ ▁2 ▁] ▁; ▁if ▁( ▁s ▁. ▁charAt ▁( ▁j ▁- ▁1 ▁) ▁== ▁'0' ▁) ▁pre _ count _0 ▁[ ▁j ▁] ▁++ ▁; ▁else ▁pre _ count _1 ▁[ ▁j ▁] ▁++ ▁; ▁if ▁( ▁s ▁. ▁charAt ▁( ▁n ▁- ▁j ▁) ▁== ▁'0' ▁) ▁post _ count _0 ▁[ ▁n ▁- ▁j ▁+ ▁1 ▁] ▁++ ▁; ▁} ▁if ▁( ▁pre _ count _0 ▁[ ▁n ▁] ▁== ▁n ▁pre _ count _0 ▁[ ▁n ▁] ▁== ▁0 ▁) ▁return ▁n ▁; ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁<= ▁n ▁; ▁j ▁++ ▁) ▁ans ▁= ▁Math ▁. ▁max ▁( ▁pre _ count _0 ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁pre _ count _1 ▁[ ▁j ▁] ▁- ▁pre _ count _1 ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁post _ count _0 ▁[ ▁j ▁+ ▁1 ▁] ▁, ▁ans ▁) ▁; ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁s ▁= ▁" 0000 11 100 000" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁longest Sub seq ▁( ▁s ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁G F G ▁{ ▁static ▁boolean ▁should Swap ▁( ▁char ▁str ▁[ ▁] ▁, ▁int ▁start ▁, ▁int ▁curr ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁start ▁; ▁i ▁< ▁curr ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁str ▁[ ▁i ▁] ▁== ▁str ▁[ ▁curr ▁] ▁) ▁{ ▁return ▁false ▁; ▁} ▁} ▁return ▁true ▁; ▁} ▁static ▁void ▁find Perm utations ▁( ▁char ▁str ▁[ ▁] ▁, ▁int ▁index ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁index ▁>= ▁n ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁str ▁) ▁; ▁return ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁index ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁boolean ▁check ▁= ▁should Swap ▁( ▁str ▁, ▁index ▁, ▁i ▁) ▁; ▁if ▁( ▁check ▁) ▁{ ▁swap ▁( ▁str ▁, ▁index ▁, ▁i ▁) ▁; ▁find Perm utations ▁( ▁str ▁, ▁index ▁+ ▁1 ▁, ▁n ▁) ▁; ▁swap ▁( ▁str ▁, ▁index ▁, ▁i ▁) ▁; ▁} ▁} ▁} ▁static ▁void ▁swap ▁( ▁char ▁[ ▁] ▁str ▁, ▁int ▁i ▁, ▁int ▁j ▁) ▁{ ▁char ▁c ▁= ▁str ▁[ ▁i ▁] ▁; ▁str ▁[ ▁i ▁] ▁= ▁str ▁[ ▁j ▁] ▁; ▁str ▁[ ▁j ▁] ▁= ▁c ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁char ▁str ▁[ ▁] ▁= ▁{ ▁' ▁A ▁' ▁, ▁' ▁B ▁' ▁, ▁' ▁C ▁' ▁, ▁' ▁A ▁' ▁} ▁; ▁int ▁n ▁= ▁str ▁. ▁length ▁; ▁find Perm utations ▁( ▁str ▁, ▁0 ▁, ▁n ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁public ▁class ▁G F G ▁{ ▁static ▁int ▁MAX _ CHAR ▁= ▁256 ▁; ▁static ▁int ▁maximum Chars ▁( ▁String ▁str ▁) ▁{ ▁int ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁int ▁res ▁= ▁- ▁1 ▁; ▁int ▁[ ▁] ▁first Ind ▁= ▁new ▁int ▁[ ▁MAX _ CHAR ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁MAX _ CHAR ▁; ▁i ▁++ ▁) ▁first Ind ▁[ ▁i ▁] ▁= ▁- ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁first _ ind ▁= ▁first Ind ▁[ ▁str ▁. ▁charAt ▁( ▁i ▁) ▁] ▁; ▁if ▁( ▁first _ ind ▁== ▁- ▁1 ▁) ▁first Ind ▁[ ▁str ▁. ▁charAt ▁( ▁i ▁) ▁] ▁= ▁i ▁; ▁else ▁res ▁= ▁Math ▁. ▁max ▁( ▁res ▁, ▁Math ▁. ▁abs ▁( ▁i ▁- ▁first _ ind ▁- ▁1 ▁) ▁) ▁; ▁} ▁return ▁res ▁; ▁} ▁static ▁public ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁" ▁ab ba ▁" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁maximum Chars ▁( ▁str ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁boolean ▁isValid ▁( ▁String ▁p ▁) ▁{ ▁int ▁n ▁= ▁p ▁. ▁length ▁( ▁) ▁; ▁int ▁c 1 ▁= ▁0 ▁, ▁c 0 ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁p ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'0' ▁) ▁{ ▁c 0 ▁++ ▁; ▁} ▁if ▁( ▁p ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'1' ▁) ▁{ ▁c 1 ▁++ ▁; ▁} ▁} ▁if ▁( ▁c 0 ▁== ▁c 1 ▁) ▁{ ▁return ▁true ▁; ▁} ▁else ▁{ ▁return ▁false ▁; ▁} ▁} ▁public ▁static ▁int ▁longest Sub ▁( ▁String ▁s ▁) ▁{ ▁int ▁max _ len ▁= ▁0 ▁; ▁int ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁isValid ▁( ▁s ▁. ▁substring ▁( ▁i ▁, ▁j ▁+ ▁1 ▁) ▁) ▁&& ▁max _ len ▁< ▁j ▁- ▁i ▁+ ▁1 ▁) ▁{ ▁max _ len ▁= ▁j ▁- ▁i ▁+ ▁1 ▁; ▁} ▁} ▁} ▁return ▁max _ len ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁s ▁= ▁"1 01 001 000" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁longest Sub ▁( ▁s ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁final ▁static ▁int ▁MAX _ CHAR ▁= ▁256 ▁; ▁static ▁void ▁print D u o ▁( ▁String ▁str ▁) ▁{ ▁int ▁count Char ▁[ ▁] ▁= ▁new ▁int ▁[ ▁MAX _ CHAR ▁] ▁; ▁int ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁count Char ▁[ ▁str ▁. ▁charAt ▁( ▁i ▁) ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁} ▁String ▁str 1 ▁= ▁" ▁" ▁, ▁str 2 ▁= ▁" ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁MAX _ CHAR ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁count Char ▁[ ▁i ▁] ▁> ▁1 ▁) ▁{ ▁str 2 ▁= ▁str 2 ▁+ ▁( ▁char ▁) ▁( ▁i ▁+ ▁' ▁a ▁' ▁) ▁; ▁} ▁else ▁if ▁( ▁count Char ▁[ ▁i ▁] ▁== ▁1 ▁) ▁{ ▁str 1 ▁= ▁str 1 ▁+ ▁( ▁char ▁) ▁( ▁i ▁+ ▁' ▁a ▁' ▁) ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁String ▁with ▁characters ▁occurring ▁" ▁+ ▁" once : NEW _ LINE "); ▁System ▁. ▁out ▁. ▁print ▁( ▁str 1 ▁+ ▁" NEW _ LINE "); ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁String ▁with ▁characters ▁occurring ▁" ▁+ ▁" multiple ▁times : NEW _ LINE "); ▁System ▁. ▁out ▁. ▁print ▁( ▁str 2 ▁+ ▁" NEW _ LINE "); ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁" ▁lo v et ocode ▁" ▁; ▁print D u o ▁( ▁str ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁find Repeat First N 2 ▁( ▁String ▁s ▁) ▁{ ▁int ▁p ▁= ▁- ▁1 ▁, ▁i ▁, ▁j ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁s ▁. ▁length ▁( ▁) ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁== ▁s ▁. ▁charAt ▁( ▁j ▁) ▁) ▁{ ▁p ▁= ▁i ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁p ▁!= ▁- ▁1 ▁) ▁break ▁; ▁} ▁return ▁p ▁; ▁} ▁static ▁public ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁" ▁g eek s forge ek s ▁" ▁; ▁int ▁pos ▁= ▁find Repeat First N 2 ▁( ▁str ▁) ▁; ▁if ▁( ▁pos ▁== ▁- ▁1 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Not ▁found ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁str ▁. ▁charAt ▁( ▁pos ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁First _ Pal in ▁{ ▁static ▁final ▁int ▁MAX _ CHAR ▁= ▁26 ▁; ▁static ▁char ▁string Pal indrome ▁( ▁String ▁A ▁, ▁String ▁B ▁) ▁{ ▁int ▁[ ▁] ▁count A ▁= ▁new ▁int ▁[ ▁MAX _ CHAR ▁] ▁; ▁int ▁[ ▁] ▁count B ▁= ▁new ▁int ▁[ ▁MAX _ CHAR ▁] ▁; ▁int ▁l 1 ▁= ▁A ▁. ▁length ▁( ▁) ▁; ▁int ▁l 2 ▁= ▁B ▁. ▁length ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁l 1 ▁; ▁i ▁++ ▁) ▁count A ▁[ ▁A ▁. ▁charAt ▁( ▁i ▁) ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁l 2 ▁; ▁i ▁++ ▁) ▁count B ▁[ ▁B ▁. ▁charAt ▁( ▁i ▁) ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁26 ▁; ▁i ▁++ ▁) ▁if ▁( ▁( ▁count A ▁[ ▁i ▁] ▁> ▁1 ▁&& ▁count B ▁[ ▁i ▁] ▁== ▁0 ▁) ▁) ▁return ▁' ▁A ▁' ▁; ▁return ▁' ▁B ▁' ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁String ▁a ▁= ▁" ▁abc de a ▁" ▁; ▁String ▁b ▁= ▁" ▁bc des g ▁" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁string Pal indrome ▁( ▁a ▁, ▁b ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁G F G ▁{ ▁static ▁int ▁find Len ▁( ▁String ▁A ▁, ▁int ▁n ▁, ▁int ▁k ▁, ▁char ▁ch ▁) ▁{ ▁int ▁maxlen ▁= ▁1 ▁; ▁int ▁cnt ▁= ▁0 ▁; ▁int ▁l ▁= ▁0 ▁, ▁r ▁= ▁0 ▁; ▁while ▁( ▁r ▁< ▁n ▁) ▁{ ▁if ▁( ▁A ▁. ▁charAt ▁( ▁r ▁) ▁!= ▁ch ▁) ▁++ ▁cnt ▁; ▁while ▁( ▁cnt ▁> ▁k ▁) ▁{ ▁if ▁( ▁A ▁. ▁charAt ▁( ▁l ▁) ▁!= ▁ch ▁) ▁-- ▁cnt ▁; ▁++ ▁l ▁; ▁} ▁maxlen ▁= ▁Math ▁. ▁max ▁( ▁maxlen ▁, ▁r ▁- ▁l ▁+ ▁1 ▁) ▁; ▁++ ▁r ▁; ▁} ▁return ▁maxlen ▁; ▁} ▁static ▁int ▁answer ▁( ▁String ▁A ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁maxlen ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁26 ▁; ▁++ ▁i ▁) ▁{ ▁maxlen ▁= ▁Math ▁. ▁max ▁( ▁maxlen ▁, ▁find Len ▁( ▁A ▁, ▁n ▁, ▁k ▁, ▁( ▁char ▁) ▁( ▁i ▁+ ▁' ▁A ▁' ▁) ▁) ▁) ▁; ▁maxlen ▁= ▁Math ▁. ▁max ▁( ▁maxlen ▁, ▁find Len ▁( ▁A ▁, ▁n ▁, ▁k ▁, ▁( ▁char ▁) ▁( ▁i ▁+ ▁' ▁a ▁' ▁) ▁) ▁) ▁; ▁} ▁return ▁maxlen ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁5 ▁, ▁k ▁= ▁2 ▁; ▁String ▁A ▁= ▁" ▁AB AB A ▁" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Maximum ▁length ▁= ▁" ▁+ ▁answer ▁( ▁A ▁, ▁n ▁, ▁k ▁) ▁) ▁; ▁n ▁= ▁6 ▁; ▁k ▁= ▁4 ▁; ▁String ▁B ▁= ▁" ▁HH HH HH ▁" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Maximum ▁length ▁= ▁" ▁+ ▁answer ▁( ▁B ▁, ▁n ▁, ▁k ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁replace Dig ▁( ▁int ▁x ▁, ▁int ▁from ▁, ▁int ▁to ▁) ▁{ ▁int ▁result ▁= ▁0 ▁; ▁int ▁multiply ▁= ▁1 ▁; ▁while ▁( ▁x ▁> ▁0 ▁) ▁{ ▁int ▁reminder ▁= ▁x ▁% ▁10 ▁; ▁if ▁( ▁reminder ▁== ▁from ▁) ▁result ▁= ▁result ▁+ ▁to ▁* ▁multiply ▁; ▁else ▁result ▁= ▁result ▁+ ▁reminder ▁* ▁multiply ▁; ▁multiply ▁*= ▁10 ▁; ▁x ▁= ▁x ▁/ ▁10 ▁; ▁} ▁return ▁result ▁; ▁} ▁static ▁void ▁calculate Min Max Sum ▁( ▁int ▁x 1 ▁, ▁int ▁x 2 ▁) ▁{ ▁int ▁min Sum ▁= ▁replace Dig ▁( ▁x 1 ▁, ▁6 ▁, ▁5 ▁) ▁+ ▁replace Dig ▁( ▁x 2 ▁, ▁6 ▁, ▁5 ▁) ▁; ▁int ▁max Sum ▁= ▁replace Dig ▁( ▁x 1 ▁, ▁5 ▁, ▁6 ▁) ▁+ ▁replace Dig ▁( ▁x 2 ▁, ▁5 ▁, ▁6 ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Minimum ▁sum ▁= ▁" ▁+ ▁min Sum ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Maximum ▁sum ▁= ▁" ▁+ ▁max Sum ); ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁x 1 ▁= ▁54 66 ▁, ▁x 2 ▁= ▁4 555 ▁; ▁calculate Min Max Sum ▁( ▁x 1 ▁, ▁x 2 ▁) ▁; ▁} ▁}
▁class ▁Test ▁{ ▁static ▁String ▁find Tw os com plement ▁( ▁StringBuffer ▁str ▁) ▁{ ▁int ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁if ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'1' ▁) ▁break ▁; ▁if ▁( ▁i ▁== ▁- ▁1 ▁) ▁return ▁"1" ▁+ ▁str ▁; ▁for ▁( ▁int ▁k ▁= ▁i ▁- ▁1 ▁; ▁k ▁>= ▁0 ▁; ▁k ▁-- ▁) ▁{ ▁if ▁( ▁str ▁. ▁charAt ▁( ▁k ▁) ▁== ▁'1' ▁) ▁str ▁. ▁replace ▁( ▁k ▁, ▁k ▁+ ▁1 ▁, ▁"0" ▁) ▁; ▁else ▁str ▁. ▁replace ▁( ▁k ▁, ▁k ▁+ ▁1 ▁, ▁"1" ▁) ▁; ▁} ▁return ▁str ▁. ▁toString ▁( ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁StringBuffer ▁str ▁= ▁new ▁StringBuffer ▁( ▁" 000001 01" ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Tw os com plement ▁( ▁str ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁is Perf ect ▁( ▁int ▁x ▁) ▁{ ▁int ▁sum _ div ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁x ▁/ ▁2 ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁x ▁% ▁i ▁== ▁0 ▁) ▁{ ▁sum _ div ▁+= ▁i ▁; ▁} ▁} ▁if ▁( ▁sum _ div ▁== ▁x ▁) ▁{ ▁return ▁1 ▁; ▁} ▁else ▁return ▁0 ▁; ▁} ▁static ▁void ▁subset Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁long ▁total ▁= ▁1 ▁<< ▁n ▁; ▁for ▁( ▁long ▁i ▁= ▁0 ▁; ▁i ▁< ▁total ▁; ▁i ▁++ ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁if ▁( ▁( ▁i ▁& ▁( ▁1 ▁<< ▁j ▁) ▁) ▁!= ▁0 ▁) ▁sum ▁+= ▁arr ▁[ ▁j ▁] ▁; ▁if ▁( ▁is Perf ect ▁( ▁sum ▁) ▁!= ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁sum ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁4 ▁, ▁6 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁subset Sum ▁( ▁arr ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁check Until ▁( ▁int ▁num ▁, ▁int ▁K ▁, ▁int ▁N ▁, ▁Vector ▁< ▁Integer ▁> ▁ans ▁) ▁{ ▁if ▁( ▁N ▁== ▁1 ▁) ▁{ ▁ans ▁. ▁add ▁( ▁num ▁) ▁; ▁return ▁; ▁} ▁if ▁( ▁( ▁num ▁% ▁10 ▁+ ▁K ▁) ▁<= ▁9 ▁) ▁check Until ▁( ▁10 ▁* ▁num ▁+ ▁( ▁num ▁% ▁10 ▁+ ▁K ▁) ▁, ▁K ▁, ▁N ▁- ▁1 ▁, ▁ans ▁) ▁; ▁if ▁( ▁K ▁> ▁0 ▁) ▁{ ▁if ▁( ▁( ▁num ▁% ▁10 ▁- ▁K ▁) ▁>= ▁0 ▁) ▁check Until ▁( ▁10 ▁* ▁num ▁+ ▁num ▁% ▁10 ▁- ▁K ▁, ▁K ▁, ▁N ▁- ▁1 ▁, ▁ans ▁) ▁; ▁} ▁} ▁static ▁void ▁check ▁( ▁int ▁K ▁, ▁int ▁N ▁, ▁Vector ▁< ▁Integer ▁> ▁ans ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁9 ▁; ▁i ▁++ ▁) ▁{ ▁check Until ▁( ▁i ▁, ▁K ▁, ▁N ▁, ▁ans ▁) ▁; ▁} ▁} ▁static ▁void ▁print ▁( ▁Vector ▁< ▁Integer ▁> ▁ans ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁ans ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁ans ▁. ▁get ▁( ▁i ▁) ▁+ ▁" ▁, ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁4 ▁, ▁K ▁= ▁8 ▁; ▁Vector ▁< ▁Integer ▁> ▁ans ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁; ▁check ▁( ▁K ▁, ▁N ▁, ▁ans ▁) ▁; ▁print ▁( ▁ans ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁N ▁= ▁4 ▁; ▁static ▁void ▁print Solution ▁( ▁int ▁sol ▁[ ▁] ▁[ ▁] ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁% ▁d ▁" ▁, ▁sol ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁printf ▁( ▁" NEW _ LINE "); ▁} ▁} ▁static ▁boolean ▁is Safe ▁( ▁int ▁maze ▁[ ▁] ▁[ ▁] ▁, ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁if ▁( ▁x ▁>= ▁0 ▁&& ▁x ▁< ▁N ▁&& ▁y ▁>= ▁0 ▁&& ▁y ▁< ▁N ▁&& ▁maze ▁[ ▁x ▁] ▁[ ▁y ▁] ▁!= ▁0 ▁) ▁{ ▁return ▁true ▁; ▁} ▁return ▁false ▁; ▁} ▁static ▁boolean ▁solve M aze ▁( ▁int ▁maze ▁[ ▁] ▁[ ▁] ▁) ▁{ ▁int ▁sol ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁} ▁} ▁; ▁if ▁( ▁solve M aze Util ▁( ▁maze ▁, ▁0 ▁, ▁0 ▁, ▁sol ▁) ▁== ▁false ▁) ▁{ ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁Solution ▁doesn ▁' ▁t ▁exist ▁" ▁) ▁; ▁return ▁false ▁; ▁} ▁print Solution ▁( ▁sol ▁) ▁; ▁return ▁true ▁; ▁} ▁static ▁boolean ▁solve M aze Util ▁( ▁int ▁maze ▁[ ▁] ▁[ ▁] ▁, ▁int ▁x ▁, ▁int ▁y ▁, ▁int ▁sol ▁[ ▁] ▁[ ▁] ▁) ▁{ ▁if ▁( ▁x ▁== ▁N ▁- ▁1 ▁&& ▁y ▁== ▁N ▁- ▁1 ▁) ▁{ ▁sol ▁[ ▁x ▁] ▁[ ▁y ▁] ▁= ▁1 ▁; ▁return ▁true ▁; ▁} ▁if ▁( ▁is Safe ▁( ▁maze ▁, ▁x ▁, ▁y ▁) ▁== ▁true ▁) ▁{ ▁sol ▁[ ▁x ▁] ▁[ ▁y ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁maze ▁[ ▁x ▁] ▁[ ▁y ▁] ▁&& ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁solve M aze Util ▁( ▁maze ▁, ▁x ▁+ ▁i ▁, ▁y ▁, ▁sol ▁) ▁== ▁true ▁) ▁{ ▁return ▁true ▁; ▁} ▁if ▁( ▁solve M aze Util ▁( ▁maze ▁, ▁x ▁, ▁y ▁+ ▁i ▁, ▁sol ▁) ▁== ▁true ▁) ▁{ ▁return ▁true ▁; ▁} ▁} ▁sol ▁[ ▁x ▁] ▁[ ▁y ▁] ▁= ▁0 ▁; ▁return ▁false ▁; ▁} ▁return ▁false ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁maze ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁2 ▁, ▁1 ▁, ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁3 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁} ▁, ▁{ ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁} ▁, ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁} ▁} ▁; ▁solve M aze ▁( ▁maze ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁final ▁int ▁maxSize ▁= ▁50 ▁; ▁static ▁double ▁[ ▁] ▁[ ▁] ▁matrix _ product ▁( ▁double ▁[ ▁] ▁[ ▁] ▁a ▁, ▁double ▁[ ▁] ▁[ ▁] ▁b ▁) ▁{ ▁double ▁[ ▁] ▁[ ▁] ▁c ▁= ▁new ▁double ▁[ ▁7 ▁] ▁[ ▁7 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁7 ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁7 ▁; ▁j ▁++ ▁) ▁for ▁( ▁int ▁k ▁= ▁0 ▁; ▁k ▁< ▁7 ▁; ▁k ▁++ ▁) ▁c ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+= ▁a ▁[ ▁i ▁] ▁[ ▁k ▁] ▁* ▁b ▁[ ▁k ▁] ▁[ ▁j ▁] ▁; ▁return ▁c ▁; ▁} ▁static ▁double ▁[ ▁] ▁[ ▁] ▁mul _ exp o ▁( ▁double ▁[ ▁] ▁[ ▁] ▁mul ▁, ▁int ▁p ▁) ▁{ ▁double ▁[ ▁] ▁[ ▁] ▁s ▁= ▁{ ▁{ ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁0 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁} ▁, ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁} ▁} ▁; ▁while ▁( ▁p ▁!= ▁1 ▁) ▁{ ▁if ▁( ▁p ▁% ▁2 ▁== ▁1 ▁) ▁s ▁= ▁matrix _ product ▁( ▁s ▁, ▁mul ▁) ▁; ▁mul ▁= ▁matrix _ product ▁( ▁mul ▁, ▁mul ▁) ▁; ▁p ▁/= ▁2 ▁; ▁} ▁return ▁matrix _ product ▁( ▁mul ▁, ▁s ▁) ▁; ▁} ▁static ▁double ▁expected Steps ▁( ▁int ▁x ▁) ▁{ ▁if ▁( ▁x ▁== ▁0 ▁) ▁return ▁0 ▁; ▁if ▁( ▁x ▁<= ▁6 ▁) ▁return ▁6 ▁; ▁double ▁[ ▁] ▁[ ▁] ▁mul ▁= ▁{ ▁{ ▁( ▁double ▁) ▁7 ▁/ ▁6 ▁, ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁0 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁} ▁, ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁} ▁, ▁{ ▁( ▁double ▁) ▁- ▁1 ▁/ ▁6 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁} ▁} ▁; ▁mul ▁= ▁mul _ exp o ▁( ▁mul ▁, ▁x ▁- ▁6 ▁) ▁; ▁return ▁( ▁mul ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁+ ▁mul ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁+ ▁mul ▁[ ▁2 ▁] ▁[ ▁0 ▁] ▁+ ▁mul ▁[ ▁3 ▁] ▁[ ▁0 ▁] ▁+ ▁mul ▁[ ▁4 ▁] ▁[ ▁0 ▁] ▁+ ▁mul ▁[ ▁5 ▁] ▁[ ▁0 ▁] ▁) ▁* ▁6 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁10 ▁; ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁% ▁.5 f ▁" ▁, ▁expected Steps ▁( ▁n ▁- ▁1 ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁long ▁F ▁( ▁long ▁A ▁, ▁long ▁B ▁) ▁{ ▁if ▁( ▁A ▁== ▁1 ▁) ▁return ▁( ▁4 ▁% ▁B ▁) ▁; ▁else ▁{ ▁long ▁temp ▁= ▁F ▁( ▁A ▁- ▁1 ▁, ▁B ▁) ▁; ▁return ▁( ▁temp ▁* ▁temp ▁) ▁% ▁B ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁long ▁A ▁= ▁25 ▁, ▁B ▁= ▁50 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁F ▁( ▁A ▁, ▁B ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁binarySearch ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁left ▁, ▁int ▁right ▁) ▁{ ▁if ▁( ▁left ▁<= ▁right ▁) ▁{ ▁int ▁mid ▁= ▁( ▁left ▁+ ▁right ▁) ▁/ ▁2 ▁; ▁if ▁( ▁arr ▁[ ▁mid ▁- ▁1 ▁] ▁< ▁arr ▁[ ▁mid ▁] ▁&& ▁arr ▁[ ▁mid ▁] ▁> ▁arr ▁[ ▁mid ▁+ ▁1 ▁] ▁) ▁return ▁mid ▁; ▁if ▁( ▁arr ▁[ ▁mid ▁] ▁< ▁arr ▁[ ▁mid ▁+ ▁1 ▁] ▁) ▁return ▁binarySearch ▁( ▁arr ▁, ▁mid ▁+ ▁1 ▁, ▁right ▁) ▁; ▁else ▁return ▁binarySearch ▁( ▁arr ▁, ▁left ▁, ▁mid ▁- ▁1 ▁) ▁; ▁} ▁return ▁- ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁6 ▁, ▁7 ▁, ▁8 ▁, ▁11 ▁, ▁9 ▁, ▁5 ▁, ▁2 ▁, ▁1 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁int ▁index ▁= ▁binarySearch ▁( ▁arr ▁, ▁1 ▁, ▁n ▁- ▁2 ▁) ▁; ▁if ▁( ▁index ▁!= ▁- ▁1 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁arr ▁[ ▁index ▁] ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁isP ossible To Re ach ▁( ▁int ▁[ ▁] ▁A ▁, ▁int ▁N ▁, ▁int ▁X ▁, ▁int ▁Y ▁) ▁{ ▁double ▁distance ▁= ▁Math ▁. ▁sqrt ▁( ▁( ▁X ▁* ▁X ▁+ ▁Y ▁* ▁Y ▁) ▁) ▁; ▁double ▁mx ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁mx ▁+= ▁( ▁A ▁[ ▁i ▁] ▁) ▁; ▁} ▁if ▁( ▁mx ▁< ▁distance ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁NO ▁" ▁) ▁; ▁return ▁0 ▁; ▁} ▁if ▁( ▁( ▁mx ▁- ▁distance ▁) ▁< ▁0. 000001 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁YES ▁" ▁) ▁; ▁return ▁0 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁distance ▁+ ▁mx ▁< ▁2 ▁* ▁A ▁[ ▁i ▁] ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁No ▁" ▁) ▁; ▁return ▁0 ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Yes ▁" ▁) ▁; ▁return ▁0 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁A ▁= ▁{ ▁2 ▁, ▁5 ▁} ▁; ▁int ▁X ▁= ▁5 ▁, ▁Y ▁= ▁4 ▁; ▁int ▁N ▁= ▁A ▁. ▁length ▁; ▁isP ossible To Re ach ▁( ▁A ▁, ▁N ▁, ▁X ▁, ▁Y ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁double ▁point _ distance ▁( ▁int ▁x 1 ▁, ▁int ▁y 1 ▁, ▁int ▁x 2 ▁, ▁int ▁y 2 ▁) ▁{ ▁int ▁p ▁= ▁( ▁x 2 ▁- ▁x 1 ▁) ▁; ▁int ▁q ▁= ▁( ▁y 2 ▁- ▁y 1 ▁) ▁; ▁double ▁distance ▁= ▁Math ▁. ▁sqrt ▁( ▁p ▁* ▁p ▁+ ▁q ▁* ▁q ▁) ▁; ▁return ▁distance ▁; ▁} ▁static ▁void ▁tang ent Angle ▁( ▁int ▁x 1 ▁, ▁int ▁y 1 ▁, ▁int ▁x 2 ▁, ▁int ▁y 2 ▁, ▁double ▁radius ▁) ▁{ ▁double ▁distance ▁= ▁point _ distance ▁( ▁x 1 ▁, ▁y 1 ▁, ▁x 2 ▁, ▁y 2 ▁) ▁; ▁if ▁( ▁radius ▁/ ▁distance ▁> ▁1 ▁radius ▁/ ▁distance ▁< ▁- ▁1 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁- ▁1 ▁) ▁; ▁} ▁double ▁result ▁= ▁2 ▁* ▁Math ▁. ▁as in ▁( ▁radius ▁/ ▁distance ▁) ▁* ▁180 ▁/ ▁3.14 15 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁String ▁. ▁format ▁( ▁" ▁% ▁.4 f ▁" ▁, ▁result ▁) ▁+ ▁" ▁degrees ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁radius ▁= ▁4 ▁; ▁int ▁x 1 ▁= ▁7 ▁, ▁y 1 ▁= ▁12 ▁; ▁int ▁x 2 ▁= ▁3 ▁, ▁y 2 ▁= ▁4 ▁; ▁tang ent Angle ▁( ▁x 1 ▁, ▁y 1 ▁, ▁x 2 ▁, ▁y 2 ▁, ▁radius ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁final ▁double ▁RAD IAN ▁= ▁0.0 17 45 329 252 ▁; ▁static ▁double ▁Area _ of _ R h omb us ▁( ▁int ▁a ▁, ▁int ▁theta ▁) ▁{ ▁double ▁area ▁= ▁( ▁a ▁* ▁a ▁) ▁* ▁Math ▁. ▁sin ▁( ▁( ▁RAD IAN ▁* ▁theta ▁) ▁) ▁; ▁return ▁area ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁= ▁4 ▁; ▁int ▁theta ▁= ▁60 ▁; ▁double ▁ans ▁= ▁Area _ of _ R h omb us ▁( ▁a ▁, ▁theta ▁) ▁; ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁% ▁.2 f ▁" ▁, ▁ans ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁double ▁Length _ Diag onal ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁double ▁theta ▁) ▁{ ▁double ▁diagonal ▁= ▁Math ▁. ▁sqrt ▁( ▁( ▁Math ▁. ▁pow ▁( ▁a ▁, ▁2 ▁) ▁+ ▁Math ▁. ▁pow ▁( ▁b ▁, ▁2 ▁) ▁) ▁- ▁2 ▁* ▁a ▁* ▁b ▁* ▁Math ▁. ▁cos ▁( ▁theta ▁* ▁( ▁Math ▁. ▁PI ▁/ ▁180 ▁) ▁) ▁) ▁; ▁return ▁diagonal ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁= ▁3 ▁; ▁int ▁b ▁= ▁5 ▁; ▁double ▁theta ▁= ▁45 ▁; ▁double ▁ans ▁= ▁Length _ Diag onal ▁( ▁a ▁, ▁b ▁, ▁theta ▁) ▁; ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁% ▁.2 f ▁" ▁, ▁ans ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁maximum Tiles ▁( ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁( ▁m ▁* ▁n ▁) ▁/ ▁2 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁M ▁= ▁3 ▁; ▁int ▁N ▁= ▁4 ▁; ▁maximum Tiles ▁( ▁N ▁, ▁M ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁double ▁find ▁( ▁double ▁x ▁, ▁double ▁y ▁, ▁int ▁[ ▁] ▁[ ▁] ▁p ▁) ▁{ ▁double ▁mind ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁p ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁double ▁a ▁= ▁p ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁, ▁b ▁= ▁p ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁; ▁mind ▁+= ▁Math ▁. ▁sqrt ▁( ▁( ▁x ▁- ▁a ▁) ▁* ▁( ▁x ▁- ▁a ▁) ▁+ ▁( ▁y ▁- ▁b ▁) ▁* ▁( ▁y ▁- ▁b ▁) ▁) ▁; ▁} ▁return ▁mind ▁; ▁} ▁static ▁double ▁getMin Dist Sum ▁( ▁int ▁[ ▁] ▁[ ▁] ▁p ▁) ▁{ ▁double ▁x ▁= ▁0 ▁, ▁y ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁p ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁x ▁+= ▁p ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁; ▁y ▁+= ▁p ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁; ▁} ▁x ▁= ▁x ▁/ ▁p ▁. ▁length ▁; ▁y ▁= ▁y ▁/ ▁p ▁. ▁length ▁; ▁double ▁mind ▁= ▁find ▁( ▁x ▁, ▁y ▁, ▁p ▁) ▁; ▁return ▁mind ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁[ ▁] ▁vec ▁= ▁{ ▁{ ▁0 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁0 ▁} ▁, ▁{ ▁1 ▁, ▁2 ▁} ▁, ▁{ ▁2 ▁, ▁1 ▁} ▁} ▁; ▁double ▁d ▁= ▁getMin Dist Sum ▁( ▁vec ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁d ▁+ ▁" NEW _ LINE "); ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁n Cr ▁( ▁int ▁n ▁, ▁int ▁r ▁) ▁{ ▁return ▁( ▁fact ▁( ▁n ▁) ▁/ ▁( ▁fact ▁( ▁r ▁) ▁* ▁fact ▁( ▁n ▁- ▁r ▁) ▁) ▁) ▁; ▁} ▁static ▁int ▁fact ▁( ▁int ▁n ▁) ▁{ ▁int ▁res ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁< ▁n ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁res ▁= ▁res ▁* ▁i ▁; ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁n Cr ▁( ▁n ▁, ▁4 ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁area Square ▁( ▁int ▁L ▁, ▁int ▁B ▁) ▁{ ▁int ▁large ▁= ▁Math ▁. ▁max ▁( ▁L ▁, ▁B ▁) ▁; ▁int ▁small ▁= ▁Math ▁. ▁min ▁( ▁L ▁, ▁B ▁) ▁; ▁if ▁( ▁large ▁>= ▁2 ▁* ▁small ▁) ▁{ ▁return ▁large ▁* ▁large ▁; ▁} ▁else ▁{ ▁return ▁( ▁2 ▁* ▁small ▁) ▁* ▁( ▁2 ▁* ▁small ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁L ▁= ▁7 ▁; ▁int ▁B ▁= ▁4 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁area Square ▁( ▁L ▁, ▁B ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁double ▁pie ▁= ▁3.14 159 265 35 89 7 ▁; ▁static ▁double ▁finds olution ▁( ▁double ▁d ▁, ▁double ▁h ▁, ▁double ▁m ▁, ▁double ▁n ▁) ▁{ ▁double ▁k ▁= ▁( ▁4 ▁* ▁m ▁) ▁/ ▁( ▁pie ▁* ▁d ▁* ▁d ▁) ▁; ▁if ▁( ▁n ▁> ▁k ▁) ▁return ▁- ▁1 ▁; ▁double ▁ans ▁= ▁( ▁h ▁/ ▁( ▁k ▁- ▁n ▁) ▁) ▁; ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁double ▁d ▁= ▁1 ▁, ▁h ▁= ▁1 ▁, ▁m ▁= ▁1 ▁, ▁n ▁= ▁1 ▁; ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁% ▁.5 f ▁" ▁, ▁finds olution ▁( ▁d ▁, ▁h ▁, ▁m ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁angle ▁( ▁int ▁n ▁) ▁{ ▁return ▁2 ▁* ▁n ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁30 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁angle ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁public ▁static ▁int ▁Valid ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁int ▁c ▁, ▁int ▁d ▁) ▁{ ▁if ▁( ▁a ▁+ ▁b ▁+ ▁c ▁+ ▁d ▁== ▁360 ▁) ▁return ▁1 ▁; ▁return ▁0 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁= ▁80 ▁, ▁b ▁= ▁70 ▁, ▁c ▁= ▁100 ▁, ▁d ▁= ▁110 ▁; ▁if ▁( ▁Valid ▁( ▁a ▁, ▁b ▁, ▁c ▁, ▁d ▁) ▁== ▁1 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Valid ▁quad r il ater al ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Invalid ▁quad r il ater al ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁len g ch ord ▁( ▁int ▁z ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁The ▁length ▁is ▁" ▁+ ▁z ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁z ▁= ▁48 ▁; ▁len g ch ord ▁( ▁z ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁count Pairs ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁HashMap ▁< ▁Double ▁, ▁Integer ▁> ▁mp ▁= ▁new ▁HashMap ▁< ▁Double ▁, ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁double ▁y ▁= ▁a ▁[ ▁i ▁] ▁; ▁if ▁( ▁y ▁!= ▁0 ▁&& ▁y ▁!= ▁1 ▁) ▁{ ▁double ▁x ▁= ▁( ▁( ▁y ▁* ▁1.0 ▁) ▁/ ▁( ▁1 ▁- ▁y ▁) ▁) ▁* ▁y ▁; ▁if ▁( ▁mp ▁. ▁containsKey ▁( ▁x ▁) ▁) ▁count ▁+= ▁mp ▁. ▁get ▁( ▁x ▁) ▁; ▁} ▁if ▁( ▁mp ▁. ▁containsKey ▁( ▁y ▁) ▁) ▁{ ▁mp ▁. ▁put ▁( ▁y ▁, ▁mp ▁. ▁get ▁( ▁y ▁) ▁+ ▁1 ▁) ▁; ▁} ▁else ▁{ ▁mp ▁. ▁put ▁( ▁y ▁, ▁1 ▁) ▁; ▁} ▁} ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁- ▁4 ▁, ▁- ▁3 ▁, ▁0 ▁, ▁2 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁count Pairs ▁( ▁arr ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁public ▁class ▁G F G ▁{ ▁static ▁boolean ▁contains ▁( ▁int ▁num ▁, ▁int ▁K ▁, ▁int ▁Base ▁) ▁{ ▁boolean ▁is There ▁= ▁false ▁; ▁while ▁( ▁num ▁> ▁0 ▁) ▁{ ▁int ▁remainder ▁= ▁num ▁% ▁Base ▁; ▁if ▁( ▁remainder ▁== ▁K ▁) ▁{ ▁is There ▁= ▁true ▁; ▁} ▁num ▁/= ▁Base ▁; ▁} ▁return ▁is There ▁; ▁} ▁static ▁void ▁count ▁( ▁int ▁n ▁, ▁int ▁k ▁, ▁Vector ▁< ▁Vector ▁< ▁Integer ▁> ▁> ▁v ▁) ▁{ ▁int ▁[ ▁] ▁pref ▁= ▁new ▁int ▁[ ▁100000 5 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁1 e 6 ▁+ ▁5 ▁; ▁i ▁++ ▁) ▁{ ▁boolean ▁present ▁= ▁contains ▁( ▁i ▁, ▁k ▁, ▁10 ▁) ▁|| ▁contains ▁( ▁i ▁, ▁k ▁, ▁8 ▁) ▁; ▁if ▁( ▁present ▁) ▁{ ▁pref ▁[ ▁i ▁] ▁+= ▁pref ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁1 ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁( ▁v ▁. ▁get ▁( ▁0 ▁) ▁. ▁get ▁( ▁1 ▁) ▁- ▁v ▁. ▁get ▁( ▁0 ▁) ▁. ▁get ▁( ▁0 ▁) ▁+ ▁1 ▁- ▁( ▁pref ▁[ ▁v ▁. ▁get ▁( ▁0 ▁) ▁. ▁get ▁( ▁1 ▁) ▁] ▁- ▁pref ▁[ ▁v ▁. ▁get ▁( ▁0 ▁) ▁. ▁get ▁( ▁0 ▁) ▁- ▁1 ▁] ▁) ▁) ▁+ ▁" ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁( ▁v ▁. ▁get ▁( ▁1 ▁) ▁. ▁get ▁( ▁1 ▁) ▁- ▁v ▁. ▁get ▁( ▁1 ▁) ▁. ▁get ▁( ▁0 ▁) ▁- ▁( ▁pref ▁[ ▁v ▁. ▁get ▁( ▁1 ▁) ▁. ▁get ▁( ▁1 ▁) ▁] ▁- ▁pref ▁[ ▁v ▁. ▁get ▁( ▁1 ▁) ▁. ▁get ▁( ▁0 ▁) ▁- ▁1 ▁] ▁) ▁) ▁+ ▁" ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁K ▁= ▁7 ▁; ▁Vector ▁< ▁Vector ▁< ▁Integer ▁> ▁> ▁Q ▁= ▁new ▁Vector ▁< ▁Vector ▁< ▁Integer ▁> ▁> ▁( ▁) ▁; ▁Q ▁. ▁add ▁( ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁) ▁; ▁Q ▁. ▁get ▁( ▁0 ▁) ▁. ▁add ▁( ▁2 ▁) ▁; ▁Q ▁. ▁get ▁( ▁0 ▁) ▁. ▁add ▁( ▁5 ▁) ▁; ▁Q ▁. ▁add ▁( ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁) ▁; ▁Q ▁. ▁get ▁( ▁1 ▁) ▁. ▁add ▁( ▁1 ▁) ▁; ▁Q ▁. ▁get ▁( ▁1 ▁) ▁. ▁add ▁( ▁15 ▁) ▁; ▁int ▁N ▁= ▁Q ▁. ▁size ▁( ▁) ▁; ▁count ▁( ▁N ▁, ▁K ▁, ▁Q ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁pr onic ▁( ▁int ▁num ▁) ▁{ ▁int ▁N ▁= ▁( ▁int ▁) ▁Math ▁. ▁sqrt ▁( ▁num ▁) ▁; ▁if ▁( ▁N ▁* ▁( ▁N ▁+ ▁1 ▁) ▁<= ▁num ▁) ▁{ ▁return ▁N ▁; ▁} ▁return ▁N ▁- ▁1 ▁; ▁} ▁static ▁int ▁count P ron ic ▁( ▁int ▁A ▁, ▁int ▁B ▁) ▁{ ▁return ▁pr onic ▁( ▁B ▁) ▁- ▁pr onic ▁( ▁A ▁- ▁1 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁A ▁= ▁3 ▁; ▁int ▁B ▁= ▁20 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁count P ron ic ▁( ▁A ▁, ▁B ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁minimum M oves ▁( ▁int ▁[ ▁] ▁a ▁, ▁int ▁n ▁) ▁{ ▁int ▁min _ element ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁int ▁max _ element ▁= ▁Integer ▁. ▁MIN _ VALUE ▁; ▁int ▁min _ ind ▁= ▁- ▁1 ▁; ▁int ▁max _ ind ▁= ▁- ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁<= ▁min _ element ▁) ▁{ ▁min _ element ▁= ▁a ▁[ ▁i ▁] ▁; ▁min _ ind ▁= ▁i ▁; ▁} ▁if ▁( ▁a ▁[ ▁i ▁] ▁> ▁max _ element ▁) ▁{ ▁max _ element ▁= ▁a ▁[ ▁i ▁] ▁; ▁max _ ind ▁= ▁i ▁; ▁} ▁} ▁if ▁( ▁max _ ind ▁== ▁min _ ind ▁) ▁{ ▁return ▁0 ▁; ▁} ▁else ▁if ▁( ▁max _ ind ▁> ▁min _ ind ▁) ▁{ ▁return ▁max _ ind ▁+ ▁( ▁n ▁- ▁min _ ind ▁- ▁2 ▁) ▁; ▁} ▁else ▁{ ▁return ▁max _ ind ▁+ ▁n ▁- ▁min _ ind ▁- ▁1 ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁35 ▁, ▁46 ▁, ▁17 ▁, ▁23 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁minimum M oves ▁( ▁arr ▁, ▁N ▁) ▁+ ▁" NEW _ LINE "); ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁find Index ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁K ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁int ▁res ▁= ▁- ▁1 ▁; ▁int ▁mini ▁= ▁( ▁int ▁) ▁1 e 9 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁temp ▁= ▁sum ▁- ▁arr ▁[ ▁i ▁] ▁; ▁if ▁( ▁temp ▁% ▁K ▁== ▁0 ▁) ▁{ ▁if ▁( ▁res ▁== ▁- ▁1 ▁mini ▁> ▁arr ▁[ ▁i ▁] ▁) ▁{ ▁res ▁= ▁i ▁+ ▁1 ▁; ▁mini ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁} ▁} ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁14 ▁, ▁7 ▁, ▁8 ▁, ▁2 ▁, ▁4 ▁} ▁; ▁int ▁K ▁= ▁7 ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁find Index ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁count Set Bits ▁( ▁int ▁N ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁while ▁( ▁N ▁!= ▁0 ▁) ▁{ ▁N ▁= ▁N ▁& ▁( ▁N ▁- ▁1 ▁) ▁; ▁count ▁++ ▁; ▁} ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁4 ▁; ▁int ▁bits ▁= ▁count Set Bits ▁( ▁N ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁O dd ▁" ▁+ ▁" ▁: ▁" ▁+ ▁( ▁int ▁) ▁( ▁Math ▁. ▁pow ▁( ▁2 ▁, ▁bits ▁) ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Even ▁" ▁+ ▁" ▁: ▁" ▁+ ▁( ▁N ▁+ ▁1 ▁- ▁( ▁int ▁) ▁( ▁Math ▁. ▁pow ▁( ▁2 ▁, ▁bits ▁) ▁) ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁double ▁find _ V ariance ▁( ▁int ▁n ▁) ▁{ ▁long ▁numerator ▁= ▁n ▁* ▁n ▁- ▁1 ▁; ▁double ▁ans ▁= ▁( ▁numerator ▁* ▁1.0 ▁) ▁/ ▁12 ▁; ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find _ V ariance ▁( ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁math ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁find Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁Map ▁< ▁Integer ▁, ▁Integer ▁> ▁map ▁= ▁new ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁! ▁map ▁. ▁containsKey ▁( ▁arr ▁[ ▁i ▁] ▁) ▁) ▁map ▁. ▁put ▁( ▁arr ▁[ ▁i ▁] ▁, ▁1 ▁) ▁; ▁else ▁map ▁. ▁replace ▁( ▁arr ▁[ ▁i ▁] ▁, ▁map ▁. ▁get ▁( ▁arr ▁[ ▁i ▁] ▁) ▁+ ▁1 ▁) ▁; ▁} ▁int ▁sum _ odd ▁= ▁0 ▁, ▁sum _ even ▁= ▁0 ▁; ▁Set ▁< ▁Map ▁. ▁Entry ▁< ▁Integer ▁, ▁Integer ▁> ▁> ▁h map ▁= ▁map ▁. ▁entrySet ▁( ▁) ▁; ▁for ▁( ▁Map ▁. ▁Entry ▁< ▁Integer ▁, ▁Integer ▁> ▁data ▁: ▁h map ▁) ▁{ ▁int ▁key ▁= ▁data ▁. ▁getKey ▁( ▁) ▁; ▁int ▁val ▁= ▁data ▁. ▁getValue ▁( ▁) ▁; ▁if ▁( ▁val ▁% ▁2 ▁!= ▁0 ▁) ▁sum _ odd ▁+= ▁( ▁key ▁) ▁* ▁( ▁val ▁) ▁; ▁if ▁( ▁val ▁% ▁2 ▁== ▁0 ▁) ▁sum _ even ▁+= ▁( ▁key ▁) ▁* ▁( ▁val ▁) ▁; ▁} ▁int ▁diff ▁= ▁sum _ even ▁- ▁sum _ odd ▁; ▁return ▁diff ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁5 ▁, ▁5 ▁, ▁2 ▁, ▁4 ▁, ▁3 ▁, ▁3 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Sum ▁( ▁arr ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁find Sum ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁1 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁a ▁) ▁; ▁return ▁; ▁} ▁int ▁s ▁= ▁a ▁+ ▁b ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁int ▁x ▁= ▁a ▁^ ▁b ▁; ▁s ▁+= ▁x ▁; ▁a ▁= ▁b ▁; ▁b ▁= ▁x ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁s ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁= ▁2 ▁, ▁b ▁= ▁5 ▁, ▁N ▁= ▁8 ▁; ▁find Sum ▁( ▁a ▁, ▁b ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁ones Com plement ▁( ▁int ▁n ▁, ▁int ▁max Element ▁) ▁{ ▁int ▁bits ▁= ▁( ▁int ▁) ▁Math ▁. ▁floor ▁( ▁( ▁Math ▁. ▁log ▁( ▁max Element ▁) ▁/ ▁Math ▁. ▁log ▁( ▁2 ▁) ▁) ▁) ▁+ ▁1 ▁; ▁return ▁( ▁( ▁1 ▁<< ▁bits ▁) ▁- ▁1 ▁) ▁^ ▁n ▁; ▁} ▁static ▁int ▁find Number ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁res ▁= ▁0 ▁; ▁int ▁max Element ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁res ▁= ▁res ▁^ ▁arr ▁[ ▁i ▁] ▁; ▁if ▁( ▁max Element ▁< ▁arr ▁[ ▁i ▁] ▁) ▁max Element ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁res ▁= ▁ones Com plement ▁( ▁res ▁, ▁max Element ▁) ▁; ▁return ▁( ▁res ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁find Number ▁( ▁arr ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁find The Gre at est X ▁( ▁int ▁P ▁, ▁int ▁Q ▁) ▁{ ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁div isi ors ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁* ▁i ▁<= ▁Q ▁; ▁i ▁++ ▁) ▁{ ▁while ▁( ▁Q ▁% ▁i ▁== ▁0 ▁&& ▁Q ▁> ▁1 ▁) ▁{ ▁Q ▁/= ▁i ▁; ▁if ▁( ▁div isi ors ▁. ▁containsKey ▁( ▁i ▁) ▁) ▁{ ▁div isi ors ▁. ▁put ▁( ▁i ▁, ▁div isi ors ▁. ▁get ▁( ▁i ▁) ▁+ ▁1 ▁) ▁; ▁} ▁else ▁{ ▁div isi ors ▁. ▁put ▁( ▁i ▁, ▁1 ▁) ▁; ▁} ▁} ▁} ▁if ▁( ▁Q ▁> ▁1 ▁) ▁if ▁( ▁div isi ors ▁. ▁containsKey ▁( ▁Q ▁) ▁) ▁{ ▁div isi ors ▁. ▁put ▁( ▁Q ▁, ▁div isi ors ▁. ▁get ▁( ▁Q ▁) ▁+ ▁1 ▁) ▁; ▁} ▁else ▁{ ▁div isi ors ▁. ▁put ▁( ▁Q ▁, ▁1 ▁) ▁; ▁} ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁Map ▁. ▁Entry ▁< ▁Integer ▁, ▁Integer ▁> ▁i ▁: ▁div isi ors ▁. ▁entrySet ▁( ▁) ▁) ▁{ ▁int ▁frequency ▁= ▁i ▁. ▁getValue ▁( ▁) ▁; ▁int ▁temp ▁= ▁P ▁; ▁int ▁cur ▁= ▁0 ▁; ▁while ▁( ▁temp ▁% ▁i ▁. ▁getKey ▁( ▁) ▁== ▁0 ▁) ▁{ ▁temp ▁/= ▁i ▁. ▁getKey ▁( ▁) ▁; ▁cur ▁++ ▁; ▁} ▁if ▁( ▁cur ▁< ▁frequency ▁) ▁{ ▁ans ▁= ▁P ▁; ▁break ▁; ▁} ▁temp ▁= ▁P ▁; ▁for ▁( ▁int ▁j ▁= ▁cur ▁; ▁j ▁>= ▁frequency ▁; ▁j ▁-- ▁) ▁{ ▁temp ▁/= ▁i ▁. ▁getKey ▁( ▁) ▁; ▁} ▁ans ▁= ▁Math ▁. ▁max ▁( ▁temp ▁, ▁ans ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁ans ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁P ▁= ▁10 ▁, ▁Q ▁= ▁4 ▁; ▁find The Gre at est X ▁( ▁P ▁, ▁Q ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁count X OR Set Bits Adj Elem Range 1_ N ▁( ▁int ▁N ▁) ▁{ ▁int ▁total _ set _ bits ▁= ▁0 ▁; ▁int ▁bit _ Position ▁= ▁1 ▁; ▁while ▁( ▁N ▁!= ▁0 ▁) ▁{ ▁total _ set _ bits ▁+= ▁( ▁( ▁N ▁+ ▁1 ▁) ▁/ ▁2 ▁* ▁bit _ Position ▁) ▁; ▁N ▁-= ▁( ▁N ▁+ ▁1 ▁) ▁/ ▁2 ▁; ▁bit _ Position ▁++ ▁; ▁} ▁return ▁total _ set _ bits ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁4 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count X OR Set Bits Adj Elem Range 1_ N ▁( ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁final ▁int ▁size _ int ▁= ▁32 ▁; ▁static ▁int ▁function Max ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁Vector ▁< ▁Integer ▁> ▁[ ▁] ▁set Bit ▁= ▁new ▁Vector ▁[ ▁32 ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁set Bit ▁. ▁length ▁; ▁i ▁++ ▁) ▁set Bit ▁[ ▁i ▁] ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁size _ int ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁( ▁arr ▁[ ▁i ▁] ▁& ▁( ▁1 ▁<< ▁j ▁) ▁) ▁> ▁0 ▁) ▁set Bit ▁[ ▁j ▁] ▁. ▁add ▁( ▁i ▁) ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁size _ int ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁set Bit ▁[ ▁i ▁] ▁. ▁size ▁( ▁) ▁== ▁1 ▁) ▁{ ▁swap ▁( ▁arr ▁, ▁0 ▁, ▁set Bit ▁[ ▁i ▁] ▁. ▁get ▁( ▁0 ▁) ▁) ▁; ▁break ▁; ▁} ▁} ▁int ▁max And ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁max And ▁= ▁max And ▁& ▁( ▁~ ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁return ▁max And ▁; ▁} ▁static ▁int ▁[ ▁] ▁swap ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁i ▁, ▁int ▁j ▁) ▁{ ▁int ▁temp ▁= ▁arr ▁[ ▁i ▁] ▁; ▁arr ▁[ ▁i ▁] ▁= ▁arr ▁[ ▁j ▁] ▁; ▁arr ▁[ ▁j ▁] ▁= ▁temp ▁; ▁return ▁arr ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁4 ▁, ▁8 ▁, ▁16 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁function Max ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁highest Power ▁( ▁int ▁n ▁) ▁{ ▁return ▁( ▁int ▁) ▁( ▁Math ▁. ▁log ▁( ▁n ▁) ▁/ ▁Math ▁. ▁log ▁( ▁2 ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁15 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁highest Power ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁print ▁( ▁int ▁N ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁100000 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁Math ▁. ▁pow ▁( ▁i ▁+ ▁1 ▁, ▁3 ▁) ▁- ▁Math ▁. ▁pow ▁( ▁i ▁, ▁3 ▁) ▁== ▁N ▁) ▁{ ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁i ▁+ ▁" ▁" ▁+ ▁j ▁) ▁; ▁return ▁; ▁} ▁} ▁} ▁static ▁boolean ▁is Perf ect Square ▁( ▁double ▁x ▁) ▁{ ▁double ▁sr ▁= ▁Math ▁. ▁sqrt ▁( ▁x ▁) ▁; ▁return ▁( ▁( ▁sr ▁- ▁Math ▁. ▁floor ▁( ▁sr ▁) ▁) ▁== ▁0 ▁) ▁; ▁} ▁static ▁boolean ▁diff Cube ▁( ▁int ▁N ▁) ▁{ ▁return ▁is Perf ect Square ▁( ▁12 ▁* ▁N ▁- ▁3 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁19 ▁; ▁if ▁( ▁diff Cube ▁( ▁N ▁) ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁print ▁( ▁N ▁) ▁; ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁boolean ▁is _ possible ▁( ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁if ▁( ▁x ▁< ▁2 ▁&& ▁y ▁!= ▁0 ▁) ▁return ▁false ▁; ▁y ▁= ▁y ▁- ▁x ▁+ ▁1 ▁; ▁if ▁( ▁y ▁% ▁2 ▁== ▁0 ▁&& ▁y ▁>= ▁0 ▁) ▁return ▁true ▁; ▁else ▁return ▁false ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁x ▁= ▁5 ▁, ▁y ▁= ▁2 ▁; ▁if ▁( ▁is _ possible ▁( ▁x ▁, ▁y ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁class ▁Node ▁{ ▁int ▁data ▁; ▁Node ▁left ▁, ▁right ▁; ▁public ▁Node ▁( ▁int ▁data ▁, ▁Node ▁left ▁, ▁Node ▁right ▁) ▁{ ▁this ▁. ▁data ▁= ▁data ▁; ▁this ▁. ▁left ▁= ▁left ▁; ▁this ▁. ▁right ▁= ▁right ▁; ▁} ▁static ▁Node ▁newNode ▁( ▁int ▁data ▁) ▁{ ▁return ▁new ▁Node ▁( ▁data ▁, ▁null ▁, ▁null ▁) ▁; ▁} ▁static ▁void ▁in order ▁( ▁Node ▁node ▁) ▁{ ▁if ▁( ▁node ▁== ▁null ▁) ▁return ▁; ▁in order ▁( ▁node ▁. ▁left ▁) ▁; ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁% ▁d ▁" ▁, ▁node ▁. ▁data ▁) ▁; ▁in order ▁( ▁node ▁. ▁right ▁) ▁; ▁} ▁static ▁Node ▁Maximum Binary Tree ▁( ▁Node ▁t 1 ▁, ▁Node ▁t 2 ▁) ▁{ ▁if ▁( ▁t 1 ▁== ▁null ▁) ▁return ▁t 2 ▁; ▁if ▁( ▁t 2 ▁== ▁null ▁) ▁return ▁t 1 ▁; ▁t 1 ▁. ▁data ▁= ▁Math ▁. ▁max ▁( ▁t 1 ▁. ▁data ▁, ▁t 2 ▁. ▁data ▁) ▁; ▁t 1 ▁. ▁left ▁= ▁Maximum Binary Tree ▁( ▁t 1 ▁. ▁left ▁, ▁t 2 ▁. ▁left ▁) ▁; ▁t 1 ▁. ▁right ▁= ▁Maximum Binary Tree ▁( ▁t 1 ▁. ▁right ▁, ▁t 2 ▁. ▁right ▁) ▁; ▁return ▁t 1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Node ▁root 1 ▁= ▁newNode ▁( ▁3 ▁) ▁; ▁root 1 ▁. ▁left ▁= ▁newNode ▁( ▁2 ▁) ▁; ▁root 1 ▁. ▁right ▁= ▁newNode ▁( ▁6 ▁) ▁; ▁root 1 ▁. ▁left ▁. ▁left ▁= ▁newNode ▁( ▁20 ▁) ▁; ▁Node ▁root 2 ▁= ▁newNode ▁( ▁5 ▁) ▁; ▁root 2 ▁. ▁left ▁= ▁newNode ▁( ▁1 ▁) ▁; ▁root 2 ▁. ▁right ▁= ▁newNode ▁( ▁8 ▁) ▁; ▁root 2 ▁. ▁left ▁. ▁right ▁= ▁newNode ▁( ▁2 ▁) ▁; ▁root 2 ▁. ▁right ▁. ▁right ▁= ▁newNode ▁( ▁8 ▁) ▁; ▁Node ▁root 3 ▁= ▁Maximum Binary Tree ▁( ▁root 1 ▁, ▁root 2 ▁) ▁; ▁in order ▁( ▁root 3 ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁power Opt im ised ▁( ▁int ▁a ▁, ▁int ▁n ▁) ▁{ ▁int ▁ans ▁= ▁1 ▁; ▁while ▁( ▁n ▁> ▁0 ▁) ▁{ ▁int ▁last _ bit ▁= ▁( ▁n ▁& ▁1 ▁) ▁; ▁if ▁( ▁last _ bit ▁> ▁0 ▁) ▁{ ▁ans ▁= ▁ans ▁* ▁a ▁; ▁} ▁a ▁= ▁a ▁* ▁a ▁; ▁n ▁= ▁n ▁>> ▁1 ▁; ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁= ▁3 ▁, ▁n ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁power Opt im ised ▁( ▁a ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁gcd ▁( ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁if ▁( ▁x ▁== ▁0 ▁) ▁return ▁y ▁; ▁return ▁gcd ▁( ▁y ▁% ▁x ▁, ▁x ▁) ▁; ▁} ▁static ▁int ▁find Distinct ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁maximum ▁= ▁Arrays ▁. ▁stream ▁( ▁arr ▁) ▁. ▁max ▁( ▁) ▁. ▁getAs Int ▁( ▁) ▁; ▁if ▁( ▁n ▁== ▁1 ▁) ▁return ▁1 ▁; ▁if ▁( ▁n ▁== ▁2 ▁) ▁{ ▁return ▁( ▁maximum ▁/ ▁gcd ▁( ▁arr ▁[ ▁0 ▁] ▁, ▁arr ▁[ ▁1 ▁] ▁) ▁) ▁; ▁} ▁int ▁k ▁= ▁gcd ▁( ▁arr ▁[ ▁0 ▁] ▁, ▁arr ▁[ ▁1 ▁] ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁k ▁= ▁gcd ▁( ▁k ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁return ▁( ▁maximum ▁/ ▁k ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Distinct ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁isEqual Fact ors ▁( ▁int ▁N ▁) ▁{ ▁int ▁ev _ count ▁= ▁0 ▁, ▁od _ count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁Math ▁. ▁sqrt ▁( ▁N ▁) ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁N ▁% ▁i ▁== ▁0 ▁) ▁{ ▁if ▁( ▁i ▁== ▁N ▁/ ▁i ▁) ▁{ ▁if ▁( ▁i ▁% ▁2 ▁== ▁0 ▁) ▁ev _ count ▁+= ▁1 ▁; ▁else ▁od _ count ▁+= ▁1 ▁; ▁} ▁else ▁{ ▁if ▁( ▁i ▁% ▁2 ▁== ▁0 ▁) ▁ev _ count ▁+= ▁1 ▁; ▁else ▁od _ count ▁+= ▁1 ▁; ▁if ▁( ▁( ▁N ▁/ ▁i ▁) ▁% ▁2 ▁== ▁0 ▁) ▁ev _ count ▁+= ▁1 ▁; ▁else ▁od _ count ▁+= ▁1 ▁; ▁} ▁} ▁} ▁if ▁( ▁ev _ count ▁== ▁od _ count ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁YES ▁" ▁+ ▁" NEW _ LINE "); ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁NO ▁" ▁+ ▁" NEW _ LINE "); ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁10 ▁; ▁isEqual Fact ors ▁( ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁max OR ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁n ▁) ▁{ ▁int ▁max _ value ▁= ▁Arrays ▁. ▁stream ▁( ▁arr ▁) ▁. ▁max ▁( ▁) ▁. ▁getAs Int ▁( ▁) ▁; ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁ans ▁= ▁Math ▁. ▁max ▁( ▁ans ▁, ▁( ▁max _ value ▁arr ▁[ ▁i ▁] ▁) ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁new ▁int ▁[ ▁] ▁{ ▁3 ▁, ▁6 ▁, ▁8 ▁, ▁16 ▁} ▁; ▁int ▁n ▁= ▁4 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁max OR ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁getSum ▁( ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁Math ▁. ▁sqrt ▁( ▁n ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁{ ▁if ▁( ▁n ▁/ ▁i ▁== ▁i ▁) ▁sum ▁= ▁sum ▁+ ▁i ▁; ▁else ▁{ ▁sum ▁= ▁sum ▁+ ▁i ▁; ▁sum ▁= ▁sum ▁+ ▁( ▁n ▁/ ▁i ▁) ▁; ▁} ▁} ▁} ▁return ▁sum ▁; ▁} ▁static ▁boolean ▁check Ab undant ▁( ▁int ▁n ▁) ▁{ ▁return ▁( ▁getSum ▁( ▁n ▁) ▁- ▁n ▁> ▁n ▁) ▁; ▁} ▁static ▁boolean ▁is Def icient ▁( ▁int ▁n ▁) ▁{ ▁return ▁( ▁getSum ▁( ▁n ▁) ▁< ▁( ▁2 ▁* ▁n ▁) ▁) ▁; ▁} ▁static ▁boolean ▁check Primitive Ab undant ▁( ▁int ▁num ▁) ▁{ ▁if ▁( ▁! ▁check Ab undant ▁( ▁num ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁Math ▁. ▁sqrt ▁( ▁num ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁num ▁% ▁i ▁== ▁0 ▁&& ▁i ▁!= ▁num ▁) ▁{ ▁if ▁( ▁i ▁* ▁i ▁== ▁num ▁) ▁{ ▁if ▁( ▁! ▁is Def icient ▁( ▁i ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁} ▁else ▁if ▁( ▁! ▁is Def icient ▁( ▁i ▁) ▁|| ▁! ▁is Def icient ▁( ▁num ▁/ ▁i ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁} ▁} ▁return ▁true ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁20 ▁; ▁if ▁( ▁check Primitive Ab undant ▁( ▁n ▁) ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Yes ▁" ▁) ▁; ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁div Sum ▁( ▁int ▁num ▁) ▁{ ▁int ▁result ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁Math ▁. ▁sqrt ▁( ▁num ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁num ▁% ▁i ▁== ▁0 ▁) ▁{ ▁if ▁( ▁i ▁== ▁( ▁num ▁/ ▁i ▁) ▁) ▁result ▁+= ▁i ▁; ▁else ▁result ▁+= ▁( ▁i ▁+ ▁num ▁/ ▁i ▁) ▁; ▁} ▁} ▁return ▁( ▁result ▁- ▁1 ▁- ▁num ▁) ▁; ▁} ▁static ▁int ▁getSum ▁( ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁while ▁( ▁n ▁!= ▁0 ▁) ▁{ ▁int ▁r ▁= ▁n ▁% ▁10 ▁; ▁sum ▁= ▁sum ▁+ ▁r ▁* ▁r ▁; ▁n ▁= ▁n ▁/ ▁10 ▁; ▁} ▁return ▁sum ▁; ▁} ▁static ▁boolean ▁is Can ada ▁( ▁int ▁n ▁) ▁{ ▁return ▁div Sum ▁( ▁n ▁) ▁== ▁getSum ▁( ▁n ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁125 ▁; ▁if ▁( ▁is Can ada ▁( ▁n ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁count Ele ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁len ▁= ▁0 ▁; ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁h map ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁len ▁= ▁Math ▁. ▁max ▁( ▁len ▁, ▁a ▁[ ▁i ▁] ▁) ▁; ▁if ▁( ▁h map ▁. ▁containsKey ▁( ▁a ▁[ ▁i ▁] ▁) ▁) ▁{ ▁h map ▁. ▁put ▁( ▁a ▁[ ▁i ▁] ▁, ▁h map ▁. ▁get ▁( ▁a ▁[ ▁i ▁] ▁) ▁+ ▁1 ▁) ▁; ▁} ▁else ▁{ ▁h map ▁. ▁put ▁( ▁a ▁[ ▁i ▁] ▁, ▁1 ▁) ▁; ▁} ▁} ▁boolean ▁[ ▁] ▁v ▁= ▁new ▁boolean ▁[ ▁len ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁len ▁; ▁i ▁++ ▁) ▁{ ▁v ▁[ ▁i ▁] ▁= ▁true ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁v ▁[ ▁a ▁[ ▁i ▁] ▁] ▁== ▁false ▁) ▁continue ▁; ▁for ▁( ▁int ▁j ▁= ▁2 ▁* ▁a ▁[ ▁i ▁] ▁; ▁j ▁<= ▁len ▁; ▁j ▁+= ▁a ▁[ ▁i ▁] ▁) ▁{ ▁v ▁[ ▁j ▁] ▁= ▁false ▁; ▁} ▁} ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁len ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁v ▁[ ▁i ▁] ▁== ▁true ▁&& ▁h map ▁. ▁containsKey ▁( ▁i ▁) ▁&& ▁h map ▁. ▁get ▁( ▁i ▁) ▁== ▁1 ▁&& ▁h map ▁. ▁get ▁( ▁i ▁) ▁== ▁1 ▁) ▁{ ▁count ▁+= ▁1 ▁; ▁} ▁} ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁86 ▁, ▁45 ▁, ▁18 ▁, ▁4 ▁, ▁8 ▁, ▁28 ▁, ▁19 ▁, ▁33 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁count Ele ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁max Ad jacent Difference ▁( ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁if ▁( ▁N ▁== ▁1 ▁) ▁{ ▁return ▁0 ▁; ▁} ▁if ▁( ▁N ▁== ▁2 ▁) ▁{ ▁return ▁K ▁; ▁} ▁return ▁2 ▁* ▁K ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁6 ▁; ▁int ▁K ▁= ▁11 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁max Ad jacent Difference ▁( ▁N ▁, ▁K ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁isP al ▁( ▁int ▁a ▁[ ▁] ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁/ ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁m ▁- ▁1 ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁[ ▁j ▁] ▁!= ▁a ▁[ ▁n ▁- ▁1 ▁- ▁i ▁] ▁[ ▁m ▁- ▁1 ▁- ▁j ▁] ▁) ▁return ▁false ▁; ▁} ▁} ▁return ▁true ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁3 ▁, ▁m ▁= ▁3 ▁; ▁int ▁a ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁, ▁{ ▁4 ▁, ▁5 ▁, ▁4 ▁} ▁, ▁{ ▁3 ▁, ▁2 ▁, ▁1 ▁} ▁} ▁; ▁if ▁( ▁isP al ▁( ▁a ▁, ▁n ▁, ▁m ▁) ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁YES ▁" ▁+ ▁" NEW _ LINE "); ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁NO ▁" ▁+ ▁" NEW _ LINE "); ▁} ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁div Sum ▁( ▁int ▁num ▁) ▁{ ▁int ▁result ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁Math ▁. ▁sqrt ▁( ▁num ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁num ▁% ▁i ▁== ▁0 ▁) ▁{ ▁if ▁( ▁i ▁== ▁( ▁num ▁/ ▁i ▁) ▁) ▁result ▁+= ▁i ▁; ▁else ▁result ▁+= ▁( ▁i ▁+ ▁num ▁/ ▁i ▁) ▁; ▁} ▁} ▁return ▁( ▁result ▁+ ▁1 ▁) ▁; ▁} ▁static ▁boolean ▁is U nt ouch able ▁( ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁2 ▁* ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁div Sum ▁( ▁i ▁) ▁== ▁n ▁) ▁return ▁false ▁; ▁} ▁return ▁true ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁52 ▁; ▁if ▁( ▁is U nt ouch able ▁( ▁n ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁gon Num 120 ▁( ▁int ▁n ▁) ▁{ ▁return ▁( ▁118 ▁* ▁n ▁* ▁n ▁- ▁116 ▁* ▁n ▁) ▁/ ▁2 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁gon Num 120 ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁construct Array ▁( ▁int ▁N ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁new ▁int ▁[ ▁N ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁= ▁i ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁" ▁, ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁6 ▁; ▁construct Array ▁( ▁N ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁find Pair ▁( ▁int ▁x ▁) ▁{ ▁int ▁lim ▁= ▁120 ▁; ▁for ▁( ▁int ▁i ▁= ▁- ▁lim ▁; ▁i ▁<= ▁lim ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁- ▁lim ▁; ▁j ▁<= ▁lim ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁Math ▁. ▁pow ▁( ▁i ▁, ▁5 ▁) ▁- ▁Math ▁. ▁pow ▁( ▁j ▁, ▁5 ▁) ▁== ▁x ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁i ▁+ ▁" ▁" ▁+ ▁j ▁+ ▁" NEW _ LINE "); ▁return ▁; ▁} ▁} ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁- ▁1" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁X ▁= ▁33 ▁; ▁find Pair ▁( ▁X ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁is Perf ect Square ▁( ▁int ▁x ▁) ▁{ ▁int ▁s ▁= ▁( ▁int ▁) ▁Math ▁. ▁sqrt ▁( ▁x ▁) ▁; ▁return ▁( ▁s ▁* ▁s ▁== ▁x ▁) ▁; ▁} ▁static ▁boolean ▁isF ib onacci ▁( ▁int ▁n ▁) ▁{ ▁return ▁is Perf ect Square ▁( ▁5 ▁* ▁n ▁* ▁n ▁+ ▁4 ▁) ▁|| ▁is Perf ect Square ▁( ▁5 ▁* ▁n ▁* ▁n ▁- ▁4 ▁) ▁; ▁} ▁static ▁boolean ▁check Digits ▁( ▁int ▁n ▁) ▁{ ▁while ▁( ▁n ▁!= ▁0 ▁) ▁{ ▁int ▁dig ▁= ▁n ▁% ▁10 ▁; ▁if ▁( ▁dig ▁== ▁4 ▁&& ▁dig ▁== ▁6 ▁&& ▁dig ▁== ▁7 ▁&& ▁dig ▁== ▁9 ▁) ▁return ▁false ▁; ▁n ▁/= ▁10 ▁; ▁} ▁return ▁true ▁; ▁} ▁static ▁boolean ▁is Full f ib onacci ▁( ▁int ▁n ▁) ▁{ ▁return ▁( ▁check Digits ▁( ▁n ▁) ▁&& ▁isF ib onacci ▁( ▁n ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁13 ▁; ▁if ▁( ▁is Full f ib onacci ▁( ▁n ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁longest Even Odd Sub array ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁longest ▁= ▁1 ▁; ▁int ▁cnt ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁a ▁[ ▁i ▁] ▁+ ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁% ▁2 ▁== ▁1 ▁) ▁{ ▁cnt ▁++ ▁; ▁} ▁else ▁{ ▁longest ▁= ▁Math ▁. ▁max ▁( ▁longest ▁, ▁cnt ▁) ▁; ▁cnt ▁= ▁1 ▁; ▁} ▁} ▁if ▁( ▁longest ▁== ▁1 ▁) ▁return ▁0 ▁; ▁return ▁Math ▁. ▁max ▁( ▁cnt ▁, ▁longest ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁7 ▁, ▁8 ▁} ▁; ▁int ▁n ▁= ▁a ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁longest Even Odd Sub array ▁( ▁a ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁find Min Div isor ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁limit ▁) ▁{ ▁int ▁low ▁= ▁0 ▁, ▁high ▁= ▁100 0000000 ▁; ▁while ▁( ▁low ▁< ▁high ▁) ▁{ ▁int ▁mid ▁= ▁( ▁low ▁+ ▁high ▁) ▁/ ▁2 ▁; ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁Math ▁. ▁ceil ▁( ▁( ▁double ▁) ▁arr ▁[ ▁i ▁] ▁/ ▁( ▁double ▁) ▁mid ▁) ▁; ▁} ▁if ▁( ▁sum ▁<= ▁limit ▁) ▁high ▁= ▁mid ▁; ▁else ▁low ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁return ▁low ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁9 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁int ▁K ▁= ▁6 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Min Div isor ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁sz ▁= ▁( ▁int ▁) ▁1 e 3 ▁; ▁static ▁boolean ▁is Even Par ity ▁( ▁int ▁x ▁) ▁{ ▁int ▁par ity ▁= ▁0 ▁; ▁while ▁( ▁x ▁!= ▁0 ▁) ▁{ ▁if ▁( ▁x ▁% ▁2 ▁== ▁1 ▁) ▁par ity ▁++ ▁; ▁x ▁= ▁x ▁>> ▁1 ▁; ▁} ▁if ▁( ▁par ity ▁% ▁2 ▁== ▁0 ▁) ▁return ▁true ▁; ▁else ▁return ▁false ▁; ▁} ▁static ▁void ▁print Array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁len ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁len ▁; ▁i ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁static ▁void ▁find Pair Even Par ity ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁len ▁) ▁{ ▁int ▁first Maximum ▁= ▁Integer ▁. ▁MIN _ VALUE ▁; ▁int ▁second Maximum ▁= ▁Integer ▁. ▁MIN _ VALUE ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁len ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁is Even Par ity ▁( ▁arr ▁[ ▁i ▁] ▁) ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁>= ▁first Maximum ▁) ▁{ ▁second Maximum ▁= ▁first Maximum ▁; ▁first Maximum ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁else ▁if ▁( ▁arr ▁[ ▁i ▁] ▁>= ▁second Maximum ▁) ▁{ ▁second Maximum ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁} ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁first Maximum ▁+ ▁" ▁" ▁+ ▁second Maximum ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁18 ▁, ▁15 ▁, ▁8 ▁, ▁9 ▁, ▁14 ▁} ▁; ▁int ▁len ▁= ▁arr ▁. ▁length ▁; ▁find Pair Even Par ity ▁( ▁arr ▁, ▁len ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁is Hex ag onal ▁( ▁int ▁N ▁) ▁{ ▁float ▁val ▁= ▁8 ▁* ▁N ▁+ ▁1 ▁; ▁float ▁x ▁= ▁1 ▁+ ▁( ▁float ▁) ▁Math ▁. ▁sqrt ▁( ▁val ▁) ▁; ▁float ▁n ▁= ▁( ▁x ▁) ▁/ ▁4 ▁; ▁if ▁( ▁( ▁n ▁- ▁( ▁int ▁) ▁n ▁) ▁== ▁0 ▁) ▁return ▁true ▁; ▁else ▁return ▁false ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁14 ▁; ▁if ▁( ▁is Hex ag onal ▁( ▁N ▁) ▁== ▁true ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁S olve ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁temp ▁= ▁0 ▁, ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁temp ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁temp ▁+= ▁arr ▁[ ▁j ▁] ▁; ▁if ▁( ▁( ▁temp ▁+ ▁2 ▁) ▁% ▁4 ▁!= ▁0 ▁) ▁count ▁++ ▁; ▁} ▁} ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁, ▁7 ▁, ▁8 ▁, ▁9 ▁, ▁10 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁S olve ▁( ▁arr ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁boolean ▁prod Square ▁( ▁int ▁n ▁) ▁{ ▁for ▁( ▁long ▁i ▁= ▁2 ▁; ▁i ▁* ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁for ▁( ▁long ▁j ▁= ▁2 ▁; ▁j ▁<= ▁n ▁; ▁j ▁++ ▁) ▁if ▁( ▁i ▁* ▁i ▁* ▁j ▁* ▁j ▁== ▁n ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁25 ▁; ▁if ▁( ▁prod Square ▁( ▁n ▁) ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁find Numbers ▁( ▁int ▁N ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁N ▁/ ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁i ▁+ ▁" ▁, ▁" ▁+ ▁- ▁i ▁+ ▁" ▁, ▁" ▁) ▁; ▁} ▁if ▁( ▁N ▁% ▁2 ▁== ▁1 ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁0 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁10 ▁; ▁find Numbers ▁( ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁count Values ▁( ▁int ▁N ▁) ▁{ ▁Vector ▁< ▁Integer ▁> ▁div ▁= ▁new ▁Vector ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁* ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁N ▁% ▁i ▁== ▁0 ▁) ▁{ ▁div ▁. ▁add ▁( ▁i ▁) ▁; ▁if ▁( ▁N ▁!= ▁i ▁* ▁i ▁) ▁{ ▁div ▁. ▁add ▁( ▁N ▁/ ▁i ▁) ▁; ▁} ▁} ▁} ▁int ▁answer ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁* ▁i ▁<= ▁N ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁N ▁- ▁1 ▁) ▁% ▁i ▁== ▁0 ▁) ▁{ ▁if ▁( ▁i ▁* ▁i ▁== ▁N ▁- ▁1 ▁) ▁answer ▁++ ▁; ▁else ▁answer ▁+= ▁2 ▁; ▁} ▁} ▁for ▁( ▁int ▁d ▁: ▁div ▁) ▁{ ▁int ▁K ▁= ▁N ▁; ▁while ▁( ▁K ▁% ▁d ▁== ▁0 ▁) ▁K ▁/= ▁d ▁; ▁if ▁( ▁( ▁K ▁- ▁1 ▁) ▁% ▁d ▁== ▁0 ▁) ▁answer ▁++ ▁; ▁} ▁return ▁answer ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁6 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁count Values ▁( ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁S olve ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁size ▁, ▁int ▁n ▁) ▁{ ▁int ▁[ ▁] ▁v ▁= ▁new ▁int ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁v ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁++ ▁; ▁int ▁max 1 ▁= ▁- ▁1 ▁, ▁mx ▁= ▁- ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁v ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁v ▁[ ▁i ▁] ▁> ▁mx ▁) ▁{ ▁mx ▁= ▁v ▁[ ▁i ▁] ▁; ▁max 1 ▁= ▁i ▁; ▁} ▁} ▁int ▁cnt ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁: ▁v ▁) ▁{ ▁if ▁( ▁i ▁== ▁0 ▁) ▁++ ▁cnt ▁; ▁} ▁int ▁diff 1 ▁= ▁n ▁+ ▁1 ▁- ▁cnt ▁; ▁int ▁max _ size ▁= ▁Math ▁. ▁max ▁( ▁Math ▁. ▁min ▁( ▁v ▁[ ▁max 1 ▁] ▁- ▁1 ▁, ▁diff 1 ▁) ▁, ▁Math ▁. ▁min ▁( ▁v ▁[ ▁max 1 ▁] ▁, ▁diff 1 ▁- ▁1 ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Maximum ▁size ▁is ▁: ▁" ▁+ ▁max _ size ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁First ▁Array ▁is ▁" ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁max _ size ▁; ▁i ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁max 1 ▁+ ▁" ▁" ▁) ▁; ▁v ▁[ ▁max 1 ▁] ▁-= ▁1 ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁The ▁Second ▁Array ▁Is ▁: ▁" ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁( ▁n ▁+ ▁1 ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁v ▁[ ▁i ▁] ▁> ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁i ▁+ ▁" ▁" ▁) ▁; ▁max _ size ▁-- ▁; ▁} ▁if ▁( ▁max _ size ▁< ▁1 ▁) ▁break ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁7 ▁; ▁int ▁arr ▁[ ▁] ▁= ▁new ▁int ▁[ ▁] ▁{ ▁1 ▁, ▁2 ▁, ▁1 ▁, ▁5 ▁, ▁1 ▁, ▁6 ▁, ▁7 ▁, ▁2 ▁} ▁; ▁int ▁size ▁= ▁arr ▁. ▁length ▁; ▁S olve ▁( ▁arr ▁, ▁size ▁, ▁n ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁class ▁Main ▁{ ▁public ▁static ▁int ▁find unique ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁k ▁) ▁{ ▁int ▁res ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁32 ▁; ▁i ▁++ ▁) ▁{ ▁int ▁p ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁a ▁. ▁length ▁; ▁j ▁++ ▁) ▁{ ▁p ▁+= ▁( ▁Math ▁. ▁abs ▁( ▁a ▁[ ▁j ▁] ▁) ▁& ▁( ▁1 ▁<< ▁i ▁) ▁) ▁!= ▁0 ▁? ▁1 ▁: ▁0 ▁; ▁} ▁p ▁% = ▁k ▁; ▁res ▁+= ▁Math ▁. ▁pow ▁( ▁2 ▁, ▁i ▁) ▁* ▁p ▁; ▁} ▁int ▁c ▁= ▁0 ▁; ▁for ▁( ▁int ▁x ▁= ▁0 ▁; ▁x ▁< ▁a ▁. ▁length ▁; ▁x ▁++ ▁) ▁if ▁( ▁a ▁[ ▁x ▁] ▁== ▁res ▁) ▁{ ▁c ▁= ▁1 ▁; ▁break ▁; ▁} ▁return ▁c ▁== ▁1 ▁? ▁res ▁: ▁- ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁12 ▁, ▁12 ▁, ▁2 ▁, ▁2 ▁, ▁3 ▁} ▁; ▁int ▁k ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find unique ▁( ▁a ▁, ▁k ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁double ▁Volume _ of _ c one ▁( ▁double ▁R ▁) ▁{ ▁double ▁V ▁= ▁( ▁double ▁) ▁( ▁( ▁1 ▁/ ▁3.0 ▁) ▁* ▁( ▁3.14 ▁) ▁* ▁( ▁2 ▁* ▁( ▁R ▁* ▁R ▁) ▁) ▁* ▁( ▁4 ▁* ▁R ▁) ▁) ▁; ▁return ▁V ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁double ▁R ▁= ▁10.0 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁Volume _ of _ c one ▁( ▁R ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁G F G ▁{ ▁static ▁void ▁find _ volume ▁( ▁double ▁area ▁, ▁double ▁h ▁) ▁{ ▁double ▁Volume ▁= ▁( ▁area ▁* ▁h ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Volume ▁: ▁" ▁+ ▁Volume ▁) ▁; ▁} ▁static ▁void ▁find _ Surface _ area ▁( ▁double ▁area ▁, ▁double ▁a ▁, ▁double ▁h ▁) ▁{ ▁double ▁Surface _ area ▁= ▁( ▁2 ▁* ▁area ▁) ▁+ ▁( ▁8 ▁* ▁a ▁* ▁h ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Surface ▁area ▁: ▁" ▁+ ▁Surface _ area ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁double ▁h ▁= ▁1 ▁; ▁double ▁a ▁= ▁6 ▁; ▁double ▁d ▁= ▁2 ▁; ▁double ▁area ▁= ▁2 ▁* ▁a ▁* ▁d ▁; ▁find _ Surface _ area ▁( ▁area ▁, ▁a ▁, ▁h ▁) ▁; ▁find _ volume ▁( ▁area ▁, ▁h ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁double ▁nth Root ▁( ▁long ▁A ▁, ▁long ▁N ▁) ▁{ ▁double ▁x Pre ▁= ▁7 ▁; ▁double ▁eps ▁= ▁1 e -3 ▁; ▁double ▁del X ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁double ▁x K ▁= ▁0 ▁; ▁while ▁( ▁del X ▁> ▁eps ▁) ▁{ ▁x K ▁= ▁( ▁( ▁N ▁- ▁1.0 ▁) ▁* ▁x Pre ▁+ ▁( ▁double ▁) ▁A ▁/ ▁Math ▁. ▁pow ▁( ▁x Pre ▁, ▁N ▁- ▁1 ▁) ▁) ▁/ ▁( ▁double ▁) ▁N ▁; ▁del X ▁= ▁Math ▁. ▁abs ▁( ▁x K ▁- ▁x Pre ▁) ▁; ▁x Pre ▁= ▁x K ▁; ▁} ▁return ▁x K ▁; ▁} ▁static ▁boolean ▁check ▁( ▁long ▁no ▁, ▁int ▁k ▁) ▁{ ▁double ▁k th _ root ▁= ▁nth Root ▁( ▁no ▁, ▁k ▁) ▁; ▁long ▁num ▁= ▁( ▁long ▁) ▁k th _ root ▁; ▁if ▁( ▁Math ▁. ▁abs ▁( ▁num ▁- ▁k th _ root ▁) ▁< ▁1 e -4 ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁static ▁void ▁print Exp o ▁( ▁long ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁check ▁( ▁arr ▁[ ▁i ▁] ▁, ▁k ▁) ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁K ▁= ▁6 ▁; ▁long ▁arr ▁[ ▁] ▁= ▁{ ▁4 66 56 ▁, ▁64 ▁, ▁256 ▁, ▁7 29 ▁, ▁16 ▁, ▁1000 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁print Exp o ▁( ▁arr ▁, ▁n ▁, ▁K ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁C nt cont Sub s ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁c ▁= ▁0 ▁, ▁d ▁= ▁0 ▁, ▁i ▁, ▁sum ▁= ▁1 ▁, ▁j ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁% ▁2 ▁!= ▁0 ▁a ▁[ ▁i ▁] ▁% ▁4 ▁== ▁0 ▁) ▁d ▁++ ▁; ▁sum ▁= ▁a ▁[ ▁i ▁] ▁; ▁for ▁( ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁sum ▁= ▁sum ▁* ▁a ▁[ ▁j ▁] ▁; ▁if ▁( ▁sum ▁% ▁2 ▁!= ▁0 ▁sum ▁% ▁4 ▁== ▁0 ▁) ▁c ▁++ ▁; ▁} ▁sum ▁= ▁1 ▁; ▁} ▁return ▁c ▁+ ▁d ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁4 ▁, ▁2 ▁, ▁9 ▁, ▁8 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁C nt cont Sub s ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁pref ▁[ ▁] ▁= ▁new ▁int ▁[ ▁10000 ▁] ▁; ▁static ▁int ▁is Perf ect ▁( ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁* ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁{ ▁if ▁( ▁i ▁* ▁i ▁!= ▁n ▁) ▁sum ▁= ▁sum ▁+ ▁i ▁+ ▁n ▁/ ▁i ▁; ▁else ▁sum ▁= ▁sum ▁+ ▁i ▁; ▁} ▁} ▁if ▁( ▁sum ▁== ▁n ▁&& ▁n ▁!= ▁1 ▁) ▁return ▁n ▁; ▁return ▁0 ▁; ▁} ▁static ▁void ▁pre com putation ▁( ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁10000 ▁; ▁++ ▁i ▁) ▁{ ▁pref ▁[ ▁i ▁] ▁= ▁pref ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁is Perf ect ▁( ▁i ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁L ▁= ▁6 ▁, ▁R ▁= ▁28 ▁; ▁pre com putation ▁( ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁pref ▁[ ▁R ▁] ▁- ▁pref ▁[ ▁L ▁- ▁1 ▁] ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁E uler T ot ient Function ▁( ▁int ▁limit ▁) ▁{ ▁int ▁copy ▁= ▁limit ▁; ▁Vector ▁< ▁Integer ▁> ▁primes ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁* ▁i ▁<= ▁limit ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁limit ▁% ▁i ▁== ▁0 ▁) ▁{ ▁while ▁( ▁limit ▁% ▁i ▁== ▁0 ▁) ▁{ ▁limit ▁/= ▁i ▁; ▁} ▁primes ▁. ▁add ▁( ▁i ▁) ▁; ▁} ▁} ▁if ▁( ▁limit ▁>= ▁2 ▁) ▁{ ▁primes ▁. ▁add ▁( ▁limit ▁) ▁; ▁} ▁int ▁ans ▁= ▁copy ▁; ▁for ▁( ▁int ▁it ▁: ▁primes ▁) ▁{ ▁ans ▁= ▁( ▁ans ▁/ ▁it ▁) ▁* ▁( ▁it ▁- ▁1 ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁static ▁void ▁Count G CD ▁( ▁int ▁m ▁, ▁int ▁k ▁) ▁{ ▁if ▁( ▁m ▁% ▁k ▁!= ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁0 ▁+ ▁" NEW _ LINE "); ▁return ▁; ▁} ▁if ▁( ▁m ▁== ▁k ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁2 ▁+ ▁" NEW _ LINE "); ▁return ▁; ▁} ▁int ▁limit ▁= ▁m ▁/ ▁k ▁; ▁int ▁ans ▁= ▁E uler T ot ient Function ▁( ▁limit ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁ans ▁+ ▁" NEW _ LINE "); ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁M ▁= ▁9 ▁; ▁int ▁K ▁= ▁1 ▁; ▁Count G CD ▁( ▁M ▁, ▁K ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁fib ▁( ▁int ▁n ▁) ▁{ ▁double ▁phi ▁= ▁( ▁1 ▁+ ▁Math ▁. ▁sqrt ▁( ▁5 ▁) ▁) ▁/ ▁2 ▁; ▁return ▁( ▁int ▁) ▁Math ▁. ▁round ▁( ▁Math ▁. ▁pow ▁( ▁phi ▁, ▁n ▁) ▁/ ▁Math ▁. ▁sqrt ▁( ▁5 ▁) ▁) ▁; ▁} ▁static ▁int ▁calculate Sum ▁( ▁int ▁l ▁, ▁int ▁r ▁) ▁{ ▁int ▁sum ▁= ▁fib ▁( ▁r ▁+ ▁2 ▁) ▁- ▁fib ▁( ▁l ▁+ ▁1 ▁) ▁; ▁return ▁sum ▁; ▁} ▁static ▁int ▁sum F ib onacci ▁( ▁int ▁k ▁) ▁{ ▁int ▁l ▁= ▁( ▁k ▁* ▁( ▁k ▁- ▁1 ▁) ▁) ▁/ ▁2 ▁; ▁int ▁r ▁= ▁l ▁+ ▁k ▁; ▁int ▁sum ▁= ▁calculate Sum ▁( ▁l ▁, ▁r ▁- ▁1 ▁) ▁; ▁return ▁sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁k ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁sum F ib onacci ▁( ▁k ▁) ▁) ▁; ▁} ▁}
▁class ▁Sum ▁{ ▁void ▁sum Of Prev K ▁( ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁new ▁int ▁[ ▁N ▁] ▁; ▁arr ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁int ▁j ▁= ▁i ▁- ▁1 ▁, ▁count ▁= ▁0 ▁, ▁sum ▁= ▁0 ▁; ▁while ▁( ▁j ▁>= ▁0 ▁&& ▁count ▁< ▁K ▁) ▁{ ▁sum ▁+= ▁arr ▁[ ▁j ▁] ▁; ▁j ▁-- ▁; ▁count ▁++ ▁; ▁} ▁arr ▁[ ▁i ▁] ▁= ▁sum ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁Sum ▁s ▁= ▁new ▁Sum ▁( ▁) ▁; ▁int ▁N ▁= ▁10 ▁, ▁K ▁= ▁4 ▁; ▁s ▁. ▁sum Of Prev K ▁( ▁N ▁, ▁K ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁find Real And Im ag ▁( ▁String ▁s ▁) ▁{ ▁int ▁l ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁int ▁i ▁; ▁if ▁( ▁s ▁. ▁indexOf ▁( ▁' ▁+ ▁' ▁) ▁!= ▁- ▁1 ▁) ▁{ ▁i ▁= ▁s ▁. ▁indexOf ▁( ▁' ▁+ ▁' ▁) ▁; ▁} ▁else ▁{ ▁i ▁= ▁s ▁. ▁indexOf ▁( ▁' ▁- ▁' ▁) ▁; ▁} ▁String ▁real ▁= ▁s ▁. ▁substring ▁( ▁0 ▁, ▁i ▁) ▁; ▁String ▁imag inary ▁= ▁s ▁. ▁substring ▁( ▁i ▁+ ▁1 ▁, ▁l ▁- ▁1 ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Real ▁part ▁: ▁" ▁+ ▁real ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Imag inary ▁part ▁: ▁" ▁+ ▁imag inary ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁s ▁= ▁"3 ▁+ ▁4 i ▁" ▁; ▁find Real And Im ag ▁( ▁s ▁) ▁; ▁} ▁}
▁class ▁G eek s ▁{ ▁static ▁int ▁reverse ▁( ▁int ▁num ▁) ▁{ ▁int ▁rev _ num ▁= ▁0 ▁; ▁while ▁( ▁num ▁> ▁0 ▁) ▁{ ▁rev _ num ▁= ▁rev _ num ▁* ▁10 ▁+ ▁num ▁% ▁10 ▁; ▁num ▁= ▁num ▁/ ▁10 ▁; ▁} ▁return ▁rev _ num ▁; ▁} ▁static ▁int ▁count Reverse ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁res ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁if ▁( ▁reverse ▁( ▁arr ▁[ ▁i ▁] ▁) ▁== ▁arr ▁[ ▁j ▁] ▁) ▁{ ▁res ▁++ ▁; ▁} ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁16 ▁, ▁61 ▁, ▁12 ▁, ▁21 ▁, ▁25 ▁} ▁; ▁int ▁n ▁= ▁a ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁count Reverse ▁( ▁a ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁print Series Sum ▁( ▁int ▁N ▁) ▁{ ▁double ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁% ▁2 ▁== ▁1 ▁) ▁{ ▁sum ▁+= ▁( ▁double ▁) ▁i ▁/ ▁( ▁i ▁+ ▁1 ▁) ▁; ▁} ▁else ▁{ ▁sum ▁-= ▁( ▁double ▁) ▁i ▁/ ▁( ▁i ▁+ ▁1 ▁) ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁sum ▁+ ▁" NEW _ LINE "); ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁10 ▁; ▁print Series Sum ▁( ▁N ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁String ▁sum Base B ▁( ▁String ▁a ▁, ▁String ▁b ▁, ▁int ▁base ▁) ▁{ ▁int ▁len _ a ▁, ▁len _ b ▁; ▁len _ a ▁= ▁a ▁. ▁length ▁( ▁) ▁; ▁len _ b ▁= ▁b ▁. ▁length ▁( ▁) ▁; ▁String ▁sum ▁, ▁s ▁; ▁s ▁= ▁" ▁" ▁; ▁sum ▁= ▁" ▁" ▁; ▁int ▁diff ▁; ▁diff ▁= ▁Math ▁. ▁abs ▁( ▁len _ a ▁- ▁len _ b ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁diff ▁; ▁i ▁++ ▁) ▁s ▁+= ▁"0" ▁; ▁if ▁( ▁len _ a ▁< ▁len _ b ▁) ▁a ▁= ▁s ▁+ ▁a ▁; ▁else ▁b ▁= ▁s ▁+ ▁b ▁; ▁int ▁curr ▁, ▁carry ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁Math ▁. ▁max ▁( ▁len _ a ▁, ▁len _ b ▁) ▁- ▁1 ▁; ▁i ▁> ▁- ▁1 ▁; ▁i ▁-- ▁) ▁{ ▁curr ▁= ▁carry ▁+ ▁( ▁a ▁. ▁charAt ▁( ▁i ▁) ▁- ▁'0' ▁) ▁+ ▁( ▁b ▁. ▁charAt ▁( ▁i ▁) ▁- ▁'0' ▁) ▁; ▁carry ▁= ▁curr ▁/ ▁base ▁; ▁curr ▁= ▁curr ▁% ▁base ▁; ▁sum ▁= ▁( ▁char ▁) ▁( ▁curr ▁+ ▁'0' ▁) ▁+ ▁sum ▁; ▁} ▁if ▁( ▁carry ▁> ▁0 ▁) ▁sum ▁= ▁( ▁char ▁) ▁( ▁carry ▁+ ▁'0' ▁) ▁+ ▁sum ▁; ▁return ▁sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁a ▁, ▁b ▁, ▁sum ▁; ▁int ▁base ▁; ▁a ▁= ▁"123" ▁; ▁b ▁= ▁" 234 " ▁; ▁base ▁= ▁6 ▁; ▁sum ▁= ▁sum Base B ▁( ▁a ▁, ▁b ▁, ▁base ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁sum ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁create Hash ▁( ▁HashSet ▁< ▁Integer ▁> ▁hash ▁, ▁int ▁max Element ▁) ▁{ ▁int ▁prev ▁= ▁0 ▁, ▁curr ▁= ▁1 ▁; ▁hash ▁. ▁add ▁( ▁prev ▁) ▁; ▁hash ▁. ▁add ▁( ▁curr ▁) ▁; ▁while ▁( ▁curr ▁<= ▁max Element ▁) ▁{ ▁int ▁temp ▁= ▁curr ▁+ ▁prev ▁; ▁hash ▁. ▁add ▁( ▁temp ▁) ▁; ▁prev ▁= ▁curr ▁; ▁curr ▁= ▁temp ▁; ▁} ▁} ▁static ▁int ▁count F ib onacci Div is ors ▁( ▁int ▁n ▁) ▁{ ▁HashSet ▁< ▁Integer ▁> ▁hash ▁= ▁new ▁HashSet ▁< ▁Integer ▁> ▁( ▁) ▁; ▁create Hash ▁( ▁hash ▁, ▁n ▁) ▁; ▁int ▁cnt ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁Math ▁. ▁sqrt ▁( ▁n ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁{ ▁if ▁( ▁( ▁n ▁/ ▁i ▁== ▁i ▁) ▁&& ▁( ▁hash ▁. ▁contains ▁( ▁n ▁/ ▁i ▁) ▁) ▁) ▁cnt ▁++ ▁; ▁else ▁{ ▁if ▁( ▁hash ▁. ▁contains ▁( ▁n ▁/ ▁i ▁) ▁) ▁cnt ▁++ ▁; ▁if ▁( ▁hash ▁. ▁contains ▁( ▁n ▁/ ▁( ▁n ▁/ ▁i ▁) ▁) ▁) ▁cnt ▁++ ▁; ▁} ▁} ▁} ▁return ▁cnt ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁12 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁count F ib onacci Div is ors ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁boolean ▁is Perf ect Cube ▁( ▁int ▁x ▁) ▁{ ▁long ▁cr ▁= ▁Math ▁. ▁round ▁( ▁Math ▁. ▁c br t ▁( ▁x ▁) ▁) ▁; ▁return ▁( ▁cr ▁* ▁cr ▁* ▁cr ▁== ▁x ▁) ▁; ▁} ▁static ▁void ▁check Cube ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁String ▁s 1 ▁= ▁Integer ▁. ▁toString ▁( ▁a ▁) ▁; ▁String ▁s 2 ▁= ▁Integer ▁. ▁toString ▁( ▁b ▁) ▁; ▁int ▁c ▁= ▁Integer ▁. ▁parseInt ▁( ▁s 1 ▁+ ▁s 2 ▁) ▁; ▁if ▁( ▁is Perf ect Cube ▁( ▁c ▁) ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁= ▁6 ▁; ▁int ▁b ▁= ▁4 ▁; ▁check Cube ▁( ▁a ▁, ▁b ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁is Perf ect Square ▁( ▁int ▁x ▁) ▁{ ▁int ▁s ▁= ▁( ▁int ▁) ▁Math ▁. ▁sqrt ▁( ▁x ▁) ▁; ▁return ▁( ▁s ▁* ▁s ▁== ▁x ▁) ▁; ▁} ▁static ▁boolean ▁isF ib onacci ▁( ▁int ▁N ▁) ▁{ ▁return ▁is Perf ect Square ▁( ▁5 ▁* ▁N ▁* ▁N ▁+ ▁4 ▁) ▁|| ▁is Perf ect Square ▁( ▁5 ▁* ▁N ▁* ▁N ▁- ▁4 ▁) ▁; ▁} ▁static ▁int ▁next Non F ib onacci ▁( ▁int ▁N ▁) ▁{ ▁if ▁( ▁N ▁<= ▁3 ▁) ▁return ▁4 ▁; ▁if ▁( ▁isF ib onacci ▁( ▁N ▁+ ▁1 ▁) ▁) ▁return ▁N ▁+ ▁2 ▁; ▁else ▁return ▁N ▁+ ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁next Non F ib onacci ▁( ▁N ▁) ▁+ ▁" NEW _ LINE "); ▁N ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁next Non F ib onacci ▁( ▁N ▁) ▁+ ▁" NEW _ LINE "); ▁N ▁= ▁7 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁next Non F ib onacci ▁( ▁N ▁) ▁+ ▁" NEW _ LINE "); ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁count Digit ▁( ▁int ▁n ▁) ▁{ ▁boolean ▁prime ▁[ ▁] ▁= ▁new ▁boolean ▁[ ▁10 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁10 ▁; ▁i ▁++ ▁) ▁prime ▁[ ▁i ▁] ▁= ▁false ▁; ▁prime ▁[ ▁2 ▁] ▁= ▁prime ▁[ ▁3 ▁] ▁= ▁true ▁; ▁prime ▁[ ▁5 ▁] ▁= ▁prime ▁[ ▁7 ▁] ▁= ▁true ▁; ▁int ▁temp ▁= ▁n ▁, ▁count ▁= ▁0 ▁; ▁while ▁( ▁temp ▁!= ▁0 ▁) ▁{ ▁int ▁d ▁= ▁temp ▁% ▁10 ▁; ▁temp ▁/= ▁10 ▁; ▁if ▁( ▁d ▁> ▁0 ▁&& ▁n ▁% ▁d ▁== ▁0 ▁&& ▁prime ▁[ ▁d ▁] ▁== ▁true ▁) ▁count ▁++ ▁; ▁} ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁10 32 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Digit ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁find Roots ▁( ▁int ▁b ▁, ▁int ▁c ▁) ▁{ ▁int ▁a ▁= ▁1 ▁; ▁int ▁d ▁= ▁b ▁* ▁b ▁- ▁4 ▁* ▁a ▁* ▁c ▁; ▁double ▁sqrt _ val ▁= ▁Math ▁. ▁sqrt ▁( ▁Math ▁. ▁abs ▁( ▁d ▁) ▁) ▁; ▁if ▁( ▁d ▁> ▁0 ▁) ▁{ ▁double ▁x ▁= ▁- ▁b ▁+ ▁sqrt _ val ▁; ▁double ▁y ▁= ▁- ▁b ▁- ▁sqrt _ val ▁; ▁int ▁root 1 ▁= ▁( ▁int ▁) ▁( ▁x ▁) ▁/ ▁( ▁2 ▁* ▁a ▁) ▁; ▁int ▁root 2 ▁= ▁( ▁int ▁) ▁( ▁y ▁) ▁/ ▁( ▁2 ▁* ▁a ▁) ▁; ▁if ▁( ▁root 1 ▁+ ▁root 2 ▁== ▁- ▁1 ▁* ▁b ▁&& ▁root 1 ▁* ▁root 2 ▁== ▁c ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁root 1 ▁+ ▁" ▁, ▁" ▁+ ▁root 2 ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁- ▁1 ▁) ▁; ▁} ▁else ▁if ▁( ▁d ▁== ▁0 ▁) ▁{ ▁int ▁root ▁= ▁- ▁b ▁/ ▁( ▁2 ▁* ▁a ▁) ▁; ▁if ▁( ▁root ▁+ ▁root ▁== ▁- ▁1 ▁* ▁b ▁&& ▁root ▁* ▁root ▁== ▁c ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁root ▁+ ▁" ▁, ▁" ▁+ ▁root ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁- ▁1 ▁) ▁; ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁- ▁1 ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁S ▁= ▁5 ▁, ▁P ▁= ▁6 ▁; ▁find Roots ▁( ▁- ▁S ▁, ▁P ▁) ▁; ▁S ▁= ▁5 ▁; ▁P ▁= ▁9 ▁; ▁find Roots ▁( ▁- ▁S ▁, ▁P ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁find Numbers ▁( ▁int ▁N ▁) ▁{ ▁int ▁i ▁= ▁1 ▁; ▁while ▁( ▁i ▁<= ▁N ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁( ▁i ▁* ▁i ▁* ▁i ▁) ▁+ ▁" ▁" ▁) ▁; ▁i ▁++ ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁4 ▁; ▁find Numbers ▁( ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁get numbers ▁( ▁int ▁n ▁) ▁{ ▁Vector ▁< ▁Integer ▁> ▁divisor ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁* ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁while ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁{ ▁divisor ▁. ▁add ▁( ▁i ▁) ▁; ▁n ▁/= ▁i ▁; ▁} ▁} ▁if ▁( ▁n ▁!= ▁1 ▁) ▁{ ▁divisor ▁. ▁add ▁( ▁n ▁) ▁; ▁} ▁int ▁a ▁, ▁b ▁, ▁c ▁, ▁size ▁; ▁a ▁= ▁b ▁= ▁c ▁= ▁1 ▁; ▁size ▁= ▁divisor ▁. ▁size ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁== ▁1 ▁) ▁{ ▁a ▁= ▁a ▁* ▁divisor ▁. ▁get ▁( ▁i ▁) ▁; ▁} ▁else ▁if ▁( ▁b ▁== ▁1 ▁b ▁== ▁a ▁) ▁{ ▁b ▁= ▁b ▁* ▁divisor ▁. ▁get ▁( ▁i ▁) ▁; ▁} ▁else ▁{ ▁c ▁= ▁c ▁* ▁divisor ▁. ▁get ▁( ▁i ▁) ▁; ▁} ▁} ▁if ▁( ▁a ▁== ▁1 ▁b ▁== ▁1 ▁c ▁== ▁1 ▁a ▁== ▁b ▁b ▁== ▁c ▁a ▁== ▁c ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁- ▁1" ▁+ ▁" NEW _ LINE "); ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁a ▁+ ▁" ▁" ▁+ ▁b ▁+ ▁" ▁" ▁+ ▁c ▁+ ▁" NEW _ LINE "); ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁64 ▁; ▁get numbers ▁( ▁n ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁Vector ▁< ▁Integer ▁> ▁prime Fact ors ▁( ▁int ▁n ▁) ▁{ ▁int ▁i ▁, ▁j ▁; ▁Vector ▁< ▁Integer ▁> ▁Prime ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁if ▁( ▁n ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁Prime ▁. ▁add ▁( ▁2 ▁) ▁; ▁} ▁while ▁( ▁n ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁n ▁= ▁n ▁/ ▁2 ▁; ▁} ▁for ▁( ▁i ▁= ▁3 ▁; ▁i ▁<= ▁Math ▁. ▁sqrt ▁( ▁n ▁) ▁; ▁i ▁= ▁i ▁+ ▁2 ▁) ▁{ ▁if ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁{ ▁Prime ▁. ▁add ▁( ▁i ▁) ▁; ▁} ▁while ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁{ ▁n ▁= ▁n ▁/ ▁i ▁; ▁} ▁} ▁if ▁( ▁n ▁> ▁2 ▁) ▁{ ▁Prime ▁. ▁add ▁( ▁n ▁) ▁; ▁} ▁return ▁Prime ▁; ▁} ▁static ▁void ▁check Distinct Prime ▁( ▁int ▁n ▁) ▁{ ▁Vector ▁< ▁Integer ▁> ▁Prime ▁= ▁prime Fact ors ▁( ▁n ▁) ▁; ▁int ▁product ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁: ▁Prime ▁) ▁{ ▁product ▁*= ▁i ▁; ▁} ▁if ▁( ▁product ▁== ▁n ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁YES ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁NO ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁30 ▁; ▁check Distinct Prime ▁( ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁lang ▁. ▁Math ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁void ▁find Sum ▁( ▁int ▁N ▁) ▁{ ▁int ▁sum ▁= ▁( ▁N ▁) ▁* ▁( ▁N ▁+ ▁1 ▁) ▁/ ▁2 ▁; ▁int ▁r ▁= ▁( ▁int ▁) ▁( ▁Math ▁. ▁log ▁( ▁N ▁) ▁/ ▁Math ▁. ▁log ▁( ▁2 ▁) ▁) ▁+ ▁1 ▁; ▁int ▁exp Sum ▁= ▁( ▁int ▁) ▁( ▁Math ▁. ▁pow ▁( ▁2 ▁, ▁r ▁) ▁) ▁- ▁1 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁sum ▁- ▁exp Sum ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁2 ▁; ▁find Sum ▁( ▁N ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁remaining Area ▁( ▁int ▁N ▁, ▁int ▁M ▁, ▁int ▁K ▁) ▁{ ▁while ▁( ▁K ▁-- ▁> ▁0 ▁&& ▁N ▁> ▁0 ▁&& ▁M ▁> ▁0 ▁) ▁{ ▁if ▁( ▁N ▁> ▁M ▁) ▁N ▁= ▁N ▁- ▁M ▁; ▁else ▁M ▁= ▁M ▁- ▁N ▁; ▁} ▁if ▁( ▁N ▁> ▁0 ▁&& ▁M ▁> ▁0 ▁) ▁return ▁N ▁* ▁M ▁; ▁else ▁return ▁0 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁5 ▁, ▁M ▁= ▁3 ▁, ▁K ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁remaining Area ▁( ▁N ▁, ▁M ▁, ▁K ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁boolean ▁isP ossible ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁, ▁max S ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁a ▁[ ▁i ▁] ▁; ▁max S ▁= ▁Math ▁. ▁max ▁( ▁a ▁[ ▁i ▁] ▁, ▁max S ▁) ▁; ▁} ▁if ▁( ▁( ▁sum ▁- ▁max S ▁) ▁> ▁max S ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁n ▁= ▁a ▁. ▁length ▁; ▁if ▁( ▁isP ossible ▁( ▁a ▁, ▁n ▁) ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁HashMap ▁; ▁import ▁java ▁. ▁util ▁. ▁Map ▁; ▁class ▁G f G ▁{ ▁static ▁Pair ▁< ▁Integer ▁, ▁Integer ▁> ▁find Four th Vertex ▁( ▁int ▁n ▁, ▁int ▁m ▁, ▁String ▁s ▁[ ▁] ▁) ▁{ ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁row ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁col ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁m ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁s ▁[ ▁i ▁] ▁. ▁charAt ▁( ▁j ▁) ▁== ▁' ▁* ▁' ▁) ▁{ ▁if ▁( ▁row ▁. ▁containsKey ▁( ▁i ▁) ▁) ▁{ ▁row ▁. ▁put ▁( ▁i ▁, ▁row ▁. ▁get ▁( ▁i ▁) ▁+ ▁1 ▁) ▁; ▁} ▁else ▁{ ▁row ▁. ▁put ▁( ▁i ▁, ▁1 ▁) ▁; ▁} ▁if ▁( ▁col ▁. ▁containsKey ▁( ▁j ▁) ▁) ▁{ ▁col ▁. ▁put ▁( ▁j ▁, ▁col ▁. ▁get ▁( ▁j ▁) ▁+ ▁1 ▁) ▁; ▁} ▁else ▁{ ▁col ▁. ▁put ▁( ▁j ▁, ▁1 ▁) ▁; ▁} ▁} ▁} ▁} ▁int ▁x ▁= ▁0 ▁, ▁y ▁= ▁0 ▁; ▁for ▁( ▁Map ▁. ▁Entry ▁< ▁Integer ▁, ▁Integer ▁> ▁entry ▁: ▁row ▁. ▁entrySet ▁( ▁) ▁) ▁{ ▁if ▁( ▁entry ▁. ▁getValue ▁( ▁) ▁== ▁1 ▁) ▁x ▁= ▁entry ▁. ▁getKey ▁( ▁) ▁; ▁} ▁for ▁( ▁Map ▁. ▁Entry ▁< ▁Integer ▁, ▁Integer ▁> ▁entry ▁: ▁col ▁. ▁entrySet ▁( ▁) ▁) ▁{ ▁if ▁( ▁entry ▁. ▁getValue ▁( ▁) ▁== ▁1 ▁) ▁y ▁= ▁entry ▁. ▁getKey ▁( ▁) ▁; ▁} ▁Pair ▁< ▁Integer ▁, ▁Integer ▁> ▁ans ▁= ▁new ▁Pair ▁< ▁> ▁( ▁x ▁+ ▁1 ▁, ▁y ▁+ ▁1 ▁) ▁; ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁s ▁[ ▁] ▁= ▁{ ▁" ▁* ▁. ▁* ▁" ▁, ▁" ▁* ▁. ▁. ▁" ▁, ▁" ▁. ▁. ▁. ▁" ▁} ▁; ▁int ▁n ▁= ▁s ▁. ▁length ▁; ▁int ▁m ▁= ▁s ▁[ ▁0 ▁] ▁. ▁length ▁( ▁) ▁; ▁Pair ▁< ▁Integer ▁, ▁Integer ▁> ▁rs ▁= ▁find Four th Vertex ▁( ▁n ▁, ▁m ▁, ▁s ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁rs ▁. ▁first ▁+ ▁" ▁" ▁+ ▁rs ▁. ▁second ▁) ▁; ▁} ▁} ▁class ▁Pair ▁< ▁A ▁, ▁B ▁> ▁{ ▁A ▁first ▁; ▁B ▁second ▁; ▁public ▁Pair ▁( ▁A ▁first ▁, ▁B ▁second ▁) ▁{ ▁this ▁. ▁first ▁= ▁first ▁; ▁this ▁. ▁second ▁= ▁second ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁float ▁con e ▁( ▁float ▁a ▁) ▁{ ▁if ▁( ▁a ▁< ▁0 ▁) ▁return ▁- ▁1 ▁; ▁float ▁r ▁= ▁( ▁float ▁) ▁( ▁a ▁* ▁Math ▁. ▁sqrt ▁( ▁2 ▁) ▁) ▁/ ▁3 ▁; ▁float ▁h ▁= ▁( ▁2 ▁* ▁a ▁) ▁/ ▁3 ▁; ▁float ▁V ▁= ▁( ▁float ▁) ▁( ▁3.14 ▁* ▁Math ▁. ▁pow ▁( ▁r ▁, ▁2 ▁) ▁* ▁h ▁) ▁; ▁return ▁V ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁float ▁a ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁con e ▁( ▁a ▁) ▁) ▁; ▁} ▁}
▁class ▁Solution ▁{ ▁static ▁float ▁square Area ▁( ▁float ▁a ▁) ▁{ ▁if ▁( ▁a ▁< ▁0 ▁) ▁return ▁- ▁1 ▁; ▁float ▁area ▁= ▁( ▁float ▁) ▁( ▁Math ▁. ▁pow ▁( ▁1. 268 ▁, ▁2 ▁) ▁* ▁Math ▁. ▁pow ▁( ▁a ▁, ▁2 ▁) ▁) ▁; ▁return ▁area ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁float ▁a ▁= ▁6 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁square Area ▁( ▁a ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁double ▁PI ▁= ▁3.14 159 265 ▁; ▁public ▁static ▁double ▁length _ ro pe ▁( ▁double ▁r ▁) ▁{ ▁return ▁( ▁( ▁2 ▁* ▁PI ▁* ▁r ▁) ▁+ ▁6 ▁* ▁r ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁double ▁r ▁= ▁7 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁length _ ro pe ▁( ▁r ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁float ▁s ph ▁( ▁float ▁r ▁, ▁float ▁h ▁) ▁{ ▁if ▁( ▁r ▁< ▁0 ▁&& ▁h ▁< ▁0 ▁) ▁return ▁- ▁1 ▁; ▁float ▁R ▁= ▁r ▁; ▁return ▁R ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁float ▁r ▁= ▁4 ▁, ▁h ▁= ▁8 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁s ph ▁( ▁r ▁, ▁h ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁numberOf C uts ▁( ▁int ▁M ▁, ▁int ▁N ▁) ▁{ ▁int ▁result ▁= ▁0 ▁; ▁result ▁= ▁( ▁M ▁- ▁1 ▁) ▁* ▁( ▁N ▁- ▁1 ▁) ▁; ▁return ▁result ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁M ▁= ▁4 ▁, ▁N ▁= ▁4 ▁; ▁int ▁C uts ▁= ▁numberOf C uts ▁( ▁M ▁, ▁N ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Maximum ▁c uts ▁= ▁" ▁+ ▁C uts ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁solution ▁{ ▁static ▁void ▁equation _ par ab ola ▁( ▁float ▁x 1 ▁, ▁float ▁y 1 ▁, ▁float ▁a ▁, ▁float ▁b ▁, ▁float ▁c ▁) ▁{ ▁float ▁t ▁= ▁a ▁* ▁a ▁+ ▁b ▁* ▁b ▁; ▁float ▁a 1 ▁= ▁t ▁- ▁( ▁a ▁* ▁a ▁) ▁; ▁float ▁b 1 ▁= ▁t ▁- ▁( ▁b ▁* ▁b ▁) ▁; ▁float ▁c 1 ▁= ▁( ▁- ▁2 ▁* ▁t ▁* ▁x 1 ▁) ▁- ▁( ▁2 ▁* ▁c ▁* ▁a ▁) ▁; ▁float ▁d 1 ▁= ▁( ▁- ▁2 ▁* ▁t ▁* ▁y 1 ▁) ▁- ▁( ▁2 ▁* ▁c ▁* ▁b ▁) ▁; ▁float ▁e 1 ▁= ▁- ▁2 ▁* ▁a ▁* ▁b ▁; ▁float ▁f 1 ▁= ▁( ▁- ▁c ▁* ▁c ▁) ▁+ ▁( ▁t ▁* ▁x 1 ▁* ▁x 1 ▁) ▁+ ▁( ▁t ▁* ▁y 1 ▁* ▁y 1 ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁equation ▁of ▁par ab ola ▁is ▁" ▁+ ▁a 1 ▁+ ▁" ▁x ▁^ ▁2 ▁+ ▁" ▁+ ▁b 1 ▁+ ▁" ▁y ▁^ ▁2 ▁+ ▁" ▁+ ▁c 1 ▁+ ▁" ▁x ▁+ ▁" ▁+ ▁d 1 ▁+ ▁" ▁y ▁+ ▁" ▁+ ▁e 1 ▁+ ▁" ▁xy ▁+ ▁" ▁+ ▁f 1 ▁+ ▁" ▁= ▁0 ▁. ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁arr ▁[ ▁] ▁) ▁{ ▁float ▁x 1 ▁= ▁0 ▁; ▁float ▁y 1 ▁= ▁0 ▁; ▁float ▁a ▁= ▁3 ▁; ▁float ▁b ▁= ▁- ▁4 ▁; ▁float ▁c ▁= ▁2 ▁; ▁equation _ par ab ola ▁( ▁x 1 ▁, ▁y 1 ▁, ▁a ▁, ▁b ▁, ▁c ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁float ▁area ▁( ▁float ▁r ▁) ▁{ ▁return ▁( ▁float ▁) ▁( ▁( ▁0.5 ▁) ▁* ▁( ▁3.14 ▁) ▁* ▁( ▁r ▁* ▁r ▁) ▁) ▁; ▁} ▁static ▁float ▁per imeter ▁( ▁float ▁r ▁) ▁{ ▁return ▁( ▁float ▁) ▁( ▁( ▁3.14 ▁) ▁* ▁( ▁r ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁float ▁r ▁= ▁10 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁The ▁Area ▁of ▁Sem ic ircle ▁: ▁" ▁+ ▁area ▁( ▁r ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁The ▁Per imeter ▁of ▁Sem ic ircle ▁: ▁" ▁+ ▁+ ▁per imeter ▁( ▁r ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁public ▁class ▁G F G ▁{ ▁static ▁boolean ▁Ar rive ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁>= ▁Math ▁. ▁abs ▁( ▁a ▁) ▁+ ▁Math ▁. ▁abs ▁( ▁b ▁) ▁&& ▁( ▁n ▁- ▁( ▁Math ▁. ▁abs ▁( ▁a ▁) ▁+ ▁Math ▁. ▁abs ▁( ▁b ▁) ▁) ▁) ▁% ▁2 ▁== ▁0 ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁return ▁0 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁= ▁5 ▁, ▁b ▁= ▁5 ▁, ▁n ▁= ▁11 ▁; ▁if ▁( ▁Ar rive ▁( ▁a ▁, ▁b ▁, ▁n ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁float ▁triangle area ▁( ▁float ▁l ▁, ▁float ▁b ▁) ▁{ ▁if ▁( ▁l ▁< ▁0 ▁b ▁< ▁0 ▁) ▁return ▁- ▁1 ▁; ▁float ▁area ▁= ▁( ▁l ▁* ▁b ▁) ▁/ ▁2 ▁; ▁return ▁area ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁float ▁l ▁= ▁5 ▁, ▁b ▁= ▁4 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁triangle area ▁( ▁l ▁, ▁b ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁G F G ▁{ ▁static ▁float ▁square Area ▁( ▁float ▁l ▁, ▁float ▁b ▁, ▁float ▁h ▁) ▁{ ▁if ▁( ▁l ▁< ▁0 ▁b ▁< ▁0 ▁h ▁< ▁0 ▁) ▁return ▁- ▁1 ▁; ▁float ▁a ▁= ▁( ▁l ▁* ▁b ▁) ▁/ ▁( ▁l ▁+ ▁b ▁) ▁; ▁return ▁a ▁* ▁a ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁float ▁l ▁= ▁5 ▁, ▁b ▁= ▁12 ▁, ▁h ▁= ▁13 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁square Area ▁( ▁l ▁, ▁b ▁, ▁h ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁Find Points ▁( ▁int ▁x 1 ▁, ▁int ▁y 1 ▁, ▁int ▁x 2 ▁, ▁int ▁y 2 ▁, ▁int ▁x 3 ▁, ▁int ▁y 3 ▁, ▁int ▁x 4 ▁, ▁int ▁y 4 ▁) ▁{ ▁int ▁x 5 ▁= ▁Math ▁. ▁max ▁( ▁x 1 ▁, ▁x 3 ▁) ▁; ▁int ▁y 5 ▁= ▁Math ▁. ▁max ▁( ▁y 1 ▁, ▁y 3 ▁) ▁; ▁int ▁x 6 ▁= ▁Math ▁. ▁min ▁( ▁x 2 ▁, ▁x 4 ▁) ▁; ▁int ▁y 6 ▁= ▁Math ▁. ▁min ▁( ▁y 2 ▁, ▁y 4 ▁) ▁; ▁if ▁( ▁x 5 ▁> ▁x 6 ▁y 5 ▁> ▁y 6 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁intersection ▁" ▁) ▁; ▁return ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁( ▁" ▁+ ▁x 5 ▁+ ▁" ▁, ▁" ▁+ ▁y 5 ▁+ ▁" ▁) ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁( ▁" ▁+ ▁x 6 ▁+ ▁" ▁, ▁" ▁+ ▁y 6 ▁+ ▁" ▁) ▁" ▁) ▁; ▁int ▁x 7 ▁= ▁x 5 ▁; ▁int ▁y 7 ▁= ▁y 6 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁( ▁" ▁+ ▁x 7 ▁+ ▁" ▁, ▁" ▁+ ▁y 7 ▁+ ▁" ▁) ▁" ▁) ▁; ▁int ▁x 8 ▁= ▁x 6 ▁; ▁int ▁y 8 ▁= ▁y 5 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁( ▁" ▁+ ▁x 8 ▁+ ▁" ▁, ▁" ▁+ ▁y 8 ▁+ ▁" ▁) ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁x 1 ▁= ▁0 ▁, ▁y 1 ▁= ▁0 ▁, ▁x 2 ▁= ▁10 ▁, ▁y 2 ▁= ▁8 ▁; ▁int ▁x 3 ▁= ▁2 ▁, ▁y 3 ▁= ▁3 ▁, ▁x 4 ▁= ▁7 ▁, ▁y 4 ▁= ▁9 ▁; ▁Find Points ▁( ▁x 1 ▁, ▁y 1 ▁, ▁x 2 ▁, ▁y 2 ▁, ▁x 3 ▁, ▁y 3 ▁, ▁x 4 ▁, ▁y 4 ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁equation _ plane ▁( ▁float ▁x 1 ▁, ▁float ▁y 1 ▁, ▁float ▁z 1 ▁, ▁float ▁x 2 ▁, ▁float ▁y 2 ▁, ▁float ▁z 2 ▁, ▁float ▁x 3 ▁, ▁float ▁y 3 ▁, ▁float ▁z 3 ▁) ▁{ ▁float ▁a 1 ▁= ▁x 2 ▁- ▁x 1 ▁; ▁float ▁b 1 ▁= ▁y 2 ▁- ▁y 1 ▁; ▁float ▁c 1 ▁= ▁z 2 ▁- ▁z 1 ▁; ▁float ▁a 2 ▁= ▁x 3 ▁- ▁x 1 ▁; ▁float ▁b 2 ▁= ▁y 3 ▁- ▁y 1 ▁; ▁float ▁c 2 ▁= ▁z 3 ▁- ▁z 1 ▁; ▁float ▁a ▁= ▁b 1 ▁* ▁c 2 ▁- ▁b 2 ▁* ▁c 1 ▁; ▁float ▁b ▁= ▁a 2 ▁* ▁c 1 ▁- ▁a 1 ▁* ▁c 2 ▁; ▁float ▁c ▁= ▁a 1 ▁* ▁b 2 ▁- ▁b 1 ▁* ▁a 2 ▁; ▁float ▁d ▁= ▁( ▁- ▁a ▁* ▁x 1 ▁- ▁b ▁* ▁y 1 ▁- ▁c ▁* ▁z 1 ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁equation ▁of ▁plane ▁is ▁" ▁+ ▁a ▁+ ▁" ▁x ▁+ ▁" ▁+ ▁b ▁+ ▁" ▁y ▁+ ▁" ▁+ ▁c ▁+ ▁" ▁z ▁+ ▁" ▁+ ▁d ▁+ ▁" ▁= ▁0 ▁. ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁float ▁x 1 ▁= ▁- ▁1 ▁; ▁float ▁y 1 ▁= ▁2 ▁; ▁float ▁z 1 ▁= ▁1 ▁; ▁float ▁x 2 ▁= ▁0 ▁; ▁float ▁y 2 ▁= ▁- ▁3 ▁; ▁float ▁z 2 ▁= ▁2 ▁; ▁float ▁x 3 ▁= ▁1 ▁; ▁float ▁y 3 ▁= ▁1 ▁; ▁float ▁z 3 ▁= ▁- ▁4 ▁; ▁equation _ plane ▁( ▁x 1 ▁, ▁y 1 ▁, ▁z 1 ▁, ▁x 2 ▁, ▁y 2 ▁, ▁z 2 ▁, ▁x 3 ▁, ▁y 3 ▁, ▁z 3 ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁solution ▁{ ▁static ▁void ▁oct ant ▁( ▁float ▁x ▁, ▁float ▁y ▁, ▁float ▁z ▁) ▁{ ▁if ▁( ▁x ▁>= ▁0 ▁&& ▁y ▁>= ▁0 ▁&& ▁z ▁>= ▁0 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Point ▁lies ▁in ▁1 st ▁oct ant ▁" ▁) ▁; ▁else ▁if ▁( ▁x ▁< ▁0 ▁&& ▁y ▁>= ▁0 ▁&& ▁z ▁>= ▁0 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Point ▁lies ▁in ▁2 nd ▁oct ant ▁" ▁) ▁; ▁else ▁if ▁( ▁x ▁< ▁0 ▁&& ▁y ▁< ▁0 ▁&& ▁z ▁>= ▁0 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Point ▁lies ▁in ▁3 rd ▁oct ant ▁" ▁) ▁; ▁else ▁if ▁( ▁x ▁>= ▁0 ▁&& ▁y ▁< ▁0 ▁&& ▁z ▁>= ▁0 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Point ▁lies ▁in ▁4 th ▁oct ant ▁" ▁) ▁; ▁else ▁if ▁( ▁x ▁>= ▁0 ▁&& ▁y ▁>= ▁0 ▁&& ▁z ▁< ▁0 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Point ▁lies ▁in ▁5 th ▁oct ant ▁" ▁) ▁; ▁else ▁if ▁( ▁x ▁< ▁0 ▁&& ▁y ▁>= ▁0 ▁&& ▁z ▁< ▁0 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Point ▁lies ▁in ▁6 th ▁oct ant ▁" ▁) ▁; ▁else ▁if ▁( ▁x ▁< ▁0 ▁&& ▁y ▁< ▁0 ▁&& ▁z ▁< ▁0 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Point ▁lies ▁in ▁7 th ▁oct ant ▁" ▁) ▁; ▁else ▁if ▁( ▁x ▁>= ▁0 ▁&& ▁y ▁< ▁0 ▁&& ▁z ▁< ▁0 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Point ▁lies ▁in ▁8 th ▁oct ant ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁float ▁x ▁= ▁2 ▁, ▁y ▁= ▁3 ▁, ▁z ▁= ▁4 ▁; ▁oct ant ▁( ▁x ▁, ▁y ▁, ▁z ▁) ▁; ▁x ▁= ▁- ▁4 ▁; ▁y ▁= ▁2 ▁; ▁z ▁= ▁- ▁8 ▁; ▁oct ant ▁( ▁x ▁, ▁y ▁, ▁z ▁) ▁; ▁x ▁= ▁- ▁6 ▁; ▁y ▁= ▁- ▁2 ▁; ▁z ▁= ▁8 ▁; ▁oct ant ▁( ▁x ▁, ▁y ▁, ▁z ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁p ent agon _ py ramid al ▁( ▁int ▁n ▁) ▁{ ▁return ▁n ▁* ▁n ▁* ▁( ▁n ▁+ ▁1 ▁) ▁/ ▁2 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁4 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁p ent agon _ py ramid al ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁other EndPoint ▁( ▁int ▁x 1 ▁, ▁int ▁y 1 ▁, ▁int ▁m 1 ▁, ▁int ▁m 2 ▁) ▁{ ▁float ▁x 2 ▁= ▁( ▁float ▁) ▁( ▁2 ▁* ▁m 1 ▁- ▁x 1 ▁) ▁; ▁float ▁y 2 ▁= ▁( ▁float ▁) ▁( ▁2 ▁* ▁m 2 ▁- ▁y 1 ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁x 2 ▁= ▁" ▁+ ▁x 2 ▁+ ▁" ▁, ▁" ▁+ ▁" ▁y 2 ▁= ▁" ▁+ ▁y 2 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁x 1 ▁= ▁- ▁4 ▁, ▁y 1 ▁= ▁- ▁1 ▁, ▁m 1 ▁= ▁3 ▁, ▁m 2 ▁= ▁5 ▁; ▁other EndPoint ▁( ▁x 1 ▁, ▁y 1 ▁, ▁m 1 ▁, ▁m 2 ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁find Triangle ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁b ▁[ ▁] ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁b ▁[ ▁i ▁] ▁= ▁a ▁[ ▁i ▁] ▁* ▁a ▁[ ▁i ▁] ▁; ▁Arrays ▁. ▁sort ▁( ▁a ▁) ▁; ▁Arrays ▁. ▁sort ▁( ▁b ▁) ▁; ▁int ▁x ▁= ▁0 ▁, ▁y ▁= ▁0 ▁, ▁z ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁p ▁= ▁i ▁+ ▁1 ▁; ▁int ▁q ▁= ▁i ▁+ ▁1 ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁while ▁( ▁p ▁< ▁n ▁- ▁1 ▁&& ▁b ▁[ ▁i ▁] ▁+ ▁b ▁[ ▁j ▁] ▁>= ▁b ▁[ ▁p ▁+ ▁1 ▁] ▁) ▁p ▁++ ▁; ▁q ▁= ▁Math ▁. ▁max ▁( ▁q ▁, ▁p ▁) ▁; ▁while ▁( ▁q ▁< ▁n ▁- ▁1 ▁&& ▁a ▁[ ▁i ▁] ▁+ ▁a ▁[ ▁j ▁] ▁> ▁a ▁[ ▁q ▁+ ▁1 ▁] ▁) ▁q ▁++ ▁; ▁if ▁( ▁b ▁[ ▁i ▁] ▁+ ▁b ▁[ ▁j ▁] ▁== ▁b ▁[ ▁p ▁] ▁) ▁{ ▁x ▁+= ▁Math ▁. ▁max ▁( ▁p ▁- ▁j ▁- ▁1 ▁, ▁0 ▁) ▁; ▁y ▁++ ▁; ▁z ▁+= ▁q ▁- ▁p ▁; ▁} ▁else ▁{ ▁x ▁+= ▁Math ▁. ▁max ▁( ▁p ▁- ▁j ▁, ▁0 ▁) ▁; ▁z ▁+= ▁q ▁- ▁p ▁; ▁} ▁} ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Ac ute ▁Triangle ▁: ▁" ▁+ ▁x ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Right ▁Triangle ▁: ▁" ▁+ ▁y ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Ob t use ▁Triangle ▁: ▁" ▁+ ▁z ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁9 ▁, ▁10 ▁, ▁12 ▁, ▁15 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁find Triangle ▁( ▁arr ▁, ▁n ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁double ▁polygon Area ▁( ▁double ▁X ▁[ ▁] ▁, ▁double ▁Y ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁double ▁area ▁= ▁0.0 ▁; ▁int ▁j ▁= ▁n ▁- ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁area ▁+= ▁( ▁X ▁[ ▁j ▁] ▁+ ▁X ▁[ ▁i ▁] ▁) ▁* ▁( ▁Y ▁[ ▁j ▁] ▁- ▁Y ▁[ ▁i ▁] ▁) ▁; ▁j ▁= ▁i ▁; ▁} ▁return ▁Math ▁. ▁abs ▁( ▁area ▁/ ▁2.0 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁double ▁X ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁2 ▁, ▁4 ▁} ▁; ▁double ▁Y ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁7 ▁} ▁; ▁int ▁n ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁polygon Area ▁( ▁X ▁, ▁Y ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁math ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁double ▁polygon Area ▁( ▁double ▁X ▁[ ▁] ▁, ▁double ▁Y ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁double ▁area ▁= ▁0.0 ▁; ▁int ▁j ▁= ▁n ▁- ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁area ▁+= ▁( ▁X ▁[ ▁j ▁] ▁+ ▁X ▁[ ▁i ▁] ▁) ▁* ▁( ▁Y ▁[ ▁j ▁] ▁- ▁Y ▁[ ▁i ▁] ▁) ▁; ▁j ▁= ▁i ▁; ▁} ▁return ▁Math ▁. ▁abs ▁( ▁area ▁/ ▁2.0 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁double ▁X ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁2 ▁, ▁4 ▁} ▁; ▁double ▁Y ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁7 ▁} ▁; ▁int ▁n ▁= ▁X ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁polygon Area ▁( ▁X ▁, ▁Y ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁G F G ▁{ ▁final ▁static ▁int ▁max n ▁= ▁10000 1 ▁; ▁static ▁int ▁gp f ▁[ ▁] ▁= ▁new ▁int ▁[ ▁max n ▁] ▁; ▁static ▁void ▁modified S ieve ▁( ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁max n ▁; ▁i ▁++ ▁) ▁gp f ▁[ ▁i ▁] ▁= ▁0 ▁; ▁gp f ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁gp f ▁[ ▁1 ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁< ▁max n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁gp f ▁[ ▁i ▁] ▁> ▁0 ▁) ▁continue ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁< ▁max n ▁; ▁j ▁+= ▁i ▁) ▁{ ▁gp f ▁[ ▁j ▁] ▁= ▁Math ▁. ▁max ▁( ▁i ▁, ▁gp f ▁[ ▁j ▁] ▁) ▁; ▁} ▁} ▁} ▁static ▁int ▁greatest Valid Int ▁( ▁int ▁N ▁) ▁{ ▁modified S ieve ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁N ▁; ▁i ▁> ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁gp f ▁[ ▁i ▁] ▁> ▁Math ▁. ▁sqrt ▁( ▁i ▁) ▁) ▁{ ▁return ▁i ▁; ▁} ▁} ▁return ▁- ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁25 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁greatest Valid Int ▁( ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁double ▁sub factor ial ▁( ▁int ▁N ▁) ▁{ ▁double ▁res ▁= ▁0 ▁, ▁fact ▁= ▁1 ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁fact ▁= ▁fact ▁* ▁i ▁; ▁if ▁( ▁count ▁% ▁2 ▁== ▁0 ▁) ▁res ▁= ▁res ▁- ▁( ▁1 ▁/ ▁fact ▁) ▁; ▁else ▁res ▁= ▁res ▁+ ▁( ▁1 ▁/ ▁fact ▁) ▁; ▁count ▁++ ▁; ▁} ▁return ▁fact ▁* ▁( ▁1 ▁+ ▁res ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁4 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁( ▁int ▁) ▁( ▁sub factor ial ▁( ▁N ▁) ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁count Pairs ▁( ▁int ▁N ▁) ▁{ ▁int ▁res ▁= ▁0 ▁; ▁for ▁( ▁int ▁q ▁= ▁1 ▁; ▁q ▁* ▁q ▁<= ▁N ▁; ▁q ▁++ ▁) ▁{ ▁int ▁max P ▁= ▁Math ▁. ▁min ▁( ▁2 ▁* ▁N ▁- ▁q ▁, ▁N ▁/ ▁q ▁) ▁; ▁if ▁( ▁max P ▁< ▁q ▁) ▁continue ▁; ▁int ▁cnt ▁= ▁max P ▁- ▁q ▁+ ▁1 ▁; ▁res ▁+= ▁( ▁cnt ▁/ ▁2 ▁+ ▁( ▁cnt ▁& ▁1 ▁) ▁) ▁; ▁} ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁count Pairs ▁( ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁last Positive Element ▁( ▁int ▁[ ▁] ▁arr ▁) ▁{ ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁if ▁( ▁N ▁== ▁1 ▁) ▁return ▁arr ▁[ ▁0 ▁] ▁; ▁int ▁greatest ▁= ▁- ▁1 ▁, ▁second Gre at est ▁= ▁- ▁1 ▁; ▁for ▁( ▁int ▁x ▁: ▁arr ▁) ▁{ ▁if ▁( ▁x ▁>= ▁greatest ▁) ▁{ ▁second Gre at est ▁= ▁greatest ▁; ▁greatest ▁= ▁x ▁; ▁} ▁else ▁if ▁( ▁x ▁>= ▁second Gre at est ▁) ▁{ ▁second Gre at est ▁= ▁x ▁; ▁} ▁} ▁return ▁greatest ▁- ▁second Gre at est ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁3 ▁, ▁5 ▁, ▁4 ▁, ▁7 ▁} ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁last Positive Element ▁( ▁arr ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁find Sum Of All Sub sets ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁factorial _ N ▁= ▁1 ▁, ▁factorial _ d ▁= ▁1 ▁, ▁factorial _ D ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁factorial _ N ▁*= ▁i ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁k ▁- ▁1 ▁; ▁i ▁++ ▁) ▁factorial _ d ▁*= ▁i ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁- ▁k ▁; ▁i ▁++ ▁) ▁factorial _ D ▁*= ▁i ▁; ▁int ▁freq ▁= ▁factorial _ N ▁/ ▁( ▁factorial _ d ▁* ▁factorial _ D ▁) ▁; ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁sum ▁= ▁sum ▁* ▁freq ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Sum ▁of ▁all ▁subsets ▁of ▁size ▁= ▁" ▁+ ▁k ▁+ ▁" ▁is ▁= ▁> ▁" ▁+ ▁sum ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁4 ▁, ▁k ▁= ▁2 ▁; ▁find Sum Of All Sub sets ▁( ▁arr ▁, ▁n ▁, ▁k ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁maximum Tri plet X OR ▁( ▁int ▁A ▁, ▁int ▁B ▁, ▁int ▁C ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁30 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁int ▁cur ▁= ▁1 ▁<< ▁i ▁; ▁if ▁( ▁A ▁>= ▁cur ▁) ▁{ ▁ans ▁+= ▁cur ▁; ▁A ▁-= ▁cur ▁; ▁} ▁else ▁if ▁( ▁B ▁>= ▁cur ▁) ▁{ ▁ans ▁+= ▁cur ▁; ▁B ▁-= ▁cur ▁; ▁} ▁else ▁if ▁( ▁C ▁>= ▁cur ▁) ▁{ ▁ans ▁+= ▁cur ▁; ▁C ▁-= ▁cur ▁; ▁} ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁A ▁= ▁6 ▁; ▁int ▁B ▁= ▁2 ▁; ▁int ▁C ▁= ▁10 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁maximum Tri plet X OR ▁( ▁A ▁, ▁B ▁, ▁C ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁max Unique Elements ▁( ▁int ▁[ ▁] ▁Arr ▁, ▁int ▁N ▁) ▁{ ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁mp ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁mp ▁. ▁containsKey ▁( ▁Arr ▁[ ▁i ▁] ▁) ▁) ▁{ ▁mp ▁. ▁put ▁( ▁Arr ▁[ ▁i ▁] ▁, ▁mp ▁. ▁get ▁( ▁Arr ▁[ ▁i ▁] ▁) ▁+ ▁1 ▁) ▁; ▁} ▁else ▁{ ▁mp ▁. ▁put ▁( ▁Arr ▁[ ▁i ▁] ▁, ▁1 ▁) ▁; ▁} ▁} ▁int ▁cnt ▁= ▁0 ▁; ▁for ▁( ▁Map ▁. ▁Entry ▁< ▁Integer ▁, ▁Integer ▁> ▁entry ▁: ▁mp ▁. ▁entrySet ▁( ▁) ▁) ▁{ ▁if ▁( ▁( ▁entry ▁. ▁getValue ▁( ▁) ▁) ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁cnt ▁++ ▁; ▁} ▁} ▁int ▁ans ▁= ▁mp ▁. ▁size ▁( ▁) ▁; ▁if ▁( ▁cnt ▁% ▁2 ▁== ▁1 ▁) ▁{ ▁ans ▁-- ▁; ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁5 ▁; ▁int ▁A ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁1 ▁, ▁3 ▁, ▁7 ▁} ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁max Unique Elements ▁( ▁A ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁m ▁= ▁100 000000 7 ▁; ▁static ▁int ▁power ▁( ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁int ▁res ▁= ▁1 ▁; ▁while ▁( ▁y ▁> ▁0 ▁) ▁{ ▁if ▁( ▁( ▁y ▁& ▁1 ▁) ▁!= ▁0 ▁) ▁res ▁= ▁( ▁res ▁* ▁x ▁) ▁% ▁m ▁; ▁y ▁= ▁y ▁>> ▁1 ▁; ▁x ▁= ▁( ▁x ▁* ▁x ▁) ▁% ▁m ▁; ▁} ▁return ▁res ▁; ▁} ▁static ▁int ▁count ND ig it Number ▁( ▁int ▁N ▁) ▁{ ▁int ▁ne ▁= ▁N ▁/ ▁2 ▁+ ▁N ▁% ▁2 ▁; ▁int ▁no ▁= ▁( ▁int ▁) ▁Math ▁. ▁floor ▁( ▁N ▁/ ▁2 ▁) ▁; ▁return ▁power ▁( ▁4 ▁, ▁ne ▁) ▁* ▁power ▁( ▁5 ▁, ▁no ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count ND ig it Number ▁( ▁N ▁) ▁% ▁m ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁awt ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁class ▁pair ▁< ▁T ▁, ▁V ▁> ▁{ ▁T ▁first ▁; ▁V ▁second ▁; ▁} ▁static ▁void ▁find Pairs ▁( ▁int ▁p ▁, ▁int ▁q ▁, ▁int ▁r ▁) ▁{ ▁ArrayList ▁< ▁Integer ▁> ▁v ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁p ▁; ▁i ▁<= ▁q ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁% ▁r ▁== ▁0 ▁) ▁{ ▁v ▁. ▁add ▁( ▁i ▁) ▁; ▁} ▁} ▁ArrayList ▁< ▁pair ▁< ▁Integer ▁, ▁Integer ▁> ▁> ▁ans ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁v ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁v ▁. ▁size ▁( ▁) ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁v ▁. ▁get ▁( ▁i ▁) ▁* ▁v ▁. ▁get ▁( ▁j ▁) ▁>= ▁p ▁* ▁q ▁/ ▁4 ▁&& ▁v ▁. ▁get ▁( ▁i ▁) ▁* ▁v ▁. ▁get ▁( ▁j ▁) ▁<= ▁p ▁* ▁q ▁) ▁{ ▁pair ▁< ▁Integer ▁, ▁Integer ▁> ▁x ▁= ▁new ▁pair ▁< ▁> ▁( ▁) ▁; ▁x ▁. ▁first ▁= ▁v ▁. ▁get ▁( ▁i ▁) ▁; ▁x ▁. ▁second ▁= ▁v ▁. ▁get ▁( ▁j ▁) ▁; ▁ans ▁. ▁add ▁( ▁x ▁) ▁; ▁} ▁} ▁} ▁if ▁( ▁ans ▁. ▁size ▁( ▁) ▁== ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁- ▁1 ▁) ▁; ▁} ▁else ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁ans ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁ans ▁. ▁get ▁( ▁i ▁) ▁. ▁first ▁+ ▁" ▁" ▁+ ▁ans ▁. ▁get ▁( ▁i ▁) ▁. ▁second ▁) ▁; ▁} ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁p ▁= ▁14 ▁, ▁q ▁= ▁30 ▁, ▁r ▁= ▁5 ▁; ▁find Pairs ▁( ▁p ▁, ▁q ▁, ▁r ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁K ad ane ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁largest Sum ▁= ▁0 ▁, ▁curr Max ▁= ▁0 ▁; ▁int ▁curr Sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁curr Sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁curr Max ▁= ▁Math ▁. ▁max ▁( ▁curr Max ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁largest Sum ▁= ▁Math ▁. ▁max ▁( ▁largest Sum ▁, ▁curr Max ▁* ▁curr Sum ▁) ▁; ▁if ▁( ▁curr Sum ▁< ▁0 ▁) ▁{ ▁curr Max ▁= ▁0 ▁; ▁curr Sum ▁= ▁0 ▁; ▁} ▁} ▁return ▁largest Sum ▁; ▁} ▁static ▁int ▁maximum Weight ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁largest Sum ▁= ▁K ad ane ▁( ▁arr ▁, ▁n ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁arr ▁[ ▁i ▁] ▁= ▁- ▁arr ▁[ ▁i ▁] ▁; ▁} ▁largest Sum ▁= ▁Math ▁. ▁max ▁( ▁largest Sum ▁, ▁K ad ane ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁return ▁largest Sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁- ▁3 ▁, ▁8 ▁, ▁- ▁2 ▁, ▁5 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁maximum Weight ▁( ▁arr ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁G F G ▁{ ▁static ▁int ▁maximum Turn s ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁Count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁while ▁( ▁arr ▁[ ▁i ▁] ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁Count ▁++ ▁; ▁arr ▁[ ▁i ▁] ▁= ▁arr ▁[ ▁i ▁] ▁/ ▁2 ▁; ▁} ▁} ▁return ▁Count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁2 ▁, ▁4 ▁} ▁; ▁int ▁M ▁= ▁3 ▁, ▁K ▁= ▁2 ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁maximum Turn s ▁( ▁arr ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁void ▁isP ossible ▁( ▁int ▁W ▁, ▁int ▁B ▁, ▁int ▁D ▁) ▁{ ▁if ▁( ▁W ▁> ▁B ▁) ▁{ ▁int ▁temp ▁= ▁W ▁; ▁W ▁= ▁B ▁; ▁B ▁= ▁temp ▁; ▁} ▁if ▁( ▁B ▁> ▁W ▁* ▁( ▁D ▁+ ▁1 ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁NO ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁YES ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁W ▁= ▁2 ▁; ▁int ▁B ▁= ▁5 ▁; ▁int ▁D ▁= ▁2 ▁; ▁isP ossible ▁( ▁W ▁, ▁B ▁, ▁D ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁int ▁GC D ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁if ▁( ▁b ▁== ▁0 ▁) ▁return ▁a ▁; ▁return ▁GC D ▁( ▁b ▁, ▁a ▁% ▁b ▁) ▁; ▁} ▁public ▁static ▁int ▁max G CD In Range ▁( ▁int ▁L ▁, ▁int ▁R ▁) ▁{ ▁int ▁ans ▁= ▁1 ▁; ▁for ▁( ▁int ▁Z ▁= ▁R ▁; ▁Z ▁>= ▁1 ▁; ▁Z ▁-- ▁) ▁{ ▁if ▁( ▁( ▁R ▁/ ▁Z ▁) ▁- ▁( ▁L ▁- ▁1 ▁) ▁/ ▁Z ▁> ▁1 ▁) ▁{ ▁ans ▁= ▁Z ▁; ▁break ▁; ▁} ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁L ▁= ▁102 ▁; ▁int ▁R ▁= ▁139 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁max G CD In Range ▁( ▁L ▁, ▁R ▁) ▁) ▁; ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁is Prime ▁( ▁int ▁X ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁* ▁i ▁<= ▁X ▁; ▁i ▁++ ▁) ▁if ▁( ▁X ▁% ▁i ▁== ▁0 ▁) ▁return ▁false ▁; ▁return ▁true ▁; ▁} ▁static ▁void ▁print Pr imes ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁A ▁[ ▁i ▁] ▁- ▁1 ▁; ▁; ▁j ▁-- ▁) ▁{ ▁if ▁( ▁is Prime ▁( ▁j ▁) ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁j ▁+ ▁" ▁" ▁) ▁; ▁break ▁; ▁} ▁} ▁for ▁( ▁int ▁j ▁= ▁A ▁[ ▁i ▁] ▁+ ▁1 ▁; ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁is Prime ▁( ▁j ▁) ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁j ▁+ ▁" ▁" ▁) ▁; ▁break ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁17 ▁, ▁28 ▁} ▁; ▁int ▁N ▁= ▁A ▁. ▁length ▁; ▁print Pr imes ▁( ▁A ▁, ▁N ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁public ▁static ▁int ▁find Num ▁( ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁int ▁rem ▁= ▁( ▁N ▁+ ▁K ▁) ▁% ▁K ▁; ▁if ▁( ▁rem ▁== ▁0 ▁) ▁return ▁N ▁; ▁else ▁return ▁N ▁+ ▁K ▁- ▁rem ▁; ▁} ▁public ▁static ▁int ▁find Small est ▁( ▁int ▁M ▁, ▁int ▁N ▁) ▁{ ▁int ▁x ▁= ▁find Num ▁( ▁M ▁, ▁N ▁) ▁; ▁return ▁x ▁- ▁M ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁M ▁= ▁100 ▁, ▁N ▁= ▁28 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Small est ▁( ▁M ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁min Time ▁( ▁int ▁[ ▁] ▁A ▁, ▁int ▁n ▁, ▁int ▁K ▁) ▁{ ▁int ▁max _ ability ▁= ▁A ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁max _ ability ▁= ▁Math ▁. ▁max ▁( ▁max _ ability ▁, ▁A ▁[ ▁i ▁] ▁) ▁; ▁} ▁int ▁tmp ▁[ ▁] ▁= ▁new ▁int ▁[ ▁max _ ability ▁+ ▁1 ▁] ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁tmp ▁[ ▁A ▁[ ▁i ▁] ▁] ▁++ ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁max _ ability ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁tmp ▁[ ▁i ▁] ▁!= ▁0 ▁) ▁{ ▁if ▁( ▁tmp ▁[ ▁i ▁] ▁* ▁i ▁< ▁K ▁) ▁{ ▁K ▁-= ▁( ▁i ▁* ▁tmp ▁[ ▁i ▁] ▁) ▁; ▁tmp ▁[ ▁i ▁/ ▁2 ▁] ▁+= ▁tmp ▁[ ▁i ▁] ▁; ▁count ▁+= ▁tmp ▁[ ▁i ▁] ▁; ▁if ▁( ▁K ▁<= ▁0 ▁) ▁{ ▁return ▁count ▁; ▁} ▁} ▁else ▁{ ▁if ▁( ▁K ▁% ▁i ▁!= ▁0 ▁) ▁{ ▁count ▁+= ▁( ▁K ▁/ ▁i ▁) ▁+ ▁1 ▁; ▁} ▁else ▁{ ▁count ▁+= ▁( ▁K ▁/ ▁i ▁) ▁; ▁} ▁return ▁count ▁; ▁} ▁} ▁} ▁return ▁- ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁1 ▁, ▁7 ▁, ▁2 ▁, ▁4 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁int ▁K ▁= ▁15 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁min Time ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁public ▁static ▁int ▁min Operations ▁( ▁int ▁N ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁new ▁int ▁[ ▁N ▁] ▁; ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁arr ▁[ ▁i ▁] ▁= ▁( ▁2 ▁* ▁i ▁) ▁+ ▁1 ▁; ▁sum ▁= ▁sum ▁+ ▁arr ▁[ ▁i ▁] ▁; ▁} ▁int ▁mid ▁= ▁0 ▁; ▁if ▁( ▁N ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁mid ▁= ▁sum ▁/ ▁N ▁; ▁} ▁else ▁{ ▁mid ▁= ▁arr ▁[ ▁N ▁/ ▁2 ▁] ▁; ▁} ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁/ ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁ans ▁+= ▁mid ▁- ▁arr ▁[ ▁i ▁] ▁; ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁6 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁min Operations ▁( ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁public ▁class ▁G F G ▁{ ▁static ▁void ▁Query ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁Q ▁[ ▁] ▁[ ▁] ▁) ▁{ ▁int ▁mul ▁= ▁1 ▁; ▁int ▁add ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁Q ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁Q ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁== ▁0 ▁) ▁{ ▁add ▁= ▁add ▁+ ▁Q ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁; ▁} ▁else ▁if ▁( ▁Q ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁== ▁1 ▁) ▁{ ▁mul ▁= ▁mul ▁* ▁Q ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁; ▁add ▁= ▁add ▁* ▁Q ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁; ▁} ▁else ▁{ ▁int ▁ans ▁= ▁arr ▁[ ▁Q ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁] ▁* ▁mul ▁+ ▁add ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁ans ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁1 ▁, ▁23 ▁, ▁45 ▁, ▁100 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁int ▁Q ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁} ▁, ▁{ ▁0 ▁, ▁10 ▁} ▁, ▁{ ▁2 ▁, ▁3 ▁} ▁, ▁{ ▁1 ▁, ▁5 ▁} ▁, ▁{ ▁2 ▁, ▁4 ▁} ▁} ▁; ▁Query ▁( ▁arr ▁, ▁N ▁, ▁Q ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁public ▁class ▁G F G ▁{ ▁static ▁int ▁getMax Pair Sum ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁int ▁[ ▁] ▁pre Max ▁= ▁new ▁int ▁[ ▁N ▁] ▁; ▁pre Max ▁[ ▁0 ▁] ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁pre Max ▁[ ▁i ▁] ▁= ▁Math ▁. ▁max ▁( ▁pre Max ▁[ ▁i ▁- ▁1 ▁] ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁int ▁res ▁= ▁Integer ▁. ▁MIN _ VALUE ▁; ▁for ▁( ▁int ▁i ▁= ▁K ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁res ▁= ▁Math ▁. ▁max ▁( ▁res ▁, ▁arr ▁[ ▁i ▁] ▁+ ▁pre Max ▁[ ▁i ▁- ▁K ▁] ▁) ▁; ▁} ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁4 ▁, ▁8 ▁, ▁6 ▁, ▁3 ▁} ▁; ▁int ▁K ▁= ▁3 ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁getMax Pair Sum ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁Count Pairs ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁res ▁= ▁0 ▁; ▁Map ▁< ▁Integer ▁, ▁Integer ▁> ▁mp ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁Integer ▁c ▁= ▁mp ▁. ▁get ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁mp ▁. ▁put ▁( ▁arr ▁[ ▁i ▁] ▁, ▁( ▁c ▁== ▁null ▁) ▁? ▁1 ▁: ▁c ▁+ ▁1 ▁) ▁; ▁} ▁Iterator ▁< ▁Map ▁. ▁Entry ▁< ▁Integer ▁, ▁Integer ▁> ▁> ▁itr ▁= ▁mp ▁. ▁entrySet ▁( ▁) ▁. ▁iterator ▁( ▁) ▁; ▁while ▁( ▁itr ▁. ▁hasNext ▁( ▁) ▁) ▁{ ▁Map ▁. ▁Entry ▁< ▁Integer ▁, ▁Integer ▁> ▁entry ▁= ▁itr ▁. ▁next ▁( ▁) ▁; ▁int ▁x ▁= ▁( ▁int ▁) ▁entry ▁. ▁getKey ▁( ▁) ▁; ▁int ▁y ▁= ▁( ▁int ▁) ▁entry ▁. ▁getValue ▁( ▁) ▁; ▁if ▁( ▁x ▁== ▁1 ▁) ▁{ ▁res ▁+= ▁N ▁- ▁1 ▁; ▁continue ▁; ▁} ▁res ▁+= ▁( ▁y ▁* ▁( ▁y ▁- ▁1 ▁) ▁) ▁/ ▁2 ▁; ▁for ▁( ▁int ▁j ▁= ▁2 ▁; ▁j ▁<= ▁Math ▁. ▁sqrt ▁( ▁x ▁) ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁x ▁% ▁j ▁== ▁0 ▁) ▁{ ▁res ▁+= ▁mp ▁. ▁get ▁( ▁j ▁) ▁; ▁if ▁( ▁j ▁!= ▁x ▁/ ▁j ▁) ▁res ▁+= ▁mp ▁. ▁get ▁( ▁( ▁int ▁) ▁x ▁/ ▁j ▁) ▁; ▁} ▁} ▁} ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁1 ▁, ▁2 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁Count Pairs ▁( ▁arr ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁find Min Sum ▁( ▁int ▁mat ▁[ ▁] ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁int ▁res ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁i ▁!= ▁j ▁) ▁{ ▁res ▁|= ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁} ▁} ▁sum ▁+= ▁res ▁; ▁} ▁return ▁sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁mat ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁- ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁, ▁{ ▁9 ▁, ▁- ▁1 ▁, ▁7 ▁} ▁, ▁{ ▁4 ▁, ▁5 ▁, ▁- ▁1 ▁} ▁} ▁; ▁int ▁N ▁= ▁mat ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Min Sum ▁( ▁mat ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁max Ad jacent Difference ▁( ▁ArrayList ▁< ▁Integer ▁> ▁A ▁) ▁{ ▁int ▁diff ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁( ▁int ▁) ▁A ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁diff ▁= ▁Math ▁. ▁max ▁( ▁diff ▁, ▁A ▁. ▁get ▁( ▁i ▁) ▁- ▁A ▁. ▁get ▁( ▁i ▁- ▁1 ▁) ▁) ▁; ▁} ▁return ▁diff ▁; ▁} ▁static ▁int ▁Minimum Value ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁Min Value ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁ArrayList ▁< ▁Integer ▁> ▁new _ arr ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁i ▁== ▁j ▁) ▁continue ▁; ▁new _ arr ▁. ▁add ▁( ▁arr ▁[ ▁j ▁] ▁) ▁; ▁} ▁Min Value ▁= ▁Math ▁. ▁min ▁( ▁Min Value ▁, ▁max Ad jacent Difference ▁( ▁new _ arr ▁) ▁) ▁; ▁} ▁return ▁Min Value ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁7 ▁, ▁8 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁Minimum Value ▁( ▁arr ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁mod ▁= ▁100 000000 7 ▁; ▁static ▁int ▁power ▁( ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁int ▁res ▁= ▁1 ▁; ▁x ▁= ▁x ▁% ▁mod ▁; ▁while ▁( ▁y ▁> ▁0 ▁) ▁{ ▁if ▁( ▁( ▁y ▁& ▁1 ▁) ▁!= ▁0 ▁) ▁res ▁= ▁( ▁res ▁* ▁x ▁) ▁% ▁mod ▁; ▁y ▁= ▁y ▁>> ▁1 ▁; ▁x ▁= ▁( ▁x ▁* ▁x ▁) ▁% ▁mod ▁; ▁} ▁return ▁res ▁; ▁} ▁static ▁int ▁ant is ym metric Relation ▁( ▁int ▁N ▁) ▁{ ▁return ▁( ▁power ▁( ▁2 ▁, ▁N ▁) ▁* ▁power ▁( ▁3 ▁, ▁( ▁N ▁* ▁N ▁- ▁N ▁) ▁/ ▁2 ▁) ▁) ▁% ▁mod ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁ant is ym metric Relation ▁( ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁count Pairs ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁even ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁% ▁2 ▁== ▁0 ▁) ▁even ▁++ ▁; ▁} ▁if ▁( ▁N ▁- ▁even ▁>= ▁1 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁even ▁) ▁; ▁return ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁0 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁4 ▁, ▁7 ▁, ▁2 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁count Pairs ▁( ▁arr ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁check Perm utation ▁( ▁int ▁ans ▁[ ▁] ▁, ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁Max ▁= ▁Integer ▁. ▁MIN _ VALUE ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁Max ▁= ▁Math ▁. ▁max ▁( ▁Max ▁, ▁ans ▁[ ▁i ▁] ▁) ▁; ▁if ▁( ▁Max ▁!= ▁a ▁[ ▁i ▁] ▁) ▁return ▁false ▁; ▁} ▁return ▁true ▁; ▁} ▁static ▁void ▁find Perm utation ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁ans ▁[ ▁] ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁um ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁! ▁um ▁. ▁containsKey ▁( ▁a ▁[ ▁i ▁] ▁) ▁) ▁{ ▁ans ▁[ ▁i ▁] ▁= ▁a ▁[ ▁i ▁] ▁; ▁um ▁. ▁put ▁( ▁a ▁[ ▁i ▁] ▁, ▁i ▁) ▁; ▁} ▁} ▁ArrayList ▁< ▁Integer ▁> ▁v ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁int ▁j ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁! ▁um ▁. ▁containsKey ▁( ▁i ▁) ▁) ▁{ ▁v ▁. ▁add ▁( ▁i ▁) ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁ans ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁ans ▁[ ▁i ▁] ▁= ▁v ▁. ▁get ▁( ▁j ▁) ▁; ▁j ▁++ ▁; ▁} ▁} ▁if ▁( ▁check Perm utation ▁( ▁ans ▁, ▁a ▁, ▁n ▁) ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁ans ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁- ▁1" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁5 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁find Perm utation ▁( ▁arr ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁Valid Pairs ▁( ▁int ▁X ▁, ▁int ▁K ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁A ▁= ▁- ▁1000 ▁; ▁A ▁<= ▁1000 ▁; ▁A ▁++ ▁) ▁{ ▁for ▁( ▁int ▁B ▁= ▁- ▁1000 ▁; ▁B ▁<= ▁1000 ▁; ▁B ▁++ ▁) ▁{ ▁if ▁( ▁Math ▁. ▁pow ▁( ▁A ▁, ▁K ▁) ▁- ▁Math ▁. ▁pow ▁( ▁B ▁, ▁K ▁) ▁== ▁X ▁) ▁{ ▁count ▁++ ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁A ▁+ ▁" ▁" ▁+ ▁B ▁) ▁; ▁} ▁} ▁} ▁if ▁( ▁count ▁== ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁- ▁1" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁X ▁= ▁33 ▁; ▁int ▁K ▁= ▁5 ▁; ▁Valid Pairs ▁( ▁X ▁, ▁K ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁find X OR ▁( ▁int ▁mat ▁[ ▁] ▁[ ▁] ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁XOR ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁XOR ▁^= ▁mat ▁[ ▁i ▁] ▁[ ▁i ▁] ▁[ ▁i ▁] ▁; ▁XOR ▁^= ▁mat ▁[ ▁i ▁] ▁[ ▁i ▁] ▁[ ▁N ▁- ▁i ▁- ▁1 ▁] ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁XOR ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁mat ▁[ ▁] ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁{ ▁1 ▁, ▁2 ▁} ▁, ▁{ ▁3 ▁, ▁4 ▁} ▁} ▁, ▁{ ▁{ ▁5 ▁, ▁6 ▁} ▁, ▁{ ▁7 ▁, ▁8 ▁} ▁} ▁} ▁; ▁int ▁N ▁= ▁mat ▁. ▁length ▁; ▁find X OR ▁( ▁mat ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁check W inner ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁diff ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁diff ▁-= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁if ▁( ▁diff ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁A ▁" ▁) ▁; ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁B ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁check W inner ▁( ▁arr ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁check Even Power ▁( ▁long ▁N ▁) ▁{ ▁if ▁( ▁( ▁N ▁& ▁( ▁N ▁- ▁1 ▁) ▁) ▁!= ▁0 ▁) ▁return ▁false ▁; ▁N ▁= ▁N ▁& ▁0 x 5555 5555 ▁; ▁return ▁( ▁N ▁> ▁0 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁long ▁N ▁= ▁4 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁check Even Power ▁( ▁N ▁) ▁? ▁1 ▁: ▁0 ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁distinct ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁Set ▁< ▁Integer ▁> ▁set ▁= ▁new ▁HashSet ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁set ▁. ▁add ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁return ▁set ▁. ▁size ▁( ▁) ▁; ▁} ▁static ▁int ▁max Sub Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁, ▁int ▁total Distinct ▁) ▁{ ▁if ▁( ▁k ▁> ▁n ▁) ▁return ▁0 ▁; ▁int ▁max ▁= ▁0 ▁, ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁k ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁= ▁0 ▁; ▁Set ▁< ▁Integer ▁> ▁set ▁= ▁new ▁HashSet ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁< ▁i ▁+ ▁k ▁; ▁j ▁++ ▁) ▁{ ▁sum ▁+= ▁arr ▁[ ▁j ▁] ▁; ▁set ▁. ▁add ▁( ▁arr ▁[ ▁j ▁] ▁) ▁; ▁} ▁if ▁( ▁set ▁. ▁size ▁( ▁) ▁== ▁total Distinct ▁) ▁max ▁= ▁Math ▁. ▁max ▁( ▁sum ▁, ▁max ▁) ▁; ▁} ▁return ▁max ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁7 ▁, ▁7 ▁, ▁2 ▁, ▁4 ▁, ▁2 ▁, ▁7 ▁, ▁4 ▁, ▁6 ▁, ▁6 ▁, ▁6 ▁} ▁; ▁int ▁K ▁= ▁6 ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁int ▁total Distinct ▁= ▁distinct ▁( ▁arr ▁, ▁N ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁max Sub Sum ▁( ▁arr ▁, ▁N ▁, ▁K ▁, ▁total Distinct ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁partition Array ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁min ▁[ ▁] ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁int ▁mini ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁mini ▁= ▁Math ▁. ▁min ▁( ▁mini ▁, ▁a ▁[ ▁i ▁] ▁) ▁; ▁min ▁[ ▁i ▁] ▁= ▁mini ▁; ▁} ▁int ▁max i ▁= ▁Integer ▁. ▁MIN _ VALUE ▁; ▁int ▁ind ▁= ▁- ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁max i ▁= ▁Math ▁. ▁max ▁( ▁max i ▁, ▁a ▁[ ▁i ▁] ▁) ▁; ▁if ▁( ▁max i ▁< ▁min ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁{ ▁ind ▁= ▁i ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁ind ▁!= ▁- ▁1 ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁ind ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁a ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁ind ▁+ ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁a ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Imp ossible ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁3 ▁, ▁2 ▁, ▁7 ▁, ▁9 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁partition Array ▁( ▁arr ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁gcd ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁while ▁( ▁b ▁> ▁0 ▁) ▁{ ▁int ▁rem ▁= ▁a ▁% ▁b ▁; ▁a ▁= ▁b ▁; ▁b ▁= ▁rem ▁; ▁} ▁return ▁a ▁; ▁} ▁static ▁int ▁count NumberOf W ays ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁1 ▁) ▁return ▁- ▁1 ▁; ▁int ▁g ▁= ▁0 ▁; ▁int ▁power ▁= ▁0 ▁; ▁while ▁( ▁n ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁power ▁++ ▁; ▁n ▁/= ▁2 ▁; ▁} ▁g ▁= ▁gcd ▁( ▁g ▁, ▁power ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁3 ▁; ▁i ▁<= ▁( ▁int ▁) ▁Math ▁. ▁sqrt ▁( ▁n ▁) ▁; ▁i ▁+= ▁2 ▁) ▁{ ▁power ▁= ▁0 ▁; ▁while ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁{ ▁power ▁++ ▁; ▁n ▁/= ▁i ▁; ▁} ▁g ▁= ▁gcd ▁( ▁g ▁, ▁power ▁) ▁; ▁} ▁if ▁( ▁n ▁> ▁2 ▁) ▁g ▁= ▁gcd ▁( ▁g ▁, ▁1 ▁) ▁; ▁int ▁ways ▁= ▁1 ▁; ▁power ▁= ▁0 ▁; ▁while ▁( ▁g ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁g ▁/= ▁2 ▁; ▁power ▁++ ▁; ▁} ▁ways ▁*= ▁( ▁power ▁+ ▁1 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁3 ▁; ▁i ▁<= ▁( ▁int ▁) ▁Math ▁. ▁sqrt ▁( ▁g ▁) ▁; ▁i ▁+= ▁2 ▁) ▁{ ▁power ▁= ▁0 ▁; ▁while ▁( ▁g ▁% ▁i ▁== ▁0 ▁) ▁{ ▁power ▁++ ▁; ▁g ▁/= ▁i ▁; ▁} ▁ways ▁*= ▁( ▁power ▁+ ▁1 ▁) ▁; ▁} ▁if ▁( ▁g ▁> ▁2 ▁) ▁ways ▁*= ▁2 ▁; ▁return ▁ways ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁64 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁count NumberOf W ays ▁( ▁N ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁G F G ▁{ ▁static ▁int ▁count ▁( ▁int ▁N ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁7 ▁* ▁Math ▁. ▁pow ▁( ▁8 ▁, ▁i ▁- ▁1 ▁) ▁; ▁} ▁return ▁sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁4 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count ▁( ▁N ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁maxValue ▁( ▁int ▁n ▁) ▁{ ▁return ▁n ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁1 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁maxValue ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁using Binary Search ▁( ▁int ▁start ▁, ▁int ▁end ▁, ▁int ▁N ▁, ▁int ▁S ▁) ▁{ ▁if ▁( ▁start ▁>= ▁end ▁) ▁return ▁start ▁; ▁int ▁mid ▁= ▁start ▁+ ▁( ▁end ▁- ▁start ▁) ▁/ ▁2 ▁; ▁int ▁total Sum ▁= ▁( ▁N ▁* ▁( ▁N ▁+ ▁1 ▁) ▁) ▁/ ▁2 ▁; ▁int ▁mid Sum ▁= ▁( ▁mid ▁* ▁( ▁mid ▁+ ▁1 ▁) ▁) ▁/ ▁2 ▁; ▁if ▁( ▁( ▁total Sum ▁- ▁mid Sum ▁) ▁<= ▁S ▁) ▁{ ▁return ▁using Binary Search ▁( ▁start ▁, ▁mid ▁, ▁N ▁, ▁S ▁) ▁; ▁} ▁return ▁using Binary Search ▁( ▁mid ▁+ ▁1 ▁, ▁end ▁, ▁N ▁, ▁S ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁, ▁S ▁; ▁N ▁= ▁5 ▁; ▁S ▁= ▁11 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁N ▁- ▁using Binary Search ▁( ▁1 ▁, ▁N ▁, ▁N ▁, ▁S ▁) ▁+ ▁1 ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁equal _ xor _ sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁Sum ▁= ▁0 ▁; ▁int ▁X or ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁Sum ▁= ▁Sum ▁+ ▁arr ▁[ ▁i ▁] ▁; ▁X or ▁= ▁X or ▁^ ▁arr ▁[ ▁i ▁] ▁; ▁} ▁if ▁( ▁Sum ▁== ▁X or ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁YES ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁NO ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁6 ▁, ▁3 ▁, ▁7 ▁, ▁10 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁equal _ xor _ sum ▁( ▁arr ▁, ▁n ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁set _ bits ▁( ▁int ▁n ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁while ▁( ▁n ▁> ▁0 ▁) ▁{ ▁count ▁+= ▁n ▁% ▁2 ▁; ▁n ▁/= ▁2 ▁; ▁} ▁return ▁count ▁; ▁} ▁static ▁int ▁min Steps ▁( ▁int ▁n ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁while ▁( ▁n ▁!= ▁1 ▁) ▁{ ▁if ▁( ▁n ▁% ▁2 ▁== ▁0 ▁) ▁n ▁/= ▁2 ▁; ▁else ▁if ▁( ▁n ▁== ▁3 ▁|| ▁set _ bits ▁( ▁n ▁- ▁1 ▁) ▁< ▁set _ bits ▁( ▁n ▁+ ▁1 ▁) ▁) ▁n ▁-- ▁; ▁else ▁n ▁++ ▁; ▁ans ▁++ ▁; ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁15 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁min Steps ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁l cm ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁return ▁( ▁a ▁/ ▁__ g cd ▁( ▁a ▁, ▁b ▁) ▁* ▁b ▁) ▁; ▁} ▁static ▁int ▁__ g cd ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁return ▁b ▁== ▁0 ▁? ▁a ▁: ▁__ g cd ▁( ▁b ▁, ▁a ▁% ▁b ▁) ▁; ▁} ▁static ▁void ▁find Num s ▁( ▁int ▁x ▁) ▁{ ▁int ▁ans ▁= ▁- ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁Math ▁. ▁sqrt ▁( ▁x ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁x ▁% ▁i ▁== ▁0 ▁&& ▁l cm ▁( ▁i ▁, ▁x ▁/ ▁i ▁) ▁== ▁x ▁) ▁{ ▁ans ▁= ▁i ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁ans ▁+ ▁" ▁" ▁+ ▁( ▁x ▁/ ▁ans ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁x ▁= ▁12 ▁; ▁find Num s ▁( ▁x ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁min OR ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁1 ▁) ▁return ▁0 ▁; ▁int ▁[ ▁] ▁pre ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁int ▁[ ▁] ▁suf ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁pre ▁[ ▁0 ▁] ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁suf ▁[ ▁n ▁- ▁1 ▁] ▁= ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁pre ▁[ ▁i ▁] ▁= ▁( ▁pre ▁[ ▁i ▁- ▁1 ▁] ▁arr ▁[ ▁i ▁] ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁2 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁suf ▁[ ▁i ▁] ▁= ▁( ▁suf ▁[ ▁i ▁+ ▁1 ▁] ▁arr ▁[ ▁i ▁] ▁) ▁; ▁int ▁ans ▁= ▁Math ▁. ▁min ▁( ▁pre ▁[ ▁n ▁- ▁2 ▁] ▁, ▁suf ▁[ ▁1 ▁] ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁ans ▁= ▁Math ▁. ▁min ▁( ▁ans ▁, ▁( ▁pre ▁[ ▁i ▁- ▁1 ▁] ▁suf ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁) ▁; ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁min OR ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁find Cnt ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁ret ▁= ▁0 ▁; ▁int ▁i ▁= ▁0 ▁; ▁while ▁( ▁i ▁< ▁n ▁) ▁{ ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁while ▁( ▁j ▁< ▁n ▁&& ▁arr ▁[ ▁j ▁] ▁>= ▁arr ▁[ ▁j ▁- ▁1 ▁] ▁) ▁j ▁++ ▁; ▁int ▁x ▁= ▁Math ▁. ▁max ▁( ▁0 ▁, ▁j ▁- ▁i ▁- ▁k ▁+ ▁1 ▁) ▁; ▁ret ▁+= ▁( ▁x ▁* ▁( ▁x ▁+ ▁1 ▁) ▁) ▁/ ▁2 ▁; ▁i ▁= ▁j ▁; ▁} ▁return ▁ret ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁4 ▁, ▁3 ▁, ▁2 ▁, ▁1 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁int ▁k ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Cnt ▁( ▁arr ▁, ▁n ▁, ▁k ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁two _ sets ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁a ▁) ▁; ▁return ▁a ▁[ ▁n ▁/ ▁2 ▁] ▁- ▁a ▁[ ▁( ▁n ▁/ ▁2 ▁) ▁- ▁1 ▁] ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁4 ▁, ▁4 ▁, ▁6 ▁, ▁7 ▁, ▁9 ▁} ▁; ▁int ▁n ▁= ▁a ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁two _ sets ▁( ▁a ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁k th Num ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁a ▁= ▁( ▁n ▁+ ▁1 ▁) ▁/ ▁2 ▁; ▁if ▁( ▁k ▁> ▁a ▁) ▁return ▁( ▁2 ▁* ▁( ▁k ▁- ▁a ▁) ▁) ▁; ▁return ▁( ▁2 ▁* ▁k ▁- ▁1 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁7 ▁, ▁k ▁= ▁7 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁k th Num ▁( ▁n ▁, ▁k ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁count ▁( ▁int ▁n ▁) ▁{ ▁return ▁n ▁* ▁( ▁3 ▁* ▁n ▁- ▁1 ▁) ▁/ ▁2 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁find Missing ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁, ▁int ▁avg ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁int ▁num ▁= ▁( ▁avg ▁* ▁( ▁n ▁+ ▁k ▁) ▁) ▁- ▁sum ▁; ▁int ▁den ▁= ▁k ▁; ▁if ▁( ▁num ▁% ▁den ▁!= ▁0 ▁) ▁return ▁- ▁1 ▁; ▁return ▁( ▁int ▁) ▁( ▁num ▁/ ▁den ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁k ▁= ▁3 ▁, ▁avg ▁= ▁4 ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁7 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Missing ▁( ▁arr ▁, ▁n ▁, ▁k ▁, ▁avg ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁sum ▁= ▁sum ▁* ▁( ▁int ▁) ▁Math ▁. ▁pow ▁( ▁2 ▁, ▁n ▁- ▁1 ▁) ▁; ▁return ▁sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁1 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁sum ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁prev Power of 2 ▁( ▁int ▁n ▁) ▁{ ▁int ▁p ▁= ▁( ▁int ▁) ▁( ▁Math ▁. ▁log ▁( ▁n ▁) ▁/ ▁Math ▁. ▁log ▁( ▁2 ▁) ▁) ▁; ▁return ▁( ▁int ▁) ▁Math ▁. ▁pow ▁( ▁2 ▁, ▁p ▁) ▁; ▁} ▁static ▁int ▁next Power Of 2 ▁( ▁int ▁n ▁) ▁{ ▁int ▁p ▁= ▁1 ▁; ▁if ▁( ▁( ▁n ▁== ▁0 ▁) ▁&& ▁! ▁( ▁( ▁n ▁& ▁( ▁n ▁- ▁1 ▁) ▁) ▁== ▁0 ▁) ▁) ▁return ▁n ▁; ▁while ▁( ▁p ▁< ▁n ▁) ▁p ▁<<= ▁1 ▁; ▁return ▁p ▁; ▁} ▁static ▁int ▁min Diff ▁( ▁int ▁n ▁) ▁{ ▁int ▁low ▁= ▁prev Power of 2 ▁( ▁n ▁) ▁; ▁int ▁high ▁= ▁next Power Of 2 ▁( ▁n ▁) ▁; ▁return ▁Math ▁. ▁min ▁( ▁n ▁- ▁low ▁, ▁high ▁- ▁n ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁6 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁min Diff ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁MAX ▁= ▁10 ▁; ▁static ▁boolean ▁is Factor ion ▁( ▁int ▁n ▁) ▁{ ▁int ▁fact ▁[ ▁] ▁= ▁new ▁int ▁[ ▁MAX ▁] ▁; ▁fact ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁MAX ▁; ▁i ▁++ ▁) ▁fact ▁[ ▁i ▁] ▁= ▁i ▁* ▁fact ▁[ ▁i ▁- ▁1 ▁] ▁; ▁int ▁org ▁= ▁n ▁; ▁int ▁sum ▁= ▁0 ▁; ▁while ▁( ▁n ▁> ▁0 ▁) ▁{ ▁int ▁d ▁= ▁n ▁% ▁10 ▁; ▁sum ▁+= ▁fact ▁[ ▁d ▁] ▁; ▁n ▁/= ▁10 ▁; ▁} ▁if ▁( ▁sum ▁== ▁org ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁405 85 ▁; ▁if ▁( ▁is Factor ion ▁( ▁n ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁final ▁int ▁MOD ▁= ▁100 000000 7 ▁; ▁static ▁int ▁mod Fact ▁( ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁int ▁result ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁m ▁; ▁i ▁++ ▁) ▁result ▁= ▁( ▁result ▁* ▁i ▁) ▁% ▁MOD ▁; ▁return ▁result ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁3 ▁, ▁m ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁mod Fact ▁( ▁n ▁, ▁m ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁gcd ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁if ▁( ▁b ▁== ▁0 ▁) ▁return ▁a ▁; ▁return ▁gcd ▁( ▁b ▁, ▁a ▁% ▁b ▁) ▁; ▁} ▁static ▁int ▁max Common Fact ors ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁int ▁__ g cd ▁= ▁gcd ▁( ▁a ▁, ▁b ▁) ▁; ▁int ▁ans ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁* ▁i ▁<= ▁__ g cd ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁__ g cd ▁% ▁i ▁== ▁0 ▁) ▁{ ▁ans ▁++ ▁; ▁while ▁( ▁__ g cd ▁% ▁i ▁== ▁0 ▁) ▁__ g cd ▁/= ▁i ▁; ▁} ▁} ▁if ▁( ▁__ g cd ▁!= ▁1 ▁) ▁ans ▁++ ▁; ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁= ▁12 ▁, ▁b ▁= ▁18 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁max Common Fact ors ▁( ▁a ▁, ▁b ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁count Unset Bits ▁( ▁int ▁n ▁) ▁{ ▁int ▁cnt ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁temp ▁= ▁i ▁; ▁while ▁( ▁temp ▁> ▁0 ▁) ▁{ ▁if ▁( ▁temp ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁cnt ▁= ▁cnt ▁+ ▁1 ▁; ▁} ▁temp ▁= ▁temp ▁/ ▁2 ▁; ▁} ▁} ▁return ▁cnt ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Unset Bits ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁boolean ▁is Div isible ▁( ▁long ▁n ▁) ▁{ ▁long ▁temp ▁= ▁n ▁; ▁int ▁sum ▁= ▁0 ▁; ▁while ▁( ▁n ▁!= ▁0 ▁) ▁{ ▁int ▁digit ▁= ▁( ▁int ▁) ▁n ▁% ▁10 ▁; ▁sum ▁+= ▁digit ▁; ▁n ▁/= ▁10 ▁; ▁} ▁n ▁= ▁temp ▁; ▁while ▁( ▁n ▁!= ▁0 ▁) ▁{ ▁int ▁digit ▁= ▁( ▁int ▁) ▁n ▁% ▁10 ▁; ▁if ▁( ▁sum ▁% ▁digit ▁!= ▁0 ▁) ▁return ▁false ▁; ▁n ▁/= ▁10 ▁; ▁} ▁return ▁true ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁long ▁n ▁= ▁123 ▁; ▁if ▁( ▁is Div isible ▁( ▁n ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁C OST ▁= ▁3 ▁; ▁static ▁int ▁max Items ▁( ▁int ▁x ▁, ▁int ▁y ▁, ▁int ▁z ▁) ▁{ ▁int ▁type 1 ▁= ▁x ▁/ ▁C OST ▁; ▁x ▁% = ▁C OST ▁; ▁int ▁type 2 ▁= ▁y ▁/ ▁C OST ▁; ▁y ▁% = ▁C OST ▁; ▁int ▁type 3 ▁= ▁z ▁/ ▁C OST ▁; ▁z ▁% = ▁C OST ▁; ▁int ▁type 4 ▁= ▁Math ▁. ▁min ▁( ▁x ▁, ▁Math ▁. ▁min ▁( ▁y ▁, ▁z ▁) ▁) ▁; ▁int ▁max Items ▁= ▁type 1 ▁+ ▁type 2 ▁+ ▁type 3 ▁+ ▁type 4 ▁; ▁return ▁max Items ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁x ▁= ▁4 ▁, ▁y ▁= ▁5 ▁, ▁z ▁= ▁6 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁max Items ▁( ▁x ▁, ▁y ▁, ▁z ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁class ▁pair ▁{ ▁int ▁first ▁, ▁second ▁; ▁public ▁pair ▁( ▁int ▁first ▁, ▁int ▁second ▁) ▁{ ▁this ▁. ▁first ▁= ▁first ▁; ▁this ▁. ▁second ▁= ▁second ▁; ▁} ▁} ▁static ▁pair ▁count Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁Number Of Odd s ▁= ▁0 ▁, ▁Number Of Ev ens ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁arr ▁[ ▁i ▁] ▁% ▁2 ▁== ▁1 ▁) ▁Number Of Odd s ▁++ ▁; ▁Number Of Ev ens ▁= ▁n ▁- ▁Number Of Odd s ▁; ▁int ▁Number Of Odd Sub sequences ▁= ▁( ▁1 ▁<< ▁Number Of Ev ens ▁) ▁* ▁( ▁1 ▁<< ▁( ▁Number Of Odd s ▁- ▁1 ▁) ▁) ▁; ▁int ▁Number Of Even Sub sequences ▁= ▁( ▁1 ▁<< ▁n ▁) ▁- ▁1 ▁- ▁Number Of Odd Sub sequences ▁; ▁return ▁new ▁pair ▁( ▁Number Of Even Sub sequences ▁, ▁Number Of Odd Sub sequences ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁2 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁pair ▁ans ▁= ▁count Sum ▁( ▁arr ▁, ▁n ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Even Sum ▁= ▁" ▁+ ▁ans ▁. ▁first ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁O dd Sum ▁= ▁" ▁+ ▁ans ▁. ▁second ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁prime ▁( ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁* ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁return ▁false ▁; ▁return ▁true ▁; ▁} ▁static ▁void ▁prime _ range ▁( ▁int ▁start ▁, ▁int ▁end ▁, ▁int ▁[ ▁] ▁a ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁start ▁; ▁i ▁< ▁end ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁( ▁a ▁[ ▁i ▁] ▁) ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁a ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁static ▁void ▁Print ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Prime ▁numbers ▁in ▁the ▁first ▁half ▁are ▁" ▁) ▁; ▁prime _ range ▁( ▁0 ▁, ▁n ▁/ ▁2 ▁, ▁arr ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Prime ▁numbers ▁in ▁the ▁second ▁half ▁are ▁" ▁) ▁; ▁prime _ range ▁( ▁n ▁/ ▁2 ▁, ▁n ▁, ▁arr ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁5 ▁, ▁10 ▁, ▁15 ▁, ▁17 ▁, ▁21 ▁, ▁23 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁Print ▁( ▁arr ▁, ▁n ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁Find Element ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁sum ▁= ▁sum ▁+ ▁a ▁[ ▁i ▁] ▁; ▁if ▁( ▁sum ▁% ▁n ▁== ▁0 ▁) ▁{ ▁int ▁m ▁= ▁sum ▁/ ▁n ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁a ▁[ ▁i ▁] ▁== ▁m ▁) ▁return ▁m ▁; ▁} ▁return ▁- ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁a ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁Find Element ▁( ▁a ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁fact ▁( ▁int ▁n ▁) ▁{ ▁int ▁res ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁res ▁= ▁res ▁* ▁i ▁; ▁return ▁res ▁; ▁} ▁static ▁int ▁Count _ number ▁( ▁int ▁N ▁) ▁{ ▁return ▁( ▁N ▁* ▁fact ▁( ▁N ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁Count _ number ▁( ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁find Hours ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁int ▁k ▁) ▁{ ▁if ▁( ▁a ▁>= ▁b ▁) ▁return ▁- ▁1 ▁; ▁int ▁time ▁= ▁k ▁/ ▁( ▁b ▁- ▁a ▁) ▁; ▁time ▁= ▁time ▁+ ▁1 ▁; ▁return ▁time ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁= ▁4 ▁, ▁b ▁= ▁5 ▁, ▁k ▁= ▁1 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Hours ▁( ▁a ▁, ▁b ▁, ▁k ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁n cr ▁( ▁int ▁n ▁, ▁int ▁r ▁) ▁{ ▁int ▁ans ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁r ▁; ▁i ▁+= ▁1 ▁) ▁{ ▁ans ▁*= ▁( ▁n ▁- ▁r ▁+ ▁i ▁) ▁; ▁ans ▁/= ▁i ▁; ▁} ▁return ▁ans ▁; ▁} ▁static ▁int ▁No Of Distribution s ▁( ▁int ▁N ▁, ▁int ▁R ▁) ▁{ ▁return ▁n cr ▁( ▁N ▁- ▁1 ▁, ▁R ▁- ▁1 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁4 ▁; ▁int ▁R ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁No Of Distribution s ▁( ▁N ▁, ▁R ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁Collections ▁; ▁import ▁java ▁. ▁util ▁. ▁Vector ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁Min Remove ▁( ▁int ▁[ ▁] ▁a ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁[ ▁] ▁cnt ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁== ▁0 ▁) ▁cnt ▁[ ▁0 ▁] ▁++ ▁; ▁else ▁if ▁( ▁cnt ▁[ ▁a ▁[ ▁i ▁] ▁- ▁1 ▁] ▁> ▁0 ▁) ▁{ ▁cnt ▁[ ▁a ▁[ ▁i ▁] ▁- ▁1 ▁] ▁-- ▁; ▁cnt ▁[ ▁a ▁[ ▁i ▁] ▁] ▁++ ▁; ▁} ▁} ▁return ▁n ▁- ▁( ▁k ▁* ▁cnt ▁[ ▁k ▁- ▁1 ▁] ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁k ▁= ▁5 ▁; ▁int ▁n ▁= ▁a ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁Min Remove ▁( ▁a ▁, ▁n ▁, ▁k ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁L ower H ess en berg Matrix ▁( ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁<= ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁j ▁> ▁i ▁+ ▁1 ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁'0' ▁+ ▁" ▁" ▁) ▁; ▁else ▁{ ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁% ▁. 0 f ▁" ▁, ▁Math ▁. ▁random ▁( ▁) ▁* ▁10 ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁" ▁) ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁" NEW _ LINE "); ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁4 ▁; ▁L ower H ess en berg Matrix ▁( ▁n ▁) ▁; ▁} ▁}
▁class ▁Rectangle ▁{ ▁static ▁int ▁count ▁( ▁int ▁N ▁) ▁{ ▁int ▁a ▁= ▁0 ▁; ▁a ▁= ▁( ▁N ▁* ▁( ▁N ▁+ ▁1 ▁) ▁) ▁/ ▁2 ▁; ▁return ▁a ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁4 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁count ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁boolean ▁isM ers en ne ▁( ▁int ▁n ▁) ▁{ ▁while ▁( ▁n ▁!= ▁0 ▁) ▁{ ▁int ▁r ▁= ▁n ▁% ▁2 ▁; ▁if ▁( ▁r ▁== ▁0 ▁) ▁return ▁false ▁; ▁n ▁/= ▁2 ▁; ▁} ▁return ▁true ▁; ▁} ▁static ▁int ▁sum Of M ers en ne ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁0 ▁&& ▁isM ers en ne ▁( ▁arr ▁[ ▁i ▁] ▁) ▁) ▁{ ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁} ▁return ▁sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁17 ▁, ▁6 ▁, ▁7 ▁, ▁63 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁sum Of M ers en ne ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁numberOf Days ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁int ▁n ▁) ▁{ ▁int ▁Days ▁= ▁b ▁* ▁( ▁n ▁+ ▁a ▁) ▁/ ▁( ▁a ▁+ ▁b ▁) ▁; ▁return ▁Days ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁= ▁10 ▁, ▁b ▁= ▁20 ▁, ▁n ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁numberOf Days ▁( ▁a ▁, ▁b ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁long ▁square Series ▁( ▁long ▁n ▁) ▁{ ▁return ▁( ▁n ▁* ▁( ▁n ▁+ ▁1 ▁) ▁* ▁( ▁2 ▁* ▁n ▁+ ▁1 ▁) ▁) ▁/ ▁6 ▁; ▁} ▁static ▁long ▁max People ▁( ▁long ▁n ▁) ▁{ ▁long ▁low ▁= ▁0 ▁; ▁long ▁high ▁= ▁1000000 L ▁; ▁long ▁ans ▁= ▁0 L ▁; ▁while ▁( ▁low ▁<= ▁high ▁) ▁{ ▁long ▁mid ▁= ▁low ▁+ ▁( ▁( ▁high ▁- ▁low ▁) ▁/ ▁2 ▁) ▁; ▁long ▁value ▁= ▁square Series ▁( ▁mid ▁) ▁; ▁if ▁( ▁value ▁<= ▁n ▁) ▁{ ▁ans ▁= ▁mid ▁; ▁low ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁else ▁{ ▁high ▁= ▁mid ▁- ▁1 ▁; ▁} ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁long ▁p ▁= ▁14 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁max People ▁( ▁p ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁solve ▁( ▁long ▁a ▁, ▁long ▁b ▁) ▁{ ▁if ▁( ▁a ▁> ▁0 ▁&& ▁b ▁> ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Positive ▁" ▁) ▁; ▁} ▁else ▁if ▁( ▁a ▁<= ▁0 ▁&& ▁b ▁>= ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Zero ▁" ▁) ▁; ▁} ▁else ▁{ ▁long ▁n ▁= ▁Math ▁. ▁abs ▁( ▁a ▁- ▁b ▁) ▁+ ▁1 ▁; ▁if ▁( ▁n ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Positive ▁" ▁) ▁; ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Negative ▁" ▁) ▁; ▁} ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁= ▁- ▁10 ▁, ▁b ▁= ▁- ▁2 ▁; ▁solve ▁( ▁a ▁, ▁b ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁factorial ▁( ▁int ▁n ▁) ▁{ ▁int ▁f ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁f ▁*= ▁i ▁; ▁} ▁return ▁f ▁; ▁} ▁static ▁int ▁sum Factor ial ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁n ▁) ▁{ ▁int ▁s ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁s ▁+= ▁factorial ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁return ▁s ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁7 ▁, ▁3 ▁, ▁5 ▁, ▁4 ▁, ▁8 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁sum Factor ial ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁id str t ▁( ▁double ▁a 1 ▁, ▁double ▁b 1 ▁, ▁double ▁c 1 ▁, ▁double ▁a 2 ▁, ▁double ▁b 2 ▁, ▁double ▁c 2 ▁) ▁{ ▁if ▁( ▁( ▁a 1 ▁/ ▁a 2 ▁== ▁b 1 ▁/ ▁b 2 ▁) ▁&& ▁( ▁a 1 ▁/ ▁a 2 ▁== ▁c 1 ▁/ ▁c 2 ▁) ▁&& ▁( ▁b 1 ▁/ ▁b 2 ▁== ▁c 1 ▁/ ▁c 2 ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁The ▁given ▁straight ▁" ▁+ ▁" ▁lines ▁are ▁identical ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁The ▁given ▁straight ▁" ▁+ ▁" ▁lines ▁are ▁not ▁identical ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁double ▁a 1 ▁= ▁- ▁2 ▁, ▁b 1 ▁= ▁4 ▁, ▁c 1 ▁= ▁3 ▁, ▁a 2 ▁= ▁- ▁6 ▁, ▁b 2 ▁= ▁12 ▁, ▁c 2 ▁= ▁9 ▁; ▁id str t ▁( ▁a 1 ▁, ▁b 1 ▁, ▁c 1 ▁, ▁a 2 ▁, ▁b 2 ▁, ▁c 2 ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁smallest Multiple ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁1 ▁) ▁return ▁5 ▁; ▁return ▁( ▁int ▁) ▁( ▁Math ▁. ▁pow ▁( ▁10 ▁, ▁n ▁- ▁1 ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁4 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁smallest Multiple ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁HashMap ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁maxlen ▁= ▁100 ▁; ▁public ▁static ▁void ▁generate Sub Strings ▁( ▁String ▁s ▁, ▁HashMap ▁< ▁String ▁, ▁Integer ▁> ▁m pp ▁) ▁{ ▁int ▁l ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁l ▁; ▁i ▁++ ▁) ▁{ ▁String ▁temp ▁= ▁" ▁" ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁< ▁l ▁; ▁j ▁++ ▁) ▁{ ▁temp ▁+= ▁s ▁. ▁charAt ▁( ▁j ▁) ▁; ▁if ▁( ▁m pp ▁. ▁containsKey ▁( ▁temp ▁) ▁) ▁{ ▁int ▁x ▁= ▁m pp ▁. ▁get ▁( ▁temp ▁) ▁; ▁m pp ▁. ▁put ▁( ▁temp ▁, ▁++ ▁x ▁) ▁; ▁} ▁else ▁m pp ▁. ▁put ▁( ▁temp ▁, ▁1 ▁) ▁; ▁} ▁} ▁} ▁public ▁static ▁void ▁bin omial Co eff ▁( ▁int ▁[ ▁] ▁[ ▁] ▁C ▁) ▁{ ▁int ▁i ▁, ▁j ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁100 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁100 ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁j ▁== ▁0 ▁j ▁== ▁i ▁) ▁C ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁1 ▁; ▁else ▁C ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁C ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁- ▁1 ▁] ▁+ ▁C ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁; ▁} ▁} ▁} ▁public ▁static ▁int ▁answer Query ▁( ▁HashMap ▁< ▁String ▁, ▁Integer ▁> ▁m pp ▁, ▁int ▁[ ▁] ▁[ ▁] ▁C ▁, ▁int ▁k ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁HashMap ▁. ▁Entry ▁< ▁String ▁, ▁Integer ▁> ▁entry ▁: ▁m pp ▁. ▁entrySet ▁( ▁) ▁) ▁{ ▁if ▁( ▁entry ▁. ▁getValue ▁( ▁) ▁>= ▁k ▁) ▁ans ▁+= ▁C ▁[ ▁entry ▁. ▁getValue ▁( ▁) ▁] ▁[ ▁k ▁] ▁; ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁s ▁= ▁" ▁a aba ab ▁" ▁; ▁HashMap ▁< ▁String ▁, ▁Integer ▁> ▁m pp ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁generate Sub Strings ▁( ▁s ▁, ▁m pp ▁) ▁; ▁int ▁[ ▁] ▁[ ▁] ▁C ▁= ▁new ▁int ▁[ ▁maxlen ▁] ▁[ ▁maxlen ▁] ▁; ▁bin omial Co eff ▁( ▁C ▁) ▁; ▁int ▁[ ▁] ▁queries ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁q ▁= ▁queries ▁. ▁length ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁q ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁answer Query ▁( ▁m pp ▁, ▁C ▁, ▁queries ▁[ ▁i ▁] ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁long ▁compute X OR ▁( ▁int ▁n ▁) ▁{ ▁int ▁x ▁= ▁n ▁& ▁3 ▁; ▁switch ▁( ▁x ▁) ▁{ ▁case ▁0 ▁: ▁return ▁n ▁; ▁case ▁1 ▁: ▁return ▁1 ▁; ▁case ▁2 ▁: ▁return ▁n ▁+ ▁1 ▁; ▁case ▁3 ▁: ▁return ▁0 ▁; ▁} ▁return ▁0 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁l ▁= ▁1 ▁, ▁r ▁= ▁4 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁compute X OR ▁( ▁r ▁) ▁^ ▁compute X OR ▁( ▁l ▁- ▁1 ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁lang ▁. ▁Math ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁fib ▁( ▁int ▁n ▁) ▁{ ▁double ▁phi ▁= ▁( ▁1 ▁+ ▁Math ▁. ▁sqrt ▁( ▁5 ▁) ▁) ▁/ ▁2 ▁; ▁return ▁( ▁int ▁) ▁Math ▁. ▁round ▁( ▁Math ▁. ▁pow ▁( ▁phi ▁, ▁n ▁) ▁/ ▁Math ▁. ▁sqrt ▁( ▁5 ▁) ▁) ▁; ▁} ▁static ▁int ▁calculate Sum ▁( ▁int ▁l ▁, ▁int ▁r ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁l ▁; ▁i ▁<= ▁r ▁; ▁i ▁++ ▁) ▁sum ▁+= ▁fib ▁( ▁i ▁) ▁; ▁return ▁sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁l ▁= ▁4 ▁, ▁r ▁= ▁8 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁calculate Sum ▁( ▁l ▁, ▁r ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁count Numbers ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁% ▁2 ▁== ▁1 ▁) ▁return ▁0 ▁; ▁return ▁( ▁9 ▁* ▁( ▁int ▁) ▁Math ▁. ▁pow ▁( ▁10 ▁, ▁n ▁/ ▁2 ▁- ▁1 ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁count Numbers ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁double ▁get Probability ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁int ▁c ▁, ▁int ▁d ▁) ▁{ ▁double ▁p ▁= ▁( ▁double ▁) ▁a ▁/ ▁( ▁double ▁) ▁b ▁; ▁double ▁q ▁= ▁( ▁double ▁) ▁c ▁/ ▁( ▁double ▁) ▁d ▁; ▁double ▁ans ▁= ▁p ▁* ▁( ▁1 ▁/ ▁( ▁1 ▁- ▁( ▁1 ▁- ▁q ▁) ▁* ▁( ▁1 ▁- ▁p ▁) ▁) ▁) ▁; ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁= ▁1 ▁, ▁b ▁= ▁2 ▁, ▁c ▁= ▁10 ▁, ▁d ▁= ▁11 ▁; ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁% ▁.5 f ▁" ▁, ▁get Probability ▁( ▁a ▁, ▁b ▁, ▁c ▁, ▁d ▁) ▁) ▁; ▁} ▁}
▁class ▁G f G ▁{ ▁static ▁int ▁find Min Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁occ ▁= ▁n ▁- ▁1 ▁, ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁* ▁( ▁int ▁) ▁Math ▁. ▁pow ▁( ▁2 ▁, ▁occ ▁) ▁; ▁occ ▁-- ▁; ▁} ▁return ▁sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Min Sum ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁final ▁int ▁n ▁= ▁3 ▁; ▁static ▁int ▁matrix Sum ▁( ▁int ▁arr ▁[ ▁] ▁[ ▁] ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁int ▁top _ left ▁= ▁( ▁i ▁+ ▁1 ▁) ▁* ▁( ▁j ▁+ ▁1 ▁) ▁; ▁int ▁bottom _ right ▁= ▁( ▁n ▁- ▁i ▁) ▁* ▁( ▁n ▁- ▁j ▁) ▁; ▁sum ▁+= ▁( ▁top _ left ▁* ▁bottom _ right ▁* ▁arr ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁; ▁} ▁} ▁return ▁sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁1 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁1 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁1 ▁, ▁1 ▁} ▁} ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁matrix Sum ▁( ▁arr ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G f G ▁{ ▁static ▁int ▁N ▁= ▁10000 5 ▁; ▁static ▁boolean ▁is prime ▁[ ▁] ▁= ▁new ▁boolean ▁[ ▁N ▁] ▁; ▁static ▁boolean ▁can ▁[ ▁] ▁= ▁new ▁boolean ▁[ ▁N ▁] ▁; ▁static ▁ArrayList ▁< ▁Integer ▁> ▁S ieve Of E rat ost hen es ▁( ▁) ▁{ ▁for ▁( ▁int ▁a ▁= ▁0 ▁; ▁a ▁< ▁is prime ▁. ▁length ▁; ▁a ▁++ ▁) ▁{ ▁is prime ▁[ ▁a ▁] ▁= ▁true ▁; ▁} ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁* ▁p ▁< ▁N ▁; ▁p ▁++ ▁) ▁{ ▁if ▁( ▁is prime ▁[ ▁p ▁] ▁== ▁true ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁p ▁* ▁p ▁; ▁i ▁< ▁N ▁; ▁i ▁+= ▁p ▁) ▁is prime ▁[ ▁i ▁] ▁= ▁false ▁; ▁} ▁} ▁ArrayList ▁< ▁Integer ▁> ▁primes ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁if ▁( ▁is prime ▁[ ▁i ▁] ▁) ▁primes ▁. ▁add ▁( ▁i ▁) ▁; ▁return ▁primes ▁; ▁} ▁static ▁int ▁Prime _ Numbers ▁( ▁int ▁n ▁) ▁{ ▁ArrayList ▁< ▁Integer ▁> ▁primes ▁= ▁S ieve Of E rat ost hen es ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁( ▁int ▁) ▁( ▁primes ▁. ▁size ▁( ▁) ▁) ▁- ▁1 ▁; ▁i ▁++ ▁) ▁if ▁( ▁primes ▁. ▁get ▁( ▁i ▁) ▁+ ▁primes ▁. ▁get ▁( ▁i ▁+ ▁1 ▁) ▁+ ▁1 ▁< ▁N ▁) ▁can ▁[ ▁primes ▁. ▁get ▁( ▁i ▁) ▁+ ▁primes ▁. ▁get ▁( ▁i ▁+ ▁1 ▁) ▁+ ▁1 ▁] ▁= ▁true ▁; ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁can ▁[ ▁i ▁] ▁&& ▁is prime ▁[ ▁i ▁] ▁== ▁true ▁) ▁{ ▁ans ▁++ ▁; ▁} ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁50 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁Prime _ Numbers ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁text ▁. ▁DecimalFormat ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁mid pt el lipse ▁( ▁float ▁rx ▁, ▁float ▁ry ▁, ▁float ▁xc ▁, ▁float ▁y c ▁) ▁{ ▁float ▁dx ▁, ▁dy ▁, ▁d 1 ▁, ▁d 2 ▁, ▁x ▁, ▁y ▁; ▁x ▁= ▁0 ▁; ▁y ▁= ▁ry ▁; ▁d 1 ▁= ▁( ▁ry ▁* ▁ry ▁) ▁- ▁( ▁rx ▁* ▁rx ▁* ▁ry ▁) ▁+ ▁( ▁0.25 f ▁* ▁rx ▁* ▁rx ▁) ▁; ▁dx ▁= ▁2 ▁* ▁ry ▁* ▁ry ▁* ▁x ▁; ▁dy ▁= ▁2 ▁* ▁rx ▁* ▁rx ▁* ▁y ▁; ▁DecimalFormat ▁df ▁= ▁new ▁DecimalFormat ▁( ▁" ▁# ▁, ▁# ▁# ▁# ▁, ▁# ▁# 0. 00000 " ▁) ▁; ▁while ▁( ▁dx ▁< ▁dy ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁df ▁. ▁format ▁( ▁( ▁x ▁+ ▁xc ▁) ▁) ▁+ ▁" ▁, ▁" ▁+ ▁df ▁. ▁format ▁( ▁( ▁y ▁+ ▁y c ▁) ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁df ▁. ▁format ▁( ▁( ▁- ▁x ▁+ ▁xc ▁) ▁) ▁+ ▁" ▁, ▁" ▁+ ▁df ▁. ▁format ▁( ▁( ▁y ▁+ ▁y c ▁) ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁df ▁. ▁format ▁( ▁( ▁x ▁+ ▁xc ▁) ▁) ▁+ ▁" ▁, ▁" ▁+ ▁df ▁. ▁format ▁( ▁( ▁- ▁y ▁+ ▁y c ▁) ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁df ▁. ▁format ▁( ▁( ▁- ▁x ▁+ ▁xc ▁) ▁) ▁+ ▁" ▁, ▁" ▁+ ▁df ▁. ▁format ▁( ▁( ▁- ▁y ▁+ ▁y c ▁) ▁) ▁) ▁; ▁if ▁( ▁d 1 ▁< ▁0 ▁) ▁{ ▁x ▁++ ▁; ▁dx ▁= ▁dx ▁+ ▁( ▁2 ▁* ▁ry ▁* ▁ry ▁) ▁; ▁d 1 ▁= ▁d 1 ▁+ ▁dx ▁+ ▁( ▁ry ▁* ▁ry ▁) ▁; ▁} ▁else ▁{ ▁x ▁++ ▁; ▁y ▁-- ▁; ▁dx ▁= ▁dx ▁+ ▁( ▁2 ▁* ▁ry ▁* ▁ry ▁) ▁; ▁dy ▁= ▁dy ▁- ▁( ▁2 ▁* ▁rx ▁* ▁rx ▁) ▁; ▁d 1 ▁= ▁d 1 ▁+ ▁dx ▁- ▁dy ▁+ ▁( ▁ry ▁* ▁ry ▁) ▁; ▁} ▁} ▁d 2 ▁= ▁( ▁( ▁ry ▁* ▁ry ▁) ▁* ▁( ▁( ▁x ▁+ ▁0.5 f ▁) ▁* ▁( ▁x ▁+ ▁0.5 f ▁) ▁) ▁) ▁+ ▁( ▁( ▁rx ▁* ▁rx ▁) ▁* ▁( ▁( ▁y ▁- ▁1 ▁) ▁* ▁( ▁y ▁- ▁1 ▁) ▁) ▁) ▁- ▁( ▁rx ▁* ▁rx ▁* ▁ry ▁* ▁ry ▁) ▁; ▁while ▁( ▁y ▁>= ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁df ▁. ▁format ▁( ▁( ▁x ▁+ ▁xc ▁) ▁) ▁+ ▁" ▁, ▁" ▁+ ▁df ▁. ▁format ▁( ▁( ▁y ▁+ ▁y c ▁) ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁df ▁. ▁format ▁( ▁( ▁- ▁x ▁+ ▁xc ▁) ▁) ▁+ ▁" ▁, ▁" ▁+ ▁df ▁. ▁format ▁( ▁( ▁y ▁+ ▁y c ▁) ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁df ▁. ▁format ▁( ▁( ▁x ▁+ ▁xc ▁) ▁) ▁+ ▁" ▁, ▁" ▁+ ▁df ▁. ▁format ▁( ▁( ▁- ▁y ▁+ ▁y c ▁) ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁df ▁. ▁format ▁( ▁( ▁- ▁x ▁+ ▁xc ▁) ▁) ▁+ ▁" ▁, ▁" ▁+ ▁df ▁. ▁format ▁( ▁( ▁- ▁y ▁+ ▁y c ▁) ▁) ▁) ▁; ▁if ▁( ▁d 2 ▁> ▁0 ▁) ▁{ ▁y ▁-- ▁; ▁dy ▁= ▁dy ▁- ▁( ▁2 ▁* ▁rx ▁* ▁rx ▁) ▁; ▁d 2 ▁= ▁d 2 ▁+ ▁( ▁rx ▁* ▁rx ▁) ▁- ▁dy ▁; ▁} ▁else ▁{ ▁y ▁-- ▁; ▁x ▁++ ▁; ▁dx ▁= ▁dx ▁+ ▁( ▁2 ▁* ▁ry ▁* ▁ry ▁) ▁; ▁dy ▁= ▁dy ▁- ▁( ▁2 ▁* ▁rx ▁* ▁rx ▁) ▁; ▁d 2 ▁= ▁d 2 ▁+ ▁dx ▁- ▁dy ▁+ ▁( ▁rx ▁* ▁rx ▁) ▁; ▁} ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁mid pt el lipse ▁( ▁10 ▁, ▁15 ▁, ▁50 ▁, ▁50 ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁alter ▁( ▁long ▁x ▁, ▁long ▁y ▁) ▁{ ▁while ▁( ▁true ▁) ▁{ ▁if ▁( ▁x ▁== ▁0 ▁y ▁== ▁0 ▁) ▁break ▁; ▁if ▁( ▁x ▁>= ▁2 ▁* ▁y ▁) ▁x ▁= ▁x ▁% ▁( ▁2 ▁* ▁y ▁) ▁; ▁else ▁if ▁( ▁y ▁>= ▁2 ▁* ▁x ▁) ▁y ▁= ▁y ▁% ▁( ▁2 ▁* ▁x ▁) ▁; ▁else ▁break ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁X ▁= ▁" ▁+ ▁x ▁+ ▁" ▁, ▁" ▁+ ▁" ▁Y ▁= ▁" ▁+ ▁y ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁long ▁x ▁= ▁12 ▁, ▁y ▁= ▁5 ▁; ▁alter ▁( ▁x ▁, ▁y ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁factorial ▁( ▁int ▁n ▁) ▁{ ▁int ▁fact ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁fact ▁= ▁fact ▁* ▁i ▁; ▁return ▁fact ▁; ▁} ▁static ▁int ▁n cr ▁( ▁int ▁n ▁, ▁int ▁r ▁) ▁{ ▁return ▁factorial ▁( ▁n ▁) ▁/ ▁( ▁factorial ▁( ▁r ▁) ▁* ▁factorial ▁( ▁n ▁- ▁r ▁) ▁) ▁; ▁} ▁static ▁int ▁count W ays ▁( ▁String ▁str ▁) ▁{ ▁int ▁freq ▁[ ▁] ▁= ▁new ▁int ▁[ ▁26 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁26 ▁; ▁i ▁++ ▁) ▁{ ▁freq ▁[ ▁i ▁] ▁= ▁0 ▁; ▁} ▁int ▁nv ow els ▁= ▁0 ▁, ▁n con son ants ▁= ▁0 ▁; ▁int ▁v places ▁, ▁c ways ▁, ▁v ways ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁str ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁++ ▁freq ▁[ ▁str ▁. ▁charAt ▁( ▁i ▁) ▁- ▁' ▁a ▁' ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁26 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁== ▁0 ▁i ▁== ▁4 ▁i ▁== ▁8 ▁i ▁== ▁14 ▁i ▁== ▁20 ▁) ▁nv ow els ▁+= ▁freq ▁[ ▁i ▁] ▁; ▁else ▁n con son ants ▁+= ▁freq ▁[ ▁i ▁] ▁; ▁} ▁v places ▁= ▁n con son ants ▁+ ▁1 ▁; ▁c ways ▁= ▁factorial ▁( ▁n con son ants ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁26 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁!= ▁0 ▁&& ▁i ▁!= ▁4 ▁&& ▁i ▁!= ▁8 ▁&& ▁i ▁!= ▁14 ▁&& ▁i ▁!= ▁20 ▁&& ▁freq ▁[ ▁i ▁] ▁> ▁1 ▁) ▁{ ▁c ways ▁= ▁c ways ▁/ ▁factorial ▁( ▁freq ▁[ ▁i ▁] ▁) ▁; ▁} ▁} ▁v ways ▁= ▁n cr ▁( ▁v places ▁, ▁nv ow els ▁) ▁* ▁factorial ▁( ▁nv ow els ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁26 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁== ▁0 ▁i ▁== ▁4 ▁i ▁== ▁8 ▁i ▁== ▁14 ▁i ▁== ▁20 ▁&& ▁freq ▁[ ▁i ▁] ▁> ▁1 ▁) ▁{ ▁v ways ▁= ▁v ways ▁/ ▁factorial ▁( ▁freq ▁[ ▁i ▁] ▁) ▁; ▁} ▁} ▁return ▁c ways ▁* ▁v ways ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁" ▁permutation ▁" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count W ays ▁( ▁str ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁S ieve Of E rat ost hen es ▁( ▁boolean ▁prime ▁[ ▁] ▁, ▁int ▁p _ size ▁) ▁{ ▁prime ▁[ ▁0 ▁] ▁= ▁false ▁; ▁prime ▁[ ▁1 ▁] ▁= ▁false ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁* ▁p ▁<= ▁p _ size ▁; ▁p ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁p ▁] ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁p ▁* ▁2 ▁; ▁i ▁<= ▁p _ size ▁; ▁i ▁+= ▁p ▁) ▁prime ▁[ ▁i ▁] ▁= ▁false ▁; ▁} ▁} ▁} ▁static ▁int ▁sum Of Elements ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁boolean ▁prime ▁[ ▁] ▁= ▁new ▁boolean ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁Arrays ▁. ▁fill ▁( ▁prime ▁, ▁true ▁) ▁; ▁S ieve Of E rat ost hen es ▁( ▁prime ▁, ▁n ▁+ ▁1 ▁) ▁; ▁int ▁i ▁, ▁j ▁; ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁m ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁m ▁. ▁containsKey ▁( ▁arr ▁[ ▁i ▁] ▁) ▁) ▁m ▁. ▁put ▁( ▁arr ▁[ ▁i ▁] ▁, ▁m ▁. ▁get ▁( ▁arr ▁[ ▁i ▁] ▁) ▁+ ▁1 ▁) ▁; ▁else ▁m ▁. ▁put ▁( ▁arr ▁[ ▁i ▁] ▁, ▁1 ▁) ▁; ▁} ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁Map ▁. ▁Entry ▁< ▁Integer ▁, ▁Integer ▁> ▁entry ▁: ▁m ▁. ▁entrySet ▁( ▁) ▁) ▁{ ▁int ▁key ▁= ▁entry ▁. ▁getKey ▁( ▁) ▁; ▁int ▁value ▁= ▁entry ▁. ▁getValue ▁( ▁) ▁; ▁if ▁( ▁prime ▁[ ▁value ▁] ▁) ▁{ ▁sum ▁+= ▁( ▁key ▁) ▁; ▁} ▁} ▁return ▁sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁4 ▁, ▁6 ▁, ▁5 ▁, ▁4 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁sum Of Elements ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁class ▁pair ▁{ ▁int ▁first ▁, ▁second ▁; ▁public ▁pair ▁( ▁int ▁first ▁, ▁int ▁second ▁) ▁{ ▁this ▁. ▁first ▁= ▁first ▁; ▁this ▁. ▁second ▁= ▁second ▁; ▁} ▁} ▁static ▁int ▁total Pairs ▁( ▁int ▁[ ▁] ▁arr 1 ▁, ▁int ▁[ ▁] ▁arr 2 ▁, ▁int ▁K ▁, ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁HashSet ▁< ▁pair ▁> ▁s ▁= ▁new ▁HashSet ▁< ▁pair ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁m ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁arr 1 ▁[ ▁i ▁] ▁> ▁arr 2 ▁[ ▁j ▁] ▁) ▁{ ▁if ▁( ▁arr 1 ▁[ ▁i ▁] ▁% ▁arr 2 ▁[ ▁j ▁] ▁== ▁K ▁) ▁s ▁. ▁add ▁( ▁new ▁pair ▁( ▁arr 1 ▁[ ▁i ▁] ▁, ▁arr 2 ▁[ ▁j ▁] ▁) ▁) ▁; ▁} ▁else ▁{ ▁if ▁( ▁arr 2 ▁[ ▁j ▁] ▁% ▁arr 1 ▁[ ▁i ▁] ▁== ▁K ▁) ▁s ▁. ▁add ▁( ▁new ▁pair ▁( ▁arr 2 ▁[ ▁j ▁] ▁, ▁arr 1 ▁[ ▁i ▁] ▁) ▁) ▁; ▁} ▁} ▁} ▁return ▁s ▁. ▁size ▁( ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr 1 ▁= ▁{ ▁8 ▁, ▁3 ▁, ▁7 ▁, ▁50 ▁} ▁; ▁int ▁[ ▁] ▁arr 2 ▁= ▁{ ▁5 ▁, ▁1 ▁, ▁10 ▁, ▁4 ▁} ▁; ▁int ▁K ▁= ▁3 ▁; ▁int ▁n ▁= ▁arr 1 ▁. ▁length ▁; ▁int ▁m ▁= ▁arr 2 ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁total Pairs ▁( ▁arr 1 ▁, ▁arr 2 ▁, ▁K ▁, ▁n ▁, ▁m ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁Vector ▁< ▁Integer ▁> ▁find Prime ▁( ▁int ▁MAX ▁) ▁{ ▁boolean ▁pm ▁[ ▁] ▁= ▁new ▁boolean ▁[ ▁MAX ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁pm ▁. ▁length ▁; ▁i ▁++ ▁) ▁pm ▁[ ▁i ▁] ▁= ▁true ▁; ▁pm ▁[ ▁0 ▁] ▁= ▁pm ▁[ ▁1 ▁] ▁= ▁false ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁MAX ▁; ▁i ▁++ ▁) ▁if ▁( ▁pm ▁[ ▁i ▁] ▁) ▁for ▁( ▁int ▁j ▁= ▁2 ▁* ▁i ▁; ▁j ▁<= ▁MAX ▁; ▁j ▁+= ▁i ▁) ▁pm ▁[ ▁j ▁] ▁= ▁false ▁; ▁Vector ▁< ▁Integer ▁> ▁prime ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁MAX ▁; ▁i ▁++ ▁) ▁if ▁( ▁pm ▁[ ▁i ▁] ▁) ▁prime ▁. ▁add ▁( ▁i ▁) ▁; ▁return ▁prime ▁; ▁} ▁static ▁int ▁max _ element ▁( ▁int ▁arr ▁[ ▁] ▁) ▁{ ▁int ▁max ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁arr ▁. ▁length ▁; ▁i ▁++ ▁) ▁max ▁= ▁Math ▁. ▁max ▁( ▁max ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁return ▁max ▁; ▁} ▁static ▁int ▁find Small est ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁MAX ▁= ▁max _ element ▁( ▁arr ▁) ▁; ▁Vector ▁< ▁Integer ▁> ▁prime ▁= ▁find Prime ▁( ▁MAX ▁) ▁; ▁Set ▁< ▁Integer ▁> ▁s ▁= ▁new ▁HashSet ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁arr ▁. ▁length ▁; ▁i ▁++ ▁) ▁s ▁. ▁add ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁long ▁ans ▁= ▁- ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁prime ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁! ▁s ▁. ▁contains ▁( ▁prime ▁. ▁get ▁( ▁i ▁) ▁) ▁) ▁{ ▁ans ▁= ▁( ▁prime ▁. ▁get ▁( ▁i ▁) ▁) ▁; ▁break ▁; ▁} ▁} ▁return ▁( ▁int ▁) ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁0 ▁, ▁1 ▁, ▁2 ▁, ▁7 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁if ▁( ▁find Small est ▁( ▁arr ▁, ▁n ▁) ▁== ▁- ▁1 ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁No ▁prime ▁number ▁missing ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁find Small est ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁G F G ▁{ ▁static ▁void ▁profit Loss ▁( ▁int ▁N ▁, ▁int ▁M ▁) ▁{ ▁if ▁( ▁N ▁== ▁M ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁No ▁Pro fit ▁nor ▁Loss ▁" ▁) ▁; ▁else ▁{ ▁float ▁result ▁= ▁0 ▁; ▁result ▁= ▁( ▁float ▁) ▁( ▁Math ▁. ▁abs ▁( ▁N ▁- ▁M ▁) ▁) ▁/ ▁M ▁; ▁if ▁( ▁N ▁- ▁M ▁< ▁0 ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Loss ▁= ▁- ▁" ▁+ ▁result ▁* ▁100 ▁+ ▁" ▁% ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Pro fit ▁= ▁" ▁+ ▁result ▁* ▁100 ▁+ ▁" ▁% ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁8 ▁, ▁M ▁= ▁9 ▁; ▁profit Loss ▁( ▁N ▁, ▁M ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁solution ▁{ ▁static ▁boolean ▁Sum Div isible ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁, ▁position ▁= ▁1 ▁; ▁while ▁( ▁n ▁> ▁0 ▁) ▁{ ▁if ▁( ▁position ▁% ▁2 ▁== ▁1 ▁) ▁sum ▁+= ▁n ▁% ▁10 ▁; ▁n ▁= ▁n ▁/ ▁10 ▁; ▁position ▁++ ▁; ▁} ▁if ▁( ▁sum ▁% ▁k ▁== ▁0 ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁arr ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁59 24 52 ▁; ▁int ▁k ▁= ▁3 ▁; ▁if ▁( ▁Sum Div isible ▁( ▁n ▁, ▁k ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁YES ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁NO ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁sum Div isible ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁String ▁num ▁= ▁Integer ▁. ▁toString ▁( ▁n ▁) ▁; ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁num ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁% ▁2 ▁!= ▁0 ▁) ▁{ ▁sum ▁= ▁sum ▁+ ▁( ▁num ▁. ▁charAt ▁( ▁i ▁) ▁- ▁'0' ▁) ▁; ▁} ▁} ▁if ▁( ▁sum ▁% ▁k ▁== ▁0 ▁) ▁{ ▁return ▁true ▁; ▁} ▁else ▁{ ▁return ▁false ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁59 24 52 ▁; ▁int ▁k ▁= ▁3 ▁; ▁if ▁( ▁sum Div isible ▁( ▁n ▁, ▁k ▁) ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁YES ▁" ▁) ▁; ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁NO ▁" ▁) ▁; ▁} ▁} ▁}
▁public ▁class ▁G F G ▁{ ▁static ▁int ▁Equal Numbers ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁sum ▁+= ▁a ▁[ ▁i ▁] ▁; ▁if ▁( ▁sum ▁% ▁n ▁!= ▁0 ▁) ▁return ▁n ▁- ▁1 ▁; ▁return ▁n ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁4 ▁, ▁1 ▁} ▁; ▁int ▁n ▁= ▁a ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁Equal Numbers ▁( ▁a ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁Possible Values ▁( ▁int ▁b ▁, ▁int ▁x ▁, ▁int ▁n ▁) ▁{ ▁int ▁least div isible ▁= ▁( ▁b ▁/ ▁x ▁+ ▁1 ▁) ▁* ▁x ▁; ▁int ▁flag ▁= ▁1 ▁; ▁while ▁( ▁least div isible ▁<= ▁n ▁) ▁{ ▁if ▁( ▁least div isible ▁- ▁b ▁>= ▁1 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁least div isible ▁- ▁b ▁+ ▁" ▁" ▁) ▁; ▁least div isible ▁+= ▁x ▁; ▁flag ▁= ▁0 ▁; ▁} ▁else ▁break ▁; ▁} ▁if ▁( ▁flag ▁> ▁0 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁- ▁1 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁b ▁= ▁10 ▁, ▁x ▁= ▁6 ▁, ▁n ▁= ▁40 ▁; ▁Possible Values ▁( ▁b ▁, ▁x ▁, ▁n ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁MAX ▁= ▁10000 ▁; ▁static ▁HashSet ▁< ▁Integer ▁> ▁s ▁= ▁new ▁HashSet ▁< ▁Integer ▁> ▁( ▁) ▁; ▁static ▁void ▁S ieve Of E rat ost hen es ▁( ▁) ▁{ ▁boolean ▁[ ▁] ▁prime ▁= ▁new ▁boolean ▁[ ▁MAX ▁] ▁; ▁Arrays ▁. ▁fill ▁( ▁prime ▁, ▁true ▁) ▁; ▁prime ▁[ ▁0 ▁] ▁= ▁false ▁; ▁prime ▁[ ▁1 ▁] ▁= ▁false ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁* ▁p ▁< ▁MAX ▁; ▁p ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁p ▁] ▁== ▁true ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁p ▁* ▁2 ▁; ▁i ▁< ▁MAX ▁; ▁i ▁+= ▁p ▁) ▁prime ▁[ ▁i ▁] ▁= ▁false ▁; ▁} ▁} ▁int ▁product ▁= ▁1 ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁< ▁MAX ▁; ▁p ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁p ▁] ▁) ▁{ ▁product ▁= ▁product ▁* ▁p ▁; ▁s ▁. ▁add ▁( ▁product ▁+ ▁1 ▁) ▁; ▁} ▁} ▁} ▁static ▁boolean ▁is E u cl id ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁s ▁. ▁contains ▁( ▁n ▁) ▁) ▁return ▁true ▁; ▁else ▁return ▁false ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁S ieve Of E rat ost hen es ▁( ▁) ▁; ▁int ▁n ▁= ▁31 ▁; ▁if ▁( ▁is E u cl id ▁( ▁n ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁n ▁= ▁42 ▁; ▁if ▁( ▁is E u cl id ▁( ▁n ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁Number Of Solution s ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁int ▁c ▁, ▁int ▁d ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁a ▁; ▁i ▁<= ▁b ▁; ▁i ▁++ ▁) ▁if ▁( ▁d ▁>= ▁Math ▁. ▁max ▁( ▁c ▁, ▁i ▁+ ▁1 ▁) ▁) ▁ans ▁+= ▁d ▁- ▁Math ▁. ▁max ▁( ▁c ▁, ▁i ▁+ ▁1 ▁) ▁+ ▁1 ▁; ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁= ▁2 ▁, ▁b ▁= ▁3 ▁, ▁c ▁= ▁3 ▁, ▁d ▁= ▁4 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁Number Of Solution s ▁( ▁a ▁, ▁b ▁, ▁c ▁, ▁d ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁solution ▁{ ▁static ▁int ▁nth Term ▁( ▁int ▁n ▁) ▁{ ▁return ▁2 ▁* ▁( ▁int ▁) ▁Math ▁. ▁pow ▁( ▁n ▁, ▁2 ▁) ▁+ ▁4 ▁* ▁n ▁- ▁2 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁arr ▁[ ▁] ▁) ▁{ ▁int ▁N ▁= ▁4 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁nth Term ▁( ▁N ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁calculate Area Sum ▁( ▁int ▁l ▁, ▁int ▁b ▁) ▁{ ▁int ▁size ▁= ▁1 ▁; ▁int ▁maxSize ▁= ▁Math ▁. ▁min ▁( ▁l ▁, ▁b ▁) ▁; ▁int ▁total Area ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁maxSize ▁; ▁i ▁++ ▁) ▁{ ▁int ▁total Square s ▁= ▁( ▁l ▁- ▁size ▁+ ▁1 ▁) ▁* ▁( ▁b ▁- ▁size ▁+ ▁1 ▁) ▁; ▁int ▁area ▁= ▁total Square s ▁* ▁size ▁* ▁size ▁; ▁total Area ▁+= ▁area ▁; ▁size ▁++ ▁; ▁} ▁return ▁total Area ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁l ▁= ▁4 ▁, ▁b ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁calculate Area Sum ▁( ▁l ▁, ▁b ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁check ▁( ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁while ▁( ▁n ▁!= ▁0 ▁) ▁{ ▁sum ▁+= ▁n ▁% ▁10 ▁; ▁n ▁= ▁n ▁/ ▁10 ▁; ▁} ▁if ▁( ▁sum ▁% ▁7 ▁== ▁0 ▁) ▁return ▁1 ▁; ▁else ▁return ▁0 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁25 ▁; ▁String ▁s ▁= ▁( ▁check ▁( ▁n ▁) ▁== ▁1 ▁) ▁? ▁" ▁YES ▁" ▁: ▁" ▁NO ▁" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁s ▁) ▁; ▁} ▁}
▁class ▁G eek s ▁{ ▁static ▁int ▁bin omial Co eff ▁( ▁int ▁x ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁, ▁term ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁&& ▁sum ▁< ▁k ▁; ▁++ ▁i ▁) ▁{ ▁term ▁*= ▁x ▁- ▁i ▁+ ▁1 ▁; ▁term ▁/= ▁i ▁; ▁sum ▁+= ▁term ▁; ▁} ▁return ▁sum ▁; ▁} ▁static ▁int ▁min Tri als ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁low ▁= ▁1 ▁, ▁high ▁= ▁k ▁; ▁while ▁( ▁low ▁< ▁high ▁) ▁{ ▁int ▁mid ▁= ▁( ▁low ▁+ ▁high ▁) ▁/ ▁2 ▁; ▁if ▁( ▁bin omial Co eff ▁( ▁mid ▁, ▁n ▁, ▁k ▁) ▁< ▁k ▁) ▁low ▁= ▁mid ▁+ ▁1 ▁; ▁else ▁high ▁= ▁mid ▁; ▁} ▁return ▁low ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁min Tri als ▁( ▁2 ▁, ▁10 ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁class ▁G eek s ▁{ ▁static ▁boolean ▁is Prime ▁( ▁int ▁num ▁) ▁{ ▁if ▁( ▁num ▁< ▁2 ▁num ▁% ▁2 ▁== ▁0 ▁) ▁return ▁num ▁== ▁2 ▁; ▁for ▁( ▁int ▁i ▁= ▁3 ▁; ▁i ▁* ▁i ▁<= ▁num ▁; ▁i ▁+= ▁2 ▁) ▁if ▁( ▁num ▁% ▁i ▁== ▁0 ▁) ▁return ▁false ▁; ▁return ▁true ▁; ▁} ▁static ▁int ▁prime Pal indrome ▁( ▁int ▁N ▁) ▁{ ▁if ▁( ▁8 ▁<= ▁N ▁&& ▁N ▁<= ▁11 ▁) ▁return ▁11 ▁; ▁for ▁( ▁int ▁x ▁= ▁1 ▁; ▁x ▁< ▁100000 ▁; ▁++ ▁x ▁) ▁{ ▁String ▁s ▁= ▁Integer ▁. ▁toString ▁( ▁x ▁) ▁; ▁StringBuffer ▁buffer ▁= ▁new ▁StringBuffer ▁( ▁s ▁) ▁; ▁buffer ▁. ▁reverse ▁( ▁) ▁; ▁int ▁y ▁= ▁Integer ▁. ▁parseInt ▁( ▁s ▁+ ▁buffer ▁. ▁substring ▁( ▁1 ▁) ▁. ▁toString ▁( ▁) ▁) ▁; ▁if ▁( ▁y ▁>= ▁N ▁&& ▁is Prime ▁( ▁y ▁) ▁== ▁true ▁) ▁return ▁y ▁; ▁} ▁return ▁- ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁prime Pal indrome ▁( ▁112 ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁boost _ hyper factor ial ▁( ▁int ▁num ▁) ▁{ ▁int ▁val ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁num ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁<= ▁i ▁; ▁j ▁++ ▁) ▁{ ▁val ▁*= ▁i ▁; ▁} ▁} ▁return ▁val ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁num ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁boost _ hyper factor ial ▁( ▁num ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁count Odd Sum ▁( ▁int ▁ar ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁temp ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁0 ▁} ▁; ▁int ▁result ▁= ▁0 ▁, ▁val ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁val ▁= ▁( ▁( ▁val ▁+ ▁ar ▁[ ▁i ▁] ▁) ▁% ▁2 ▁+ ▁2 ▁) ▁% ▁2 ▁; ▁temp ▁[ ▁val ▁] ▁++ ▁; ▁} ▁result ▁= ▁temp ▁[ ▁0 ▁] ▁* ▁temp ▁[ ▁1 ▁] ▁; ▁return ▁( ▁result ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁ar ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁4 ▁, ▁4 ▁, ▁5 ▁, ▁1 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁ar ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁The ▁Number ▁of ▁Sub arrays ▁" ▁+ ▁" ▁with ▁odd ▁sum ▁is ▁" ▁+ ▁count Odd Sum ▁( ▁ar ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁center _ hex ad ec ag onal _ num ▁( ▁int ▁n ▁) ▁{ ▁return ▁8 ▁* ▁n ▁* ▁n ▁- ▁8 ▁* ▁n ▁+ ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁n ▁+ ▁" ▁th ▁centered ▁" ▁+ ▁" ▁hex ad ec ag onal ▁number ▁: ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁center _ hex ad ec ag onal _ num ▁( ▁n ▁) ▁) ▁; ▁n ▁= ▁12 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁n ▁+ ▁" ▁th ▁centered ▁" ▁+ ▁" ▁hex ad ec ag onal ▁number ▁: ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁center _ hex ad ec ag onal _ num ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁check ▁( ▁long ▁m ▁, ▁long ▁n ▁) ▁{ ▁double ▁R HS ▁= ▁m ▁* ▁( ▁double ▁) ▁Math ▁. ▁log ▁( ▁n ▁) ▁; ▁double ▁L HS ▁= ▁n ▁* ▁( ▁double ▁) ▁Math ▁. ▁log ▁( ▁m ▁) ▁; ▁if ▁( ▁L HS ▁> ▁R HS ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁m ▁^ ▁n ▁> ▁n ▁^ ▁m ▁" ▁) ▁; ▁else ▁if ▁( ▁L HS ▁< ▁R HS ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁m ▁^ ▁n ▁< ▁n ▁^ ▁m ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁m ▁^ ▁n ▁= ▁n ▁^ ▁m ▁" ▁) ▁; ▁} ▁static ▁public ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁long ▁m ▁= ▁98 7654 321 ▁, ▁n ▁= ▁123456 98 7 ▁; ▁check ▁( ▁m ▁, ▁n ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁factorial ▁( ▁int ▁n ▁) ▁{ ▁int ▁res ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁res ▁= ▁res ▁* ▁i ▁; ▁return ▁res ▁; ▁} ▁static ▁int ▁calculate Series ▁( ▁int ▁n ▁) ▁{ ▁return ▁2 ▁+ ▁( ▁n ▁* ▁n ▁+ ▁n ▁- ▁2 ▁) ▁* ▁factorial ▁( ▁n ▁+ ▁1 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁calculate Series ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁find Sum ▁( ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁sum ▁+= ▁( ▁( ▁i ▁* ▁( ▁i ▁+ ▁1 ▁) ▁* ▁( ▁2 ▁* ▁i ▁+ ▁1 ▁) ▁) ▁/ ▁6 ▁) ▁; ▁return ▁sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Sum ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁Vector ▁< ▁Long ▁> ▁gen ▁( ▁long ▁n ▁, ▁Vector ▁< ▁Long ▁> ▁r ▁) ▁{ ▁long ▁a ▁= ▁r ▁. ▁get ▁( ▁r ▁. ▁size ▁( ▁) ▁- ▁1 ▁) ▁; ▁a ▁++ ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁a ▁+= ▁2 ▁, ▁i ▁++ ▁) ▁{ ▁r ▁. ▁add ▁( ▁a ▁) ▁; ▁} ▁return ▁r ▁; ▁} ▁static ▁Vector ▁< ▁Long ▁> ▁con ell ▁( ▁long ▁n ▁) ▁{ ▁Vector ▁< ▁Long ▁> ▁res ▁= ▁new ▁Vector ▁< ▁Long ▁> ▁( ▁) ▁; ▁long ▁k ▁= ▁1 ▁; ▁res ▁. ▁add ▁( ▁0 L ▁) ▁; ▁while ▁( ▁true ▁) ▁{ ▁res ▁= ▁gen ▁( ▁k ▁, ▁res ▁) ▁; ▁k ▁++ ▁; ▁int ▁j ▁= ▁res ▁. ▁size ▁( ▁) ▁- ▁1 ▁; ▁while ▁( ▁j ▁!= ▁n ▁&& ▁j ▁+ ▁k ▁> ▁n ▁) ▁{ ▁k ▁-- ▁; ▁} ▁if ▁( ▁j ▁>= ▁n ▁) ▁{ ▁break ▁; ▁} ▁} ▁res ▁. ▁remove ▁( ▁0 ▁) ▁; ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁long ▁n ▁= ▁10 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁The ▁first ▁" ▁+ ▁n ▁+ ▁" ▁terms ▁are ▁" ▁) ▁; ▁Vector ▁< ▁Long ▁> ▁res ▁= ▁con ell ▁( ▁n ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁res ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁res ▁. ▁get ▁( ▁i ▁) ▁+ ▁" ▁" ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁N ic om ach u The orum _ sum ▁( ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁k ▁= ▁1 ▁; ▁k ▁<= ▁n ▁; ▁k ▁++ ▁) ▁sum ▁+= ▁k ▁* ▁k ▁* ▁k ▁; ▁int ▁tri No ▁= ▁n ▁* ▁( ▁n ▁+ ▁1 ▁) ▁/ ▁2 ▁; ▁if ▁( ▁sum ▁== ▁tri No ▁* ▁tri No ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁5 ▁; ▁N ic om ach u The orum _ sum ▁( ▁n ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁factorial ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁0 ▁) ▁return ▁1 ▁; ▁return ▁n ▁* ▁factorial ▁( ▁n ▁- ▁1 ▁) ▁; ▁} ▁static ▁int ▁L CM Of Ne ighb our Fact ▁( ▁int ▁n ▁) ▁{ ▁return ▁factorial ▁( ▁n ▁+ ▁1 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁N ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁L CM Of Ne ighb our Fact ▁( ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁is Prime ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁0 ▁n ▁== ▁1 ▁) ▁return ▁false ▁; ▁int ▁root ▁= ▁( ▁int ▁) ▁Math ▁. ▁sqrt ▁( ▁n ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁root ▁; ▁i ▁++ ▁) ▁if ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁return ▁false ▁; ▁return ▁true ▁; ▁} ▁static ▁boolean ▁isS and witch ed ▁( ▁int ▁n ▁) ▁{ ▁return ▁( ▁is Prime ▁( ▁n ▁- ▁1 ▁) ▁&& ▁is Prime ▁( ▁n ▁+ ▁1 ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁64 2 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁n ▁+ ▁" ▁: ▁" ▁) ▁; ▁if ▁( ▁isS and witch ed ▁( ▁n ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁n ▁= ▁9 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁n ▁+ ▁" ▁: ▁" ▁) ▁; ▁if ▁( ▁isS and witch ed ▁( ▁n ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁boolean ▁is Square Free ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁% ▁2 ▁== ▁0 ▁) ▁n ▁= ▁n ▁/ ▁2 ▁; ▁if ▁( ▁n ▁% ▁2 ▁== ▁0 ▁) ▁return ▁false ▁; ▁for ▁( ▁int ▁i ▁= ▁3 ▁; ▁i ▁<= ▁Math ▁. ▁sqrt ▁( ▁n ▁) ▁; ▁i ▁= ▁i ▁+ ▁2 ▁) ▁{ ▁if ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁{ ▁n ▁= ▁n ▁/ ▁i ▁; ▁if ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁return ▁false ▁; ▁} ▁} ▁return ▁true ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁10 ▁; ▁if ▁( ▁is Square Free ▁( ▁n ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁math ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁sum of odd Fact ors ▁( ▁int ▁n ▁) ▁{ ▁int ▁res ▁= ▁1 ▁; ▁while ▁( ▁n ▁% ▁2 ▁== ▁0 ▁) ▁n ▁= ▁n ▁/ ▁2 ▁; ▁for ▁( ▁int ▁i ▁= ▁3 ▁; ▁i ▁<= ▁Math ▁. ▁sqrt ▁( ▁n ▁) ▁; ▁i ▁++ ▁) ▁{ ▁int ▁count ▁= ▁0 ▁, ▁curr _ sum ▁= ▁1 ▁; ▁int ▁curr _ term ▁= ▁1 ▁; ▁while ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁{ ▁count ▁++ ▁; ▁n ▁= ▁n ▁/ ▁i ▁; ▁curr _ term ▁*= ▁i ▁; ▁curr _ sum ▁+= ▁curr _ term ▁; ▁} ▁res ▁*= ▁curr _ sum ▁; ▁} ▁if ▁( ▁n ▁>= ▁2 ▁) ▁res ▁*= ▁( ▁1 ▁+ ▁n ▁) ▁; ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁throws ▁IOException ▁{ ▁int ▁n ▁= ▁30 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁sum of odd Fact ors ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁count Solution s ▁( ▁int ▁n ▁, ▁int ▁val ▁) ▁{ ▁int ▁total ▁= ▁0 ▁; ▁if ▁( ▁n ▁== ▁1 ▁&& ▁val ▁>= ▁0 ▁) ▁return ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁val ▁; ▁i ▁++ ▁) ▁{ ▁total ▁+= ▁count Solution s ▁( ▁n ▁- ▁1 ▁, ▁val ▁- ▁i ▁) ▁; ▁} ▁return ▁total ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁5 ▁; ▁int ▁val ▁= ▁20 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁count Solution s ▁( ▁n ▁, ▁val ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁static ▁java ▁. ▁lang ▁. ▁Math ▁. ▁* ▁; ▁class ▁n arc iss istic ▁{ ▁int ▁count Digit ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁0 ▁) ▁return ▁0 ▁; ▁return ▁1 ▁+ ▁count Digit ▁( ▁n ▁/ ▁10 ▁) ▁; ▁} ▁boolean ▁check ▁( ▁int ▁n ▁) ▁{ ▁int ▁l ▁= ▁count Digit ▁( ▁n ▁) ▁; ▁int ▁dup ▁= ▁n ▁; ▁int ▁sum ▁= ▁0 ▁; ▁while ▁( ▁dup ▁> ▁0 ▁) ▁{ ▁sum ▁+= ▁pow ▁( ▁dup ▁% ▁10 ▁, ▁l ▁) ▁; ▁dup ▁/= ▁10 ▁; ▁} ▁return ▁( ▁n ▁== ▁sum ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁n arc iss istic ▁obj ▁= ▁new ▁n arc iss istic ▁( ▁) ▁; ▁int ▁n ▁= ▁16 34 ▁; ▁if ▁( ▁obj ▁. ▁check ▁( ▁n ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁no ▁" ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁gcd ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁if ▁( ▁a ▁== ▁0 ▁) ▁return ▁b ▁; ▁return ▁gcd ▁( ▁b ▁% ▁a ▁, ▁a ▁) ▁; ▁} ▁static ▁int ▁same Rem ainder ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁int ▁c ▁) ▁{ ▁int ▁a 1 ▁= ▁( ▁b ▁- ▁a ▁) ▁, ▁b 1 ▁= ▁( ▁c ▁- ▁b ▁) ▁, ▁c 1 ▁= ▁( ▁c ▁- ▁a ▁) ▁; ▁return ▁gcd ▁( ▁a 1 ▁, ▁gcd ▁( ▁b 1 ▁, ▁c 1 ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁= ▁62 ▁, ▁b ▁= ▁132 ▁, ▁c ▁= ▁2 37 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁same Rem ainder ▁( ▁a ▁, ▁b ▁, ▁c ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁char ▁[ ▁] ▁Prime Digit Number ▁( ▁char ▁N ▁[ ▁] ▁, ▁int ▁size ▁) ▁{ ▁char ▁[ ▁] ▁ans ▁= ▁new ▁char ▁[ ▁size ▁] ▁; ▁int ▁ns ▁= ▁0 ▁; ▁int ▁small ▁= ▁0 ▁; ▁int ▁i ▁; ▁int ▁p ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁0 ▁} ▁; ▁int ▁prev prime ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁2 ▁, ▁3 ▁, ▁3 ▁, ▁5 ▁, ▁5 ▁, ▁7 ▁, ▁7 ▁} ▁; ▁if ▁( ▁size ▁== ▁1 ▁) ▁{ ▁ans ▁[ ▁0 ▁] ▁= ▁( ▁char ▁) ▁( ▁prev prime ▁[ ▁N ▁[ ▁0 ▁] ▁- ▁'0' ▁] ▁+ ▁'0' ▁) ▁; ▁ans ▁[ ▁1 ▁] ▁= ▁' ▁\0' ▁; ▁return ▁ans ▁; ▁} ▁if ▁( ▁N ▁[ ▁0 ▁] ▁== ▁'1' ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁- ▁1 ▁; ▁i ▁++ ▁) ▁ans ▁[ ▁i ▁] ▁= ▁'7' ▁; ▁ans ▁[ ▁size ▁- ▁1 ▁] ▁= ▁' ▁\0' ▁; ▁return ▁ans ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁&& ▁small ▁== ▁0 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁p ▁[ ▁N ▁[ ▁i ▁] ▁- ▁'0' ▁] ▁== ▁1 ▁) ▁{ ▁ans ▁[ ▁ns ▁++ ▁] ▁= ▁N ▁[ ▁i ▁] ▁; ▁} ▁else ▁{ ▁if ▁( ▁p ▁[ ▁N ▁[ ▁i ▁] ▁- ▁'0' ▁] ▁== ▁0 ▁&& ▁prev prime ▁[ ▁N ▁[ ▁i ▁] ▁- ▁'0' ▁] ▁!= ▁0 ▁) ▁{ ▁ans ▁[ ▁ns ▁++ ▁] ▁= ▁( ▁char ▁) ▁( ▁prev prime ▁[ ▁N ▁[ ▁i ▁] ▁- ▁'0' ▁] ▁+ ▁'0' ▁) ▁; ▁small ▁= ▁1 ▁; ▁} ▁else ▁if ▁( ▁p ▁[ ▁N ▁[ ▁i ▁] ▁- ▁'0' ▁] ▁== ▁0 ▁&& ▁prev prime ▁[ ▁N ▁[ ▁i ▁] ▁- ▁'0' ▁] ▁== ▁0 ▁) ▁{ ▁int ▁j ▁= ▁i ▁; ▁while ▁( ▁j ▁> ▁0 ▁&& ▁p ▁[ ▁N ▁[ ▁j ▁] ▁- ▁'0' ▁] ▁== ▁0 ▁&& ▁prev prime ▁[ ▁N ▁[ ▁j ▁] ▁- ▁'0' ▁] ▁== ▁0 ▁) ▁{ ▁ans ▁[ ▁j ▁] ▁= ▁N ▁[ ▁j ▁] ▁= ▁'7' ▁; ▁N ▁[ ▁j ▁- ▁1 ▁] ▁= ▁( ▁char ▁) ▁( ▁prev prime ▁[ ▁N ▁[ ▁j ▁- ▁1 ▁] ▁- ▁'0' ▁] ▁+ ▁'0' ▁) ▁; ▁ans ▁[ ▁j ▁- ▁1 ▁] ▁= ▁N ▁[ ▁j ▁- ▁1 ▁] ▁; ▁small ▁= ▁1 ▁; ▁j ▁-- ▁; ▁} ▁i ▁= ▁ns ▁; ▁} ▁} ▁} ▁if ▁( ▁small ▁== ▁0 ▁) ▁{ ▁if ▁( ▁prev prime ▁[ ▁N ▁[ ▁size ▁- ▁1 ▁] ▁- ▁'0' ▁] ▁+ ▁'0' ▁!= ▁'0' ▁) ▁ans ▁[ ▁size ▁- ▁1 ▁] ▁= ▁( ▁char ▁) ▁( ▁prev prime ▁[ ▁N ▁[ ▁size ▁- ▁1 ▁] ▁- ▁'0' ▁] ▁+ ▁'0' ▁) ▁; ▁else ▁{ ▁int ▁j ▁= ▁size ▁- ▁1 ▁; ▁while ▁( ▁j ▁> ▁0 ▁&& ▁prev prime ▁[ ▁N ▁[ ▁j ▁] ▁- ▁'0' ▁] ▁== ▁0 ▁) ▁{ ▁ans ▁[ ▁j ▁] ▁= ▁N ▁[ ▁j ▁] ▁= ▁'7' ▁; ▁N ▁[ ▁j ▁- ▁1 ▁] ▁= ▁( ▁char ▁) ▁( ▁prev prime ▁[ ▁N ▁[ ▁j ▁- ▁1 ▁] ▁- ▁'0' ▁] ▁+ ▁'0' ▁) ▁; ▁ans ▁[ ▁j ▁- ▁1 ▁] ▁= ▁N ▁[ ▁j ▁- ▁1 ▁] ▁; ▁small ▁= ▁1 ▁; ▁j ▁-- ▁; ▁} ▁} ▁} ▁for ▁( ▁; ▁ns ▁< ▁size ▁; ▁ns ▁++ ▁) ▁ans ▁[ ▁ns ▁] ▁= ▁'7' ▁; ▁ans ▁[ ▁ns ▁] ▁= ▁' ▁\0' ▁; ▁int ▁k ▁= ▁0 ▁; ▁while ▁( ▁ans ▁[ ▁k ▁] ▁== ▁'0' ▁) ▁k ▁++ ▁; ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁char ▁[ ▁] ▁N ▁= ▁"1 000" ▁. ▁toCharArray ▁( ▁) ▁; ▁int ▁size ▁= ▁N ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁Prime Digit Number ▁( ▁N ▁, ▁size ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁boolean ▁is Power Of K ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁boolean ▁one Seen ▁= ▁false ▁; ▁while ▁( ▁n ▁> ▁0 ▁) ▁{ ▁int ▁digit ▁= ▁n ▁% ▁k ▁; ▁if ▁( ▁digit ▁> ▁1 ▁) ▁return ▁false ▁; ▁if ▁( ▁digit ▁== ▁1 ▁) ▁{ ▁if ▁( ▁one Seen ▁) ▁return ▁false ▁; ▁one Seen ▁= ▁true ▁; ▁} ▁n ▁/= ▁k ▁; ▁} ▁return ▁true ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁64 ▁, ▁k ▁= ▁4 ▁; ▁if ▁( ▁is Power Of K ▁( ▁n ▁, ▁k ▁) ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁calc Scr ▁( ▁ArrayList ▁< ▁Integer ▁> ▁arr ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁arr ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁ans ▁+= ▁( ▁i ▁^ ▁arr ▁. ▁get ▁( ▁i ▁) ▁) ▁; ▁return ▁ans ▁; ▁} ▁static ▁int ▁getMax ▁( ▁ArrayList ▁< ▁Integer ▁> ▁arr ▁, ▁int ▁ans ▁, ▁ArrayList ▁< ▁Boolean ▁> ▁chosen ▁, ▁int ▁N ▁) ▁{ ▁if ▁( ▁arr ▁. ▁size ▁( ▁) ▁== ▁N ▁) ▁{ ▁ans ▁= ▁Math ▁. ▁max ▁( ▁ans ▁, ▁calc Scr ▁( ▁arr ▁) ▁) ▁; ▁return ▁ans ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁chosen ▁. ▁get ▁( ▁i ▁) ▁) ▁continue ▁; ▁chosen ▁. ▁set ▁( ▁i ▁, ▁true ▁) ▁; ▁arr ▁. ▁add ▁( ▁i ▁) ▁; ▁ans ▁= ▁getMax ▁( ▁arr ▁, ▁ans ▁, ▁chosen ▁, ▁N ▁) ▁; ▁chosen ▁. ▁set ▁( ▁i ▁, ▁false ▁) ▁; ▁arr ▁. ▁remove ▁( ▁arr ▁. ▁size ▁( ▁) ▁- ▁1 ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁2 ▁; ▁ArrayList ▁< ▁Integer ▁> ▁arr ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁int ▁ans ▁= ▁- ▁1 ▁; ▁ArrayList ▁< ▁Boolean ▁> ▁chosen ▁= ▁new ▁ArrayList ▁< ▁Boolean ▁> ▁( ▁Collections ▁. ▁n Copies ▁( ▁N ▁, ▁false ▁) ▁) ▁; ▁ans ▁= ▁getMax ▁( ▁arr ▁, ▁ans ▁, ▁chosen ▁, ▁N ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁ans ▁+ ▁" NEW _ LINE "); ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁solution ▁{ ▁static ▁void ▁find Prime N os ▁( ▁int ▁L ▁, ▁int ▁R ▁, ▁Map ▁< ▁Integer ▁, ▁Integer ▁> ▁M ▁, ▁int ▁K ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁L ▁; ▁i ▁<= ▁R ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁M ▁. ▁get ▁( ▁i ▁) ▁!= ▁null ▁) ▁M ▁. ▁put ▁( ▁i ▁, ▁M ▁. ▁get ▁( ▁i ▁) ▁+ ▁1 ▁) ▁; ▁else ▁M ▁. ▁put ▁( ▁i ▁, ▁1 ▁) ▁; ▁} ▁if ▁( ▁M ▁. ▁get ▁( ▁1 ▁) ▁!= ▁null ▁) ▁{ ▁M ▁. ▁remove ▁( ▁1 ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁Math ▁. ▁sqrt ▁( ▁R ▁) ▁; ▁i ▁++ ▁) ▁{ ▁int ▁multiple ▁= ▁2 ▁; ▁while ▁( ▁( ▁i ▁* ▁multiple ▁) ▁<= ▁R ▁) ▁{ ▁if ▁( ▁M ▁. ▁get ▁( ▁i ▁* ▁multiple ▁) ▁!= ▁null ▁) ▁{ ▁M ▁. ▁remove ▁( ▁i ▁* ▁multiple ▁) ▁; ▁} ▁multiple ▁++ ▁; ▁} ▁} ▁for ▁( ▁Map ▁. ▁Entry ▁< ▁Integer ▁, ▁Integer ▁> ▁entry ▁: ▁M ▁. ▁entrySet ▁( ▁) ▁) ▁{ ▁if ▁( ▁M ▁. ▁get ▁( ▁entry ▁. ▁getKey ▁( ▁) ▁+ ▁K ▁) ▁!= ▁null ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁( ▁" ▁+ ▁entry ▁. ▁getKey ▁( ▁) ▁+ ▁" ▁, ▁" ▁+ ▁( ▁entry ▁. ▁getKey ▁( ▁) ▁+ ▁K ▁) ▁+ ▁" ▁) ▁" ▁) ▁; ▁} ▁} ▁} ▁static ▁void ▁getPr ime Pairs ▁( ▁int ▁L ▁, ▁int ▁R ▁, ▁int ▁K ▁) ▁{ ▁Map ▁< ▁Integer ▁, ▁Integer ▁> ▁M ▁= ▁new ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁( ▁) ▁; ▁find Prime N os ▁( ▁L ▁, ▁R ▁, ▁M ▁, ▁K ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁L ▁= ▁1 ▁, ▁R ▁= ▁19 ▁; ▁int ▁K ▁= ▁6 ▁; ▁getPr ime Pairs ▁( ▁L ▁, ▁R ▁, ▁K ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁gon Num 6 55 37 ▁( ▁int ▁n ▁) ▁{ ▁return ▁( ▁65535 ▁* ▁n ▁* ▁n ▁- ▁655 33 ▁* ▁n ▁) ▁/ ▁2 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁gon Num 6 55 37 ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁solution ▁{ ▁static ▁int ▁count ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁arr ▁) ▁; ▁int ▁cnt ▁= ▁0 ▁; ▁int ▁i ▁= ▁0 ▁, ▁j ▁= ▁1 ▁; ▁while ▁( ▁i ▁< ▁n ▁&& ▁j ▁< ▁n ▁) ▁{ ▁j ▁= ▁( ▁j ▁<= ▁i ▁) ▁? ▁( ▁i ▁+ ▁1 ▁) ▁: ▁j ▁; ▁while ▁( ▁j ▁< ▁n ▁&& ▁( ▁arr ▁[ ▁j ▁] ▁- ▁arr ▁[ ▁i ▁] ▁) ▁< ▁k ▁) ▁j ▁++ ▁; ▁cnt ▁+= ▁( ▁n ▁- ▁j ▁) ▁; ▁i ▁++ ▁; ▁} ▁return ▁cnt ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁int ▁k ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count ▁( ▁arr ▁, ▁n ▁, ▁k ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁maximum Factor ▁( ▁int ▁[ ▁] ▁arr ▁) ▁{ ▁int ▁[ ▁] ▁rank ▁= ▁new ▁int ▁[ ▁Arrays ▁. ▁stream ▁( ▁arr ▁) ▁. ▁max ▁( ▁) ▁. ▁getAs Int ▁( ▁) ▁+ ▁1 ▁] ▁; ▁int ▁[ ▁] ▁factors ▁= ▁new ▁int ▁[ ▁Arrays ▁. ▁stream ▁( ▁arr ▁) ▁. ▁max ▁( ▁) ▁. ▁getAs Int ▁( ▁) ▁+ ▁1 ▁] ▁; ▁int ▁g ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁Arrays ▁. ▁stream ▁( ▁arr ▁) ▁. ▁max ▁( ▁) ▁. ▁getAs Int ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁arr ▁. ▁length ▁; ▁j ▁++ ▁) ▁if ▁( ▁arr ▁[ ▁j ▁] ▁% ▁i ▁== ▁0 ▁) ▁count ▁+= ▁1 ▁; ▁rank ▁[ ▁g ▁] ▁= ▁count ▁; ▁factors ▁[ ▁g ▁] ▁= ▁i ▁; ▁g ▁++ ▁; ▁} ▁int ▁m ▁= ▁Arrays ▁. ▁stream ▁( ▁rank ▁) ▁. ▁max ▁( ▁) ▁. ▁getAs Int ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁rank ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁rank ▁[ ▁i ▁] ▁== ▁m ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁factors ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁120 ▁, ▁15 ▁, ▁24 ▁, ▁63 ▁, ▁18 ▁} ▁; ▁maximum Factor ▁( ▁arr ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁find Sum ▁( ▁int ▁n ▁, ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁i ▁% ▁a ▁== ▁0 ▁i ▁% ▁b ▁== ▁0 ▁) ▁sum ▁+= ▁i ▁; ▁return ▁sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁10 ▁, ▁a ▁= ▁3 ▁, ▁b ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Sum ▁( ▁n ▁, ▁a ▁, ▁b ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁double ▁find Medi an ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁a ▁) ▁; ▁if ▁( ▁n ▁% ▁2 ▁!= ▁0 ▁) ▁return ▁( ▁double ▁) ▁a ▁[ ▁n ▁/ ▁2 ▁] ▁; ▁return ▁( ▁double ▁) ▁( ▁a ▁[ ▁( ▁n ▁- ▁1 ▁) ▁/ ▁2 ▁] ▁+ ▁a ▁[ ▁n ▁/ ▁2 ▁] ▁) ▁/ ▁2.0 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁4 ▁, ▁2 ▁, ▁7 ▁, ▁5 ▁, ▁8 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁a ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Medi an ▁= ▁" ▁+ ▁find Medi an ▁( ▁a ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁centered I cos ah ed ral Num ▁( ▁int ▁n ▁) ▁{ ▁return ▁( ▁2 ▁* ▁n ▁+ ▁1 ▁) ▁* ▁( ▁5 ▁* ▁n ▁* ▁n ▁+ ▁5 ▁* ▁n ▁+ ▁3 ▁) ▁/ ▁3 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁10 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁centered I cos ah ed ral Num ▁( ▁n ▁) ▁) ▁; ▁n ▁= ▁12 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁centered I cos ah ed ral Num ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁D ode c ag onal _ number ▁( ▁int ▁n ▁) ▁{ ▁return ▁5 ▁* ▁n ▁* ▁n ▁- ▁4 ▁* ▁n ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁7 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁D ode c ag onal _ number ▁( ▁n ▁) ▁) ▁; ▁n ▁= ▁12 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁D ode c ag onal _ number ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁average Even ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁% ▁2 ▁!= ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Invalid ▁Input ▁" ▁) ▁; ▁return ▁- ▁1 ▁; ▁} ▁return ▁( ▁n ▁+ ▁2 ▁) ▁/ ▁2 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁16 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁average Even ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G eek s for G eek s ▁{ ▁static ▁double ▁compute ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁double ▁AM ▁, ▁G M ▁, ▁H M ▁; ▁AM ▁= ▁( ▁a ▁+ ▁b ▁) ▁/ ▁2 ▁; ▁G M ▁= ▁Math ▁. ▁sqrt ▁( ▁a ▁* ▁b ▁) ▁; ▁H M ▁= ▁( ▁G M ▁* ▁G M ▁) ▁/ ▁AM ▁; ▁return ▁H M ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁a ▁= ▁5 ▁, ▁b ▁= ▁15 ▁; ▁double ▁H M ▁= ▁compute ▁( ▁a ▁, ▁b ▁) ▁; ▁String ▁str ▁= ▁" ▁" ▁; ▁str ▁= ▁str ▁+ ▁H M ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Har mon ic ▁Mean ▁between ▁" ▁+ ▁a ▁+ ▁" ▁and ▁" ▁+ ▁b ▁+ ▁" ▁is ▁" ▁+ ▁str ▁. ▁substring ▁( ▁0 ▁, ▁5 ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁Array _ pu zz le _2 ▁{ ▁static ▁final ▁double ▁EPS ▁= ▁1 e -9 ▁; ▁static ▁void ▁product P uzz le ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁double ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁sum ▁+= ▁Math ▁. ▁log 10 ▁( ▁a ▁[ ▁i ▁] ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁( ▁int ▁) ▁( ▁EPS ▁+ ▁Math ▁. ▁pow ▁( ▁10. 00 ▁, ▁sum ▁- ▁Math ▁. ▁log 10 ▁( ▁a ▁[ ▁i ▁] ▁) ▁) ▁) ▁+ ▁" ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁3 ▁, ▁5 ▁, ▁6 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁a ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁The ▁product ▁array ▁is ▁: ▁" ▁) ▁; ▁product P uzz le ▁( ▁a ▁, ▁n ▁) ▁; ▁} ▁}
▁class ▁P ell Number ▁{ ▁public ▁static ▁int ▁p ell ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁<= ▁2 ▁) ▁return ▁n ▁; ▁return ▁2 ▁* ▁p ell ▁( ▁n ▁- ▁1 ▁) ▁+ ▁p ell ▁( ▁n ▁- ▁2 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁4 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁p ell ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁class ▁G F G 1 ▁{ ▁static ▁long ▁find Min Value ▁( ▁long ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁arr ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁val ▁+= ▁( ▁double ▁) ▁( ▁Math ▁. ▁log ▁( ▁( ▁double ▁) ▁( ▁arr ▁[ ▁i ▁] ▁) ▁) ▁) ▁; ▁} ▁long ▁left ▁= ▁arr ▁[ ▁0 ▁] ▁, ▁right ▁= ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁; ▁long ▁ans ▁= ▁0 ▁; ▁while ▁( ▁left ▁<= ▁right ▁) ▁{ ▁long ▁mid ▁= ▁( ▁left ▁+ ▁right ▁) ▁/ ▁2 ▁; ▁double ▁temp ▁= ▁( ▁double ▁) ▁n ▁* ▁( ▁double ▁) ▁( ▁Math ▁. ▁log ▁( ▁( ▁double ▁) ▁( ▁mid ▁) ▁) ▁) ▁; ▁if ▁( ▁val ▁< ▁temp ▁) ▁{ ▁ans ▁= ▁mid ▁; ▁right ▁= ▁mid ▁- ▁1 ▁; ▁} ▁else ▁{ ▁left ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁long ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁2 ▁, ▁1 ▁, ▁10 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Min Value ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁print Other S ides ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁% ▁2 ▁!= ▁0 ▁) ▁{ ▁if ▁( ▁n ▁== ▁1 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁- ▁1" ▁) ▁; ▁else ▁{ ▁int ▁b ▁= ▁( ▁n ▁* ▁n ▁- ▁1 ▁) ▁/ ▁2 ▁; ▁int ▁c ▁= ▁( ▁n ▁* ▁n ▁+ ▁1 ▁) ▁/ ▁2 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁b ▁= ▁" ▁+ ▁b ▁+ ▁" ▁, ▁c ▁= ▁" ▁+ ▁c ▁) ▁; ▁} ▁} ▁else ▁{ ▁if ▁( ▁n ▁== ▁2 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁- ▁1" ▁) ▁; ▁else ▁{ ▁int ▁b ▁= ▁n ▁* ▁n ▁/ ▁4 ▁- ▁1 ▁; ▁int ▁c ▁= ▁n ▁* ▁n ▁/ ▁4 ▁+ ▁1 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁b ▁= ▁" ▁+ ▁b ▁+ ▁" ▁, ▁c ▁= ▁" ▁+ ▁c ▁) ▁; ▁} ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁= ▁3 ▁; ▁print Other S ides ▁( ▁a ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁public ▁class ▁Div ision ▁{ ▁static ▁int ▁fact ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁0 ▁) ▁return ▁1 ▁; ▁return ▁n ▁* ▁fact ▁( ▁n ▁- ▁1 ▁) ▁; ▁} ▁static ▁int ▁div ▁( ▁int ▁x ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁x ▁; ▁i ▁++ ▁) ▁if ▁( ▁x ▁% ▁i ▁== ▁0 ▁) ▁ans ▁+= ▁i ▁; ▁return ▁ans ▁; ▁} ▁static ▁int ▁sum Fact Div ▁( ▁int ▁n ▁) ▁{ ▁return ▁div ▁( ▁fact ▁( ▁n ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁4 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁sum Fact Div ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁ArrayList ▁< ▁Integer ▁> ▁all Pr imes ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁static ▁void ▁s ieve ▁( ▁int ▁n ▁) ▁{ ▁boolean ▁[ ▁] ▁prime ▁= ▁new ▁boolean ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁* ▁p ▁<= ▁n ▁; ▁p ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁p ▁] ▁== ▁false ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁p ▁* ▁2 ▁; ▁i ▁<= ▁n ▁; ▁i ▁+= ▁p ▁) ▁prime ▁[ ▁i ▁] ▁= ▁true ▁; ▁} ▁} ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁<= ▁n ▁; ▁p ▁++ ▁) ▁if ▁( ▁prime ▁[ ▁p ▁] ▁== ▁false ▁) ▁all Pr imes ▁. ▁add ▁( ▁p ▁) ▁; ▁} ▁static ▁int ▁factorial Div is ors ▁( ▁int ▁n ▁) ▁{ ▁int ▁result ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁all Pr imes ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁int ▁p ▁= ▁all Pr imes ▁. ▁get ▁( ▁i ▁) ▁; ▁int ▁exp ▁= ▁0 ▁; ▁while ▁( ▁p ▁<= ▁n ▁) ▁{ ▁exp ▁= ▁exp ▁+ ▁( ▁n ▁/ ▁p ▁) ▁; ▁p ▁= ▁p ▁* ▁all Pr imes ▁. ▁get ▁( ▁i ▁) ▁; ▁} ▁result ▁= ▁result ▁* ▁( ▁( ▁int ▁) ▁Math ▁. ▁pow ▁( ▁all Pr imes ▁. ▁get ▁( ▁i ▁) ▁, ▁exp ▁+ ▁1 ▁) ▁- ▁1 ▁) ▁/ ▁( ▁all Pr imes ▁. ▁get ▁( ▁i ▁) ▁- ▁1 ▁) ▁; ▁} ▁return ▁result ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁factorial Div is ors ▁( ▁4 ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁check P and ig ital ▁( ▁int ▁b ▁, ▁String ▁n ▁) ▁{ ▁if ▁( ▁n ▁. ▁length ▁( ▁) ▁< ▁b ▁) ▁return ▁false ▁; ▁boolean ▁hash ▁[ ▁] ▁= ▁new ▁boolean ▁[ ▁b ▁] ▁; ▁Arrays ▁. ▁fill ▁( ▁hash ▁, ▁false ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁n ▁. ▁charAt ▁( ▁i ▁) ▁>= ▁'0' ▁&& ▁n ▁. ▁charAt ▁( ▁i ▁) ▁<= ▁'9' ▁) ▁hash ▁[ ▁n ▁. ▁charAt ▁( ▁i ▁) ▁- ▁'0' ▁] ▁= ▁true ▁; ▁else ▁if ▁( ▁n ▁. ▁charAt ▁( ▁i ▁) ▁- ▁' ▁A ▁' ▁<= ▁b ▁- ▁11 ▁) ▁hash ▁[ ▁n ▁. ▁charAt ▁( ▁i ▁) ▁- ▁' ▁A ▁' ▁+ ▁10 ▁] ▁= ▁true ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁b ▁; ▁i ▁++ ▁) ▁if ▁( ▁hash ▁[ ▁i ▁] ▁== ▁false ▁) ▁return ▁false ▁; ▁return ▁true ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁b ▁= ▁13 ▁; ▁String ▁n ▁= ▁"12 98 4 50 376 ABC ▁" ▁; ▁if ▁( ▁check P and ig ital ▁( ▁b ▁, ▁n ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁numberOf 2 sin Range ▁( ▁int ▁n ▁) ▁{ ▁String ▁s ▁= ▁" ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁s ▁+= ▁String ▁. ▁valueOf ▁( ▁i ▁) ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'2' ▁) ▁{ ▁count ▁++ ▁; ▁} ▁} ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁30 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁numberOf 2 sin Range ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁power ▁( ▁int ▁num ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁0 ▁) ▁return ▁1 ▁; ▁else ▁if ▁( ▁n ▁% ▁2 ▁== ▁0 ▁) ▁return ▁power ▁( ▁num ▁, ▁n ▁/ ▁2 ▁) ▁* ▁power ▁( ▁num ▁, ▁n ▁/ ▁2 ▁) ▁; ▁else ▁return ▁num ▁* ▁power ▁( ▁num ▁, ▁n ▁/ ▁2 ▁) ▁* ▁power ▁( ▁num ▁, ▁n ▁/ ▁2 ▁) ▁; ▁} ▁static ▁int ▁check Recursive ▁( ▁int ▁x ▁, ▁int ▁n ▁, ▁int ▁curr _ num ▁, ▁int ▁curr _ sum ▁) ▁{ ▁int ▁results ▁= ▁0 ▁; ▁int ▁p ▁= ▁power ▁( ▁curr _ num ▁, ▁n ▁) ▁; ▁while ▁( ▁p ▁+ ▁curr _ sum ▁< ▁x ▁) ▁{ ▁results ▁+= ▁check Recursive ▁( ▁x ▁, ▁n ▁, ▁curr _ num ▁+ ▁1 ▁, ▁p ▁+ ▁curr _ sum ▁) ▁; ▁curr _ num ▁++ ▁; ▁p ▁= ▁power ▁( ▁curr _ num ▁, ▁n ▁) ▁; ▁} ▁if ▁( ▁p ▁+ ▁curr _ sum ▁== ▁x ▁) ▁results ▁++ ▁; ▁return ▁results ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁x ▁= ▁10 ▁, ▁n ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁check Recursive ▁( ▁x ▁, ▁n ▁, ▁1 ▁, ▁0 ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁gcd ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁if ▁( ▁a ▁== ▁0 ▁) ▁return ▁b ▁; ▁return ▁gcd ▁( ▁b ▁% ▁a ▁, ▁a ▁) ▁; ▁} ▁static ▁void ▁print Gener ators ▁( ▁int ▁n ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁"1 ▁" ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁gcd ▁( ▁i ▁, ▁n ▁) ▁== ▁1 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁i ▁+ ▁" ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁10 ▁; ▁print Gener ators ▁( ▁n ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁HashMap ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁int ▁sum Div is ors Of Div is ors ▁( ▁int ▁n ▁) ▁{ ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁mp ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁j ▁= ▁2 ▁; ▁j ▁<= ▁Math ▁. ▁sqrt ▁( ▁n ▁) ▁; ▁j ▁++ ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁while ▁( ▁n ▁% ▁j ▁== ▁0 ▁) ▁{ ▁n ▁/= ▁j ▁; ▁count ▁++ ▁; ▁} ▁if ▁( ▁count ▁!= ▁0 ▁) ▁mp ▁. ▁put ▁( ▁j ▁, ▁count ▁) ▁; ▁} ▁if ▁( ▁n ▁!= ▁1 ▁) ▁mp ▁. ▁put ▁( ▁n ▁, ▁1 ▁) ▁; ▁int ▁ans ▁= ▁1 ▁; ▁for ▁( ▁HashMap ▁. ▁Entry ▁< ▁Integer ▁, ▁Integer ▁> ▁entry ▁: ▁mp ▁. ▁entrySet ▁( ▁) ▁) ▁{ ▁int ▁pw ▁= ▁1 ▁; ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁entry ▁. ▁getValue ▁( ▁) ▁+ ▁1 ▁; ▁i ▁>= ▁1 ▁; ▁i ▁-- ▁) ▁{ ▁sum ▁+= ▁( ▁i ▁* ▁pw ▁) ▁; ▁pw ▁= ▁entry ▁. ▁getKey ▁( ▁) ▁; ▁} ▁ans ▁*= ▁sum ▁; ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁10 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁sum Div is ors Of Div is ors ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁find Sum ▁( ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁ans ▁+= ▁( ▁i ▁% ▁K ▁) ▁; ▁return ▁ans ▁; ▁} ▁static ▁public ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁10 ▁, ▁K ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Sum ▁( ▁N ▁, ▁K ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁z ▁= ▁0 ▁; ▁static ▁int ▁pow 1 ▁( ▁int ▁base 1 ▁, ▁int ▁exponent ▁, ▁int ▁modulus ▁) ▁{ ▁int ▁result ▁= ▁1 ▁; ▁base 1 ▁= ▁base 1 ▁% ▁modulus ▁; ▁while ▁( ▁exponent ▁> ▁0 ▁) ▁{ ▁if ▁( ▁exponent ▁% ▁2 ▁== ▁1 ▁) ▁result ▁= ▁( ▁result ▁* ▁base 1 ▁) ▁% ▁modulus ▁; ▁exponent ▁= ▁exponent ▁>> ▁1 ▁; ▁base 1 ▁= ▁( ▁base 1 ▁* ▁base 1 ▁) ▁% ▁modulus ▁; ▁} ▁return ▁result ▁; ▁} ▁static ▁int ▁gcd ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁if ▁( ▁b ▁== ▁0 ▁) ▁return ▁a ▁; ▁else ▁return ▁gcd ▁( ▁b ▁, ▁a ▁% ▁b ▁) ▁; ▁} ▁static ▁int ▁order ▁( ▁int ▁p ▁, ▁int ▁b ▁) ▁{ ▁if ▁( ▁gcd ▁( ▁p ▁, ▁b ▁) ▁!= ▁1 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁p ▁and ▁b ▁are ▁" ▁+ ▁" ▁not ▁co ▁- ▁prime ▁. ▁" ▁) ▁; ▁return ▁- ▁1 ▁; ▁} ▁int ▁k ▁= ▁3 ▁; ▁while ▁( ▁true ▁) ▁{ ▁if ▁( ▁pow 1 ▁( ▁b ▁, ▁k ▁, ▁p ▁) ▁== ▁1 ▁) ▁return ▁k ▁; ▁k ▁++ ▁; ▁} ▁} ▁static ▁int ▁convert x 2 e ▁( ▁int ▁x ▁) ▁{ ▁z ▁= ▁0 ▁; ▁while ▁( ▁x ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁x ▁/= ▁2 ▁; ▁z ▁++ ▁; ▁} ▁return ▁x ▁; ▁} ▁static ▁int ▁ST on elli ▁( ▁int ▁n ▁, ▁int ▁p ▁) ▁{ ▁if ▁( ▁gcd ▁( ▁n ▁, ▁p ▁) ▁!= ▁1 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁a ▁and ▁p ▁are ▁not ▁cop r ime ▁" ▁) ▁; ▁return ▁- ▁1 ▁; ▁} ▁if ▁( ▁pow 1 ▁( ▁n ▁, ▁( ▁p ▁- ▁1 ▁) ▁/ ▁2 ▁, ▁p ▁) ▁== ▁( ▁p ▁- ▁1 ▁) ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁no ▁sqrt ▁possible ▁" ▁) ▁; ▁return ▁- ▁1 ▁; ▁} ▁int ▁s ▁, ▁e ▁; ▁s ▁= ▁convert x 2 e ▁( ▁p ▁- ▁1 ▁) ▁; ▁e ▁= ▁z ▁; ▁int ▁q ▁; ▁for ▁( ▁q ▁= ▁2 ▁; ▁; ▁q ▁++ ▁) ▁{ ▁if ▁( ▁pow 1 ▁( ▁q ▁, ▁( ▁p ▁- ▁1 ▁) ▁/ ▁2 ▁, ▁p ▁) ▁== ▁( ▁p ▁- ▁1 ▁) ▁) ▁break ▁; ▁} ▁int ▁x ▁= ▁pow 1 ▁( ▁n ▁, ▁( ▁s ▁+ ▁1 ▁) ▁/ ▁2 ▁, ▁p ▁) ▁; ▁int ▁b ▁= ▁pow 1 ▁( ▁n ▁, ▁s ▁, ▁p ▁) ▁; ▁int ▁g ▁= ▁pow 1 ▁( ▁q ▁, ▁s ▁, ▁p ▁) ▁; ▁int ▁r ▁= ▁e ▁; ▁while ▁( ▁true ▁) ▁{ ▁int ▁m ▁; ▁for ▁( ▁m ▁= ▁0 ▁; ▁m ▁< ▁r ▁; ▁m ▁++ ▁) ▁{ ▁if ▁( ▁order ▁( ▁p ▁, ▁b ▁) ▁== ▁- ▁1 ▁) ▁return ▁- ▁1 ▁; ▁if ▁( ▁order ▁( ▁p ▁, ▁b ▁) ▁== ▁Math ▁. ▁pow ▁( ▁2 ▁, ▁m ▁) ▁) ▁break ▁; ▁} ▁if ▁( ▁m ▁== ▁0 ▁) ▁return ▁x ▁; ▁x ▁= ▁( ▁x ▁* ▁pow 1 ▁( ▁g ▁, ▁( ▁int ▁) ▁Math ▁. ▁pow ▁( ▁2 ▁, ▁r ▁- ▁m ▁- ▁1 ▁) ▁, ▁p ▁) ▁) ▁% ▁p ▁; ▁g ▁= ▁pow 1 ▁( ▁g ▁, ▁( ▁int ▁) ▁Math ▁. ▁pow ▁( ▁2 ▁, ▁r ▁- ▁m ▁) ▁, ▁p ▁) ▁; ▁b ▁= ▁( ▁b ▁* ▁g ▁) ▁% ▁p ▁; ▁if ▁( ▁b ▁== ▁1 ▁) ▁return ▁x ▁; ▁r ▁= ▁m ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁2 ▁; ▁int ▁p ▁= ▁11 3 ▁; ▁int ▁x ▁= ▁ST on elli ▁( ▁n ▁, ▁p ▁) ▁; ▁if ▁( ▁x ▁== ▁- ▁1 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Mod ular ▁square ▁" ▁+ ▁" root ▁is ▁not ▁exist NEW _ LINE "); ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Mod ular ▁square ▁root ▁of ▁" ▁+ ▁n ▁+ ▁" ▁and ▁" ▁+ ▁p ▁+ ▁" ▁is ▁" ▁+ ▁x ▁+ ▁" NEW _ LINE "); ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁static ▁java ▁. ▁lang ▁. ▁Math ▁. ▁* ▁; ▁class ▁Quad ratic ▁{ ▁static ▁void ▁find Roots ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁int ▁c ▁) ▁{ ▁if ▁( ▁a ▁== ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Invalid ▁" ▁) ▁; ▁return ▁; ▁} ▁int ▁d ▁= ▁b ▁* ▁b ▁- ▁4 ▁* ▁a ▁* ▁c ▁; ▁double ▁sqrt _ val ▁= ▁sqrt ▁( ▁abs ▁( ▁d ▁) ▁) ▁; ▁if ▁( ▁d ▁> ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" Roots ▁are ▁real ▁and ▁different ▁NEW _ LINE "); ▁System ▁. ▁out ▁. ▁println ▁( ▁( ▁double ▁) ▁( ▁- ▁b ▁+ ▁sqrt _ val ▁) ▁/ ▁( ▁2 ▁* ▁a ▁) ▁+ ▁" NEW _ LINE " ▁+ ▁( ▁double ▁) ▁( ▁- ▁b ▁- ▁sqrt _ val ▁) ▁/ ▁( ▁2 ▁* ▁a ▁) ▁) ▁; ▁} ▁else ▁if ▁( ▁d ▁== ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" Roots ▁are ▁real ▁and ▁same ▁NEW _ LINE "); ▁System ▁. ▁out ▁. ▁println ▁( ▁- ▁( ▁double ▁) ▁b ▁/ ▁( ▁2 ▁* ▁a ▁) ▁+ ▁" NEW _ LINE " ▁+ ▁- ▁( ▁double ▁) ▁b ▁/ ▁( ▁2 ▁* ▁a ▁) ▁) ▁; ▁} ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" Roots ▁are ▁complex ▁NEW _ LINE "); ▁System ▁. ▁out ▁. ▁println ▁( ▁- ▁( ▁double ▁) ▁b ▁/ ▁( ▁2 ▁* ▁a ▁) ▁+ ▁" ▁+ ▁i ▁" ▁+ ▁sqrt _ val ▁+ ▁" NEW _ LINE " ▁+ ▁- ▁( ▁double ▁) ▁b ▁/ ▁( ▁2 ▁* ▁a ▁) ▁+ ▁" ▁- ▁i ▁" ▁+ ▁sqrt _ val ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁a ▁= ▁1 ▁, ▁b ▁= ▁- ▁7 ▁, ▁c ▁= ▁12 ▁; ▁find Roots ▁( ▁a ▁, ▁b ▁, ▁c ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁Vector ▁; ▁class ▁Test ▁{ ▁static ▁void ▁print Div is ors ▁( ▁int ▁n ▁) ▁{ ▁Vector ▁< ▁Integer ▁> ▁v ▁= ▁new ▁Vector ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁Math ▁. ▁sqrt ▁( ▁n ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁{ ▁if ▁( ▁n ▁/ ▁i ▁== ▁i ▁) ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁% ▁d ▁" ▁, ▁i ▁) ▁; ▁else ▁{ ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁% ▁d ▁" ▁, ▁i ▁) ▁; ▁v ▁. ▁add ▁( ▁n ▁/ ▁i ▁) ▁; ▁} ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁v ▁. ▁size ▁( ▁) ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁% ▁d ▁" ▁, ▁v ▁. ▁get ▁( ▁i ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁The ▁div is ors ▁of ▁100 ▁are ▁: ▁" ▁) ▁; ▁print Div is ors ▁( ▁100 ▁) ▁; ▁} ▁}
▁class ▁Test ▁{ ▁static ▁void ▁print Div is ors ▁( ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁i ▁+ ▁" ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁The ▁div is ors ▁of ▁100 ▁are ▁: ▁" ▁) ▁; ▁print Div is ors ▁( ▁100 ▁) ▁; ▁; ▁} ▁}
▁class ▁Test ▁{ ▁static ▁void ▁print Div is ors ▁( ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁Math ▁. ▁sqrt ▁( ▁n ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁{ ▁if ▁( ▁n ▁/ ▁i ▁== ▁i ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁" ▁+ ▁i ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁i ▁+ ▁" ▁" ▁+ ▁n ▁/ ▁i ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁The ▁div is ors ▁of ▁100 ▁are ▁: ▁" ▁) ▁; ▁print Div is ors ▁( ▁100 ▁) ▁; ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁series Sum ▁( ▁int ▁calculated ▁, ▁int ▁current ▁, ▁int ▁N ▁) ▁{ ▁int ▁i ▁, ▁cur ▁= ▁1 ▁; ▁if ▁( ▁current ▁== ▁N ▁+ ▁1 ▁) ▁return ▁0 ▁; ▁for ▁( ▁i ▁= ▁calculated ▁; ▁i ▁< ▁calculated ▁+ ▁current ▁; ▁i ▁++ ▁) ▁cur ▁*= ▁i ▁; ▁return ▁cur ▁+ ▁series Sum ▁( ▁i ▁, ▁current ▁+ ▁1 ▁, ▁N ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁series Sum ▁( ▁1 ▁, ▁1 ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁n Cr Mod p DP ▁( ▁int ▁n ▁, ▁int ▁r ▁, ▁int ▁p ▁) ▁{ ▁int ▁[ ▁] ▁C ▁= ▁new ▁int ▁[ ▁r ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁Math ▁. ▁min ▁( ▁i ▁, ▁r ▁) ▁; ▁j ▁> ▁0 ▁; ▁j ▁-- ▁) ▁C ▁[ ▁j ▁] ▁= ▁( ▁C ▁[ ▁j ▁] ▁+ ▁C ▁[ ▁j ▁- ▁1 ▁] ▁) ▁% ▁p ▁; ▁} ▁return ▁C ▁[ ▁r ▁] ▁; ▁} ▁static ▁int ▁n Cr Mod p L uc as ▁( ▁int ▁n ▁, ▁int ▁r ▁, ▁int ▁p ▁) ▁{ ▁if ▁( ▁r ▁== ▁0 ▁) ▁return ▁1 ▁; ▁int ▁ni ▁= ▁n ▁% ▁p ▁; ▁int ▁ri ▁= ▁r ▁% ▁p ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁1000 ▁, ▁r ▁= ▁900 ▁, ▁p ▁= ▁13 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Value ▁of ▁n Cr ▁% ▁p ▁is ▁" ▁+ ▁n Cr Mod p L uc as ▁( ▁n ▁, ▁r ▁, ▁p ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁mod Inverse ▁( ▁int ▁a ▁, ▁int ▁m ▁) ▁{ ▁int ▁m 0 ▁= ▁m ▁; ▁int ▁y ▁= ▁0 ▁, ▁x ▁= ▁1 ▁; ▁if ▁( ▁m ▁== ▁1 ▁) ▁return ▁0 ▁; ▁while ▁( ▁a ▁> ▁1 ▁) ▁{ ▁int ▁q ▁= ▁a ▁/ ▁m ▁; ▁int ▁t ▁= ▁m ▁; ▁m ▁= ▁a ▁% ▁m ▁; ▁a ▁= ▁t ▁; ▁t ▁= ▁y ▁; ▁y ▁= ▁x ▁- ▁q ▁* ▁y ▁; ▁x ▁= ▁t ▁; ▁} ▁if ▁( ▁x ▁< ▁0 ▁) ▁x ▁+= ▁m 0 ▁; ▁return ▁x ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁a ▁= ▁3 ▁, ▁m ▁= ▁11 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Mod ular ▁multip lic ative ▁" ▁+ ▁" ▁inverse ▁is ▁" ▁+ ▁mod Inverse ▁( ▁a ▁, ▁m ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁gcd ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁if ▁( ▁a ▁== ▁0 ▁) ▁return ▁b ▁; ▁return ▁gcd ▁( ▁b ▁% ▁a ▁, ▁a ▁) ▁; ▁} ▁static ▁int ▁phi ▁( ▁int ▁n ▁) ▁{ ▁int ▁result ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁gcd ▁( ▁i ▁, ▁n ▁) ▁== ▁1 ▁) ▁result ▁++ ▁; ▁return ▁result ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁; ▁for ▁( ▁n ▁= ▁1 ▁; ▁n ▁<= ▁10 ▁; ▁n ▁++ ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁phi ▁( ▁" ▁+ ▁n ▁+ ▁" ▁) ▁= ▁" ▁+ ▁phi ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁Test ▁{ ▁static ▁void ▁print F ib onacci Numbers ▁( ▁int ▁n ▁) ▁{ ▁int ▁f 1 ▁= ▁0 ▁, ▁f 2 ▁= ▁1 ▁, ▁i ▁; ▁if ▁( ▁n ▁< ▁1 ▁) ▁return ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁f 1 ▁+ ▁" ▁" ▁) ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁f 2 ▁+ ▁" ▁" ▁) ▁; ▁int ▁next ▁= ▁f 1 ▁+ ▁f 2 ▁; ▁f 1 ▁= ▁f 2 ▁; ▁f 2 ▁= ▁next ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁print F ib onacci Numbers ▁( ▁7 ▁) ▁; ▁} ▁}
▁class ▁Test ▁{ ▁static ▁int ▁gcd ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁if ▁( ▁a ▁== ▁0 ▁) ▁return ▁b ▁; ▁return ▁gcd ▁( ▁b ▁% ▁a ▁, ▁a ▁) ▁; ▁} ▁static ▁int ▁l cm ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁return ▁( ▁a ▁/ ▁gcd ▁( ▁a ▁, ▁b ▁) ▁) ▁* ▁b ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁= ▁15 ▁, ▁b ▁= ▁20 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁L CM ▁of ▁" ▁+ ▁a ▁+ ▁" ▁and ▁" ▁+ ▁b ▁+ ▁" ▁is ▁" ▁+ ▁l cm ▁( ▁a ▁, ▁b ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁MAX ▁= ▁11 ▁; ▁static ▁boolean ▁is Multiple of 5 ▁( ▁int ▁n ▁) ▁{ ▁char ▁str ▁[ ▁] ▁= ▁new ▁char ▁[ ▁MAX ▁] ▁; ▁int ▁len ▁= ▁str ▁. ▁length ▁; ▁if ▁( ▁str ▁[ ▁len ▁- ▁1 ▁] ▁== ▁'5' ▁str ▁[ ▁len ▁- ▁1 ▁] ▁== ▁'0' ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁19 ▁; ▁if ▁( ▁is Multiple of 5 ▁( ▁n ▁) ▁== ▁true ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁n ▁+ ▁" ▁is ▁multiple ▁" ▁+ ▁" ▁of ▁5" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁n ▁+ ▁" ▁is ▁not ▁a ▁" ▁+ ▁" ▁multiple ▁of ▁5" ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁rev _ num ▁= ▁0 ▁; ▁static ▁int ▁base _ pos ▁= ▁1 ▁; ▁static ▁int ▁re vers Digits ▁( ▁int ▁num ▁) ▁{ ▁if ▁( ▁num ▁> ▁0 ▁) ▁{ ▁re vers Digits ▁( ▁num ▁/ ▁10 ▁) ▁; ▁rev _ num ▁+= ▁( ▁num ▁% ▁10 ▁) ▁* ▁base _ pos ▁; ▁base _ pos ▁*= ▁10 ▁; ▁} ▁return ▁rev _ num ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁num ▁= ▁456 2 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁re vers Digits ▁( ▁num ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁M ▁= ▁3 ▁; ▁static ▁int ▁N ▁= ▁3 ▁; ▁static ▁int ▁find X OR ▁( ▁int ▁X ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁while ▁( ▁X ▁!= ▁0 ▁) ▁{ ▁ans ▁^= ▁( ▁X ▁% ▁10 ▁) ▁; ▁X ▁/= ▁10 ▁; ▁} ▁return ▁ans ▁; ▁} ▁static ▁void ▁print X OR matrix ▁( ▁int ▁arr ▁[ ▁] ▁[ ▁] ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁M ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁} ▁} ▁static ▁void ▁convert X OR ▁( ▁int ▁arr ▁[ ▁] ▁[ ▁] ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁M ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁int ▁X ▁= ▁arr ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁int ▁temp ▁= ▁find X OR ▁( ▁X ▁) ▁; ▁arr ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁temp ▁; ▁} ▁} ▁print X OR matrix ▁( ▁arr ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁27 ▁, ▁17 3 ▁, ▁5 ▁} ▁, ▁{ ▁21 ▁, ▁6 ▁, ▁6 24 ▁} ▁, ▁{ ▁5 ▁, ▁32 1 ▁, ▁49 ▁} ▁} ▁; ▁convert X OR ▁( ▁arr ▁) ▁; ▁} ▁}
▁static ▁int ▁set Bit ▁( ▁int ▁num ▁, ▁int ▁i ▁) ▁{ ▁return ▁num ▁| ▁( ▁1 ▁<< ▁i ▁) ▁; ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁print OR Sum forEach Element ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁int ▁req _ sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁req _ sum ▁+= ▁( ▁arr ▁[ ▁i ▁] ▁arr ▁[ ▁j ▁] ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁req _ sum ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁print OR Sum forEach Element ▁( ▁arr ▁, ▁N ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁find L argest Number ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁arr ▁[ ▁i ▁] ▁&= ▁0 xFFFF ▁; ▁if ▁( ▁arr ▁[ ▁i ▁] ▁<= ▁n ▁) ▁{ ▁arr ▁[ ▁i ▁] ▁+= ▁0 x 10000 ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁> ▁0 ▁; ▁-- ▁i ▁) ▁{ ▁if ▁( ▁( ▁arr ▁[ ▁i ▁] ▁>> ▁16 ▁) ▁== ▁i ▁) ▁return ▁i ▁+ ▁1 ▁; ▁} ▁return ▁- ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁3 ▁, ▁2 ▁, ▁5 ▁, ▁5 ▁, ▁2 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁find L argest Number ▁( ▁arr ▁, ▁n ▁) ▁+ ▁" NEW _ LINE "); ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁Recursive Function ▁( ▁ArrayList ▁< ▁Integer ▁> ▁ref ▁, ▁int ▁bit ▁) ▁{ ▁if ▁( ▁ref ▁. ▁size ▁( ▁) ▁== ▁0 ▁bit ▁< ▁0 ▁) ▁return ▁0 ▁; ▁ArrayList ▁< ▁Integer ▁> ▁curr _ on ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁ArrayList ▁< ▁Integer ▁> ▁curr _ off ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁ref ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁( ▁ref ▁. ▁get ▁( ▁i ▁) ▁>> ▁bit ▁) ▁& ▁1 ▁) ▁== ▁0 ▁) ▁curr _ off ▁. ▁add ▁( ▁ref ▁. ▁get ▁( ▁i ▁) ▁) ▁; ▁else ▁curr _ on ▁. ▁add ▁( ▁ref ▁. ▁get ▁( ▁i ▁) ▁) ▁; ▁} ▁if ▁( ▁curr _ off ▁. ▁size ▁( ▁) ▁== ▁0 ▁) ▁return ▁Recursive Function ▁( ▁curr _ on ▁, ▁bit ▁- ▁1 ▁) ▁; ▁if ▁( ▁curr _ on ▁. ▁size ▁( ▁) ▁== ▁0 ▁) ▁return ▁Recursive Function ▁( ▁curr _ off ▁, ▁bit ▁- ▁1 ▁) ▁; ▁return ▁Math ▁. ▁min ▁( ▁Recursive Function ▁( ▁curr _ off ▁, ▁bit ▁- ▁1 ▁) ▁, ▁Recursive Function ▁( ▁curr _ on ▁, ▁bit ▁- ▁1 ▁) ▁) ▁+ ▁( ▁1 ▁<< ▁bit ▁) ▁; ▁} ▁static ▁void ▁Print Minimum ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁ArrayList ▁< ▁Integer ▁> ▁v ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁v ▁. ▁add ▁( ▁a ▁[ ▁i ▁] ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁Recursive Function ▁( ▁v ▁, ▁30 ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁2 ▁, ▁1 ▁} ▁; ▁int ▁size ▁= ▁arr ▁. ▁length ▁; ▁Print Minimum ▁( ▁arr ▁, ▁size ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁MAX ▁= ▁100000 5 ▁; ▁static ▁boolean ▁prime ▁[ ▁] ▁= ▁new ▁boolean ▁[ ▁MAX ▁] ▁; ▁static ▁void ▁S ieve Of E rat ost hen es ▁( ▁boolean ▁[ ▁] ▁prime ▁) ▁{ ▁prime ▁[ ▁1 ▁] ▁= ▁false ▁; ▁prime ▁[ ▁0 ▁] ▁= ▁false ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁* ▁p ▁< ▁MAX ▁; ▁p ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁p ▁] ▁== ▁true ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁p ▁* ▁2 ▁; ▁i ▁< ▁MAX ▁; ▁i ▁+= ▁p ▁) ▁prime ▁[ ▁i ▁] ▁= ▁false ▁; ▁} ▁} ▁} ▁static ▁void ▁prime _ xor ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁MAX ▁; ▁i ▁++ ▁) ▁prime ▁[ ▁i ▁] ▁= ▁true ▁; ▁S ieve Of E rat ost hen es ▁( ▁prime ▁) ▁; ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁) ▁{ ▁if ▁( ▁( ▁i ▁+ ▁1 ▁) ▁% ▁k ▁== ▁0 ▁) ▁{ ▁ans ▁^= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁} ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁ans ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁5 ▁, ▁7 ▁, ▁11 ▁, ▁8 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁int ▁K ▁= ▁2 ▁; ▁prime _ xor ▁( ▁arr ▁, ▁n ▁, ▁K ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁is Power Of Two ▁( ▁int ▁x ▁) ▁{ ▁if ▁( ▁x ▁== ▁0 ▁) ▁return ▁false ▁; ▁if ▁( ▁( ▁x ▁& ▁( ▁x ▁- ▁1 ▁) ▁) ▁== ▁0 ▁) ▁return ▁true ▁; ▁else ▁return ▁false ▁; ▁} ▁static ▁int ▁count Num ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁is Power Of Two ▁( ▁a ▁[ ▁i ▁] ▁) ▁|| ▁is Power Of Two ▁( ▁a ▁[ ▁i ▁] ▁+ ▁1 ▁) ▁) ▁count ▁++ ▁; ▁} ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁6 ▁, ▁9 ▁, ▁3 ▁, ▁1 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Num ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁xor Given Set Bits ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁Vector ▁< ▁Integer ▁> ▁v ▁= ▁new ▁Vector ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁Integer ▁. ▁bit Count ▁( ▁arr ▁[ ▁i ▁] ▁) ▁== ▁k ▁) ▁{ ▁v ▁. ▁add ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁} ▁int ▁result ▁= ▁v ▁. ▁get ▁( ▁0 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁v ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁result ▁= ▁result ▁^ ▁v ▁. ▁get ▁( ▁i ▁) ▁; ▁} ▁return ▁result ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁13 ▁, ▁1 ▁, ▁19 ▁, ▁7 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁int ▁k ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁xor Given Set Bits ▁( ▁arr ▁, ▁n ▁, ▁k ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁count Zeros ▁( ▁int ▁x ▁) ▁{ ▁int ▁y ▁; ▁int ▁n ▁= ▁32 ▁; ▁y ▁= ▁x ▁>> ▁16 ▁; ▁if ▁( ▁y ▁!= ▁0 ▁) ▁{ ▁n ▁= ▁n ▁- ▁16 ▁; ▁x ▁= ▁y ▁; ▁} ▁y ▁= ▁x ▁>> ▁8 ▁; ▁if ▁( ▁y ▁!= ▁0 ▁) ▁{ ▁n ▁= ▁n ▁- ▁8 ▁; ▁x ▁= ▁y ▁; ▁} ▁y ▁= ▁x ▁>> ▁4 ▁; ▁if ▁( ▁y ▁!= ▁0 ▁) ▁{ ▁n ▁= ▁n ▁- ▁4 ▁; ▁x ▁= ▁y ▁; ▁} ▁y ▁= ▁x ▁>> ▁2 ▁; ▁if ▁( ▁y ▁!= ▁0 ▁) ▁{ ▁n ▁= ▁n ▁- ▁2 ▁; ▁x ▁= ▁y ▁; ▁} ▁y ▁= ▁x ▁>> ▁1 ▁; ▁if ▁( ▁y ▁!= ▁0 ▁) ▁return ▁n ▁- ▁2 ▁; ▁return ▁n ▁- ▁x ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁x ▁= ▁101 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Zeros ▁( ▁x ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁find Even Pair ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁if ▁( ▁( ▁! ▁( ▁( ▁A ▁[ ▁i ▁] ▁& ▁1 ▁) ▁> ▁0 ▁) ▁) ▁) ▁count ▁++ ▁; ▁return ▁count ▁* ▁( ▁count ▁- ▁1 ▁) ▁/ ▁2 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁6 ▁, ▁2 ▁, ▁8 ▁} ▁; ▁int ▁N ▁= ▁A ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Even Pair ▁( ▁A ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁N ▁= ▁1000 ▁; ▁static ▁int ▁last Element ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁steps ▁= ▁1 ▁; ▁Vector ▁< ▁Integer ▁> ▁[ ▁] ▁v ▁= ▁new ▁Vector ▁[ ▁N ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁v ▁[ ▁i ▁] ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁if ▁( ▁n ▁== ▁1 ▁) ▁return ▁a ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁+= ▁2 ▁) ▁v ▁[ ▁steps ▁] ▁. ▁add ▁( ▁a ▁[ ▁i ▁] ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁; ▁while ▁( ▁v ▁[ ▁steps ▁] ▁. ▁size ▁( ▁) ▁> ▁1 ▁) ▁{ ▁steps ▁+= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁v ▁[ ▁steps ▁- ▁1 ▁] ▁. ▁size ▁( ▁) ▁; ▁i ▁+= ▁2 ▁) ▁{ ▁if ▁( ▁steps ▁% ▁2 ▁== ▁1 ▁) ▁v ▁[ ▁steps ▁] ▁. ▁add ▁( ▁v ▁[ ▁steps ▁- ▁1 ▁] ▁. ▁get ▁( ▁i ▁) ▁| ▁v ▁[ ▁steps ▁- ▁1 ▁] ▁. ▁get ▁( ▁i ▁+ ▁1 ▁) ▁) ▁; ▁v ▁[ ▁steps ▁] ▁. ▁add ▁( ▁v ▁[ ▁steps ▁- ▁1 ▁] ▁. ▁get ▁( ▁i ▁) ▁^ ▁v ▁[ ▁steps ▁- ▁1 ▁] ▁. ▁get ▁( ▁i ▁+ ▁1 ▁) ▁) ▁; ▁} ▁} ▁return ▁v ▁[ ▁steps ▁] ▁. ▁get ▁( ▁0 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁a ▁. ▁length ▁; ▁int ▁index ▁= ▁0 ▁; ▁int ▁value ▁= ▁2 ▁; ▁a ▁[ ▁0 ▁] ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁last Element ▁( ▁a ▁, ▁n ▁) ▁) ▁; ▁index ▁= ▁3 ▁; ▁value ▁= ▁5 ▁; ▁a ▁[ ▁index ▁] ▁= ▁value ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁last Element ▁( ▁a ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁public ▁class ▁G f G ▁{ ▁public ▁static ▁int ▁x n or ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁if ▁( ▁a ▁< ▁b ▁) ▁{ ▁int ▁t ▁= ▁a ▁; ▁a ▁= ▁b ▁; ▁b ▁= ▁t ▁; ▁} ▁if ▁( ▁a ▁== ▁0 ▁&& ▁b ▁== ▁0 ▁) ▁return ▁1 ▁; ▁int ▁a _ rem ▁= ▁0 ▁; ▁int ▁b _ rem ▁= ▁0 ▁; ▁int ▁count ▁= ▁0 ▁; ▁int ▁x n or num ▁= ▁0 ▁; ▁while ▁( ▁true ▁) ▁{ ▁a _ rem ▁= ▁a ▁& ▁1 ▁; ▁b _ rem ▁= ▁b ▁& ▁1 ▁; ▁if ▁( ▁a _ rem ▁== ▁b _ rem ▁) ▁x n or num ▁|= ▁( ▁1 ▁<< ▁count ▁) ▁; ▁count ▁++ ▁; ▁a ▁= ▁a ▁>> ▁1 ▁; ▁b ▁= ▁b ▁>> ▁1 ▁; ▁if ▁( ▁a ▁< ▁1 ▁) ▁break ▁; ▁} ▁return ▁x n or num ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁arg c ▁[ ▁] ▁) ▁{ ▁int ▁a ▁= ▁10 ▁, ▁b ▁= ▁50 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁x n or ▁( ▁a ▁, ▁b ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁public ▁class ▁G F G ▁{ ▁static ▁void ▁divide ▁( ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Rem ainder ▁= ▁" ▁+ ▁( ▁( ▁n ▁) ▁& ▁( ▁m ▁- ▁1 ▁) ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Qu ot ient ▁= ▁" ▁+ ▁( ▁n ▁>> ▁( ▁int ▁) ▁( ▁Math ▁. ▁log ▁( ▁m ▁) ▁/ ▁Math ▁. ▁log ▁( ▁2 ▁) ▁) ▁) ▁) ▁; ▁} ▁static ▁public ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁43 ▁, ▁m ▁= ▁8 ▁; ▁divide ▁( ▁n ▁, ▁m ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁public ▁class ▁G f G ▁{ ▁public ▁static ▁boolean ▁are All Bits Set ▁( ▁long ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁0 ▁) ▁return ▁false ▁; ▁if ▁( ▁( ▁( ▁n ▁+ ▁1 ▁) ▁& ▁n ▁) ▁== ▁0 ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁public ▁static ▁boolean ▁isOn es Com plement Of Other ▁( ▁long ▁a ▁, ▁long ▁b ▁) ▁{ ▁return ▁are All Bits Set ▁( ▁a ▁^ ▁b ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁arg c ▁[ ▁] ▁) ▁{ ▁long ▁a ▁= ▁10 ▁, ▁b ▁= ▁5 ▁; ▁if ▁( ▁isOn es Com plement Of Other ▁( ▁a ▁, ▁b ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁count Bits ▁( ▁int ▁number ▁) ▁{ ▁return ▁( ▁int ▁) ▁( ▁Math ▁. ▁log ▁( ▁number ▁) ▁/ ▁Math ▁. ▁log ▁( ▁2 ▁) ▁+ ▁1 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁num ▁= ▁65 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Bits ▁( ▁num ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁bit Extract ed ▁( ▁int ▁number ▁, ▁int ▁k ▁, ▁int ▁p ▁) ▁{ ▁return ▁( ▁( ▁( ▁1 ▁<< ▁k ▁) ▁- ▁1 ▁) ▁& ▁( ▁number ▁>> ▁( ▁p ▁- ▁1 ▁) ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁number ▁= ▁17 1 ▁, ▁k ▁= ▁5 ▁, ▁p ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁The ▁extracted ▁number ▁is ▁" ▁+ ▁bit Extract ed ▁( ▁number ▁, ▁k ▁, ▁p ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁multiply ▁( ▁int ▁F ▁[ ▁] ▁[ ▁] ▁, ▁int ▁M ▁[ ▁] ▁[ ▁] ▁) ▁{ ▁int ▁x ▁= ▁F ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁* ▁M ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁+ ▁F ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁* ▁M ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁; ▁int ▁y ▁= ▁F ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁* ▁M ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁+ ▁F ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁* ▁M ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁; ▁int ▁z ▁= ▁F ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁* ▁M ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁+ ▁F ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁* ▁M ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁; ▁int ▁w ▁= ▁F ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁* ▁M ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁+ ▁F ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁* ▁M ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁; ▁F ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁= ▁x ▁; ▁F ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁= ▁y ▁; ▁F ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁= ▁z ▁; ▁F ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁= ▁w ▁; ▁} ▁static ▁void ▁power ▁( ▁int ▁F ▁[ ▁] ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁0 ▁n ▁== ▁1 ▁) ▁{ ▁return ▁; ▁} ▁int ▁M ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁0 ▁} ▁} ▁; ▁power ▁( ▁F ▁, ▁n ▁/ ▁2 ▁) ▁; ▁multiply ▁( ▁F ▁, ▁F ▁) ▁; ▁if ▁( ▁n ▁% ▁2 ▁!= ▁0 ▁) ▁{ ▁multiply ▁( ▁F ▁, ▁M ▁) ▁; ▁} ▁} ▁static ▁int ▁count W ays ▁( ▁int ▁n ▁) ▁{ ▁int ▁F ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁0 ▁} ▁} ▁; ▁if ▁( ▁n ▁== ▁0 ▁) ▁{ ▁return ▁0 ▁; ▁} ▁power ▁( ▁F ▁, ▁n ▁) ▁; ▁return ▁F ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count W ays ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁count X OR ▁( ▁int ▁n ▁) ▁{ ▁int ▁count 0 ▁= ▁0 ▁, ▁count 1 ▁= ▁0 ▁; ▁while ▁( ▁n ▁!= ▁0 ▁) ▁{ ▁if ▁( ▁n ▁% ▁2 ▁== ▁0 ▁) ▁count 0 ▁++ ▁; ▁else ▁count 1 ▁++ ▁; ▁n ▁/= ▁2 ▁; ▁} ▁return ▁( ▁count 0 ▁^ ▁count 1 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁31 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count X OR ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁int ▁count Values ▁( ▁int ▁n ▁) ▁{ ▁int ▁count V ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁( ▁n ▁+ ▁i ▁) ▁== ▁( ▁n ▁^ ▁i ▁) ▁) ▁count V ▁++ ▁; ▁return ▁count V ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁12 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Values ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁multiply By S even By E ight ▁( ▁int ▁n ▁) ▁{ ▁return ▁( ▁n ▁- ▁( ▁n ▁>> ▁3 ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁9 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁multiply By S even By E ight ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁public ▁static ▁void ▁print Long est Pal indrome ▁( ▁String ▁S ▁, ▁int ▁N ▁) ▁{ ▁int ▁pal Length ▁[ ▁] ▁= ▁new ▁int ▁[ ▁N ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁int ▁maxlength ▁= ▁1 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁i ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁S ▁. ▁charAt ▁( ▁j ▁) ▁== ▁S ▁. ▁charAt ▁( ▁i ▁) ▁) ▁{ ▁if ▁( ▁isP al indrome ▁( ▁S ▁, ▁j ▁, ▁i ▁) ▁) ▁{ ▁maxlength ▁= ▁i ▁- ▁j ▁+ ▁1 ▁; ▁break ▁; ▁} ▁} ▁} ▁for ▁( ▁int ▁j ▁= ▁N ▁- ▁1 ▁; ▁j ▁> ▁i ▁; ▁j ▁-- ▁) ▁{ ▁if ▁( ▁S ▁. ▁charAt ▁( ▁j ▁) ▁== ▁S ▁. ▁charAt ▁( ▁i ▁) ▁) ▁{ ▁if ▁( ▁isP al indrome ▁( ▁S ▁, ▁i ▁, ▁j ▁) ▁) ▁{ ▁maxlength ▁= ▁Math ▁. ▁max ▁( ▁j ▁- ▁i ▁+ ▁1 ▁, ▁maxlength ▁) ▁; ▁break ▁; ▁} ▁} ▁} ▁pal Length ▁[ ▁i ▁] ▁= ▁maxlength ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁pal Length ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁boolean ▁isP al indrome ▁( ▁String ▁S ▁, ▁int ▁i ▁, ▁int ▁j ▁) ▁{ ▁while ▁( ▁i ▁< ▁j ▁) ▁{ ▁if ▁( ▁S ▁. ▁charAt ▁( ▁i ▁) ▁!= ▁S ▁. ▁charAt ▁( ▁j ▁) ▁) ▁return ▁false ▁; ▁i ▁++ ▁; ▁j ▁-- ▁; ▁} ▁return ▁true ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁S ▁= ▁" ▁b ab aba ▁" ▁; ▁int ▁N ▁= ▁S ▁. ▁length ▁( ▁) ▁; ▁print Long est Pal indrome ▁( ▁S ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁check Sorted ▁( ▁int ▁n ▁, ▁int ▁arr ▁[ ▁] ▁) ▁{ ▁int ▁[ ▁] ▁b ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁b ▁[ ▁i ▁] ▁= ▁arr ▁[ ▁i ▁] ▁; ▁Arrays ▁. ▁sort ▁( ▁b ▁, ▁0 ▁, ▁n ▁) ▁; ▁int ▁ct ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁arr ▁[ ▁i ▁] ▁!= ▁b ▁[ ▁i ▁] ▁) ▁ct ▁++ ▁; ▁if ▁( ▁ct ▁== ▁0 ▁ct ▁== ▁2 ▁) ▁return ▁true ▁; ▁else ▁return ▁false ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁5 ▁, ▁3 ▁, ▁4 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁if ▁( ▁check Sorted ▁( ▁n ▁, ▁arr ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁min Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁) ▁{ ▁int ▁j ▁= ▁i ▁; ▁while ▁( ▁j ▁< ▁n ▁&& ▁arr ▁[ ▁j ▁] ▁<= ▁arr ▁[ ▁j ▁- ▁1 ▁] ▁) ▁{ ▁arr ▁[ ▁j ▁] ▁= ▁arr ▁[ ▁j ▁] ▁+ ▁1 ▁; ▁j ▁++ ▁; ▁} ▁} ▁sum ▁= ▁sum ▁+ ▁arr ▁[ ▁i ▁] ▁; ▁} ▁return ▁sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁2 ▁, ▁3 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁min Sum ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁min Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁arr ▁[ ▁0 ▁] ▁, ▁prev ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁<= ▁prev ▁) ▁{ ▁prev ▁= ▁prev ▁+ ▁1 ▁; ▁sum ▁= ▁sum ▁+ ▁prev ▁; ▁} ▁else ▁{ ▁sum ▁= ▁sum ▁+ ▁arr ▁[ ▁i ▁] ▁; ▁prev ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁} ▁return ▁sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁2 ▁, ▁3 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁min Sum ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁HashMap ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁valid Perm utations ▁( ▁String ▁str ▁) ▁{ ▁HashMap ▁< ▁Character ▁, ▁Integer ▁> ▁m ▁= ▁new ▁HashMap ▁< ▁Character ▁, ▁Integer ▁> ▁( ▁) ▁; ▁int ▁count ▁= ▁str ▁. ▁length ▁( ▁) ▁, ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁str ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁m ▁. ▁put ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁, ▁m ▁. ▁getOr Default ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁, ▁0 ▁) ▁+ ▁1 ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁str ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁ans ▁+= ▁count ▁- ▁m ▁. ▁get ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁) ▁; ▁m ▁. ▁put ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁, ▁m ▁. ▁get ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁) ▁- ▁1 ▁) ▁; ▁count ▁-- ▁; ▁} ▁return ▁ans ▁+ ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁" ▁sst t ▁" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁valid Perm utations ▁( ▁str ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁if Possible ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁copy ▁[ ▁] ▁= ▁Arrays ▁. ▁copyOf ▁( ▁arr ▁, ▁arr ▁. ▁length ▁) ▁; ▁Arrays ▁. ▁sort ▁( ▁copy ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁! ▁( ▁arr ▁[ ▁i ▁] ▁== ▁copy ▁[ ▁i ▁] ▁) ▁&& ▁! ▁( ▁arr ▁[ ▁n ▁- ▁1 ▁- ▁i ▁] ▁== ▁copy ▁[ ▁i ▁] ▁) ▁) ▁return ▁false ▁; ▁} ▁return ▁true ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁7 ▁, ▁6 ▁, ▁4 ▁, ▁5 ▁, ▁3 ▁, ▁2 ▁, ▁8 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁if ▁( ▁if Possible ▁( ▁arr ▁, ▁n ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁M ▁= ▁20 ▁; ▁static ▁int ▁dp ▁[ ▁] ▁[ ▁] ▁[ ▁] ▁[ ▁] ▁= ▁new ▁int ▁[ ▁M ▁] ▁[ ▁16 5 ▁] ▁[ ▁M ▁] ▁[ ▁2 ▁] ▁; ▁static ▁int ▁n ▁, ▁m ▁; ▁static ▁int ▁count ▁( ▁int ▁pos ▁, ▁int ▁sum ▁, ▁int ▁rem ▁, ▁int ▁tight ▁, ▁int ▁non z ▁, ▁Vector ▁< ▁Integer ▁> ▁num ▁) ▁{ ▁if ▁( ▁pos ▁== ▁num ▁. ▁size ▁( ▁) ▁) ▁{ ▁if ▁( ▁rem ▁== ▁0 ▁&& ▁sum ▁== ▁n ▁) ▁return ▁1 ▁; ▁return ▁0 ▁; ▁} ▁if ▁( ▁dp ▁[ ▁pos ▁] ▁[ ▁sum ▁] ▁[ ▁rem ▁] ▁[ ▁tight ▁] ▁!= ▁- ▁1 ▁) ▁return ▁dp ▁[ ▁pos ▁] ▁[ ▁sum ▁] ▁[ ▁rem ▁] ▁[ ▁tight ▁] ▁; ▁int ▁ans ▁= ▁0 ▁; ▁int ▁limit ▁= ▁( ▁tight ▁!= ▁0 ▁? ▁9 ▁: ▁num ▁. ▁get ▁( ▁pos ▁) ▁) ▁; ▁for ▁( ▁int ▁d ▁= ▁0 ▁; ▁d ▁<= ▁limit ▁; ▁d ▁++ ▁) ▁{ ▁if ▁( ▁d ▁== ▁0 ▁&& ▁non z ▁!= ▁0 ▁) ▁continue ▁; ▁int ▁curr Sum ▁= ▁sum ▁+ ▁d ▁; ▁int ▁curr Rem ▁= ▁( ▁rem ▁* ▁10 ▁+ ▁d ▁) ▁% ▁m ▁; ▁int ▁curr F ▁= ▁( ▁tight ▁!= ▁0 ▁|| ▁( ▁d ▁< ▁num ▁. ▁get ▁( ▁pos ▁) ▁) ▁) ▁? ▁1 ▁: ▁0 ▁; ▁ans ▁+= ▁count ▁( ▁pos ▁+ ▁1 ▁, ▁curr Sum ▁, ▁curr Rem ▁, ▁curr F ▁, ▁( ▁non z ▁!= ▁0 ▁d ▁!= ▁0 ▁) ▁? ▁1 ▁: ▁0 ▁, ▁num ▁) ▁; ▁} ▁return ▁dp ▁[ ▁pos ▁] ▁[ ▁sum ▁] ▁[ ▁rem ▁] ▁[ ▁tight ▁] ▁= ▁ans ▁; ▁} ▁static ▁int ▁solve ▁( ▁int ▁x ▁) ▁{ ▁Vector ▁< ▁Integer ▁> ▁num ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁while ▁( ▁x ▁!= ▁0 ▁) ▁{ ▁num ▁. ▁add ▁( ▁x ▁% ▁10 ▁) ▁; ▁x ▁/= ▁10 ▁; ▁} ▁Collections ▁. ▁reverse ▁( ▁num ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁M ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁16 5 ▁; ▁j ▁++ ▁) ▁for ▁( ▁int ▁k ▁= ▁0 ▁; ▁k ▁< ▁M ▁; ▁k ▁++ ▁) ▁for ▁( ▁int ▁l ▁= ▁0 ▁; ▁l ▁< ▁2 ▁; ▁l ▁++ ▁) ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁[ ▁k ▁] ▁[ ▁l ▁] ▁= ▁- ▁1 ▁; ▁return ▁count ▁( ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁num ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁L ▁= ▁1 ▁, ▁R ▁= ▁100 ▁; ▁n ▁= ▁8 ▁; ▁m ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁solve ▁( ▁R ▁) ▁- ▁solve ▁( ▁L ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁maximum Sum Sub array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁min _ prefix _ sum ▁= ▁0 ▁; ▁int ▁res ▁= ▁Integer ▁. ▁MIN _ VALUE ▁; ▁int ▁prefix _ sum ▁[ ▁] ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁prefix _ sum ▁[ ▁0 ▁] ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁prefix _ sum ▁[ ▁i ▁] ▁= ▁prefix _ sum ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁arr ▁[ ▁i ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁res ▁= ▁Math ▁. ▁max ▁( ▁res ▁, ▁prefix _ sum ▁[ ▁i ▁] ▁- ▁min _ prefix _ sum ▁) ▁; ▁min _ prefix _ sum ▁= ▁Math ▁. ▁min ▁( ▁min _ prefix _ sum ▁, ▁prefix _ sum ▁[ ▁i ▁] ▁) ▁; ▁} ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr 1 ▁[ ▁] ▁= ▁{ ▁- ▁2 ▁, ▁- ▁3 ▁, ▁4 ▁, ▁- ▁1 ▁, ▁- ▁2 ▁, ▁1 ▁, ▁5 ▁, ▁- ▁3 ▁} ▁; ▁int ▁n 1 ▁= ▁arr 1 ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁maximum Sum Sub array ▁( ▁arr 1 ▁, ▁n 1 ▁) ▁) ▁; ▁int ▁arr 2 ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁- ▁8 ▁, ▁9 ▁, ▁- ▁4 ▁, ▁1 ▁, ▁- ▁8 ▁, ▁- ▁1 ▁, ▁6 ▁} ▁; ▁int ▁n 2 ▁= ▁arr 2 ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁maximum Sum Sub array ▁( ▁arr 2 ▁, ▁n 2 ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁count Paths ▁( ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁int ▁dp ▁[ ▁] ▁[ ▁] ▁= ▁new ▁int ▁[ ▁n ▁+ ▁1 ▁] ▁[ ▁m ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁dp ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁m ▁; ▁i ▁++ ▁) ▁dp ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁<= ▁m ▁; ▁j ▁++ ▁) ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁+ ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁; ▁return ▁dp ▁[ ▁n ▁] ▁[ ▁m ▁] ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁3 ▁, ▁m ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Number ▁of ▁Paths ▁" ▁+ ▁count Paths ▁( ▁n ▁, ▁m ▁) ▁) ▁; ▁} ▁}
▁public ▁static ▁int ▁[ ▁] ▁dp ▁= ▁new ▁int ▁[ ▁MAX N ▁] ▁; ▁static ▁int ▁solve ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁< ▁0 ▁) ▁return ▁0 ▁; ▁if ▁( ▁n ▁== ▁0 ▁) ▁return ▁1 ▁; ▁if ▁( ▁dp ▁[ ▁n ▁] ▁!= ▁- ▁1 ▁) ▁return ▁dp ▁[ ▁n ▁] ▁; ▁return ▁dp ▁[ ▁n ▁] ▁= ▁solve ▁( ▁n ▁- ▁1 ▁) ▁+ ▁solve ▁( ▁n ▁- ▁3 ▁) ▁+ ▁solve ▁( ▁n ▁- ▁5 ▁) ▁; ▁}
▁class ▁G F G ▁{ ▁static ▁String ▁print Short est Super Seq ▁( ▁String ▁X ▁, ▁String ▁Y ▁) ▁{ ▁int ▁m ▁= ▁X ▁. ▁length ▁( ▁) ▁; ▁int ▁n ▁= ▁Y ▁. ▁length ▁( ▁) ▁; ▁int ▁dp ▁[ ▁] ▁[ ▁] ▁= ▁new ▁int ▁[ ▁m ▁+ ▁1 ▁] ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁m ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁<= ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁i ▁== ▁0 ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁j ▁; ▁} ▁else ▁if ▁( ▁j ▁== ▁0 ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁i ▁; ▁} ▁else ▁if ▁( ▁X ▁. ▁charAt ▁( ▁i ▁- ▁1 ▁) ▁== ▁Y ▁. ▁charAt ▁( ▁j ▁- ▁1 ▁) ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁1 ▁+ ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁- ▁1 ▁] ▁; ▁} ▁else ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁1 ▁+ ▁Math ▁. ▁min ▁( ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁, ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁) ▁; ▁} ▁} ▁} ▁String ▁str ▁= ▁" ▁" ▁; ▁int ▁i ▁= ▁m ▁, ▁j ▁= ▁n ▁; ▁while ▁( ▁i ▁> ▁0 ▁&& ▁j ▁> ▁0 ▁) ▁{ ▁if ▁( ▁X ▁. ▁charAt ▁( ▁i ▁- ▁1 ▁) ▁== ▁Y ▁. ▁charAt ▁( ▁j ▁- ▁1 ▁) ▁) ▁{ ▁str ▁+= ▁( ▁X ▁. ▁charAt ▁( ▁i ▁- ▁1 ▁) ▁) ▁; ▁i ▁-- ▁; ▁j ▁-- ▁; ▁} ▁else ▁if ▁( ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁> ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁) ▁{ ▁str ▁+= ▁( ▁Y ▁. ▁charAt ▁( ▁j ▁- ▁1 ▁) ▁) ▁; ▁j ▁-- ▁; ▁} ▁else ▁{ ▁str ▁+= ▁( ▁X ▁. ▁charAt ▁( ▁i ▁- ▁1 ▁) ▁) ▁; ▁i ▁-- ▁; ▁} ▁} ▁while ▁( ▁i ▁> ▁0 ▁) ▁{ ▁str ▁+= ▁( ▁X ▁. ▁charAt ▁( ▁i ▁- ▁1 ▁) ▁) ▁; ▁i ▁-- ▁; ▁} ▁while ▁( ▁j ▁> ▁0 ▁) ▁{ ▁str ▁+= ▁( ▁Y ▁. ▁charAt ▁( ▁j ▁- ▁1 ▁) ▁) ▁; ▁j ▁-- ▁; ▁} ▁str ▁= ▁reverse ▁( ▁str ▁) ▁; ▁return ▁str ▁; ▁} ▁static ▁String ▁reverse ▁( ▁String ▁input ▁) ▁{ ▁char ▁[ ▁] ▁tem par ray ▁= ▁input ▁. ▁toCharArray ▁( ▁) ▁; ▁int ▁left ▁, ▁right ▁= ▁0 ▁; ▁right ▁= ▁tem par ray ▁. ▁length ▁- ▁1 ▁; ▁for ▁( ▁left ▁= ▁0 ▁; ▁left ▁< ▁right ▁; ▁left ▁++ ▁, ▁right ▁-- ▁) ▁{ ▁char ▁temp ▁= ▁tem par ray ▁[ ▁left ▁] ▁; ▁tem par ray ▁[ ▁left ▁] ▁= ▁tem par ray ▁[ ▁right ▁] ▁; ▁tem par ray ▁[ ▁right ▁] ▁= ▁temp ▁; ▁} ▁return ▁String ▁. ▁valueOf ▁( ▁tem par ray ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁X ▁= ▁" ▁A GG TAB ▁" ▁; ▁String ▁Y ▁= ▁" ▁G XT X AY B ▁" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁print Short est Super Seq ▁( ▁X ▁, ▁Y ▁) ▁) ▁; ▁} ▁}
▁class ▁Matrix Chain Multip lication ▁{ ▁static ▁int ▁Matrix Chain Order ▁( ▁int ▁p ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁m ▁[ ▁] ▁[ ▁] ▁= ▁new ▁int ▁[ ▁n ▁] ▁[ ▁n ▁] ▁; ▁int ▁i ▁, ▁j ▁, ▁k ▁, ▁L ▁, ▁q ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁m ▁[ ▁i ▁] ▁[ ▁i ▁] ▁= ▁0 ▁; ▁for ▁( ▁L ▁= ▁2 ▁; ▁L ▁< ▁n ▁; ▁L ▁++ ▁) ▁{ ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁- ▁L ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁j ▁= ▁i ▁+ ▁L ▁- ▁1 ▁; ▁if ▁( ▁j ▁== ▁n ▁) ▁continue ▁; ▁m ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁for ▁( ▁k ▁= ▁i ▁; ▁k ▁<= ▁j ▁- ▁1 ▁; ▁k ▁++ ▁) ▁{ ▁q ▁= ▁m ▁[ ▁i ▁] ▁[ ▁k ▁] ▁+ ▁m ▁[ ▁k ▁+ ▁1 ▁] ▁[ ▁j ▁] ▁+ ▁p ▁[ ▁i ▁- ▁1 ▁] ▁* ▁p ▁[ ▁k ▁] ▁* ▁p ▁[ ▁j ▁] ▁; ▁if ▁( ▁q ▁< ▁m ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁m ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁q ▁; ▁} ▁} ▁} ▁return ▁m ▁[ ▁1 ▁] ▁[ ▁n ▁- ▁1 ▁] ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁new ▁int ▁[ ▁] ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁size ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Minimum ▁number ▁of ▁multiplication s ▁is ▁" ▁+ ▁Matrix Chain Order ▁( ▁arr ▁, ▁size ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁count ▁( ▁int ▁S ▁[ ▁] ▁, ▁int ▁m ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁0 ▁) ▁return ▁1 ▁; ▁if ▁( ▁n ▁< ▁0 ▁) ▁return ▁0 ▁; ▁if ▁( ▁m ▁<= ▁0 ▁&& ▁n ▁>= ▁1 ▁) ▁return ▁0 ▁; ▁return ▁count ▁( ▁S ▁, ▁m ▁- ▁1 ▁, ▁n ▁) ▁+ ▁count ▁( ▁S ▁, ▁m ▁, ▁n ▁- ▁S ▁[ ▁m ▁- ▁1 ▁] ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁; ▁int ▁m ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count ▁( ▁arr ▁, ▁m ▁, ▁4 ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁Solution ▁{ ▁static ▁int ▁find Sub string Count ▁( ▁String ▁str ▁) ▁{ ▁int ▁result ▁= ▁0 ▁; ▁int ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁+ ▁1 ▁== ▁str ▁. ▁charAt ▁( ▁i ▁+ ▁1 ▁) ▁) ▁{ ▁result ▁++ ▁; ▁while ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁+ ▁1 ▁== ▁str ▁. ▁charAt ▁( ▁i ▁+ ▁1 ▁) ▁) ▁{ ▁i ▁++ ▁; ▁} ▁} ▁} ▁return ▁result ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁String ▁str ▁= ▁" ▁alphabet ▁" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Sub string Count ▁( ▁str ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁round ▁( ▁int ▁n ▁) ▁{ ▁int ▁a ▁= ▁( ▁n ▁/ ▁10 ▁) ▁* ▁10 ▁; ▁int ▁b ▁= ▁a ▁+ ▁10 ▁; ▁return ▁( ▁n ▁- ▁a ▁> ▁b ▁- ▁n ▁) ▁? ▁b ▁: ▁a ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁47 22 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁round ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁boolean ▁is V ow el ▁( ▁char ▁c ▁) ▁{ ▁return ▁( ▁c ▁== ▁' ▁a ▁' ▁c ▁== ▁' ▁e ▁' ▁c ▁== ▁' ▁i ▁' ▁c ▁== ▁' ▁o ▁' ▁c ▁== ▁' ▁u ▁' ▁) ▁; ▁} ▁static ▁String ▁encrypt String ▁( ▁String ▁s ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁count V ow els ▁= ▁0 ▁; ▁int ▁count Con son ants ▁= ▁0 ▁; ▁String ▁ans ▁= ▁" ▁" ▁; ▁for ▁( ▁int ▁l ▁= ▁0 ▁; ▁l ▁<= ▁n ▁- ▁k ▁; ▁l ▁++ ▁) ▁{ ▁count V ow els ▁= ▁0 ▁; ▁count Con son ants ▁= ▁0 ▁; ▁for ▁( ▁int ▁r ▁= ▁l ▁; ▁r ▁<= ▁l ▁+ ▁k ▁- ▁1 ▁; ▁r ▁++ ▁) ▁{ ▁if ▁( ▁is V ow el ▁( ▁s ▁. ▁charAt ▁( ▁r ▁) ▁) ▁== ▁true ▁) ▁{ ▁count V ow els ▁++ ▁; ▁} ▁else ▁{ ▁count Con son ants ▁++ ▁; ▁} ▁} ▁ans ▁+= ▁String ▁. ▁valueOf ▁( ▁count V ow els ▁* ▁count Con son ants ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁static ▁public ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁s ▁= ▁" ▁hello ▁" ▁; ▁int ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁int ▁k ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁encrypt String ▁( ▁s ▁, ▁n ▁, ▁k ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁ham ming Dist ▁( ▁String ▁str 1 ▁, ▁String ▁str 2 ▁) ▁{ ▁int ▁i ▁= ▁0 ▁, ▁count ▁= ▁0 ▁; ▁while ▁( ▁i ▁< ▁str 1 ▁. ▁length ▁( ▁) ▁) ▁{ ▁if ▁( ▁str 1 ▁. ▁charAt ▁( ▁i ▁) ▁!= ▁str 2 ▁. ▁charAt ▁( ▁i ▁) ▁) ▁count ▁++ ▁; ▁i ▁++ ▁; ▁} ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str 1 ▁= ▁" ▁g eek sp ractice ▁" ▁; ▁String ▁str 2 ▁= ▁" ▁n er d sp ract ise ▁" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁ham ming Dist ▁( ▁str 1 ▁, ▁str 2 ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁solution ▁{ ▁static ▁float ▁surface Area ▁( ▁float ▁a ▁, ▁float ▁b ▁, ▁float ▁h ▁) ▁{ ▁return ▁5 ▁* ▁a ▁* ▁b ▁+ ▁5 ▁* ▁b ▁* ▁h ▁; ▁} ▁static ▁float ▁volume ▁( ▁float ▁b ▁, ▁float ▁h ▁) ▁{ ▁return ▁( ▁5 ▁* ▁b ▁* ▁h ▁) ▁/ ▁2 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁arr ▁[ ▁] ▁) ▁{ ▁float ▁a ▁= ▁5 ▁; ▁float ▁b ▁= ▁3 ▁; ▁float ▁h ▁= ▁7 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁surface ▁area ▁= ▁" ▁+ ▁surface Area ▁( ▁a ▁, ▁b ▁, ▁h ▁) ▁+ ▁" ▁, ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁volume ▁= ▁" ▁+ ▁volume ▁( ▁b ▁, ▁h ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁form Quad ru pl ets ▁( ▁Integer ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁, ▁pairs ▁= ▁0 ▁; ▁pairs ▁= ▁n ▁/ ▁4 ▁; ▁Arrays ▁. ▁sort ▁( ▁arr ▁, ▁Collections ▁. ▁reverse Order ▁( ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁pairs ▁; ▁i ▁+= ▁3 ▁) ▁{ ▁ans ▁+= ▁arr ▁[ ▁i ▁+ ▁2 ▁] ▁; ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Integer ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁1 ▁, ▁7 ▁, ▁5 ▁, ▁5 ▁, ▁4 ▁, ▁1 ▁, ▁1 ▁, ▁3 ▁, ▁3 ▁, ▁2 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁form Quad ru pl ets ▁( ▁arr ▁, ▁n ▁) ▁+ ▁" NEW _ LINE "); ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁Count ▁( ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁if ▁( ▁K ▁== ▁0 ▁) ▁return ▁0 ▁; ▁int ▁res ▁= ▁0 ▁; ▁int ▁low ▁= ▁1 ▁, ▁high ▁= ▁N ▁; ▁while ▁( ▁low ▁<= ▁high ▁) ▁{ ▁int ▁mid ▁= ▁( ▁low ▁+ ▁high ▁) ▁/ ▁2 ▁; ▁int ▁sum ▁= ▁( ▁mid ▁* ▁mid ▁+ ▁mid ▁) ▁/ ▁2 ▁; ▁if ▁( ▁sum ▁<= ▁K ▁) ▁{ ▁res ▁= ▁Math ▁. ▁max ▁( ▁res ▁, ▁mid ▁) ▁; ▁low ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁else ▁{ ▁high ▁= ▁mid ▁- ▁1 ▁; ▁} ▁} ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁6 ▁, ▁K ▁= ▁14 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁Count ▁( ▁N ▁, ▁K ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁max Items ▁( ▁int ▁n ▁, ▁int ▁m ▁, ▁int ▁a ▁[ ▁] ▁, ▁int ▁b ▁[ ▁] ▁, ▁int ▁K ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁int ▁A ▁[ ▁] ▁= ▁new ▁int ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁int ▁B ▁[ ▁] ▁= ▁new ▁int ▁[ ▁m ▁+ ▁1 ▁] ▁; ▁A ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁B ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁A ▁[ ▁i ▁] ▁= ▁a ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁A ▁[ ▁i ▁- ▁1 ▁] ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁m ▁; ▁i ▁++ ▁) ▁{ ▁B ▁[ ▁i ▁] ▁= ▁b ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁B ▁[ ▁i ▁- ▁1 ▁] ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁A ▁[ ▁i ▁] ▁> ▁K ▁) ▁break ▁; ▁int ▁rem ▁= ▁K ▁- ▁A ▁[ ▁i ▁] ▁; ▁int ▁j ▁= ▁0 ▁; ▁int ▁lo ▁= ▁0 ▁, ▁hi ▁= ▁m ▁; ▁while ▁( ▁lo ▁<= ▁hi ▁) ▁{ ▁int ▁mid ▁= ▁( ▁lo ▁+ ▁hi ▁) ▁/ ▁2 ▁; ▁if ▁( ▁B ▁[ ▁mid ▁] ▁<= ▁rem ▁) ▁{ ▁j ▁= ▁mid ▁; ▁lo ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁else ▁{ ▁hi ▁= ▁mid ▁- ▁1 ▁; ▁} ▁} ▁count ▁= ▁Math ▁. ▁max ▁( ▁j ▁+ ▁i ▁, ▁count ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁count ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁4 ▁, ▁m ▁= ▁5 ▁, ▁K ▁= ▁7 ▁; ▁int ▁A ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁4 ▁, ▁7 ▁, ▁3 ▁} ▁; ▁int ▁B ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁9 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁max Items ▁( ▁n ▁, ▁m ▁, ▁A ▁, ▁B ▁, ▁K ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁is Prime ▁( ▁int ▁N ▁) ▁{ ▁if ▁( ▁N ▁== ▁1 ▁) ▁return ▁false ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁* ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁N ▁% ▁i ▁== ▁0 ▁) ▁return ▁false ▁; ▁} ▁return ▁true ▁; ▁} ▁static ▁int ▁find Co Prime ▁( ▁int ▁L ▁, ▁int ▁R ▁) ▁{ ▁int ▁co Prime ▁; ▁for ▁( ▁int ▁i ▁= ▁R ▁+ ▁1 ▁; ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁is Prime ▁( ▁i ▁) ▁) ▁{ ▁co Prime ▁= ▁i ▁; ▁break ▁; ▁} ▁} ▁return ▁co Prime ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁L ▁= ▁16 ▁, ▁R ▁= ▁17 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Co Prime ▁( ▁L ▁, ▁R ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁void ▁K th Character ▁( ▁String ▁S ▁, ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁char ▁str array ▁[ ▁] ▁= ▁S ▁. ▁toCharArray ▁( ▁) ▁; ▁Arrays ▁. ▁sort ▁( ▁str array ▁) ▁; ▁char ▁ch ▁= ▁str array ▁[ ▁K ▁- ▁1 ▁] ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁char ▁c ▁: ▁str array ▁) ▁{ ▁if ▁( ▁c ▁== ▁ch ▁) ▁count ▁++ ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁count ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁S ▁= ▁" ▁g eek s forge ek s ▁" ▁; ▁int ▁N ▁= ▁S ▁. ▁length ▁( ▁) ▁; ▁int ▁K ▁= ▁3 ▁; ▁K th Character ▁( ▁S ▁, ▁N ▁, ▁K ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁find Sub string ▁( ▁String ▁S ▁) ▁{ ▁String ▁T ▁= ▁" ▁" ▁; ▁String ▁ans ▁= ▁" ▁" ▁; ▁int ▁l ▁= ▁0 ▁; ▁T ▁+= ▁S ▁. ▁charAt ▁( ▁0 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁S ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁Math ▁. ▁abs ▁( ▁S ▁. ▁charAt ▁( ▁i ▁) ▁- ▁S ▁. ▁charAt ▁( ▁i ▁- ▁1 ▁) ▁) ▁== ▁1 ▁) ▁{ ▁l ▁= ▁T ▁. ▁length ▁( ▁) ▁; ▁if ▁( ▁l ▁> ▁ans ▁. ▁length ▁( ▁) ▁) ▁{ ▁ans ▁= ▁T ▁; ▁} ▁T ▁= ▁" ▁" ▁; ▁T ▁+= ▁S ▁. ▁charAt ▁( ▁i ▁) ▁; ▁} ▁else ▁{ ▁T ▁+= ▁S ▁. ▁charAt ▁( ▁i ▁) ▁; ▁} ▁} ▁l ▁= ▁T ▁. ▁length ▁( ▁) ▁; ▁if ▁( ▁l ▁> ▁ans ▁. ▁length ▁( ▁) ▁) ▁{ ▁ans ▁= ▁T ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁ans ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁S ▁= ▁" ▁a ab d ml ▁" ▁; ▁find Sub string ▁( ▁S ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁no Of Valid K bers ▁( ▁int ▁K ▁, ▁int ▁arr ▁[ ▁] ▁) ▁{ ▁HashSet ▁< ▁Integer ▁> ▁set ▁= ▁new ▁HashSet ▁< ▁> ▁( ▁) ▁; ▁while ▁( ▁K ▁!= ▁0 ▁) ▁{ ▁set ▁. ▁add ▁( ▁K ▁% ▁10 ▁) ▁; ▁K ▁= ▁K ▁/ ▁10 ▁; ▁} ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁arr ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁int ▁no ▁= ▁arr ▁[ ▁i ▁] ▁; ▁boolean ▁flag ▁= ▁true ▁; ▁while ▁( ▁no ▁!= ▁0 ▁) ▁{ ▁int ▁digit ▁= ▁no ▁% ▁10 ▁; ▁if ▁( ▁! ▁set ▁. ▁contains ▁( ▁digit ▁) ▁) ▁{ ▁flag ▁= ▁false ▁; ▁break ▁; ▁} ▁no ▁= ▁no ▁/ ▁10 ▁; ▁} ▁if ▁( ▁flag ▁== ▁true ▁) ▁{ ▁count ▁++ ▁; ▁} ▁} ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁K ▁= ▁12 ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁12 ▁, ▁12 22 ▁, ▁13 ▁, ▁2 ▁} ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁no Of Valid K bers ▁( ▁K ▁, ▁arr ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁final ▁int ▁MAX ▁= ▁10000 ▁; ▁static ▁Vector ▁< ▁Integer ▁> ▁[ ▁] ▁div is ors ▁= ▁new ▁Vector ▁[ ▁MAX ▁+ ▁1 ▁] ▁; ▁static ▁void ▁compute Div is ors ▁( ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁MAX ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁<= ▁MAX ▁; ▁j ▁+= ▁i ▁) ▁{ ▁div is ors ▁[ ▁j ▁] ▁. ▁add ▁( ▁i ▁) ▁; ▁} ▁} ▁} ▁static ▁int ▁getC lo sest ▁( ▁int ▁val 1 ▁, ▁int ▁val 2 ▁, ▁int ▁target ▁) ▁{ ▁if ▁( ▁target ▁- ▁val 1 ▁>= ▁val 2 ▁- ▁target ▁) ▁return ▁val 2 ▁; ▁else ▁return ▁val 1 ▁; ▁} ▁static ▁int ▁find Clo sest ▁( ▁Vector ▁< ▁Integer ▁> ▁array ▁, ▁int ▁n ▁, ▁int ▁target ▁) ▁{ ▁Integer ▁[ ▁] ▁arr ▁= ▁array ▁. ▁toArray ▁( ▁new ▁Integer ▁[ ▁array ▁. ▁size ▁( ▁) ▁] ▁) ▁; ▁if ▁( ▁target ▁<= ▁arr ▁[ ▁0 ▁] ▁) ▁return ▁arr ▁[ ▁0 ▁] ▁; ▁if ▁( ▁target ▁>= ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁) ▁return ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁; ▁int ▁i ▁= ▁0 ▁, ▁j ▁= ▁n ▁, ▁mid ▁= ▁0 ▁; ▁while ▁( ▁i ▁< ▁j ▁) ▁{ ▁mid ▁= ▁( ▁i ▁+ ▁j ▁) ▁/ ▁2 ▁; ▁if ▁( ▁arr ▁[ ▁mid ▁] ▁== ▁target ▁) ▁return ▁arr ▁[ ▁mid ▁] ▁; ▁if ▁( ▁target ▁< ▁arr ▁[ ▁mid ▁] ▁) ▁{ ▁if ▁( ▁mid ▁> ▁0 ▁&& ▁target ▁> ▁arr ▁[ ▁mid ▁- ▁1 ▁] ▁) ▁return ▁getC lo sest ▁( ▁arr ▁[ ▁mid ▁- ▁1 ▁] ▁, ▁arr ▁[ ▁mid ▁] ▁, ▁target ▁) ▁; ▁j ▁= ▁mid ▁; ▁} ▁else ▁{ ▁if ▁( ▁mid ▁< ▁n ▁- ▁1 ▁&& ▁target ▁< ▁arr ▁[ ▁mid ▁+ ▁1 ▁] ▁) ▁return ▁getC lo sest ▁( ▁arr ▁[ ▁mid ▁] ▁, ▁arr ▁[ ▁mid ▁+ ▁1 ▁] ▁, ▁target ▁) ▁; ▁i ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁} ▁return ▁arr ▁[ ▁mid ▁] ▁; ▁} ▁static ▁void ▁print Clo sest ▁( ▁int ▁N ▁, ▁int ▁X ▁) ▁{ ▁compute Div is ors ▁( ▁) ▁; ▁int ▁ans ▁= ▁find Clo sest ▁( ▁div is ors ▁[ ▁N ▁] ▁, ▁div is ors ▁[ ▁N ▁] ▁. ▁size ▁( ▁) ▁, ▁X ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁ans ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁16 ▁, ▁X ▁= ▁5 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁div is ors ▁. ▁length ▁; ▁i ▁++ ▁) ▁div is ors ▁[ ▁i ▁] ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁print Clo sest ▁( ▁N ▁, ▁X ▁) ▁; ▁} ▁}
▁public ▁class ▁G F G ▁{ ▁static ▁int ▁count Div ▁( ▁int ▁[ ▁] ▁arr ▁) ▁{ ▁int ▁rem 0 ▁= ▁0 ▁; ▁int ▁rem 1 ▁= ▁0 ▁; ▁int ▁rem 2 ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁: ▁arr ▁) ▁{ ▁int ▁digit Sum ▁= ▁0 ▁; ▁digit Sum ▁+= ▁i ▁; ▁if ▁( ▁digit Sum ▁% ▁3 ▁== ▁0 ▁) ▁{ ▁rem 0 ▁+= ▁1 ▁; ▁} ▁else ▁if ▁( ▁digit Sum ▁% ▁3 ▁== ▁1 ▁) ▁{ ▁rem 1 ▁+= ▁1 ▁; ▁} ▁else ▁{ ▁rem 2 ▁+= ▁1 ▁; ▁} ▁} ▁return ▁( ▁rem 0 ▁/ ▁2 ▁+ ▁Math ▁. ▁min ▁( ▁rem 1 ▁, ▁rem 2 ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁5 ▁, ▁3 ▁, ▁2 ▁, ▁8 ▁, ▁7 ▁} ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Div ▁( ▁arr ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁N ▁= ▁10000 5 ▁; ▁static ▁void ▁S ieve Of E rat ost hen es ▁( ▁boolean ▁prime ▁[ ▁] ▁, ▁int ▁p _ size ▁) ▁{ ▁prime ▁[ ▁0 ▁] ▁= ▁false ▁; ▁prime ▁[ ▁1 ▁] ▁= ▁false ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁* ▁p ▁<= ▁p _ size ▁; ▁p ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁p ▁] ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁p ▁* ▁2 ▁; ▁i ▁<= ▁p _ size ▁; ▁i ▁+= ▁p ▁) ▁prime ▁[ ▁i ▁] ▁= ▁false ▁; ▁} ▁} ▁} ▁static ▁int ▁digit Product ▁( ▁int ▁number ▁) ▁{ ▁int ▁res ▁= ▁1 ▁; ▁while ▁( ▁number ▁> ▁0 ▁) ▁{ ▁res ▁*= ▁( ▁number ▁% ▁10 ▁) ▁; ▁number ▁/= ▁10 ▁; ▁} ▁return ▁res ▁; ▁} ▁static ▁void ▁Dist inct Composite Digit Product ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁TreeSet ▁< ▁Integer ▁> ▁output ▁= ▁new ▁TreeSet ▁< ▁Integer ▁> ▁( ▁) ▁; ▁boolean ▁prime ▁[ ▁] ▁= ▁new ▁boolean ▁[ ▁N ▁+ ▁1 ▁] ▁; ▁Arrays ▁. ▁fill ▁( ▁prime ▁, ▁true ▁) ▁; ▁S ieve Of E rat ost hen es ▁( ▁prime ▁, ▁N ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁ans ▁= ▁digit Product ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁if ▁( ▁ans ▁<= ▁1 ▁) ▁{ ▁continue ▁; ▁} ▁if ▁( ▁! ▁prime ▁[ ▁ans ▁] ▁) ▁{ ▁output ▁. ▁add ▁( ▁ans ▁) ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁output ▁. ▁size ▁( ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁13 ▁, ▁55 ▁, ▁7 ▁, ▁13 ▁, ▁11 ▁, ▁71 ▁, ▁2 33 ▁, ▁2 33 ▁, ▁144 ▁, ▁89 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁Dist inct Composite Digit Product ▁( ▁arr ▁, ▁n ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁ArrayList ▁< ▁Integer ▁> ▁simple S ieve ▁( ▁int ▁l mt ▁, ▁ArrayList ▁< ▁Integer ▁> ▁prime ▁) ▁{ ▁boolean ▁[ ▁] ▁S ieve ▁= ▁new ▁boolean ▁[ ▁l mt ▁+ ▁1 ▁] ▁; ▁Arrays ▁. ▁fill ▁( ▁S ieve ▁, ▁true ▁) ▁; ▁S ieve ▁[ ▁0 ▁] ▁= ▁S ieve ▁[ ▁1 ▁] ▁= ▁false ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁l mt ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁S ieve ▁[ ▁i ▁] ▁== ▁true ▁) ▁{ ▁prime ▁. ▁add ▁( ▁i ▁) ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁* ▁i ▁; ▁j ▁<= ▁l mt ▁; ▁j ▁+= ▁i ▁) ▁{ ▁S ieve ▁[ ▁j ▁] ▁= ▁false ▁; ▁} ▁} ▁} ▁return ▁prime ▁; ▁} ▁static ▁boolean ▁[ ▁] ▁Segment ed S ieve Fn ▁( ▁int ▁low ▁, ▁int ▁high ▁) ▁{ ▁int ▁l mt ▁= ▁( ▁int ▁) ▁( ▁Math ▁. ▁sqrt ▁( ▁high ▁) ▁) ▁+ ▁1 ▁; ▁ArrayList ▁< ▁Integer ▁> ▁prime ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁prime ▁= ▁simple S ieve ▁( ▁l mt ▁, ▁prime ▁) ▁; ▁int ▁n ▁= ▁high ▁- ▁low ▁+ ▁1 ▁; ▁boolean ▁[ ▁] ▁segment ed S ieve ▁= ▁new ▁boolean ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁Arrays ▁. ▁fill ▁( ▁segment ed S ieve ▁, ▁true ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁prime ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁int ▁low L im ▁= ▁( ▁int ▁) ▁( ▁low ▁/ ▁prime ▁. ▁get ▁( ▁i ▁) ▁) ▁* ▁prime ▁. ▁get ▁( ▁i ▁) ▁; ▁if ▁( ▁low L im ▁< ▁low ▁) ▁{ ▁low L im ▁+= ▁prime ▁. ▁get ▁( ▁i ▁) ▁; ▁} ▁for ▁( ▁int ▁j ▁= ▁low L im ▁; ▁j ▁<= ▁high ▁; ▁j ▁+= ▁prime ▁. ▁get ▁( ▁i ▁) ▁) ▁{ ▁if ▁( ▁j ▁!= ▁prime ▁. ▁get ▁( ▁i ▁) ▁) ▁{ ▁segment ed S ieve ▁[ ▁j ▁- ▁low ▁] ▁= ▁false ▁; ▁} ▁} ▁} ▁return ▁segment ed S ieve ▁; ▁} ▁static ▁int ▁count Pairs Wh ose Sum Prime L _ R ▁( ▁int ▁L ▁, ▁int ▁R ▁) ▁{ ▁boolean ▁[ ▁] ▁segment ed S ieve ▁= ▁Segment ed S ieve Fn ▁( ▁L ▁, ▁R ▁) ▁; ▁int ▁cnt Pairs ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁L ▁; ▁i ▁<= ▁R ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁segment ed S ieve ▁[ ▁i ▁- ▁L ▁] ▁) ▁{ ▁cnt Pairs ▁+= ▁i ▁/ ▁2 ▁; ▁} ▁} ▁return ▁cnt Pairs ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁L ▁= ▁1 ▁, ▁R ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Pairs Wh ose Sum Prime L _ R ▁( ▁L ▁, ▁R ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁count Sub se que ce ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁i ▁, ▁j ▁, ▁k ▁, ▁l ▁; ▁int ▁answer ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁for ▁( ▁k ▁= ▁j ▁+ ▁1 ▁; ▁k ▁< ▁n ▁; ▁k ▁++ ▁) ▁{ ▁for ▁( ▁l ▁= ▁k ▁+ ▁1 ▁; ▁l ▁< ▁n ▁; ▁l ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁j ▁] ▁== ▁a ▁[ ▁l ▁] ▁&& ▁a ▁[ ▁i ▁] ▁== ▁a ▁[ ▁k ▁] ▁) ▁{ ▁answer ▁++ ▁; ▁} ▁} ▁} ▁} ▁} ▁return ▁answer ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁a ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁2 ▁, ▁1 ▁, ▁3 ▁, ▁2 ▁} ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁count Sub se que ce ▁( ▁a ▁, ▁7 ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁final ▁int ▁MAX ▁= ▁10000 000 ▁; ▁static ▁boolean ▁[ ▁] ▁is Prime ▁= ▁new ▁boolean ▁[ ▁MAX ▁+ ▁1 ▁] ▁; ▁static ▁Vector ▁< ▁Integer ▁> ▁primes ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁static ▁void ▁S ieve Of E rat ost hen es ▁( ▁) ▁{ ▁Arrays ▁. ▁fill ▁( ▁is Prime ▁, ▁true ▁) ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁* ▁p ▁<= ▁MAX ▁; ▁p ▁++ ▁) ▁{ ▁if ▁( ▁is Prime ▁[ ▁p ▁] ▁== ▁true ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁p ▁* ▁p ▁; ▁i ▁<= ▁MAX ▁; ▁i ▁+= ▁p ▁) ▁is Prime ▁[ ▁i ▁] ▁= ▁false ▁; ▁} ▁} ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁<= ▁MAX ▁; ▁p ▁++ ▁) ▁if ▁( ▁is Prime ▁[ ▁p ▁] ▁) ▁primes ▁. ▁add ▁( ▁p ▁) ▁; ▁} ▁static ▁int ▁prime _ search ▁( ▁Vector ▁< ▁Integer ▁> ▁primes ▁, ▁int ▁diff ▁) ▁{ ▁int ▁low ▁= ▁0 ▁; ▁int ▁high ▁= ▁primes ▁. ▁size ▁( ▁) ▁- ▁1 ▁; ▁int ▁res ▁= ▁- ▁1 ▁; ▁while ▁( ▁low ▁<= ▁high ▁) ▁{ ▁int ▁mid ▁= ▁( ▁low ▁+ ▁high ▁) ▁/ ▁2 ▁; ▁if ▁( ▁primes ▁. ▁get ▁( ▁mid ▁) ▁== ▁diff ▁) ▁{ ▁return ▁primes ▁. ▁get ▁( ▁mid ▁) ▁; ▁} ▁else ▁if ▁( ▁primes ▁. ▁get ▁( ▁mid ▁) ▁< ▁diff ▁) ▁{ ▁low ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁else ▁{ ▁res ▁= ▁primes ▁. ▁get ▁( ▁mid ▁) ▁; ▁high ▁= ▁mid ▁- ▁1 ▁; ▁} ▁} ▁return ▁res ▁; ▁} ▁static ▁int ▁min Cost ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁S ieve Of E rat ost hen es ▁( ▁) ▁; ▁int ▁res ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁) ▁{ ▁int ▁diff ▁= ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁- ▁arr ▁[ ▁i ▁] ▁; ▁int ▁closest _ prime ▁= ▁prime _ search ▁( ▁primes ▁, ▁diff ▁) ▁; ▁res ▁+= ▁closest _ prime ▁; ▁arr ▁[ ▁i ▁] ▁+= ▁closest _ prime ▁; ▁} ▁} ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁1 ▁, ▁5 ▁, ▁4 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁min Cost ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁char ▁min Dist Char ▁( ▁char ▁[ ▁] ▁s ▁) ▁{ ▁int ▁n ▁= ▁s ▁. ▁length ▁; ▁int ▁[ ▁] ▁first ▁= ▁new ▁int ▁[ ▁26 ▁] ▁; ▁int ▁[ ▁] ▁last ▁= ▁new ▁int ▁[ ▁26 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁26 ▁; ▁i ▁++ ▁) ▁{ ▁first ▁[ ▁i ▁] ▁= ▁- ▁1 ▁; ▁last ▁[ ▁i ▁] ▁= ▁- ▁1 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁first ▁[ ▁s ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁] ▁== ▁- ▁1 ▁) ▁{ ▁first ▁[ ▁s ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁] ▁= ▁i ▁; ▁} ▁last ▁[ ▁s ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁] ▁= ▁i ▁; ▁} ▁int ▁min ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁char ▁ans ▁= ▁'1' ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁26 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁last ▁[ ▁i ▁] ▁== ▁first ▁[ ▁i ▁] ▁) ▁continue ▁; ▁if ▁( ▁min ▁> ▁last ▁[ ▁i ▁] ▁- ▁first ▁[ ▁i ▁] ▁) ▁{ ▁min ▁= ▁last ▁[ ▁i ▁] ▁- ▁first ▁[ ▁i ▁] ▁; ▁ans ▁= ▁( ▁char ▁) ▁( ▁i ▁+ ▁' ▁a ▁' ▁) ▁; ▁} ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁" ▁g eek s forge ek s ▁" ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁min Dist Char ▁( ▁str ▁. ▁toCharArray ▁( ▁) ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁public ▁class ▁Main ▁{ ▁public ▁static ▁void ▁unique Element ▁( ▁int ▁arr ▁[ ▁] ▁) ▁{ ▁Set ▁< ▁Integer ▁> ▁set ▁= ▁new ▁HashSet ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁arr ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁set ▁. ▁add ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁if ▁( ▁set ▁. ▁size ▁( ▁) ▁== ▁1 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁9 ▁, ▁9 ▁, ▁9 ▁, ▁9 ▁, ▁9 ▁, ▁9 ▁, ▁9 ▁} ▁; ▁unique Element ▁( ▁arr ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁@ ▁Suppress Warnings ▁( ▁" ▁unchecked ▁" ▁) ▁static ▁Vector ▁< ▁Integer ▁> ▁[ ▁] ▁adj ▁= ▁new ▁Vector ▁[ ▁10000 5 ▁] ▁; ▁static ▁int ▁[ ▁] ▁visited ▁= ▁new ▁int ▁[ ▁10000 5 ▁] ▁; ▁static ▁int ▁ans ▁= ▁0 ▁; ▁static ▁void ▁dfs ▁( ▁int ▁node ▁, ▁int ▁count ▁, ▁int ▁m ▁, ▁int ▁arr ▁[ ▁] ▁, ▁int ▁k ▁) ▁{ ▁visited ▁[ ▁node ▁] ▁= ▁1 ▁; ▁if ▁( ▁arr ▁[ ▁node ▁- ▁1 ▁] ▁== ▁k ▁) ▁{ ▁count ▁++ ▁; ▁} ▁else ▁{ ▁count ▁= ▁0 ▁; ▁} ▁if ▁( ▁count ▁> ▁m ▁) ▁{ ▁return ▁; ▁} ▁if ▁( ▁adj ▁[ ▁node ▁] ▁. ▁size ▁( ▁) ▁== ▁1 ▁&& ▁node ▁!= ▁1 ▁) ▁{ ▁ans ▁++ ▁; ▁} ▁for ▁( ▁int ▁x ▁: ▁adj ▁[ ▁node ▁] ▁) ▁{ ▁if ▁( ▁visited ▁[ ▁x ▁] ▁== ▁0 ▁) ▁{ ▁dfs ▁( ▁x ▁, ▁count ▁, ▁m ▁, ▁arr ▁, ▁k ▁) ▁; ▁} ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁1 ▁, ▁3 ▁, ▁2 ▁, ▁1 ▁, ▁2 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁7 ▁, ▁K ▁= ▁2 ▁, ▁M ▁= ▁2 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁adj ▁. ▁length ▁; ▁i ▁++ ▁) ▁adj ▁[ ▁i ▁] ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁adj ▁[ ▁1 ▁] ▁. ▁add ▁( ▁2 ▁) ▁; ▁adj ▁[ ▁2 ▁] ▁. ▁add ▁( ▁1 ▁) ▁; ▁adj ▁[ ▁1 ▁] ▁. ▁add ▁( ▁3 ▁) ▁; ▁adj ▁[ ▁3 ▁] ▁. ▁add ▁( ▁1 ▁) ▁; ▁adj ▁[ ▁2 ▁] ▁. ▁add ▁( ▁4 ▁) ▁; ▁adj ▁[ ▁4 ▁] ▁. ▁add ▁( ▁2 ▁) ▁; ▁adj ▁[ ▁2 ▁] ▁. ▁add ▁( ▁5 ▁) ▁; ▁adj ▁[ ▁5 ▁] ▁. ▁add ▁( ▁2 ▁) ▁; ▁adj ▁[ ▁3 ▁] ▁. ▁add ▁( ▁6 ▁) ▁; ▁adj ▁[ ▁6 ▁] ▁. ▁add ▁( ▁3 ▁) ▁; ▁adj ▁[ ▁3 ▁] ▁. ▁add ▁( ▁7 ▁) ▁; ▁adj ▁[ ▁7 ▁] ▁. ▁add ▁( ▁3 ▁) ▁; ▁int ▁counter ▁= ▁0 ▁; ▁dfs ▁( ▁1 ▁, ▁counter ▁, ▁M ▁, ▁arr ▁, ▁K ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁ans ▁+ ▁" NEW _ LINE "); ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁calc _ distance ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁B ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁distance _ tr avel ed _ A ▁= ▁0 ▁; ▁int ▁distance _ tr avel ed _ B ▁= ▁0 ▁; ▁int ▁answer ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁5 ▁; ▁i ▁++ ▁) ▁{ ▁distance _ tr avel ed _ A ▁+= ▁A ▁[ ▁i ▁] ▁; ▁distance _ tr avel ed _ B ▁+= ▁B ▁[ ▁i ▁] ▁; ▁if ▁( ▁( ▁distance _ tr avel ed _ A ▁== ▁distance _ tr avel ed _ B ▁) ▁&& ▁( ▁A ▁[ ▁i ▁] ▁== ▁B ▁[ ▁i ▁] ▁) ▁) ▁{ ▁answer ▁+= ▁A ▁[ ▁i ▁] ▁; ▁} ▁} ▁return ▁answer ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁2 ▁, ▁4 ▁} ▁; ▁int ▁B ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁1 ▁, ▁3 ▁, ▁1 ▁, ▁4 ▁} ▁; ▁int ▁N ▁= ▁A ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁calc _ distance ▁( ▁A ▁, ▁B ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁max Product ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁if ▁( ▁N ▁< ▁3 ▁) ▁{ ▁return ▁; ▁} ▁int ▁a ▁= ▁arr ▁[ ▁0 ▁] ▁, ▁b ▁= ▁arr ▁[ ▁1 ▁] ▁; ▁int ▁c ▁= ▁0 ▁, ▁d ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁N ▁- ▁1 ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁* ▁arr ▁[ ▁j ▁] ▁> ▁a ▁* ▁b ▁) ▁{ ▁c ▁= ▁a ▁; ▁d ▁= ▁b ▁; ▁a ▁= ▁arr ▁[ ▁i ▁] ▁; ▁b ▁= ▁arr ▁[ ▁j ▁] ▁; ▁} ▁if ▁( ▁arr ▁[ ▁i ▁] ▁* ▁arr ▁[ ▁j ▁] ▁< ▁a ▁* ▁b ▁&& ▁arr ▁[ ▁i ▁] ▁* ▁arr ▁[ ▁j ▁] ▁> ▁c ▁* ▁d ▁) ▁c ▁= ▁arr ▁[ ▁i ▁] ▁; ▁d ▁= ▁arr ▁[ ▁j ▁] ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁c ▁+ ▁" ▁" ▁+ ▁d ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁2 ▁, ▁67 ▁, ▁45 ▁, ▁160 ▁, ▁78 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁max Product ▁( ▁arr ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁find Max Value ▁( ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁int ▁packages ▁; ▁int ▁max i ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁K ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁N ▁% ▁i ▁== ▁0 ▁) ▁max i ▁= ▁Math ▁. ▁max ▁( ▁max i ▁, ▁i ▁) ▁; ▁} ▁packages ▁= ▁N ▁/ ▁max i ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁packages ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁8 ▁, ▁K ▁= ▁7 ▁; ▁find Max Value ▁( ▁N ▁, ▁K ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁make Groups ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁[ ▁] ▁v ▁= ▁new ▁int ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁v ▁[ ▁a ▁[ ▁i ▁] ▁] ▁++ ▁; ▁} ▁int ▁no _ of _ groups ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁no _ of _ groups ▁+= ▁v ▁[ ▁i ▁] ▁/ ▁i ▁; ▁v ▁[ ▁i ▁] ▁= ▁v ▁[ ▁i ▁] ▁% ▁i ▁; ▁} ▁int ▁i ▁= ▁1 ▁; ▁int ▁total ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁v ▁[ ▁i ▁] ▁!= ▁0 ▁) ▁{ ▁total ▁= ▁v ▁[ ▁i ▁] ▁; ▁break ▁; ▁} ▁} ▁i ▁++ ▁; ▁while ▁( ▁i ▁<= ▁n ▁) ▁{ ▁if ▁( ▁v ▁[ ▁i ▁] ▁!= ▁0 ▁) ▁{ ▁total ▁+= ▁v ▁[ ▁i ▁] ▁; ▁if ▁( ▁total ▁>= ▁i ▁) ▁{ ▁int ▁rem ▁= ▁total ▁- ▁i ▁; ▁no _ of _ groups ▁++ ▁; ▁total ▁= ▁rem ▁; ▁} ▁} ▁i ▁++ ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁no _ of _ groups ▁+ ▁" NEW _ LINE "); ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁1 ▁, ▁2 ▁, ▁2 ▁} ▁; ▁int ▁size ▁= ▁arr ▁. ▁length ▁; ▁make Groups ▁( ▁arr ▁, ▁size ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁final ▁int ▁N ▁= ▁4 ▁; ▁static ▁final ▁int ▁M ▁= ▁5 ▁; ▁static ▁void ▁pre Process ▁( ▁int ▁[ ▁] ▁[ ▁] ▁mat ▁, ▁int ▁[ ▁] ▁[ ▁] ▁aux ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁M ▁; ▁i ▁++ ▁) ▁aux ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁= ▁mat ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁M ▁; ▁j ▁++ ▁) ▁aux ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+ ▁aux ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁< ▁M ▁; ▁j ▁++ ▁) ▁aux ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+= ▁aux ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁; ▁} ▁static ▁int ▁sum Query ▁( ▁int ▁[ ▁] ▁[ ▁] ▁aux ▁, ▁int ▁t li ▁, ▁int ▁tl j ▁, ▁int ▁rb i ▁, ▁int ▁rb j ▁) ▁{ ▁int ▁res ▁= ▁aux ▁[ ▁rb i ▁] ▁[ ▁rb j ▁] ▁; ▁if ▁( ▁t li ▁> ▁0 ▁) ▁res ▁= ▁res ▁- ▁aux ▁[ ▁t li ▁- ▁1 ▁] ▁[ ▁rb j ▁] ▁; ▁if ▁( ▁tl j ▁> ▁0 ▁) ▁res ▁= ▁res ▁- ▁aux ▁[ ▁rb i ▁] ▁[ ▁tl j ▁- ▁1 ▁] ▁; ▁if ▁( ▁t li ▁> ▁0 ▁&& ▁tl j ▁> ▁0 ▁) ▁res ▁= ▁res ▁+ ▁aux ▁[ ▁t li ▁- ▁1 ▁] ▁[ ▁tl j ▁- ▁1 ▁] ▁; ▁return ▁res ▁; ▁} ▁static ▁boolean ▁check ▁( ▁int ▁mid ▁, ▁int ▁[ ▁] ▁[ ▁] ▁aux ▁, ▁int ▁K ▁) ▁{ ▁boolean ▁satisfies ▁= ▁true ▁; ▁for ▁( ▁int ▁x ▁= ▁0 ▁; ▁x ▁< ▁N ▁; ▁x ▁++ ▁) ▁{ ▁for ▁( ▁int ▁y ▁= ▁0 ▁; ▁y ▁< ▁M ▁; ▁y ▁++ ▁) ▁{ ▁if ▁( ▁x ▁+ ▁mid ▁- ▁1 ▁<= ▁N ▁- ▁1 ▁&& ▁y ▁+ ▁mid ▁- ▁1 ▁<= ▁M ▁- ▁1 ▁) ▁{ ▁if ▁( ▁sum Query ▁( ▁aux ▁, ▁x ▁, ▁y ▁, ▁x ▁+ ▁mid ▁- ▁1 ▁, ▁y ▁+ ▁mid ▁- ▁1 ▁) ▁> ▁K ▁) ▁satisfies ▁= ▁false ▁; ▁} ▁} ▁} ▁return ▁( ▁satisfies ▁== ▁true ▁) ▁; ▁} ▁static ▁int ▁maximum Square Size ▁( ▁int ▁[ ▁] ▁[ ▁] ▁mat ▁, ▁int ▁K ▁) ▁{ ▁int ▁[ ▁] ▁[ ▁] ▁aux ▁= ▁new ▁int ▁[ ▁N ▁] ▁[ ▁M ▁] ▁; ▁pre Process ▁( ▁mat ▁, ▁aux ▁) ▁; ▁int ▁low ▁= ▁1 ▁, ▁high ▁= ▁Math ▁. ▁min ▁( ▁N ▁, ▁M ▁) ▁; ▁int ▁mid ▁; ▁while ▁( ▁high ▁- ▁low ▁> ▁1 ▁) ▁{ ▁mid ▁= ▁( ▁low ▁+ ▁high ▁) ▁/ ▁2 ▁; ▁if ▁( ▁check ▁( ▁mid ▁, ▁aux ▁, ▁K ▁) ▁) ▁{ ▁low ▁= ▁mid ▁; ▁} ▁else ▁high ▁= ▁mid ▁; ▁} ▁if ▁( ▁check ▁( ▁high ▁, ▁aux ▁, ▁K ▁) ▁) ▁return ▁high ▁; ▁return ▁low ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁K ▁= ▁30 ▁; ▁int ▁[ ▁] ▁[ ▁] ▁mat ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁6 ▁} ▁, ▁{ ▁5 ▁, ▁3 ▁, ▁8 ▁, ▁1 ▁, ▁2 ▁} ▁, ▁{ ▁4 ▁, ▁6 ▁, ▁7 ▁, ▁5 ▁, ▁5 ▁} ▁, ▁{ ▁2 ▁, ▁4 ▁, ▁8 ▁, ▁9 ▁, ▁4 ▁} ▁} ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁maximum Square Size ▁( ▁mat ▁, ▁K ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁boolean ▁is alpha ▁( ▁int ▁input _ char ▁) ▁{ ▁if ▁( ▁( ▁input _ char ▁>= ▁65 ▁&& ▁input _ char ▁<= ▁90 ▁) ▁|| ▁( ▁input _ char ▁>= ▁97 ▁&& ▁input _ char ▁<= ▁12 2 ▁) ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁static ▁void ▁find Sub Array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁int ▁maxsize ▁= ▁- ▁1 ▁, ▁start index ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁is alpha ▁( ▁arr ▁[ ▁i ▁] ▁) ▁) ▁{ ▁arr ▁[ ▁i ▁] ▁= ▁0 ▁; ▁} ▁else ▁{ ▁arr ▁[ ▁i ▁] ▁= ▁1 ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁= ▁( ▁arr ▁[ ▁i ▁] ▁== ▁0 ▁) ▁? ▁- ▁1 ▁: ▁1 ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁j ▁] ▁== ▁0 ▁) ▁sum ▁+= ▁- ▁1 ▁; ▁else ▁sum ▁+= ▁1 ▁; ▁if ▁( ▁sum ▁== ▁0 ▁&& ▁maxsize ▁< ▁j ▁- ▁i ▁+ ▁1 ▁) ▁{ ▁maxsize ▁= ▁j ▁- ▁i ▁+ ▁1 ▁; ▁start index ▁= ▁i ▁; ▁} ▁} ▁} ▁if ▁( ▁maxsize ▁== ▁- ▁1 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁maxsize ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁start index ▁+ ▁" ▁" ▁+ ▁( ▁start index ▁+ ▁maxsize ▁- ▁1 ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁' ▁A ▁' ▁, ▁' ▁B ▁' ▁, ▁' ▁X ▁' ▁, ▁4 ▁, ▁6 ▁, ▁' ▁X ▁' ▁, ▁' ▁a ▁' ▁} ▁; ▁int ▁size ▁= ▁arr ▁. ▁length ▁; ▁find Sub Array ▁( ▁arr ▁, ▁size ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁n ▁= ▁3 ▁; ▁static ▁class ▁Pair ▁{ ▁int ▁first ▁, ▁second ▁; ▁Pair ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁first ▁= ▁a ▁; ▁second ▁= ▁b ▁; ▁} ▁} ▁static ▁int ▁min Steps ▁( ▁int ▁arr ▁[ ▁] ▁[ ▁] ▁) ▁{ ▁boolean ▁v ▁[ ▁] ▁[ ▁] ▁= ▁new ▁boolean ▁[ ▁n ▁] ▁[ ▁n ▁] ▁; ▁Queue ▁< ▁Pair ▁> ▁q ▁= ▁new ▁LinkedList ▁< ▁Pair ▁> ▁( ▁) ▁; ▁q ▁. ▁add ▁( ▁new ▁Pair ▁( ▁0 ▁, ▁0 ▁) ▁) ▁; ▁int ▁depth ▁= ▁0 ▁; ▁while ▁( ▁q ▁. ▁size ▁( ▁) ▁!= ▁0 ▁) ▁{ ▁int ▁x ▁= ▁q ▁. ▁size ▁( ▁) ▁; ▁while ▁( ▁x ▁-- ▁> ▁0 ▁) ▁{ ▁Pair ▁y ▁= ▁q ▁. ▁peek ▁( ▁) ▁; ▁int ▁i ▁= ▁y ▁. ▁first ▁, ▁j ▁= ▁y ▁. ▁second ▁; ▁q ▁. ▁remove ▁( ▁) ▁; ▁if ▁( ▁v ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁continue ▁; ▁if ▁( ▁i ▁== ▁n ▁- ▁1 ▁&& ▁j ▁== ▁n ▁- ▁1 ▁) ▁return ▁depth ▁; ▁v ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁true ▁; ▁if ▁( ▁i ▁+ ▁arr ▁[ ▁i ▁] ▁[ ▁j ▁] ▁< ▁n ▁) ▁q ▁. ▁add ▁( ▁new ▁Pair ▁( ▁i ▁+ ▁arr ▁[ ▁i ▁] ▁[ ▁j ▁] ▁, ▁j ▁) ▁) ▁; ▁if ▁( ▁j ▁+ ▁arr ▁[ ▁i ▁] ▁[ ▁j ▁] ▁< ▁n ▁) ▁q ▁. ▁add ▁( ▁new ▁Pair ▁( ▁i ▁, ▁j ▁+ ▁arr ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁) ▁; ▁} ▁depth ▁++ ▁; ▁} ▁return ▁- ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁1 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁1 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁1 ▁, ▁1 ▁} ▁} ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁min Steps ▁( ▁arr ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁check Distinct ▁( ▁int ▁x ▁) ▁{ ▁int ▁last ▁= ▁x ▁% ▁10 ▁; ▁while ▁( ▁x ▁> ▁0 ▁) ▁{ ▁if ▁( ▁x ▁% ▁10 ▁!= ▁last ▁) ▁return ▁false ▁; ▁x ▁= ▁x ▁/ ▁10 ▁; ▁} ▁return ▁true ▁; ▁} ▁static ▁int ▁find Count ▁( ▁int ▁L ▁, ▁int ▁R ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁L ▁; ▁i ▁<= ▁R ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁check Distinct ▁( ▁i ▁) ▁) ▁count ▁+= ▁1 ▁; ▁} ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁L ▁= ▁10 ▁, ▁R ▁= ▁50 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Count ▁( ▁L ▁, ▁R ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁A Q ES ▁{ ▁static ▁int ▁L ower Insertion Point ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁X ▁) ▁{ ▁if ▁( ▁X ▁< ▁arr ▁[ ▁0 ▁] ▁) ▁return ▁0 ▁; ▁else ▁if ▁( ▁X ▁> ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁) ▁return ▁n ▁; ▁int ▁lower P nt ▁= ▁0 ▁; ▁int ▁i ▁= ▁1 ▁; ▁while ▁( ▁i ▁< ▁n ▁&& ▁arr ▁[ ▁i ▁] ▁< ▁X ▁) ▁{ ▁lower P nt ▁= ▁i ▁; ▁i ▁= ▁i ▁* ▁2 ▁; ▁} ▁while ▁( ▁lower P nt ▁< ▁n ▁&& ▁arr ▁[ ▁lower P nt ▁] ▁< ▁X ▁) ▁lower P nt ▁++ ▁; ▁return ▁lower P nt ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁, ▁7 ▁, ▁9 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁int ▁X ▁= ▁4 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁L ower Insertion Point ▁( ▁arr ▁, ▁n ▁, ▁X ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁boolean ▁check ▁( ▁String ▁s ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁length ▁( ▁) ▁- ▁1 ▁; ▁i ▁++ ▁) ▁if ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁== ▁s ▁. ▁charAt ▁( ▁i ▁+ ▁1 ▁) ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁s ▁= ▁" ▁x z yy z ▁" ▁; ▁if ▁( ▁check ▁( ▁s ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁YES ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁NO ▁" ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁count An om al ies ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁res ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁j ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁if ▁( ▁i ▁!= ▁j ▁&& ▁Math ▁. ▁abs ▁( ▁arr ▁[ ▁i ▁] ▁- ▁arr ▁[ ▁j ▁] ▁) ▁<= ▁k ▁) ▁break ▁; ▁if ▁( ▁j ▁== ▁n ▁) ▁res ▁++ ▁; ▁} ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁7 ▁, ▁1 ▁, ▁8 ▁} ▁, ▁k ▁= ▁5 ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count An om al ies ▁( ▁arr ▁, ▁n ▁, ▁k ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁GO C 1 ▁{ ▁static ▁int ▁col Max Diff ▁( ▁int ▁mat ▁[ ▁] ▁[ ▁] ▁) ▁{ ▁int ▁max _ diff ▁= ▁Integer ▁. ▁MIN _ VALUE ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁int ▁max _ val ▁= ▁mat ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁, ▁min _ val ▁= ▁mat ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁; ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁max _ val ▁= ▁Math ▁. ▁max ▁( ▁max _ val ▁, ▁mat ▁[ ▁j ▁] ▁[ ▁i ▁] ▁) ▁; ▁min _ val ▁= ▁Math ▁. ▁min ▁( ▁min _ val ▁, ▁mat ▁[ ▁j ▁] ▁[ ▁i ▁] ▁) ▁; ▁} ▁max _ diff ▁= ▁Math ▁. ▁max ▁( ▁max _ diff ▁, ▁max _ val ▁- ▁min _ val ▁) ▁; ▁} ▁return ▁max _ diff ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁mat ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁, ▁{ ▁5 ▁, ▁3 ▁, ▁5 ▁, ▁4 ▁, ▁0 ▁} ▁, ▁{ ▁5 ▁, ▁6 ▁, ▁7 ▁, ▁8 ▁, ▁9 ▁} ▁, ▁{ ▁0 ▁, ▁6 ▁, ▁3 ▁, ▁4 ▁, ▁12 ▁} ▁, ▁{ ▁9 ▁, ▁7 ▁, ▁12 ▁, ▁4 ▁, ▁3 ▁} ▁, ▁} ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Max ▁difference ▁: ▁" ▁+ ▁col Max Diff ▁( ▁mat ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁find missing ▁( ▁int ▁[ ▁] ▁ar ▁, ▁int ▁N ▁) ▁{ ▁int ▁l ▁= ▁0 ▁, ▁r ▁= ▁N ▁- ▁1 ▁; ▁while ▁( ▁l ▁<= ▁r ▁) ▁{ ▁int ▁mid ▁= ▁( ▁l ▁+ ▁r ▁) ▁/ ▁2 ▁; ▁if ▁( ▁ar ▁[ ▁mid ▁] ▁!= ▁mid ▁+ ▁1 ▁&& ▁ar ▁[ ▁mid ▁- ▁1 ▁] ▁== ▁mid ▁) ▁return ▁( ▁mid ▁+ ▁1 ▁) ▁; ▁if ▁( ▁ar ▁[ ▁mid ▁] ▁!= ▁mid ▁+ ▁1 ▁) ▁r ▁= ▁mid ▁- ▁1 ▁; ▁else ▁l ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁return ▁- ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁7 ▁, ▁8 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find missing ▁( ▁arr ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁solve ▁( ▁int ▁[ ▁] ▁a ▁, ▁int ▁n ▁) ▁{ ▁int ▁max 1 ▁= ▁Integer ▁. ▁MIN _ VALUE ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁Math ▁. ▁abs ▁( ▁a ▁[ ▁i ▁] ▁- ▁a ▁[ ▁j ▁] ▁) ▁> ▁max 1 ▁) ▁{ ▁max 1 ▁= ▁Math ▁. ▁abs ▁( ▁a ▁[ ▁i ▁] ▁- ▁a ▁[ ▁j ▁] ▁) ▁; ▁} ▁} ▁} ▁return ▁max 1 ▁; ▁} ▁static ▁public ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁- ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁- ▁4 ▁, ▁- ▁10 ▁, ▁22 ▁} ▁; ▁int ▁size ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁L argest ▁gap ▁is ▁: ▁" ▁+ ▁solve ▁( ▁arr ▁, ▁size ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁max Product ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁< ▁4 ▁) ▁{ ▁return ▁- ▁1 ▁; ▁} ▁int ▁max A ▁= ▁Integer ▁. ▁MIN _ VALUE ▁, ▁max B ▁= ▁Integer ▁. ▁MIN _ VALUE ▁, ▁max C ▁= ▁Integer ▁. ▁MIN _ VALUE ▁, ▁max D ▁= ▁Integer ▁. ▁MIN _ VALUE ▁; ▁int ▁min A ▁= ▁Integer ▁. ▁MAX _ VALUE ▁, ▁min B ▁= ▁Integer ▁. ▁MAX _ VALUE ▁, ▁min C ▁= ▁Integer ▁. ▁MAX _ VALUE ▁, ▁min D ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁max A ▁) ▁{ ▁max D ▁= ▁max C ▁; ▁max C ▁= ▁max B ▁; ▁max B ▁= ▁max A ▁; ▁max A ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁else ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁max B ▁) ▁{ ▁max D ▁= ▁max C ▁; ▁max C ▁= ▁max B ▁; ▁max B ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁else ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁max C ▁) ▁{ ▁max D ▁= ▁max C ▁; ▁max C ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁else ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁max D ▁) ▁{ ▁max D ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁min A ▁) ▁{ ▁min D ▁= ▁min C ▁; ▁min C ▁= ▁min B ▁; ▁min B ▁= ▁min A ▁; ▁min A ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁else ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁min B ▁) ▁{ ▁min D ▁= ▁min C ▁; ▁min C ▁= ▁min B ▁; ▁min B ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁else ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁min C ▁) ▁{ ▁min D ▁= ▁min C ▁; ▁min C ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁else ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁min D ▁) ▁{ ▁min D ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁} ▁int ▁x ▁= ▁max A ▁* ▁max B ▁* ▁max C ▁* ▁max D ▁; ▁int ▁y ▁= ▁min A ▁* ▁min B ▁* ▁min C ▁* ▁min D ▁; ▁int ▁z ▁= ▁min A ▁* ▁min B ▁* ▁max A ▁* ▁max B ▁; ▁return ▁Math ▁. ▁max ▁( ▁x ▁, ▁Math ▁. ▁max ▁( ▁y ▁, ▁z ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁- ▁4 ▁, ▁3 ▁, ▁- ▁6 ▁, ▁7 ▁, ▁0 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁int ▁max ▁= ▁max Product ▁( ▁arr ▁, ▁n ▁) ▁; ▁if ▁( ▁max ▁== ▁- ▁1 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁Quad r uple ▁Exists ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Maximum ▁product ▁is ▁" ▁+ ▁max ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁print Matrix ▁( ▁ArrayList ▁< ▁ArrayList ▁< ▁Integer ▁> ▁> ▁a ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁a ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁a ▁. ▁get ▁( ▁i ▁) ▁. ▁size ▁( ▁) ▁; ▁j ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁a ▁. ▁get ▁( ▁i ▁) ▁. ▁get ▁( ▁j ▁) ▁+ ▁" ▁" ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁} ▁} ▁static ▁void ▁sort Boundary W ise ▁( ▁ArrayList ▁< ▁ArrayList ▁< ▁Integer ▁> ▁> ▁a ▁) ▁{ ▁int ▁i ▁, ▁k ▁= ▁0 ▁, ▁l ▁= ▁0 ▁; ▁int ▁m ▁= ▁a ▁. ▁size ▁( ▁) ▁, ▁n ▁= ▁a ▁. ▁get ▁( ▁0 ▁) ▁. ▁size ▁( ▁) ▁; ▁int ▁n _ i ▁, ▁n _ k ▁= ▁0 ▁, ▁n _ l ▁= ▁0 ▁, ▁n _ m ▁= ▁m ▁, ▁n _ n ▁= ▁n ▁; ▁while ▁( ▁k ▁< ▁m ▁&& ▁l ▁< ▁n ▁) ▁{ ▁ArrayList ▁< ▁Integer ▁> ▁boundary ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁i ▁= ▁l ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁{ ▁boundary ▁. ▁add ▁( ▁a ▁. ▁get ▁( ▁k ▁) ▁. ▁get ▁( ▁i ▁) ▁) ▁; ▁} ▁k ▁++ ▁; ▁for ▁( ▁i ▁= ▁k ▁; ▁i ▁< ▁m ▁; ▁++ ▁i ▁) ▁{ ▁boundary ▁. ▁add ▁( ▁a ▁. ▁get ▁( ▁i ▁) ▁. ▁get ▁( ▁n ▁- ▁1 ▁) ▁) ▁; ▁} ▁n ▁-- ▁; ▁if ▁( ▁k ▁< ▁m ▁) ▁{ ▁for ▁( ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁l ▁; ▁-- ▁i ▁) ▁{ ▁boundary ▁. ▁add ▁( ▁a ▁. ▁get ▁( ▁m ▁- ▁1 ▁) ▁. ▁get ▁( ▁i ▁) ▁) ▁; ▁} ▁m ▁-- ▁; ▁} ▁if ▁( ▁l ▁< ▁n ▁) ▁{ ▁for ▁( ▁i ▁= ▁m ▁- ▁1 ▁; ▁i ▁>= ▁k ▁; ▁-- ▁i ▁) ▁{ ▁boundary ▁. ▁add ▁( ▁a ▁. ▁get ▁( ▁i ▁) ▁. ▁get ▁( ▁l ▁) ▁) ▁; ▁} ▁l ▁++ ▁; ▁} ▁Collections ▁. ▁sort ▁( ▁boundary ▁) ▁; ▁int ▁ind ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁n _ l ▁; ▁i ▁< ▁n _ n ▁; ▁++ ▁i ▁) ▁{ ▁a ▁. ▁get ▁( ▁n _ k ▁) ▁. ▁set ▁( ▁i ▁, ▁boundary ▁. ▁get ▁( ▁ind ▁) ▁) ▁; ▁ind ▁++ ▁; ▁} ▁n _ k ▁+= ▁1 ▁; ▁for ▁( ▁i ▁= ▁n _ k ▁; ▁i ▁< ▁n _ m ▁; ▁++ ▁i ▁) ▁{ ▁a ▁. ▁get ▁( ▁i ▁) ▁. ▁set ▁( ▁n _ n ▁- ▁1 ▁, ▁boundary ▁. ▁get ▁( ▁ind ▁) ▁) ▁; ▁ind ▁++ ▁; ▁} ▁n _ n ▁-- ▁; ▁if ▁( ▁n _ k ▁< ▁n _ m ▁) ▁{ ▁for ▁( ▁i ▁= ▁n _ n ▁- ▁1 ▁; ▁i ▁>= ▁n _ l ▁; ▁-- ▁i ▁) ▁{ ▁a ▁. ▁get ▁( ▁n _ m ▁- ▁1 ▁) ▁. ▁set ▁( ▁i ▁, ▁boundary ▁. ▁get ▁( ▁ind ▁) ▁) ▁; ▁ind ▁++ ▁; ▁} ▁n _ m ▁-- ▁; ▁} ▁if ▁( ▁n _ l ▁< ▁n _ n ▁) ▁{ ▁for ▁( ▁i ▁= ▁n _ m ▁- ▁1 ▁; ▁i ▁>= ▁n _ k ▁; ▁-- ▁i ▁) ▁{ ▁a ▁. ▁get ▁( ▁i ▁) ▁. ▁set ▁( ▁n _ l ▁, ▁boundary ▁. ▁get ▁( ▁ind ▁) ▁) ▁; ▁ind ▁++ ▁; ▁} ▁n _ l ▁++ ▁; ▁} ▁} ▁print Matrix ▁( ▁a ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁ArrayList ▁< ▁ArrayList ▁< ▁Integer ▁> ▁> ▁matrix ▁= ▁new ▁ArrayList ▁< ▁ArrayList ▁< ▁Integer ▁> ▁> ▁( ▁) ▁; ▁ArrayList ▁< ▁Integer ▁> ▁list 1 ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁Arrays ▁. ▁asList ▁( ▁9 ▁, ▁7 ▁, ▁4 ▁, ▁5 ▁) ▁) ▁; ▁ArrayList ▁< ▁Integer ▁> ▁list 2 ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁Arrays ▁. ▁asList ▁( ▁1 ▁, ▁6 ▁, ▁2 ▁, ▁- ▁6 ▁) ▁) ▁; ▁ArrayList ▁< ▁Integer ▁> ▁list 3 ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁Arrays ▁. ▁asList ▁( ▁12 ▁, ▁20 ▁, ▁2 ▁, ▁0 ▁) ▁) ▁; ▁ArrayList ▁< ▁Integer ▁> ▁list 4 ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁Arrays ▁. ▁asList ▁( ▁- ▁5 ▁, ▁- ▁6 ▁, ▁7 ▁, ▁- ▁2 ▁) ▁) ▁; ▁matrix ▁. ▁add ▁( ▁list 1 ▁) ▁; ▁matrix ▁. ▁add ▁( ▁list 2 ▁) ▁; ▁matrix ▁. ▁add ▁( ▁list 3 ▁) ▁; ▁matrix ▁. ▁add ▁( ▁list 4 ▁) ▁; ▁sort Boundary W ise ▁( ▁matrix ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁math ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁public ▁class ▁G F G ▁{ ▁static ▁int ▁max Score ▁( ▁int ▁i ▁, ▁int ▁A ▁[ ▁] ▁, ▁int ▁K ▁, ▁int ▁N ▁, ▁int ▁dp ▁[ ▁] ▁) ▁{ ▁if ▁( ▁i ▁>= ▁N ▁- ▁1 ▁) ▁return ▁A ▁[ ▁N ▁- ▁1 ▁] ▁; ▁if ▁( ▁dp ▁[ ▁i ▁] ▁!= ▁- ▁1 ▁) ▁return ▁dp ▁[ ▁i ▁] ▁; ▁int ▁score ▁= ▁Integer ▁. ▁MIN _ VALUE ▁; ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁<= ▁K ▁; ▁j ▁++ ▁) ▁{ ▁score ▁= ▁Math ▁. ▁max ▁( ▁score ▁, ▁max Score ▁( ▁i ▁+ ▁j ▁, ▁A ▁, ▁K ▁, ▁N ▁, ▁dp ▁) ▁) ▁; ▁} ▁return ▁dp ▁[ ▁i ▁] ▁= ▁score ▁+ ▁A ▁[ ▁i ▁] ▁; ▁} ▁static ▁void ▁getScore ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁int ▁dp ▁[ ▁] ▁= ▁new ▁int ▁[ ▁N ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁dp ▁[ ▁i ▁] ▁= ▁- ▁1 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁max Score ▁( ▁0 ▁, ▁A ▁, ▁K ▁, ▁N ▁, ▁dp ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁100 ▁, ▁- ▁30 ▁, ▁- ▁50 ▁, ▁- ▁15 ▁, ▁- ▁20 ▁, ▁- ▁30 ▁} ▁; ▁int ▁K ▁= ▁3 ▁; ▁int ▁N ▁= ▁A ▁. ▁length ▁; ▁getScore ▁( ▁A ▁, ▁N ▁, ▁K ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁check if Sorted ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁B ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁boolean ▁flag ▁= ▁false ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁A ▁[ ▁i ▁] ▁> ▁A ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁{ ▁flag ▁= ▁true ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁! ▁flag ▁) ▁{ ▁return ▁true ▁; ▁} ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁B ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁count ▁++ ▁; ▁break ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁B ▁[ ▁i ▁] ▁== ▁1 ▁) ▁{ ▁count ▁++ ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁count ▁== ▁2 ▁) ▁{ ▁return ▁true ▁; ▁} ▁return ▁false ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁1 ▁, ▁2 ▁} ▁; ▁int ▁B ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁1 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁A ▁. ▁length ▁; ▁boolean ▁check ▁= ▁check if Sorted ▁( ▁A ▁, ▁B ▁, ▁N ▁) ▁; ▁if ▁( ▁check ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁YES ▁" ▁) ▁; ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁NO ▁" ▁) ▁; ▁} ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁isIn cre asing ▁( ▁int ▁[ ▁] ▁arr ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁arr ▁. ▁length ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁arr ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁return ▁false ▁; ▁} ▁return ▁true ▁; ▁} ▁static ▁int ▁[ ▁] ▁sort Arr ▁( ▁int ▁[ ▁] ▁arr ▁) ▁{ ▁int ▁prev ▁= ▁- ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁arr ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁int ▁opt Ele ▁= ▁arr ▁[ ▁i ▁] ▁; ▁String ▁str Ele ▁= ▁String ▁. ▁valueOf ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁for ▁( ▁int ▁idx ▁= ▁0 ▁; ▁idx ▁< ▁str Ele ▁. ▁length ▁( ▁) ▁; ▁idx ▁++ ▁) ▁{ ▁String ▁str Ele 2 ▁= ▁str Ele ▁. ▁substring ▁( ▁idx ▁) ▁+ ▁str Ele ▁. ▁substring ▁( ▁0 ▁, ▁idx ▁) ▁; ▁int ▁temp ▁= ▁Integer ▁. ▁valueOf ▁( ▁str Ele 2 ▁) ▁; ▁if ▁( ▁temp ▁>= ▁prev ▁&& ▁temp ▁< ▁opt Ele ▁) ▁opt Ele ▁= ▁temp ▁; ▁} ▁arr ▁[ ▁i ▁] ▁= ▁opt Ele ▁; ▁prev ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁if ▁( ▁isIn cre asing ▁( ▁arr ▁) ▁) ▁return ▁arr ▁; ▁else ▁{ ▁return ▁new ▁int ▁[ ▁] ▁{ ▁- ▁1 ▁} ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁5 11 ▁, ▁32 1 ▁, ▁3 23 ▁, ▁4 32 ▁, ▁4 33 ▁} ▁; ▁int ▁[ ▁] ▁res ▁= ▁sort Arr ▁( ▁arr ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁res ▁. ▁length ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁res ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁final ▁static ▁int ▁N ▁= ▁100 ▁; ▁final ▁static ▁int ▁INF ▁= ▁1000000 ▁; ▁static ▁int ▁dp ▁[ ▁] ▁[ ▁] ▁= ▁new ▁int ▁[ ▁N ▁] ▁[ ▁N ▁] ▁; ▁static ▁int ▁vis ▁[ ▁] ▁[ ▁] ▁= ▁new ▁int ▁[ ▁N ▁] ▁[ ▁N ▁] ▁; ▁static ▁int ▁find Sum ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁n ▁, ▁int ▁k ▁, ▁int ▁l ▁, ▁int ▁r ▁) ▁{ ▁if ▁( ▁( ▁l ▁) ▁+ ▁( ▁n ▁- ▁1 ▁- ▁r ▁) ▁== ▁k ▁) ▁return ▁arr ▁[ ▁r ▁] ▁- ▁arr ▁[ ▁l ▁] ▁; ▁if ▁( ▁vis ▁[ ▁l ▁] ▁[ ▁r ▁] ▁== ▁1 ▁) ▁return ▁dp ▁[ ▁l ▁] ▁[ ▁r ▁] ▁; ▁vis ▁[ ▁l ▁] ▁[ ▁r ▁] ▁= ▁1 ▁; ▁dp ▁[ ▁l ▁] ▁[ ▁r ▁] ▁= ▁Math ▁. ▁min ▁( ▁find Sum ▁( ▁arr ▁, ▁n ▁, ▁k ▁, ▁l ▁, ▁r ▁- ▁1 ▁) ▁, ▁find Sum ▁( ▁arr ▁, ▁n ▁, ▁k ▁, ▁l ▁+ ▁1 ▁, ▁r ▁) ▁) ▁; ▁return ▁dp ▁[ ▁l ▁] ▁[ ▁r ▁] ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁100 ▁, ▁120 ▁, ▁140 ▁} ▁; ▁int ▁k ▁= ▁2 ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Sum ▁( ▁arr ▁, ▁n ▁, ▁k ▁, ▁0 ▁, ▁n ▁- ▁1 ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁Collections ▁; ▁import ▁java ▁. ▁util ▁. ▁Vector ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁String ▁getS orted String ▁( ▁StringBuilder ▁s ▁, ▁int ▁n ▁) ▁{ ▁Vector ▁< ▁Character ▁> ▁v 1 ▁= ▁new ▁Vector ▁< ▁> ▁( ▁) ▁; ▁Vector ▁< ▁Character ▁> ▁v 2 ▁= ▁new ▁Vector ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁>= ▁' ▁a ▁' ▁&& ▁s ▁. ▁charAt ▁( ▁i ▁) ▁<= ▁' ▁z ▁' ▁) ▁v 1 ▁. ▁add ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁) ▁; ▁if ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁>= ▁' ▁A ▁' ▁&& ▁s ▁. ▁charAt ▁( ▁i ▁) ▁<= ▁' ▁z ▁' ▁) ▁v 2 ▁. ▁add ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁) ▁; ▁} ▁Collections ▁. ▁sort ▁( ▁v 1 ▁) ▁; ▁Collections ▁. ▁sort ▁( ▁v 2 ▁) ▁; ▁int ▁i ▁= ▁0 ▁, ▁j ▁= ▁0 ▁; ▁for ▁( ▁int ▁k ▁= ▁0 ▁; ▁k ▁< ▁n ▁; ▁k ▁++ ▁) ▁{ ▁if ▁( ▁s ▁. ▁charAt ▁( ▁k ▁) ▁> ▁= ▁' ▁a ▁' ▁&& ▁s ▁. ▁charAt ▁( ▁k ▁) ▁<= ▁' ▁z ▁' ▁) ▁{ ▁s ▁. ▁set Char At ▁( ▁k ▁, ▁v 1 ▁. ▁elementAt ▁( ▁i ▁) ▁) ▁; ▁++ ▁i ▁; ▁} ▁else ▁if ▁( ▁s ▁. ▁charAt ▁( ▁k ▁) ▁> ▁= ▁' ▁A ▁' ▁&& ▁s ▁. ▁charAt ▁( ▁k ▁) ▁<= ▁' ▁Z ▁' ▁) ▁{ ▁s ▁. ▁set Char At ▁( ▁k ▁, ▁v 2 ▁. ▁elementAt ▁( ▁j ▁) ▁) ▁; ▁++ ▁j ▁; ▁} ▁} ▁return ▁s ▁. ▁toString ▁( ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁StringBuilder ▁s ▁= ▁new ▁StringBuilder ▁( ▁" ▁g E ek sf Org EE k S ▁" ▁) ▁; ▁int ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁getS orted String ▁( ▁s ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁remove Elements ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁n ▁) ▁{ ▁int ▁[ ▁] ▁br r ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁int ▁l ▁= ▁1 ▁; ▁br r ▁[ ▁0 ▁] ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁br r ▁[ ▁l ▁- ▁1 ▁] ▁<= ▁arr ▁[ ▁i ▁] ▁) ▁{ ▁br r ▁[ ▁l ▁] ▁= ▁arr ▁[ ▁i ▁] ▁; ▁l ▁++ ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁l ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁br r ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁static ▁public ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁10 ▁, ▁12 ▁, ▁9 ▁, ▁10 ▁, ▁2 ▁, ▁13 ▁, ▁14 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁remove Elements ▁( ▁arr ▁, ▁n ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁find X ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁a ▁) ▁; ▁int ▁x ▁= ▁a ▁[ ▁0 ▁] ▁* ▁a ▁[ ▁n ▁- ▁1 ▁] ▁; ▁Vector ▁< ▁Integer ▁> ▁vec ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁* ▁i ▁<= ▁x ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁x ▁% ▁i ▁== ▁0 ▁) ▁{ ▁vec ▁. ▁add ▁( ▁i ▁) ▁; ▁if ▁( ▁( ▁x ▁/ ▁i ▁) ▁!= ▁i ▁) ▁vec ▁. ▁add ▁( ▁x ▁/ ▁i ▁) ▁; ▁} ▁} ▁Collections ▁. ▁sort ▁( ▁vec ▁) ▁; ▁if ▁( ▁vec ▁. ▁size ▁( ▁) ▁!= ▁n ▁) ▁return ▁- ▁1 ▁; ▁else ▁{ ▁int ▁i ▁= ▁0 ▁; ▁for ▁( ▁int ▁it ▁: ▁vec ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁++ ▁] ▁!= ▁it ▁) ▁return ▁- ▁1 ▁; ▁} ▁} ▁return ▁x ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁5 ▁, ▁4 ▁, ▁10 ▁} ▁; ▁int ▁n ▁= ▁a ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁find X ▁( ▁a ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁MOD ▁= ▁100 000000 7 ▁; ▁static ▁int ▁max ▁= ▁101 ▁; ▁static ▁long ▁C ▁[ ▁] ▁[ ▁] ▁= ▁new ▁long ▁[ ▁max ▁] ▁[ ▁max ▁] ▁; ▁static ▁long ▁power ▁( ▁long ▁x ▁, ▁long ▁y ▁) ▁{ ▁long ▁res ▁= ▁1 ▁; ▁x ▁= ▁x ▁% ▁MOD ▁; ▁while ▁( ▁y ▁> ▁0 ▁) ▁{ ▁if ▁( ▁y ▁% ▁2 ▁== ▁1 ▁) ▁{ ▁res ▁= ▁( ▁res ▁* ▁x ▁) ▁% ▁MOD ▁; ▁} ▁y ▁= ▁y ▁>> ▁1 ▁; ▁x ▁= ▁( ▁x ▁* ▁x ▁) ▁% ▁MOD ▁; ▁} ▁return ▁res ▁% ▁MOD ▁; ▁} ▁static ▁void ▁comb i ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁i ▁, ▁j ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁<= ▁Math ▁. ▁min ▁( ▁i ▁, ▁k ▁) ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁j ▁== ▁0 ▁j ▁== ▁i ▁) ▁C ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁1 ▁; ▁else ▁C ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁( ▁C ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁- ▁1 ▁] ▁% ▁MOD ▁+ ▁C ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁% ▁MOD ▁) ▁% ▁MOD ▁; ▁} ▁} ▁} ▁static ▁long ▁product ▁( ▁long ▁a ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁long ▁ans ▁= ▁1 ▁; ▁Arrays ▁. ▁sort ▁( ▁a ▁) ▁; ▁long ▁pow a ▁= ▁C ▁[ ▁n ▁- ▁1 ▁] ▁[ ▁k ▁- ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁long ▁pow la ▁= ▁C ▁[ ▁i ▁] ▁[ ▁k ▁- ▁1 ▁] ▁; ▁long ▁pow fa ▁= ▁C ▁[ ▁n ▁- ▁i ▁- ▁1 ▁] ▁[ ▁k ▁- ▁1 ▁] ▁; ▁long ▁pow e ▁= ▁( ▁( ▁pow a ▁% ▁MOD ▁) ▁- ▁( ▁pow la ▁+ ▁pow fa ▁) ▁% ▁MOD ▁+ ▁MOD ▁) ▁% ▁MOD ▁; ▁long ▁mul ▁= ▁power ▁( ▁a ▁[ ▁i ▁] ▁, ▁pow e ▁) ▁% ▁MOD ▁; ▁ans ▁= ▁( ▁( ▁ans ▁% ▁MOD ▁) ▁* ▁( ▁mul ▁% ▁MOD ▁) ▁) ▁% ▁MOD ▁; ▁} ▁return ▁ans ▁% ▁MOD ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁comb i ▁( ▁100 ▁, ▁100 ▁) ▁; ▁long ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁int ▁k ▁= ▁3 ▁; ▁long ▁ans ▁= ▁product ▁( ▁arr ▁, ▁n ▁, ▁k ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁ans ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁distribution ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁Set ▁< ▁Integer ▁> ▁resources ▁= ▁new ▁HashSet ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁resources ▁. ▁add ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁return ▁Math ▁. ▁min ▁( ▁resources ▁. ▁size ▁( ▁) ▁, ▁n ▁/ ▁2 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁1 ▁, ▁2 ▁, ▁1 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁distribution ▁( ▁arr ▁, ▁n ▁) ▁+ ▁" NEW _ LINE "); ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁void ▁print Sorted ▁( ▁String ▁s ▁, ▁int ▁l ▁) ▁{ ▁Stack ▁< ▁Character ▁> ▁stack ▁= ▁new ▁Stack ▁< ▁Character ▁> ▁( ▁) ▁; ▁Stack ▁< ▁Character ▁> ▁temp stack ▁= ▁new ▁Stack ▁< ▁Character ▁> ▁( ▁) ▁; ▁stack ▁. ▁push ▁( ▁s ▁. ▁charAt ▁( ▁0 ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁l ▁; ▁i ▁++ ▁) ▁{ ▁int ▁a ▁= ▁s ▁. ▁charAt ▁( ▁i ▁) ▁; ▁int ▁b ▁= ▁( ▁int ▁) ▁( ▁( ▁char ▁) ▁stack ▁. ▁peek ▁( ▁) ▁) ▁; ▁if ▁( ▁( ▁a ▁- ▁b ▁) ▁>= ▁1 ▁|| ▁( ▁a ▁== ▁b ▁) ▁) ▁{ ▁stack ▁. ▁push ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁) ▁; ▁} ▁else ▁if ▁( ▁( ▁b ▁- ▁a ▁) ▁>= ▁1 ▁) ▁{ ▁while ▁( ▁( ▁b ▁- ▁a ▁) ▁>= ▁1 ▁) ▁{ ▁temp stack ▁. ▁push ▁( ▁stack ▁. ▁peek ▁( ▁) ▁) ▁; ▁stack ▁. ▁pop ▁( ▁) ▁; ▁if ▁( ▁stack ▁. ▁size ▁( ▁) ▁> ▁0 ▁) ▁{ ▁b ▁= ▁( ▁int ▁) ▁( ▁( ▁char ▁) ▁stack ▁. ▁peek ▁( ▁) ▁) ▁; ▁} ▁else ▁{ ▁break ▁; ▁} ▁} ▁stack ▁. ▁push ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁) ▁; ▁while ▁( ▁temp stack ▁. ▁size ▁( ▁) ▁> ▁0 ▁) ▁{ ▁stack ▁. ▁push ▁( ▁temp stack ▁. ▁peek ▁( ▁) ▁) ▁; ▁temp stack ▁. ▁pop ▁( ▁) ▁; ▁} ▁} ▁} ▁String ▁answer ▁= ▁" ▁" ▁; ▁while ▁( ▁stack ▁. ▁size ▁( ▁) ▁> ▁0 ▁) ▁{ ▁answer ▁= ▁stack ▁. ▁peek ▁( ▁) ▁+ ▁answer ▁; ▁stack ▁. ▁pop ▁( ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁answer ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁s ▁= ▁" ▁g eek s forge ek s ▁" ▁; ▁int ▁l ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁print Sorted ▁( ▁s ▁, ▁l ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁maximum _ to ys ▁( ▁int ▁cost ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁int ▁count ▁= ▁0 ▁, ▁sum ▁= ▁0 ▁; ▁Arrays ▁. ▁sort ▁( ▁cost ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁sum ▁+ ▁cost ▁[ ▁i ▁] ▁<= ▁K ▁) ▁{ ▁sum ▁= ▁sum ▁+ ▁cost ▁[ ▁i ▁] ▁; ▁count ▁++ ▁; ▁} ▁} ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁K ▁= ▁50 ▁; ▁int ▁cost ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁12 ▁, ▁5 ▁, ▁111 ▁, ▁200 ▁, ▁1000 ▁, ▁10 ▁, ▁9 ▁, ▁12 ▁, ▁15 ▁} ▁; ▁int ▁N ▁= ▁cost ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁maximum _ to ys ▁( ▁cost ▁, ▁N ▁, ▁K ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁boolean ▁almost Sort ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁A ▁[ ▁i ▁] ▁> ▁A ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁{ ▁int ▁temp ▁= ▁A ▁[ ▁i ▁] ▁; ▁A ▁[ ▁i ▁] ▁= ▁A ▁[ ▁i ▁+ ▁1 ▁] ▁; ▁A ▁[ ▁i ▁+ ▁1 ▁] ▁= ▁temp ▁; ▁i ▁++ ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁if ▁( ▁A ▁[ ▁i ▁] ▁> ▁A ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁return ▁false ▁; ▁return ▁true ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁2 ▁, ▁4 ▁, ▁6 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁A ▁. ▁length ▁; ▁if ▁( ▁almost Sort ▁( ▁A ▁, ▁n ▁) ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁merge Two Half ▁( ▁int ▁[ ▁] ▁A ▁, ▁int ▁n ▁) ▁{ ▁int ▁i ▁; ▁int ▁[ ▁] ▁temp ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁A ▁[ ▁i ▁] ▁> ▁A ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁{ ▁half _ i ▁= ▁i ▁+ ▁1 ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁half _ i ▁== ▁0 ▁) ▁return ▁; ▁i ▁= ▁0 ▁; ▁int ▁j ▁= ▁half _ i ▁; ▁int ▁k ▁= ▁0 ▁; ▁while ▁( ▁i ▁< ▁half _ i ▁&& ▁j ▁< ▁n ▁) ▁{ ▁if ▁( ▁A ▁[ ▁i ▁] ▁< ▁A ▁[ ▁j ▁] ▁) ▁temp ▁[ ▁k ▁++ ▁] ▁= ▁A ▁[ ▁i ▁++ ▁] ▁; ▁else ▁temp ▁[ ▁k ▁++ ▁] ▁= ▁A ▁[ ▁j ▁++ ▁] ▁; ▁} ▁while ▁( ▁i ▁< ▁half _ i ▁) ▁temp ▁[ ▁k ▁++ ▁] ▁= ▁A ▁[ ▁i ▁++ ▁] ▁; ▁while ▁( ▁j ▁< ▁n ▁) ▁temp ▁[ ▁k ▁++ ▁] ▁= ▁A ▁[ ▁j ▁++ ▁] ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁A ▁[ ▁i ▁] ▁= ▁temp ▁[ ▁i ▁] ▁; ▁} ▁static ▁public ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁A ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁8 ▁, ▁- ▁1 ▁, ▁7 ▁, ▁10 ▁} ▁; ▁int ▁n ▁= ▁A ▁. ▁length ▁; ▁merge Two Half ▁( ▁A ▁, ▁n ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁A ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁final ▁double ▁Pi ▁= ▁3.14 15 92 ▁; ▁static ▁int ▁Max Build ings Cover ed ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁L ▁) ▁{ ▁double ▁curr _ sum ▁= ▁0 ▁; ▁int ▁start ▁= ▁0 ▁, ▁curr _ count ▁= ▁0 ▁, ▁max _ count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁curr _ sum ▁= ▁curr _ sum ▁+ ▁( ▁( ▁double ▁) ▁arr ▁[ ▁i ▁] ▁* ▁Pi ▁) ▁; ▁if ▁( ▁i ▁!= ▁0 ▁) ▁curr _ sum ▁+= ▁1 ▁; ▁if ▁( ▁curr _ sum ▁<= ▁L ▁) ▁{ ▁curr _ count ▁++ ▁; ▁} ▁else ▁if ▁( ▁curr _ sum ▁> ▁L ▁) ▁{ ▁curr _ sum ▁= ▁curr _ sum ▁- ▁( ▁( ▁double ▁) ▁arr ▁[ ▁start ▁] ▁* ▁Pi ▁) ▁; ▁curr _ sum ▁-= ▁1 ▁; ▁start ▁++ ▁; ▁curr _ count ▁-- ▁; ▁} ▁max _ count ▁= ▁Math ▁. ▁max ▁( ▁curr _ count ▁, ▁max _ count ▁) ▁; ▁} ▁return ▁max _ count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁1 ▁, ▁6 ▁, ▁2 ▁} ▁; ▁int ▁L ▁= ▁24 ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁Max Build ings Cover ed ▁( ▁arr ▁, ▁N ▁, ▁L ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁MyClass ▁{ ▁static ▁boolean ▁isP ossible ▁( ▁String ▁s ▁) ▁{ ▁int ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁int ▁count _0 ▁= ▁0 ▁, ▁count _1 ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'0' ▁) ▁++ ▁count _0 ▁; ▁else ▁++ ▁count _1 ▁; ▁if ▁( ▁count _1 ▁> ▁count _0 ▁) ▁return ▁false ▁; ▁} ▁if ▁( ▁count _0 ▁!= ▁( ▁2 ▁* ▁count _1 ▁) ▁) ▁return ▁false ▁; ▁count _0 ▁= ▁0 ▁; ▁count _1 ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁-- ▁i ▁) ▁{ ▁if ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'0' ▁) ▁++ ▁count _0 ▁; ▁else ▁++ ▁count _1 ▁; ▁if ▁( ▁count _1 ▁> ▁count _0 ▁) ▁return ▁false ▁; ▁} ▁return ▁true ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁String ▁s ▁= ▁" 0101 00" ▁; ▁if ▁( ▁isP ossible ▁( ▁s ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁find Max Val By Re arr Arr ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁res ▁= ▁0 ▁; ▁res ▁= ▁( ▁N ▁* ▁( ▁N ▁+ ▁1 ▁) ▁) ▁/ ▁2 ▁; ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁2 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁find Max Val By Re arr Arr ▁( ▁arr ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁float ▁pair Product Mean ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁suffix Sum Array ▁[ ▁] ▁= ▁new ▁int ▁[ ▁N ▁] ▁; ▁suffix Sum Array ▁[ ▁N ▁- ▁1 ▁] ▁= ▁arr ▁[ ▁N ▁- ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁N ▁- ▁2 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁suffix Sum Array ▁[ ▁i ▁] ▁= ▁suffix Sum Array ▁[ ▁i ▁+ ▁1 ▁] ▁+ ▁arr ▁[ ▁i ▁] ▁; ▁} ▁int ▁length ▁= ▁( ▁N ▁* ▁( ▁N ▁- ▁1 ▁) ▁) ▁/ ▁2 ▁; ▁float ▁res ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁res ▁+= ▁arr ▁[ ▁i ▁] ▁* ▁suffix Sum Array ▁[ ▁i ▁+ ▁1 ▁] ▁; ▁} ▁float ▁mean ▁; ▁if ▁( ▁length ▁!= ▁0 ▁) ▁mean ▁= ▁res ▁/ ▁length ▁; ▁else ▁mean ▁= ▁0 ▁; ▁return ▁mean ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁4 ▁, ▁8 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁format ▁( ▁" ▁% ▁.2 f ▁" ▁, ▁pair Product Mean ▁( ▁arr ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁values _ of _ Q ▁( ▁int ▁X ▁) ▁{ ▁ArrayList ▁< ▁Integer ▁> ▁val _ Q ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁X ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁( ▁( ▁X ▁+ ▁i ▁) ▁* ▁X ▁) ▁) ▁% ▁i ▁== ▁0 ▁) ▁{ ▁val _ Q ▁. ▁add ▁( ▁X ▁+ ▁i ▁) ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁val _ Q ▁. ▁size ▁( ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁val _ Q ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁val _ Q ▁. ▁get ▁( ▁i ▁) ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁X ▁= ▁3 ▁; ▁values _ of _ Q ▁( ▁X ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁sum Of Fact ors ▁( ▁int ▁N ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁int ▁first ▁= ▁i ▁; ▁int ▁last ▁= ▁( ▁N ▁/ ▁i ▁) ▁* ▁i ▁; ▁int ▁factors ▁= ▁( ▁last ▁- ▁first ▁) ▁/ ▁i ▁+ ▁1 ▁; ▁int ▁total Contrib ution ▁= ▁( ▁( ▁( ▁factors ▁) ▁* ▁( ▁factors ▁+ ▁1 ▁) ▁) ▁/ ▁2 ▁) ▁* ▁i ▁; ▁ans ▁+= ▁total Contrib ution ▁; ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁sum Of Fact ors ▁( ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁max Pro fit ▁( ▁int ▁[ ▁] ▁value ▁, ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁value ▁) ▁; ▁int ▁maxval ▁= ▁value ▁[ ▁N ▁- ▁1 ▁] ▁; ▁int ▁max Pro fit ▁= ▁0 ▁; ▁int ▁curr _ val ▁; ▁do ▁{ ▁curr _ val ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁curr _ val ▁+= ▁value ▁[ ▁i ▁] ▁; ▁if ▁( ▁curr _ val ▁<= ▁K ▁) ▁{ ▁max Pro fit ▁= ▁Math ▁. ▁max ▁( ▁curr _ val ▁+ ▁maxval ▁* ▁( ▁i ▁+ ▁1 ▁) ▁, ▁max Pro fit ▁) ▁; ▁} ▁} ▁} ▁while ▁( ▁next _ perm utation ▁( ▁value ▁) ▁) ▁; ▁return ▁max Pro fit ▁; ▁} ▁static ▁boolean ▁next _ perm utation ▁( ▁int ▁[ ▁] ▁p ▁) ▁{ ▁for ▁( ▁int ▁a ▁= ▁p ▁. ▁length ▁- ▁2 ▁; ▁a ▁>= ▁0 ▁; ▁-- ▁a ▁) ▁if ▁( ▁p ▁[ ▁a ▁] ▁< ▁p ▁[ ▁a ▁+ ▁1 ▁] ▁) ▁for ▁( ▁int ▁b ▁= ▁p ▁. ▁length ▁- ▁1 ▁; ▁; ▁-- ▁b ▁) ▁if ▁( ▁p ▁[ ▁b ▁] ▁> ▁p ▁[ ▁a ▁] ▁) ▁{ ▁int ▁t ▁= ▁p ▁[ ▁a ▁] ▁; ▁p ▁[ ▁a ▁] ▁= ▁p ▁[ ▁b ▁] ▁; ▁p ▁[ ▁b ▁] ▁= ▁t ▁; ▁for ▁( ▁++ ▁a ▁, ▁b ▁= ▁p ▁. ▁length ▁- ▁1 ▁; ▁a ▁< ▁b ▁; ▁++ ▁a ▁, ▁-- ▁b ▁) ▁{ ▁t ▁= ▁p ▁[ ▁a ▁] ▁; ▁p ▁[ ▁a ▁] ▁= ▁p ▁[ ▁b ▁] ▁; ▁p ▁[ ▁b ▁] ▁= ▁t ▁; ▁} ▁return ▁true ▁; ▁} ▁return ▁false ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁4 ▁, ▁K ▁= ▁6 ▁; ▁int ▁[ ▁] ▁values ▁= ▁{ ▁5 ▁, ▁2 ▁, ▁7 ▁, ▁3 ▁} ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁max Pro fit ▁( ▁values ▁, ▁N ▁, ▁K ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁lang ▁. ▁Math ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁minValue ▁( ▁int ▁n ▁) ▁{ ▁while ▁( ▁( ▁int ▁) ▁Math ▁. ▁sqrt ▁( ▁n ▁) ▁== ▁Math ▁. ▁sqrt ▁( ▁n ▁) ▁&& ▁n ▁> ▁1 ▁) ▁{ ▁n ▁= ▁( ▁int ▁) ▁( ▁Math ▁. ▁sqrt ▁( ▁n ▁) ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁( ▁int ▁) ▁( ▁Math ▁. ▁sqrt ▁( ▁n ▁) ▁) ▁; ▁i ▁> ▁1 ▁; ▁i ▁-- ▁) ▁{ ▁while ▁( ▁n ▁% ▁( ▁i ▁* ▁i ▁) ▁== ▁0 ▁) ▁n ▁/= ▁i ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁n ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁N ▁= ▁20 ▁; ▁minValue ▁( ▁N ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁find Direction ▁( ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁if ▁( ▁n ▁> ▁m ▁) ▁{ ▁if ▁( ▁m ▁% ▁2 ▁== ▁0 ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" Up NEW _ LINE "); ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" Down NEW _ LINE "); ▁} ▁else ▁{ ▁if ▁( ▁n ▁% ▁2 ▁== ▁0 ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" Left NEW _ LINE "); ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" Right NEW _ LINE "); ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁3 ▁, ▁m ▁= ▁3 ▁; ▁find Direction ▁( ▁n ▁, ▁m ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁N ▁= ▁( ▁int ▁) ▁( ▁1 e 5 ▁+ ▁5 ▁) ▁; ▁static ▁Vector ▁< ▁Integer ▁> ▁[ ▁] ▁v ▁= ▁new ▁Vector ▁[ ▁N ▁] ▁; ▁static ▁int ▁[ ▁] ▁val ▁= ▁new ▁int ▁[ ▁N ▁] ▁; ▁static ▁int ▁[ ▁] ▁answer ▁= ▁new ▁int ▁[ ▁N ▁] ▁; ▁static ▁int ▁n ▁; ▁static ▁int ▁gcd ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁if ▁( ▁b ▁== ▁0 ▁) ▁return ▁a ▁; ▁return ▁gcd ▁( ▁b ▁, ▁a ▁% ▁b ▁) ▁; ▁} ▁static ▁void ▁DFS ▁( ▁int ▁node ▁, ▁int ▁parent ▁) ▁{ ▁answer ▁[ ▁node ▁] ▁= ▁val ▁[ ▁node ▁] ▁; ▁for ▁( ▁int ▁child ▁: ▁v ▁[ ▁node ▁] ▁) ▁{ ▁if ▁( ▁child ▁== ▁parent ▁) ▁continue ▁; ▁DFS ▁( ▁child ▁, ▁node ▁) ▁; ▁answer ▁[ ▁node ▁] ▁= ▁gcd ▁( ▁answer ▁[ ▁node ▁] ▁, ▁answer ▁[ ▁child ▁] ▁) ▁; ▁} ▁} ▁static ▁void ▁preprocess ▁( ▁) ▁{ ▁DFS ▁( ▁1 ▁, ▁- ▁1 ▁) ▁; ▁} ▁static ▁void ▁find G CD ▁( ▁int ▁queries ▁[ ▁] ▁, ▁int ▁q ▁) ▁{ ▁preprocess ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁q ▁; ▁i ▁++ ▁) ▁{ ▁int ▁GC D ▁= ▁answer ▁[ ▁queries ▁[ ▁i ▁] ▁] ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁For ▁subtree ▁of ▁" ▁+ ▁queries ▁[ ▁i ▁] ▁+ ▁" ▁, ▁GC D ▁= ▁" ▁+ ▁GC D ▁+ ▁" NEW _ LINE "); ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁n ▁= ▁5 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁v ▁. ▁length ▁; ▁i ▁++ ▁) ▁v ▁[ ▁i ▁] ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁v ▁[ ▁1 ▁] ▁. ▁add ▁( ▁2 ▁) ▁; ▁v ▁[ ▁2 ▁] ▁. ▁add ▁( ▁1 ▁) ▁; ▁v ▁[ ▁1 ▁] ▁. ▁add ▁( ▁3 ▁) ▁; ▁v ▁[ ▁3 ▁] ▁. ▁add ▁( ▁1 ▁) ▁; ▁v ▁[ ▁3 ▁] ▁. ▁add ▁( ▁4 ▁) ▁; ▁v ▁[ ▁4 ▁] ▁. ▁add ▁( ▁3 ▁) ▁; ▁v ▁[ ▁3 ▁] ▁. ▁add ▁( ▁5 ▁) ▁; ▁v ▁[ ▁5 ▁] ▁. ▁add ▁( ▁3 ▁) ▁; ▁val ▁[ ▁1 ▁] ▁= ▁2 ▁; ▁val ▁[ ▁2 ▁] ▁= ▁3 ▁; ▁val ▁[ ▁3 ▁] ▁= ▁4 ▁; ▁val ▁[ ▁4 ▁] ▁= ▁8 ▁; ▁val ▁[ ▁5 ▁] ▁= ▁16 ▁; ▁int ▁queries ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁1 ▁} ▁; ▁int ▁q ▁= ▁queries ▁. ▁length ▁; ▁find G CD ▁( ▁queries ▁, ▁q ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁boolean ▁check ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁n ▁) ▁{ ▁boolean ▁flag ▁= ▁true ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁n ▁- ▁i ▁) ▁{ ▁flag ▁= ▁false ▁; ▁} ▁} ▁if ▁( ▁flag ▁) ▁{ ▁return ▁true ▁; ▁} ▁else ▁{ ▁return ▁false ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr 1 ▁[ ▁] ▁= ▁{ ▁11 ▁, ▁11 ▁, ▁11 ▁, ▁11 ▁} ▁; ▁int ▁n 1 ▁= ▁arr 1 ▁. ▁length ▁; ▁if ▁( ▁check ▁( ▁arr 1 ▁, ▁n 1 ▁) ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Yes ▁" ▁+ ▁" NEW _ LINE "); ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁No ▁" ▁+ ▁" NEW _ LINE "); ▁} ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁getL argest Sum ▁( ▁int ▁N ▁) ▁{ ▁int ▁max _ sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁* ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁* ▁j ▁<= ▁N ▁; ▁j ▁++ ▁) ▁{ ▁int ▁k ▁= ▁N ▁/ ▁j ▁; ▁int ▁a ▁= ▁k ▁* ▁i ▁; ▁int ▁b ▁= ▁k ▁* ▁j ▁; ▁if ▁( ▁a ▁<= ▁N ▁&& ▁b ▁<= ▁N ▁&& ▁a ▁* ▁b ▁% ▁( ▁a ▁+ ▁b ▁) ▁== ▁0 ▁) ▁max _ sum ▁= ▁Math ▁. ▁max ▁( ▁max _ sum ▁, ▁a ▁+ ▁b ▁) ▁; ▁} ▁} ▁return ▁max _ sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁25 ▁; ▁int ▁max _ sum ▁= ▁getL argest Sum ▁( ▁N ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁max _ sum ▁+ ▁" NEW _ LINE "); ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁gcd ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁if ▁( ▁a ▁== ▁0 ▁) ▁return ▁b ▁; ▁return ▁gcd ▁( ▁b ▁% ▁a ▁, ▁a ▁) ▁; ▁} ▁static ▁int ▁l cm ▁( ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁return ▁( ▁n ▁* ▁m ▁) ▁/ ▁gcd ▁( ▁n ▁, ▁m ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁2 ▁, ▁m ▁= ▁3 ▁, ▁k ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁k ▁/ ▁l cm ▁( ▁n ▁, ▁m ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁Check For Sequence ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁k ▁>= ▁arr ▁[ ▁i ▁] ▁) ▁k ▁-= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁if ▁( ▁k ▁!= ▁0 ▁) ▁return ▁false ▁; ▁else ▁return ▁true ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁7 ▁, ▁15 ▁, ▁31 ▁} ▁; ▁int ▁n ▁= ▁A ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁Check For Sequence ▁( ▁A ▁, ▁n ▁, ▁18 ▁) ▁? ▁" ▁True ▁" ▁: ▁" ▁False ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁Sub array Sum ▁( ▁int ▁[ ▁] ▁a ▁, ▁int ▁n ▁, ▁int ▁x ▁) ▁{ ▁int ▁ans ▁= ▁- ▁10000 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁int ▁cur ans ▁= ▁0 ▁; ▁ArrayList ▁< ▁Integer ▁> ▁pq ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁ArrayList ▁< ▁Integer ▁> ▁pq 2 ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁k ▁= ▁0 ▁; ▁k ▁< ▁n ▁; ▁k ▁++ ▁) ▁{ ▁if ▁( ▁k ▁>= ▁i ▁&& ▁k ▁<= ▁j ▁) ▁{ ▁cur ans ▁+= ▁a ▁[ ▁k ▁] ▁; ▁pq 2 ▁. ▁add ▁( ▁a ▁[ ▁k ▁] ▁) ▁; ▁} ▁else ▁pq ▁. ▁add ▁( ▁a ▁[ ▁k ▁] ▁) ▁; ▁} ▁Collections ▁. ▁sort ▁( ▁pq ▁) ▁; ▁Collections ▁. ▁reverse ▁( ▁pq ▁) ▁; ▁Collections ▁. ▁sort ▁( ▁pq 2 ▁) ▁; ▁ans ▁= ▁Math ▁. ▁max ▁( ▁ans ▁, ▁cur ans ▁) ▁; ▁for ▁( ▁int ▁k ▁= ▁1 ▁; ▁k ▁<= ▁x ▁; ▁k ▁++ ▁) ▁{ ▁if ▁( ▁pq ▁. ▁size ▁( ▁) ▁== ▁0 ▁|| ▁pq 2 ▁. ▁size ▁( ▁) ▁== ▁0 ▁|| ▁pq 2 ▁. ▁get ▁( ▁0 ▁) ▁>= ▁pq ▁. ▁get ▁( ▁0 ▁) ▁) ▁break ▁; ▁cur ans ▁-= ▁pq 2 ▁. ▁get ▁( ▁0 ▁) ▁; ▁pq 2 ▁. ▁remove ▁( ▁0 ▁) ▁; ▁cur ans ▁+= ▁pq ▁. ▁get ▁( ▁0 ▁) ▁; ▁pq ▁. ▁remove ▁( ▁0 ▁) ▁; ▁ans ▁= ▁Math ▁. ▁max ▁( ▁ans ▁, ▁cur ans ▁) ▁; ▁} ▁} ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁a ▁= ▁{ ▁5 ▁, ▁- ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁- ▁2 ▁, ▁5 ▁} ▁; ▁int ▁x ▁= ▁2 ▁; ▁int ▁n ▁= ▁a ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁Sub array Sum ▁( ▁a ▁, ▁n ▁, ▁x ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁generate Array ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁[ ▁] ▁array ▁= ▁new ▁int ▁[ ▁k ▁] ▁; ▁int ▁remaining ▁= ▁n ▁- ▁( ▁k ▁* ▁( ▁k ▁+ ▁1 ▁) ▁/ ▁2 ▁) ▁; ▁if ▁( ▁remaining ▁< ▁0 ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁NO ▁" ▁) ▁; ▁int ▁right _ most ▁= ▁remaining ▁% ▁k ▁; ▁int ▁high ▁= ▁( ▁int ▁) ▁Math ▁. ▁ceil ▁( ▁remaining ▁/ ▁( ▁k ▁* ▁1.0 ▁) ▁) ▁; ▁int ▁low ▁= ▁( ▁int ▁) ▁Math ▁. ▁floor ▁( ▁remaining ▁/ ▁( ▁k ▁* ▁1.0 ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁k ▁- ▁right _ most ▁; ▁i ▁< ▁k ▁; ▁i ▁++ ▁) ▁array ▁[ ▁i ▁] ▁= ▁high ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁( ▁k ▁- ▁right _ most ▁) ▁; ▁i ▁++ ▁) ▁array ▁[ ▁i ▁] ▁= ▁low ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁k ▁; ▁i ▁++ ▁) ▁array ▁[ ▁i ▁] ▁+= ▁i ▁+ ▁1 ▁; ▁if ▁( ▁k ▁- ▁1 ▁!= ▁remaining ▁k ▁== ▁1 ▁) ▁{ ▁for ▁( ▁int ▁u ▁: ▁array ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁u ▁+ ▁" ▁" ▁) ▁; ▁} ▁else ▁if ▁( ▁k ▁== ▁2 ▁k ▁== ▁3 ▁) ▁System ▁. ▁out ▁. ▁printf ▁( ▁" -1 NEW _ LINE "); ▁else ▁{ ▁array ▁[ ▁1 ▁] ▁-= ▁1 ▁; ▁array ▁[ ▁k ▁- ▁1 ▁] ▁+= ▁1 ▁; ▁for ▁( ▁int ▁u ▁: ▁array ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁u ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁26 ▁, ▁k ▁= ▁6 ▁; ▁generate Array ▁( ▁n ▁, ▁k ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁max Sub Strings ▁( ▁String ▁s ▁, ▁int ▁k ▁) ▁{ ▁int ▁max Sub Str ▁= ▁0 ▁, ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁for ▁( ▁int ▁c ▁= ▁0 ▁; ▁c ▁< ▁26 ▁; ▁c ▁++ ▁) ▁{ ▁char ▁ch ▁= ▁( ▁char ▁) ▁( ▁( ▁int ▁) ▁' ▁a ▁' ▁+ ▁c ▁) ▁; ▁int ▁curr ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁n ▁- ▁k ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁!= ▁ch ▁) ▁continue ▁; ▁int ▁cnt ▁= ▁0 ▁; ▁while ▁( ▁i ▁< ▁n ▁&& ▁s ▁. ▁charAt ▁( ▁i ▁) ▁== ▁ch ▁&& ▁cnt ▁!= ▁k ▁) ▁{ ▁i ▁++ ▁; ▁cnt ▁++ ▁; ▁} ▁i ▁-- ▁; ▁if ▁( ▁cnt ▁== ▁k ▁) ▁curr ▁++ ▁; ▁} ▁max Sub Str ▁= ▁Math ▁. ▁max ▁( ▁max Sub Str ▁, ▁curr ▁) ▁; ▁} ▁return ▁max Sub Str ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁s ▁= ▁" ▁aa ac a abb aa ▁" ▁; ▁int ▁k ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁max Sub Strings ▁( ▁s ▁, ▁k ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁min Cost ▁( ▁int ▁N ▁, ▁int ▁P ▁, ▁int ▁Q ▁) ▁{ ▁int ▁cost ▁= ▁0 ▁; ▁while ▁( ▁N ▁> ▁0 ▁) ▁{ ▁if ▁( ▁( ▁N ▁& ▁1 ▁) ▁> ▁0 ▁) ▁{ ▁cost ▁+= ▁P ▁; ▁N ▁-- ▁; ▁} ▁else ▁{ ▁int ▁temp ▁= ▁N ▁/ ▁2 ▁; ▁if ▁( ▁temp ▁* ▁P ▁> ▁Q ▁) ▁cost ▁+= ▁Q ▁; ▁else ▁cost ▁+= ▁P ▁* ▁temp ▁; ▁N ▁/= ▁2 ▁; ▁} ▁} ▁return ▁cost ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁9 ▁, ▁P ▁= ▁5 ▁, ▁Q ▁= ▁1 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁min Cost ▁( ▁N ▁, ▁P ▁, ▁Q ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁solve ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁b ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁i ▁; ▁int ▁s ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁s ▁+= ▁( ▁a ▁[ ▁i ▁] ▁+ ▁b ▁[ ▁i ▁] ▁) ▁; ▁if ▁( ▁n ▁== ▁1 ▁) ▁return ▁a ▁[ ▁0 ▁] ▁+ ▁b ▁[ ▁0 ▁] ▁; ▁if ▁( ▁s ▁% ▁n ▁!= ▁0 ▁) ▁return ▁- ▁1 ▁; ▁int ▁x ▁= ▁s ▁/ ▁n ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁> ▁x ▁) ▁return ▁- ▁1 ▁; ▁if ▁( ▁i ▁> ▁0 ▁) ▁{ ▁a ▁[ ▁i ▁] ▁+= ▁b ▁[ ▁i ▁- ▁1 ▁] ▁; ▁b ▁[ ▁i ▁- ▁1 ▁] ▁= ▁0 ▁; ▁} ▁if ▁( ▁a ▁[ ▁i ▁] ▁== ▁x ▁) ▁continue ▁; ▁int ▁y ▁= ▁a ▁[ ▁i ▁] ▁+ ▁b ▁[ ▁i ▁] ▁; ▁if ▁( ▁i ▁+ ▁1 ▁< ▁n ▁) ▁y ▁+= ▁b ▁[ ▁i ▁+ ▁1 ▁] ▁; ▁if ▁( ▁y ▁== ▁x ▁) ▁{ ▁a ▁[ ▁i ▁] ▁= ▁y ▁; ▁b ▁[ ▁i ▁] ▁= ▁0 ▁; ▁continue ▁; ▁} ▁if ▁( ▁a ▁[ ▁i ▁] ▁+ ▁b ▁[ ▁i ▁] ▁== ▁x ▁) ▁{ ▁a ▁[ ▁i ▁] ▁+= ▁b ▁[ ▁i ▁] ▁; ▁b ▁[ ▁i ▁] ▁= ▁0 ▁; ▁continue ▁; ▁} ▁if ▁( ▁i ▁+ ▁1 ▁< ▁n ▁&& ▁a ▁[ ▁i ▁] ▁+ ▁b ▁[ ▁i ▁+ ▁1 ▁] ▁== ▁x ▁) ▁{ ▁a ▁[ ▁i ▁] ▁+= ▁b ▁[ ▁i ▁+ ▁1 ▁] ▁; ▁b ▁[ ▁i ▁+ ▁1 ▁] ▁= ▁0 ▁; ▁continue ▁; ▁} ▁return ▁- ▁1 ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁b ▁[ ▁i ▁] ▁!= ▁0 ▁) ▁return ▁- ▁1 ▁; ▁return ▁x ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁6 ▁, ▁14 ▁, ▁21 ▁, ▁1 ▁} ▁; ▁int ▁b ▁[ ▁] ▁= ▁{ ▁15 ▁, ▁7 ▁, ▁10 ▁, ▁10 ▁} ▁; ▁int ▁n ▁= ▁a ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁solve ▁( ▁a ▁, ▁b ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁surv ival ▁( ▁int ▁S ▁, ▁int ▁N ▁, ▁int ▁M ▁) ▁{ ▁if ▁( ▁( ▁( ▁N ▁* ▁6 ▁) ▁< ▁( ▁M ▁* ▁7 ▁) ▁&& ▁S ▁> ▁6 ▁) ▁M ▁> ▁N ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁else ▁{ ▁int ▁days ▁= ▁( ▁M ▁* ▁S ▁) ▁/ ▁N ▁; ▁if ▁( ▁( ▁( ▁M ▁* ▁S ▁) ▁% ▁N ▁) ▁!= ▁0 ▁) ▁days ▁++ ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁+ ▁days ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁S ▁= ▁10 ▁, ▁N ▁= ▁16 ▁, ▁M ▁= ▁2 ▁; ▁surv ival ▁( ▁S ▁, ▁N ▁, ▁M ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁Long est Odd Even Sub array ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁dp ▁[ ▁] ▁= ▁new ▁int ▁[ ▁N ▁] ▁; ▁dp ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁int ▁ans ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁A ▁[ ▁i ▁] ▁% ▁2 ▁== ▁0 ▁&& ▁A ▁[ ▁i ▁- ▁1 ▁] ▁% ▁2 ▁== ▁0 ▁) ▁|| ▁( ▁A ▁[ ▁i ▁] ▁% ▁2 ▁!= ▁0 ▁&& ▁A ▁[ ▁i ▁- ▁1 ▁] ▁% ▁2 ▁!= ▁0 ▁) ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁1 ▁; ▁} ▁else ▁dp ▁[ ▁i ▁] ▁= ▁1 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁ans ▁= ▁Math ▁. ▁max ▁( ▁ans ▁, ▁dp ▁[ ▁i ▁] ▁) ▁; ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁5 ▁, ▁7 ▁, ▁2 ▁, ▁4 ▁, ▁6 ▁, ▁8 ▁, ▁3 ▁} ▁; ▁int ▁N ▁= ▁A ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁Long est Odd Even Sub array ▁( ▁A ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁public ▁class ▁Main ▁{ ▁static ▁int ▁getValue ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁N ▁) ▁{ ▁int ▁dp ▁[ ▁] ▁= ▁new ▁int ▁[ ▁N ▁] ▁; ▁dp ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁int ▁min ▁= ▁arr ▁[ ▁i ▁] ▁; ▁int ▁max ▁= ▁arr ▁[ ▁i ▁] ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁>= ▁0 ▁; ▁j ▁-- ▁) ▁{ ▁min ▁= ▁Math ▁. ▁min ▁( ▁arr ▁[ ▁j ▁] ▁, ▁min ▁) ▁; ▁max ▁= ▁Math ▁. ▁max ▁( ▁arr ▁[ ▁j ▁] ▁, ▁max ▁) ▁; ▁dp ▁[ ▁i ▁] ▁= ▁Math ▁. ▁max ▁( ▁dp ▁[ ▁i ▁] ▁, ▁max ▁- ▁min ▁+ ▁( ▁( ▁j ▁>= ▁1 ▁) ▁? ▁dp ▁[ ▁j ▁- ▁1 ▁] ▁: ▁0 ▁) ▁) ▁; ▁} ▁} ▁return ▁dp ▁[ ▁N ▁- ▁1 ▁] ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁8 ▁, ▁1 ▁, ▁7 ▁, ▁9 ▁, ▁2 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁getValue ▁( ▁arr ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁reduce Zero ▁( ▁int ▁N ▁) ▁{ ▁int ▁[ ▁] ▁dp ▁= ▁new ▁int ▁[ ▁N ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁dp ▁[ ▁i ▁] ▁= ▁( ▁int ▁) ▁1 e 9 ▁; ▁dp ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁char ▁c ▁: ▁String ▁. ▁valueOf ▁( ▁i ▁) ▁. ▁toCharArray ▁( ▁) ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁= ▁Math ▁. ▁min ▁( ▁dp ▁[ ▁i ▁] ▁, ▁dp ▁[ ▁i ▁- ▁( ▁c ▁- ▁'0' ▁) ▁] ▁+ ▁1 ▁) ▁; ▁} ▁} ▁return ▁dp ▁[ ▁N ▁] ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁25 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁reduce Zero ▁( ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁[ ▁] ▁prime ▁= ▁new ▁boolean ▁[ ▁10000 1 ▁] ▁; ▁static ▁void ▁S ieve Of E rat ost hen es ▁( ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁prime ▁. ▁length ▁; ▁i ▁++ ▁) ▁prime ▁[ ▁i ▁] ▁= ▁true ▁; ▁prime ▁[ ▁0 ▁] ▁= ▁prime ▁[ ▁1 ▁] ▁= ▁false ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁* ▁p ▁< ▁100000 ▁; ▁p ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁p ▁] ▁== ▁true ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁p ▁* ▁p ▁; ▁i ▁<= ▁100000 ▁; ▁i ▁+= ▁p ▁) ▁prime ▁[ ▁i ▁] ▁= ▁false ▁; ▁} ▁} ▁} ▁static ▁int ▁distinct Prime Sub Seq ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁S ieve Of E rat ost hen es ▁( ▁) ▁; ▁Vector ▁< ▁Integer ▁> ▁primes ▁= ▁new ▁Vector ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁a ▁[ ▁i ▁] ▁] ▁) ▁primes ▁. ▁add ▁( ▁a ▁[ ▁i ▁] ▁) ▁; ▁} ▁int ▁l ▁= ▁primes ▁. ▁size ▁( ▁) ▁; ▁Collections ▁. ▁sort ▁( ▁primes ▁) ▁; ▁Vector ▁< ▁Integer ▁> ▁b ▁= ▁new ▁Vector ▁< ▁> ▁( ▁) ▁; ▁Vector ▁< ▁Integer ▁> ▁dp ▁= ▁new ▁Vector ▁< ▁> ▁( ▁) ▁; ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁l ▁; ▁) ▁{ ▁int ▁count ▁= ▁1 ▁, ▁x ▁= ▁a ▁[ ▁i ▁] ▁; ▁i ▁++ ▁; ▁while ▁( ▁i ▁< ▁l ▁&& ▁a ▁[ ▁i ▁] ▁== ▁x ▁) ▁{ ▁count ▁++ ▁; ▁i ▁++ ▁; ▁} ▁b ▁. ▁add ▁( ▁count ▁) ▁; ▁dp ▁. ▁add ▁( ▁count ▁) ▁; ▁sum ▁+= ▁count ▁; ▁} ▁int ▁of _ length ▁= ▁2 ▁; ▁int ▁len ▁= ▁dp ▁. ▁size ▁( ▁) ▁; ▁int ▁ans ▁= ▁0 ▁; ▁while ▁( ▁of _ length ▁< ▁k ▁) ▁{ ▁int ▁freq ▁= ▁0 ▁; ▁int ▁prev ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁( ▁len ▁- ▁1 ▁) ▁; ▁i ▁++ ▁) ▁{ ▁freq ▁+= ▁dp ▁. ▁elementAt ▁( ▁i ▁) ▁; ▁int ▁j ▁= ▁sum ▁- ▁freq ▁; ▁int ▁sub seq ▁= ▁b ▁. ▁elementAt ▁( ▁i ▁) ▁* ▁j ▁; ▁ans ▁+= ▁sub seq ▁; ▁dp ▁. ▁add ▁( ▁i ▁, ▁sub seq ▁) ▁; ▁prev ▁+= ▁dp ▁. ▁elementAt ▁( ▁i ▁) ▁; ▁} ▁len ▁-- ▁; ▁sum ▁= ▁prev ▁; ▁of _ length ▁++ ▁; ▁} ▁ans ▁+= ▁( ▁l ▁+ ▁3 ▁) ▁; ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁2 ▁, ▁3 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁a ▁. ▁length ▁; ▁int ▁k ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁distinct Prime Sub Seq ▁( ▁a ▁, ▁n ▁, ▁k ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁mod ▁= ▁100 000000 7 ▁; ▁static ▁int ▁[ ▁] ▁[ ▁] ▁dp ▁= ▁new ▁int ▁[ ▁1000 ▁] ▁[ ▁1000 ▁] ▁; ▁static ▁int ▁calculate ▁( ▁int ▁pos ▁, ▁int ▁left ▁, ▁int ▁k ▁, ▁int ▁L ▁, ▁int ▁R ▁) ▁{ ▁if ▁( ▁pos ▁== ▁k ▁) ▁{ ▁if ▁( ▁left ▁== ▁0 ▁) ▁return ▁1 ▁; ▁else ▁return ▁0 ▁; ▁} ▁if ▁( ▁left ▁== ▁0 ▁) ▁return ▁0 ▁; ▁if ▁( ▁dp ▁[ ▁pos ▁] ▁[ ▁left ▁] ▁!= ▁- ▁1 ▁) ▁return ▁dp ▁[ ▁pos ▁] ▁[ ▁left ▁] ▁; ▁int ▁answer ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁L ▁; ▁i ▁<= ▁R ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁> ▁left ▁) ▁break ▁; ▁answer ▁= ▁( ▁answer ▁+ ▁calculate ▁( ▁pos ▁+ ▁1 ▁, ▁left ▁- ▁i ▁, ▁k ▁, ▁L ▁, ▁R ▁) ▁) ▁% ▁mod ▁; ▁} ▁return ▁dp ▁[ ▁pos ▁] ▁[ ▁left ▁] ▁= ▁answer ▁; ▁} ▁static ▁int ▁count Way sto Div ide ▁( ▁int ▁n ▁, ▁int ▁k ▁, ▁int ▁L ▁, ▁int ▁R ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁1000 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁1000 ▁; ▁j ▁++ ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁- ▁1 ▁; ▁} ▁} ▁return ▁calculate ▁( ▁0 ▁, ▁n ▁, ▁k ▁, ▁L ▁, ▁R ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁12 ▁; ▁int ▁K ▁= ▁3 ▁; ▁int ▁L ▁= ▁1 ▁; ▁int ▁R ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁count Way sto Div ide ▁( ▁N ▁, ▁K ▁, ▁L ▁, ▁R ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁largest Square ▁( ▁int ▁matrix ▁[ ▁] ▁[ ▁] ▁, ▁int ▁R ▁, ▁int ▁C ▁, ▁int ▁q _ i ▁[ ▁] ▁, ▁int ▁q _ j ▁[ ▁] ▁, ▁int ▁K ▁, ▁int ▁Q ▁) ▁{ ▁int ▁count DP ▁[ ▁] ▁[ ▁] ▁= ▁new ▁int ▁[ ▁R ▁] ▁[ ▁C ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁R ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁C ▁; ▁j ▁++ ▁) ▁count DP ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁0 ▁; ▁count DP ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁= ▁matrix ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁R ▁; ▁i ▁++ ▁) ▁count DP ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁= ▁count DP ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁0 ▁] ▁+ ▁matrix ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁< ▁C ▁; ▁j ▁++ ▁) ▁count DP ▁[ ▁0 ▁] ▁[ ▁j ▁] ▁= ▁count DP ▁[ ▁0 ▁] ▁[ ▁j ▁- ▁1 ▁] ▁+ ▁matrix ▁[ ▁0 ▁] ▁[ ▁j ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁R ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁< ▁C ▁; ▁j ▁++ ▁) ▁count DP ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁matrix ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+ ▁count DP ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁+ ▁count DP ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁- ▁count DP ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁- ▁1 ▁] ▁; ▁for ▁( ▁int ▁q ▁= ▁0 ▁; ▁q ▁< ▁Q ▁; ▁q ▁++ ▁) ▁{ ▁int ▁i ▁= ▁q _ i ▁[ ▁q ▁] ▁; ▁int ▁j ▁= ▁q _ j ▁[ ▁q ▁] ▁; ▁int ▁min _ dist ▁= ▁Math ▁. ▁min ▁( ▁Math ▁. ▁min ▁( ▁i ▁, ▁j ▁) ▁, ▁Math ▁. ▁min ▁( ▁R ▁- ▁i ▁- ▁1 ▁, ▁C ▁- ▁j ▁- ▁1 ▁) ▁) ▁; ▁int ▁ans ▁= ▁- ▁1 ▁, ▁l ▁= ▁0 ▁, ▁u ▁= ▁min _ dist ▁; ▁while ▁( ▁l ▁<= ▁u ▁) ▁{ ▁int ▁mid ▁= ▁( ▁l ▁+ ▁u ▁) ▁/ ▁2 ▁; ▁int ▁x 1 ▁= ▁i ▁- ▁mid ▁, ▁x 2 ▁= ▁i ▁+ ▁mid ▁; ▁int ▁y 1 ▁= ▁j ▁- ▁mid ▁, ▁y 2 ▁= ▁j ▁+ ▁mid ▁; ▁int ▁count ▁= ▁count DP ▁[ ▁x 2 ▁] ▁[ ▁y 2 ▁] ▁; ▁if ▁( ▁x 1 ▁> ▁0 ▁) ▁count ▁-= ▁count DP ▁[ ▁x 1 ▁- ▁1 ▁] ▁[ ▁y 2 ▁] ▁; ▁if ▁( ▁y 1 ▁> ▁0 ▁) ▁count ▁-= ▁count DP ▁[ ▁x 2 ▁] ▁[ ▁y 1 ▁- ▁1 ▁] ▁; ▁if ▁( ▁x 1 ▁> ▁0 ▁&& ▁y 1 ▁> ▁0 ▁) ▁count ▁+= ▁count DP ▁[ ▁x 1 ▁- ▁1 ▁] ▁[ ▁y 1 ▁- ▁1 ▁] ▁; ▁if ▁( ▁count ▁<= ▁K ▁) ▁{ ▁ans ▁= ▁2 ▁* ▁mid ▁+ ▁1 ▁; ▁l ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁else ▁u ▁= ▁mid ▁- ▁1 ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁ans ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁matrix ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁} ▁} ▁; ▁int ▁K ▁= ▁9 ▁, ▁Q ▁= ▁1 ▁; ▁int ▁q _ i ▁[ ▁] ▁= ▁{ ▁1 ▁} ▁; ▁int ▁q _ j ▁[ ▁] ▁= ▁{ ▁2 ▁} ▁; ▁largest Square ▁( ▁matrix ▁, ▁4 ▁, ▁5 ▁, ▁q _ i ▁, ▁q _ j ▁, ▁K ▁, ▁Q ▁) ▁; ▁} ▁}
