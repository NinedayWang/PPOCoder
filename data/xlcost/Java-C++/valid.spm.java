▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁calculate Span ▁( ▁int ▁price ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁S ▁[ ▁] ▁) ▁{ ▁S ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁S ▁[ ▁i ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁- ▁1 ▁; ▁( ▁j ▁>= ▁0 ▁) ▁&& ▁( ▁price ▁[ ▁i ▁] ▁>= ▁price ▁[ ▁j ▁] ▁) ▁; ▁j ▁-- ▁) ▁S ▁[ ▁i ▁] ▁++ ▁; ▁} ▁} ▁static ▁void ▁print Array ▁( ▁int ▁arr ▁[ ▁] ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁Arrays ▁. ▁toString ▁( ▁arr ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁price ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁4 ▁, ▁5 ▁, ▁90 ▁, ▁120 ▁, ▁80 ▁} ▁; ▁int ▁n ▁= ▁price ▁. ▁length ▁; ▁int ▁S ▁[ ▁] ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁calculate Span ▁( ▁price ▁, ▁n ▁, ▁S ▁) ▁; ▁print Array ▁( ▁S ▁) ▁; ▁} ▁}
▁class ▁Main ▁{ ▁static ▁void ▁print NG E ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁next ▁, ▁i ▁, ▁j ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁next ▁= ▁- ▁1 ▁; ▁for ▁( ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁arr ▁[ ▁j ▁] ▁) ▁{ ▁next ▁= ▁arr ▁[ ▁j ▁] ▁; ▁break ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁" ▁- ▁- ▁" ▁+ ▁next ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁11 ▁, ▁13 ▁, ▁21 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁print NG E ▁( ▁arr ▁, ▁n ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁Stack ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁Print Min Number For Pattern ▁( ▁String ▁seq ▁) ▁{ ▁String ▁result ▁= ▁" ▁" ▁; ▁Stack ▁< ▁Integer ▁> ▁st k ▁= ▁new ▁Stack ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁seq ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁st k ▁. ▁push ▁( ▁i ▁+ ▁1 ▁) ▁; ▁if ▁( ▁i ▁== ▁seq ▁. ▁length ▁( ▁) ▁|| ▁seq ▁. ▁charAt ▁( ▁i ▁) ▁== ▁' ▁I ▁' ▁) ▁{ ▁while ▁( ▁! ▁st k ▁. ▁empty ▁( ▁) ▁) ▁{ ▁result ▁+= ▁String ▁. ▁valueOf ▁( ▁st k ▁. ▁peek ▁( ▁) ▁) ▁; ▁result ▁+= ▁" ▁" ▁; ▁st k ▁. ▁pop ▁( ▁) ▁; ▁} ▁} ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁result ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Print Min Number For Pattern ▁( ▁" ▁ID ID ▁" ▁) ▁; ▁Print Min Number For Pattern ▁( ▁" ▁I ▁" ▁) ▁; ▁Print Min Number For Pattern ▁( ▁" ▁DD ▁" ▁) ▁; ▁Print Min Number For Pattern ▁( ▁" ▁II ▁" ▁) ▁; ▁Print Min Number For Pattern ▁( ▁" ▁D ID I ▁" ▁) ▁; ▁Print Min Number For Pattern ▁( ▁" ▁I ID DD ▁" ▁) ▁; ▁Print Min Number For Pattern ▁( ▁" ▁DD ID DI ID ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁HashMap ▁; ▁import ▁java ▁. ▁util ▁. ▁Map ▁; ▁import ▁java ▁. ▁util ▁. ▁Map ▁. ▁Entry ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁most F requ ent ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁Map ▁< ▁Integer ▁, ▁Integer ▁> ▁hp ▁= ▁new ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁key ▁= ▁arr ▁[ ▁i ▁] ▁; ▁if ▁( ▁hp ▁. ▁containsKey ▁( ▁key ▁) ▁) ▁{ ▁int ▁freq ▁= ▁hp ▁. ▁get ▁( ▁key ▁) ▁; ▁freq ▁++ ▁; ▁hp ▁. ▁put ▁( ▁key ▁, ▁freq ▁) ▁; ▁} ▁else ▁{ ▁hp ▁. ▁put ▁( ▁key ▁, ▁1 ▁) ▁; ▁} ▁} ▁int ▁max _ count ▁= ▁0 ▁, ▁res ▁= ▁- ▁1 ▁; ▁for ▁( ▁Entry ▁< ▁Integer ▁, ▁Integer ▁> ▁val ▁: ▁hp ▁. ▁entrySet ▁( ▁) ▁) ▁{ ▁if ▁( ▁max _ count ▁< ▁val ▁. ▁getValue ▁( ▁) ▁) ▁{ ▁res ▁= ▁val ▁. ▁getKey ▁( ▁) ▁; ▁max _ count ▁= ▁val ▁. ▁getValue ▁( ▁) ▁; ▁} ▁} ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁5 ▁, ▁2 ▁, ▁1 ▁, ▁3 ▁, ▁2 ▁, ▁1 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁most F requ ent ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁HashSet ▁; ▁import ▁java ▁. ▁util ▁. ▁Set ▁; ▁public ▁class ▁G f G ▁{ ▁static ▁void ▁find Missing ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁b ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁HashSet ▁< ▁Integer ▁> ▁s ▁= ▁new ▁HashSet ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁m ▁; ▁i ▁++ ▁) ▁s ▁. ▁add ▁( ▁b ▁[ ▁i ▁] ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁! ▁s ▁. ▁contains ▁( ▁a ▁[ ▁i ▁] ▁) ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁a ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁6 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁b ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁4 ▁, ▁3 ▁, ▁1 ▁, ▁0 ▁} ▁; ▁int ▁n ▁= ▁a ▁. ▁length ▁; ▁int ▁m ▁= ▁b ▁. ▁length ▁; ▁find Missing ▁( ▁a ▁, ▁b ▁, ▁n ▁, ▁m ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁public ▁class ▁G f G ▁{ ▁public ▁static ▁int ▁subset ▁( ▁int ▁ar ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁res ▁= ▁0 ▁; ▁Arrays ▁. ▁sort ▁( ▁ar ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁count ▁= ▁1 ▁; ▁for ▁( ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁ar ▁[ ▁i ▁] ▁== ▁ar ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁count ▁++ ▁; ▁else ▁break ▁; ▁} ▁res ▁= ▁Math ▁. ▁max ▁( ▁res ▁, ▁count ▁) ▁; ▁} ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁arg c ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁6 ▁, ▁9 ▁, ▁3 ▁, ▁4 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁n ▁= ▁7 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁subset ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁make Perm utation ▁( ▁int ▁[ ▁] ▁a ▁, ▁int ▁n ▁) ▁{ ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁count ▁= ▁new ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁count ▁. ▁containsKey ▁( ▁a ▁[ ▁i ▁] ▁) ▁) ▁{ ▁count ▁. ▁put ▁( ▁a ▁[ ▁i ▁] ▁, ▁count ▁. ▁get ▁( ▁a ▁[ ▁i ▁] ▁) ▁+ ▁1 ▁) ▁; ▁} ▁else ▁{ ▁count ▁. ▁put ▁( ▁a ▁[ ▁i ▁] ▁, ▁1 ▁) ▁; ▁} ▁} ▁int ▁next _ missing ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁count ▁. ▁containsKey ▁( ▁a ▁[ ▁i ▁] ▁) ▁&& ▁count ▁. ▁get ▁( ▁a ▁[ ▁i ▁] ▁) ▁!= ▁1 ▁a ▁[ ▁i ▁] ▁> ▁n ▁a ▁[ ▁i ▁] ▁< ▁1 ▁) ▁{ ▁count ▁. ▁put ▁( ▁a ▁[ ▁i ▁] ▁, ▁count ▁. ▁get ▁( ▁a ▁[ ▁i ▁] ▁) ▁- ▁1 ▁) ▁; ▁while ▁( ▁count ▁. ▁containsKey ▁( ▁next _ missing ▁) ▁) ▁next _ missing ▁++ ▁; ▁a ▁[ ▁i ▁] ▁= ▁next _ missing ▁; ▁count ▁. ▁put ▁( ▁next _ missing ▁, ▁1 ▁) ▁; ▁} ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁2 ▁, ▁3 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁A ▁. ▁length ▁; ▁make Perm utation ▁( ▁A ▁, ▁n ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁A ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁Solution ▁{ ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁2 ▁, ▁- ▁2 ▁, ▁- ▁20 ▁, ▁10 ▁} ▁; ▁int ▁k ▁= ▁- ▁10 ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁int ▁res ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁sum ▁+= ▁arr ▁[ ▁j ▁] ▁; ▁if ▁( ▁sum ▁== ▁k ▁) ▁res ▁++ ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁res ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁void ▁find Pairs ▁( ▁int ▁arr 1 ▁[ ▁] ▁, ▁int ▁arr 2 ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁m ▁, ▁int ▁x ▁) ▁{ ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁s ▁= ▁new ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁s ▁. ▁put ▁( ▁arr 1 ▁[ ▁i ▁] ▁, ▁0 ▁) ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁m ▁; ▁j ▁++ ▁) ▁if ▁( ▁s ▁. ▁containsKey ▁( ▁x ▁- ▁arr 2 ▁[ ▁j ▁] ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁x ▁- ▁arr 2 ▁[ ▁j ▁] ▁+ ▁" ▁" ▁+ ▁arr 2 ▁[ ▁j ▁] ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr 1 ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁0 ▁, ▁- ▁4 ▁, ▁7 ▁, ▁6 ▁, ▁4 ▁} ▁; ▁int ▁arr 2 ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁2 ▁, ▁4 ▁, ▁- ▁3 ▁, ▁2 ▁, ▁1 ▁} ▁; ▁int ▁x ▁= ▁8 ▁; ▁find Pairs ▁( ▁arr 1 ▁, ▁arr 2 ▁, ▁arr 1 ▁. ▁length ▁, ▁arr 2 ▁. ▁length ▁, ▁x ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁boolean ▁find Tri plet ▁( ▁int ▁a 1 ▁[ ▁] ▁, ▁int ▁a 2 ▁[ ▁] ▁, ▁int ▁a 3 ▁[ ▁] ▁, ▁int ▁n 1 ▁, ▁int ▁n 2 ▁, ▁int ▁n 3 ▁, ▁int ▁sum ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n 1 ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n 2 ▁; ▁j ▁++ ▁) ▁for ▁( ▁int ▁k ▁= ▁0 ▁; ▁k ▁< ▁n 3 ▁; ▁k ▁++ ▁) ▁if ▁( ▁a 1 ▁[ ▁i ▁] ▁+ ▁a 2 ▁[ ▁j ▁] ▁+ ▁a 3 ▁[ ▁k ▁] ▁== ▁sum ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a 1 ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁a 2 ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁6 ▁, ▁1 ▁, ▁2 ▁} ▁; ▁int ▁a 3 ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁2 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁int ▁sum ▁= ▁9 ▁; ▁int ▁n 1 ▁= ▁a 1 ▁. ▁length ▁; ▁int ▁n 2 ▁= ▁a 2 ▁. ▁length ▁; ▁int ▁n 3 ▁= ▁a 3 ▁. ▁length ▁; ▁if ▁( ▁find Tri plet ▁( ▁a 1 ▁, ▁a 2 ▁, ▁a 3 ▁, ▁n 1 ▁, ▁n 2 ▁, ▁n 3 ▁, ▁sum ▁) ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁longest ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁[ ▁] ▁freq ▁= ▁new ▁int ▁[ ▁7 ▁] ▁; ▁int ▁start ▁= ▁0 ▁, ▁end ▁= ▁0 ▁, ▁now ▁= ▁0 ▁, ▁l ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁freq ▁[ ▁a ▁[ ▁i ▁] ▁] ▁++ ▁; ▁if ▁( ▁freq ▁[ ▁a ▁[ ▁i ▁] ▁] ▁== ▁1 ▁) ▁now ▁++ ▁; ▁while ▁( ▁now ▁> ▁k ▁) ▁{ ▁freq ▁[ ▁a ▁[ ▁l ▁] ▁] ▁-- ▁; ▁if ▁( ▁freq ▁[ ▁a ▁[ ▁l ▁] ▁] ▁== ▁0 ▁) ▁now ▁-- ▁; ▁l ▁++ ▁; ▁} ▁if ▁( ▁i ▁- ▁l ▁+ ▁1 ▁>= ▁end ▁- ▁start ▁+ ▁1 ▁) ▁{ ▁end ▁= ▁i ▁; ▁start ▁= ▁l ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁start ▁; ▁i ▁<= ▁end ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁a ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁6 ▁, ▁5 ▁, ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁2 ▁, ▁1 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁a ▁. ▁length ▁; ▁int ▁k ▁= ▁3 ▁; ▁longest ▁( ▁a ▁, ▁n ▁, ▁k ▁) ▁; ▁} ▁}
▁class ▁L argest Sub Array ▁{ ▁int ▁find Sub Array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁int ▁maxsize ▁= ▁- ▁1 ▁, ▁start index ▁= ▁0 ▁; ▁int ▁end index ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁= ▁( ▁arr ▁[ ▁i ▁] ▁== ▁0 ▁) ▁? ▁- ▁1 ▁: ▁1 ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁j ▁] ▁== ▁0 ▁) ▁sum ▁+= ▁- ▁1 ▁; ▁else ▁sum ▁+= ▁1 ▁; ▁if ▁( ▁sum ▁== ▁0 ▁&& ▁maxsize ▁< ▁j ▁- ▁i ▁+ ▁1 ▁) ▁{ ▁maxsize ▁= ▁j ▁- ▁i ▁+ ▁1 ▁; ▁start index ▁= ▁i ▁; ▁} ▁} ▁} ▁end index ▁= ▁start index ▁+ ▁maxsize ▁- ▁1 ▁; ▁if ▁( ▁maxsize ▁== ▁- ▁1 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁such ▁sub array ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁start index ▁+ ▁" ▁to ▁" ▁+ ▁end index ▁) ▁; ▁return ▁maxsize ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁L argest Sub Array ▁sub ▁; ▁sub ▁= ▁new ▁L argest Sub Array ▁( ▁) ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁} ▁; ▁int ▁size ▁= ▁arr ▁. ▁length ▁; ▁sub ▁. ▁find Sub Array ▁( ▁arr ▁, ▁size ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁findAll Tri pl ets ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁- ▁1 ▁, ▁k ▁= ▁i ▁+ ▁1 ▁; ▁j ▁>= ▁0 ▁&& ▁k ▁< ▁n ▁; ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁j ▁] ▁+ ▁arr ▁[ ▁k ▁] ▁== ▁2 ▁* ▁arr ▁[ ▁i ▁] ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁arr ▁[ ▁j ▁] ▁+ ▁" ▁" ▁+ ▁arr ▁[ ▁i ▁] ▁+ ▁" ▁" ▁+ ▁arr ▁[ ▁k ▁] ▁) ▁; ▁k ▁++ ▁; ▁j ▁-- ▁; ▁} ▁else ▁if ▁( ▁arr ▁[ ▁j ▁] ▁+ ▁arr ▁[ ▁k ▁] ▁< ▁2 ▁* ▁arr ▁[ ▁i ▁] ▁) ▁k ▁++ ▁; ▁else ▁j ▁-- ▁; ▁} ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁6 ▁, ▁9 ▁, ▁12 ▁, ▁17 ▁, ▁22 ▁, ▁31 ▁, ▁32 ▁, ▁35 ▁, ▁42 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁findAll Tri pl ets ▁( ▁arr ▁, ▁n ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁public ▁class ▁Main ▁{ ▁public ▁static ▁void ▁find Tri pl ets ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁sum ▁) ▁{ ▁int ▁i ▁; ▁Arrays ▁. ▁sort ▁( ▁a ▁) ▁; ▁boolean ▁flag ▁= ▁false ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁== ▁0 ▁a ▁[ ▁i ▁] ▁> ▁a ▁[ ▁i ▁- ▁1 ▁] ▁) ▁{ ▁int ▁start ▁= ▁i ▁+ ▁1 ▁; ▁int ▁end ▁= ▁n ▁- ▁1 ▁; ▁int ▁target ▁= ▁sum ▁- ▁a ▁[ ▁i ▁] ▁; ▁while ▁( ▁start ▁< ▁end ▁) ▁{ ▁if ▁( ▁start ▁> ▁i ▁+ ▁1 ▁&& ▁a ▁[ ▁start ▁] ▁== ▁a ▁[ ▁start ▁- ▁1 ▁] ▁) ▁{ ▁start ▁++ ▁; ▁continue ▁; ▁} ▁if ▁( ▁end ▁< ▁n ▁- ▁1 ▁&& ▁a ▁[ ▁end ▁] ▁== ▁a ▁[ ▁end ▁+ ▁1 ▁] ▁) ▁{ ▁end ▁-- ▁; ▁continue ▁; ▁} ▁if ▁( ▁target ▁== ▁a ▁[ ▁start ▁] ▁+ ▁a ▁[ ▁end ▁] ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁[ ▁" ▁+ ▁a ▁[ ▁i ▁] ▁+ ▁" ▁, ▁" ▁+ ▁a ▁[ ▁start ▁] ▁+ ▁" ▁, ▁" ▁+ ▁a ▁[ ▁end ▁] ▁+ ▁" ▁] ▁" ▁) ▁; ▁flag ▁= ▁true ▁; ▁start ▁++ ▁; ▁end ▁-- ▁; ▁} ▁else ▁if ▁( ▁target ▁> ▁( ▁a ▁[ ▁start ▁] ▁+ ▁a ▁[ ▁end ▁] ▁) ▁) ▁{ ▁start ▁++ ▁; ▁} ▁else ▁{ ▁end ▁-- ▁; ▁} ▁} ▁} ▁} ▁if ▁( ▁flag ▁== ▁false ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁No ▁Such ▁Tri pl ets ▁Ex ist ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁12 ▁, ▁3 ▁, ▁6 ▁, ▁1 ▁, ▁6 ▁, ▁9 ▁} ▁; ▁int ▁n ▁= ▁a ▁. ▁length ▁; ▁int ▁sum ▁= ▁24 ▁; ▁find Tri pl ets ▁( ▁a ▁, ▁n ▁, ▁sum ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁count Tri pl ets ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁2 ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁- ▁1 ▁; ▁j ▁++ ▁) ▁for ▁( ▁int ▁k ▁= ▁j ▁+ ▁1 ▁; ▁k ▁< ▁n ▁; ▁k ▁++ ▁) ▁if ▁( ▁arr ▁[ ▁i ▁] ▁* ▁arr ▁[ ▁j ▁] ▁* ▁arr ▁[ ▁k ▁] ▁== ▁m ▁) ▁count ▁++ ▁; ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁4 ▁, ▁6 ▁, ▁2 ▁, ▁3 ▁, ▁8 ▁} ▁; ▁int ▁m ▁= ▁24 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Tri pl ets ▁( ▁arr ▁, ▁arr ▁. ▁length ▁, ▁m ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁g eek s ▁{ ▁public ▁static ▁int ▁sum of length ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁n ▁) ▁{ ▁Set ▁< ▁Integer ▁> ▁s ▁= ▁new ▁HashSet ▁< ▁> ▁( ▁) ▁; ▁int ▁j ▁= ▁0 ▁, ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁while ▁( ▁j ▁< ▁n ▁&& ▁! ▁s ▁. ▁contains ▁( ▁arr ▁[ ▁j ▁] ▁) ▁) ▁{ ▁s ▁. ▁add ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁j ▁++ ▁; ▁} ▁ans ▁+= ▁( ▁( ▁j ▁- ▁i ▁) ▁* ▁( ▁j ▁- ▁i ▁+ ▁1 ▁) ▁) ▁/ ▁2 ▁; ▁s ▁. ▁remove ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁sum of length ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁Rot ate Array ▁{ ▁void ▁left Rotate by One ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁i ▁, ▁temp ▁; ▁temp ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁arr ▁[ ▁i ▁] ▁= ▁arr ▁[ ▁i ▁+ ▁1 ▁] ▁; ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁= ▁temp ▁; ▁} ▁void ▁left Rotate ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁d ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁d ▁; ▁i ▁++ ▁) ▁left Rotate by One ▁( ▁arr ▁, ▁n ▁) ▁; ▁} ▁void ▁print Array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Rot ate Array ▁rotate ▁= ▁new ▁Rot ate Array ▁( ▁) ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁, ▁7 ▁} ▁; ▁rotate ▁. ▁left Rotate ▁( ▁arr ▁, ▁2 ▁, ▁7 ▁) ▁; ▁rotate ▁. ▁print Array ▁( ▁arr ▁, ▁7 ▁) ▁; ▁} ▁}
▁class ▁Main ▁{ ▁static ▁int ▁search ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁l ▁, ▁int ▁h ▁, ▁int ▁key ▁) ▁{ ▁if ▁( ▁l ▁> ▁h ▁) ▁return ▁- ▁1 ▁; ▁int ▁mid ▁= ▁( ▁l ▁+ ▁h ▁) ▁/ ▁2 ▁; ▁if ▁( ▁arr ▁[ ▁mid ▁] ▁== ▁key ▁) ▁return ▁mid ▁; ▁if ▁( ▁arr ▁[ ▁l ▁] ▁<= ▁arr ▁[ ▁mid ▁] ▁) ▁{ ▁if ▁( ▁key ▁>= ▁arr ▁[ ▁l ▁] ▁&& ▁key ▁<= ▁arr ▁[ ▁mid ▁] ▁) ▁return ▁search ▁( ▁arr ▁, ▁l ▁, ▁mid ▁- ▁1 ▁, ▁key ▁) ▁; ▁return ▁search ▁( ▁arr ▁, ▁mid ▁+ ▁1 ▁, ▁h ▁, ▁key ▁) ▁; ▁} ▁if ▁( ▁key ▁>= ▁arr ▁[ ▁mid ▁] ▁&& ▁key ▁<= ▁arr ▁[ ▁h ▁] ▁) ▁return ▁search ▁( ▁arr ▁, ▁mid ▁+ ▁1 ▁, ▁h ▁, ▁key ▁) ▁; ▁return ▁search ▁( ▁arr ▁, ▁l ▁, ▁mid ▁- ▁1 ▁, ▁key ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁5 ▁, ▁6 ▁, ▁7 ▁, ▁8 ▁, ▁9 ▁, ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁int ▁key ▁= ▁6 ▁; ▁int ▁i ▁= ▁search ▁( ▁arr ▁, ▁0 ▁, ▁n ▁- ▁1 ▁, ▁key ▁) ▁; ▁if ▁( ▁i ▁!= ▁- ▁1 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Index ▁: ▁" ▁+ ▁i ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Key ▁not ▁found ▁" ▁) ▁; ▁} ▁}
▁class ▁Pair In Sorted Rot ated ▁{ ▁static ▁boolean ▁pair In Sorted Rot ated ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁x ▁) ▁{ ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁arr ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁break ▁; ▁int ▁l ▁= ▁( ▁i ▁+ ▁1 ▁) ▁% ▁n ▁; ▁int ▁r ▁= ▁i ▁; ▁while ▁( ▁l ▁!= ▁r ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁l ▁] ▁+ ▁arr ▁[ ▁r ▁] ▁== ▁x ▁) ▁return ▁true ▁; ▁if ▁( ▁arr ▁[ ▁l ▁] ▁+ ▁arr ▁[ ▁r ▁] ▁< ▁x ▁) ▁l ▁= ▁( ▁l ▁+ ▁1 ▁) ▁% ▁n ▁; ▁else ▁r ▁= ▁( ▁n ▁+ ▁r ▁- ▁1 ▁) ▁% ▁n ▁; ▁} ▁return ▁false ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁11 ▁, ▁15 ▁, ▁6 ▁, ▁8 ▁, ▁9 ▁, ▁10 ▁} ▁; ▁int ▁sum ▁= ▁16 ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁if ▁( ▁pair In Sorted Rot ated ▁( ▁arr ▁, ▁n ▁, ▁sum ▁) ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Array ▁has ▁two ▁elements ▁" ▁+ ▁" ▁with ▁sum ▁16 " ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Array ▁doesn ▁' ▁t ▁have ▁two ▁" ▁+ ▁" ▁elements ▁with ▁sum ▁16 ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁left Rotate ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁k ▁; ▁i ▁< ▁k ▁+ ▁n ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁i ▁% ▁n ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁5 ▁, ▁7 ▁, ▁9 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁int ▁k ▁= ▁2 ▁; ▁left Rotate ▁( ▁arr ▁, ▁n ▁, ▁k ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁k ▁= ▁3 ▁; ▁left Rotate ▁( ▁arr ▁, ▁n ▁, ▁k ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁k ▁= ▁4 ▁; ▁left Rotate ▁( ▁arr ▁, ▁n ▁, ▁k ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁Minimum ▁{ ▁static ▁int ▁find Min ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁low ▁, ▁int ▁high ▁) ▁{ ▁if ▁( ▁high ▁< ▁low ▁) ▁return ▁arr ▁[ ▁0 ▁] ▁; ▁if ▁( ▁high ▁== ▁low ▁) ▁return ▁arr ▁[ ▁low ▁] ▁; ▁int ▁mid ▁= ▁low ▁+ ▁( ▁high ▁- ▁low ▁) ▁/ ▁2 ▁; ▁if ▁( ▁mid ▁< ▁high ▁&& ▁arr ▁[ ▁mid ▁+ ▁1 ▁] ▁< ▁arr ▁[ ▁mid ▁] ▁) ▁return ▁arr ▁[ ▁mid ▁+ ▁1 ▁] ▁; ▁if ▁( ▁mid ▁> ▁low ▁&& ▁arr ▁[ ▁mid ▁] ▁< ▁arr ▁[ ▁mid ▁- ▁1 ▁] ▁) ▁return ▁arr ▁[ ▁mid ▁] ▁; ▁if ▁( ▁arr ▁[ ▁high ▁] ▁> ▁arr ▁[ ▁mid ▁] ▁) ▁return ▁find Min ▁( ▁arr ▁, ▁low ▁, ▁mid ▁- ▁1 ▁) ▁; ▁return ▁find Min ▁( ▁arr ▁, ▁mid ▁+ ▁1 ▁, ▁high ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr 1 ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁6 ▁, ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁n 1 ▁= ▁arr 1 ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁The ▁minimum ▁element ▁is ▁" ▁+ ▁find Min ▁( ▁arr 1 ▁, ▁0 ▁, ▁n 1 ▁- ▁1 ▁) ▁) ▁; ▁int ▁arr 2 ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁n 2 ▁= ▁arr 2 ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁The ▁minimum ▁element ▁is ▁" ▁+ ▁find Min ▁( ▁arr 2 ▁, ▁0 ▁, ▁n 2 ▁- ▁1 ▁) ▁) ▁; ▁int ▁arr 3 ▁[ ▁] ▁= ▁{ ▁1 ▁} ▁; ▁int ▁n 3 ▁= ▁arr 3 ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁The ▁minimum ▁element ▁is ▁" ▁+ ▁find Min ▁( ▁arr 3 ▁, ▁0 ▁, ▁n 3 ▁- ▁1 ▁) ▁) ▁; ▁int ▁arr 4 ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁} ▁; ▁int ▁n 4 ▁= ▁arr 4 ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁The ▁minimum ▁element ▁is ▁" ▁+ ▁find Min ▁( ▁arr 4 ▁, ▁0 ▁, ▁n 4 ▁- ▁1 ▁) ▁) ▁; ▁int ▁arr 5 ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁1 ▁} ▁; ▁int ▁n 5 ▁=
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁void ▁Split And Add ▁( ▁int ▁[ ▁] ▁A ▁, ▁int ▁length ▁, ▁int ▁rotation ▁) ▁{ ▁int ▁[ ▁] ▁tmp ▁= ▁new ▁int ▁[ ▁length ▁* ▁2 ▁] ▁; ▁System ▁. ▁arraycopy ▁( ▁A ▁, ▁0 ▁, ▁tmp ▁, ▁0 ▁, ▁length ▁) ▁; ▁System ▁. ▁arraycopy ▁( ▁A ▁, ▁0 ▁, ▁tmp ▁, ▁length ▁, ▁length ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁rotation ▁; ▁i ▁< ▁rotation ▁+ ▁length ▁; ▁i ▁++ ▁) ▁A ▁[ ▁i ▁- ▁rotation ▁] ▁= ▁tmp ▁[ ▁i ▁] ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁12 ▁, ▁10 ▁, ▁5 ▁, ▁6 ▁, ▁52 ▁, ▁36 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁int ▁position ▁= ▁2 ▁; ▁Split And Add ▁( ▁arr ▁, ▁n ▁, ▁position ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁print Array ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁size ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁A ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁" ▁) ▁; ▁; ▁} ▁static ▁void ▁reverse ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁l ▁, ▁int ▁r ▁) ▁{ ▁if ▁( ▁l ▁< ▁r ▁) ▁{ ▁arr ▁= ▁swap ▁( ▁arr ▁, ▁l ▁, ▁r ▁) ▁; ▁reverse ▁( ▁arr ▁, ▁++ ▁l ▁, ▁-- ▁r ▁) ▁; ▁} ▁} ▁static ▁void ▁merge ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁l ▁, ▁int ▁m ▁, ▁int ▁r ▁) ▁{ ▁int ▁i ▁= ▁l ▁; ▁int ▁j ▁= ▁m ▁+ ▁1 ▁; ▁while ▁( ▁i ▁<= ▁m ▁&& ▁arr ▁[ ▁i ▁] ▁< ▁0 ▁) ▁i ▁++ ▁; ▁while ▁( ▁j ▁<= ▁r ▁&& ▁arr ▁[ ▁j ▁] ▁< ▁0 ▁) ▁j ▁++ ▁; ▁reverse ▁( ▁arr ▁, ▁i ▁, ▁m ▁) ▁; ▁reverse ▁( ▁arr ▁, ▁m ▁+ ▁1 ▁, ▁j ▁- ▁1 ▁) ▁; ▁reverse ▁( ▁arr ▁, ▁i ▁, ▁j ▁- ▁1 ▁) ▁; ▁} ▁static ▁void ▁R ear range Pos Neg ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁l ▁, ▁int ▁r ▁) ▁{ ▁if ▁( ▁l ▁< ▁r ▁) ▁{ ▁int ▁m ▁= ▁l ▁+ ▁( ▁r ▁- ▁l ▁) ▁/ ▁2 ▁; ▁R ear range Pos Neg ▁( ▁arr ▁, ▁l ▁, ▁m ▁) ▁; ▁R ear range Pos Neg ▁( ▁arr ▁, ▁m ▁+ ▁1 ▁, ▁r ▁) ▁; ▁merge ▁( ▁arr ▁, ▁l ▁, ▁m ▁, ▁r ▁) ▁; ▁} ▁} ▁static ▁int ▁[ ▁] ▁swap ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁i ▁, ▁int ▁j ▁) ▁{ ▁int ▁temp ▁= ▁arr ▁[ ▁i ▁] ▁; ▁arr ▁[ ▁i ▁] ▁= ▁arr ▁[ ▁j ▁] ▁; ▁arr ▁[ ▁j ▁] ▁= ▁temp ▁; ▁return ▁arr ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁- ▁12 ▁, ▁11 ▁, ▁- ▁13 ▁, ▁- ▁5 ▁, ▁6 ▁, ▁- ▁7 ▁, ▁5 ▁, ▁- ▁3 ▁, ▁- ▁6 ▁} ▁; ▁int ▁arr _ size ▁= ▁arr ▁. ▁length ▁; ▁R ear range Pos Neg ▁( ▁arr ▁, ▁0 ▁, ▁arr _ size ▁- ▁1 ▁) ▁;
▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁public ▁class ▁G F G ▁{ ▁static ▁void ▁re arrange ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁n ▁) ▁{ ▁int ▁temp ▁[ ▁] ▁= ▁arr ▁. ▁clone ▁( ▁) ▁; ▁int ▁small ▁= ▁0 ▁, ▁large ▁= ▁n ▁- ▁1 ▁; ▁boolean ▁flag ▁= ▁true ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁flag ▁) ▁arr ▁[ ▁i ▁] ▁= ▁temp ▁[ ▁large ▁-- ▁] ▁; ▁else ▁arr ▁[ ▁i ▁] ▁= ▁temp ▁[ ▁small ▁++ ▁] ▁; ▁flag ▁= ▁! ▁flag ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁new ▁int ▁[ ▁] ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Original ▁Array ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁Arrays ▁. ▁toString ▁( ▁arr ▁) ▁) ▁; ▁re arrange ▁( ▁arr ▁, ▁arr ▁. ▁length ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Modified ▁Array ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁Arrays ▁. ▁toString ▁( ▁arr ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁Main ▁{ ▁public ▁static ▁void ▁re arrange ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁max _ ele ▁= ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁; ▁int ▁min _ ele ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁arr ▁[ ▁i ▁] ▁= ▁max _ ele ▁; ▁max _ ele ▁-= ▁1 ▁; ▁} ▁else ▁{ ▁arr ▁[ ▁i ▁] ▁= ▁min _ ele ▁; ▁min _ ele ▁+= ▁1 ▁; ▁} ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁, ▁7 ▁, ▁8 ▁, ▁9 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Original ▁Array ▁" ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁re arrange ▁( ▁arr ▁, ▁n ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Modified ▁Array ▁"); ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁}
▁class ▁Node ▁{ ▁int ▁data ▁; ▁Node ▁left ▁, ▁right ▁; ▁Node ▁( ▁int ▁item ▁) ▁{ ▁data ▁= ▁item ▁; ▁left ▁= ▁right ▁= ▁null ▁; ▁} ▁} ▁class ▁Binary Tree ▁{ ▁Node ▁root ▁; ▁boolean ▁is Leaf ▁( ▁Node ▁node ▁) ▁{ ▁if ▁( ▁node ▁== ▁null ▁) ▁return ▁false ▁; ▁if ▁( ▁node ▁. ▁left ▁== ▁null ▁&& ▁node ▁. ▁right ▁== ▁null ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁int ▁left Le aves Sum ▁( ▁Node ▁node ▁) ▁{ ▁int ▁res ▁= ▁0 ▁; ▁if ▁( ▁node ▁!= ▁null ▁) ▁{ ▁if ▁( ▁is Leaf ▁( ▁node ▁. ▁left ▁) ▁) ▁res ▁+= ▁node ▁. ▁left ▁. ▁data ▁; ▁else ▁res ▁+= ▁left Le aves Sum ▁( ▁node ▁. ▁left ▁) ▁; ▁res ▁+= ▁left Le aves Sum ▁( ▁node ▁. ▁right ▁) ▁; ▁} ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁Binary Tree ▁tree ▁= ▁new ▁Binary Tree ▁( ▁) ▁; ▁tree ▁. ▁root ▁= ▁new ▁Node ▁( ▁20 ▁) ▁; ▁tree ▁. ▁root ▁. ▁left ▁= ▁new ▁Node ▁( ▁9 ▁) ▁; ▁tree ▁. ▁root ▁. ▁right ▁= ▁new ▁Node ▁( ▁49 ▁) ▁; ▁tree ▁. ▁root ▁. ▁left ▁. ▁right ▁= ▁new ▁Node ▁( ▁12 ▁) ▁; ▁tree ▁. ▁root ▁. ▁left ▁. ▁left ▁= ▁new ▁Node ▁( ▁5 ▁) ▁; ▁tree ▁. ▁root ▁. ▁right ▁. ▁left ▁= ▁new ▁Node ▁( ▁23 ▁) ▁; ▁tree ▁. ▁root ▁. ▁right ▁. ▁right ▁= ▁new ▁Node ▁( ▁52 ▁) ▁; ▁tree ▁. ▁root ▁. ▁left ▁. ▁right ▁. ▁right ▁= ▁new ▁Node ▁( ▁12 ▁) ▁; ▁tree ▁. ▁root ▁. ▁right ▁. ▁right ▁. ▁left ▁= ▁new ▁Node ▁( ▁50 ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁The ▁sum ▁of ▁leaves ▁is ▁" ▁+ ▁tree ▁. ▁left Le aves Sum ▁( ▁tree ▁. ▁root ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁seg reg ate Elements ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁temp ▁[ ▁] ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁int ▁j ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁arr ▁[ ▁i ▁] ▁>= ▁0 ▁) ▁temp ▁[ ▁j ▁++ ▁] ▁= ▁arr ▁[ ▁i ▁] ▁; ▁if ▁( ▁j ▁== ▁n ▁j ▁== ▁0 ▁) ▁return ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁0 ▁) ▁temp ▁[ ▁j ▁++ ▁] ▁= ▁arr ▁[ ▁i ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁arr ▁[ ▁i ▁] ▁= ▁temp ▁[ ▁i ▁] ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁arg ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁- ▁1 ▁, ▁- ▁3 ▁, ▁- ▁2 ▁, ▁7 ▁, ▁5 ▁, ▁11 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁seg reg ate Elements ▁( ▁arr ▁, ▁n ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁swap ▁( ▁int ▁[ ▁] ▁a ▁, ▁int ▁i ▁, ▁int ▁j ▁) ▁{ ▁int ▁temp ▁= ▁a ▁[ ▁i ▁] ▁; ▁a ▁[ ▁i ▁] ▁= ▁a ▁[ ▁j ▁] ▁; ▁a ▁[ ▁j ▁] ▁= ▁temp ▁; ▁} ▁static ▁void ▁print Array ▁( ▁int ▁[ ▁] ▁a ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁a ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁1 ▁, ▁- ▁3 ▁, ▁5 ▁, ▁6 ▁, ▁- ▁3 ▁, ▁6 ▁, ▁7 ▁, ▁- ▁4 ▁, ▁9 ▁, ▁10 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁print Array ▁( ▁arr ▁, ▁n ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁>= ▁0 ▁&& ▁i ▁% ▁2 ▁== ▁1 ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁j ▁] ▁< ▁0 ▁&& ▁j ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁swap ▁( ▁arr ▁, ▁i ▁, ▁j ▁) ▁; ▁break ▁; ▁} ▁} ▁} ▁else ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁0 ▁&& ▁i ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁j ▁] ▁>= ▁0 ▁&& ▁j ▁% ▁2 ▁== ▁1 ▁) ▁{ ▁swap ▁( ▁arr ▁, ▁i ▁, ▁j ▁) ▁; ▁break ▁; ▁} ▁} ▁} ▁} ▁print Array ▁( ▁arr ▁, ▁n ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁largest ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁n ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁arr ▁) ▁; ▁return ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁; ▁} ▁static ▁public ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁10 ▁, ▁3 24 ▁, ▁45 ▁, ▁90 ▁, ▁9 808 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁largest ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁double ▁find Mean ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁sum ▁+= ▁a ▁[ ▁i ▁] ▁; ▁return ▁( ▁double ▁) ▁sum ▁/ ▁( ▁double ▁) ▁n ▁; ▁} ▁public ▁static ▁double ▁find Medi an ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁a ▁) ▁; ▁if ▁( ▁n ▁% ▁2 ▁!= ▁0 ▁) ▁return ▁( ▁double ▁) ▁a ▁[ ▁n ▁/ ▁2 ▁] ▁; ▁return ▁( ▁double ▁) ▁( ▁a ▁[ ▁( ▁n ▁- ▁1 ▁) ▁/ ▁2 ▁] ▁+ ▁a ▁[ ▁n ▁/ ▁2 ▁] ▁) ▁/ ▁2.0 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁4 ▁, ▁2 ▁, ▁7 ▁, ▁5 ▁, ▁8 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁a ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Mean ▁= ▁" ▁+ ▁find Mean ▁( ▁a ▁, ▁n ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Medi an ▁= ▁" ▁+ ▁find Medi an ▁( ▁a ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁print 2 l argest ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁arr _ size ▁) ▁{ ▁int ▁i ▁, ▁first ▁, ▁second ▁; ▁if ▁( ▁arr _ size ▁< ▁2 ▁) ▁{ ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁Invalid ▁Input ▁" ▁) ▁; ▁return ▁; ▁} ▁int ▁largest ▁= ▁second ▁= ▁Integer ▁. ▁MIN _ VALUE ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁arr _ size ▁; ▁i ▁++ ▁) ▁{ ▁largest ▁= ▁Math ▁. ▁max ▁( ▁largest ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁arr _ size ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁!= ▁largest ▁) ▁second ▁= ▁Math ▁. ▁max ▁( ▁second ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁if ▁( ▁second ▁== ▁Integer ▁. ▁MIN _ VALUE ▁) ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁There ▁is ▁no ▁second ▁" ▁+ ▁" l argest ▁element NEW _ LINE "); ▁else ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁The ▁second ▁largest ▁" ▁+ ▁" element ▁is ▁% d NEW _ LINE ", ▁second ); ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁12 ▁, ▁35 ▁, ▁1 ▁, ▁10 ▁, ▁34 ▁, ▁1 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁print 2 l argest ▁( ▁arr ▁, ▁n ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁public ▁static ▁void ▁print 2 l argest ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁arr _ size ▁) ▁{ ▁int ▁i ▁, ▁first ▁, ▁second ▁; ▁if ▁( ▁arr _ size ▁< ▁2 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Invalid ▁Input ▁" ▁) ▁; ▁return ▁; ▁} ▁first ▁= ▁second ▁= ▁Integer ▁. ▁MIN _ VALUE ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁arr _ size ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁first ▁) ▁{ ▁second ▁= ▁first ▁; ▁first ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁else ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁second ▁&& ▁arr ▁[ ▁i ▁] ▁!= ▁first ▁) ▁second ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁if ▁( ▁second ▁== ▁Integer ▁. ▁MIN _ VALUE ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁There ▁is ▁no ▁second ▁largest ▁" ▁+ ▁" ▁element NEW _ LINE "); ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁The ▁second ▁largest ▁element ▁" ▁+ ▁" ▁is ▁" ▁+ ▁second ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁12 ▁, ▁35 ▁, ▁1 ▁, ▁10 ▁, ▁34 ▁, ▁1 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁print 2 l argest ▁( ▁arr ▁, ▁n ▁) ▁; ▁} ▁}
▁class ▁Maximum Sum ▁{ ▁int ▁Find Max Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁incl ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁int ▁ex cl ▁= ▁0 ▁; ▁int ▁ex cl _ new ▁; ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁ex cl _ new ▁= ▁( ▁incl ▁> ▁ex cl ▁) ▁? ▁incl ▁: ▁ex cl ▁; ▁incl ▁= ▁ex cl ▁+ ▁arr ▁[ ▁i ▁] ▁; ▁ex cl ▁= ▁ex cl _ new ▁; ▁} ▁return ▁( ▁( ▁incl ▁> ▁ex cl ▁) ▁? ▁incl ▁: ▁ex cl ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Maximum Sum ▁sum ▁= ▁new ▁Maximum Sum ▁( ▁) ▁; ▁int ▁arr ▁[ ▁] ▁= ▁new ▁int ▁[ ▁] ▁{ ▁5 ▁, ▁5 ▁, ▁10 ▁, ▁100 ▁, ▁10 ▁, ▁5 ▁} ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁sum ▁. ▁Find Max Sum ▁( ▁arr ▁, ▁arr ▁. ▁length ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁max Sub Array Sum ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁size ▁) ▁{ ▁int ▁max _ so _ far ▁= ▁a ▁[ ▁0 ▁] ▁; ▁int ▁curr _ max ▁= ▁a ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁{ ▁curr _ max ▁= ▁Math ▁. ▁max ▁( ▁a ▁[ ▁i ▁] ▁, ▁curr _ max ▁+ ▁a ▁[ ▁i ▁] ▁) ▁; ▁max _ so _ far ▁= ▁Math ▁. ▁max ▁( ▁max _ so _ far ▁, ▁curr _ max ▁) ▁; ▁} ▁return ▁max _ so _ far ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁- ▁2 ▁, ▁- ▁3 ▁, ▁4 ▁, ▁- ▁1 ▁, ▁- ▁2 ▁, ▁1 ▁, ▁5 ▁, ▁- ▁3 ▁} ▁; ▁int ▁n ▁= ▁a ▁. ▁length ▁; ▁int ▁max _ sum ▁= ▁max Sub Array Sum ▁( ▁a ▁, ▁n ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Maximum ▁contiguous ▁sum ▁is ▁" ▁+ ▁max _ sum ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁min J umps ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁l ▁, ▁int ▁h ▁) ▁{ ▁if ▁( ▁h ▁== ▁l ▁) ▁return ▁0 ▁; ▁if ▁( ▁arr ▁[ ▁l ▁] ▁== ▁0 ▁) ▁return ▁Integer ▁. ▁MAX _ VALUE ▁; ▁int ▁min ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁for ▁( ▁int ▁i ▁= ▁l ▁+ ▁1 ▁; ▁i ▁<= ▁h ▁&& ▁i ▁<= ▁l ▁+ ▁arr ▁[ ▁l ▁] ▁; ▁i ▁++ ▁) ▁{ ▁int ▁jumps ▁= ▁min J umps ▁( ▁arr ▁, ▁i ▁, ▁h ▁) ▁; ▁if ▁( ▁jumps ▁!= ▁Integer ▁. ▁MAX _ VALUE ▁&& ▁jumps ▁+ ▁1 ▁< ▁min ▁) ▁min ▁= ▁jumps ▁+ ▁1 ▁; ▁} ▁return ▁min ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁6 ▁, ▁3 ▁, ▁2 ▁, ▁3 ▁, ▁6 ▁, ▁8 ▁, ▁9 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Minimum ▁number ▁of ▁jumps ▁to ▁reach ▁end ▁is ▁" ▁+ ▁min J umps ▁( ▁arr ▁, ▁0 ▁, ▁n ▁- ▁1 ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁max Sub Array Sum ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁size ▁) ▁{ ▁int ▁max _ so _ far ▁= ▁Integer ▁. ▁MIN _ VALUE ▁, ▁max _ ending _ here ▁= ▁0 ▁, ▁start ▁= ▁0 ▁, ▁end ▁= ▁0 ▁, ▁s ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁{ ▁max _ ending _ here ▁+= ▁a ▁[ ▁i ▁] ▁; ▁if ▁( ▁max _ so _ far ▁< ▁max _ ending _ here ▁) ▁{ ▁max _ so _ far ▁= ▁max _ ending _ here ▁; ▁start ▁= ▁s ▁; ▁end ▁= ▁i ▁; ▁} ▁if ▁( ▁max _ ending _ here ▁< ▁0 ▁) ▁{ ▁max _ ending _ here ▁= ▁0 ▁; ▁s ▁= ▁i ▁+ ▁1 ▁; ▁} ▁} ▁return ▁( ▁end ▁- ▁start ▁+ ▁1 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁- ▁2 ▁, ▁- ▁3 ▁, ▁4 ▁, ▁- ▁1 ▁, ▁- ▁2 ▁, ▁1 ▁, ▁5 ▁, ▁- ▁3 ▁} ▁; ▁int ▁n ▁= ▁a ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁max Sub Array Sum ▁( ▁a ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁sorted After Swap ▁( ▁int ▁A ▁[ ▁] ▁, ▁boolean ▁B ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁i ▁, ▁j ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁B ▁[ ▁i ▁] ▁) ▁{ ▁j ▁= ▁i ▁; ▁while ▁( ▁B ▁[ ▁j ▁] ▁) ▁{ ▁j ▁++ ▁; ▁} ▁Arrays ▁. ▁sort ▁( ▁A ▁, ▁i ▁, ▁1 ▁+ ▁j ▁) ▁; ▁i ▁= ▁j ▁; ▁} ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁A ▁[ ▁i ▁] ▁!= ▁i ▁+ ▁1 ▁) ▁{ ▁return ▁false ▁; ▁} ▁} ▁return ▁true ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁5 ▁, ▁3 ▁, ▁4 ▁, ▁6 ▁} ▁; ▁boolean ▁B ▁[ ▁] ▁= ▁{ ▁false ▁, ▁true ▁, ▁true ▁, ▁true ▁, ▁false ▁} ▁; ▁int ▁n ▁= ▁A ▁. ▁length ▁; ▁if ▁( ▁sorted After Swap ▁( ▁A ▁, ▁B ▁, ▁n ▁) ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁A ▁can ▁be ▁sorted ▁" ▁) ▁; ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁A ▁can ▁not ▁be ▁sorted ▁" ▁) ▁; ▁} ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁find NumberOf Tri angles ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁for ▁( ▁int ▁k ▁= ▁j ▁+ ▁1 ▁; ▁k ▁< ▁n ▁; ▁k ▁++ ▁) ▁if ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁arr ▁[ ▁j ▁] ▁> ▁arr ▁[ ▁k ▁] ▁&& ▁arr ▁[ ▁i ▁] ▁+ ▁arr ▁[ ▁k ▁] ▁> ▁arr ▁[ ▁j ▁] ▁&& ▁arr ▁[ ▁k ▁] ▁+ ▁arr ▁[ ▁j ▁] ▁> ▁arr ▁[ ▁i ▁] ▁) ▁count ▁++ ▁; ▁} ▁} ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁21 ▁, ▁22 ▁, ▁100 ▁, ▁101 ▁, ▁200 ▁, ▁300 ▁} ▁; ▁int ▁size ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Total ▁number ▁of ▁triangles ▁possible ▁is ▁" ▁+ ▁find NumberOf Tri angles ▁( ▁arr ▁, ▁size ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁Count Tri angles ▁{ ▁static ▁int ▁find NumberOf Tri angles ▁( ▁int ▁arr ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁Arrays ▁. ▁sort ▁( ▁arr ▁) ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁2 ▁; ▁++ ▁i ▁) ▁{ ▁int ▁k ▁= ▁i ▁+ ▁2 ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁++ ▁j ▁) ▁{ ▁while ▁( ▁k ▁< ▁n ▁&& ▁arr ▁[ ▁i ▁] ▁+ ▁arr ▁[ ▁j ▁] ▁> ▁arr ▁[ ▁k ▁] ▁) ▁++ ▁k ▁; ▁if ▁( ▁k ▁> ▁j ▁) ▁count ▁+= ▁k ▁- ▁j ▁- ▁1 ▁; ▁} ▁} ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁21 ▁, ▁22 ▁, ▁100 ▁, ▁101 ▁, ▁200 ▁, ▁300 ▁} ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Total ▁number ▁of ▁triangles ▁is ▁" ▁+ ▁find NumberOf Tri angles ▁( ▁arr ▁) ▁) ▁; ▁} ▁}
▁class ▁Equ il ib ri um Index ▁{ ▁int ▁equ il ib ri um ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁i ▁, ▁j ▁; ▁int ▁left sum ▁, ▁right sum ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁{ ▁left sum ▁= ▁0 ▁; ▁right sum ▁= ▁0 ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁i ▁; ▁j ▁++ ▁) ▁left sum ▁+= ▁arr ▁[ ▁j ▁] ▁; ▁for ▁( ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁right sum ▁+= ▁arr ▁[ ▁j ▁] ▁; ▁if ▁( ▁left sum ▁== ▁right sum ▁) ▁return ▁i ▁; ▁} ▁return ▁- ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Equ il ib ri um Index ▁equ i ▁= ▁new ▁Equ il ib ri um Index ▁( ▁) ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁- ▁7 ▁, ▁1 ▁, ▁5 ▁, ▁2 ▁, ▁- ▁4 ▁, ▁3 ▁, ▁0 ▁} ▁; ▁int ▁arr _ size ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁equ i ▁. ▁equ il ib ri um ▁( ▁arr ▁, ▁arr _ size ▁) ▁) ▁; ▁} ▁}
▁class ▁Main ▁{ ▁static ▁int ▁ceil Search ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁low ▁, ▁int ▁high ▁, ▁int ▁x ▁) ▁{ ▁int ▁i ▁; ▁if ▁( ▁x ▁<= ▁arr ▁[ ▁low ▁] ▁) ▁return ▁low ▁; ▁for ▁( ▁i ▁= ▁low ▁; ▁i ▁< ▁high ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁x ▁) ▁return ▁i ▁; ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁x ▁&& ▁arr ▁[ ▁i ▁+ ▁1 ▁] ▁>= ▁x ▁) ▁return ▁i ▁+ ▁1 ▁; ▁} ▁return ▁- ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁8 ▁, ▁10 ▁, ▁10 ▁, ▁12 ▁, ▁19 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁int ▁x ▁= ▁3 ▁; ▁int ▁index ▁= ▁ceil Search ▁( ▁arr ▁, ▁0 ▁, ▁n ▁- ▁1 ▁, ▁x ▁) ▁; ▁if ▁( ▁index ▁== ▁- ▁1 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁C e iling ▁of ▁" ▁+ ▁x ▁+ ▁" ▁doesn ▁' ▁t ▁exist ▁in ▁array ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁ceiling ▁of ▁" ▁+ ▁x ▁+ ▁" ▁is ▁" ▁+ ▁arr ▁[ ▁index ▁] ▁) ▁; ▁} ▁}
▁class ▁M ajor ity Element ▁{ ▁int ▁find Candidate ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁size ▁) ▁{ ▁int ▁ma j _ index ▁= ▁0 ▁, ▁count ▁= ▁1 ▁; ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁ma j _ index ▁] ▁== ▁a ▁[ ▁i ▁] ▁) ▁count ▁++ ▁; ▁else ▁count ▁-- ▁; ▁if ▁( ▁count ▁== ▁0 ▁) ▁{ ▁ma j _ index ▁= ▁i ▁; ▁count ▁= ▁1 ▁; ▁} ▁} ▁return ▁a ▁[ ▁ma j _ index ▁] ▁; ▁} ▁boolean ▁is Major ity ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁size ▁, ▁int ▁cand ▁) ▁{ ▁int ▁i ▁, ▁count ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁== ▁cand ▁) ▁count ▁++ ▁; ▁} ▁if ▁( ▁count ▁> ▁size ▁/ ▁2 ▁) ▁return ▁true ▁; ▁else ▁return ▁false ▁; ▁} ▁void ▁print Major ity ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁size ▁) ▁{ ▁int ▁cand ▁= ▁find Candidate ▁( ▁a ▁, ▁size ▁) ▁; ▁if ▁( ▁is Major ity ▁( ▁a ▁, ▁size ▁, ▁cand ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁" ▁+ ▁cand ▁+ ▁" ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁M ajor ity ▁Element ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁M ajor ity Element ▁ma j ore lement ▁= ▁new ▁M ajor ity Element ▁( ▁) ▁; ▁int ▁a ▁[ ▁] ▁= ▁new ▁int ▁[ ▁] ▁{ ▁1 ▁, ▁3 ▁, ▁3 ▁, ▁1 ▁, ▁2 ▁} ▁; ▁int ▁size ▁= ▁a ▁. ▁length ▁; ▁ma j ore lement ▁. ▁print Major ity ▁( ▁a ▁, ▁size ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁class ▁pair ▁{ ▁int ▁first ▁, ▁second ▁; ▁public ▁pair ▁( ▁int ▁first ▁, ▁int ▁second ▁) ▁{ ▁this ▁. ▁first ▁= ▁first ▁; ▁this ▁. ▁second ▁= ▁second ▁; ▁} ▁} ▁static ▁int ▁find Root ▁( ▁pair ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁root ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁root ▁+= ▁( ▁arr ▁[ ▁i ▁] ▁. ▁first ▁- ▁arr ▁[ ▁i ▁] ▁. ▁second ▁) ▁; ▁} ▁return ▁root ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁pair ▁arr ▁[ ▁] ▁= ▁{ ▁new ▁pair ▁( ▁1 ▁, ▁5 ▁) ▁, ▁new ▁pair ▁( ▁2 ▁, ▁0 ▁) ▁, ▁new ▁pair ▁( ▁3 ▁, ▁0 ▁) ▁, ▁new ▁pair ▁( ▁4 ▁, ▁0 ▁) ▁, ▁new ▁pair ▁( ▁5 ▁, ▁5 ▁) ▁, ▁new ▁pair ▁( ▁6 ▁, ▁5 ▁) ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁printf ▁( ▁"% d NEW _ LINE ", ▁find Root ( arr , ▁n )); ▁} ▁}
▁class ▁Binary Tree ▁{ ▁void ▁fill Depth ▁( ▁int ▁parent ▁[ ▁] ▁, ▁int ▁i ▁, ▁int ▁depth ▁[ ▁] ▁) ▁{ ▁if ▁( ▁depth ▁[ ▁i ▁] ▁!= ▁0 ▁) ▁{ ▁return ▁; ▁} ▁if ▁( ▁parent ▁[ ▁i ▁] ▁== ▁- ▁1 ▁) ▁{ ▁depth ▁[ ▁i ▁] ▁= ▁1 ▁; ▁return ▁; ▁} ▁if ▁( ▁depth ▁[ ▁parent ▁[ ▁i ▁] ▁] ▁== ▁0 ▁) ▁{ ▁fill Depth ▁( ▁parent ▁, ▁parent ▁[ ▁i ▁] ▁, ▁depth ▁) ▁; ▁} ▁depth ▁[ ▁i ▁] ▁= ▁depth ▁[ ▁parent ▁[ ▁i ▁] ▁] ▁+ ▁1 ▁; ▁} ▁int ▁find Height ▁( ▁int ▁parent ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁depth ▁[ ▁] ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁depth ▁[ ▁i ▁] ▁= ▁0 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁fill Depth ▁( ▁parent ▁, ▁i ▁, ▁depth ▁) ▁; ▁} ▁int ▁ht ▁= ▁depth ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁ht ▁< ▁depth ▁[ ▁i ▁] ▁) ▁{ ▁ht ▁= ▁depth ▁[ ▁i ▁] ▁; ▁} ▁} ▁return ▁ht ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁Binary Tree ▁tree ▁= ▁new ▁Binary Tree ▁( ▁) ▁; ▁int ▁parent ▁[ ▁] ▁= ▁new ▁int ▁[ ▁] ▁{ ▁- ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁3 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁parent ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Height ▁is ▁" ▁+ ▁tree ▁. ▁find Height ▁( ▁parent ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁void ▁getPost Order B ST ▁( ▁int ▁pre ▁[ ▁] ▁) ▁{ ▁int ▁pivot Point ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁pre ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁pre ▁[ ▁0 ▁] ▁<= ▁pre ▁[ ▁i ▁] ▁) ▁{ ▁pivot Point ▁= ▁i ▁; ▁break ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁pivot Point ▁- ▁1 ▁; ▁i ▁> ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁pre ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁pre ▁. ▁length ▁- ▁1 ▁; ▁i ▁>= ▁pivot Point ▁; ▁i ▁-- ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁pre ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁pre ▁[ ▁0 ▁] ▁) ▁; ▁}
▁class ▁Node ▁{ ▁int ▁data ▁; ▁Node ▁left ▁, ▁right ▁; ▁public ▁Node ▁( ▁int ▁item ▁) ▁{ ▁data ▁= ▁item ▁; ▁left ▁= ▁right ▁= ▁null ▁; ▁} ▁} ▁public ▁class ▁Binary Tree ▁{ ▁Node ▁root ▁; ▁int ▁minimum Depth ▁( ▁) ▁{ ▁return ▁minimum Depth ▁( ▁root ▁) ▁; ▁} ▁int ▁minimum Depth ▁( ▁Node ▁root ▁) ▁{ ▁if ▁( ▁root ▁== ▁null ▁) ▁return ▁0 ▁; ▁if ▁( ▁root ▁. ▁left ▁== ▁null ▁&& ▁root ▁. ▁right ▁== ▁null ▁) ▁return ▁1 ▁; ▁if ▁( ▁root ▁. ▁left ▁== ▁null ▁) ▁return ▁minimum Depth ▁( ▁root ▁. ▁right ▁) ▁+ ▁1 ▁; ▁if ▁( ▁root ▁. ▁right ▁== ▁null ▁) ▁return ▁minimum Depth ▁( ▁root ▁. ▁left ▁) ▁+ ▁1 ▁; ▁return ▁Math ▁. ▁min ▁( ▁minimum Depth ▁( ▁root ▁. ▁left ▁) ▁, ▁minimum Depth ▁( ▁root ▁. ▁right ▁) ▁) ▁+ ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁Binary Tree ▁tree ▁= ▁new ▁Binary Tree ▁( ▁) ▁; ▁tree ▁. ▁root ▁= ▁new ▁Node ▁( ▁1 ▁) ▁; ▁tree ▁. ▁root ▁. ▁left ▁= ▁new ▁Node ▁( ▁2 ▁) ▁; ▁tree ▁. ▁root ▁. ▁right ▁= ▁new ▁Node ▁( ▁3 ▁) ▁; ▁tree ▁. ▁root ▁. ▁left ▁. ▁left ▁= ▁new ▁Node ▁( ▁4 ▁) ▁; ▁tree ▁. ▁root ▁. ▁left ▁. ▁right ▁= ▁new ▁Node ▁( ▁5 ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁The ▁minimum ▁depth ▁of ▁" ▁+ ▁" ▁binary ▁tree ▁is ▁: ▁" ▁+ ▁tree ▁. ▁minimum Depth ▁( ▁) ▁) ▁; ▁} ▁}
▁if ▁( ▁in M ST ▁[ ▁v ▁] ▁== ▁false ▁&& ▁key ▁[ ▁v ▁] ▁> ▁weight ▁) ▁{ ▁key ▁[ ▁v ▁] ▁= ▁weight ▁; ▁pq ▁. ▁add ▁( ▁new ▁Pair ▁< ▁Integer ▁, ▁Integer ▁> ▁( ▁key ▁[ ▁v ▁] ▁, ▁v ▁) ▁) ▁; ▁parent ▁[ ▁v ▁] ▁= ▁u ▁; ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁size ▁= ▁4 ▁; ▁static ▁boolean ▁check Star ▁( ▁int ▁mat ▁[ ▁] ▁[ ▁] ▁) ▁{ ▁int ▁vertex D 1 ▁= ▁0 ▁, ▁vertex Dn _1 ▁= ▁0 ▁; ▁if ▁( ▁size ▁== ▁1 ▁) ▁return ▁( ▁mat ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁== ▁0 ▁) ▁; ▁if ▁( ▁size ▁== ▁2 ▁) ▁return ▁( ▁mat ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁== ▁0 ▁&& ▁mat ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁== ▁1 ▁&& ▁mat ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁== ▁1 ▁&& ▁mat ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁== ▁0 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁{ ▁int ▁degree I ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁size ▁; ▁j ▁++ ▁) ▁if ▁( ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁== ▁1 ▁) ▁degree I ▁++ ▁; ▁if ▁( ▁degree I ▁== ▁1 ▁) ▁vertex D 1 ▁++ ▁; ▁else ▁if ▁( ▁degree I ▁== ▁size ▁- ▁1 ▁) ▁vertex Dn _1 ▁++ ▁; ▁} ▁return ▁( ▁vertex D 1 ▁== ▁( ▁size ▁- ▁1 ▁) ▁&& ▁vertex Dn _1 ▁== ▁1 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁mat ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁} ▁} ▁; ▁if ▁( ▁check Star ▁( ▁mat ▁) ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Star ▁Graph ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Not ▁a ▁Star ▁Graph ▁" ▁) ▁; ▁} ▁}
▁class ▁G f G ▁{ ▁static ▁class ▁Node ▁{ ▁int ▁data ▁; ▁Node ▁left ▁, ▁right ▁; ▁} ▁static ▁Node ▁newNode ▁( ▁int ▁data ▁) ▁{ ▁Node ▁temp ▁= ▁new ▁Node ▁( ▁) ▁; ▁temp ▁. ▁data ▁= ▁data ▁; ▁temp ▁. ▁right ▁= ▁null ▁; ▁temp ▁. ▁left ▁= ▁null ▁; ▁return ▁temp ▁; ▁} ▁static ▁Node ▁K th L argest Using M or ris Traversal ▁( ▁Node ▁root ▁, ▁int ▁k ▁) ▁{ ▁Node ▁curr ▁= ▁root ▁; ▁Node ▁K l argest ▁= ▁null ▁; ▁int ▁count ▁= ▁0 ▁; ▁while ▁( ▁curr ▁!= ▁null ▁) ▁{ ▁if ▁( ▁curr ▁. ▁right ▁== ▁null ▁) ▁{ ▁if ▁( ▁++ ▁count ▁== ▁k ▁) ▁K l argest ▁= ▁curr ▁; ▁curr ▁= ▁curr ▁. ▁left ▁; ▁} ▁else ▁{ ▁Node ▁succ ▁= ▁curr ▁. ▁right ▁; ▁while ▁( ▁succ ▁. ▁left ▁!= ▁null ▁&& ▁succ ▁. ▁left ▁!= ▁curr ▁) ▁succ ▁= ▁succ ▁. ▁left ▁; ▁if ▁( ▁succ ▁. ▁left ▁== ▁null ▁) ▁{ ▁succ ▁. ▁left ▁= ▁curr ▁; ▁curr ▁= ▁curr ▁. ▁right ▁; ▁} ▁else ▁{ ▁succ ▁. ▁left ▁= ▁null ▁; ▁if ▁( ▁++ ▁count ▁== ▁k ▁) ▁K l argest ▁= ▁curr ▁; ▁curr ▁= ▁curr ▁. ▁left ▁; ▁} ▁} ▁} ▁return ▁K l argest ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Node ▁root ▁= ▁newNode ▁( ▁4 ▁) ▁; ▁root ▁. ▁left ▁= ▁newNode ▁( ▁2 ▁) ▁; ▁root ▁. ▁right ▁= ▁newNode ▁( ▁7 ▁) ▁; ▁root ▁. ▁left ▁. ▁left ▁= ▁newNode ▁( ▁1 ▁) ▁; ▁root ▁. ▁left ▁. ▁right ▁= ▁newNode ▁( ▁3 ▁) ▁; ▁root ▁. ▁right ▁. ▁left ▁= ▁newNode ▁( ▁6 ▁) ▁; ▁root ▁. ▁right ▁. ▁right ▁= ▁newNode ▁( ▁10 ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Finding ▁K ▁- ▁th ▁largest ▁Node ▁in ▁B ST ▁: ▁" ▁+ ▁K th L argest Using M or ris Traversal ▁( ▁root ▁, ▁2 ▁) ▁. ▁data ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁public ▁class ▁TreeNode ▁{ ▁int ▁val ▁; ▁TreeNode ▁left ▁; ▁TreeNode ▁right ▁; ▁TreeNode ▁( ▁int ▁x ▁) ▁{ ▁val ▁= ▁x ▁; ▁} ▁} ▁class ▁Binary Tree ▁{ ▁static ▁Set ▁< ▁TreeNode ▁> ▁set ▁= ▁new ▁HashSet ▁< ▁> ▁( ▁) ▁; ▁static ▁Stack ▁< ▁TreeNode ▁> ▁stack ▁= ▁new ▁Stack ▁< ▁> ▁( ▁) ▁; ▁public ▁TreeNode ▁build Tree ▁( ▁int ▁[ ▁] ▁pre order ▁, ▁int ▁[ ▁] ▁in order ▁) ▁{ ▁TreeNode ▁root ▁= ▁null ▁; ▁for ▁( ▁int ▁pre ▁= ▁0 ▁, ▁in ▁= ▁0 ▁; ▁pre ▁< ▁pre order ▁. ▁length ▁; ▁) ▁{ ▁TreeNode ▁node ▁= ▁null ▁; ▁do ▁{ ▁node ▁= ▁new ▁TreeNode ▁( ▁pre order ▁[ ▁pre ▁] ▁) ▁; ▁if ▁( ▁root ▁== ▁null ▁) ▁{ ▁root ▁= ▁node ▁; ▁} ▁if ▁( ▁! ▁stack ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁if ▁( ▁set ▁. ▁contains ▁( ▁stack ▁. ▁peek ▁( ▁) ▁) ▁) ▁{ ▁set ▁. ▁remove ▁( ▁stack ▁. ▁peek ▁( ▁) ▁) ▁; ▁stack ▁. ▁pop ▁( ▁) ▁. ▁right ▁= ▁node ▁; ▁} ▁else ▁{ ▁stack ▁. ▁peek ▁( ▁) ▁. ▁left ▁= ▁node ▁; ▁} ▁} ▁stack ▁. ▁push ▁( ▁node ▁) ▁; ▁} ▁while ▁( ▁pre order ▁[ ▁pre ▁++ ▁] ▁!= ▁in order ▁[ ▁in ▁] ▁&& ▁pre ▁< ▁pre order ▁. ▁length ▁) ▁; ▁node ▁= ▁null ▁; ▁while ▁( ▁! ▁stack ▁. ▁isEmpty ▁( ▁) ▁&& ▁in ▁< ▁in order ▁. ▁length ▁&& ▁stack ▁. ▁peek ▁( ▁) ▁. ▁val ▁== ▁in order ▁[ ▁in ▁] ▁) ▁{ ▁node ▁= ▁stack ▁. ▁pop ▁( ▁) ▁; ▁in ▁++ ▁; ▁} ▁if ▁( ▁node ▁!= ▁null ▁) ▁{ ▁set ▁. ▁add ▁( ▁node ▁) ▁; ▁stack ▁. ▁push ▁( ▁node ▁) ▁; ▁} ▁} ▁return ▁root ▁; ▁} ▁void ▁print In order ▁( ▁TreeNode ▁node ▁) ▁{ ▁if ▁( ▁node ▁== ▁null ▁) ▁return ▁; ▁print In order ▁( ▁node ▁. ▁left ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁node ▁. ▁val ▁+ ▁" ▁" ▁) ▁; ▁print In order ▁( ▁node ▁. ▁right ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁Binary Tree ▁tree ▁= ▁new ▁Binary Tree ▁( ▁) ▁; ▁int ▁in ▁[ ▁] ▁= ▁new ▁int ▁[ ▁] ▁{ ▁9 ▁, ▁8 ▁, ▁4 ▁, ▁2 ▁, ▁10 ▁, ▁5 ▁, ▁10 ▁, ▁1 ▁,
▁class ▁Solution ▁{ ▁static ▁class ▁Node ▁{ ▁Node ▁left ▁, ▁right ▁; ▁int ▁data ▁; ▁} ▁static ▁Node ▁createNode ▁( ▁int ▁x ▁) ▁{ ▁Node ▁p ▁= ▁new ▁Node ▁( ▁) ▁; ▁p ▁. ▁data ▁= ▁x ▁; ▁p ▁. ▁left ▁= ▁p ▁. ▁right ▁= ▁null ▁; ▁return ▁p ▁; ▁} ▁static ▁void ▁insert Node ▁( ▁Node ▁root ▁, ▁int ▁x ▁) ▁{ ▁Node ▁p ▁= ▁root ▁, ▁q ▁= ▁null ▁; ▁while ▁( ▁p ▁!= ▁null ▁) ▁{ ▁q ▁= ▁p ▁; ▁if ▁( ▁p ▁. ▁data ▁< ▁x ▁) ▁p ▁= ▁p ▁. ▁right ▁; ▁else ▁p ▁= ▁p ▁. ▁left ▁; ▁} ▁if ▁( ▁q ▁== ▁null ▁) ▁p ▁= ▁createNode ▁( ▁x ▁) ▁; ▁else ▁{ ▁if ▁( ▁q ▁. ▁data ▁< ▁x ▁) ▁q ▁. ▁right ▁= ▁createNode ▁( ▁x ▁) ▁; ▁else ▁q ▁. ▁left ▁= ▁createNode ▁( ▁x ▁) ▁; ▁} ▁} ▁static ▁int ▁max el path ▁( ▁Node ▁q ▁, ▁int ▁x ▁) ▁{ ▁Node ▁p ▁= ▁q ▁; ▁int ▁mx ▁= ▁- ▁1 ▁; ▁while ▁( ▁p ▁. ▁data ▁!= ▁x ▁) ▁{ ▁if ▁( ▁p ▁. ▁data ▁> ▁x ▁) ▁{ ▁mx ▁= ▁Math ▁. ▁max ▁( ▁mx ▁, ▁p ▁. ▁data ▁) ▁; ▁p ▁= ▁p ▁. ▁left ▁; ▁} ▁else ▁{ ▁mx ▁= ▁Math ▁. ▁max ▁( ▁mx ▁, ▁p ▁. ▁data ▁) ▁; ▁p ▁= ▁p ▁. ▁right ▁; ▁} ▁} ▁return ▁Math ▁. ▁max ▁( ▁mx ▁, ▁x ▁) ▁; ▁} ▁static ▁int ▁maximum Element ▁( ▁Node ▁root ▁, ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁Node ▁p ▁= ▁root ▁; ▁while ▁( ▁( ▁x ▁< ▁p ▁. ▁data ▁&& ▁y ▁< ▁p ▁. ▁data ▁) ▁|| ▁( ▁x ▁> ▁p ▁. ▁data ▁&& ▁y ▁> ▁p ▁. ▁data ▁) ▁) ▁{ ▁if ▁( ▁x ▁< ▁p ▁. ▁data ▁&& ▁y ▁< ▁p ▁. ▁data ▁) ▁p ▁= ▁p ▁. ▁left ▁; ▁else ▁if ▁( ▁x ▁> ▁p ▁. ▁data ▁&& ▁y ▁> ▁p ▁. ▁data ▁) ▁p ▁= ▁p ▁. ▁right ▁; ▁} ▁return ▁Math ▁. ▁max ▁( ▁max el path ▁( ▁p ▁, ▁x ▁) ▁, ▁max el path ▁( ▁p ▁, ▁y ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁18 ▁, ▁36 ▁, ▁9 ▁, ▁6 ▁, ▁12 ▁, ▁10 ▁, ▁1 ▁, ▁8 ▁} ▁; ▁int ▁a
▁class ▁G F G ▁{ ▁static ▁int ▁i ▁= ▁0 ▁; ▁static ▁boolean ▁is Leaf ▁( ▁int ▁pre ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁min ▁, ▁int ▁max ▁) ▁{ ▁if ▁( ▁i ▁>= ▁n ▁) ▁{ ▁return ▁false ▁; ▁} ▁if ▁( ▁pre ▁[ ▁i ▁] ▁> ▁min ▁&& ▁pre ▁[ ▁i ▁] ▁< ▁max ▁) ▁{ ▁i ▁++ ▁; ▁boolean ▁left ▁= ▁is Leaf ▁( ▁pre ▁, ▁n ▁, ▁min ▁, ▁pre ▁[ ▁i ▁- ▁1 ▁] ▁) ▁; ▁boolean ▁right ▁= ▁is Leaf ▁( ▁pre ▁, ▁n ▁, ▁pre ▁[ ▁i ▁- ▁1 ▁] ▁, ▁max ▁) ▁; ▁if ▁( ▁! ▁left ▁&& ▁! ▁right ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁pre ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁return ▁true ▁; ▁} ▁return ▁false ▁; ▁} ▁static ▁void ▁print Le aves ▁( ▁int ▁pre order ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁is Leaf ▁( ▁pre order ▁, ▁n ▁, ▁Integer ▁. ▁MIN _ VALUE ▁, ▁Integer ▁. ▁MAX _ VALUE ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁pre order ▁[ ▁] ▁= ▁{ ▁8 90 ▁, ▁3 25 ▁, ▁2 90 ▁, ▁5 30 ▁, ▁9 65 ▁} ▁; ▁int ▁n ▁= ▁pre order ▁. ▁length ▁; ▁print Le aves ▁( ▁pre order ▁, ▁n ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁public ▁class ▁Inter change ▁{ ▁static ▁void ▁inter change First Last ▁( ▁int ▁m ▁[ ▁] ▁[ ▁] ▁) ▁{ ▁int ▁rows ▁= ▁m ▁. ▁length ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁m ▁[ ▁0 ▁] ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁int ▁t ▁= ▁m ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁; ▁m ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁= ▁m ▁[ ▁rows ▁- ▁1 ▁] ▁[ ▁i ▁] ▁; ▁m ▁[ ▁rows ▁- ▁1 ▁] ▁[ ▁i ▁] ▁= ▁t ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁throws ▁IOException ▁{ ▁int ▁m ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁8 ▁, ▁9 ▁, ▁7 ▁, ▁6 ▁} ▁, ▁{ ▁4 ▁, ▁7 ▁, ▁6 ▁, ▁5 ▁} ▁, ▁{ ▁3 ▁, ▁2 ▁, ▁1 ▁, ▁8 ▁} ▁, ▁{ ▁9 ▁, ▁9 ▁, ▁7 ▁, ▁7 ▁} ▁} ▁; ▁inter change First Last ▁( ▁m ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁m ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁m ▁[ ▁0 ▁] ▁. ▁length ▁; ▁j ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁m ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+ ▁" ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁} ▁} ▁}
▁class ▁Node ▁{ ▁int ▁data ▁; ▁Node ▁left ▁, ▁right ▁; ▁public ▁Node ▁( ▁int ▁data ▁) ▁{ ▁this ▁. ▁data ▁= ▁data ▁; ▁left ▁= ▁right ▁= ▁null ▁; ▁} ▁} ▁class ▁Binary Tree ▁{ ▁Node ▁build Util ▁( ▁int ▁in ▁[ ▁] ▁, ▁int ▁post ▁[ ▁] ▁, ▁int ▁in Str t ▁, ▁int ▁in End ▁, ▁int ▁post Str t ▁, ▁int ▁post End ▁) ▁{ ▁if ▁( ▁in Str t ▁> ▁in End ▁) ▁return ▁null ▁; ▁Node ▁node ▁= ▁new ▁Node ▁( ▁post ▁[ ▁post End ▁] ▁) ▁; ▁if ▁( ▁in Str t ▁== ▁in End ▁) ▁return ▁node ▁; ▁int ▁i Index ▁= ▁search ▁( ▁in ▁, ▁in Str t ▁, ▁in End ▁, ▁node ▁. ▁data ▁) ▁; ▁node ▁. ▁left ▁= ▁build Util ▁( ▁in ▁, ▁post ▁, ▁in Str t ▁, ▁i Index ▁- ▁1 ▁, ▁post Str t ▁, ▁post Str t ▁- ▁in Str t ▁+ ▁i Index ▁- ▁1 ▁) ▁; ▁node ▁. ▁right ▁= ▁build Util ▁( ▁in ▁, ▁post ▁, ▁i Index ▁+ ▁1 ▁, ▁in End ▁, ▁post End ▁- ▁in End ▁+ ▁i Index ▁, ▁post End ▁- ▁1 ▁) ▁; ▁return ▁node ▁; ▁} ▁int ▁search ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁str t ▁, ▁int ▁end ▁, ▁int ▁value ▁) ▁{ ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁str t ▁; ▁i ▁<= ▁end ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁value ▁) ▁break ▁; ▁} ▁return ▁i ▁; ▁} ▁void ▁pre Order ▁( ▁Node ▁node ▁) ▁{ ▁if ▁( ▁node ▁== ▁null ▁) ▁return ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁node ▁. ▁data ▁+ ▁" ▁" ▁) ▁; ▁pre Order ▁( ▁node ▁. ▁left ▁) ▁; ▁pre Order ▁( ▁node ▁. ▁right ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Binary Tree ▁tree ▁= ▁new ▁Binary Tree ▁( ▁) ▁; ▁int ▁in ▁[ ▁] ▁= ▁new ▁int ▁[ ▁] ▁{ ▁4 ▁, ▁8 ▁, ▁2 ▁, ▁5 ▁, ▁1 ▁, ▁6 ▁, ▁3 ▁, ▁7 ▁} ▁; ▁int ▁post ▁[ ▁] ▁= ▁new ▁int ▁[ ▁] ▁{ ▁8 ▁, ▁4 ▁, ▁5 ▁, ▁2 ▁, ▁6 ▁, ▁7 ▁, ▁3 ▁, ▁1 ▁} ▁; ▁int ▁n ▁= ▁in ▁. ▁length ▁; ▁Node ▁root ▁= ▁tree ▁. ▁build Util ▁( ▁in ▁, ▁post ▁, ▁0 ▁, ▁n ▁-
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁col a ▁= ▁2 ▁, ▁row a ▁= ▁3 ▁, ▁col b ▁= ▁3 ▁, ▁row b ▁= ▁2 ▁; ▁static ▁void ▁K r one cker product ▁( ▁int ▁A ▁[ ▁] ▁[ ▁] ▁, ▁int ▁B ▁[ ▁] ▁[ ▁] ▁) ▁{ ▁int ▁[ ▁] ▁[ ▁] ▁C ▁= ▁new ▁int ▁[ ▁row a ▁* ▁row b ▁] ▁[ ▁col a ▁* ▁col b ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁row a ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁k ▁= ▁0 ▁; ▁k ▁< ▁row b ▁; ▁k ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁col a ▁; ▁j ▁++ ▁) ▁{ ▁for ▁( ▁int ▁l ▁= ▁0 ▁; ▁l ▁< ▁col b ▁; ▁l ▁++ ▁) ▁{ ▁C ▁[ ▁i ▁+ ▁l ▁+ ▁1 ▁] ▁[ ▁j ▁+ ▁k ▁+ ▁1 ▁] ▁= ▁A ▁[ ▁i ▁] ▁[ ▁j ▁] ▁* ▁B ▁[ ▁k ▁] ▁[ ▁l ▁] ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁C ▁[ ▁i ▁+ ▁l ▁+ ▁1 ▁] ▁[ ▁j ▁+ ▁k ▁+ ▁1 ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁} ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁A ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁} ▁, ▁{ ▁3 ▁, ▁4 ▁} ▁, ▁{ ▁1 ▁, ▁0 ▁} ▁} ▁; ▁int ▁B ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁0 ▁, ▁5 ▁, ▁2 ▁} ▁, ▁{ ▁6 ▁, ▁7 ▁, ▁3 ▁} ▁} ▁; ▁K r one cker product ▁( ▁A ▁, ▁B ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁public ▁class ▁G f G ▁{ ▁public ▁static ▁int ▁find ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁if ▁( ▁n ▁+ ▁1 ▁>= ▁k ▁) ▁return ▁( ▁k ▁- ▁1 ▁) ▁; ▁else ▁return ▁( ▁2 ▁* ▁n ▁+ ▁1 ▁- ▁k ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁arg c ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁4 ▁, ▁k ▁= ▁7 ▁; ▁int ▁freq ▁= ▁find ▁( ▁n ▁, ▁k ▁) ▁; ▁if ▁( ▁freq ▁< ▁0 ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁element ▁" ▁+ ▁" ▁not ▁exist ▁NEW _ LINE ▁"); ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Frequency ▁" ▁+ ▁" ▁of ▁" ▁+ ▁k ▁+ ▁" ▁is ▁" ▁+ ▁freq ▁+ ▁" NEW _ LINE "); ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁identity ▁( ▁int ▁num ▁) ▁{ ▁int ▁row ▁, ▁col ▁; ▁for ▁( ▁row ▁= ▁0 ▁; ▁row ▁< ▁num ▁; ▁row ▁++ ▁) ▁{ ▁for ▁( ▁col ▁= ▁0 ▁; ▁col ▁< ▁num ▁; ▁col ▁++ ▁) ▁{ ▁if ▁( ▁row ▁== ▁col ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁1 ▁+ ▁" ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁0 ▁+ ▁" ▁" ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁} ▁return ▁0 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁size ▁= ▁5 ▁; ▁identity ▁( ▁size ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁MAX ▁= ▁100 ▁; ▁static ▁void ▁image Swap ▁( ▁int ▁mat ▁[ ▁] ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁row ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁Stack ▁< ▁Integer ▁> ▁s ▁= ▁new ▁Stack ▁< ▁> ▁( ▁) ▁; ▁int ▁i ▁= ▁row ▁, ▁k ▁= ▁j ▁; ▁while ▁( ▁i ▁< ▁n ▁&& ▁k ▁>= ▁0 ▁) ▁{ ▁s ▁. ▁push ▁( ▁mat ▁[ ▁i ▁++ ▁] ▁[ ▁k ▁-- ▁] ▁) ▁; ▁} ▁i ▁= ▁row ▁; ▁k ▁= ▁j ▁; ▁while ▁( ▁i ▁< ▁n ▁&& ▁k ▁>= ▁0 ▁) ▁{ ▁mat ▁[ ▁i ▁++ ▁] ▁[ ▁k ▁-- ▁] ▁= ▁s ▁. ▁peek ▁( ▁) ▁; ▁s ▁. ▁pop ▁( ▁) ▁; ▁} ▁} ▁int ▁column ▁= ▁n ▁- ▁1 ▁; ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁Stack ▁< ▁Integer ▁> ▁s ▁= ▁new ▁Stack ▁< ▁> ▁( ▁) ▁; ▁int ▁i ▁= ▁j ▁, ▁k ▁= ▁column ▁; ▁while ▁( ▁i ▁< ▁n ▁&& ▁k ▁>= ▁0 ▁) ▁{ ▁s ▁. ▁push ▁( ▁mat ▁[ ▁i ▁++ ▁] ▁[ ▁k ▁-- ▁] ▁) ▁; ▁} ▁i ▁= ▁j ▁; ▁k ▁= ▁column ▁; ▁while ▁( ▁i ▁< ▁n ▁&& ▁k ▁>= ▁0 ▁) ▁{ ▁mat ▁[ ▁i ▁++ ▁] ▁[ ▁k ▁-- ▁] ▁= ▁s ▁. ▁peek ▁( ▁) ▁; ▁s ▁. ▁pop ▁( ▁) ▁; ▁} ▁} ▁} ▁static ▁void ▁print Matrix ▁( ▁int ▁mat ▁[ ▁] ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁mat ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁, ▁{ ▁5 ▁, ▁6 ▁, ▁7 ▁, ▁8 ▁} ▁, ▁{ ▁9 ▁, ▁10 ▁, ▁11 ▁, ▁12 ▁} ▁, ▁{ ▁13 ▁, ▁14 ▁, ▁15 ▁, ▁16 ▁} ▁} ▁; ▁int ▁n
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁R ▁= ▁4 ▁; ▁static ▁int ▁C ▁= ▁4 ▁; ▁static ▁int ▁getTotal Coverage Of Matrix ▁( ▁int ▁[ ▁] ▁[ ▁] ▁mat ▁) ▁{ ▁int ▁res ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁R ▁; ▁i ▁++ ▁) ▁{ ▁boolean ▁is One ▁= ▁false ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁C ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁== ▁1 ▁) ▁is One ▁= ▁true ▁; ▁else ▁if ▁( ▁is One ▁) ▁res ▁++ ▁; ▁} ▁is One ▁= ▁false ▁; ▁for ▁( ▁int ▁j ▁= ▁C ▁- ▁1 ▁; ▁j ▁>= ▁0 ▁; ▁j ▁-- ▁) ▁{ ▁if ▁( ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁== ▁1 ▁) ▁is One ▁= ▁true ▁; ▁else ▁if ▁( ▁is One ▁) ▁res ▁++ ▁; ▁} ▁} ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁C ▁; ▁j ▁++ ▁) ▁{ ▁boolean ▁is One ▁= ▁false ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁R ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁== ▁1 ▁) ▁is One ▁= ▁true ▁; ▁else ▁if ▁( ▁is One ▁) ▁res ▁++ ▁; ▁} ▁is One ▁= ▁false ▁; ▁for ▁( ▁int ▁i ▁= ▁R ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁== ▁1 ▁) ▁is One ▁= ▁true ▁; ▁else ▁if ▁( ▁is One ▁) ▁res ▁++ ▁; ▁} ▁} ▁return ▁res ▁; ▁} ▁static ▁public ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁[ ▁] ▁mat ▁= ▁{ ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁} ▁, ▁{ ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁0 ▁} ▁, ▁{ ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁0 ▁} ▁} ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁getTotal Coverage Of Matrix ▁( ▁mat ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁R ▁= ▁3 ▁; ▁static ▁int ▁C ▁= ▁6 ▁; ▁static ▁void ▁sp ir al Print ▁( ▁int ▁m ▁, ▁int ▁n ▁, ▁int ▁[ ▁] ▁[ ▁] ▁a ▁, ▁int ▁c ▁) ▁{ ▁int ▁i ▁, ▁k ▁= ▁0 ▁, ▁l ▁= ▁0 ▁; ▁int ▁count ▁= ▁0 ▁; ▁while ▁( ▁k ▁< ▁m ▁&& ▁l ▁< ▁n ▁) ▁{ ▁for ▁( ▁i ▁= ▁l ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁{ ▁count ▁++ ▁; ▁if ▁( ▁count ▁== ▁c ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁a ▁[ ▁k ▁] ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁k ▁++ ▁; ▁for ▁( ▁i ▁= ▁k ▁; ▁i ▁< ▁m ▁; ▁++ ▁i ▁) ▁{ ▁count ▁++ ▁; ▁if ▁( ▁count ▁== ▁c ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁a ▁[ ▁i ▁] ▁[ ▁n ▁- ▁1 ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁n ▁-- ▁; ▁if ▁( ▁k ▁< ▁m ▁) ▁{ ▁for ▁( ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁l ▁; ▁-- ▁i ▁) ▁{ ▁count ▁++ ▁; ▁if ▁( ▁count ▁== ▁c ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁a ▁[ ▁m ▁- ▁1 ▁] ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁m ▁-- ▁; ▁} ▁if ▁( ▁l ▁< ▁n ▁) ▁{ ▁for ▁( ▁i ▁= ▁m ▁- ▁1 ▁; ▁i ▁>= ▁k ▁; ▁-- ▁i ▁) ▁{ ▁count ▁++ ▁; ▁if ▁( ▁count ▁== ▁c ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁a ▁[ ▁i ▁] ▁[ ▁l ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁l ▁++ ▁; ▁} ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁} ▁, ▁{ ▁7 ▁, ▁8 ▁, ▁9 ▁, ▁10 ▁, ▁11 ▁, ▁12 ▁} ▁, ▁{ ▁13 ▁, ▁14 ▁, ▁15 ▁, ▁16 ▁, ▁17 ▁, ▁18 ▁} ▁} ▁; ▁int ▁k ▁= ▁17 ▁; ▁sp ir al Print ▁( ▁R ▁, ▁C ▁, ▁a ▁, ▁k ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁count Negative ▁( ▁int ▁M ▁[ ▁] ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁m ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁M ▁[ ▁i ▁] ▁[ ▁j ▁] ▁< ▁0 ▁) ▁count ▁+= ▁1 ▁; ▁else ▁break ▁; ▁} ▁} ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁M ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁- ▁3 ▁, ▁- ▁2 ▁, ▁- ▁1 ▁, ▁1 ▁} ▁, ▁{ ▁- ▁2 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁, ▁{ ▁4 ▁, ▁5 ▁, ▁7 ▁, ▁8 ▁} ▁} ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Negative ▁( ▁M ▁, ▁3 ▁, ▁4 ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁N ▁= ▁10 ▁; ▁static ▁int ▁find L argest Plus ▁( ▁int ▁mat ▁[ ▁] ▁[ ▁] ▁) ▁{ ▁int ▁left ▁[ ▁] ▁[ ▁] ▁= ▁new ▁int ▁[ ▁N ▁] ▁[ ▁N ▁] ▁; ▁int ▁right ▁[ ▁] ▁[ ▁] ▁= ▁new ▁int ▁[ ▁N ▁] ▁[ ▁N ▁] ▁; ▁int ▁top ▁[ ▁] ▁[ ▁] ▁= ▁new ▁int ▁[ ▁N ▁] ▁[ ▁N ▁] ▁; ▁int ▁bottom ▁[ ▁] ▁[ ▁] ▁= ▁new ▁int ▁[ ▁N ▁] ▁[ ▁N ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁top ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁= ▁mat ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁; ▁bottom ▁[ ▁N ▁- ▁1 ▁] ▁[ ▁i ▁] ▁= ▁mat ▁[ ▁N ▁- ▁1 ▁] ▁[ ▁i ▁] ▁; ▁left ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁= ▁mat ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁; ▁right ▁[ ▁i ▁] ▁[ ▁N ▁- ▁1 ▁] ▁= ▁mat ▁[ ▁i ▁] ▁[ ▁N ▁- ▁1 ▁] ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁== ▁1 ▁) ▁left ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁left ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁+ ▁1 ▁; ▁else ▁left ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁0 ▁; ▁if ▁( ▁mat ▁[ ▁j ▁] ▁[ ▁i ▁] ▁== ▁1 ▁) ▁top ▁[ ▁j ▁] ▁[ ▁i ▁] ▁= ▁top ▁[ ▁j ▁- ▁1 ▁] ▁[ ▁i ▁] ▁+ ▁1 ▁; ▁else ▁top ▁[ ▁j ▁] ▁[ ▁i ▁] ▁= ▁0 ▁; ▁j ▁= ▁N ▁- ▁1 ▁- ▁j ▁; ▁if ▁( ▁mat ▁[ ▁j ▁] ▁[ ▁i ▁] ▁== ▁1 ▁) ▁bottom ▁[ ▁j ▁] ▁[ ▁i ▁] ▁= ▁bottom ▁[ ▁j ▁+ ▁1 ▁] ▁[ ▁i ▁] ▁+ ▁1 ▁; ▁else ▁bottom ▁[ ▁j ▁] ▁[ ▁i ▁] ▁= ▁0 ▁; ▁if ▁( ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁== ▁1 ▁) ▁right ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁right ▁[ ▁i ▁] ▁[ ▁j ▁+ ▁1 ▁] ▁+ ▁1 ▁; ▁else ▁right ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁0 ▁; ▁j ▁= ▁N ▁- ▁1
▁class ▁G F G ▁{ ▁static ▁final ▁int ▁N ▁= ▁4 ▁; ▁static ▁void ▁add ▁( ▁int ▁A ▁[ ▁] ▁[ ▁] ▁, ▁int ▁B ▁[ ▁] ▁[ ▁] ▁, ▁int ▁C ▁[ ▁] ▁[ ▁] ▁) ▁{ ▁int ▁i ▁, ▁j ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁C ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁A ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+ ▁B ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁A ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁} ▁, ▁{ ▁2 ▁, ▁2 ▁, ▁2 ▁, ▁2 ▁} ▁, ▁{ ▁3 ▁, ▁3 ▁, ▁3 ▁, ▁3 ▁} ▁, ▁{ ▁4 ▁, ▁4 ▁, ▁4 ▁, ▁4 ▁} ▁} ▁; ▁int ▁B ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁} ▁, ▁{ ▁2 ▁, ▁2 ▁, ▁2 ▁, ▁2 ▁} ▁, ▁{ ▁3 ▁, ▁3 ▁, ▁3 ▁, ▁3 ▁} ▁, ▁{ ▁4 ▁, ▁4 ▁, ▁4 ▁, ▁4 ▁} ▁} ▁; ▁int ▁C ▁[ ▁] ▁[ ▁] ▁= ▁new ▁int ▁[ ▁N ▁] ▁[ ▁N ▁] ▁; ▁int ▁i ▁, ▁j ▁; ▁add ▁( ▁A ▁, ▁B ▁, ▁C ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" Result ▁matrix ▁is ▁NEW _ LINE "); ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁C ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+ ▁" ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" NEW _ LINE "); ▁} ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁final ▁int ▁N ▁= ▁4 ▁; ▁static ▁void ▁subtract ▁( ▁int ▁A ▁[ ▁] ▁[ ▁] ▁, ▁int ▁B ▁[ ▁] ▁[ ▁] ▁, ▁int ▁C ▁[ ▁] ▁[ ▁] ▁) ▁{ ▁int ▁i ▁, ▁j ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁C ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁A ▁[ ▁i ▁] ▁[ ▁j ▁] ▁- ▁B ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁A ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁} ▁, ▁{ ▁2 ▁, ▁2 ▁, ▁2 ▁, ▁2 ▁} ▁, ▁{ ▁3 ▁, ▁3 ▁, ▁3 ▁, ▁3 ▁} ▁, ▁{ ▁4 ▁, ▁4 ▁, ▁4 ▁, ▁4 ▁} ▁} ▁; ▁int ▁B ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁} ▁, ▁{ ▁2 ▁, ▁2 ▁, ▁2 ▁, ▁2 ▁} ▁, ▁{ ▁3 ▁, ▁3 ▁, ▁3 ▁, ▁3 ▁} ▁, ▁{ ▁4 ▁, ▁4 ▁, ▁4 ▁, ▁4 ▁} ▁} ▁; ▁int ▁C ▁[ ▁] ▁[ ▁] ▁= ▁new ▁int ▁[ ▁N ▁] ▁[ ▁N ▁] ▁; ▁int ▁i ▁, ▁j ▁; ▁subtract ▁( ▁A ▁, ▁B ▁, ▁C ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" Result ▁matrix ▁is ▁NEW _ LINE "); ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁C ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+ ▁" ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" NEW _ LINE "); ▁} ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁P eak Element ▁{ ▁static ▁int ▁find Peak Util ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁low ▁, ▁int ▁high ▁, ▁int ▁n ▁) ▁{ ▁int ▁mid ▁= ▁low ▁+ ▁( ▁high ▁- ▁low ▁) ▁/ ▁2 ▁; ▁if ▁( ▁( ▁mid ▁== ▁0 ▁arr ▁[ ▁mid ▁- ▁1 ▁] ▁<= ▁arr ▁[ ▁mid ▁] ▁) ▁&& ▁( ▁mid ▁== ▁n ▁- ▁1 ▁arr ▁[ ▁mid ▁+ ▁1 ▁] ▁<= ▁arr ▁[ ▁mid ▁] ▁) ▁) ▁return ▁mid ▁; ▁else ▁if ▁( ▁mid ▁> ▁0 ▁&& ▁arr ▁[ ▁mid ▁- ▁1 ▁] ▁> ▁arr ▁[ ▁mid ▁] ▁) ▁return ▁find Peak Util ▁( ▁arr ▁, ▁low ▁, ▁( ▁mid ▁- ▁1 ▁) ▁, ▁n ▁) ▁; ▁else ▁return ▁find Peak Util ▁( ▁arr ▁, ▁( ▁mid ▁+ ▁1 ▁) ▁, ▁high ▁, ▁n ▁) ▁; ▁} ▁static ▁int ▁find Peak ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁return ▁find Peak Util ▁( ▁arr ▁, ▁0 ▁, ▁n ▁- ▁1 ▁, ▁n ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁20 ▁, ▁4 ▁, ▁1 ▁, ▁0 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Index ▁of ▁a ▁peak ▁point ▁is ▁" ▁+ ▁find Peak ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁Repeat Element ▁{ ▁void ▁print Repe ating ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁size ▁) ▁{ ▁int ▁i ▁, ▁j ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Repeated ▁Elements ▁are ▁: ▁" ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁size ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁arr ▁[ ▁j ▁] ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Repeat Element ▁repeat ▁= ▁new ▁Repeat Element ▁( ▁) ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁2 ▁, ▁4 ▁, ▁5 ▁, ▁2 ▁, ▁3 ▁, ▁1 ▁} ▁; ▁int ▁arr _ size ▁= ▁arr ▁. ▁length ▁; ▁repeat ▁. ▁print Repe ating ▁( ▁arr ▁, ▁arr _ size ▁) ▁; ▁} ▁}
▁class ▁Repeat Element ▁{ ▁void ▁print Repe ating ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁size ▁) ▁{ ▁int ▁S ▁= ▁0 ▁; ▁int ▁P ▁= ▁1 ▁; ▁int ▁x ▁, ▁y ▁; ▁int ▁D ▁; ▁int ▁n ▁= ▁size ▁- ▁2 ▁, ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁{ ▁S ▁= ▁S ▁+ ▁arr ▁[ ▁i ▁] ▁; ▁P ▁= ▁P ▁* ▁arr ▁[ ▁i ▁] ▁; ▁} ▁S ▁= ▁S ▁- ▁n ▁* ▁( ▁n ▁+ ▁1 ▁) ▁/ ▁2 ▁; ▁P ▁= ▁P ▁/ ▁fact ▁( ▁n ▁) ▁; ▁D ▁= ▁( ▁int ▁) ▁Math ▁. ▁sqrt ▁( ▁S ▁* ▁S ▁- ▁4 ▁* ▁P ▁) ▁; ▁x ▁= ▁( ▁D ▁+ ▁S ▁) ▁/ ▁2 ▁; ▁y ▁= ▁( ▁S ▁- ▁D ▁) ▁/ ▁2 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁The ▁two ▁repeating ▁elements ▁are ▁: ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁x ▁+ ▁" ▁" ▁+ ▁y ▁) ▁; ▁} ▁int ▁fact ▁( ▁int ▁n ▁) ▁{ ▁return ▁( ▁n ▁== ▁0 ▁) ▁? ▁1 ▁: ▁n ▁* ▁fact ▁( ▁n ▁- ▁1 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Repeat Element ▁repeat ▁= ▁new ▁Repeat Element ▁( ▁) ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁2 ▁, ▁4 ▁, ▁5 ▁, ▁2 ▁, ▁3 ▁, ▁1 ▁} ▁; ▁int ▁arr _ size ▁= ▁arr ▁. ▁length ▁; ▁repeat ▁. ▁print Repe ating ▁( ▁arr ▁, ▁arr _ size ▁) ▁; ▁} ▁}
▁class ▁Repeat Element ▁{ ▁void ▁print Repe ating ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁size ▁) ▁{ ▁int ▁xor ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁int ▁set _ bit _ no ▁; ▁int ▁i ▁; ▁int ▁n ▁= ▁size ▁- ▁2 ▁; ▁int ▁x ▁= ▁0 ▁, ▁y ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁xor ▁^= ▁arr ▁[ ▁i ▁] ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁xor ▁^= ▁i ▁; ▁set _ bit _ no ▁= ▁( ▁xor ▁& ▁~ ▁( ▁xor ▁- ▁1 ▁) ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁{ ▁int ▁a ▁= ▁arr ▁[ ▁i ▁] ▁& ▁set _ bit _ no ▁; ▁if ▁( ▁a ▁!= ▁0 ▁) ▁x ▁= ▁x ▁^ ▁arr ▁[ ▁i ▁] ▁; ▁else ▁y ▁= ▁y ▁^ ▁arr ▁[ ▁i ▁] ▁; ▁} ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁a ▁= ▁i ▁& ▁set _ bit _ no ▁; ▁if ▁( ▁a ▁!= ▁0 ▁) ▁x ▁= ▁x ▁^ ▁i ▁; ▁else ▁y ▁= ▁y ▁^ ▁i ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁The ▁two ▁rep peated ▁elements ▁are ▁: ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁x ▁+ ▁" ▁" ▁+ ▁y ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Repeat Element ▁repeat ▁= ▁new ▁Repeat Element ▁( ▁) ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁2 ▁, ▁4 ▁, ▁5 ▁, ▁2 ▁, ▁3 ▁, ▁1 ▁} ▁; ▁int ▁arr _ size ▁= ▁arr ▁. ▁length ▁; ▁repeat ▁. ▁print Repe ating ▁( ▁arr ▁, ▁arr _ size ▁) ▁; ▁} ▁}
▁class ▁Main ▁{ ▁static ▁int ▁linear Search ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁i ▁) ▁return ▁i ▁; ▁} ▁return ▁- ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁- ▁10 ▁, ▁- ▁1 ▁, ▁0 ▁, ▁3 ▁, ▁10 ▁, ▁11 ▁, ▁30 ▁, ▁50 ▁, ▁100 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Fixed ▁Point ▁is ▁" ▁+ ▁linear Search ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁Sub array Sum ▁{ ▁int ▁sub Array Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁sum ▁) ▁{ ▁int ▁curr _ sum ▁= ▁arr ▁[ ▁0 ▁] ▁, ▁start ▁= ▁0 ▁, ▁i ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁while ▁( ▁curr _ sum ▁> ▁sum ▁&& ▁start ▁< ▁i ▁- ▁1 ▁) ▁{ ▁curr _ sum ▁= ▁curr _ sum ▁- ▁arr ▁[ ▁start ▁] ▁; ▁start ▁++ ▁; ▁} ▁if ▁( ▁curr _ sum ▁== ▁sum ▁) ▁{ ▁int ▁p ▁= ▁i ▁- ▁1 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Sum ▁found ▁between ▁indexes ▁" ▁+ ▁start ▁+ ▁" ▁and ▁" ▁+ ▁p ▁) ▁; ▁return ▁1 ▁; ▁} ▁if ▁( ▁i ▁< ▁n ▁) ▁curr _ sum ▁= ▁curr _ sum ▁+ ▁arr ▁[ ▁i ▁] ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁sub array ▁found ▁" ▁) ▁; ▁return ▁0 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Sub array Sum ▁array sum ▁= ▁new ▁Sub array Sum ▁( ▁) ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁15 ▁, ▁2 ▁, ▁4 ▁, ▁8 ▁, ▁9 ▁, ▁5 ▁, ▁10 ▁, ▁23 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁int ▁sum ▁= ▁23 ▁; ▁array sum ▁. ▁sub Array Sum ▁( ▁arr ▁, ▁n ▁, ▁sum ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁maximum ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁int ▁c ▁) ▁{ ▁return ▁Math ▁. ▁max ▁( ▁Math ▁. ▁max ▁( ▁a ▁, ▁b ▁) ▁, ▁c ▁) ▁; ▁} ▁static ▁int ▁minimum ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁int ▁c ▁) ▁{ ▁return ▁Math ▁. ▁min ▁( ▁Math ▁. ▁min ▁( ▁a ▁, ▁b ▁) ▁, ▁c ▁) ▁; ▁} ▁static ▁void ▁smallest Difference Tri plet ▁( ▁int ▁arr 1 ▁[ ▁] ▁, ▁int ▁arr 2 ▁[ ▁] ▁, ▁int ▁arr 3 ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁arr 1 ▁) ▁; ▁Arrays ▁. ▁sort ▁( ▁arr 2 ▁) ▁; ▁Arrays ▁. ▁sort ▁( ▁arr 3 ▁) ▁; ▁int ▁res _ min ▁= ▁0 ▁, ▁res _ max ▁= ▁0 ▁, ▁res _ mid ▁= ▁0 ▁; ▁int ▁i ▁= ▁0 ▁, ▁j ▁= ▁0 ▁, ▁k ▁= ▁0 ▁; ▁int ▁diff ▁= ▁214748364 7 ▁; ▁while ▁( ▁i ▁< ▁n ▁&& ▁j ▁< ▁n ▁&& ▁k ▁< ▁n ▁) ▁{ ▁int ▁sum ▁= ▁arr 1 ▁[ ▁i ▁] ▁+ ▁arr 2 ▁[ ▁j ▁] ▁+ ▁arr 3 ▁[ ▁k ▁] ▁; ▁int ▁max ▁= ▁maximum ▁( ▁arr 1 ▁[ ▁i ▁] ▁, ▁arr 2 ▁[ ▁j ▁] ▁, ▁arr 3 ▁[ ▁k ▁] ▁) ▁; ▁int ▁min ▁= ▁minimum ▁( ▁arr 1 ▁[ ▁i ▁] ▁, ▁arr 2 ▁[ ▁j ▁] ▁, ▁arr 3 ▁[ ▁k ▁] ▁) ▁; ▁if ▁( ▁min ▁== ▁arr 1 ▁[ ▁i ▁] ▁) ▁i ▁++ ▁; ▁else ▁if ▁( ▁min ▁== ▁arr 2 ▁[ ▁j ▁] ▁) ▁j ▁++ ▁; ▁else ▁k ▁++ ▁; ▁if ▁( ▁diff ▁> ▁( ▁max ▁- ▁min ▁) ▁) ▁{ ▁diff ▁= ▁max ▁- ▁min ▁; ▁res _ max ▁= ▁max ▁; ▁res _ mid ▁= ▁sum ▁- ▁( ▁max ▁+ ▁min ▁) ▁; ▁res _ min ▁= ▁min ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁res _ max ▁+ ▁" ▁, ▁" ▁+ ▁res _ mid ▁+ ▁" ▁, ▁" ▁+ ▁res _ min ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr 1 ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁2 ▁, ▁8 ▁} ▁; ▁int ▁arr 2 ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁7 ▁, ▁12 ▁} ▁; ▁int ▁arr 3 ▁[ ▁] ▁= ▁{ ▁9
▁class ▁Find Tri plet ▁{ ▁boolean ▁find 3 Numbers ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁arr _ size ▁, ▁int ▁sum ▁) ▁{ ▁int ▁l ▁, ▁r ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁arr _ size ▁- ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁arr _ size ▁- ▁1 ▁; ▁j ▁++ ▁) ▁{ ▁for ▁( ▁int ▁k ▁= ▁j ▁+ ▁1 ▁; ▁k ▁< ▁arr _ size ▁; ▁k ▁++ ▁) ▁{ ▁if ▁( ▁A ▁[ ▁i ▁] ▁+ ▁A ▁[ ▁j ▁] ▁+ ▁A ▁[ ▁k ▁] ▁== ▁sum ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Tri plet ▁is ▁" ▁+ ▁A ▁[ ▁i ▁] ▁+ ▁" ▁, ▁" ▁+ ▁A ▁[ ▁j ▁] ▁+ ▁" ▁, ▁" ▁+ ▁A ▁[ ▁k ▁] ▁) ▁; ▁return ▁true ▁; ▁} ▁} ▁} ▁} ▁return ▁false ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Find Tri plet ▁tri plet ▁= ▁new ▁Find Tri plet ▁( ▁) ▁; ▁int ▁A ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁4 ▁, ▁45 ▁, ▁6 ▁, ▁10 ▁, ▁8 ▁} ▁; ▁int ▁sum ▁= ▁22 ▁; ▁int ▁arr _ size ▁= ▁A ▁. ▁length ▁; ▁tri plet ▁. ▁find 3 Numbers ▁( ▁A ▁, ▁arr _ size ▁, ▁sum ▁) ▁; ▁} ▁}
▁class ▁Test ▁{ ▁static ▁int ▁arr ▁[ ▁] ▁= ▁new ▁int ▁[ ▁] ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁static ▁void ▁sub Array ▁( ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁for ▁( ▁int ▁k ▁= ▁i ▁; ▁k ▁<= ▁j ▁; ▁k ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁k ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁All ▁Non ▁- ▁empty ▁Sub arrays ▁" ▁) ▁; ▁sub Array ▁( ▁arr ▁. ▁length ▁) ▁; ▁} ▁}
▁class ▁Are Con secutive ▁{ ▁boolean ▁are Con secutive ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁< ▁1 ▁) ▁return ▁false ▁; ▁int ▁min ▁= ▁getMin ▁( ▁arr ▁, ▁n ▁) ▁; ▁int ▁max ▁= ▁getMax ▁( ▁arr ▁, ▁n ▁) ▁; ▁if ▁( ▁max ▁- ▁min ▁+ ▁1 ▁== ▁n ▁) ▁{ ▁boolean ▁visited ▁[ ▁] ▁= ▁new ▁boolean ▁[ ▁n ▁] ▁; ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁visited ▁[ ▁arr ▁[ ▁i ▁] ▁- ▁min ▁] ▁!= ▁false ▁) ▁return ▁false ▁; ▁visited ▁[ ▁arr ▁[ ▁i ▁] ▁- ▁min ▁] ▁= ▁true ▁; ▁} ▁return ▁true ▁; ▁} ▁return ▁false ▁; ▁} ▁int ▁getMin ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁min ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁min ▁) ▁min ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁return ▁min ▁; ▁} ▁int ▁getMax ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁max ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁max ▁) ▁max ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁return ▁max ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Are Con secutive ▁consecutive ▁= ▁new ▁Are Con secutive ▁( ▁) ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁4 ▁, ▁2 ▁, ▁3 ▁, ▁1 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁if ▁( ▁consecutive ▁. ▁are Con secutive ▁( ▁arr ▁, ▁n ▁) ▁== ▁true ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Array ▁elements ▁are ▁consecutive ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Array ▁elements ▁are ▁not ▁consecutive ▁" ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁public ▁static ▁int ▁search ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁x ▁) ▁{ ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁x ▁) ▁return ▁i ▁; ▁} ▁return ▁- ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁10 ▁, ▁40 ▁} ▁; ▁int ▁x ▁= ▁10 ▁; ▁int ▁result ▁= ▁search ▁( ▁arr ▁, ▁x ▁) ▁; ▁if ▁( ▁result ▁== ▁- ▁1 ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Element ▁is ▁not ▁present ▁in ▁array ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Element ▁is ▁present ▁at ▁index ▁" ▁+ ▁result ▁) ▁; ▁} ▁}
▁class ▁Binary Search ▁{ ▁int ▁binarySearch ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁l ▁, ▁int ▁r ▁, ▁int ▁x ▁) ▁{ ▁if ▁( ▁r ▁>= ▁l ▁) ▁{ ▁int ▁mid ▁= ▁l ▁+ ▁( ▁r ▁- ▁l ▁) ▁/ ▁2 ▁; ▁if ▁( ▁arr ▁[ ▁mid ▁] ▁== ▁x ▁) ▁return ▁mid ▁; ▁if ▁( ▁arr ▁[ ▁mid ▁] ▁> ▁x ▁) ▁return ▁binarySearch ▁( ▁arr ▁, ▁l ▁, ▁mid ▁- ▁1 ▁, ▁x ▁) ▁; ▁return ▁binarySearch ▁( ▁arr ▁, ▁mid ▁+ ▁1 ▁, ▁r ▁, ▁x ▁) ▁; ▁} ▁return ▁- ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁Binary Search ▁ob ▁= ▁new ▁Binary Search ▁( ▁) ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁10 ▁, ▁40 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁int ▁x ▁= ▁10 ▁; ▁int ▁result ▁= ▁ob ▁. ▁binarySearch ▁( ▁arr ▁, ▁0 ▁, ▁n ▁- ▁1 ▁, ▁x ▁) ▁; ▁if ▁( ▁result ▁== ▁- ▁1 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Element ▁not ▁present ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Element ▁found ▁at ▁index ▁" ▁+ ▁result ▁) ▁; ▁} ▁}
▁class ▁Counting Sort ▁{ ▁void ▁sort ▁( ▁char ▁arr ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁char ▁output ▁[ ▁] ▁= ▁new ▁char ▁[ ▁n ▁] ▁; ▁int ▁count ▁[ ▁] ▁= ▁new ▁int ▁[ ▁256 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁256 ▁; ▁++ ▁i ▁) ▁count ▁[ ▁i ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁++ ▁count ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁255 ▁; ▁++ ▁i ▁) ▁count ▁[ ▁i ▁] ▁+= ▁count ▁[ ▁i ▁- ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁output ▁[ ▁count ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁- ▁1 ▁] ▁= ▁arr ▁[ ▁i ▁] ▁; ▁-- ▁count ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁arr ▁[ ▁i ▁] ▁= ▁output ▁[ ▁i ▁] ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁Counting Sort ▁ob ▁= ▁new ▁Counting Sort ▁( ▁) ▁; ▁char ▁arr ▁[ ▁] ▁= ▁{ ▁' ▁g ▁' ▁, ▁' ▁e ▁' ▁, ▁' ▁e ▁' ▁, ▁' ▁k ▁' ▁, ▁' ▁s ▁' ▁, ▁' ▁f ▁' ▁, ▁' ▁o ▁' ▁, ▁' ▁r ▁' ▁, ▁' ▁g ▁' ▁, ▁' ▁e ▁' ▁, ▁' ▁e ▁' ▁, ▁' ▁k ▁' ▁, ▁' ▁s ▁' ▁} ▁; ▁ob ▁. ▁sort ▁( ▁arr ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Sorted ▁character ▁array ▁is ▁" ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁arr ▁. ▁length ▁; ▁++ ▁i ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁count Sort ▁( ▁int ▁[ ▁] ▁arr ▁) ▁{ ▁int ▁max ▁= ▁Arrays ▁. ▁stream ▁( ▁arr ▁) ▁. ▁max ▁( ▁) ▁. ▁getAs Int ▁( ▁) ▁; ▁int ▁min ▁= ▁Arrays ▁. ▁stream ▁( ▁arr ▁) ▁. ▁min ▁( ▁) ▁. ▁getAs Int ▁( ▁) ▁; ▁int ▁range ▁= ▁max ▁- ▁min ▁+ ▁1 ▁; ▁int ▁count ▁[ ▁] ▁= ▁new ▁int ▁[ ▁range ▁] ▁; ▁int ▁output ▁[ ▁] ▁= ▁new ▁int ▁[ ▁arr ▁. ▁length ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁arr ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁count ▁[ ▁arr ▁[ ▁i ▁] ▁- ▁min ▁] ▁++ ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁count ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁count ▁[ ▁i ▁] ▁+= ▁count ▁[ ▁i ▁- ▁1 ▁] ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁arr ▁. ▁length ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁output ▁[ ▁count ▁[ ▁arr ▁[ ▁i ▁] ▁- ▁min ▁] ▁- ▁1 ▁] ▁= ▁arr ▁[ ▁i ▁] ▁; ▁count ▁[ ▁arr ▁[ ▁i ▁] ▁- ▁min ▁] ▁-- ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁arr ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁arr ▁[ ▁i ▁] ▁= ▁output ▁[ ▁i ▁] ▁; ▁} ▁} ▁static ▁void ▁print Array ▁( ▁int ▁[ ▁] ▁arr ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁arr ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁- ▁5 ▁, ▁- ▁10 ▁, ▁0 ▁, ▁- ▁3 ▁, ▁8 ▁, ▁5 ▁, ▁- ▁1 ▁, ▁10 ▁} ▁; ▁count Sort ▁( ▁arr ▁) ▁; ▁print Array ▁( ▁arr ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁void ▁cycle Sort ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁writes ▁= ▁0 ▁; ▁for ▁( ▁int ▁cycle _ start ▁= ▁0 ▁; ▁cycle _ start ▁<= ▁n ▁- ▁2 ▁; ▁cycle _ start ▁++ ▁) ▁{ ▁int ▁item ▁= ▁arr ▁[ ▁cycle _ start ▁] ▁; ▁int ▁pos ▁= ▁cycle _ start ▁; ▁for ▁( ▁int ▁i ▁= ▁cycle _ start ▁+ ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁item ▁) ▁pos ▁++ ▁; ▁if ▁( ▁pos ▁== ▁cycle _ start ▁) ▁continue ▁; ▁while ▁( ▁item ▁== ▁arr ▁[ ▁pos ▁] ▁) ▁pos ▁+= ▁1 ▁; ▁if ▁( ▁pos ▁!= ▁cycle _ start ▁) ▁{ ▁int ▁temp ▁= ▁item ▁; ▁item ▁= ▁arr ▁[ ▁pos ▁] ▁; ▁arr ▁[ ▁pos ▁] ▁= ▁temp ▁; ▁writes ▁++ ▁; ▁} ▁while ▁( ▁pos ▁!= ▁cycle _ start ▁) ▁{ ▁pos ▁= ▁cycle _ start ▁; ▁for ▁( ▁int ▁i ▁= ▁cycle _ start ▁+ ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁item ▁) ▁pos ▁+= ▁1 ▁; ▁while ▁( ▁item ▁== ▁arr ▁[ ▁pos ▁] ▁) ▁pos ▁+= ▁1 ▁; ▁if ▁( ▁item ▁!= ▁arr ▁[ ▁pos ▁] ▁) ▁{ ▁int ▁temp ▁= ▁item ▁; ▁item ▁= ▁arr ▁[ ▁pos ▁] ▁; ▁arr ▁[ ▁pos ▁] ▁= ▁temp ▁; ▁writes ▁++ ▁; ▁} ▁} ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁8 ▁, ▁3 ▁, ▁9 ▁, ▁10 ▁, ▁10 ▁, ▁2 ▁, ▁4 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁cycle Sort ▁( ▁arr ▁, ▁n ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁After ▁sort ▁: ▁" ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁}
▁class ▁Clo sest Pair ▁{ ▁void ▁print Clo sest ▁( ▁int ▁ar 1 ▁[ ▁] ▁, ▁int ▁ar 2 ▁[ ▁] ▁, ▁int ▁m ▁, ▁int ▁n ▁, ▁int ▁x ▁) ▁{ ▁int ▁diff ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁int ▁res _ l ▁= ▁0 ▁, ▁res _ r ▁= ▁0 ▁; ▁int ▁l ▁= ▁0 ▁, ▁r ▁= ▁n ▁- ▁1 ▁; ▁while ▁( ▁l ▁< ▁m ▁&& ▁r ▁>= ▁0 ▁) ▁{ ▁if ▁( ▁Math ▁. ▁abs ▁( ▁ar 1 ▁[ ▁l ▁] ▁+ ▁ar 2 ▁[ ▁r ▁] ▁- ▁x ▁) ▁< ▁diff ▁) ▁{ ▁res _ l ▁= ▁l ▁; ▁res _ r ▁= ▁r ▁; ▁diff ▁= ▁Math ▁. ▁abs ▁( ▁ar 1 ▁[ ▁l ▁] ▁+ ▁ar 2 ▁[ ▁r ▁] ▁- ▁x ▁) ▁; ▁} ▁if ▁( ▁ar 1 ▁[ ▁l ▁] ▁+ ▁ar 2 ▁[ ▁r ▁] ▁> ▁x ▁) ▁r ▁-- ▁; ▁else ▁l ▁++ ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁The ▁closest ▁pair ▁is ▁[ ▁" ▁+ ▁ar 1 ▁[ ▁res _ l ▁] ▁+ ▁" ▁, ▁" ▁+ ▁ar 2 ▁[ ▁res _ r ▁] ▁+ ▁" ▁] ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁Clo sest Pair ▁ob ▁= ▁new ▁Clo sest Pair ▁( ▁) ▁; ▁int ▁ar 1 ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁4 ▁, ▁5 ▁, ▁7 ▁} ▁; ▁int ▁ar 2 ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁20 ▁, ▁30 ▁, ▁40 ▁} ▁; ▁int ▁m ▁= ▁ar 1 ▁. ▁length ▁; ▁int ▁n ▁= ▁ar 2 ▁. ▁length ▁; ▁int ▁x ▁= ▁38 ▁; ▁ob ▁. ▁print Clo sest ▁( ▁ar 1 ▁, ▁ar 2 ▁, ▁m ▁, ▁n ▁, ▁x ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁Activity Selection ▁{ ▁public ▁static ▁void ▁print Max Activities ▁( ▁int ▁s ▁[ ▁] ▁, ▁int ▁f ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁i ▁, ▁j ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Following ▁activities ▁are ▁selected ▁: ▁n ▁" ▁) ▁; ▁i ▁= ▁0 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁i ▁+ ▁" ▁" ▁) ▁; ▁for ▁( ▁j ▁= ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁s ▁[ ▁j ▁] ▁>= ▁f ▁[ ▁i ▁] ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁j ▁+ ▁" ▁" ▁) ▁; ▁i ▁= ▁j ▁; ▁} ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁s ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁0 ▁, ▁5 ▁, ▁8 ▁, ▁5 ▁} ▁; ▁int ▁f ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁4 ▁, ▁6 ▁, ▁7 ▁, ▁9 ▁, ▁9 ▁} ▁; ▁int ▁n ▁= ▁s ▁. ▁length ▁; ▁print Max Activities ▁( ▁s ▁, ▁f ▁, ▁n ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁bin omial Co eff ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁if ▁( ▁k ▁> ▁n ▁) ▁return ▁0 ▁; ▁if ▁( ▁k ▁== ▁0 ▁k ▁== ▁n ▁) ▁return ▁1 ▁; ▁return ▁bin omial Co eff ▁( ▁n ▁- ▁1 ▁, ▁k ▁- ▁1 ▁) ▁+ ▁bin omial Co eff ▁( ▁n ▁- ▁1 ▁, ▁k ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁5 ▁, ▁k ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁Value ▁of ▁C ▁( ▁% ▁d ▁, ▁% ▁d ▁) ▁is ▁% ▁d ▁" ▁, ▁n ▁, ▁k ▁, ▁bin omial Co eff ▁( ▁n ▁, ▁k ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁getCount ▁( ▁char ▁key pad ▁[ ▁] ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁key pad ▁== ▁null ▁n ▁<= ▁0 ▁) ▁return ▁0 ▁; ▁if ▁( ▁n ▁== ▁1 ▁) ▁return ▁10 ▁; ▁int ▁row ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁0 ▁, ▁- ▁1 ▁, ▁0 ▁, ▁1 ▁} ▁; ▁int ▁col ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁- ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁} ▁; ▁int ▁[ ▁] ▁[ ▁] ▁count ▁= ▁new ▁int ▁[ ▁10 ▁] ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁int ▁i ▁= ▁0 ▁, ▁j ▁= ▁0 ▁, ▁k ▁= ▁0 ▁, ▁move ▁= ▁0 ▁, ▁ro ▁= ▁0 ▁, ▁co ▁= ▁0 ▁, ▁num ▁= ▁0 ▁; ▁int ▁next Num ▁= ▁0 ▁, ▁totalCount ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁<= ▁9 ▁; ▁i ▁++ ▁) ▁{ ▁count ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁count ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁= ▁1 ▁; ▁} ▁for ▁( ▁k ▁= ▁2 ▁; ▁k ▁<= ▁n ▁; ▁k ▁++ ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁4 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁3 ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁key pad ▁[ ▁i ▁] ▁[ ▁j ▁] ▁!= ▁' ▁* ▁' ▁&& ▁key pad ▁[ ▁i ▁] ▁[ ▁j ▁] ▁!= ▁' ▁# ▁' ▁) ▁{ ▁num ▁= ▁key pad ▁[ ▁i ▁] ▁[ ▁j ▁] ▁- ▁'0' ▁; ▁count ▁[ ▁num ▁] ▁[ ▁k ▁] ▁= ▁0 ▁; ▁for ▁( ▁move ▁= ▁0 ▁; ▁move ▁< ▁5 ▁; ▁move ▁++ ▁) ▁{ ▁ro ▁= ▁i ▁+ ▁row ▁[ ▁move ▁] ▁; ▁co ▁= ▁j ▁+ ▁col ▁[ ▁move ▁] ▁; ▁if ▁( ▁ro ▁>= ▁0 ▁&& ▁ro ▁<= ▁3 ▁&& ▁co ▁>= ▁0 ▁&& ▁co ▁<= ▁2 ▁&& ▁key pad ▁[ ▁ro ▁] ▁[ ▁co ▁] ▁!= ▁' ▁* ▁' ▁&& ▁key pad ▁[ ▁ro ▁] ▁[ ▁co ▁] ▁!= ▁' ▁# ▁' ▁) ▁{ ▁next Num ▁= ▁key pad ▁[ ▁ro ▁] ▁[ ▁co ▁] ▁- ▁'0' ▁; ▁count ▁[ ▁num ▁] ▁[ ▁k ▁] ▁+= ▁count ▁[ ▁next Num ▁] ▁[ ▁k ▁- ▁1 ▁] ▁; ▁} ▁} ▁} ▁} ▁} ▁} ▁totalCount ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁<= ▁9 ▁; ▁i ▁++ ▁) ▁totalCount ▁+=
▁class ▁sum _ dig ▁{ ▁static ▁int ▁count Rec ▁( ▁int ▁n ▁, ▁int ▁sum ▁) ▁{ ▁if ▁( ▁n ▁== ▁0 ▁) ▁return ▁sum ▁== ▁0 ▁? ▁1 ▁: ▁0 ▁; ▁if ▁( ▁sum ▁== ▁0 ▁) ▁return ▁1 ▁; ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁9 ▁; ▁i ▁++ ▁) ▁if ▁( ▁sum ▁- ▁i ▁>= ▁0 ▁) ▁ans ▁+= ▁count Rec ▁( ▁n ▁- ▁1 ▁, ▁sum ▁- ▁i ▁) ▁; ▁return ▁ans ▁; ▁} ▁static ▁int ▁final Count ▁( ▁int ▁n ▁, ▁int ▁sum ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁9 ▁; ▁i ▁++ ▁) ▁if ▁( ▁sum ▁- ▁i ▁>= ▁0 ▁) ▁ans ▁+= ▁count Rec ▁( ▁n ▁- ▁1 ▁, ▁sum ▁- ▁i ▁) ▁; ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁2 ▁, ▁sum ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁final Count ▁( ▁n ▁, ▁sum ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁G F G ▁{ ▁private ▁static ▁void ▁find Count ▁( ▁int ▁n ▁, ▁int ▁sum ▁) ▁{ ▁int ▁start ▁= ▁( ▁int ▁) ▁Math ▁. ▁pow ▁( ▁10 ▁, ▁n ▁- ▁1 ▁) ▁; ▁int ▁end ▁= ▁( ▁int ▁) ▁Math ▁. ▁pow ▁( ▁10 ▁, ▁n ▁) ▁- ▁1 ▁; ▁int ▁count ▁= ▁0 ▁; ▁int ▁i ▁= ▁start ▁; ▁while ▁( ▁i ▁< ▁end ▁) ▁{ ▁int ▁cur ▁= ▁0 ▁; ▁int ▁temp ▁= ▁i ▁; ▁while ▁( ▁temp ▁!= ▁0 ▁) ▁{ ▁cur ▁+= ▁temp ▁% ▁10 ▁; ▁temp ▁= ▁temp ▁/ ▁10 ▁; ▁} ▁if ▁( ▁cur ▁== ▁sum ▁) ▁{ ▁count ▁++ ▁; ▁i ▁+= ▁9 ▁; ▁} ▁else ▁i ▁++ ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁count ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁3 ▁; ▁int ▁sum ▁= ▁5 ▁; ▁find Count ▁( ▁n ▁, ▁sum ▁) ▁; ▁} ▁}
▁class ▁squares ▁{ ▁static ▁int ▁getMin Square s ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁<= ▁3 ▁) ▁return ▁n ▁; ▁int ▁res ▁= ▁n ▁; ▁for ▁( ▁int ▁x ▁= ▁1 ▁; ▁x ▁<= ▁n ▁; ▁x ▁++ ▁) ▁{ ▁int ▁temp ▁= ▁x ▁* ▁x ▁; ▁if ▁( ▁temp ▁> ▁n ▁) ▁break ▁; ▁else ▁res ▁= ▁Math ▁. ▁min ▁( ▁res ▁, ▁1 ▁+ ▁getMin Square s ▁( ▁n ▁- ▁temp ▁) ▁) ▁; ▁} ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁getMin Square s ▁( ▁6 ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁math ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁sum Of Digits From 1 To N Util ▁( ▁int ▁n ▁, ▁int ▁a ▁[ ▁] ▁) ▁{ ▁if ▁( ▁n ▁< ▁10 ▁) ▁return ▁( ▁n ▁* ▁( ▁n ▁+ ▁1 ▁) ▁/ ▁2 ▁) ▁; ▁int ▁d ▁= ▁( ▁int ▁) ▁( ▁Math ▁. ▁log 10 ▁( ▁n ▁) ▁) ▁; ▁int ▁p ▁= ▁( ▁int ▁) ▁( ▁Math ▁. ▁ceil ▁( ▁Math ▁. ▁pow ▁( ▁10 ▁, ▁d ▁) ▁) ▁) ▁; ▁int ▁ms d ▁= ▁n ▁/ ▁p ▁; ▁return ▁( ▁ms d ▁* ▁a ▁[ ▁d ▁] ▁+ ▁( ▁ms d ▁* ▁( ▁ms d ▁- ▁1 ▁) ▁/ ▁2 ▁) ▁* ▁p ▁+ ▁ms d ▁* ▁( ▁1 ▁+ ▁n ▁% ▁p ▁) ▁+ ▁sum Of Digits From 1 To N Util ▁( ▁n ▁% ▁p ▁, ▁a ▁) ▁) ▁; ▁} ▁static ▁int ▁sum Of Digits From 1 To N ▁( ▁int ▁n ▁) ▁{ ▁int ▁d ▁= ▁( ▁int ▁) ▁( ▁Math ▁. ▁log 10 ▁( ▁n ▁) ▁) ▁; ▁int ▁a ▁[ ▁] ▁= ▁new ▁int ▁[ ▁d ▁+ ▁1 ▁] ▁; ▁a ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁a ▁[ ▁1 ▁] ▁= ▁45 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁d ▁; ▁i ▁++ ▁) ▁a ▁[ ▁i ▁] ▁= ▁a ▁[ ▁i ▁- ▁1 ▁] ▁* ▁10 ▁+ ▁45 ▁* ▁( ▁int ▁) ▁( ▁Math ▁. ▁ceil ▁( ▁Math ▁. ▁pow ▁( ▁10 ▁, ▁i ▁- ▁1 ▁) ▁) ▁) ▁; ▁return ▁sum Of Digits From 1 To N Util ▁( ▁n ▁, ▁a ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁3 28 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Sum ▁of ▁digits ▁in ▁numbers ▁" ▁+ ▁" ▁from ▁1 ▁to ▁" ▁+ ▁n ▁+ ▁" ▁is ▁" ▁+ ▁sum Of Digits From 1 To N ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁find opt imal ▁( ▁int ▁N ▁) ▁{ ▁if ▁( ▁N ▁<= ▁6 ▁) ▁return ▁N ▁; ▁int ▁max ▁= ▁0 ▁; ▁int ▁b ▁; ▁for ▁( ▁b ▁= ▁N ▁- ▁3 ▁; ▁b ▁>= ▁1 ▁; ▁b ▁-- ▁) ▁{ ▁int ▁curr ▁= ▁( ▁N ▁- ▁b ▁- ▁1 ▁) ▁* ▁find opt imal ▁( ▁b ▁) ▁; ▁if ▁( ▁curr ▁> ▁max ▁) ▁max ▁= ▁curr ▁; ▁} ▁return ▁max ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁; ▁for ▁( ▁N ▁= ▁1 ▁; ▁N ▁<= ▁20 ▁; ▁N ▁++ ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Maximum ▁Number ▁of ▁A ▁' ▁s ▁with ▁key st rokes ▁is ▁" ▁+ ▁N ▁+ ▁find opt imal ▁( ▁N ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁search ▁( ▁String ▁pat ▁, ▁String ▁txt ▁) ▁{ ▁int ▁M ▁= ▁pat ▁. ▁length ▁( ▁) ▁; ▁int ▁N ▁= ▁txt ▁. ▁length ▁( ▁) ▁; ▁int ▁i ▁= ▁0 ▁; ▁while ▁( ▁i ▁<= ▁N ▁- ▁M ▁) ▁{ ▁int ▁j ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁M ▁; ▁j ▁++ ▁) ▁if ▁( ▁txt ▁. ▁charAt ▁( ▁i ▁+ ▁j ▁) ▁!= ▁pat ▁. ▁charAt ▁( ▁j ▁) ▁) ▁break ▁; ▁if ▁( ▁j ▁== ▁M ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Pattern ▁found ▁at ▁index ▁" ▁+ ▁i ▁) ▁; ▁i ▁= ▁i ▁+ ▁M ▁; ▁} ▁else ▁if ▁( ▁j ▁== ▁0 ▁) ▁i ▁= ▁i ▁+ ▁1 ▁; ▁else ▁i ▁= ▁i ▁+ ▁j ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁txt ▁= ▁" ▁AB CE AB CD AB CE AB CD ▁" ▁; ▁String ▁pat ▁= ▁" ▁AB CD ▁" ▁; ▁search ▁( ▁pat ▁, ▁txt ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁float ▁power ▁( ▁float ▁x ▁, ▁int ▁y ▁) ▁{ ▁float ▁temp ▁; ▁if ▁( ▁y ▁== ▁0 ▁) ▁return ▁1 ▁; ▁temp ▁= ▁power ▁( ▁x ▁, ▁y ▁/ ▁2 ▁) ▁; ▁if ▁( ▁y ▁% ▁2 ▁== ▁0 ▁) ▁return ▁temp ▁* ▁temp ▁; ▁else ▁{ ▁if ▁( ▁y ▁> ▁0 ▁) ▁return ▁x ▁* ▁temp ▁* ▁temp ▁; ▁else ▁return ▁( ▁temp ▁* ▁temp ▁) ▁/ ▁x ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁float ▁x ▁= ▁2 ▁; ▁int ▁y ▁= ▁- ▁3 ▁; ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁% ▁f ▁" ▁, ▁power ▁( ▁x ▁, ▁y ▁) ▁) ▁; ▁} ▁}
▁class ▁Main ▁{ ▁static ▁int ▁getM edi an ▁( ▁int ▁ar 1 ▁[ ▁] ▁, ▁int ▁ar 2 ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁i ▁= ▁0 ▁; ▁int ▁j ▁= ▁0 ▁; ▁int ▁count ▁; ▁int ▁m 1 ▁= ▁- ▁1 ▁, ▁m 2 ▁= ▁- ▁1 ▁; ▁for ▁( ▁count ▁= ▁0 ▁; ▁count ▁<= ▁n ▁; ▁count ▁++ ▁) ▁{ ▁if ▁( ▁i ▁== ▁n ▁) ▁{ ▁m 1 ▁= ▁m 2 ▁; ▁m 2 ▁= ▁ar 2 ▁[ ▁0 ▁] ▁; ▁break ▁; ▁} ▁else ▁if ▁( ▁j ▁== ▁n ▁) ▁{ ▁m 1 ▁= ▁m 2 ▁; ▁m 2 ▁= ▁ar 1 ▁[ ▁0 ▁] ▁; ▁break ▁; ▁} ▁if ▁( ▁ar 1 ▁[ ▁i ▁] ▁<= ▁ar 2 ▁[ ▁j ▁] ▁) ▁{ ▁m 1 ▁= ▁m 2 ▁; ▁m 2 ▁= ▁ar 1 ▁[ ▁i ▁] ▁; ▁i ▁++ ▁; ▁} ▁else ▁{ ▁m 1 ▁= ▁m 2 ▁; ▁m 2 ▁= ▁ar 2 ▁[ ▁j ▁] ▁; ▁j ▁++ ▁; ▁} ▁} ▁return ▁( ▁m 1 ▁+ ▁m 2 ▁) ▁/ ▁2 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁ar 1 ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁12 ▁, ▁15 ▁, ▁26 ▁, ▁38 ▁} ▁; ▁int ▁ar 2 ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁13 ▁, ▁17 ▁, ▁30 ▁, ▁45 ▁} ▁; ▁int ▁n 1 ▁= ▁ar 1 ▁. ▁length ▁; ▁int ▁n 2 ▁= ▁ar 2 ▁. ▁length ▁; ▁if ▁( ▁n 1 ▁== ▁n 2 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Medi an ▁is ▁" ▁+ ▁getM edi an ▁( ▁ar 1 ▁, ▁ar 2 ▁, ▁n 1 ▁) ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁arrays ▁are ▁of ▁un equal ▁size ▁" ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁float ▁square Root ▁( ▁float ▁n ▁) ▁{ ▁float ▁x ▁= ▁n ▁; ▁float ▁y ▁= ▁1 ▁; ▁double ▁e ▁= ▁0. 000001 ▁; ▁while ▁( ▁x ▁- ▁y ▁> ▁e ▁) ▁{ ▁x ▁= ▁( ▁x ▁+ ▁y ▁) ▁/ ▁2 ▁; ▁y ▁= ▁n ▁/ ▁x ▁; ▁} ▁return ▁x ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁50 ▁; ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁Square ▁root ▁of ▁" ▁+ ▁n ▁+ ▁" ▁is ▁" ▁+ ▁square Root ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁multiply ▁( ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁if ▁( ▁y ▁== ▁0 ▁) ▁return ▁0 ▁; ▁if ▁( ▁y ▁> ▁0 ▁) ▁return ▁( ▁x ▁+ ▁multiply ▁( ▁x ▁, ▁y ▁- ▁1 ▁) ▁) ▁; ▁if ▁( ▁y ▁< ▁0 ▁) ▁return ▁- ▁multiply ▁( ▁x ▁, ▁- ▁y ▁) ▁; ▁return ▁- ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" NEW _ LINE " ▁+ ▁multiply (5, ▁- 11 )); ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁pow ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁if ▁( ▁b ▁== ▁0 ▁) ▁return ▁1 ▁; ▁int ▁answer ▁= ▁a ▁; ▁int ▁increment ▁= ▁a ▁; ▁int ▁i ▁, ▁j ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁b ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁j ▁= ▁1 ▁; ▁j ▁< ▁a ▁; ▁j ▁++ ▁) ▁{ ▁answer ▁+= ▁increment ▁; ▁} ▁increment ▁= ▁answer ▁; ▁} ▁return ▁answer ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁pow ▁( ▁5 ▁, ▁3 ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁multiply ▁( ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁if ▁( ▁y ▁> ▁0 ▁) ▁return ▁( ▁x ▁+ ▁multiply ▁( ▁x ▁, ▁y ▁- ▁1 ▁) ▁) ▁; ▁else ▁return ▁0 ▁; ▁} ▁static ▁int ▁pow ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁if ▁( ▁b ▁> ▁0 ▁) ▁return ▁multiply ▁( ▁a ▁, ▁pow ▁( ▁a ▁, ▁b ▁- ▁1 ▁) ▁) ▁; ▁else ▁return ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁pow ▁( ▁5 ▁, ▁3 ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁sum ▁, ▁n ▁; ▁static ▁float ▁getAv g ▁( ▁int ▁x ▁) ▁{ ▁sum ▁+= ▁x ▁; ▁return ▁( ▁( ▁( ▁float ▁) ▁sum ▁) ▁/ ▁++ ▁n ▁) ▁; ▁} ▁static ▁void ▁stream Avg ▁( ▁float ▁[ ▁] ▁arr ▁, ▁int ▁n ▁) ▁{ ▁float ▁avg ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁avg ▁= ▁getAv g ▁( ▁( ▁int ▁) ▁arr ▁[ ▁i ▁] ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Average ▁of ▁" ▁+ ▁( ▁i ▁+ ▁1 ▁) ▁+ ▁" ▁numbers ▁is ▁" ▁+ ▁avg ▁) ▁; ▁} ▁return ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁float ▁[ ▁] ▁arr ▁= ▁new ▁float ▁[ ▁] ▁{ ▁10 ▁, ▁20 ▁, ▁30 ▁, ▁40 ▁, ▁50 ▁, ▁60 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁stream Avg ▁( ▁arr ▁, ▁n ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁count ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁< ▁3 ▁) ▁return ▁n ▁; ▁if ▁( ▁n ▁>= ▁3 ▁&& ▁n ▁< ▁10 ▁) ▁return ▁n ▁- ▁1 ▁; ▁int ▁po ▁= ▁1 ▁; ▁while ▁( ▁n ▁/ ▁po ▁> ▁9 ▁) ▁po ▁= ▁po ▁* ▁10 ▁; ▁int ▁ms d ▁= ▁n ▁/ ▁po ▁; ▁if ▁( ▁ms d ▁!= ▁3 ▁) ▁return ▁count ▁( ▁ms d ▁) ▁* ▁count ▁( ▁po ▁- ▁1 ▁) ▁+ ▁count ▁( ▁ms d ▁) ▁+ ▁count ▁( ▁n ▁% ▁po ▁) ▁; ▁else ▁return ▁count ▁( ▁ms d ▁* ▁po ▁- ▁1 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁5 78 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁void ▁print P as cal ▁( ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁line ▁= ▁1 ▁; ▁line ▁<= ▁n ▁; ▁line ▁++ ▁) ▁{ ▁int ▁C ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁line ▁; ▁i ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁C ▁+ ▁" ▁" ▁) ▁; ▁C ▁= ▁C ▁* ▁( ▁line ▁- ▁i ▁) ▁/ ▁i ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁5 ▁; ▁print P as cal ▁( ▁n ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁Comb ination ▁{ ▁static ▁void ▁print Comb ination ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁r ▁) ▁{ ▁int ▁data ▁[ ▁] ▁= ▁new ▁int ▁[ ▁r ▁] ▁; ▁combination Util ▁( ▁arr ▁, ▁data ▁, ▁0 ▁, ▁n ▁- ▁1 ▁, ▁0 ▁, ▁r ▁) ▁; ▁} ▁static ▁void ▁combination Util ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁data ▁[ ▁] ▁, ▁int ▁start ▁, ▁int ▁end ▁, ▁int ▁index ▁, ▁int ▁r ▁) ▁{ ▁if ▁( ▁index ▁== ▁r ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁r ▁; ▁j ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁data ▁[ ▁j ▁] ▁+ ▁" ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁" ▁) ▁; ▁return ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁start ▁; ▁i ▁<= ▁end ▁&& ▁end ▁- ▁i ▁+ ▁1 ▁>= ▁r ▁- ▁index ▁; ▁i ▁++ ▁) ▁{ ▁data ▁[ ▁index ▁] ▁= ▁arr ▁[ ▁i ▁] ▁; ▁combination Util ▁( ▁arr ▁, ▁data ▁, ▁i ▁+ ▁1 ▁, ▁end ▁, ▁index ▁+ ▁1 ▁, ▁r ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁r ▁= ▁3 ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁print Comb ination ▁( ▁arr ▁, ▁n ▁, ▁r ▁) ▁; ▁} ▁}
▁class ▁Find Groups ▁{ ▁int ▁find groups ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁c ▁[ ▁] ▁= ▁new ▁int ▁[ ▁] ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁} ▁; ▁int ▁i ▁; ▁int ▁res ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁c ▁[ ▁arr ▁[ ▁i ▁] ▁% ▁3 ▁] ▁++ ▁; ▁res ▁+= ▁( ▁( ▁c ▁[ ▁0 ▁] ▁* ▁( ▁c ▁[ ▁0 ▁] ▁- ▁1 ▁) ▁) ▁>> ▁1 ▁) ▁; ▁res ▁+= ▁c ▁[ ▁1 ▁] ▁* ▁c ▁[ ▁2 ▁] ▁; ▁res ▁+= ▁( ▁c ▁[ ▁0 ▁] ▁* ▁( ▁c ▁[ ▁0 ▁] ▁- ▁1 ▁) ▁* ▁( ▁c ▁[ ▁0 ▁] ▁- ▁2 ▁) ▁) ▁/ ▁6 ▁; ▁res ▁+= ▁( ▁c ▁[ ▁1 ▁] ▁* ▁( ▁c ▁[ ▁1 ▁] ▁- ▁1 ▁) ▁* ▁( ▁c ▁[ ▁1 ▁] ▁- ▁2 ▁) ▁) ▁/ ▁6 ▁; ▁res ▁+= ▁( ▁( ▁c ▁[ ▁2 ▁] ▁* ▁( ▁c ▁[ ▁2 ▁] ▁- ▁1 ▁) ▁* ▁( ▁c ▁[ ▁2 ▁] ▁- ▁2 ▁) ▁) ▁/ ▁6 ▁) ▁; ▁res ▁+= ▁c ▁[ ▁0 ▁] ▁* ▁c ▁[ ▁1 ▁] ▁* ▁c ▁[ ▁2 ▁] ▁; ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Find Groups ▁groups ▁= ▁new ▁Find Groups ▁( ▁) ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁6 ▁, ▁7 ▁, ▁2 ▁, ▁9 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Required ▁number ▁of ▁groups ▁are ▁" ▁+ ▁groups ▁. ▁find groups ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁calc Angle ▁( ▁double ▁h ▁, ▁double ▁m ▁) ▁{ ▁if ▁( ▁h ▁< ▁0 ▁m ▁< ▁0 ▁h ▁> ▁12 ▁m ▁> ▁60 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Wrong ▁input ▁" ▁) ▁; ▁if ▁( ▁h ▁== ▁12 ▁) ▁h ▁= ▁0 ▁; ▁if ▁( ▁m ▁== ▁60 ▁) ▁{ ▁m ▁= ▁0 ▁; ▁h ▁+= ▁1 ▁; ▁if ▁( ▁h ▁> ▁12 ▁) ▁h ▁= ▁h ▁- ▁12 ▁; ▁} ▁int ▁hour _ angle ▁= ▁( ▁int ▁) ▁( ▁0.5 ▁* ▁( ▁h ▁* ▁60 ▁+ ▁m ▁) ▁) ▁; ▁int ▁minute _ angle ▁= ▁( ▁int ▁) ▁( ▁6 ▁* ▁m ▁) ▁; ▁int ▁angle ▁= ▁Math ▁. ▁abs ▁( ▁hour _ angle ▁- ▁minute _ angle ▁) ▁; ▁angle ▁= ▁Math ▁. ▁min ▁( ▁360 ▁- ▁angle ▁, ▁angle ▁) ▁; ▁return ▁angle ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁calc Angle ▁( ▁9 ▁, ▁60 ▁) ▁+ ▁" ▁degree ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁calc Angle ▁( ▁3 ▁, ▁30 ▁) ▁+ ▁" ▁degree ▁" ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁double ▁find ▁( ▁double ▁p ▁) ▁{ ▁return ▁Math ▁. ▁ceil ▁( ▁Math ▁. ▁sqrt ▁( ▁2 ▁* ▁365 ▁* ▁Math ▁. ▁log ▁( ▁1 ▁/ ▁( ▁1 ▁- ▁p ▁) ▁) ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁find ▁( ▁0. 70 ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁MAX _ ITER ▁= ▁1000000 ▁; ▁static ▁double ▁func ▁( ▁double ▁x ▁) ▁{ ▁return ▁( ▁x ▁* ▁x ▁* ▁x ▁- ▁x ▁* ▁x ▁+ ▁2 ▁) ▁; ▁} ▁static ▁void ▁reg ula F al si ▁( ▁double ▁a ▁, ▁double ▁b ▁) ▁{ ▁if ▁( ▁func ▁( ▁a ▁) ▁* ▁func ▁( ▁b ▁) ▁>= ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁You ▁have ▁not ▁assumed ▁right ▁a ▁and ▁b ▁" ▁) ▁; ▁} ▁double ▁c ▁= ▁a ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁MAX _ ITER ▁; ▁i ▁++ ▁) ▁{ ▁c ▁= ▁( ▁a ▁* ▁func ▁( ▁b ▁) ▁- ▁b ▁* ▁func ▁( ▁a ▁) ▁) ▁/ ▁( ▁func ▁( ▁b ▁) ▁- ▁func ▁( ▁a ▁) ▁) ▁; ▁if ▁( ▁func ▁( ▁c ▁) ▁== ▁0 ▁) ▁break ▁; ▁else ▁if ▁( ▁func ▁( ▁c ▁) ▁* ▁func ▁( ▁a ▁) ▁< ▁0 ▁) ▁b ▁= ▁c ▁; ▁else ▁a ▁= ▁c ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁The ▁value ▁of ▁root ▁is ▁: ▁" ▁+ ▁( ▁int ▁) ▁c ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁double ▁a ▁= ▁- ▁200 ▁, ▁b ▁= ▁300 ▁; ▁reg ula F al si ▁( ▁a ▁, ▁b ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁swap Bits ▁( ▁int ▁x ▁, ▁int ▁p 1 ▁, ▁int ▁p 2 ▁, ▁int ▁n ▁) ▁{ ▁int ▁set 1 ▁= ▁( ▁x ▁>> ▁p 1 ▁) ▁& ▁( ▁( ▁1 ▁<< ▁n ▁) ▁- ▁1 ▁) ▁; ▁int ▁set 2 ▁= ▁( ▁x ▁>> ▁p 2 ▁) ▁& ▁( ▁( ▁1 ▁<< ▁n ▁) ▁- ▁1 ▁) ▁; ▁int ▁xor ▁= ▁( ▁set 1 ▁^ ▁set 2 ▁) ▁; ▁xor ▁= ▁( ▁xor ▁<< ▁p 1 ▁) ▁| ▁( ▁xor ▁<< ▁p 2 ▁) ▁; ▁int ▁result ▁= ▁x ▁^ ▁xor ▁; ▁return ▁result ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁res ▁= ▁swap Bits ▁( ▁28 ▁, ▁0 ▁, ▁3 ▁, ▁2 ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Result ▁= ▁" ▁+ ▁res ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁fun ▁( ▁int ▁n ▁) ▁{ ▁return ▁n ▁& ▁( ▁n ▁- ▁1 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁arg ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁7 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁The ▁number ▁after ▁un setting ▁" ▁+ ▁" ▁the ▁right most ▁set ▁bit ▁" ▁+ ▁fun ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁is Power Of Four ▁( ▁int ▁n ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁int ▁x ▁= ▁n ▁& ▁( ▁n ▁- ▁1 ▁) ▁; ▁if ▁( ▁n ▁> ▁0 ▁&& ▁x ▁== ▁0 ▁) ▁{ ▁while ▁( ▁n ▁> ▁1 ▁) ▁{ ▁n ▁>>= ▁1 ▁; ▁count ▁+= ▁1 ▁; ▁} ▁return ▁( ▁count ▁% ▁2 ▁== ▁0 ▁) ▁? ▁1 ▁: ▁0 ▁; ▁} ▁return ▁0 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁test _ no ▁= ▁64 ▁; ▁if ▁( ▁is Power Of Four ▁( ▁test _ no ▁) ▁> ▁0 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁test _ no ▁+ ▁" ▁is ▁a ▁power ▁of ▁4" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁test _ no ▁+ ▁" ▁is ▁not ▁a ▁power ▁of ▁4" ▁) ▁; ▁} ▁}
▁public ▁class ▁AWS ▁{ ▁static ▁int ▁min ▁( ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁return ▁y ▁^ ▁( ▁( ▁x ▁^ ▁y ▁) ▁& ▁- ▁( ▁x ▁<< ▁y ▁) ▁) ▁; ▁} ▁static ▁int ▁max ▁( ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁return ▁x ▁^ ▁( ▁( ▁x ▁^ ▁y ▁) ▁& ▁- ▁( ▁x ▁<< ▁y ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁x ▁= ▁15 ▁; ▁int ▁y ▁= ▁6 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Minimum ▁of ▁" ▁+ ▁x ▁+ ▁" ▁and ▁" ▁+ ▁y ▁+ ▁" ▁is ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁min ▁( ▁x ▁, ▁y ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Maximum ▁of ▁" ▁+ ▁x ▁+ ▁" ▁and ▁" ▁+ ▁y ▁+ ▁" ▁is ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁max ▁( ▁x ▁, ▁y ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁HashMap ▁; ▁class ▁O dd Occurrence ▁{ ▁static ▁int ▁getO dd Occurrence ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁h map ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁h map ▁. ▁containsKey ▁( ▁arr ▁[ ▁i ▁] ▁) ▁) ▁{ ▁int ▁val ▁= ▁h map ▁. ▁get ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁h map ▁. ▁put ▁( ▁arr ▁[ ▁i ▁] ▁, ▁val ▁+ ▁1 ▁) ▁; ▁} ▁else ▁h map ▁. ▁put ▁( ▁arr ▁[ ▁i ▁] ▁, ▁1 ▁) ▁; ▁} ▁for ▁( ▁Integer ▁a ▁: ▁h map ▁. ▁keySet ▁( ▁) ▁) ▁{ ▁if ▁( ▁h map ▁. ▁get ▁( ▁a ▁) ▁% ▁2 ▁!= ▁0 ▁) ▁return ▁a ▁; ▁} ▁return ▁- ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁new ▁int ▁[ ▁] ▁{ ▁2 ▁, ▁3 ▁, ▁5 ▁, ▁4 ▁, ▁5 ▁, ▁2 ▁, ▁4 ▁, ▁3 ▁, ▁5 ▁, ▁2 ▁, ▁4 ▁, ▁4 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁getO dd Occurrence ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁[ ▁] ▁num _ to _ bits ▁= ▁new ▁int ▁[ ▁] ▁{ ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁2 ▁, ▁1 ▁, ▁2 ▁, ▁2 ▁, ▁3 ▁, ▁1 ▁, ▁2 ▁, ▁2 ▁, ▁3 ▁, ▁2 ▁, ▁3 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁static ▁int ▁count Set Bits Rec ▁( ▁int ▁num ▁) ▁{ ▁int ▁n ibble ▁= ▁0 ▁; ▁if ▁( ▁0 ▁== ▁num ▁) ▁return ▁num _ to _ bits ▁[ ▁0 ▁] ▁; ▁n ibble ▁= ▁num ▁& ▁0 xf ▁; ▁return ▁num _ to _ bits ▁[ ▁n ibble ▁] ▁+ ▁count Set Bits Rec ▁( ▁num ▁>> ▁4 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁num ▁= ▁31 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Set Bits Rec ▁( ▁num ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁next Power Of 2 ▁( ▁int ▁n ▁) ▁{ ▁n ▁-- ▁; ▁n ▁|= ▁n ▁>> ▁1 ▁; ▁n ▁|= ▁n ▁>> ▁2 ▁; ▁n ▁|= ▁n ▁>> ▁4 ▁; ▁n ▁|= ▁n ▁>> ▁8 ▁; ▁n ▁|= ▁n ▁>> ▁16 ▁; ▁n ▁++ ▁; ▁return ▁n ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁next Power Of 2 ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁boolean ▁is Power Of Two ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁0 ▁) ▁return ▁false ▁; ▁return ▁( ▁int ▁) ▁( ▁Math ▁. ▁ceil ▁( ▁( ▁Math ▁. ▁log ▁( ▁n ▁) ▁/ ▁Math ▁. ▁log ▁( ▁2 ▁) ▁) ▁) ▁) ▁== ▁( ▁int ▁) ▁( ▁Math ▁. ▁floor ▁( ▁( ▁( ▁Math ▁. ▁log ▁( ▁n ▁) ▁/ ▁Math ▁. ▁log ▁( ▁2 ▁) ▁) ▁) ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁if ▁( ▁is Power Of Two ▁( ▁31 ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁if ▁( ▁is Power Of Two ▁( ▁64 ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁is Power Of Two ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁0 ▁) ▁return ▁false ▁; ▁while ▁( ▁n ▁!= ▁1 ▁) ▁{ ▁if ▁( ▁n ▁% ▁2 ▁!= ▁0 ▁) ▁return ▁false ▁; ▁n ▁= ▁n ▁/ ▁2 ▁; ▁} ▁return ▁true ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁if ▁( ▁is Power Of Two ▁( ▁31 ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁if ▁( ▁is Power Of Two ▁( ▁64 ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁public ▁static ▁int ▁getFirst Set Bit Pos ▁( ▁int ▁n ▁) ▁{ ▁return ▁( ▁int ▁) ▁( ▁( ▁Math ▁. ▁log 10 ▁( ▁n ▁& ▁- ▁n ▁) ▁) ▁/ ▁Math ▁. ▁log 10 ▁( ▁2 ▁) ▁) ▁+ ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁12 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁getFirst Set Bit Pos ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁swap Bits ▁( ▁int ▁x ▁) ▁{ ▁int ▁even _ bits ▁= ▁x ▁& ▁0 x AAAAAAAA ▁; ▁int ▁odd _ bits ▁= ▁x ▁& ▁0 x 5555 5555 ▁; ▁even _ bits ▁>>= ▁1 ▁; ▁odd _ bits ▁<<= ▁1 ▁; ▁return ▁( ▁even _ bits ▁odd _ bits ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁x ▁= ▁23 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁swap Bits ▁( ▁x ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁boolean ▁is Power Of Two ▁( ▁int ▁n ▁) ▁{ ▁return ▁n ▁> ▁0 ▁&& ▁( ▁( ▁n ▁& ▁( ▁n ▁- ▁1 ▁) ▁) ▁== ▁0 ▁) ▁; ▁} ▁static ▁int ▁find Position ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁! ▁is Power Of Two ▁( ▁n ▁) ▁) ▁return ▁- ▁1 ▁; ▁int ▁count ▁= ▁0 ▁; ▁while ▁( ▁n ▁> ▁0 ▁) ▁{ ▁n ▁= ▁n ▁>> ▁1 ▁; ▁++ ▁count ▁; ▁} ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁0 ▁; ▁int ▁pos ▁= ▁find Position ▁( ▁n ▁) ▁; ▁if ▁( ▁pos ▁== ▁- ▁1 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁n ▁= ▁" ▁+ ▁n ▁+ ▁" ▁, ▁Invalid ▁number ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁n ▁= ▁" ▁+ ▁n ▁+ ▁" ▁, ▁Position ▁" ▁+ ▁pos ▁) ▁; ▁n ▁= ▁12 ▁; ▁pos ▁= ▁find Position ▁( ▁n ▁) ▁; ▁if ▁( ▁pos ▁== ▁- ▁1 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁n ▁= ▁" ▁+ ▁n ▁+ ▁" ▁, ▁Invalid ▁number ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁n ▁= ▁" ▁+ ▁n ▁+ ▁" ▁, ▁Position ▁" ▁+ ▁pos ▁) ▁; ▁n ▁= ▁128 ▁; ▁pos ▁= ▁find Position ▁( ▁n ▁) ▁; ▁if ▁( ▁pos ▁== ▁- ▁1 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁n ▁= ▁" ▁+ ▁n ▁+ ▁" ▁, ▁Invalid ▁number ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁n ▁= ▁" ▁+ ▁n ▁+ ▁" ▁, ▁Position ▁" ▁+ ▁pos ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁Next Gre at est ▁{ ▁static ▁void ▁next Gre at est ▁( ▁int ▁arr ▁[ ▁] ▁) ▁{ ▁int ▁size ▁= ▁arr ▁. ▁length ▁; ▁int ▁max _ from _ right ▁= ▁arr ▁[ ▁size ▁- ▁1 ▁] ▁; ▁arr ▁[ ▁size ▁- ▁1 ▁] ▁= ▁- ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁size ▁- ▁2 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁int ▁temp ▁= ▁arr ▁[ ▁i ▁] ▁; ▁arr ▁[ ▁i ▁] ▁= ▁max _ from _ right ▁; ▁if ▁( ▁max _ from _ right ▁< ▁temp ▁) ▁max _ from _ right ▁= ▁temp ▁; ▁} ▁} ▁static ▁void ▁print Array ▁( ▁int ▁arr ▁[ ▁] ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁arr ▁. ▁length ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁16 ▁, ▁17 ▁, ▁4 ▁, ▁3 ▁, ▁5 ▁, ▁2 ▁} ▁; ▁next Gre at est ▁( ▁arr ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁The ▁modified ▁array ▁: ▁" ▁) ▁; ▁print Array ▁( ▁arr ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁int ▁max C ircular Sum ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁1 ▁) ▁return ▁a ▁[ ▁0 ▁] ▁; ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁a ▁[ ▁i ▁] ▁; ▁} ▁int ▁curr _ max ▁= ▁a ▁[ ▁0 ▁] ▁, ▁max _ so _ far ▁= ▁a ▁[ ▁0 ▁] ▁, ▁curr _ min ▁= ▁a ▁[ ▁0 ▁] ▁, ▁min _ so _ far ▁= ▁a ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁curr _ max ▁= ▁Math ▁. ▁max ▁( ▁curr _ max ▁+ ▁a ▁[ ▁i ▁] ▁, ▁a ▁[ ▁i ▁] ▁) ▁; ▁max _ so _ far ▁= ▁Math ▁. ▁max ▁( ▁max _ so _ far ▁, ▁curr _ max ▁) ▁; ▁curr _ min ▁= ▁Math ▁. ▁min ▁( ▁curr _ min ▁+ ▁a ▁[ ▁i ▁] ▁, ▁a ▁[ ▁i ▁] ▁) ▁; ▁min _ so _ far ▁= ▁Math ▁. ▁min ▁( ▁min _ so _ far ▁, ▁curr _ min ▁) ▁; ▁} ▁if ▁( ▁min _ so _ far ▁== ▁sum ▁) ▁{ ▁return ▁max _ so _ far ▁; ▁} ▁return ▁Math ▁. ▁max ▁( ▁max _ so _ far ▁, ▁sum ▁- ▁min _ so _ far ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁11 ▁, ▁10 ▁, ▁- ▁20 ▁, ▁5 ▁, ▁- ▁3 ▁, ▁- ▁5 ▁, ▁8 ▁, ▁- ▁13 ▁, ▁10 ▁} ▁; ▁int ▁n ▁= ▁9 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Maximum ▁circular ▁sum ▁is ▁" ▁+ ▁max C ircular Sum ▁( ▁a ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁Maximum Diff ren ce ▁{ ▁int ▁max Diff ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁arr _ size ▁) ▁{ ▁int ▁max _ diff ▁= ▁arr ▁[ ▁1 ▁] ▁- ▁arr ▁[ ▁0 ▁] ▁; ▁int ▁i ▁, ▁j ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁arr _ size ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁arr _ size ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁j ▁] ▁- ▁arr ▁[ ▁i ▁] ▁> ▁max _ diff ▁) ▁max _ diff ▁= ▁arr ▁[ ▁j ▁] ▁- ▁arr ▁[ ▁i ▁] ▁; ▁} ▁} ▁return ▁max _ diff ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Maximum Difference ▁max d if ▁= ▁new ▁Maximum Difference ▁( ▁) ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁90 ▁, ▁10 ▁, ▁110 ▁} ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Maximum ▁difference ▁is ▁" ▁+ ▁max d if ▁. ▁max Diff ▁( ▁arr ▁, ▁5 ▁) ▁) ▁; ▁} ▁}
▁class ▁Main ▁{ ▁static ▁int ▁find Maximum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁low ▁, ▁int ▁high ▁) ▁{ ▁if ▁( ▁low ▁== ▁high ▁) ▁return ▁arr ▁[ ▁low ▁] ▁; ▁if ▁( ▁( ▁high ▁== ▁low ▁+ ▁1 ▁) ▁&& ▁arr ▁[ ▁low ▁] ▁>= ▁arr ▁[ ▁high ▁] ▁) ▁return ▁arr ▁[ ▁low ▁] ▁; ▁if ▁( ▁( ▁high ▁== ▁low ▁+ ▁1 ▁) ▁&& ▁arr ▁[ ▁low ▁] ▁< ▁arr ▁[ ▁high ▁] ▁) ▁return ▁arr ▁[ ▁high ▁] ▁; ▁int ▁mid ▁= ▁( ▁low ▁+ ▁high ▁) ▁/ ▁2 ▁; ▁if ▁( ▁arr ▁[ ▁mid ▁] ▁> ▁arr ▁[ ▁mid ▁+ ▁1 ▁] ▁&& ▁arr ▁[ ▁mid ▁] ▁> ▁arr ▁[ ▁mid ▁- ▁1 ▁] ▁) ▁return ▁arr ▁[ ▁mid ▁] ▁; ▁if ▁( ▁arr ▁[ ▁mid ▁] ▁> ▁arr ▁[ ▁mid ▁+ ▁1 ▁] ▁&& ▁arr ▁[ ▁mid ▁] ▁< ▁arr ▁[ ▁mid ▁- ▁1 ▁] ▁) ▁return ▁find Maximum ▁( ▁arr ▁, ▁low ▁, ▁mid ▁- ▁1 ▁) ▁; ▁else ▁return ▁find Maximum ▁( ▁arr ▁, ▁mid ▁+ ▁1 ▁, ▁high ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁50 ▁, ▁10 ▁, ▁9 ▁, ▁7 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁The ▁maximum ▁element ▁is ▁" ▁+ ▁find Maximum ▁( ▁arr ▁, ▁0 ▁, ▁n ▁- ▁1 ▁) ▁) ▁; ▁} ▁}
▁class ▁g fg ▁{ ▁static ▁int ▁find Min Sw aps ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁no Of Zero es ▁[ ▁] ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁int ▁i ▁, ▁count ▁= ▁0 ▁; ▁no Of Zero es ▁[ ▁n ▁- ▁1 ▁] ▁= ▁1 ▁- ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁; ▁for ▁( ▁i ▁= ▁n ▁- ▁2 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁no Of Zero es ▁[ ▁i ▁] ▁= ▁no Of Zero es ▁[ ▁i ▁+ ▁1 ▁] ▁; ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁0 ▁) ▁no Of Zero es ▁[ ▁i ▁] ▁++ ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁1 ▁) ▁count ▁+= ▁no Of Zero es ▁[ ▁i ▁] ▁; ▁} ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁ar ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁} ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Min Sw aps ▁( ▁ar ▁, ▁ar ▁. ▁length ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁min Sw aps To Sort ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁ArrayList ▁< ▁ArrayList ▁< ▁Integer ▁> ▁> ▁arr Pos ▁= ▁new ▁ArrayList ▁< ▁ArrayList ▁< ▁Integer ▁> ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁arr Pos ▁. ▁add ▁( ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁Arrays ▁. ▁asList ▁( ▁arr ▁[ ▁i ▁] ▁, ▁i ▁) ▁) ▁) ▁; ▁} ▁Collections ▁. ▁sort ▁( ▁arr Pos ▁, ▁new ▁Comparator ▁< ▁ArrayList ▁< ▁Integer ▁> ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁int ▁compare ▁( ▁ArrayList ▁< ▁Integer ▁> ▁o 1 ▁, ▁ArrayList ▁< ▁Integer ▁> ▁o 2 ▁) ▁{ ▁return ▁o 1 ▁. ▁get ▁( ▁0 ▁) ▁. ▁compareTo ▁( ▁o 2 ▁. ▁get ▁( ▁0 ▁) ▁) ▁; ▁} ▁} ▁) ▁; ▁boolean ▁[ ▁] ▁vis ▁= ▁new ▁boolean ▁[ ▁n ▁] ▁; ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁vis ▁[ ▁i ▁] ▁|| ▁arr Pos ▁. ▁get ▁( ▁i ▁) ▁. ▁get ▁( ▁1 ▁) ▁== ▁i ▁) ▁continue ▁; ▁int ▁cycle _ size ▁= ▁0 ▁; ▁int ▁j ▁= ▁i ▁; ▁while ▁( ▁! ▁vis ▁[ ▁j ▁] ▁) ▁{ ▁vis ▁[ ▁j ▁] ▁= ▁true ▁; ▁j ▁= ▁arr Pos ▁. ▁get ▁( ▁j ▁) ▁. ▁get ▁( ▁1 ▁) ▁; ▁cycle _ size ▁++ ▁; ▁} ▁ans ▁+= ▁( ▁cycle _ size ▁- ▁1 ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁static ▁int ▁min Swap To Make Array Same ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁b ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁Map ▁< ▁Integer ▁, ▁Integer ▁> ▁mp ▁= ▁new ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁mp ▁. ▁put ▁( ▁b ▁[ ▁i ▁] ▁, ▁i ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁b ▁[ ▁i ▁] ▁= ▁mp ▁. ▁get ▁( ▁a ▁[ ▁i ▁] ▁) ▁; ▁return ▁min Sw aps To Sort ▁( ▁b ▁, ▁n ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args
▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁class ▁Test ▁{ ▁static ▁int ▁arr ▁[ ▁] ▁= ▁new ▁int ▁[ ▁] ▁{ ▁5 ▁, ▁1 ▁, ▁3 ▁, ▁4 ▁, ▁7 ▁} ▁; ▁static ▁int ▁count Tri pl ets ▁( ▁int ▁n ▁, ▁int ▁sum ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁arr ▁) ▁; ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁int ▁j ▁= ▁i ▁+ ▁1 ▁, ▁k ▁= ▁n ▁- ▁1 ▁; ▁while ▁( ▁j ▁< ▁k ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁arr ▁[ ▁j ▁] ▁+ ▁arr ▁[ ▁k ▁] ▁>= ▁sum ▁) ▁k ▁-- ▁; ▁else ▁{ ▁ans ▁+= ▁( ▁k ▁- ▁j ▁) ▁; ▁j ▁++ ▁; ▁} ▁} ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁sum ▁= ▁12 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Tri pl ets ▁( ▁arr ▁. ▁length ▁, ▁sum ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁print Two Elements ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁size ▁) ▁{ ▁int ▁i ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁The ▁repeating ▁element ▁is ▁" ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁{ ▁int ▁abs _ val ▁= ▁Math ▁. ▁abs ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁if ▁( ▁arr ▁[ ▁abs _ val ▁- ▁1 ▁] ▁> ▁0 ▁) ▁arr ▁[ ▁abs _ val ▁- ▁1 ▁] ▁= ▁- ▁arr ▁[ ▁abs _ val ▁- ▁1 ▁] ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁abs _ val ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁And ▁the ▁missing ▁element ▁is ▁" ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁0 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁i ▁+ ▁1 ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁7 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁5 ▁, ▁6 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁print Two Elements ▁( ▁arr ▁, ▁n ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁Main ▁{ ▁static ▁void ▁print Two Odd ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁size ▁) ▁{ ▁int ▁xor 2 ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁int ▁set _ bit _ no ▁; ▁int ▁i ▁; ▁int ▁n ▁= ▁size ▁- ▁2 ▁; ▁int ▁x ▁= ▁0 ▁, ▁y ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁xor 2 ▁= ▁xor 2 ▁^ ▁arr ▁[ ▁i ▁] ▁; ▁set _ bit _ no ▁= ▁xor 2 ▁& ▁~ ▁( ▁xor 2 ▁- ▁1 ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁arr ▁[ ▁i ▁] ▁& ▁set _ bit _ no ▁) ▁> ▁0 ▁) ▁x ▁= ▁x ▁^ ▁arr ▁[ ▁i ▁] ▁; ▁else ▁y ▁= ▁y ▁^ ▁arr ▁[ ▁i ▁] ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁The ▁two ▁O DD ▁elements ▁are ▁" ▁+ ▁x ▁+ ▁" ▁& ▁" ▁+ ▁y ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁2 ▁, ▁4 ▁, ▁5 ▁, ▁2 ▁, ▁3 ▁, ▁3 ▁, ▁1 ▁} ▁; ▁int ▁arr _ size ▁= ▁arr ▁. ▁length ▁; ▁print Two Odd ▁( ▁arr ▁, ▁arr _ size ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁Pair Difference ▁{ ▁static ▁boolean ▁find Pair ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁size ▁= ▁arr ▁. ▁length ▁; ▁int ▁i ▁= ▁0 ▁, ▁j ▁= ▁1 ▁; ▁while ▁( ▁i ▁< ▁size ▁&& ▁j ▁< ▁size ▁) ▁{ ▁if ▁( ▁i ▁!= ▁j ▁&& ▁arr ▁[ ▁j ▁] ▁- ▁arr ▁[ ▁i ▁] ▁== ▁n ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Pair ▁Found ▁: ▁" ▁+ ▁" ▁( ▁" ▁+ ▁arr ▁[ ▁i ▁] ▁+ ▁" ▁, ▁" ▁+ ▁arr ▁[ ▁j ▁] ▁+ ▁" ▁) ▁" ▁) ▁; ▁return ▁true ▁; ▁} ▁else ▁if ▁( ▁arr ▁[ ▁j ▁] ▁- ▁arr ▁[ ▁i ▁] ▁< ▁n ▁) ▁j ▁++ ▁; ▁else ▁i ▁++ ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁No ▁such ▁pair ▁" ▁) ▁; ▁return ▁false ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁8 ▁, ▁30 ▁, ▁40 ▁, ▁100 ▁} ▁; ▁int ▁n ▁= ▁60 ▁; ▁find Pair ▁( ▁arr ▁, ▁n ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁four Element With Sum ▁{ ▁public ▁static ▁void ▁four Sum ▁( ▁int ▁X ▁, ▁int ▁[ ▁] ▁arr ▁, ▁Map ▁< ▁Integer ▁, ▁pair ▁> ▁map ▁) ▁{ ▁int ▁[ ▁] ▁temp ▁= ▁new ▁int ▁[ ▁arr ▁. ▁length ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁temp ▁. ▁length ▁; ▁i ▁++ ▁) ▁temp ▁[ ▁i ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁arr ▁. ▁length ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁arr ▁. ▁length ▁; ▁j ▁++ ▁) ▁{ ▁int ▁curr _ sum ▁= ▁arr ▁[ ▁i ▁] ▁+ ▁arr ▁[ ▁j ▁] ▁; ▁if ▁( ▁map ▁. ▁containsKey ▁( ▁X ▁- ▁curr _ sum ▁) ▁) ▁{ ▁pair ▁p ▁= ▁map ▁. ▁get ▁( ▁X ▁- ▁curr _ sum ▁) ▁; ▁if ▁( ▁p ▁. ▁first ▁!= ▁i ▁&& ▁p ▁. ▁sec ▁!= ▁i ▁&& ▁p ▁. ▁first ▁!= ▁j ▁&& ▁p ▁. ▁sec ▁!= ▁j ▁&& ▁temp ▁[ ▁p ▁. ▁first ▁] ▁== ▁0 ▁&& ▁temp ▁[ ▁p ▁. ▁sec ▁] ▁== ▁0 ▁&& ▁temp ▁[ ▁i ▁] ▁== ▁0 ▁&& ▁temp ▁[ ▁j ▁] ▁== ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁% ▁d ▁, ▁% ▁d ▁, ▁% ▁d ▁, ▁% ▁d ▁" ▁, ▁arr ▁[ ▁i ▁] ▁, ▁arr ▁[ ▁j ▁] ▁, ▁arr ▁[ ▁p ▁. ▁first ▁] ▁, ▁arr ▁[ ▁p ▁. ▁sec ▁] ▁) ▁; ▁temp ▁[ ▁p ▁. ▁sec ▁] ▁= ▁1 ▁; ▁temp ▁[ ▁i ▁] ▁= ▁1 ▁; ▁temp ▁[ ▁j ▁] ▁= ▁1 ▁; ▁break ▁; ▁} ▁} ▁} ▁} ▁} ▁public ▁static ▁Map ▁< ▁Integer ▁, ▁pair ▁> ▁two Sum ▁( ▁int ▁[ ▁] ▁nums ▁) ▁{ ▁Map ▁< ▁Integer ▁, ▁pair ▁> ▁map ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁nums ▁. ▁length ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁nums ▁. ▁length ▁; ▁j ▁++ ▁) ▁{ ▁map ▁. ▁put ▁( ▁nums ▁[ ▁i ▁] ▁+ ▁nums ▁[ ▁j ▁] ▁, ▁new ▁pair ▁( ▁i ▁, ▁j ▁) ▁) ▁; ▁} ▁} ▁return ▁map ▁; ▁} ▁public ▁static ▁class ▁pair ▁{ ▁int ▁first ▁, ▁sec ▁; ▁public ▁pair ▁( ▁int
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁Del etion ▁{ ▁static ▁int ▁delete Element ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁x ▁) ▁{ ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁x ▁) ▁break ▁; ▁if ▁( ▁i ▁< ▁n ▁) ▁{ ▁n ▁= ▁n ▁- ▁1 ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁arr ▁[ ▁j ▁] ▁= ▁arr ▁[ ▁j ▁+ ▁1 ▁] ▁; ▁} ▁return ▁n ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁11 ▁, ▁15 ▁, ▁6 ▁, ▁8 ▁, ▁9 ▁, ▁10 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁int ▁x ▁= ▁6 ▁; ▁n ▁= ▁delete Element ▁( ▁arr ▁, ▁n ▁, ▁x ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Modified ▁array ▁is ▁" ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁}
▁public ▁class ▁Maximum Absolute Difference ▁{ ▁private ▁static ▁int ▁max Distance ▁( ▁int ▁[ ▁] ▁array ▁) ▁{ ▁int ▁max 1 ▁= ▁Integer ▁. ▁MIN _ VALUE ▁; ▁int ▁min 1 ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁int ▁max 2 ▁= ▁Integer ▁. ▁MIN _ VALUE ▁; ▁int ▁min 2 ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁array ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁max 1 ▁= ▁Math ▁. ▁max ▁( ▁max 1 ▁, ▁array ▁[ ▁i ▁] ▁+ ▁i ▁) ▁; ▁min 1 ▁= ▁Math ▁. ▁min ▁( ▁min 1 ▁, ▁array ▁[ ▁i ▁] ▁+ ▁i ▁) ▁; ▁max 2 ▁= ▁Math ▁. ▁max ▁( ▁max 2 ▁, ▁array ▁[ ▁i ▁] ▁- ▁i ▁) ▁; ▁min 2 ▁= ▁Math ▁. ▁min ▁( ▁min 2 ▁, ▁array ▁[ ▁i ▁] ▁- ▁i ▁) ▁; ▁} ▁return ▁Math ▁. ▁max ▁( ▁max 1 ▁- ▁min 1 ▁, ▁max 2 ▁- ▁min 2 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁array ▁= ▁{ ▁- ▁70 ▁, ▁- ▁64 ▁, ▁- ▁6 ▁, ▁- ▁56 ▁, ▁64 ▁, ▁61 ▁, ▁- ▁57 ▁, ▁16 ▁, ▁48 ▁, ▁- ▁98 ▁} ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁max Distance ▁( ▁array ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁Find Clo sest Number ▁{ ▁public ▁static ▁int ▁find Clo sest ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁target ▁) ▁{ ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁if ▁( ▁target ▁<= ▁arr ▁[ ▁0 ▁] ▁) ▁return ▁arr ▁[ ▁0 ▁] ▁; ▁if ▁( ▁target ▁>= ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁) ▁return ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁; ▁int ▁i ▁= ▁0 ▁, ▁j ▁= ▁n ▁, ▁mid ▁= ▁0 ▁; ▁while ▁( ▁i ▁< ▁j ▁) ▁{ ▁mid ▁= ▁( ▁i ▁+ ▁j ▁) ▁/ ▁2 ▁; ▁if ▁( ▁arr ▁[ ▁mid ▁] ▁== ▁target ▁) ▁return ▁arr ▁[ ▁mid ▁] ▁; ▁if ▁( ▁target ▁< ▁arr ▁[ ▁mid ▁] ▁) ▁{ ▁if ▁( ▁mid ▁> ▁0 ▁&& ▁target ▁> ▁arr ▁[ ▁mid ▁- ▁1 ▁] ▁) ▁return ▁getC lo sest ▁( ▁arr ▁[ ▁mid ▁- ▁1 ▁] ▁, ▁arr ▁[ ▁mid ▁] ▁, ▁target ▁) ▁; ▁j ▁= ▁mid ▁; ▁} ▁else ▁{ ▁if ▁( ▁mid ▁< ▁n ▁- ▁1 ▁&& ▁target ▁< ▁arr ▁[ ▁mid ▁+ ▁1 ▁] ▁) ▁return ▁getC lo sest ▁( ▁arr ▁[ ▁mid ▁] ▁, ▁arr ▁[ ▁mid ▁+ ▁1 ▁] ▁, ▁target ▁) ▁; ▁i ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁} ▁return ▁arr ▁[ ▁mid ▁] ▁; ▁} ▁public ▁static ▁int ▁getC lo sest ▁( ▁int ▁val 1 ▁, ▁int ▁val 2 ▁, ▁int ▁target ▁) ▁{ ▁if ▁( ▁target ▁- ▁val 1 ▁>= ▁val 2 ▁- ▁target ▁) ▁return ▁val 2 ▁; ▁else ▁return ▁val 1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁, ▁6 ▁, ▁8 ▁, ▁9 ▁} ▁; ▁int ▁target ▁= ▁11 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Clo sest ▁( ▁arr ▁, ▁target ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁class ▁Node ▁{ ▁int ▁data ▁; ▁Node ▁next ▁; ▁} ▁; ▁static ▁void ▁print List ▁( ▁Node ▁node ▁) ▁{ ▁while ▁( ▁node ▁!= ▁null ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁node ▁. ▁data ▁+ ▁" ▁" ▁) ▁; ▁node ▁= ▁node ▁. ▁next ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁} ▁static ▁Node ▁newNode ▁( ▁int ▁key ▁) ▁{ ▁Node ▁temp ▁= ▁new ▁Node ▁( ▁) ▁; ▁temp ▁. ▁data ▁= ▁key ▁; ▁temp ▁. ▁next ▁= ▁null ▁; ▁return ▁temp ▁; ▁} ▁static ▁Node ▁insert B eg ▁( ▁Node ▁head ▁, ▁int ▁val ▁) ▁{ ▁Node ▁temp ▁= ▁newNode ▁( ▁val ▁) ▁; ▁temp ▁. ▁next ▁= ▁head ▁; ▁head ▁= ▁temp ▁; ▁return ▁head ▁; ▁} ▁static ▁Node ▁re arrange ▁( ▁Node ▁head ▁) ▁{ ▁Node ▁even ▁; ▁Node ▁temp ▁, ▁prev _ temp ▁; ▁Node ▁i ▁, ▁j ▁, ▁k ▁, ▁l ▁, ▁ptr ▁= ▁null ▁; ▁temp ▁= ▁( ▁head ▁) ▁. ▁next ▁; ▁prev _ temp ▁= ▁head ▁; ▁while ▁( ▁temp ▁!= ▁null ▁) ▁{ ▁Node ▁x ▁= ▁temp ▁. ▁next ▁; ▁if ▁( ▁temp ▁. ▁data ▁% ▁2 ▁!= ▁0 ▁) ▁{ ▁prev _ temp ▁. ▁next ▁= ▁x ▁; ▁temp ▁. ▁next ▁= ▁( ▁head ▁) ▁; ▁( ▁head ▁) ▁= ▁temp ▁; ▁} ▁else ▁{ ▁prev _ temp ▁= ▁temp ▁; ▁} ▁temp ▁= ▁x ▁; ▁} ▁temp ▁= ▁( ▁head ▁) ▁. ▁next ▁; ▁prev _ temp ▁= ▁( ▁head ▁) ▁; ▁while ▁( ▁temp ▁!= ▁null ▁&& ▁temp ▁. ▁data ▁% ▁2 ▁!= ▁0 ▁) ▁{ ▁prev _ temp ▁= ▁temp ▁; ▁temp ▁= ▁temp ▁. ▁next ▁; ▁} ▁even ▁= ▁temp ▁; ▁prev _ temp ▁. ▁next ▁= ▁null ▁; ▁i ▁= ▁head ▁; ▁j ▁= ▁even ▁; ▁while ▁( ▁j ▁!= ▁null ▁&& ▁i ▁!= ▁null ▁) ▁{ ▁k ▁= ▁i ▁. ▁next ▁; ▁l ▁= ▁j ▁. ▁next ▁; ▁i ▁. ▁next ▁= ▁j ▁; ▁j ▁. ▁next ▁= ▁k ▁; ▁ptr ▁= ▁j ▁; ▁i ▁= ▁k ▁; ▁j ▁= ▁l ▁; ▁} ▁if ▁( ▁i ▁== ▁null ▁) ▁{ ▁ptr ▁. ▁next ▁= ▁j ▁; ▁} ▁return ▁head ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁Node ▁head ▁= ▁newNode ▁( ▁8 ▁) ▁; ▁head ▁= ▁insert B eg ▁( ▁head ▁, ▁7 ▁) ▁; ▁head ▁=
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁class ▁Node ▁{ ▁int ▁data ▁; ▁Node ▁next ▁; ▁} ▁; ▁static ▁Node ▁head ▁= ▁null ▁; ▁static ▁void ▁rotate ▁( ▁int ▁k ▁) ▁{ ▁if ▁( ▁k ▁== ▁0 ▁) ▁return ▁; ▁Node ▁current ▁= ▁head ▁; ▁while ▁( ▁current ▁. ▁next ▁!= ▁null ▁) ▁current ▁= ▁current ▁. ▁next ▁; ▁current ▁. ▁next ▁= ▁head ▁; ▁current ▁= ▁head ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁k ▁- ▁1 ▁; ▁i ▁++ ▁) ▁current ▁= ▁current ▁. ▁next ▁; ▁head ▁= ▁current ▁. ▁next ▁; ▁current ▁. ▁next ▁= ▁null ▁; ▁} ▁static ▁void ▁push ▁( ▁int ▁new _ data ▁) ▁{ ▁Node ▁new _ node ▁= ▁new ▁Node ▁( ▁) ▁; ▁new _ node ▁. ▁data ▁= ▁new _ data ▁; ▁new _ node ▁. ▁next ▁= ▁head ▁; ▁head ▁= ▁new _ node ▁; ▁} ▁static ▁void ▁print List ▁( ▁Node ▁node ▁) ▁{ ▁while ▁( ▁node ▁!= ▁null ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁node ▁. ▁data ▁+ ▁" ▁" ▁) ▁; ▁node ▁= ▁node ▁. ▁next ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁60 ▁; ▁i ▁> ▁0 ▁; ▁i ▁-= ▁10 ▁) ▁push ▁( ▁i ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" Given ▁linked ▁list ▁NEW _ LINE "); ▁print List ▁( ▁head ▁) ▁; ▁rotate ▁( ▁4 ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Rot ated ▁Linked ▁list ▁"); ▁print List ▁( ▁head ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁ArrayList ▁< ▁Integer ▁> ▁list ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁list ▁. ▁add ▁( ▁1 ▁) ▁; ▁list ▁. ▁add ▁( ▁2 ▁) ▁; ▁list ▁. ▁add ▁( ▁3 ▁) ▁; ▁Iterator ▁< ▁Integer ▁> ▁it ▁= ▁list ▁. ▁iterator ▁( ▁) ▁; ▁while ▁( ▁it ▁. ▁hasNext ▁( ▁) ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁it ▁. ▁next ▁( ▁) ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁Node ▁{ ▁int ▁data ▁; ▁Node ▁next ▁; ▁public ▁Node ▁( ▁int ▁data ▁) ▁{ ▁this ▁. ▁data ▁= ▁data ▁; ▁this ▁. ▁next ▁= ▁null ▁; ▁} ▁} ▁class ▁g fg ▁{ ▁static ▁Node ▁root ▁; ▁public ▁static ▁Node ▁key To End ▁( ▁Node ▁head ▁, ▁int ▁key ▁) ▁{ ▁Node ▁tail ▁= ▁head ▁; ▁if ▁( ▁head ▁== ▁null ▁) ▁{ ▁return ▁null ▁; ▁} ▁while ▁( ▁tail ▁. ▁next ▁!= ▁null ▁) ▁{ ▁tail ▁= ▁tail ▁. ▁next ▁; ▁} ▁Node ▁last ▁= ▁tail ▁; ▁Node ▁current ▁= ▁head ▁; ▁Node ▁prev ▁= ▁null ▁; ▁Node ▁prev 2 ▁= ▁null ▁; ▁while ▁( ▁current ▁!= ▁tail ▁) ▁{ ▁if ▁( ▁current ▁. ▁data ▁== ▁key ▁&& ▁prev 2 ▁== ▁null ▁) ▁{ ▁prev ▁= ▁current ▁; ▁current ▁= ▁current ▁. ▁next ▁; ▁head ▁= ▁current ▁; ▁last ▁. ▁next ▁= ▁prev ▁; ▁last ▁= ▁last ▁. ▁next ▁; ▁last ▁. ▁next ▁= ▁null ▁; ▁prev ▁= ▁null ▁; ▁} ▁else ▁{ ▁if ▁( ▁current ▁. ▁data ▁== ▁key ▁&& ▁prev 2 ▁!= ▁null ▁) ▁{ ▁prev ▁= ▁current ▁; ▁current ▁= ▁current ▁. ▁next ▁; ▁prev 2 ▁. ▁next ▁= ▁current ▁; ▁last ▁. ▁next ▁= ▁prev ▁; ▁last ▁= ▁last ▁. ▁next ▁; ▁last ▁. ▁next ▁= ▁null ▁; ▁} ▁else ▁if ▁( ▁current ▁!= ▁tail ▁) ▁{ ▁prev 2 ▁= ▁current ▁; ▁current ▁= ▁current ▁. ▁next ▁; ▁} ▁} ▁} ▁return ▁head ▁; ▁} ▁public ▁static ▁void ▁display ▁( ▁Node ▁root ▁) ▁{ ▁while ▁( ▁root ▁!= ▁null ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁root ▁. ▁data ▁+ ▁" ▁" ▁) ▁; ▁root ▁= ▁root ▁. ▁next ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁root ▁= ▁new ▁Node ▁( ▁5 ▁) ▁; ▁root ▁. ▁next ▁= ▁new ▁Node ▁( ▁2 ▁) ▁; ▁root ▁. ▁next ▁. ▁next ▁= ▁new ▁Node ▁( ▁2 ▁) ▁; ▁root ▁. ▁next ▁. ▁next ▁. ▁next ▁= ▁new ▁Node ▁( ▁7 ▁) ▁; ▁root ▁. ▁next ▁. ▁next ▁. ▁next ▁. ▁next ▁= ▁new ▁Node ▁( ▁2 ▁) ▁; ▁root ▁. ▁next ▁. ▁next ▁. ▁next ▁. ▁next ▁. ▁next ▁= ▁new ▁Node ▁( ▁2 ▁) ▁; ▁root ▁. ▁next ▁. ▁next ▁. ▁next ▁. ▁next ▁. ▁next ▁. ▁next ▁= ▁new ▁Node ▁( ▁2 ▁) ▁; ▁int ▁key ▁= ▁2 ▁;
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁class ▁Node ▁{ ▁int ▁data ▁; ▁Node ▁next ▁; ▁} ▁; ▁static ▁Node ▁push ▁( ▁Node ▁head _ ref ▁, ▁int ▁new _ data ▁) ▁{ ▁Node ▁new _ node ▁= ▁new ▁Node ▁( ▁) ▁; ▁new _ node ▁. ▁data ▁= ▁new _ data ▁; ▁new _ node ▁. ▁next ▁= ▁head _ ref ▁; ▁head _ ref ▁= ▁new _ node ▁; ▁return ▁head _ ref ▁; ▁} ▁static ▁int ▁sum Of Last N _ Nodes Util ▁( ▁Node ▁head ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁<= ▁0 ▁) ▁return ▁0 ▁; ▁Stack ▁< ▁Integer ▁> ▁st ▁= ▁new ▁Stack ▁< ▁Integer ▁> ▁( ▁) ▁; ▁int ▁sum ▁= ▁0 ▁; ▁while ▁( ▁head ▁!= ▁null ▁) ▁{ ▁st ▁. ▁push ▁( ▁head ▁. ▁data ▁) ▁; ▁head ▁= ▁head ▁. ▁next ▁; ▁} ▁while ▁( ▁n ▁-- ▁> ▁0 ▁) ▁{ ▁sum ▁+= ▁st ▁. ▁peek ▁( ▁) ▁; ▁st ▁. ▁pop ▁( ▁) ▁; ▁} ▁return ▁sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Node ▁head ▁= ▁null ▁; ▁head ▁= ▁push ▁( ▁head ▁, ▁12 ▁) ▁; ▁head ▁= ▁push ▁( ▁head ▁, ▁4 ▁) ▁; ▁head ▁= ▁push ▁( ▁head ▁, ▁8 ▁) ▁; ▁head ▁= ▁push ▁( ▁head ▁, ▁6 ▁) ▁; ▁head ▁= ▁push ▁( ▁head ▁, ▁10 ▁) ▁; ▁int ▁n ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Sum ▁of ▁last ▁" ▁+ ▁n ▁+ ▁" ▁nodes ▁= ▁" ▁+ ▁sum Of Last N _ Nodes Util ▁( ▁head ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁class ▁Node ▁{ ▁int ▁data ▁; ▁Node ▁next ▁; ▁} ▁; ▁static ▁Node ▁head ▁; ▁static ▁void ▁push ▁( ▁Node ▁head _ ref ▁, ▁int ▁new _ data ▁) ▁{ ▁Node ▁new _ node ▁= ▁new ▁Node ▁( ▁) ▁; ▁new _ node ▁. ▁data ▁= ▁new _ data ▁; ▁new _ node ▁. ▁next ▁= ▁head _ ref ▁; ▁head _ ref ▁= ▁new _ node ▁; ▁head ▁= ▁head _ ref ▁; ▁} ▁static ▁void ▁reverse List ▁( ▁Node ▁head _ ref ▁) ▁{ ▁Node ▁current ▁, ▁prev ▁, ▁next ▁; ▁current ▁= ▁head _ ref ▁; ▁prev ▁= ▁null ▁; ▁while ▁( ▁current ▁!= ▁null ▁) ▁{ ▁next ▁= ▁current ▁. ▁next ▁; ▁current ▁. ▁next ▁= ▁prev ▁; ▁prev ▁= ▁current ▁; ▁current ▁= ▁next ▁; ▁} ▁head _ ref ▁= ▁prev ▁; ▁head ▁= ▁head _ ref ▁; ▁} ▁static ▁int ▁sum Of Last N _ Nodes Util ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁<= ▁0 ▁) ▁return ▁0 ▁; ▁reverse List ▁( ▁head ▁) ▁; ▁int ▁sum ▁= ▁0 ▁; ▁Node ▁current ▁= ▁head ▁; ▁while ▁( ▁current ▁!= ▁null ▁&& ▁n ▁-- ▁> ▁0 ▁) ▁{ ▁sum ▁+= ▁current ▁. ▁data ▁; ▁current ▁= ▁current ▁. ▁next ▁; ▁} ▁reverse List ▁( ▁head ▁) ▁; ▁return ▁sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁push ▁( ▁head ▁, ▁12 ▁) ▁; ▁push ▁( ▁head ▁, ▁4 ▁) ▁; ▁push ▁( ▁head ▁, ▁8 ▁) ▁; ▁push ▁( ▁head ▁, ▁6 ▁) ▁; ▁push ▁( ▁head ▁, ▁10 ▁) ▁; ▁int ▁n ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Sum ▁of ▁last ▁" ▁+ ▁n ▁+ ▁" ▁nodes ▁= ▁" ▁+ ▁sum Of Last N _ Nodes Util ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁class ▁Node ▁{ ▁int ▁data ▁; ▁Node ▁next ▁; ▁} ▁; ▁static ▁Node ▁swap Nodes ▁( ▁Node ▁head _ ref ▁, ▁Node ▁curr X ▁, ▁Node ▁curr Y ▁, ▁Node ▁prev Y ▁) ▁{ ▁head _ ref ▁= ▁curr Y ▁; ▁prev Y ▁. ▁next ▁= ▁curr X ▁; ▁Node ▁temp ▁= ▁curr Y ▁. ▁next ▁; ▁curr Y ▁. ▁next ▁= ▁curr X ▁. ▁next ▁; ▁curr X ▁. ▁next ▁= ▁temp ▁; ▁return ▁head _ ref ▁; ▁} ▁static ▁Node ▁rec ur Selection Sort ▁( ▁Node ▁head ▁) ▁{ ▁if ▁( ▁head ▁. ▁next ▁== ▁null ▁) ▁return ▁head ▁; ▁Node ▁min ▁= ▁head ▁; ▁Node ▁before Min ▁= ▁null ▁; ▁Node ▁ptr ▁; ▁for ▁( ▁ptr ▁= ▁head ▁; ▁ptr ▁. ▁next ▁!= ▁null ▁; ▁ptr ▁= ▁ptr ▁. ▁next ▁) ▁{ ▁if ▁( ▁ptr ▁. ▁next ▁. ▁data ▁< ▁min ▁. ▁data ▁) ▁{ ▁min ▁= ▁ptr ▁. ▁next ▁; ▁before Min ▁= ▁ptr ▁; ▁} ▁} ▁if ▁( ▁min ▁!= ▁head ▁) ▁head ▁= ▁swap Nodes ▁( ▁head ▁, ▁head ▁, ▁min ▁, ▁before Min ▁) ▁; ▁head ▁. ▁next ▁= ▁rec ur Selection Sort ▁( ▁head ▁. ▁next ▁) ▁; ▁return ▁head ▁; ▁} ▁static ▁Node ▁sort ▁( ▁Node ▁head _ ref ▁) ▁{ ▁if ▁( ▁( ▁head _ ref ▁) ▁== ▁null ▁) ▁return ▁null ▁; ▁head _ ref ▁= ▁rec ur Selection Sort ▁( ▁head _ ref ▁) ▁; ▁return ▁head _ ref ▁; ▁} ▁static ▁Node ▁push ▁( ▁Node ▁head _ ref ▁, ▁int ▁new _ data ▁) ▁{ ▁Node ▁new _ node ▁= ▁new ▁Node ▁( ▁) ▁; ▁new _ node ▁. ▁data ▁= ▁new _ data ▁; ▁new _ node ▁. ▁next ▁= ▁( ▁head _ ref ▁) ▁; ▁( ▁head _ ref ▁) ▁= ▁new _ node ▁; ▁return ▁head _ ref ▁; ▁} ▁static ▁void ▁print List ▁( ▁Node ▁head ▁) ▁{ ▁while ▁( ▁head ▁!= ▁null ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁head ▁. ▁data ▁+ ▁" ▁" ▁) ▁; ▁head ▁= ▁head ▁. ▁next ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁Node ▁head ▁= ▁null ▁; ▁head ▁= ▁push ▁( ▁head ▁, ▁6 ▁) ▁; ▁head ▁= ▁push ▁( ▁head ▁, ▁4 ▁) ▁; ▁head ▁= ▁push ▁( ▁head ▁, ▁8 ▁) ▁; ▁head ▁= ▁push ▁( ▁head ▁, ▁12
▁class ▁G F G ▁{ ▁static ▁class ▁Node ▁{ ▁int ▁data ▁; ▁Node ▁next ▁, ▁prev ▁; ▁} ▁; ▁static ▁Node ▁insert ▁( ▁Node ▁head _ ref ▁, ▁int ▁data ▁) ▁{ ▁Node ▁new _ node ▁= ▁new ▁Node ▁( ▁) ▁; ▁new _ node ▁. ▁data ▁= ▁data ▁; ▁if ▁( ▁head _ ref ▁== ▁null ▁) ▁{ ▁new _ node ▁. ▁next ▁= ▁new _ node ▁; ▁new _ node ▁. ▁prev ▁= ▁new _ node ▁; ▁} ▁else ▁{ ▁Node ▁last ▁= ▁( ▁head _ ref ▁) ▁. ▁prev ▁; ▁new _ node ▁. ▁next ▁= ▁head _ ref ▁; ▁new _ node ▁. ▁prev ▁= ▁last ▁; ▁last ▁. ▁next ▁= ▁( ▁head _ ref ▁) ▁. ▁prev ▁= ▁new _ node ▁; ▁} ▁head _ ref ▁= ▁new _ node ▁; ▁return ▁head _ ref ▁; ▁} ▁static ▁Node ▁merge ▁( ▁Node ▁first ▁, ▁Node ▁second ▁) ▁{ ▁if ▁( ▁first ▁== ▁null ▁) ▁return ▁second ▁; ▁if ▁( ▁second ▁== ▁null ▁) ▁return ▁first ▁; ▁if ▁( ▁first ▁. ▁data ▁< ▁second ▁. ▁data ▁) ▁{ ▁first ▁. ▁next ▁= ▁merge ▁( ▁first ▁. ▁next ▁, ▁second ▁) ▁; ▁first ▁. ▁next ▁. ▁prev ▁= ▁first ▁; ▁first ▁. ▁prev ▁= ▁null ▁; ▁return ▁first ▁; ▁} ▁else ▁{ ▁second ▁. ▁next ▁= ▁merge ▁( ▁first ▁, ▁second ▁. ▁next ▁) ▁; ▁second ▁. ▁next ▁. ▁prev ▁= ▁second ▁; ▁second ▁. ▁prev ▁= ▁null ▁; ▁return ▁second ▁; ▁} ▁} ▁static ▁Node ▁merge Util ▁( ▁Node ▁head 1 ▁, ▁Node ▁head 2 ▁) ▁{ ▁if ▁( ▁head 1 ▁== ▁null ▁) ▁return ▁head 2 ▁; ▁if ▁( ▁head 2 ▁== ▁null ▁) ▁return ▁head 1 ▁; ▁Node ▁last _ node ▁; ▁if ▁( ▁head 1 ▁. ▁prev ▁. ▁data ▁< ▁head 2 ▁. ▁prev ▁. ▁data ▁) ▁last _ node ▁= ▁head 2 ▁. ▁prev ▁; ▁else ▁last _ node ▁= ▁head 1 ▁. ▁prev ▁; ▁head 1 ▁. ▁prev ▁. ▁next ▁= ▁head 2 ▁. ▁prev ▁. ▁next ▁= ▁null ▁; ▁Node ▁final Head ▁= ▁merge ▁( ▁head 1 ▁, ▁head 2 ▁) ▁; ▁final Head ▁. ▁prev ▁= ▁last _ node ▁; ▁last _ node ▁. ▁next ▁= ▁final Head ▁; ▁return ▁final Head ▁; ▁} ▁static ▁void ▁print List ▁( ▁Node ▁head ▁) ▁{ ▁Node ▁temp ▁= ▁head ▁; ▁while ▁( ▁temp ▁. ▁next ▁!= ▁head ▁) ▁{ ▁System ▁.
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁String ▁min Lex Rotation ▁( ▁String ▁str ▁) ▁{ ▁int ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁String ▁arr ▁[ ▁] ▁= ▁new ▁String ▁[ ▁n ▁] ▁; ▁String ▁concat ▁= ▁str ▁+ ▁str ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁arr ▁[ ▁i ▁] ▁= ▁concat ▁. ▁substring ▁( ▁i ▁, ▁i ▁+ ▁n ▁) ▁; ▁} ▁Arrays ▁. ▁sort ▁( ▁arr ▁) ▁; ▁return ▁arr ▁[ ▁0 ▁] ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁min Lex Rotation ▁( ▁" ▁G EEK S FOR GE EK S ▁" ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁min Lex Rotation ▁( ▁" ▁G EEK S QUI Z ▁" ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁min Lex Rotation ▁( ▁" ▁BC AB D AD AB ▁" ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁final ▁int ▁MAX ▁= ▁1000 ▁; ▁static ▁final ▁int ▁log ▁= ▁10 ▁; ▁static ▁int ▁[ ▁] ▁level ▁= ▁new ▁int ▁[ ▁MAX ▁] ▁; ▁static ▁int ▁[ ▁] ▁[ ▁] ▁l ca ▁= ▁new ▁int ▁[ ▁MAX ▁] ▁[ ▁log ▁] ▁; ▁static ▁int ▁[ ▁] ▁[ ▁] ▁min Weight ▁= ▁new ▁int ▁[ ▁MAX ▁] ▁[ ▁log ▁] ▁; ▁static ▁int ▁[ ▁] ▁[ ▁] ▁max Weight ▁= ▁new ▁int ▁[ ▁MAX ▁] ▁[ ▁log ▁] ▁; ▁static ▁Vector ▁< ▁Integer ▁> ▁[ ▁] ▁graph ▁= ▁new ▁Vector ▁[ ▁MAX ▁] ▁; ▁static ▁int ▁[ ▁] ▁weight ▁= ▁new ▁int ▁[ ▁MAX ▁] ▁; ▁private ▁static ▁void ▁swap ▁( ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁int ▁temp ▁= ▁x ▁; ▁x ▁= ▁y ▁; ▁y ▁= ▁temp ▁; ▁} ▁static ▁void ▁addEdge ▁( ▁int ▁u ▁, ▁int ▁v ▁) ▁{ ▁graph ▁[ ▁u ▁] ▁. ▁add ▁( ▁v ▁) ▁; ▁graph ▁[ ▁v ▁] ▁. ▁add ▁( ▁u ▁) ▁; ▁} ▁static ▁void ▁dfs ▁( ▁int ▁node ▁, ▁int ▁parent ▁, ▁int ▁h ▁) ▁{ ▁l ca ▁[ ▁node ▁] ▁[ ▁0 ▁] ▁= ▁parent ▁; ▁level ▁[ ▁node ▁] ▁= ▁h ▁; ▁if ▁( ▁parent ▁!= ▁- ▁1 ▁) ▁{ ▁min Weight ▁[ ▁node ▁] ▁[ ▁0 ▁] ▁= ▁Math ▁. ▁min ▁( ▁weight ▁[ ▁node ▁] ▁, ▁weight ▁[ ▁parent ▁] ▁) ▁; ▁max Weight ▁[ ▁node ▁] ▁[ ▁0 ▁] ▁= ▁Math ▁. ▁max ▁( ▁weight ▁[ ▁node ▁] ▁, ▁weight ▁[ ▁parent ▁] ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁log ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁l ca ▁[ ▁node ▁] ▁[ ▁i ▁- ▁1 ▁] ▁!= ▁- ▁1 ▁) ▁{ ▁l ca ▁[ ▁node ▁] ▁[ ▁i ▁] ▁= ▁l ca ▁[ ▁l ca ▁[ ▁node ▁] ▁[ ▁i ▁- ▁1 ▁] ▁] ▁[ ▁i ▁- ▁1 ▁] ▁; ▁min Weight ▁[ ▁node ▁] ▁[ ▁i ▁] ▁= ▁Math ▁. ▁min ▁( ▁min Weight ▁[ ▁node ▁] ▁[ ▁i ▁- ▁1 ▁] ▁, ▁min Weight ▁[ ▁l ca ▁[ ▁node ▁] ▁[ ▁i ▁- ▁1 ▁] ▁] ▁[ ▁i ▁- ▁1 ▁] ▁) ▁; ▁max Weight ▁[ ▁node ▁] ▁[ ▁i ▁] ▁= ▁Math ▁. ▁max ▁( ▁max Weight ▁[ ▁node ▁] ▁[ ▁i ▁- ▁1 ▁] ▁, ▁max Weight ▁[ ▁l
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁MAX ▁= ▁1000 ▁; ▁static ▁int ▁find L CA ▁( ▁int ▁n 1 ▁, ▁int ▁n 2 ▁, ▁int ▁parent ▁[ ▁] ▁) ▁{ ▁boolean ▁[ ▁] ▁visited ▁= ▁new ▁boolean ▁[ ▁MAX ▁] ▁; ▁visited ▁[ ▁n 1 ▁] ▁= ▁true ▁; ▁while ▁( ▁parent ▁[ ▁n 1 ▁] ▁!= ▁- ▁1 ▁) ▁{ ▁visited ▁[ ▁n 1 ▁] ▁= ▁true ▁; ▁n 1 ▁= ▁parent ▁[ ▁n 1 ▁] ▁; ▁} ▁visited ▁[ ▁n 1 ▁] ▁= ▁true ▁; ▁while ▁( ▁! ▁visited ▁[ ▁n 2 ▁] ▁) ▁n 2 ▁= ▁parent ▁[ ▁n 2 ▁] ▁; ▁return ▁n 2 ▁; ▁} ▁static ▁void ▁insert Adj ▁( ▁int ▁parent ▁[ ▁] ▁, ▁int ▁i ▁, ▁int ▁j ▁) ▁{ ▁parent ▁[ ▁i ▁] ▁= ▁j ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁parent ▁= ▁new ▁int ▁[ ▁MAX ▁] ▁; ▁parent ▁[ ▁20 ▁] ▁= ▁- ▁1 ▁; ▁insert Adj ▁( ▁parent ▁, ▁8 ▁, ▁20 ▁) ▁; ▁insert Adj ▁( ▁parent ▁, ▁22 ▁, ▁20 ▁) ▁; ▁insert Adj ▁( ▁parent ▁, ▁4 ▁, ▁8 ▁) ▁; ▁insert Adj ▁( ▁parent ▁, ▁12 ▁, ▁8 ▁) ▁; ▁insert Adj ▁( ▁parent ▁, ▁10 ▁, ▁12 ▁) ▁; ▁insert Adj ▁( ▁parent ▁, ▁14 ▁, ▁12 ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find L CA ▁( ▁10 ▁, ▁14 ▁, ▁parent ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁public ▁static ▁int ▁solve ▁( ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁int ▁ans ▁= ▁n ▁* ▁( ▁m ▁/ ▁2 ▁) ▁; ▁if ▁( ▁m ▁% ▁2 ▁== ▁1 ▁) ▁{ ▁ans ▁+= ▁( ▁n ▁+ ▁1 ▁) ▁/ ▁2 ▁; ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁N ▁= ▁5 ▁; ▁int ▁M ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁solve ▁( ▁N ▁, ▁M ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁max _ len ▁= ▁10000 5 ▁; ▁static ▁int ▁cnt ▁[ ▁] ▁= ▁new ▁int ▁[ ▁max _ len ▁] ▁; ▁public ▁static ▁void ▁pre compute ▁( ▁String ▁s ▁, ▁String ▁K ▁) ▁{ ▁int ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁cnt ▁[ ▁i ▁+ ▁1 ▁] ▁= ▁cnt ▁[ ▁i ▁] ▁; ▁if ▁( ▁s ▁. ▁substring ▁( ▁i ▁, ▁i ▁+ ▁K ▁. ▁length ▁( ▁) ▁) ▁. ▁equals ▁( ▁K ▁) ▁) ▁{ ▁cnt ▁[ ▁i ▁+ ▁1 ▁] ▁+= ▁1 ▁; ▁} ▁} ▁cnt ▁[ ▁n ▁- ▁2 ▁+ ▁1 ▁] ▁= ▁cnt ▁[ ▁n ▁- ▁2 ▁] ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁s ▁= ▁" ▁ABC ABC AB ABC ▁" ▁; ▁String ▁K ▁= ▁" ▁ABC ▁" ▁; ▁pre compute ▁( ▁s ▁, ▁K ▁) ▁; ▁int ▁Q ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁6 ▁} ▁, ▁{ ▁5 ▁, ▁11 ▁} ▁} ▁; ▁for ▁( ▁int ▁it ▁= ▁0 ▁; ▁it ▁< ▁Q ▁. ▁length ▁; ▁it ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁cnt ▁[ ▁Q ▁[ ▁it ▁] ▁[ ▁1 ▁] ▁- ▁1 ▁] ▁- ▁cnt ▁[ ▁Q ▁[ ▁it ▁] ▁[ ▁0 ▁] ▁- ▁1 ▁] ▁) ▁; ▁} ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁count Int gr al Points ▁( ▁int ▁x 1 ▁, ▁int ▁y 1 ▁, ▁int ▁x 2 ▁, ▁int ▁y 2 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁( ▁y 2 ▁- ▁y 1 ▁- ▁1 ▁) ▁* ▁( ▁x 2 ▁- ▁x 1 ▁- ▁1 ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁x 1 ▁= ▁1 ▁, ▁y 1 ▁= ▁1 ▁; ▁int ▁x 2 ▁= ▁4 ▁, ▁y 2 ▁= ▁4 ▁; ▁count Int gr al Points ▁( ▁x 1 ▁, ▁y 1 ▁, ▁x 2 ▁, ▁y 2 ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁min Sum ▁( ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁while ▁( ▁n ▁> ▁0 ▁) ▁{ ▁sum ▁+= ▁( ▁n ▁% ▁10 ▁) ▁; ▁n ▁/= ▁10 ▁; ▁} ▁if ▁( ▁sum ▁== ▁1 ▁) ▁return ▁10 ▁; ▁return ▁sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁18 84 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁min Sum ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁int ▁repeating Element ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁M ▁= ▁0 ▁, ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁M ▁= ▁Math ▁. ▁max ▁( ▁M ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁int ▁sum 1 ▁= ▁M ▁* ▁( ▁M ▁+ ▁1 ▁) ▁/ ▁2 ▁; ▁int ▁ans ▁= ▁( ▁sum ▁- ▁sum 1 ▁) ▁/ ▁( ▁N ▁- ▁M ▁) ▁; ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁6 ▁, ▁4 ▁, ▁3 ▁, ▁1 ▁, ▁5 ▁, ▁2 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁repeating Element ▁( ▁arr ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁int ▁calculate Max ▁( ▁int ▁N ▁, ▁int ▁M ▁, ▁int ▁K ▁) ▁{ ▁int ▁ans ▁= ▁- ▁1 ▁; ▁int ▁low ▁= ▁0 ▁, ▁high ▁= ▁M ▁; ▁while ▁( ▁low ▁<= ▁high ▁) ▁{ ▁int ▁mid ▁= ▁( ▁low ▁+ ▁high ▁) ▁/ ▁2 ▁; ▁int ▁val ▁= ▁0 ▁; ▁int ▁L ▁= ▁K ▁- ▁1 ▁; ▁int ▁R ▁= ▁N ▁- ▁K ▁; ▁val ▁+= ▁mid ▁; ▁if ▁( ▁mid ▁>= ▁L ▁) ▁{ ▁val ▁+= ▁( ▁L ▁) ▁* ▁( ▁2 ▁* ▁mid ▁- ▁L ▁- ▁1 ▁) ▁/ ▁2 ▁; ▁} ▁else ▁{ ▁val ▁+= ▁mid ▁* ▁( ▁mid ▁- ▁1 ▁) ▁/ ▁2 ▁+ ▁( ▁L ▁- ▁mid ▁) ▁; ▁} ▁if ▁( ▁mid ▁>= ▁R ▁) ▁{ ▁val ▁+= ▁( ▁R ▁) ▁* ▁( ▁2 ▁* ▁mid ▁- ▁R ▁- ▁1 ▁) ▁/ ▁2 ▁; ▁} ▁else ▁{ ▁val ▁+= ▁mid ▁* ▁( ▁mid ▁- ▁1 ▁) ▁/ ▁2 ▁+ ▁( ▁R ▁- ▁mid ▁) ▁; ▁} ▁if ▁( ▁val ▁<= ▁M ▁) ▁{ ▁ans ▁= ▁Math ▁. ▁max ▁( ▁ans ▁, ▁mid ▁) ▁; ▁low ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁else ▁high ▁= ▁mid ▁- ▁1 ▁; ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁7 ▁, ▁M ▁= ▁100 ▁, ▁K ▁= ▁6 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁calculate Max ▁( ▁N ▁, ▁M ▁, ▁K ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁find _ index ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁max _ value ▁= ▁Integer ▁. ▁MIN _ VALUE ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁max _ value ▁= ▁Math ▁. ▁max ▁( ▁max _ value ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁Map ▁< ▁Integer ▁, ▁Integer ▁> ▁store ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁max _ value ▁; ▁i ▁++ ▁) ▁{ ▁store ▁. ▁put ▁( ▁i ▁, ▁store ▁. ▁getOr Default ▁( ▁i ▁, ▁0 ▁) ▁+ ▁1 ▁) ▁; ▁} ▁if ▁( ▁store ▁. ▁containsKey ▁( ▁1 ▁) ▁) ▁{ ▁store ▁. ▁remove ▁( ▁1 ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁Math ▁. ▁sqrt ▁( ▁max _ value ▁) ▁; ▁i ▁++ ▁) ▁{ ▁int ▁multiple ▁= ▁2 ▁; ▁while ▁( ▁( ▁i ▁* ▁multiple ▁) ▁<= ▁max _ value ▁) ▁{ ▁if ▁( ▁store ▁. ▁containsKey ▁( ▁i ▁* ▁multiple ▁) ▁) ▁{ ▁store ▁. ▁remove ▁( ▁i ▁* ▁multiple ▁) ▁; ▁} ▁multiple ▁++ ▁; ▁} ▁} ▁int ▁prime _ sum _ from _ left ▁= ▁0 ▁; ▁int ▁[ ▁] ▁first _ array ▁= ▁new ▁int ▁[ ▁N ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁first _ array ▁[ ▁i ▁] ▁= ▁prime _ sum _ from _ left ▁; ▁if ▁( ▁store ▁. ▁containsKey ▁( ▁arr ▁[ ▁i ▁] ▁) ▁) ▁{ ▁prime _ sum _ from _ left ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁} ▁int ▁prime _ sum _ from _ right ▁= ▁0 ▁; ▁int ▁[ ▁] ▁second _ array ▁= ▁new ▁int ▁[ ▁N ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁N ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁second _ array ▁[ ▁i ▁] ▁= ▁prime _ sum _ from _ right ▁; ▁if ▁( ▁store ▁. ▁containsKey ▁( ▁arr ▁[ ▁i ▁] ▁) ▁) ▁{ ▁prime _ sum _ from _ right ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁first
▁class ▁G F G ▁{ ▁static ▁int ▁find Cost ▁( ▁int ▁[ ▁] ▁A ▁, ▁int ▁N ▁) ▁{ ▁int ▁total Cost ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁A ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁A ▁[ ▁i ▁] ▁= ▁1 ▁; ▁total Cost ▁+= ▁i ▁; ▁} ▁} ▁return ▁total Cost ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Cost ▁( ▁arr ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁is Greater Equal ▁( ▁int ▁N ▁, ▁int ▁K ▁, ▁int ▁X ▁) ▁{ ▁return ▁( ▁( ▁N ▁* ▁1 L ▁* ▁( ▁N ▁+ ▁1 ▁) ▁/ ▁2 ▁) ▁- ▁( ▁( ▁K ▁- ▁1 ▁) ▁* ▁1 L ▁* ▁K ▁/ ▁2 ▁) ▁) ▁>= ▁X ▁; ▁} ▁static ▁void ▁minimum Number ▁( ▁int ▁K ▁, ▁int ▁X ▁) ▁{ ▁if ▁( ▁K ▁> ▁X ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁- ▁1" ▁) ▁; ▁return ▁; ▁} ▁int ▁low ▁= ▁K ▁, ▁high ▁= ▁X ▁, ▁res ▁= ▁- ▁1 ▁; ▁while ▁( ▁low ▁<= ▁high ▁) ▁{ ▁int ▁mid ▁= ▁low ▁+ ▁( ▁high ▁- ▁low ▁) ▁/ ▁2 ▁; ▁if ▁( ▁is Greater Equal ▁( ▁mid ▁, ▁K ▁, ▁X ▁) ▁) ▁{ ▁res ▁= ▁mid ▁; ▁high ▁= ▁mid ▁- ▁1 ▁; ▁} ▁else ▁low ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁res ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁K ▁= ▁5 ▁, ▁X ▁= ▁13 ▁; ▁minimum Number ▁( ▁K ▁, ▁X ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁Get Diff ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁S uff Max Arr ▁[ ▁] ▁= ▁new ▁int ▁[ ▁N ▁] ▁; ▁S uff Max Arr ▁[ ▁N ▁- ▁1 ▁] ▁= ▁A ▁[ ▁N ▁- ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁N ▁- ▁2 ▁; ▁i ▁>= ▁0 ▁; ▁-- ▁i ▁) ▁{ ▁S uff Max Arr ▁[ ▁i ▁] ▁= ▁Math ▁. ▁max ▁( ▁S uff Max Arr ▁[ ▁i ▁+ ▁1 ▁] ▁, ▁A ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁; ▁} ▁int ▁Maximum Sum ▁= ▁Integer ▁. ▁MIN _ VALUE ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁A ▁[ ▁i ▁] ▁< ▁S uff Max Arr ▁[ ▁i ▁] ▁) ▁Maximum Sum ▁= ▁Math ▁. ▁max ▁( ▁Maximum Sum ▁, ▁A ▁[ ▁i ▁] ▁+ ▁S uff Max Arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁int ▁Minimum Sum ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁int ▁S uff Min Arr ▁[ ▁] ▁= ▁new ▁int ▁[ ▁N ▁] ▁; ▁S uff Min Arr ▁[ ▁N ▁- ▁1 ▁] ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁for ▁( ▁int ▁i ▁= ▁N ▁- ▁2 ▁; ▁i ▁>= ▁0 ▁; ▁-- ▁i ▁) ▁{ ▁S uff Min Arr ▁[ ▁i ▁] ▁= ▁Math ▁. ▁min ▁( ▁S uff Min Arr ▁[ ▁i ▁+ ▁1 ▁] ▁, ▁A ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁A ▁[ ▁i ▁] ▁< ▁S uff Min Arr ▁[ ▁i ▁] ▁) ▁{ ▁Minimum Sum ▁= ▁Math ▁. ▁min ▁( ▁Minimum Sum ▁, ▁A ▁[ ▁i ▁] ▁+ ▁S uff Min Arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁} ▁return ▁Math ▁. ▁abs ▁( ▁Maximum Sum ▁- ▁Minimum Sum ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁4 ▁, ▁1 ▁, ▁3 ▁, ▁7 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁Get Diff ▁( ▁arr ▁, ▁N ▁) ▁) ▁;
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁sum Of Digits ▁( ▁String ▁s ▁) ▁{ ▁int ▁curr ▁= ▁0 ▁; ▁int ▁ret ▁= ▁0 ▁; ▁for ▁( ▁char ▁ch ▁: ▁s ▁. ▁toCharArray ▁( ▁) ▁) ▁{ ▁if ▁( ▁ch ▁>= ▁48 ▁&& ▁ch ▁<= ▁57 ▁) ▁{ ▁curr ▁= ▁curr ▁* ▁10 ▁+ ▁ch ▁- ▁'0' ▁; ▁} ▁else ▁{ ▁ret ▁+= ▁curr ▁; ▁curr ▁= ▁0 ▁; ▁} ▁} ▁ret ▁+= ▁curr ▁; ▁return ▁ret ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁S ▁= ▁"11 aa 32 bbb 5" ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁sum Of Digits ▁( ▁S ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁G F G ▁{ ▁static ▁void ▁minimum Operations ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁N ▁) ▁{ ▁int ▁odd Cnt ▁= ▁0 ▁, ▁even Cnt ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁even Cnt ▁++ ▁; ▁} ▁else ▁{ ▁odd Cnt ▁++ ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁Math ▁. ▁min ▁( ▁odd Cnt ▁, ▁even Cnt ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁4 ▁, ▁1 ▁, ▁2 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁minimum Operations ▁( ▁arr ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁check ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁boolean ▁flag ▁= ▁false ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁> ▁a ▁[ ▁i ▁] ▁&& ▁a ▁[ ▁i ▁] ▁< ▁a ▁[ ▁i ▁- ▁1 ▁] ▁) ▁flag ▁= ▁true ▁; ▁} ▁if ▁( ▁flag ▁) ▁return ▁false ▁; ▁else ▁return ▁true ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁5 ▁, ▁2 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁if ▁( ▁check ▁( ▁arr ▁, ▁N ▁) ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁YES ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁NO ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁min Operations ▁( ▁String ▁S ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁S ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁S ▁. ▁charAt ▁( ▁i ▁) ▁!= ▁S ▁. ▁charAt ▁( ▁i ▁- ▁1 ▁) ▁) ▁{ ▁count ▁+= ▁1 ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁count ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁S ▁= ▁" 0101 0101 01" ▁; ▁min Operations ▁( ▁S ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁numberOf Pairs ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁[ ▁] ▁set _ bits ▁= ▁new ▁int ▁[ ▁31 ▁] ▁; ▁Arrays ▁. ▁fill ▁( ▁set _ bits ▁, ▁0 ▁) ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁int ▁x ▁= ▁arr ▁[ ▁i ▁] ▁; ▁int ▁bit pos ▁= ▁- ▁1 ▁; ▁while ▁( ▁x ▁> ▁0 ▁) ▁{ ▁bit pos ▁++ ▁; ▁x ▁/= ▁2 ▁; ▁} ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁<= ▁bit pos ▁; ▁j ▁++ ▁) ▁{ ▁count ▁+= ▁set _ bits ▁[ ▁j ▁] ▁; ▁} ▁set _ bits ▁[ ▁bit pos ▁] ▁++ ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁count ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁16 ▁, ▁8 ▁, ▁64 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁numberOf Pairs ▁( ▁arr ▁, ▁N ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁find Maximum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁Q ▁, ▁int ▁queries ▁[ ▁] ▁[ ▁] ▁) ▁{ ▁int ▁prefix _ max ▁[ ▁] ▁= ▁new ▁int ▁[ ▁N ▁+ ▁1 ▁] ▁; ▁int ▁suffix _ max ▁[ ▁] ▁= ▁new ▁int ▁[ ▁N ▁+ ▁1 ▁] ▁; ▁prefix _ max ▁[ ▁0 ▁] ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁prefix _ max ▁[ ▁i ▁] ▁= ▁Math ▁. ▁max ▁( ▁prefix _ max ▁[ ▁i ▁- ▁1 ▁] ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁suffix _ max ▁[ ▁N ▁- ▁1 ▁] ▁= ▁arr ▁[ ▁N ▁- ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁N ▁- ▁2 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁suffix _ max ▁[ ▁i ▁] ▁= ▁Math ▁. ▁max ▁( ▁suffix _ max ▁[ ▁i ▁+ ▁1 ▁] ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁Q ▁; ▁i ▁++ ▁) ▁{ ▁int ▁l ▁= ▁queries ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁; ▁int ▁r ▁= ▁queries ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁; ▁if ▁( ▁l ▁== ▁0 ▁&& ▁r ▁== ▁( ▁N ▁- ▁1 ▁) ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁"0 NEW _ LINE "); ▁else ▁if ▁( ▁l ▁== ▁0 ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁suffix _ max ▁[ ▁r ▁+ ▁1 ▁] ▁+ ▁" NEW _ LINE "); ▁else ▁if ▁( ▁r ▁== ▁( ▁N ▁- ▁1 ▁) ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁prefix _ max ▁[ ▁l ▁- ▁1 ▁] ▁+ ▁" NEW _ LINE "); ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁Math ▁. ▁max ▁( ▁prefix _ max ▁[ ▁l ▁- ▁1 ▁] ▁, ▁suffix _ max ▁[ ▁r ▁+ ▁1 ▁] ▁) ▁+ ▁" NEW _ LINE "); ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁6 ▁, ▁8 ▁, ▁10 ▁, ▁15 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁int ▁queries ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁0 ▁, ▁1 ▁} ▁, ▁{ ▁0 ▁, ▁2 ▁} ▁, ▁{ ▁1 ▁, ▁4 ▁} ▁} ▁; ▁int ▁Q ▁= ▁queries ▁. ▁length ▁; ▁find
▁class ▁G F G ▁{ ▁static ▁String ▁min Email ▁( ▁String ▁email ▁) ▁{ ▁String ▁ans ▁= ▁new ▁String ▁( ▁" ▁" ▁) ▁; ▁int ▁len ▁= ▁email ▁. ▁length ▁( ▁) ▁; ▁ans ▁+= ▁email ▁. ▁charAt ▁( ▁0 ▁) ▁; ▁int ▁i ▁= ▁1 ▁; ▁boolean ▁not At ▁= ▁true ▁; ▁while ▁( ▁i ▁< ▁len ▁) ▁{ ▁if ▁( ▁i ▁< ▁len ▁- ▁3 ▁&& ▁not At ▁&& ▁email ▁. ▁charAt ▁( ▁i ▁) ▁== ▁' ▁a ▁' ▁&& ▁email ▁. ▁charAt ▁( ▁i ▁+ ▁1 ▁) ▁== ▁' ▁t ▁' ▁) ▁{ ▁ans ▁+= ▁' ▁@ ▁' ▁; ▁i ▁+= ▁1 ▁; ▁not At ▁= ▁false ▁; ▁} ▁else ▁if ▁( ▁i ▁< ▁len ▁- ▁4 ▁&& ▁email ▁. ▁charAt ▁( ▁i ▁) ▁== ▁' ▁d ▁' ▁&& ▁email ▁. ▁charAt ▁( ▁i ▁+ ▁1 ▁) ▁== ▁' ▁o ▁' ▁&& ▁email ▁. ▁charAt ▁( ▁i ▁+ ▁2 ▁) ▁== ▁' ▁t ▁' ▁) ▁{ ▁ans ▁+= ▁' ▁. ▁' ▁; ▁i ▁+= ▁2 ▁; ▁} ▁else ▁{ ▁ans ▁+= ▁email ▁. ▁charAt ▁( ▁i ▁) ▁; ▁} ▁i ▁+= ▁1 ▁; ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁email ▁= ▁new ▁String ▁( ▁" ▁g eek s forge ek sat g ma ild ot com ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁min Email ▁( ▁email ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁count Remaining Elements ▁( ▁int ▁[ ▁] ▁L 1 ▁, ▁int ▁[ ▁] ▁L 2 ▁, ▁int ▁n ▁) ▁{ ▁int ▁one ▁= ▁0 ▁; ▁int ▁zero ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁L 1 ▁[ ▁i ▁] ▁== ▁1 ▁) ▁one ▁++ ▁; ▁else ▁zero ▁++ ▁; ▁} ▁int ▁ans ▁= ▁n ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁L 2 ▁[ ▁i ▁] ▁== ▁1 ▁) ▁{ ▁one ▁-- ▁; ▁if ▁( ▁one ▁< ▁0 ▁) ▁{ ▁ans ▁= ▁i ▁; ▁break ▁; ▁} ▁} ▁else ▁{ ▁zero ▁-- ▁; ▁if ▁( ▁zero ▁< ▁0 ▁) ▁{ ▁ans ▁= ▁i ▁; ▁break ▁; ▁} ▁} ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁n ▁- ▁ans ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁L 1 ▁= ▁{ ▁1 ▁, ▁1 ▁, ▁0 ▁, ▁0 ▁} ▁; ▁int ▁[ ▁] ▁L 2 ▁= ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁L 1 ▁. ▁length ▁; ▁count Remaining Elements ▁( ▁L 1 ▁, ▁L 2 ▁, ▁N ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁L CM ▁( ▁int ▁A ▁, ▁int ▁B ▁) ▁{ ▁return ▁( ▁A ▁* ▁B ▁/ ▁__ g cd ▁( ▁A ▁, ▁B ▁) ▁) ▁; ▁} ▁static ▁void ▁find Small est Number ▁( ▁int ▁X ▁) ▁{ ▁int ▁l cm ▁= ▁1 ▁; ▁int ▁temp ▁= ▁X ▁; ▁while ▁( ▁temp ▁> ▁0 ▁) ▁{ ▁int ▁last ▁= ▁temp ▁% ▁10 ▁; ▁temp ▁/= ▁10 ▁; ▁if ▁( ▁last ▁== ▁0 ▁) ▁continue ▁; ▁l cm ▁= ▁L CM ▁( ▁l cm ▁, ▁last ▁) ▁; ▁} ▁int ▁answer ▁= ▁( ▁( ▁X ▁+ ▁l cm ▁- ▁1 ▁) ▁/ ▁l cm ▁) ▁* ▁l cm ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁answer ▁) ▁; ▁} ▁static ▁int ▁__ g cd ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁return ▁b ▁== ▁0 ▁? ▁a ▁: ▁__ g cd ▁( ▁b ▁, ▁a ▁% ▁b ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁X ▁= ▁2 80 ▁; ▁find Small est Number ▁( ▁X ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁int ▁find Non Multi ples ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁Set ▁< ▁Integer ▁> ▁multiples ▁= ▁new ▁HashSet ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁! ▁multiples ▁. ▁contains ▁( ▁arr ▁[ ▁i ▁] ▁) ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁<= ▁k ▁/ ▁arr ▁[ ▁i ▁] ▁; ▁j ▁++ ▁) ▁{ ▁multiples ▁. ▁add ▁( ▁arr ▁[ ▁i ▁] ▁* ▁j ▁) ▁; ▁} ▁} ▁} ▁return ▁k ▁- ▁multiples ▁. ▁size ▁( ▁) ▁; ▁} ▁public ▁static ▁int ▁count Values ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁N ▁, ▁int ▁L ▁, ▁int ▁R ▁) ▁{ ▁return ▁find Non Multi ples ▁( ▁arr ▁, ▁N ▁, ▁R ▁) ▁- ▁find Non Multi ples ▁( ▁arr ▁, ▁N ▁, ▁L ▁- ▁1 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁int ▁L ▁= ▁1 ▁; ▁int ▁R ▁= ▁20 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Values ▁( ▁arr ▁, ▁N ▁, ▁L ▁, ▁R ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁find Cnt Tri plet ▁( ▁int ▁N ▁) ▁{ ▁int ▁cnt Tri plet ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁N ▁% ▁i ▁!= ▁0 ▁) ▁{ ▁cnt Tri plet ▁+= ▁N ▁/ ▁i ▁; ▁} ▁else ▁{ ▁cnt Tri plet ▁+= ▁( ▁N ▁/ ▁i ▁) ▁- ▁1 ▁; ▁} ▁} ▁return ▁cnt Tri plet ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Cnt Tri plet ▁( ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁min Collect ing Speed ▁( ▁int ▁[ ▁] ▁p iles ▁, ▁int ▁H ▁) ▁{ ▁int ▁ans ▁= ▁- ▁1 ▁; ▁int ▁low ▁= ▁1 ▁, ▁high ▁; ▁high ▁= ▁Arrays ▁. ▁stream ▁( ▁p iles ▁) ▁. ▁max ▁( ▁) ▁. ▁getAs Int ▁( ▁) ▁; ▁while ▁( ▁low ▁<= ▁high ▁) ▁{ ▁int ▁K ▁= ▁low ▁+ ▁( ▁high ▁- ▁low ▁) ▁/ ▁2 ▁; ▁int ▁time ▁= ▁0 ▁; ▁for ▁( ▁int ▁ai ▁: ▁p iles ▁) ▁{ ▁time ▁+= ▁( ▁ai ▁+ ▁K ▁- ▁1 ▁) ▁/ ▁K ▁; ▁} ▁if ▁( ▁time ▁<= ▁H ▁) ▁{ ▁ans ▁= ▁K ▁; ▁high ▁= ▁K ▁- ▁1 ▁; ▁} ▁else ▁{ ▁low ▁= ▁K ▁+ ▁1 ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁ans ▁) ▁; ▁} ▁static ▁public ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁3 ▁, ▁6 ▁, ▁7 ▁, ▁11 ▁} ▁; ▁int ▁H ▁= ▁8 ▁; ▁min Collect ing Speed ▁( ▁arr ▁, ▁H ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁count Sub Array Sign Change ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁prefix Count ▁= ▁new ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁( ▁) ▁; ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁suffix Count ▁= ▁new ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁( ▁) ▁; ▁int ▁total ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁N ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁total ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁if ▁( ▁suffix Count ▁. ▁containsKey ▁( ▁arr ▁[ ▁i ▁] ▁) ▁) ▁{ ▁suffix Count ▁. ▁put ▁( ▁arr ▁[ ▁i ▁] ▁, ▁suffix Count ▁. ▁get ▁( ▁arr ▁[ ▁i ▁] ▁) ▁+ ▁1 ▁) ▁; ▁} ▁else ▁{ ▁suffix Count ▁. ▁put ▁( ▁arr ▁[ ▁i ▁] ▁, ▁1 ▁) ▁; ▁} ▁} ▁int ▁prefix Sum ▁= ▁0 ▁; ▁int ▁suffix Sum ▁= ▁0 ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁prefix Sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁if ▁( ▁prefix Count ▁. ▁containsKey ▁( ▁arr ▁[ ▁i ▁] ▁) ▁) ▁{ ▁prefix Count ▁. ▁put ▁( ▁arr ▁[ ▁i ▁] ▁, ▁prefix Count ▁. ▁get ▁( ▁arr ▁[ ▁i ▁] ▁) ▁+ ▁1 ▁) ▁; ▁} ▁else ▁{ ▁prefix Count ▁. ▁put ▁( ▁arr ▁[ ▁i ▁] ▁, ▁1 ▁) ▁; ▁} ▁suffix Sum ▁= ▁total ▁- ▁prefix Sum ▁; ▁if ▁( ▁suffix Count ▁. ▁containsKey ▁( ▁arr ▁[ ▁i ▁] ▁) ▁) ▁{ ▁suffix Count ▁. ▁put ▁( ▁arr ▁[ ▁i ▁] ▁, ▁suffix Count ▁. ▁get ▁( ▁arr ▁[ ▁i ▁] ▁) ▁- ▁1 ▁) ▁; ▁} ▁int ▁diff ▁= ▁prefix Sum ▁- ▁suffix Sum ▁; ▁if ▁( ▁diff ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁int ▁x ▁= ▁( ▁prefix Count ▁. ▁containsKey ▁( ▁diff ▁/ ▁2 ▁) ▁? ▁prefix Count ▁. ▁get ▁( ▁diff ▁/ ▁2 ▁) ▁: ▁0 ▁) ▁+ ▁( ▁suffix Count ▁. ▁containsKey ▁( ▁- ▁diff ▁/ ▁2 ▁) ▁? ▁suffix Count ▁. ▁get ▁( ▁- ▁diff ▁/ ▁2 ▁) ▁: ▁0 ▁) ▁; ▁count ▁= ▁count ▁+ ▁x ▁; ▁} ▁} ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁2 ▁,
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁count Common Char ▁( ▁int ▁ind ▁, ▁String ▁S ▁) ▁{ ▁int ▁cnt ▁= ▁0 ▁; ▁HashSet ▁< ▁Character ▁> ▁ls ▁= ▁new ▁HashSet ▁< ▁Character ▁> ▁( ▁) ▁; ▁HashSet ▁< ▁Character ▁> ▁rs ▁= ▁new ▁HashSet ▁< ▁Character ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁ind ▁; ▁++ ▁i ▁) ▁{ ▁ls ▁. ▁add ▁( ▁S ▁. ▁charAt ▁( ▁i ▁) ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁ind ▁; ▁i ▁< ▁S ▁. ▁length ▁( ▁) ▁; ▁++ ▁i ▁) ▁{ ▁rs ▁. ▁add ▁( ▁S ▁. ▁charAt ▁( ▁i ▁) ▁) ▁; ▁} ▁for ▁( ▁char ▁v ▁: ▁ls ▁) ▁{ ▁if ▁( ▁rs ▁. ▁contains ▁( ▁v ▁) ▁) ▁{ ▁++ ▁cnt ▁; ▁} ▁} ▁return ▁cnt ▁; ▁} ▁static ▁void ▁partition String With Max Com ▁( ▁String ▁S ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁S ▁. ▁length ▁( ▁) ▁; ▁++ ▁i ▁) ▁{ ▁ans ▁= ▁Math ▁. ▁max ▁( ▁ans ▁, ▁count Common Char ▁( ▁i ▁, ▁S ▁) ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁ans ▁+ ▁" NEW _ LINE "); ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁" ▁a abb ca ▁" ▁; ▁partition String With Max Com ▁( ▁str ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁String ▁Small est String ▁( ▁String ▁s ▁, ▁char ▁c ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁> ▁c ▁) ▁{ ▁String ▁temp ▁= ▁s ▁; ▁s ▁= ▁s ▁. ▁substring ▁( ▁0 ▁, ▁i ▁) ▁; ▁s ▁+= ▁c ▁; ▁s ▁+= ▁temp ▁. ▁substring ▁( ▁i ▁, ▁temp ▁. ▁length ▁( ▁) ▁) ▁; ▁return ▁s ▁; ▁} ▁} ▁s ▁+= ▁c ▁; ▁return ▁s ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁String ▁S ▁= ▁" ▁ac d ▁" ▁; ▁char ▁C ▁= ▁' ▁b ▁' ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁Small est String ▁( ▁S ▁, ▁C ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁sum Of Path Nodes ▁( ▁int ▁N ▁) ▁{ ▁if ▁( ▁N ▁== ▁1 ▁) ▁{ ▁return ▁1 ▁; ▁} ▁else ▁if ▁( ▁N ▁== ▁2 ▁N ▁== ▁3 ▁) ▁{ ▁return ▁N ▁+ ▁1 ▁; ▁} ▁Vector ▁< ▁Integer ▁> ▁arr ▁= ▁new ▁Vector ▁< ▁> ▁( ▁) ▁; ▁arr ▁. ▁add ▁( ▁1 ▁) ▁; ▁int ▁k ▁= ▁1 ▁; ▁boolean ▁flag ▁= ▁true ▁; ▁while ▁( ▁k ▁< ▁N ▁) ▁{ ▁if ▁( ▁flag ▁== ▁true ▁) ▁{ ▁k ▁*= ▁2 ▁; ▁flag ▁= ▁false ▁; ▁} ▁else ▁{ ▁k ▁*= ▁4 ▁; ▁flag ▁= ▁true ▁; ▁} ▁if ▁( ▁k ▁> ▁N ▁) ▁{ ▁break ▁; ▁} ▁arr ▁. ▁add ▁( ▁k ▁) ▁; ▁} ▁int ▁len ▁= ▁arr ▁. ▁size ▁( ▁) ▁; ▁int ▁[ ▁] ▁prefix ▁= ▁new ▁int ▁[ ▁len ▁] ▁; ▁prefix ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁len ▁; ▁++ ▁i ▁) ▁{ ▁prefix ▁[ ▁i ▁] ▁= ▁arr ▁. ▁get ▁( ▁i ▁) ▁+ ▁prefix ▁[ ▁i ▁- ▁1 ▁] ▁; ▁} ▁int ▁it ▁= ▁lowerBound ▁( ▁prefix ▁, ▁0 ▁, ▁len ▁, ▁N ▁) ▁+ ▁1 ▁; ▁int ▁ind ▁= ▁it ▁- ▁prefix ▁[ ▁0 ▁] ▁; ▁int ▁final _ ans ▁= ▁0 ▁; ▁int ▁temp ▁= ▁N ▁; ▁while ▁( ▁ind ▁> ▁1 ▁) ▁{ ▁int ▁val ▁= ▁temp ▁- ▁prefix ▁[ ▁ind ▁- ▁1 ▁] ▁; ▁if ▁( ▁ind ▁% ▁2 ▁!= ▁0 ▁) ▁{ ▁temp ▁= ▁prefix ▁[ ▁ind ▁- ▁2 ▁] ▁+ ▁( ▁val ▁+ ▁1 ▁) ▁/ ▁2 ▁; ▁} ▁else ▁{ ▁temp ▁= ▁prefix ▁[ ▁ind ▁- ▁2 ▁] ▁+ ▁( ▁val ▁+ ▁3 ▁) ▁/ ▁4 ▁; ▁} ▁-- ▁ind ▁; ▁final _ ans ▁+= ▁temp ▁; ▁} ▁final _ ans ▁+= ▁( ▁N ▁+ ▁1 ▁) ▁; ▁return ▁final _ ans ▁; ▁} ▁static ▁int ▁lowerBound ▁( ▁int ▁[ ▁] ▁a ▁, ▁int ▁low ▁, ▁int ▁high ▁, ▁int ▁element ▁) ▁{ ▁while ▁( ▁low ▁< ▁high ▁) ▁{ ▁int ▁middle ▁= ▁low ▁+ ▁( ▁high ▁- ▁low ▁) ▁/ ▁2 ▁; ▁if ▁( ▁element ▁> ▁a ▁[ ▁middle ▁] ▁) ▁low ▁= ▁middle ▁+ ▁1 ▁; ▁else ▁high ▁= ▁middle ▁; ▁} ▁return ▁low ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁import ▁java ▁. ▁util ▁. ▁Collections ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁re arrange Array ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁a ▁[ ▁i ▁] ▁; ▁} ▁if ▁( ▁sum ▁== ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁- ▁1" ▁) ▁; ▁return ▁; ▁} ▁sum ▁= ▁0 ▁; ▁int ▁b ▁= ▁0 ▁; ▁Arrays ▁. ▁sort ▁( ▁a ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁a ▁[ ▁i ▁] ▁; ▁if ▁( ▁sum ▁== ▁0 ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁!= ▁a ▁[ ▁N ▁- ▁1 ▁] ▁) ▁{ ▁sum ▁-= ▁a ▁[ ▁i ▁] ▁; ▁int ▁temp ▁= ▁a ▁[ ▁i ▁] ▁; ▁a ▁[ ▁i ▁] ▁= ▁a ▁[ ▁N ▁- ▁1 ▁] ▁; ▁a ▁[ ▁N ▁- ▁1 ▁] ▁= ▁temp ▁; ▁sum ▁+= ▁a ▁[ ▁i ▁] ▁; ▁} ▁else ▁{ ▁b ▁= ▁1 ▁; ▁break ▁; ▁} ▁} ▁} ▁if ▁( ▁b ▁== ▁1 ▁) ▁{ ▁b ▁= ▁0 ▁; ▁sum ▁= ▁0 ▁; ▁Arrays ▁. ▁sort ▁( ▁a ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁N ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁sum ▁+= ▁a ▁[ ▁i ▁] ▁; ▁if ▁( ▁sum ▁== ▁0 ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁!= ▁a ▁[ ▁0 ▁] ▁) ▁{ ▁sum ▁-= ▁a ▁[ ▁i ▁] ▁; ▁int ▁temp ▁= ▁a ▁[ ▁i ▁] ▁; ▁a ▁[ ▁i ▁] ▁= ▁a ▁[ ▁0 ▁] ▁; ▁a ▁[ ▁0 ▁] ▁= ▁temp ▁; ▁sum ▁+= ▁a ▁[ ▁i ▁] ▁; ▁} ▁else ▁{ ▁b ▁= ▁1 ▁; ▁break ▁; ▁} ▁} ▁} ▁} ▁if ▁( ▁b ▁== ▁1 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁- ▁1" ▁+ ▁" ▁" ▁) ▁; ▁return ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁a ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁- ▁1
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁find Minimum Operations ▁( ▁char ▁[ ▁] ▁a ▁, ▁char ▁[ ▁] ▁b ▁) ▁{ ▁int ▁step ▁= ▁0 ▁; ▁int ▁last _ index ▁= ▁0 ▁; ▁while ▁( ▁! ▁Arrays ▁. ▁equals ▁( ▁a ▁, ▁b ▁) ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁a ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁!= ▁b ▁[ ▁i ▁] ▁) ▁{ ▁last _ index ▁= ▁i ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁last _ index ▁; ▁i ▁++ ▁) ▁{ ▁a ▁[ ▁i ▁] ▁= ▁( ▁a ▁[ ▁i ▁] ▁== ▁'0' ▁) ▁? ▁'1' ▁: ▁'0' ▁; ▁} ▁step ▁++ ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁step ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁A ▁= ▁"1 0101 0" ▁, ▁B ▁= ▁"11 00 11" ▁; ▁find Minimum Operations ▁( ▁A ▁. ▁toCharArray ▁( ▁) ▁, ▁B ▁. ▁toCharArray ▁( ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁is Prime ▁( ▁int ▁num ▁) ▁{ ▁if ▁( ▁num ▁<= ▁1 ▁) ▁return ▁false ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁* ▁i ▁<= ▁num ▁; ▁i ▁++ ▁) ▁if ▁( ▁num ▁% ▁i ▁== ▁0 ▁) ▁return ▁false ▁; ▁return ▁true ▁; ▁} ▁static ▁boolean ▁isF ul Prime ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁! ▁is Prime ▁( ▁n ▁) ▁) ▁return ▁false ▁; ▁else ▁{ ▁while ▁( ▁n ▁> ▁0 ▁) ▁{ ▁int ▁rem ▁= ▁n ▁% ▁10 ▁; ▁if ▁( ▁! ▁( ▁rem ▁== ▁2 ▁rem ▁== ▁3 ▁rem ▁== ▁5 ▁rem ▁== ▁7 ▁) ▁) ▁return ▁false ▁; ▁n ▁= ▁n ▁/ ▁10 ▁; ▁} ▁} ▁return ▁true ▁; ▁} ▁static ▁int ▁count F ul Prime ▁( ▁int ▁L ▁, ▁int ▁R ▁) ▁{ ▁int ▁cnt ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁L ▁; ▁i ▁<= ▁R ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁i ▁% ▁2 ▁) ▁!= ▁0 ▁&& ▁isF ul Prime ▁( ▁i ▁) ▁) ▁{ ▁cnt ▁++ ▁; ▁} ▁} ▁return ▁cnt ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁L ▁= ▁1 ▁, ▁R ▁= ▁100 ▁; ▁int ▁ans ▁= ▁0 ▁; ▁if ▁( ▁L ▁< ▁3 ▁) ▁ans ▁++ ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁ans ▁+ ▁count F ul Prime ▁( ▁L ▁, ▁R ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁boolean ▁is _ prime ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁<= ▁1 ▁) ▁return ▁false ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁* ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁return ▁false ▁; ▁} ▁return ▁true ▁; ▁} ▁static ▁void ▁count Small er Pr imes ▁( ▁int ▁ar ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁ar ▁[ ▁j ▁] ▁<= ▁ar ▁[ ▁i ▁] ▁&& ▁is _ prime ▁( ▁ar ▁[ ▁j ▁] ▁) ▁) ▁{ ▁count ▁++ ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁count ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁ar ▁[ ▁] ▁= ▁{ ▁43 ▁, ▁3 ▁, ▁5 ▁, ▁7 ▁, ▁2 ▁, ▁41 ▁} ▁; ▁int ▁N ▁= ▁ar ▁. ▁length ▁; ▁count Small er Pr imes ▁( ▁ar ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁min Length ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁0 ▁] ▁!= ▁arr ▁[ ▁i ▁] ▁) ▁{ ▁return ▁1 ▁; ▁} ▁} ▁return ▁N ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁2 ▁, ▁1 ▁, ▁3 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁min Length ▁( ▁arr ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁num Special ▁( ▁int ▁[ ▁] ▁[ ▁] ▁mat ▁) ▁{ ▁int ▁m ▁= ▁mat ▁. ▁length ▁; ▁int ▁n ▁= ▁mat ▁[ ▁0 ▁] ▁. ▁length ▁; ▁int ▁[ ▁] ▁rows ▁= ▁new ▁int ▁[ ▁m ▁] ▁; ▁int ▁[ ▁] ▁cols ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁int ▁i ▁, ▁j ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁m ▁; ▁i ▁++ ▁) ▁{ ▁rows ▁[ ▁i ▁] ▁= ▁0 ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁rows ▁[ ▁i ▁] ▁+= ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁cols ▁[ ▁i ▁] ▁= ▁0 ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁m ▁; ▁j ▁++ ▁) ▁cols ▁[ ▁i ▁] ▁+= ▁mat ▁[ ▁j ▁] ▁[ ▁i ▁] ▁; ▁} ▁int ▁cnt ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁m ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁== ▁1 ▁&& ▁rows ▁[ ▁i ▁] ▁== ▁1 ▁&& ▁cols ▁[ ▁j ▁] ▁== ▁1 ▁) ▁cnt ▁++ ▁; ▁} ▁} ▁return ▁cnt ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁[ ▁] ▁mat ▁= ▁{ ▁{ ▁1 ▁, ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁0 ▁, ▁0 ▁, ▁1 ▁} ▁, ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁} ▁} ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁num Special ▁( ▁mat ▁) ▁+ ▁" NEW _ LINE "); ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁Vector ▁< ▁Integer ▁> ▁min max Numbers ▁( ▁int ▁[ ▁] ▁[ ▁] ▁matrix ▁, ▁Vector ▁< ▁Integer ▁> ▁res ▁) ▁{ ▁Set ▁< ▁Integer ▁> ▁set ▁= ▁new ▁HashSet ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁matrix ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁int ▁min r ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁matrix ▁[ ▁i ▁] ▁. ▁length ▁; ▁j ▁++ ▁) ▁{ ▁min r ▁= ▁Math ▁. ▁min ▁( ▁min r ▁, ▁matrix ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁; ▁} ▁set ▁. ▁add ▁( ▁min r ▁) ▁; ▁} ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁matrix ▁[ ▁0 ▁] ▁. ▁length ▁; ▁j ▁++ ▁) ▁{ ▁int ▁max c ▁= ▁Integer ▁. ▁MIN _ VALUE ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁matrix ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁max c ▁= ▁Math ▁. ▁max ▁( ▁max c ▁, ▁matrix ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁; ▁} ▁if ▁( ▁set ▁. ▁contains ▁( ▁max c ▁) ▁) ▁{ ▁res ▁. ▁add ▁( ▁max c ▁) ▁; ▁} ▁} ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁[ ▁] ▁mat ▁= ▁{ ▁{ ▁1 ▁, ▁10 ▁, ▁4 ▁} ▁, ▁{ ▁9 ▁, ▁3 ▁, ▁8 ▁} ▁, ▁{ ▁15 ▁, ▁16 ▁, ▁17 ▁} ▁} ▁; ▁Vector ▁< ▁Integer ▁> ▁ans ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁ans ▁= ▁min max Numbers ▁( ▁mat ▁, ▁ans ▁) ▁; ▁if ▁( ▁ans ▁. ▁size ▁( ▁) ▁== ▁0 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁- ▁1" ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁ans ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁ans ▁. ▁get ▁( ▁i ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁count Prec ed ing K ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁K ▁) ▁{ ▁int ▁[ ▁] ▁prefix ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁prefix ▁[ ▁0 ▁] ▁= ▁a ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁prefix ▁[ ▁i ▁] ▁= ▁prefix ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁a ▁[ ▁i ▁] ▁; ▁} ▁int ▁ctr ▁= ▁0 ▁; ▁if ▁( ▁prefix ▁[ ▁K ▁- ▁1 ▁] ▁< ▁a ▁[ ▁K ▁] ▁) ▁ctr ▁++ ▁; ▁for ▁( ▁int ▁i ▁= ▁K ▁+ ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁prefix ▁[ ▁i ▁- ▁1 ▁] ▁- ▁prefix ▁[ ▁i ▁- ▁K ▁- ▁1 ▁] ▁< ▁a ▁[ ▁i ▁] ▁) ▁ctr ▁++ ▁; ▁} ▁return ▁ctr ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁8 ▁, ▁10 ▁, ▁- ▁2 ▁, ▁7 ▁, ▁5 ▁, ▁5 ▁, ▁9 ▁, ▁15 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁int ▁K ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁count Prec ed ing K ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁final ▁int ▁M ▁= ▁1000 ▁; ▁static ▁int ▁count Num ▁( ▁int ▁N ▁, ▁int ▁sum ▁, ▁int ▁K ▁, ▁int ▁st ▁, ▁int ▁dp ▁[ ▁] ▁[ ▁] ▁[ ▁] ▁) ▁{ ▁if ▁( ▁N ▁== ▁0 ▁&& ▁sum ▁== ▁0 ▁) ▁{ ▁return ▁1 ▁; ▁} ▁if ▁( ▁N ▁< ▁0 ▁) ▁{ ▁return ▁0 ▁; ▁} ▁if ▁( ▁dp ▁[ ▁N ▁] ▁[ ▁sum ▁] ▁[ ▁st ▁] ▁!= ▁- ▁1 ▁) ▁{ ▁return ▁dp ▁[ ▁N ▁] ▁[ ▁sum ▁] ▁[ ▁st ▁] ▁; ▁} ▁int ▁res ▁= ▁0 ▁; ▁int ▁start ▁= ▁st ▁== ▁1 ▁? ▁0 ▁: ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁start ▁; ▁i ▁<= ▁9 ▁; ▁i ▁++ ▁) ▁{ ▁res ▁+= ▁count Num ▁( ▁N ▁- ▁1 ▁, ▁( ▁sum ▁+ ▁i ▁) ▁% ▁K ▁, ▁K ▁, ▁( ▁( ▁st ▁i ▁) ▁> ▁0 ▁) ▁? ▁1 ▁: ▁0 ▁, ▁dp ▁) ▁; ▁} ▁return ▁dp ▁[ ▁N ▁] ▁[ ▁sum ▁] ▁[ ▁st ▁] ▁= ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁2 ▁, ▁K ▁= ▁7 ▁; ▁int ▁[ ▁] ▁[ ▁] ▁[ ▁] ▁dp ▁= ▁new ▁int ▁[ ▁M ▁] ▁[ ▁M ▁] ▁[ ▁2 ▁] ▁; ▁for ▁( ▁int ▁[ ▁] ▁[ ▁] ▁i ▁: ▁dp ▁) ▁for ▁( ▁int ▁[ ▁] ▁j ▁: ▁i ▁) ▁Arrays ▁. ▁fill ▁( ▁j ▁, ▁- ▁1 ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁count Num ▁( ▁N ▁, ▁0 ▁, ▁K ▁, ▁0 ▁, ▁dp ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁min Deletion ▁( ▁String ▁str ▁) ▁{ ▁int ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁int ▁first Idx 1 ▁= ▁- ▁1 ▁; ▁int ▁last Idx 0 ▁= ▁- ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'1' ▁) ▁{ ▁first Idx 1 ▁= ▁i ▁; ▁break ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'0' ▁) ▁{ ▁last Idx 0 ▁= ▁i ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁first Idx 1 ▁== ▁- ▁1 ▁last Idx 0 ▁== ▁- ▁1 ▁) ▁return ▁0 ▁; ▁int ▁count 1 ▁= ▁0 ▁, ▁count 0 ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁last Idx 0 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'1' ▁) ▁{ ▁count 1 ▁++ ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁first Idx 1 ▁+ ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'1' ▁) ▁{ ▁count 0 ▁++ ▁; ▁} ▁} ▁return ▁Math ▁. ▁min ▁( ▁count 0 ▁, ▁count 1 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁"100 01 01" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁min Deletion ▁( ▁str ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁void ▁print _ substring ▁( ▁String ▁s ▁) ▁{ ▁int ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁String ▁str ▁= ▁" ▁" ▁; ▁Vector ▁< ▁Integer ▁> ▁ans ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁if ▁( ▁n ▁== ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁- ▁1" ▁) ▁; ▁return ▁; ▁} ▁int ▁[ ▁] ▁last _ pos ▁= ▁new ▁int ▁[ ▁26 ▁] ▁; ▁Arrays ▁. ▁fill ▁( ▁last _ pos ▁, ▁- ▁1 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁-- ▁i ▁) ▁{ ▁if ▁( ▁last _ pos ▁[ ▁s ▁. ▁charAt ▁( ▁i ▁) ▁- ▁' ▁a ▁' ▁] ▁== ▁- ▁1 ▁) ▁{ ▁last _ pos ▁[ ▁s ▁. ▁charAt ▁( ▁i ▁) ▁- ▁' ▁a ▁' ▁] ▁= ▁i ▁; ▁} ▁} ▁int ▁min p ▁= ▁- ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁{ ▁int ▁lp ▁= ▁last _ pos ▁[ ▁s ▁. ▁charAt ▁( ▁i ▁) ▁- ▁' ▁a ▁' ▁] ▁; ▁min p ▁= ▁Math ▁. ▁max ▁( ▁min p ▁, ▁lp ▁) ▁; ▁if ▁( ▁i ▁== ▁min p ▁) ▁{ ▁str ▁+= ▁s ▁. ▁charAt ▁( ▁i ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁str ▁+ ▁' ▁' ▁) ▁; ▁min p ▁= ▁- ▁1 ▁; ▁str ▁= ▁" ▁" ▁; ▁} ▁else ▁{ ▁str ▁+= ▁s ▁. ▁charAt ▁( ▁i ▁) ▁; ▁} ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁S ▁= ▁" ▁ab ab cb ac ad ef eg de hi jh k li j ▁" ▁; ▁print _ substring ▁( ▁S ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁partition String ▁( ▁String ▁s ▁) ▁{ ▁int ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁Vector ▁< ▁Integer ▁> ▁ans ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁if ▁( ▁n ▁== ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁- ▁1" ▁) ▁; ▁return ▁; ▁} ▁int ▁[ ▁] ▁last _ pos ▁= ▁new ▁int ▁[ ▁26 ▁] ▁; ▁Arrays ▁. ▁fill ▁( ▁last _ pos ▁, ▁- ▁1 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁-- ▁i ▁) ▁{ ▁if ▁( ▁last _ pos ▁[ ▁s ▁. ▁charAt ▁( ▁i ▁) ▁- ▁' ▁a ▁' ▁] ▁== ▁- ▁1 ▁) ▁{ ▁last _ pos ▁[ ▁s ▁. ▁charAt ▁( ▁i ▁) ▁- ▁' ▁a ▁' ▁] ▁= ▁i ▁; ▁} ▁} ▁int ▁min p ▁= ▁- ▁1 ▁, ▁pl en ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁{ ▁int ▁lp ▁= ▁last _ pos ▁[ ▁s ▁. ▁charAt ▁( ▁i ▁) ▁- ▁' ▁a ▁' ▁] ▁; ▁min p ▁= ▁Math ▁. ▁max ▁( ▁min p ▁, ▁lp ▁) ▁; ▁++ ▁pl en ▁; ▁if ▁( ▁i ▁== ▁min p ▁) ▁{ ▁ans ▁. ▁add ▁( ▁pl en ▁) ▁; ▁min p ▁= ▁- ▁1 ▁; ▁pl en ▁= ▁0 ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁( ▁int ▁) ▁ans ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁ans ▁. ▁get ▁( ▁i ▁) ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁" ▁ac bb cc ▁" ▁; ▁partition String ▁( ▁str ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁check ▁( ▁String ▁s ▁, ▁int ▁k ▁) ▁{ ▁int ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁k ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁< ▁n ▁; ▁j ▁+= ▁k ▁) ▁{ ▁if ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁!= ▁s ▁. ▁charAt ▁( ▁j ▁) ▁) ▁return ▁false ▁; ▁} ▁} ▁int ▁c ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁k ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'0' ▁) ▁c ▁++ ▁; ▁else ▁c ▁-- ▁; ▁} ▁if ▁( ▁c ▁== ▁0 ▁) ▁return ▁true ▁; ▁else ▁return ▁false ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁s ▁= ▁"1 0101 0" ▁; ▁int ▁k ▁= ▁2 ▁; ▁if ▁( ▁check ▁( ▁s ▁, ▁k ▁) ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Yes ▁" ▁+ ▁" NEW _ LINE "); ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁No ▁" ▁+ ▁" NEW _ LINE "); ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁max G CD ▁( ▁int ▁n ▁) ▁{ ▁int ▁max H cf ▁= ▁Integer ▁. ▁MIN _ VALUE ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁<= ▁n ▁; ▁j ▁++ ▁) ▁{ ▁max H cf ▁= ▁Math ▁. ▁max ▁( ▁max H cf ▁, ▁__ g cd ▁( ▁i ▁, ▁j ▁) ▁) ▁; ▁} ▁} ▁return ▁max H cf ▁; ▁} ▁static ▁int ▁__ g cd ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁return ▁b ▁== ▁0 ▁? ▁a ▁: ▁__ g cd ▁( ▁b ▁, ▁a ▁% ▁b ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁4 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁max G CD ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁final ▁double ▁eps ▁= ▁1 e -6 ▁; ▁static ▁double ▁func ▁( ▁double ▁a ▁, ▁double ▁b ▁, ▁double ▁c ▁, ▁double ▁x ▁) ▁{ ▁return ▁a ▁* ▁x ▁* ▁x ▁+ ▁b ▁* ▁x ▁+ ▁c ▁; ▁} ▁static ▁double ▁find Root ▁( ▁double ▁a ▁, ▁double ▁b ▁, ▁double ▁c ▁, ▁double ▁low ▁, ▁double ▁high ▁) ▁{ ▁double ▁x ▁= ▁- ▁1 ▁; ▁while ▁( ▁Math ▁. ▁abs ▁( ▁high ▁- ▁low ▁) ▁> ▁eps ▁) ▁{ ▁x ▁= ▁( ▁low ▁+ ▁high ▁) ▁/ ▁2 ▁; ▁if ▁( ▁func ▁( ▁a ▁, ▁b ▁, ▁c ▁, ▁low ▁) ▁* ▁func ▁( ▁a ▁, ▁b ▁, ▁c ▁, ▁x ▁) ▁<= ▁0 ▁) ▁{ ▁high ▁= ▁x ▁; ▁} ▁else ▁{ ▁low ▁= ▁x ▁; ▁} ▁} ▁return ▁x ▁; ▁} ▁static ▁void ▁solve ▁( ▁double ▁a ▁, ▁double ▁b ▁, ▁double ▁c ▁, ▁double ▁A ▁, ▁double ▁B ▁) ▁{ ▁if ▁( ▁func ▁( ▁a ▁, ▁b ▁, ▁c ▁, ▁A ▁) ▁* ▁func ▁( ▁a ▁, ▁b ▁, ▁c ▁, ▁B ▁) ▁> ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁solution ▁" ▁) ▁; ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁format ▁( ▁" ▁% ▁.4 f ▁" ▁, ▁find Root ▁( ▁a ▁, ▁b ▁, ▁c ▁, ▁A ▁, ▁B ▁) ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁double ▁a ▁= ▁2 ▁, ▁b ▁= ▁- ▁3 ▁, ▁c ▁= ▁- ▁2 ▁, ▁A ▁= ▁0 ▁, ▁B ▁= ▁3 ▁; ▁solve ▁( ▁a ▁, ▁b ▁, ▁c ▁, ▁A ▁, ▁B ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁[ ▁] ▁find Sub arrays ▁( ▁int ▁[ ▁] ▁a ▁) ▁{ ▁int ▁n ▁= ▁a ▁. ▁length ▁; ▁int ▁[ ▁] ▁freq ▁= ▁new ▁int ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁if ▁( ▁count ▁== ▁0 ▁) ▁continue ▁; ▁else ▁{ ▁int ▁value ▁= ▁count ▁; ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁<= ▁count ▁; ▁j ▁++ ▁) ▁{ ▁freq ▁[ ▁j ▁] ▁+= ▁value ▁; ▁value ▁-- ▁; ▁} ▁count ▁= ▁0 ▁; ▁} ▁} ▁else ▁count ▁++ ▁; ▁} ▁if ▁( ▁count ▁> ▁0 ▁) ▁{ ▁int ▁value ▁= ▁count ▁; ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁<= ▁count ▁; ▁j ▁++ ▁) ▁{ ▁freq ▁[ ▁j ▁] ▁+= ▁value ▁; ▁value ▁-- ▁; ▁} ▁} ▁return ▁freq ▁; ▁} ▁static ▁void ▁count Rect angles ▁( ▁int ▁[ ▁] ▁a ▁, ▁int ▁[ ▁] ▁b ▁, ▁int ▁K ▁) ▁{ ▁int ▁n ▁= ▁a ▁. ▁length ▁; ▁int ▁m ▁= ▁b ▁. ▁length ▁; ▁int ▁[ ▁] ▁sub A ▁= ▁find Sub arrays ▁( ▁a ▁) ▁; ▁int ▁[ ▁] ▁sub B ▁= ▁find Sub arrays ▁( ▁b ▁) ▁; ▁int ▁total ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁sub A ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁K ▁% ▁i ▁== ▁0 ▁&& ▁( ▁K ▁/ ▁i ▁) ▁<= ▁m ▁) ▁{ ▁total ▁= ▁total ▁+ ▁sub A ▁[ ▁i ▁] ▁* ▁sub B ▁[ ▁K ▁/ ▁i ▁] ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁total ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁a ▁= ▁{ ▁0 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁} ▁; ▁int ▁[ ▁] ▁b ▁= ▁{ ▁1 ▁, ▁0 ▁, ▁1 ▁} ▁; ▁int ▁K ▁= ▁2 ▁; ▁count Rect angles ▁( ▁a ▁, ▁b ▁, ▁K ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁print Res ▁( ▁Vector ▁< ▁Integer ▁> ▁res ▁) ▁{ ▁Enumeration ▁en u ▁= ▁res ▁. ▁elements ▁( ▁) ▁; ▁while ▁( ▁en u ▁. ▁hasMoreElements ▁( ▁) ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁en u ▁. ▁nextElement ▁( ▁) ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁static ▁void ▁print LB S ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁lis ▁[ ▁] ▁= ▁new ▁int ▁[ ▁N ▁] ▁; ▁int ▁l ds ▁[ ▁] ▁= ▁new ▁int ▁[ ▁N ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁lis ▁[ ▁i ▁] ▁= ▁l ds ▁[ ▁i ▁] ▁= ▁1 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁i ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁j ▁] ▁< ▁arr ▁[ ▁i ▁] ▁) ▁{ ▁if ▁( ▁lis ▁[ ▁i ▁] ▁< ▁lis ▁[ ▁j ▁] ▁+ ▁1 ▁) ▁lis ▁[ ▁i ▁] ▁= ▁lis ▁[ ▁j ▁] ▁+ ▁1 ▁; ▁} ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁N ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁N ▁- ▁1 ▁; ▁j ▁> ▁i ▁; ▁j ▁-- ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁j ▁] ▁< ▁arr ▁[ ▁i ▁] ▁) ▁{ ▁if ▁( ▁l ds ▁[ ▁i ▁] ▁< ▁l ds ▁[ ▁j ▁] ▁+ ▁1 ▁) ▁l ds ▁[ ▁i ▁] ▁= ▁l ds ▁[ ▁j ▁] ▁+ ▁1 ▁; ▁} ▁} ▁} ▁int ▁Max Val ▁= ▁arr ▁[ ▁0 ▁] ▁, ▁in x ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁Max Val ▁< ▁lis ▁[ ▁i ▁] ▁+ ▁l ds ▁[ ▁i ▁] ▁- ▁1 ▁) ▁{ ▁Max Val ▁= ▁lis ▁[ ▁i ▁] ▁+ ▁l ds ▁[ ▁i ▁] ▁- ▁1 ▁; ▁in x ▁= ▁i ▁; ▁} ▁} ▁int ▁ct 1 ▁= ▁lis ▁[ ▁in x ▁] ▁; ▁Vector ▁< ▁Integer ▁> ▁res ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁in x ▁; ▁i ▁>= ▁0 ▁&& ▁ct 1 ▁> ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁(
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁solve ▁( ▁int ▁n ▁, ▁int ▁arr ▁[ ▁] ▁) ▁{ ▁int ▁i ▁, ▁ans ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁left ▁= ▁Math ▁. ▁max ▁( ▁i ▁- ▁1 ▁, ▁0 ▁) ▁; ▁int ▁right ▁= ▁Math ▁. ▁min ▁( ▁n ▁- ▁1 ▁, ▁i ▁+ ▁1 ▁) ▁; ▁while ▁( ▁left ▁>= ▁0 ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁left ▁] ▁> ▁arr ▁[ ▁i ▁] ▁) ▁{ ▁left ▁++ ▁; ▁break ▁; ▁} ▁left ▁-- ▁; ▁} ▁if ▁( ▁left ▁< ▁0 ▁) ▁left ▁++ ▁; ▁while ▁( ▁right ▁< ▁n ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁right ▁] ▁> ▁arr ▁[ ▁i ▁] ▁) ▁{ ▁right ▁-- ▁; ▁break ▁; ▁} ▁right ▁++ ▁; ▁} ▁if ▁( ▁right ▁>= ▁n ▁) ▁right ▁-- ▁; ▁ans ▁= ▁1 ▁+ ▁right ▁- ▁left ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁ans ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁2 ▁, ▁1 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁solve ▁( ▁n ▁, ▁arr ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁getSum ▁( ▁int ▁BIT ree ▁[ ▁] ▁, ▁int ▁index ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁index ▁+= ▁1 ▁; ▁while ▁( ▁index ▁> ▁0 ▁) ▁{ ▁ans ▁+= ▁BIT ree ▁[ ▁index ▁] ▁; ▁index ▁-= ▁index ▁& ▁( ▁- ▁index ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁static ▁void ▁update BIT ▁( ▁int ▁BIT ree ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁index ▁, ▁int ▁val ▁) ▁{ ▁index ▁= ▁index ▁+ ▁1 ▁; ▁while ▁( ▁index ▁<= ▁n ▁) ▁{ ▁BIT ree ▁[ ▁index ▁] ▁+= ▁val ▁; ▁index ▁+= ▁index ▁& ▁( ▁- ▁index ▁) ▁; ▁} ▁} ▁static ▁int ▁[ ▁] ▁construct BIT ree ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁[ ▁] ▁BIT ree ▁= ▁new ▁int ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁BIT ree ▁[ ▁i ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁update BIT ▁( ▁BIT ree ▁, ▁n ▁, ▁i ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁return ▁BIT ree ▁; ▁} ▁static ▁int ▁getL ower Bound ▁( ▁int ▁BIT ree ▁[ ▁] ▁, ▁int ▁[ ▁] ▁arr ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁lb ▁= ▁- ▁1 ▁; ▁int ▁l ▁= ▁0 ▁, ▁r ▁= ▁n ▁- ▁1 ▁; ▁while ▁( ▁l ▁<= ▁r ▁) ▁{ ▁int ▁mid ▁= ▁l ▁+ ▁( ▁r ▁- ▁l ▁) ▁/ ▁2 ▁; ▁if ▁( ▁getSum ▁( ▁BIT ree ▁, ▁mid ▁) ▁>= ▁k ▁) ▁{ ▁r ▁= ▁mid ▁- ▁1 ▁; ▁lb ▁= ▁mid ▁; ▁} ▁else ▁l ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁return ▁lb ▁; ▁} ▁static ▁void ▁perform Queries ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁q ▁[ ▁] ▁[ ▁] ▁) ▁{ ▁int ▁[ ▁] ▁BIT ree ▁= ▁construct BIT ree ▁( ▁A ▁, ▁n ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁q ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁int ▁id ▁= ▁q ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁; ▁if ▁( ▁id ▁== ▁1 ▁) ▁{ ▁int ▁idx ▁= ▁q ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁; ▁int ▁val ▁= ▁q ▁[ ▁i ▁] ▁[ ▁2
▁class ▁G F G ▁{ ▁static ▁boolean ▁Contin uous Elements ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁1 ▁) ▁return ▁false ▁; ▁int ▁curr ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁!= ▁a ▁[ ▁i ▁- ▁1 ▁] ▁) ▁{ ▁if ▁( ▁curr ▁== ▁1 ▁) ▁return ▁false ▁; ▁else ▁curr ▁= ▁0 ▁; ▁} ▁curr ▁++ ▁; ▁} ▁if ▁( ▁curr ▁== ▁1 ▁) ▁return ▁false ▁; ▁return ▁true ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁1 ▁, ▁2 ▁, ▁2 ▁, ▁1 ▁, ▁3 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁a ▁. ▁length ▁; ▁if ▁( ▁Contin uous Elements ▁( ▁a ▁, ▁n ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁maximum Count ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁B ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁Queue ▁< ▁Integer ▁> ▁q ▁= ▁new ▁LinkedList ▁< ▁> ▁( ▁) ▁; ▁HashSet ▁< ▁Integer ▁> ▁s ▁= ▁new ▁HashSet ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁s ▁. ▁add ▁( ▁B ▁[ ▁i ▁] ▁) ▁; ▁q ▁. ▁add ▁( ▁B ▁[ ▁i ▁] ▁) ▁; ▁} ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁! ▁s ▁. ▁contains ▁( ▁A ▁[ ▁i ▁] ▁) ▁) ▁continue ▁; ▁while ▁( ▁! ▁q ▁. ▁isEmpty ▁( ▁) ▁&& ▁q ▁. ▁peek ▁( ▁) ▁!= ▁A ▁[ ▁i ▁] ▁) ▁{ ▁s ▁. ▁remove ▁( ▁q ▁. ▁peek ▁( ▁) ▁) ▁; ▁q ▁. ▁remove ▁( ▁) ▁; ▁count ▁++ ▁; ▁} ▁if ▁( ▁A ▁[ ▁i ▁] ▁== ▁q ▁. ▁peek ▁( ▁) ▁) ▁{ ▁q ▁. ▁remove ▁( ▁) ▁; ▁s ▁. ▁remove ▁( ▁A ▁[ ▁i ▁] ▁) ▁; ▁} ▁if ▁( ▁q ▁. ▁isEmpty ▁( ▁) ▁) ▁break ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁count ▁+ ▁" NEW _ LINE "); ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁4 ▁; ▁int ▁A ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁B ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁4 ▁, ▁3 ▁} ▁; ▁maximum Count ▁( ▁A ▁, ▁B ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁count _ elements ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁count ▁= ▁1 ▁; ▁int ▁max ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁max ▁) ▁{ ▁count ▁+= ▁1 ▁; ▁max ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁} ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁s ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁1 ▁, ▁4 ▁, ▁6 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁count _ elements ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁int ▁find Subset ▁( ▁int ▁[ ▁] ▁a ▁, ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁int ▁cnt ▁= ▁0 ▁; ▁Vector ▁< ▁Integer ▁> ▁v ▁= ▁new ▁Vector ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁- ▁1 ▁] ▁- ▁i ▁<= ▁0 ▁) ▁{ ▁sum ▁+= ▁a ▁[ ▁i ▁- ▁1 ▁] ▁- ▁i ▁; ▁cnt ▁+= ▁1 ▁; ▁} ▁else ▁{ ▁v ▁. ▁add ▁( ▁a ▁[ ▁i ▁- ▁1 ▁] ▁- ▁i ▁) ▁; ▁} ▁} ▁Collections ▁. ▁sort ▁( ▁v ▁) ▁; ▁int ▁ptr ▁= ▁0 ▁; ▁while ▁( ▁ptr ▁< ▁v ▁. ▁size ▁( ▁) ▁&& ▁sum ▁+ ▁v ▁. ▁get ▁( ▁ptr ▁) ▁<= ▁0 ▁) ▁{ ▁cnt ▁+= ▁1 ▁; ▁ptr ▁+= ▁1 ▁; ▁sum ▁+= ▁v ▁. ▁get ▁( ▁ptr ▁) ▁; ▁} ▁return ▁cnt ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁1 ▁, ▁6 ▁, ▁7 ▁, ▁8 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Subset ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁check Array ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁B ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁start ▁= ▁0 ▁; ▁int ▁end ▁= ▁N ▁- ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁A ▁[ ▁i ▁] ▁!= ▁B ▁[ ▁i ▁] ▁) ▁{ ▁start ▁= ▁i ▁; ▁break ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁N ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁A ▁[ ▁i ▁] ▁!= ▁B ▁[ ▁i ▁] ▁) ▁{ ▁end ▁= ▁i ▁; ▁break ▁; ▁} ▁} ▁Collections ▁. ▁reverse ▁( ▁Arrays ▁. ▁asList ▁( ▁A ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁A ▁[ ▁i ▁] ▁!= ▁B ▁[ ▁i ▁] ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁return ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁2 ▁, ▁4 ▁} ▁; ▁int ▁B ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁N ▁= ▁A ▁. ▁length ▁; ▁check Array ▁( ▁A ▁, ▁B ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁get _ subset _ count ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁K ▁, ▁int ▁N ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁arr ▁) ▁; ▁int ▁left ▁, ▁right ▁; ▁left ▁= ▁0 ▁; ▁right ▁= ▁N ▁- ▁1 ▁; ▁int ▁ans ▁= ▁0 ▁; ▁while ▁( ▁left ▁<= ▁right ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁left ▁] ▁+ ▁arr ▁[ ▁right ▁] ▁< ▁K ▁) ▁{ ▁ans ▁+= ▁1 ▁<< ▁( ▁right ▁- ▁left ▁) ▁; ▁left ▁++ ▁; ▁} ▁else ▁{ ▁right ▁-- ▁; ▁} ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁4 ▁, ▁5 ▁, ▁7 ▁} ▁; ▁int ▁K ▁= ▁8 ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁get _ subset _ count ▁( ▁arr ▁, ▁K ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁binary _ search ed _ find _ x ▁( ▁int ▁k ▁) ▁{ ▁int ▁l ▁= ▁0 ▁; ▁int ▁r ▁= ▁k ▁; ▁int ▁ans ▁= ▁0 ▁; ▁while ▁( ▁l ▁<= ▁r ▁) ▁{ ▁int ▁mid ▁= ▁l ▁+ ▁( ▁r ▁- ▁l ▁) ▁/ ▁2 ▁; ▁if ▁( ▁Math ▁. ▁pow ▁( ▁( ▁( ▁mid ▁* ▁( ▁mid ▁+ ▁1 ▁) ▁) ▁/ ▁2 ▁) ▁, ▁2 ▁) ▁>= ▁k ▁) ▁{ ▁ans ▁= ▁mid ▁; ▁r ▁= ▁mid ▁- ▁1 ▁; ▁} ▁else ▁{ ▁l ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁100 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁binary _ search ed _ find _ x ▁( ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁len Of Long Z ig Z ag Arr ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁max ▁= ▁1 ▁, ▁len ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁% ▁2 ▁== ▁0 ▁&& ▁( ▁a ▁[ ▁i ▁] ▁< ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁) ▁len ▁++ ▁; ▁else ▁if ▁( ▁i ▁% ▁2 ▁== ▁1 ▁&& ▁( ▁a ▁[ ▁i ▁] ▁> ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁) ▁len ▁++ ▁; ▁else ▁{ ▁if ▁( ▁max ▁< ▁len ▁) ▁max ▁= ▁len ▁; ▁len ▁= ▁1 ▁; ▁} ▁} ▁if ▁( ▁max ▁< ▁len ▁) ▁max ▁= ▁len ▁; ▁return ▁max ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁len Of Long Z ig Z ag Arr ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁check Perf ect Square ▁( ▁long ▁N ▁, ▁long ▁start ▁, ▁long ▁last ▁) ▁{ ▁long ▁mid ▁= ▁( ▁start ▁+ ▁last ▁) ▁/ ▁2 ▁; ▁if ▁( ▁start ▁> ▁last ▁) ▁{ ▁return ▁- ▁1 ▁; ▁} ▁if ▁( ▁mid ▁* ▁mid ▁== ▁N ▁) ▁{ ▁return ▁( ▁int ▁) ▁mid ▁; ▁} ▁else ▁if ▁( ▁mid ▁* ▁mid ▁> ▁N ▁) ▁{ ▁return ▁check Perf ect Square ▁( ▁N ▁, ▁start ▁, ▁mid ▁- ▁1 ▁) ▁; ▁} ▁else ▁{ ▁return ▁check Perf ect Square ▁( ▁N ▁, ▁mid ▁+ ▁1 ▁, ▁last ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁long ▁N ▁= ▁65 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁check Perf ect Square ▁( ▁N ▁, ▁1 ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁find Sub Array ▁( ▁int ▁[ ▁] ▁a ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁[ ▁] ▁pref ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁pref ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁++ ▁i ▁) ▁{ ▁pref ▁[ ▁i ▁] ▁= ▁pref ▁[ ▁i ▁- ▁1 ▁] ▁; ▁if ▁( ▁a ▁[ ▁i ▁] ▁> ▁a ▁[ ▁i ▁- ▁1 ▁] ▁&& ▁a ▁[ ▁i ▁] ▁> ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁pref ▁[ ▁i ▁] ▁++ ▁; ▁} ▁int ▁peak ▁= ▁0 ▁, ▁left ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁+ ▁k ▁- ▁1 ▁< ▁n ▁; ▁++ ▁i ▁) ▁if ▁( ▁pref ▁[ ▁i ▁+ ▁k ▁- ▁2 ▁] ▁- ▁pref ▁[ ▁i ▁] ▁> ▁peak ▁) ▁{ ▁peak ▁= ▁pref ▁[ ▁i ▁+ ▁k ▁- ▁2 ▁] ▁- ▁pref ▁[ ▁i ▁] ▁; ▁left ▁= ▁i ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Left ▁= ▁" ▁+ ▁( ▁left ▁+ ▁1 ▁) ▁+ ▁" NEW _ LINE "); ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Right ▁= ▁" ▁+ ▁( ▁left ▁+ ▁k ▁) ▁+ ▁" NEW _ LINE "); ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁P eak ▁= ▁" ▁+ ▁peak ▁+ ▁" NEW _ LINE "); ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁2 ▁, ▁3 ▁, ▁2 ▁, ▁1 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁int ▁k ▁= ▁3 ▁; ▁find Sub Array ▁( ▁arr ▁, ▁n ▁, ▁k ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁Find Rank ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁length ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁"1" ▁+ ▁" ▁" ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁arr ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁int ▁rank ▁= ▁1 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁i ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁j ▁] ▁> ▁arr ▁[ ▁i ▁] ▁) ▁rank ▁++ ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁rank ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁88 ▁, ▁14 ▁, ▁69 ▁, ▁30 ▁, ▁29 ▁, ▁89 ▁} ▁; ▁int ▁len ▁= ▁arr ▁. ▁length ▁; ▁Find Rank ▁( ▁arr ▁, ▁len ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁MAX ▁= ▁100000 5 ▁; ▁static ▁int ▁[ ▁] ▁fib U pto ▁= ▁new ▁int ▁[ ▁MAX ▁+ ▁1 ▁] ▁; ▁static ▁void ▁compute ▁( ▁int ▁sz ▁) ▁{ ▁boolean ▁[ ▁] ▁isF ib ▁= ▁new ▁boolean ▁[ ▁sz ▁+ ▁1 ▁] ▁; ▁int ▁prev ▁= ▁0 ▁, ▁curr ▁= ▁1 ▁; ▁isF ib ▁[ ▁prev ▁] ▁= ▁isF ib ▁[ ▁curr ▁] ▁= ▁true ▁; ▁while ▁( ▁curr ▁<= ▁sz ▁) ▁{ ▁int ▁temp ▁= ▁curr ▁+ ▁prev ▁; ▁if ▁( ▁temp ▁<= ▁sz ▁) ▁isF ib ▁[ ▁temp ▁] ▁= ▁true ▁; ▁prev ▁= ▁curr ▁; ▁curr ▁= ▁temp ▁; ▁} ▁fib U pto ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁sz ▁; ▁i ▁++ ▁) ▁{ ▁fib U pto ▁[ ▁i ▁] ▁= ▁fib U pto ▁[ ▁i ▁- ▁1 ▁] ▁; ▁if ▁( ▁isF ib ▁[ ▁i ▁] ▁) ▁fib U pto ▁[ ▁i ▁] ▁++ ▁; ▁} ▁} ▁static ▁int ▁count Of Numbers ▁( ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁compute ▁( ▁N ▁) ▁; ▁int ▁low ▁= ▁1 ▁, ▁high ▁= ▁N ▁, ▁ans ▁= ▁0 ▁; ▁while ▁( ▁low ▁<= ▁high ▁) ▁{ ▁int ▁mid ▁= ▁( ▁low ▁+ ▁high ▁) ▁>> ▁1 ▁; ▁if ▁( ▁mid ▁- ▁fib U pto ▁[ ▁mid ▁] ▁>= ▁K ▁) ▁{ ▁ans ▁= ▁mid ▁; ▁high ▁= ▁mid ▁- ▁1 ▁; ▁} ▁else ▁low ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁return ▁( ▁ans ▁> ▁0 ▁? ▁N ▁- ▁ans ▁+ ▁1 ▁: ▁0 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁10 ▁, ▁K ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁count Of Numbers ▁( ▁N ▁, ▁K ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁MAX ▁= ▁26 ▁; ▁static ▁Vector ▁< ▁Integer ▁> ▁find Count ▁( ▁String ▁a ▁[ ▁] ▁, ▁String ▁b ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁int ▁[ ▁] ▁freq ▁= ▁new ▁int ▁[ ▁MAX ▁] ▁; ▁Vector ▁< ▁Integer ▁> ▁smallest Freq ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁String ▁s ▁= ▁a ▁[ ▁i ▁] ▁; ▁Arrays ▁. ▁fill ▁( ▁freq ▁, ▁0 ▁) ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁s ▁. ▁length ▁( ▁) ▁; ▁j ▁++ ▁) ▁{ ▁freq ▁[ ▁s ▁. ▁charAt ▁( ▁j ▁) ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁} ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁MAX ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁freq ▁[ ▁j ▁] ▁> ▁0 ▁) ▁{ ▁smallest Freq ▁. ▁add ▁( ▁freq ▁[ ▁j ▁] ▁) ▁; ▁break ▁; ▁} ▁} ▁} ▁Collections ▁. ▁sort ▁( ▁smallest Freq ▁) ▁; ▁Vector ▁< ▁Integer ▁> ▁ans ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁m ▁; ▁i ▁++ ▁) ▁{ ▁String ▁s ▁= ▁b ▁[ ▁i ▁] ▁; ▁Arrays ▁. ▁fill ▁( ▁freq ▁, ▁0 ▁) ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁s ▁. ▁length ▁( ▁) ▁; ▁j ▁++ ▁) ▁{ ▁freq ▁[ ▁s ▁. ▁charAt ▁( ▁j ▁) ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁} ▁int ▁frequency ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁MAX ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁freq ▁[ ▁j ▁] ▁> ▁0 ▁) ▁{ ▁frequency ▁= ▁freq ▁[ ▁j ▁] ▁; ▁break ▁; ▁} ▁} ▁int ▁[ ▁] ▁array ▁= ▁new ▁int ▁[ ▁smallest Freq ▁. ▁size ▁( ▁) ▁] ▁; ▁int ▁k ▁= ▁0 ▁; ▁for ▁( ▁Integer ▁val ▁: ▁smallest Freq ▁) ▁{ ▁array ▁[ ▁k ▁] ▁= ▁val ▁; ▁k ▁++ ▁; ▁} ▁int ▁ind ▁= ▁lower _ bound ▁( ▁array ▁, ▁0 ▁, ▁smallest Freq ▁. ▁size ▁( ▁) ▁, ▁frequency ▁) ▁; ▁ans ▁. ▁add ▁( ▁ind ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁static ▁int ▁lower _ bound ▁( ▁int ▁[ ▁] ▁a ▁, ▁int ▁low ▁, ▁int ▁high ▁, ▁int ▁element
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁count LessThan ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁key ▁) ▁{ ▁int ▁l ▁= ▁0 ▁, ▁r ▁= ▁n ▁- ▁1 ▁; ▁int ▁index ▁= ▁- ▁1 ▁; ▁while ▁( ▁l ▁<= ▁r ▁) ▁{ ▁int ▁m ▁= ▁( ▁l ▁+ ▁r ▁) ▁/ ▁2 ▁; ▁if ▁( ▁arr ▁[ ▁m ▁] ▁< ▁key ▁) ▁{ ▁l ▁= ▁m ▁+ ▁1 ▁; ▁index ▁= ▁m ▁; ▁} ▁else ▁{ ▁r ▁= ▁m ▁- ▁1 ▁; ▁} ▁} ▁return ▁( ▁index ▁+ ▁1 ▁) ▁; ▁} ▁static ▁int ▁count GreaterThan ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁key ▁) ▁{ ▁int ▁l ▁= ▁0 ▁, ▁r ▁= ▁n ▁- ▁1 ▁; ▁int ▁index ▁= ▁- ▁1 ▁; ▁while ▁( ▁l ▁<= ▁r ▁) ▁{ ▁int ▁m ▁= ▁( ▁l ▁+ ▁r ▁) ▁/ ▁2 ▁; ▁if ▁( ▁arr ▁[ ▁m ▁] ▁<= ▁key ▁) ▁{ ▁l ▁= ▁m ▁+ ▁1 ▁; ▁} ▁else ▁{ ▁r ▁= ▁m ▁- ▁1 ▁; ▁index ▁= ▁m ▁; ▁} ▁} ▁if ▁( ▁index ▁== ▁- ▁1 ▁) ▁return ▁0 ▁; ▁return ▁( ▁n ▁- ▁index ▁) ▁; ▁} ▁static ▁int ▁count Tri pl ets ▁( ▁int ▁n ▁, ▁int ▁a ▁[ ▁] ▁, ▁int ▁b ▁[ ▁] ▁, ▁int ▁c ▁[ ▁] ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁a ▁) ▁; ▁Arrays ▁. ▁sort ▁( ▁b ▁) ▁; ▁Arrays ▁. ▁sort ▁( ▁c ▁) ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁{ ▁int ▁current ▁= ▁b ▁[ ▁i ▁] ▁; ▁int ▁low ▁= ▁count LessThan ▁( ▁a ▁, ▁n ▁, ▁current ▁) ▁; ▁int ▁high ▁= ▁count GreaterThan ▁( ▁c ▁, ▁n ▁, ▁current ▁) ▁; ▁count ▁+= ▁( ▁low ▁* ▁high ▁) ▁; ▁} ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁5 ▁} ▁; ▁int ▁b ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁4 ▁} ▁; ▁int ▁c ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁6 ▁} ▁; ▁int ▁size ▁= ▁a ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Tri pl ets ▁( ▁size ▁, ▁a ▁, ▁b ▁, ▁c ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁divisor count ▁( ▁int ▁elem ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁Math ▁. ▁sqrt ▁( ▁elem ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁elem ▁% ▁i ▁== ▁0 ▁) ▁{ ▁if ▁( ▁i ▁* ▁i ▁== ▁elem ▁) ▁ans ▁++ ▁; ▁else ▁ans ▁+= ▁2 ▁; ▁} ▁} ▁return ▁ans ▁; ▁} ▁static ▁String ▁find w inner ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁B ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁M ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁A ▁[ ▁i ▁] ▁= ▁divisor count ▁( ▁A ▁[ ▁i ▁] ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁M ▁; ▁i ▁++ ▁) ▁{ ▁B ▁[ ▁i ▁] ▁= ▁divisor count ▁( ▁B ▁[ ▁i ▁] ▁) ▁; ▁} ▁Arrays ▁. ▁sort ▁( ▁A ▁) ▁; ▁Arrays ▁. ▁sort ▁( ▁B ▁) ▁; ▁int ▁win A ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁int ▁val ▁= ▁A ▁[ ▁i ▁] ▁; ▁int ▁start ▁= ▁0 ▁; ▁int ▁end ▁= ▁M ▁- ▁1 ▁; ▁int ▁index ▁= ▁- ▁1 ▁; ▁while ▁( ▁start ▁<= ▁end ▁) ▁{ ▁int ▁mid ▁= ▁( ▁start ▁+ ▁end ▁) ▁/ ▁2 ▁; ▁if ▁( ▁B ▁[ ▁mid ▁] ▁<= ▁val ▁) ▁{ ▁index ▁= ▁mid ▁; ▁start ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁else ▁{ ▁end ▁= ▁mid ▁- ▁1 ▁; ▁} ▁} ▁win A ▁+= ▁( ▁index ▁+ ▁1 ▁) ▁; ▁} ▁int ▁win B ▁= ▁N ▁* ▁M ▁- ▁win A ▁; ▁if ▁( ▁win A ▁> ▁win B ▁) ▁{ ▁return ▁" ▁A ▁" ▁; ▁} ▁else ▁if ▁( ▁win B ▁> ▁win A ▁) ▁{ ▁return ▁" ▁B ▁" ▁; ▁} ▁return ▁" ▁Draw ▁" ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁12 ▁, ▁24 ▁} ▁; ▁int ▁N ▁= ▁A ▁. ▁length ▁; ▁int ▁B ▁[ ▁] ▁= ▁{ ▁25 ▁, ▁28 ▁, ▁13 ▁, ▁45 ▁} ▁; ▁int ▁M ▁= ▁B ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁find w inner ▁( ▁A ▁, ▁B ▁, ▁N ▁, ▁M ▁) ▁)
▁class ▁G F G ▁{ ▁static ▁boolean ▁isP ossible ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁dist ▁, ▁int ▁k ▁) ▁{ ▁int ▁req ▁= ▁0 ▁; ▁int ▁curr ▁= ▁0 ▁; ▁int ▁prev ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁while ▁( ▁curr ▁!= ▁n ▁&& ▁arr ▁[ ▁curr ▁] ▁- ▁arr ▁[ ▁prev ▁] ▁<= ▁dist ▁) ▁{ ▁curr ▁++ ▁; ▁} ▁req ▁++ ▁; ▁if ▁( ▁curr ▁== ▁n ▁) ▁{ ▁break ▁; ▁} ▁prev ▁= ▁curr ▁- ▁1 ▁; ▁} ▁if ▁( ▁curr ▁!= ▁n ▁) ▁{ ▁return ▁false ▁; ▁} ▁if ▁( ▁req ▁<= ▁k ▁) ▁{ ▁return ▁true ▁; ▁} ▁return ▁false ▁; ▁} ▁static ▁int ▁min Distance ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁l ▁= ▁0 ▁; ▁int ▁h ▁= ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁; ▁int ▁ans ▁= ▁0 ▁; ▁while ▁( ▁l ▁<= ▁h ▁) ▁{ ▁int ▁m ▁= ▁( ▁l ▁+ ▁h ▁) ▁/ ▁2 ▁; ▁if ▁( ▁isP ossible ▁( ▁arr ▁, ▁n ▁, ▁m ▁, ▁k ▁) ▁) ▁{ ▁ans ▁= ▁m ▁; ▁h ▁= ▁m ▁- ▁1 ▁; ▁} ▁else ▁{ ▁l ▁= ▁m ▁+ ▁1 ▁; ▁} ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁15 ▁, ▁36 ▁, ▁43 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁int ▁k ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁min Distance ▁( ▁arr ▁, ▁n ▁, ▁k ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁count Factor ▁( ▁int ▁P ▁, ▁int ▁X ▁) ▁{ ▁if ▁( ▁X ▁< ▁P ▁) ▁return ▁0 ▁; ▁return ▁( ▁X ▁/ ▁P ▁+ ▁count Factor ▁( ▁P ▁, ▁X ▁/ ▁P ▁) ▁) ▁; ▁} ▁static ▁int ▁find Small est X ▁( ▁int ▁Y ▁) ▁{ ▁int ▁low ▁= ▁0 ▁, ▁high ▁= ▁5 ▁* ▁Y ▁; ▁int ▁N ▁= ▁0 ▁; ▁while ▁( ▁low ▁<= ▁high ▁) ▁{ ▁int ▁mid ▁= ▁( ▁high ▁+ ▁low ▁) ▁/ ▁2 ▁; ▁if ▁( ▁count Factor ▁( ▁5 ▁, ▁mid ▁) ▁< ▁Y ▁) ▁{ ▁low ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁else ▁{ ▁N ▁= ▁mid ▁; ▁high ▁= ▁mid ▁- ▁1 ▁; ▁} ▁} ▁return ▁N ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁Y ▁= ▁10 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Small est X ▁( ▁Y ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G f G ▁{ ▁static ▁boolean ▁prime ▁[ ▁] ▁= ▁new ▁boolean ▁[ ▁1000000 ▁+ ▁5 ▁] ▁; ▁static ▁void ▁find Prime ▁( ▁) ▁{ ▁Arrays ▁. ▁fill ▁( ▁prime ▁, ▁true ▁) ▁; ▁prime ▁[ ▁1 ▁] ▁= ▁false ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁* ▁p ▁<= ▁1000000 ▁; ▁p ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁p ▁] ▁== ▁true ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁p ▁* ▁2 ▁; ▁i ▁<= ▁1000000 ▁; ▁i ▁+= ▁p ▁) ▁prime ▁[ ▁i ▁] ▁= ▁false ▁; ▁} ▁} ▁} ▁static ▁int ▁len Of Long Sub arr ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁Map ▁< ▁Integer ▁, ▁Integer ▁> ▁um ▁= ▁new ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁( ▁) ▁; ▁int ▁sum ▁= ▁0 ▁, ▁max Len ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁prime ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁== ▁false ▁? ▁- ▁1 ▁: ▁1 ▁; ▁if ▁( ▁sum ▁== ▁1 ▁) ▁max Len ▁= ▁i ▁+ ▁1 ▁; ▁else ▁if ▁( ▁! ▁um ▁. ▁containsKey ▁( ▁sum ▁) ▁) ▁um ▁. ▁put ▁( ▁sum ▁, ▁i ▁) ▁; ▁if ▁( ▁um ▁. ▁containsKey ▁( ▁sum ▁- ▁1 ▁) ▁) ▁{ ▁if ▁( ▁max Len ▁< ▁( ▁i ▁- ▁um ▁. ▁get ▁( ▁sum ▁- ▁1 ▁) ▁) ▁) ▁max Len ▁= ▁i ▁- ▁um ▁. ▁get ▁( ▁sum ▁- ▁1 ▁) ▁; ▁} ▁} ▁return ▁max Len ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁find Prime ▁( ▁) ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁9 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁, ▁7 ▁, ▁8 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁len Of Long Sub arr ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁value ▁; ▁static ▁boolean ▁canBe Opt imal Value ▁( ▁int ▁K ▁, ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁B ▁) ▁{ ▁int ▁[ ▁] ▁tmp ▁= ▁new ▁int ▁[ ▁N ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁tmp ▁[ ▁i ▁] ▁= ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁K ▁* ▁( ▁i ▁+ ▁1 ▁) ▁) ▁; ▁Arrays ▁. ▁sort ▁( ▁tmp ▁) ▁; ▁value ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁K ▁; ▁i ▁++ ▁) ▁value ▁+= ▁tmp ▁[ ▁i ▁] ▁; ▁return ▁value ▁<= ▁B ▁; ▁} ▁static ▁void ▁find No Of Elements and Value ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁B ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁value ▁= ▁0 ▁; ▁while ▁( ▁start ▁<= ▁end ▁) ▁{ ▁int ▁mid ▁= ▁( ▁start ▁+ ▁end ▁) ▁/ ▁2 ▁; ▁if ▁( ▁canBe Opt imal Value ▁( ▁mid ▁, ▁arr ▁, ▁N ▁, ▁B ▁) ▁) ▁{ ▁ans ▁= ▁mid ▁; ▁start ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁else ▁end ▁= ▁mid ▁- ▁1 ▁; ▁} ▁canBe Opt imal Value ▁( ▁ans ▁, ▁arr ▁, ▁N ▁, ▁B ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁ans ▁+ ▁" ▁" ▁+ ▁value ▁+ ▁" NEW _ LINE "); ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁5 ▁, ▁6 ▁, ▁3 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁int ▁B ▁= ▁90 ▁; ▁find No Of Elements and Value ▁( ▁arr ▁, ▁N ▁, ▁B ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁lex i Middle Small est ▁( ▁int ▁K ▁, ▁int ▁N ▁) ▁{ ▁if ▁( ▁K ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁K ▁/ ▁2 ▁+ ▁" ▁" ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁- ▁1 ▁; ▁++ ▁i ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁K ▁+ ▁" ▁" ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁return ▁; ▁} ▁ArrayList ▁< ▁Integer ▁> ▁a ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁/ ▁2 ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁a ▁. ▁get ▁( ▁a ▁. ▁size ▁( ▁) ▁- ▁1 ▁) ▁== ▁1 ▁) ▁{ ▁a ▁. ▁remove ▁( ▁a ▁. ▁size ▁( ▁) ▁- ▁1 ▁) ▁; ▁} ▁else ▁{ ▁int ▁t ▁= ▁a ▁. ▁get ▁( ▁a ▁. ▁size ▁( ▁) ▁- ▁1 ▁) ▁- ▁1 ▁; ▁a ▁. ▁set ▁( ▁a ▁. ▁get ▁( ▁a ▁. ▁size ▁( ▁) ▁- ▁1 ▁) ▁, ▁t ▁) ▁; ▁while ▁( ▁a ▁. ▁size ▁( ▁) ▁< ▁N ▁) ▁{ ▁a ▁. ▁add ▁( ▁K ▁) ▁; ▁} ▁} ▁} ▁for ▁( ▁int ▁i ▁: ▁a ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁i ▁+ ▁" ▁" ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁K ▁= ▁2 ▁, ▁N ▁= ▁4 ▁; ▁lex i Middle Small est ▁( ▁K ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁class ▁pair ▁{ ▁int ▁first ▁, ▁second ▁; ▁public ▁pair ▁( ▁int ▁first ▁, ▁int ▁second ▁) ▁{ ▁this ▁. ▁first ▁= ▁first ▁; ▁this ▁. ▁second ▁= ▁second ▁; ▁} ▁} ▁static ▁void ▁find Pair ▁( ▁pair ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁int ▁a ▁= ▁arr ▁[ ▁i ▁] ▁. ▁first ▁, ▁b ▁= ▁arr ▁[ ▁i ▁] ▁. ▁second ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁int ▁c ▁= ▁arr ▁[ ▁j ▁] ▁. ▁first ▁, ▁d ▁= ▁arr ▁[ ▁j ▁] ▁. ▁second ▁; ▁if ▁( ▁a ▁< ▁c ▁&& ▁b ▁> ▁d ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁( ▁" ▁+ ▁a ▁+ ▁" ▁" ▁+ ▁b ▁+ ▁" ▁) ▁, ▁( ▁" ▁+ ▁c ▁+ ▁" ▁" ▁+ ▁d ▁+ ▁" ▁) ▁" ▁) ▁; ▁return ▁; ▁} ▁} ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁NO ▁SU CH ▁PA IR ▁EX IST ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁pair ▁arr ▁[ ▁] ▁= ▁{ ▁new ▁pair ▁( ▁3 ▁, ▁7 ▁) ▁, ▁new ▁pair ▁( ▁21 ▁, ▁23 ▁) ▁, ▁new ▁pair ▁( ▁4 ▁, ▁13 ▁) ▁, ▁new ▁pair ▁( ▁1 ▁, ▁2 ▁) ▁, ▁new ▁pair ▁( ▁7 ▁, ▁- ▁1 ▁) ▁} ▁; ▁find Pair ▁( ▁arr ▁, ▁5 ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁max Cost ToRemove ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁int ▁max Cost ▁= ▁0 ▁; ▁Arrays ▁. ▁sort ▁( ▁arr ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁+= ▁K ▁) ▁{ ▁max Cost ▁+= ▁arr ▁[ ▁i ▁+ ▁1 ▁] ▁; ▁} ▁return ▁max Cost ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁4 ▁, ▁1 ▁, ▁5 ▁, ▁1 ▁, ▁5 ▁, ▁3 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁int ▁K ▁= ▁4 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁max Cost ToRemove ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁checkIf Possible Merge ▁( ▁int ▁[ ▁] ▁A ▁, ▁int ▁[ ▁] ▁B ▁, ▁int ▁N ▁) ▁{ ▁int ▁i ▁= ▁0 ▁; ▁int ▁j ▁= ▁0 ▁; ▁int ▁prev ▁= ▁- ▁1 ▁; ▁boolean ▁flag ▁= ▁true ▁; ▁while ▁( ▁i ▁< ▁N ▁&& ▁j ▁< ▁N ▁) ▁{ ▁if ▁( ▁A ▁[ ▁i ▁] ▁< ▁B ▁[ ▁j ▁] ▁&& ▁prev ▁!= ▁0 ▁) ▁{ ▁prev ▁= ▁0 ▁; ▁i ▁++ ▁; ▁} ▁else ▁if ▁( ▁B ▁[ ▁j ▁] ▁< ▁A ▁[ ▁i ▁] ▁&& ▁prev ▁!= ▁1 ▁) ▁{ ▁prev ▁= ▁1 ▁; ▁j ▁++ ▁; ▁} ▁else ▁if ▁( ▁A ▁[ ▁i ▁] ▁== ▁B ▁[ ▁j ▁] ▁) ▁{ ▁if ▁( ▁prev ▁!= ▁1 ▁) ▁{ ▁prev ▁= ▁1 ▁; ▁j ▁++ ▁; ▁} ▁else ▁{ ▁prev ▁= ▁0 ▁; ▁i ▁++ ▁; ▁} ▁} ▁else ▁{ ▁flag ▁= ▁false ▁; ▁break ▁; ▁} ▁} ▁return ▁flag ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁A ▁= ▁{ ▁3 ▁, ▁5 ▁, ▁8 ▁} ▁; ▁int ▁[ ▁] ▁B ▁= ▁{ ▁2 ▁, ▁4 ▁, ▁6 ▁} ▁; ▁int ▁N ▁= ▁A ▁. ▁length ▁; ▁if ▁( ▁checkIf Possible Merge ▁( ▁A ▁, ▁B ▁, ▁N ▁) ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁max Sum ▁( ▁int ▁n ▁, ▁int ▁a ▁[ ▁] ▁, ▁int ▁[ ▁] ▁[ ▁] ▁l ▁, ▁int ▁q ▁) ▁{ ▁Vector ▁< ▁Integer ▁> ▁v ▁= ▁new ▁Vector ▁< ▁> ▁( ▁) ▁; ▁int ▁[ ▁] ▁d ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁q ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁x ▁= ▁l ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁; ▁x ▁<= ▁l ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁; ▁x ▁++ ▁) ▁{ ▁if ▁( ▁d ▁[ ▁x ▁] ▁== ▁0 ▁) ▁{ ▁d ▁[ ▁x ▁] ▁= ▁1 ▁; ▁} ▁} ▁} ▁HashSet ▁< ▁Integer ▁> ▁st ▁= ▁new ▁HashSet ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁d ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁v ▁. ▁add ▁( ▁a ▁[ ▁i ▁] ▁) ▁; ▁st ▁. ▁add ▁( ▁i ▁) ▁; ▁} ▁} ▁Collections ▁. ▁sort ▁( ▁v ▁) ▁; ▁Collections ▁. ▁reverse ▁( ▁v ▁) ▁; ▁int ▁c ▁= ▁0 ▁; ▁for ▁( ▁int ▁it ▁: ▁st ▁) ▁{ ▁a ▁[ ▁it ▁] ▁= ▁v ▁. ▁get ▁( ▁c ▁) ▁; ▁c ▁++ ▁; ▁} ▁int ▁pref _ sum ▁= ▁0 ▁; ▁int ▁temp _ sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁temp _ sum ▁+= ▁a ▁[ ▁i ▁] ▁; ▁pref _ sum ▁+= ▁temp _ sum ▁; ▁} ▁return ▁pref _ sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁- ▁8 ▁, ▁4 ▁, ▁- ▁2 ▁, ▁- ▁6 ▁, ▁4 ▁, ▁7 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁int ▁[ ▁] ▁[ ▁] ▁q ▁= ▁{ ▁{ ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁4 ▁, ▁5 ▁} ▁} ▁; ▁int ▁queries ▁= ▁q ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁max Sum ▁( ▁N ▁, ▁arr ▁, ▁q ▁, ▁queries ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁lang ▁. ▁Math ▁; ▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁import ▁java ▁. ▁util ▁. ▁Collections ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁Max Re arr n ge Sum ▁( ▁Integer ▁A ▁[ ▁] ▁, ▁Integer ▁B ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁A ▁) ▁; ▁Arrays ▁. ▁sort ▁( ▁B ▁, ▁Collections ▁. ▁reverse Order ▁( ▁) ▁) ▁; ▁int ▁max Sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁max Sum ▁+= ▁Math ▁. ▁abs ▁( ▁A ▁[ ▁i ▁] ▁- ▁B ▁[ ▁i ▁] ▁) ▁; ▁} ▁return ▁max Sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Integer ▁A ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁2 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁Integer ▁B ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁5 ▁, ▁5 ▁, ▁6 ▁, ▁6 ▁} ▁; ▁int ▁N ▁= ▁A ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁Max Re arr n ge Sum ▁( ▁A ▁, ▁B ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁min Heap ify ▁( ▁int ▁br r ▁[ ▁] ▁, ▁int ▁i ▁, ▁int ▁M ▁) ▁{ ▁int ▁left ▁= ▁2 ▁* ▁i ▁+ ▁1 ▁; ▁int ▁right ▁= ▁2 ▁* ▁i ▁+ ▁2 ▁; ▁int ▁smallest ▁= ▁i ▁; ▁if ▁( ▁left ▁< ▁M ▁&& ▁br r ▁[ ▁left ▁] ▁< ▁br r ▁[ ▁smallest ▁] ▁) ▁{ ▁smallest ▁= ▁left ▁; ▁} ▁if ▁( ▁right ▁< ▁M ▁&& ▁br r ▁[ ▁right ▁] ▁< ▁br r ▁[ ▁smallest ▁] ▁) ▁{ ▁smallest ▁= ▁right ▁; ▁} ▁if ▁( ▁smallest ▁!= ▁i ▁) ▁{ ▁int ▁temp ▁= ▁br r ▁[ ▁i ▁] ▁; ▁br r ▁[ ▁i ▁] ▁= ▁br r ▁[ ▁smallest ▁] ▁; ▁br r ▁[ ▁smallest ▁] ▁= ▁temp ▁; ▁min Heap ify ▁( ▁br r ▁, ▁smallest ▁, ▁M ▁) ▁; ▁} ▁} ▁static ▁void ▁merge ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁br r ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁M ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁br r ▁[ ▁0 ▁] ▁) ▁{ ▁int ▁temp ▁= ▁arr ▁[ ▁i ▁] ▁; ▁arr ▁[ ▁i ▁] ▁= ▁br r ▁[ ▁0 ▁] ▁; ▁br r ▁[ ▁0 ▁] ▁= ▁temp ▁; ▁min Heap ify ▁( ▁br r ▁, ▁0 ▁, ▁M ▁) ▁; ▁} ▁} ▁Arrays ▁. ▁sort ▁( ▁br r ▁) ▁; ▁} ▁static ▁void ▁print Array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁23 ▁, ▁35 ▁, ▁2 35 ▁, ▁2 335 ▁} ▁; ▁int ▁br r ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁5 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁int ▁M ▁= ▁br r ▁. ▁length ▁; ▁merge ▁( ▁arr ▁, ▁br r ▁, ▁N ▁, ▁M ▁) ▁; ▁print Array ▁( ▁arr ▁, ▁N ▁) ▁; ▁print Array ▁( ▁br r ▁, ▁M ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁max Area ▁( ▁int ▁[ ▁] ▁point _ x ▁, ▁int ▁[ ▁] ▁point _ y ▁, ▁int ▁n ▁, ▁int ▁length ▁, ▁int ▁width ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁point _ x ▁) ▁; ▁Arrays ▁. ▁sort ▁( ▁point _ y ▁) ▁; ▁int ▁dx ▁= ▁point _ x ▁[ ▁0 ▁] ▁; ▁int ▁dy ▁= ▁point _ y ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁dx ▁= ▁Math ▁. ▁max ▁( ▁dx ▁, ▁point _ x ▁[ ▁i ▁] ▁- ▁point _ x ▁[ ▁i ▁- ▁1 ▁] ▁) ▁; ▁dy ▁= ▁Math ▁. ▁max ▁( ▁dy ▁, ▁point _ y ▁[ ▁i ▁] ▁- ▁point _ y ▁[ ▁i ▁- ▁1 ▁] ▁) ▁; ▁} ▁dx ▁= ▁Math ▁. ▁max ▁( ▁dx ▁, ▁( ▁length ▁+ ▁1 ▁) ▁- ▁point _ x ▁[ ▁n ▁- ▁1 ▁] ▁) ▁; ▁dy ▁= ▁Math ▁. ▁max ▁( ▁dy ▁, ▁( ▁width ▁+ ▁1 ▁) ▁- ▁point _ y ▁[ ▁n ▁- ▁1 ▁] ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁( ▁dx ▁- ▁1 ▁) ▁* ▁( ▁dy ▁- ▁1 ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁length ▁= ▁15 ▁, ▁width ▁= ▁8 ▁; ▁int ▁n ▁= ▁3 ▁; ▁int ▁point _ x ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁11 ▁, ▁8 ▁} ▁; ▁int ▁point _ y ▁[ ▁] ▁= ▁{ ▁8 ▁, ▁2 ▁, ▁6 ▁} ▁; ▁max Area ▁( ▁point _ x ▁, ▁point _ y ▁, ▁n ▁, ▁length ▁, ▁width ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁find Max Value ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁arr ▁) ▁; ▁int ▁ans ▁= ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁; ▁int ▁max Possible ▁= ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁2 ▁; ▁i ▁>= ▁0 ▁; ▁-- ▁i ▁) ▁{ ▁if ▁( ▁max Possible ▁> ▁0 ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁>= ▁max Possible ▁) ▁{ ▁ans ▁+= ▁( ▁max Possible ▁- ▁1 ▁) ▁; ▁max Possible ▁= ▁max Possible ▁- ▁1 ▁; ▁} ▁else ▁{ ▁max Possible ▁= ▁arr ▁[ ▁i ▁] ▁; ▁ans ▁+= ▁max Possible ▁; ▁} ▁} ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁4 ▁, ▁1 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁find Max Value ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁lex Numbers ▁( ▁int ▁n ▁) ▁{ ▁Vector ▁< ▁String ▁> ▁s ▁= ▁new ▁Vector ▁< ▁String ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁s ▁. ▁add ▁( ▁String ▁. ▁valueOf ▁( ▁i ▁) ▁) ▁; ▁} ▁Collections ▁. ▁sort ▁( ▁s ▁) ▁; ▁Vector ▁< ▁Integer ▁> ▁ans ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁ans ▁. ▁add ▁( ▁Integer ▁. ▁valueOf ▁( ▁s ▁. ▁get ▁( ▁i ▁) ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁ans ▁. ▁get ▁( ▁i ▁) ▁+ ▁" ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁15 ▁; ▁lex Numbers ▁( ▁n ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁sorted Ad jacent D ifferences ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁[ ▁] ▁ans ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁Arrays ▁. ▁sort ▁( ▁arr ▁) ▁; ▁int ▁l ▁= ▁0 ▁, ▁r ▁= ▁n ▁- ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁i ▁% ▁2 ▁== ▁1 ▁) ▁{ ▁ans ▁[ ▁i ▁] ▁= ▁arr ▁[ ▁l ▁] ▁; ▁l ▁++ ▁; ▁} ▁else ▁{ ▁ans ▁[ ▁i ▁] ▁= ▁arr ▁[ ▁r ▁] ▁; ▁r ▁-- ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁ans ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁- ▁2 ▁, ▁4 ▁, ▁8 ▁, ▁6 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁sorted Ad jacent D ifferences ▁( ▁arr ▁, ▁n ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁check Is AP ▁( ▁double ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁1 ▁) ▁return ▁true ▁; ▁Arrays ▁. ▁sort ▁( ▁arr ▁) ▁; ▁double ▁d ▁= ▁arr ▁[ ▁1 ▁] ▁- ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁- ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁!= ▁d ▁) ▁{ ▁return ▁false ▁; ▁} ▁} ▁return ▁true ▁; ▁} ▁static ▁boolean ▁check Is GP ▁( ▁double ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁1 ▁) ▁return ▁true ▁; ▁Arrays ▁. ▁sort ▁( ▁arr ▁) ▁; ▁double ▁r ▁= ▁arr ▁[ ▁1 ▁] ▁/ ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁/ ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁!= ▁r ▁) ▁return ▁false ▁; ▁} ▁return ▁true ▁; ▁} ▁static ▁boolean ▁check Is HP ▁( ▁double ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁1 ▁) ▁{ ▁return ▁true ▁; ▁} ▁double ▁[ ▁] ▁rec ▁= ▁new ▁double ▁[ ▁n ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁rec ▁[ ▁i ▁] ▁= ▁( ▁( ▁1 ▁/ ▁arr ▁[ ▁i ▁] ▁) ▁) ▁; ▁} ▁if ▁( ▁check Is AP ▁( ▁rec ▁, ▁n ▁) ▁) ▁return ▁true ▁; ▁else ▁return ▁false ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁double ▁arr ▁[ ▁] ▁= ▁{ ▁1.0 ▁/ ▁5.0 ▁, ▁1.0 ▁/ ▁10.0 ▁, ▁1.0 ▁/ ▁15.0 ▁, ▁1.0 ▁/ ▁20.0 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁int ▁flag ▁= ▁0 ▁; ▁if ▁( ▁check Is AP ▁( ▁arr ▁, ▁n ▁) ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Yes ▁, ▁An ▁AP ▁can ▁be ▁formed ▁" ▁+ ▁" NEW _ LINE "); ▁flag ▁= ▁1 ▁; ▁} ▁if ▁( ▁check Is GP ▁( ▁arr ▁, ▁n ▁) ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Yes ▁, ▁A ▁GP ▁can ▁be ▁formed ▁" ▁+ ▁" NEW _ LINE "); ▁flag ▁= ▁1 ▁; ▁} ▁if ▁( ▁check Is HP ▁( ▁arr ▁, ▁n ▁)
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁sortBy Freq ▁( ▁Integer ▁[ ▁] ▁arr ▁, ▁int ▁n ▁) ▁{ ▁int ▁max E ▁= ▁- ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁max E ▁= ▁Math ▁. ▁max ▁( ▁max E ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁int ▁freq ▁[ ▁] ▁= ▁new ▁int ▁[ ▁max E ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁freq ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁++ ▁; ▁} ▁int ▁cnt ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁max E ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁freq ▁[ ▁i ▁] ▁> ▁0 ▁) ▁{ ▁int ▁value ▁= ▁100000 ▁- ▁i ▁; ▁arr ▁[ ▁cnt ▁] ▁= ▁100000 ▁* ▁freq ▁[ ▁i ▁] ▁+ ▁value ▁; ▁cnt ▁++ ▁; ▁} ▁} ▁return ▁cnt ▁; ▁} ▁static ▁void ▁print Sorted Array ▁( ▁Integer ▁[ ▁] ▁arr ▁, ▁int ▁cnt ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁cnt ▁; ▁i ▁++ ▁) ▁{ ▁int ▁frequency ▁= ▁arr ▁[ ▁i ▁] ▁/ ▁100000 ▁; ▁int ▁value ▁= ▁100000 ▁- ▁( ▁arr ▁[ ▁i ▁] ▁% ▁100000 ▁) ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁frequency ▁; ▁j ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁value ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Integer ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁, ▁4 ▁, ▁2 ▁, ▁2 ▁, ▁8 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁int ▁cnt ▁= ▁sortBy Freq ▁( ▁arr ▁, ▁n ▁) ▁; ▁Arrays ▁. ▁sort ▁( ▁arr ▁, ▁Collections ▁. ▁reverse Order ▁( ▁) ▁) ▁; ▁print Sorted Array ▁( ▁arr ▁, ▁cnt ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁max _ element ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁max ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁max ▁< ▁arr ▁[ ▁i ▁] ▁) ▁max ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁return ▁max ▁; ▁} ▁static ▁int ▁max Mod ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁max Val ▁= ▁max _ element ▁( ▁arr ▁, ▁n ▁) ▁; ▁int ▁second Max ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁max Val ▁&& ▁arr ▁[ ▁i ▁] ▁> ▁second Max ▁) ▁{ ▁second Max ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁} ▁return ▁second Max ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁4 ▁, ▁1 ▁, ▁5 ▁, ▁3 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁max Mod ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁isP ossible ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁B ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁m ▁, ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁if ▁( ▁x ▁> ▁n ▁y ▁> ▁m ▁) ▁return ▁false ▁; ▁Arrays ▁. ▁sort ▁( ▁A ▁) ▁; ▁Arrays ▁. ▁sort ▁( ▁B ▁) ▁; ▁if ▁( ▁A ▁[ ▁x ▁- ▁1 ▁] ▁< ▁B ▁[ ▁m ▁- ▁y ▁] ▁) ▁return ▁true ▁; ▁else ▁return ▁false ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁} ▁; ▁int ▁B ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁A ▁. ▁length ▁; ▁int ▁m ▁= ▁B ▁. ▁length ▁; ▁; ▁int ▁x ▁= ▁3 ▁, ▁y ▁= ▁1 ▁; ▁if ▁( ▁isP ossible ▁( ▁A ▁, ▁B ▁, ▁n ▁, ▁m ▁, ▁x ▁, ▁y ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁getNumber ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁int ▁i ▁= ▁0 ▁; ▁int ▁odd ▁= ▁1 ▁; ▁while ▁( ▁odd ▁<= ▁n ▁) ▁{ ▁arr ▁[ ▁i ▁++ ▁] ▁= ▁odd ▁; ▁odd ▁+= ▁2 ▁; ▁} ▁int ▁even ▁= ▁2 ▁; ▁while ▁( ▁even ▁<= ▁n ▁) ▁{ ▁arr ▁[ ▁i ▁++ ▁] ▁= ▁even ▁; ▁even ▁+= ▁2 ▁; ▁} ▁return ▁arr ▁[ ▁k ▁- ▁1 ▁] ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁8 ▁, ▁k ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁getNumber ▁( ▁n ▁, ▁k ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁MAX ▁= ▁10000 5 ▁; ▁static ▁int ▁Min _ Replace ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁arr ▁) ▁; ▁Integer ▁[ ▁] ▁freq ▁= ▁new ▁Integer ▁[ ▁MAX ▁] ▁; ▁Arrays ▁. ▁fill ▁( ▁freq ▁, ▁0 ▁) ▁; ▁int ▁p ▁= ▁0 ▁; ▁freq ▁[ ▁p ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁) ▁++ ▁freq ▁[ ▁p ▁] ▁; ▁else ▁++ ▁freq ▁[ ▁++ ▁p ▁] ▁; ▁} ▁Arrays ▁. ▁sort ▁( ▁freq ▁, ▁Collections ▁. ▁reverse Order ▁( ▁) ▁) ▁; ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁k ▁; ▁i ▁<= ▁p ▁; ▁i ▁++ ▁) ▁ans ▁+= ▁freq ▁[ ▁i ▁] ▁; ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁7 ▁, ▁8 ▁, ▁2 ▁, ▁3 ▁, ▁2 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁int ▁k ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁Min _ Replace ▁( ▁arr ▁, ▁n ▁, ▁k ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁Segment ▁( ▁int ▁x ▁[ ▁] ▁, ▁int ▁l ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁1 ▁) ▁return ▁1 ▁; ▁int ▁ans ▁= ▁2 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁x ▁[ ▁i ▁] ▁- ▁l ▁[ ▁i ▁] ▁> ▁x ▁[ ▁i ▁- ▁1 ▁] ▁) ▁ans ▁++ ▁; ▁else ▁if ▁( ▁x ▁[ ▁i ▁] ▁+ ▁l ▁[ ▁i ▁] ▁< ▁x ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁{ ▁x ▁[ ▁i ▁] ▁= ▁x ▁[ ▁i ▁] ▁+ ▁l ▁[ ▁i ▁] ▁; ▁ans ▁++ ▁; ▁} ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁x ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁8 ▁} ▁, ▁l ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁1 ▁, ▁2 ▁, ▁2 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁x ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁Segment ▁( ▁x ▁, ▁l ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁print Arr angement ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁a ▁) ▁; ▁int ▁b ▁[ ▁] ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁int ▁low ▁= ▁0 ▁, ▁high ▁= ▁n ▁- ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁% ▁2 ▁== ▁0 ▁) ▁b ▁[ ▁low ▁++ ▁] ▁= ▁a ▁[ ▁i ▁] ▁; ▁else ▁b ▁[ ▁high ▁-- ▁] ▁= ▁a ▁[ ▁i ▁] ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁== ▁0 ▁) ▁{ ▁if ▁( ▁b ▁[ ▁n ▁- ▁1 ▁] ▁+ ▁b ▁[ ▁1 ▁] ▁<= ▁b ▁[ ▁i ▁] ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁- ▁1 ▁) ▁; ▁return ▁; ▁} ▁} ▁else ▁if ▁( ▁i ▁== ▁( ▁n ▁- ▁1 ▁) ▁) ▁{ ▁if ▁( ▁b ▁[ ▁n ▁- ▁2 ▁] ▁+ ▁b ▁[ ▁0 ▁] ▁<= ▁b ▁[ ▁i ▁] ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁- ▁1 ▁) ▁; ▁return ▁; ▁} ▁} ▁else ▁{ ▁if ▁( ▁b ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁b ▁[ ▁i ▁+ ▁1 ▁] ▁<= ▁b ▁[ ▁i ▁] ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁- ▁1 ▁) ▁; ▁return ▁; ▁} ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁b ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁4 ▁, ▁4 ▁, ▁3 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁a ▁. ▁length ▁; ▁print Arr angement ▁( ▁a ▁, ▁n ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁N ▁= ▁2 ▁; ▁static ▁int ▁M ▁= ▁2 ▁; ▁static ▁boolean ▁is Matrix Inc ▁( ▁int ▁a ▁[ ▁] ▁[ ▁] ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁M ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁i ▁- ▁1 ▁>= ▁0 ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁[ ▁j ▁] ▁<= ▁a ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁) ▁return ▁false ▁; ▁} ▁if ▁( ▁j ▁- ▁1 ▁>= ▁0 ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁[ ▁j ▁] ▁<= ▁a ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁) ▁return ▁false ▁; ▁} ▁} ▁} ▁return ▁true ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁2 ▁, ▁10 ▁} ▁, ▁{ ▁11 ▁, ▁20 ▁} ▁} ▁; ▁if ▁( ▁is Matrix Inc ▁( ▁a ▁) ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁N ▁= ▁1000000 5 ▁; ▁static ▁int ▁[ ▁] ▁prime ▁= ▁new ▁int ▁[ ▁N ▁] ▁; ▁static ▁void ▁se ive ▁( ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁i ▁; ▁j ▁< ▁N ▁; ▁j ▁+= ▁i ▁) ▁{ ▁prime ▁[ ▁j ▁] ▁= ▁1 ▁; ▁} ▁} ▁} ▁prime ▁[ ▁1 ▁] ▁= ▁1 ▁; ▁} ▁static ▁int ▁maxSize Arr ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁ArrayList ▁< ▁Integer ▁> ▁v ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁ArrayList ▁< ▁Integer ▁> ▁diff ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁int ▁num ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁== ▁1 ▁) ▁{ ▁v ▁. ▁add ▁( ▁i ▁) ▁; ▁} ▁} ▁num ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁v ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁diff ▁. ▁add ▁( ▁v ▁. ▁get ▁( ▁i ▁) ▁- ▁v ▁. ▁get ▁( ▁i ▁- ▁1 ▁) ▁- ▁1 ▁) ▁; ▁} ▁Collections ▁. ▁sort ▁( ▁diff ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁diff ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁diff ▁. ▁set ▁( ▁i ▁, ▁diff ▁. ▁get ▁( ▁i ▁) ▁+ ▁diff ▁. ▁get ▁( ▁i ▁- ▁1 ▁) ▁) ▁; ▁} ▁if ▁( ▁k ▁> ▁n ▁|| ▁( ▁k ▁== ▁0 ▁&& ▁v ▁. ▁size ▁( ▁) ▁> ▁0 ▁) ▁) ▁{ ▁return ▁- ▁1 ▁; ▁} ▁else ▁if ▁( ▁v ▁. ▁size ▁( ▁) ▁<= ▁k ▁) ▁{ ▁return ▁( ▁n ▁- ▁k ▁) ▁; ▁} ▁else ▁if ▁( ▁v ▁. ▁size ▁( ▁) ▁> ▁k ▁) ▁{ ▁int ▁tt ▁= ▁v ▁. ▁size ▁( ▁) ▁- ▁k ▁; ▁int ▁sum ▁= ▁0 ▁; ▁sum ▁+= ▁diff ▁. ▁get ▁( ▁tt ▁- ▁1 ▁) ▁; ▁int ▁res ▁= ▁n ▁- ▁( ▁v ▁. ▁size ▁( ▁) ▁+ ▁sum ▁) ▁; ▁return ▁res ▁; ▁} ▁return ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁class ▁Node ▁{ ▁int ▁data ▁; ▁Node ▁next ▁; ▁} ▁; ▁static ▁Node ▁start ▁; ▁static ▁void ▁sort List ▁( ▁Node ▁head ▁) ▁{ ▁int ▁start Val ▁= ▁1 ▁; ▁while ▁( ▁head ▁!= ▁null ▁) ▁{ ▁head ▁. ▁data ▁= ▁start Val ▁; ▁start Val ▁++ ▁; ▁head ▁= ▁head ▁. ▁next ▁; ▁} ▁} ▁static ▁void ▁push ▁( ▁Node ▁head _ ref ▁, ▁int ▁new _ data ▁) ▁{ ▁Node ▁new _ node ▁= ▁new ▁Node ▁( ▁) ▁; ▁new _ node ▁. ▁data ▁= ▁new _ data ▁; ▁new _ node ▁. ▁next ▁= ▁head _ ref ▁; ▁head _ ref ▁= ▁new _ node ▁; ▁start ▁= ▁head _ ref ▁; ▁} ▁static ▁void ▁print List ▁( ▁Node ▁node ▁) ▁{ ▁while ▁( ▁node ▁!= ▁null ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁node ▁. ▁data ▁+ ▁" ▁" ▁) ▁; ▁node ▁= ▁node ▁. ▁next ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁start ▁= ▁null ▁; ▁push ▁( ▁start ▁, ▁2 ▁) ▁; ▁push ▁( ▁start ▁, ▁1 ▁) ▁; ▁push ▁( ▁start ▁, ▁6 ▁) ▁; ▁push ▁( ▁start ▁, ▁4 ▁) ▁; ▁push ▁( ▁start ▁, ▁5 ▁) ▁; ▁push ▁( ▁start ▁, ▁3 ▁) ▁; ▁sort List ▁( ▁start ▁) ▁; ▁print List ▁( ▁start ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁int ▁count Tri pl ets LessThan ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁n ▁, ▁int ▁val ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁arr ▁) ▁; ▁int ▁ans ▁= ▁0 ▁; ▁int ▁j ▁, ▁k ▁; ▁int ▁sum ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁j ▁= ▁i ▁+ ▁1 ▁; ▁k ▁= ▁n ▁- ▁1 ▁; ▁while ▁( ▁j ▁!= ▁k ▁) ▁{ ▁sum ▁= ▁arr ▁[ ▁i ▁] ▁+ ▁arr ▁[ ▁j ▁] ▁+ ▁arr ▁[ ▁k ▁] ▁; ▁if ▁( ▁sum ▁> ▁val ▁) ▁k ▁-- ▁; ▁else ▁{ ▁ans ▁+= ▁( ▁k ▁- ▁j ▁) ▁; ▁j ▁++ ▁; ▁} ▁} ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁int ▁count Tri pl ets ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁int ▁res ▁; ▁res ▁= ▁count Tri pl ets LessThan ▁( ▁arr ▁, ▁n ▁, ▁b ▁) ▁- ▁count Tri pl ets LessThan ▁( ▁arr ▁, ▁n ▁, ▁a ▁- ▁1 ▁) ▁; ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁2 ▁, ▁7 ▁, ▁5 ▁, ▁3 ▁, ▁8 ▁, ▁4 ▁, ▁1 ▁, ▁9 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁int ▁a ▁= ▁8 ▁, ▁b ▁= ▁16 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁" ▁+ ▁count Tri pl ets ▁( ▁arr ▁, ▁n ▁, ▁a ▁, ▁b ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁max Level ▁( ▁int ▁[ ▁] ▁boxes ▁, ▁int ▁n ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁boxes ▁) ▁; ▁int ▁prev _ width ▁= ▁boxes ▁[ ▁0 ▁] ▁; ▁int ▁prev _ count ▁= ▁1 ▁; ▁int ▁curr _ count ▁= ▁0 ▁; ▁int ▁curr _ width ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁curr _ width ▁+= ▁boxes ▁[ ▁i ▁] ▁; ▁curr _ count ▁+= ▁1 ▁; ▁if ▁( ▁curr _ width ▁> ▁prev _ width ▁&& ▁curr _ count ▁> ▁prev _ count ▁) ▁{ ▁prev _ width ▁= ▁curr _ width ▁; ▁prev _ count ▁= ▁curr _ count ▁; ▁curr _ count ▁= ▁0 ▁; ▁curr _ width ▁= ▁0 ▁; ▁ans ▁++ ▁; ▁} ▁} ▁return ▁ans ▁; ▁} ▁static ▁public ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁boxes ▁= ▁{ ▁10 ▁, ▁20 ▁, ▁30 ▁, ▁50 ▁, ▁60 ▁, ▁70 ▁} ▁; ▁int ▁n ▁= ▁boxes ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁max Level ▁( ▁boxes ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁merge ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁temp ▁[ ▁] ▁, ▁int ▁left ▁, ▁int ▁mid ▁, ▁int ▁right ▁) ▁{ ▁int ▁inv _ count ▁= ▁0 ▁; ▁int ▁i ▁= ▁left ▁; ▁int ▁j ▁= ▁mid ▁; ▁int ▁k ▁= ▁left ▁; ▁while ▁( ▁( ▁i ▁<= ▁mid ▁- ▁1 ▁) ▁&& ▁( ▁j ▁<= ▁right ▁) ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁<= ▁arr ▁[ ▁j ▁] ▁) ▁temp ▁[ ▁k ▁++ ▁] ▁= ▁arr ▁[ ▁i ▁++ ▁] ▁; ▁else ▁{ ▁temp ▁[ ▁k ▁++ ▁] ▁= ▁arr ▁[ ▁j ▁++ ▁] ▁; ▁inv _ count ▁= ▁inv _ count ▁+ ▁( ▁mid ▁- ▁i ▁) ▁; ▁} ▁} ▁while ▁( ▁i ▁<= ▁mid ▁- ▁1 ▁) ▁temp ▁[ ▁k ▁++ ▁] ▁= ▁arr ▁[ ▁i ▁++ ▁] ▁; ▁while ▁( ▁j ▁<= ▁right ▁) ▁temp ▁[ ▁k ▁++ ▁] ▁= ▁arr ▁[ ▁j ▁++ ▁] ▁; ▁for ▁( ▁i ▁= ▁left ▁; ▁i ▁<= ▁right ▁; ▁i ▁++ ▁) ▁arr ▁[ ▁i ▁] ▁= ▁temp ▁[ ▁i ▁] ▁; ▁return ▁inv _ count ▁; ▁} ▁static ▁int ▁_ merge Sort ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁temp ▁[ ▁] ▁, ▁int ▁left ▁, ▁int ▁right ▁) ▁{ ▁int ▁mid ▁, ▁inv _ count ▁= ▁0 ▁; ▁if ▁( ▁right ▁> ▁left ▁) ▁{ ▁mid ▁= ▁( ▁right ▁+ ▁left ▁) ▁/ ▁2 ▁; ▁inv _ count ▁= ▁_ merge Sort ▁( ▁arr ▁, ▁temp ▁, ▁left ▁, ▁mid ▁) ▁; ▁inv _ count ▁+= ▁_ merge Sort ▁( ▁arr ▁, ▁temp ▁, ▁mid ▁+ ▁1 ▁, ▁right ▁) ▁; ▁inv _ count ▁+= ▁merge ▁( ▁arr ▁, ▁temp ▁, ▁left ▁, ▁mid ▁+ ▁1 ▁, ▁right ▁) ▁; ▁} ▁return ▁inv _ count ▁; ▁} ▁static ▁int ▁count Sw aps ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁temp ▁[ ▁] ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁return ▁_ merge Sort ▁( ▁arr ▁, ▁temp ▁, ▁0 ▁, ▁n ▁- ▁1 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁20 ▁, ▁6 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Number ▁of ▁sw aps ▁is ▁" ▁+ ▁count
▁class ▁G F G ▁{ ▁static ▁int ▁minimum Size Array ▁( ▁int ▁S ▁, ▁int ▁P ▁) ▁{ ▁if ▁( ▁S ▁== ▁P ▁) ▁{ ▁return ▁1 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁S ▁; ▁i ▁++ ▁) ▁{ ▁double ▁d ▁= ▁i ▁; ▁if ▁( ▁( ▁S ▁/ ▁d ▁) ▁>= ▁Math ▁. ▁pow ▁( ▁P ▁, ▁1.0 ▁/ ▁d ▁) ▁) ▁{ ▁return ▁i ▁; ▁} ▁} ▁return ▁- ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁S ▁= ▁5 ▁, ▁P ▁= ▁6 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁minimum Size Array ▁( ▁S ▁, ▁P ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁max Sub seq ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁Arrays ▁. ▁sort ▁( ▁arr ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁K ▁== ▁0 ▁) ▁break ▁; ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁0 ▁) ▁{ ▁arr ▁[ ▁i ▁] ▁= ▁- ▁arr ▁[ ▁i ▁] ▁; ▁K ▁-- ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁0 ▁) ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁return ▁sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁6 ▁, ▁- ▁10 ▁, ▁- ▁1 ▁, ▁0 ▁, ▁- ▁4 ▁, ▁2 ▁} ▁; ▁int ▁K ▁= ▁2 ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁max Sub seq ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁print The Array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁static ▁void ▁re arrange ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁if ▁( ▁( ▁N ▁& ▁1 ▁) ▁!= ▁0 ▁) ▁N ▁-- ▁; ▁int ▁odd _ idx ▁= ▁1 ▁, ▁even _ idx ▁= ▁0 ▁; ▁int ▁i ▁, ▁max _ elem ▁= ▁arr ▁[ ▁N ▁- ▁1 ▁] ▁+ ▁1 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁/ ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁arr ▁[ ▁i ▁] ▁+= ▁( ▁arr ▁[ ▁odd _ idx ▁] ▁% ▁max _ elem ▁) ▁* ▁max _ elem ▁; ▁odd _ idx ▁+= ▁2 ▁; ▁} ▁for ▁( ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁arr ▁[ ▁i ▁] ▁+= ▁( ▁arr ▁[ ▁even _ idx ▁] ▁% ▁max _ elem ▁) ▁* ▁max _ elem ▁; ▁even _ idx ▁+= ▁2 ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁arr ▁[ ▁i ▁] ▁= ▁arr ▁[ ▁i ▁] ▁/ ▁max _ elem ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁16 ▁, ▁18 ▁, ▁19 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁re arrange ▁( ▁arr ▁, ▁N ▁) ▁; ▁print The Array ▁( ▁arr ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁check ▁( ▁int ▁num ▁) ▁{ ▁int ▁sm ▁= ▁0 ▁; ▁int ▁num 2 ▁= ▁num ▁* ▁num ▁; ▁while ▁( ▁num ▁> ▁0 ▁) ▁{ ▁sm ▁+= ▁num ▁% ▁10 ▁; ▁num ▁/= ▁10 ▁; ▁} ▁int ▁sm 2 ▁= ▁0 ▁; ▁while ▁( ▁num 2 ▁> ▁0 ▁) ▁{ ▁sm 2 ▁+= ▁num 2 ▁% ▁10 ▁; ▁num 2 ▁/= ▁10 ▁; ▁} ▁return ▁( ▁( ▁sm ▁* ▁sm ▁) ▁== ▁sm 2 ▁) ▁; ▁} ▁static ▁int ▁convert ▁( ▁String ▁s ▁) ▁{ ▁int ▁val ▁= ▁0 ▁; ▁s ▁= ▁reverse ▁( ▁s ▁) ▁; ▁int ▁cur ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁val ▁+= ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁- ▁'0' ▁) ▁* ▁cur ▁; ▁cur ▁*= ▁10 ▁; ▁} ▁return ▁val ▁; ▁} ▁static ▁void ▁generate ▁( ▁String ▁s ▁, ▁int ▁len ▁, ▁HashSet ▁< ▁Integer ▁> ▁uniq ▁) ▁{ ▁if ▁( ▁s ▁. ▁length ▁( ▁) ▁== ▁len ▁) ▁{ ▁if ▁( ▁check ▁( ▁convert ▁( ▁s ▁) ▁) ▁) ▁{ ▁uniq ▁. ▁add ▁( ▁convert ▁( ▁s ▁) ▁) ▁; ▁} ▁return ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁3 ▁; ▁i ▁++ ▁) ▁{ ▁generate ▁( ▁s ▁+ ▁( ▁char ▁) ▁( ▁i ▁+ ▁'0' ▁) ▁, ▁len ▁, ▁uniq ▁) ▁; ▁} ▁} ▁static ▁String ▁reverse ▁( ▁String ▁input ▁) ▁{ ▁char ▁[ ▁] ▁a ▁= ▁input ▁. ▁toCharArray ▁( ▁) ▁; ▁int ▁l ▁, ▁r ▁= ▁a ▁. ▁length ▁- ▁1 ▁; ▁for ▁( ▁l ▁= ▁0 ▁; ▁l ▁< ▁r ▁; ▁l ▁++ ▁, ▁r ▁-- ▁) ▁{ ▁char ▁temp ▁= ▁a ▁[ ▁l ▁] ▁; ▁a ▁[ ▁l ▁] ▁= ▁a ▁[ ▁r ▁] ▁; ▁a ▁[ ▁r ▁] ▁= ▁temp ▁; ▁} ▁return ▁String ▁. ▁valueOf ▁( ▁a ▁) ▁; ▁} ▁static ▁int ▁total Numbers ▁( ▁int ▁L ▁, ▁int ▁R ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁int ▁max _ len ▁= ▁( ▁int ▁) ▁( ▁Math ▁. ▁log 10 ▁( ▁R ▁) ▁+ ▁1 ▁) ▁; ▁HashSet ▁< ▁Integer ▁> ▁uniq ▁= ▁new ▁HashSet ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁max _ len ▁; ▁i ▁++ ▁) ▁{ ▁generate ▁(
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁count Arrays ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁Vector ▁< ▁Integer ▁> ▁[ ▁] ▁div is ors ▁= ▁new ▁Vector ▁[ ▁k ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁div is ors ▁. ▁length ▁; ▁i ▁++ ▁) ▁div is ors ▁[ ▁i ▁] ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁k ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁2 ▁* ▁i ▁; ▁j ▁<= ▁k ▁; ▁j ▁+= ▁i ▁) ▁{ ▁div is ors ▁[ ▁j ▁] ▁. ▁add ▁( ▁i ▁) ▁; ▁} ▁} ▁int ▁[ ▁] ▁[ ▁] ▁dp ▁= ▁new ▁int ▁[ ▁n ▁+ ▁1 ▁] ▁[ ▁k ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁<= ▁k ▁; ▁j ▁++ ▁) ▁{ ▁dp ▁[ ▁1 ▁] ▁[ ▁j ▁] ▁= ▁1 ▁; ▁} ▁for ▁( ▁int ▁x ▁= ▁2 ▁; ▁x ▁<= ▁n ▁; ▁x ▁++ ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁<= ▁k ▁; ▁j ▁++ ▁) ▁{ ▁sum ▁+= ▁dp ▁[ ▁x ▁- ▁1 ▁] ▁[ ▁j ▁] ▁; ▁} ▁for ▁( ▁int ▁y ▁= ▁1 ▁; ▁y ▁<= ▁k ▁; ▁y ▁++ ▁) ▁{ ▁dp ▁[ ▁x ▁] ▁[ ▁y ▁] ▁= ▁sum ▁; ▁for ▁( ▁int ▁d ▁: ▁div is ors ▁[ ▁y ▁] ▁) ▁{ ▁dp ▁[ ▁x ▁] ▁[ ▁y ▁] ▁= ▁( ▁dp ▁[ ▁x ▁] ▁[ ▁y ▁] ▁- ▁dp ▁[ ▁x ▁- ▁1 ▁] ▁[ ▁d ▁] ▁) ▁; ▁} ▁} ▁} ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁<= ▁k ▁; ▁j ▁++ ▁) ▁{ ▁sum ▁+= ▁dp ▁[ ▁n ▁] ▁[ ▁j ▁] ▁; ▁} ▁return ▁sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁2 ▁, ▁K ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁count Arrays ▁( ▁N ▁, ▁K ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁public ▁static ▁int ▁find Maximum Points ▁( ▁int ▁N ▁, ▁int ▁X ▁[ ▁] ▁, ▁int ▁H ▁[ ▁] ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁int ▁prev ▁= ▁Integer ▁. ▁MIN _ VALUE ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁prev ▁< ▁( ▁X ▁[ ▁i ▁] ▁- ▁H ▁[ ▁i ▁] ▁) ▁) ▁{ ▁++ ▁ans ▁; ▁prev ▁= ▁X ▁[ ▁i ▁] ▁; ▁} ▁else ▁if ▁( ▁i ▁== ▁N ▁- ▁1 ▁|| ▁( ▁X ▁[ ▁i ▁] ▁+ ▁H ▁[ ▁i ▁] ▁) ▁< ▁X ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁{ ▁++ ▁ans ▁; ▁prev ▁= ▁X ▁[ ▁i ▁] ▁+ ▁H ▁[ ▁i ▁] ▁; ▁} ▁else ▁{ ▁prev ▁= ▁X ▁[ ▁i ▁] ▁; ▁} ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁X ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁; ▁int ▁H ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁5 ▁, ▁5 ▁} ▁; ▁int ▁N ▁= ▁X ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Maximum Points ▁( ▁N ▁, ▁X ▁, ▁H ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁public ▁class ▁MyClass ▁{ ▁static ▁void ▁possible Numbers ▁( ▁Set ▁< ▁Integer ▁> ▁numbers ▁, ▁int ▁N ▁, ▁int ▁M ▁, ▁int ▁A ▁, ▁int ▁B ▁) ▁{ ▁if ▁( ▁M ▁== ▁0 ▁) ▁{ ▁numbers ▁. ▁add ▁( ▁N ▁) ▁; ▁return ▁; ▁} ▁possible Numbers ▁( ▁numbers ▁, ▁N ▁+ ▁A ▁, ▁M ▁- ▁1 ▁, ▁A ▁, ▁B ▁) ▁; ▁possible Numbers ▁( ▁numbers ▁, ▁N ▁+ ▁B ▁, ▁M ▁- ▁1 ▁, ▁A ▁, ▁B ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁N ▁= ▁5 ▁, ▁M ▁= ▁3 ▁, ▁A ▁= ▁4 ▁, ▁B ▁= ▁6 ▁; ▁Set ▁< ▁Integer ▁> ▁numbers ▁= ▁new ▁HashSet ▁< ▁Integer ▁> ▁( ▁) ▁; ▁possible Numbers ▁( ▁numbers ▁, ▁N ▁, ▁M ▁, ▁A ▁, ▁B ▁) ▁; ▁Iterator ▁< ▁Integer ▁> ▁i ▁= ▁numbers ▁. ▁iterator ▁( ▁) ▁; ▁while ▁( ▁i ▁. ▁hasNext ▁( ▁) ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁i ▁. ▁next ▁( ▁) ▁+ ▁" ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁reduce ToOne ▁( ▁long ▁N ▁) ▁{ ▁int ▁cnt ▁= ▁0 ▁; ▁while ▁( ▁N ▁!= ▁1 ▁) ▁{ ▁if ▁( ▁N ▁== ▁2 ▁|| ▁( ▁N ▁% ▁2 ▁== ▁1 ▁) ▁) ▁{ ▁N ▁= ▁N ▁- ▁1 ▁; ▁cnt ▁++ ▁; ▁} ▁else ▁if ▁( ▁N ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁N ▁= ▁N ▁/ ▁( ▁N ▁/ ▁2 ▁) ▁; ▁cnt ▁++ ▁; ▁} ▁} ▁return ▁cnt ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁long ▁N ▁= ▁35 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁reduce ToOne ▁( ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁Vector ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁solve ▁( ▁int ▁S ▁, ▁int ▁K ▁, ▁int ▁N ▁) ▁{ ▁if ▁( ▁K ▁> ▁N ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁- ▁1" ▁) ▁; ▁return ▁; ▁} ▁int ▁max _ sum ▁= ▁0 ▁, ▁min _ sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁K ▁; ▁i ▁++ ▁) ▁{ ▁min _ sum ▁+= ▁i ▁; ▁max _ sum ▁+= ▁N ▁- ▁i ▁+ ▁1 ▁; ▁} ▁if ▁( ▁S ▁< ▁min _ sum ▁S ▁> ▁max _ sum ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁- ▁1" ▁) ▁; ▁return ▁; ▁} ▁int ▁s 1 ▁= ▁0 ▁; ▁Vector ▁< ▁Integer ▁> ▁nums ▁= ▁new ▁Vector ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s 1 ▁> ▁S ▁) ▁break ▁; ▁s 1 ▁+= ▁i ▁; ▁nums ▁. ▁add ▁( ▁i ▁) ▁; ▁} ▁Vector ▁< ▁Integer ▁> ▁answer ▁= ▁new ▁Vector ▁< ▁> ▁( ▁) ▁; ▁int ▁s 2 ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁K ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁answer ▁. ▁add ▁( ▁nums ▁. ▁get ▁( ▁i ▁) ▁) ▁; ▁s 2 ▁+= ▁nums ▁. ▁get ▁( ▁i ▁) ▁; ▁} ▁answer ▁. ▁add ▁( ▁S ▁- ▁s 2 ▁) ▁; ▁int ▁Max ▁= ▁N ▁; ▁for ▁( ▁int ▁i ▁= ▁answer ▁. ▁size ▁( ▁) ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁answer ▁. ▁get ▁( ▁i ▁) ▁> ▁Max ▁) ▁{ ▁int ▁extra ▁= ▁answer ▁. ▁get ▁( ▁i ▁) ▁- ▁Max ▁; ▁if ▁( ▁i ▁- ▁1 ▁>= ▁0 ▁) ▁answer ▁. ▁set ▁( ▁i ▁- ▁1 ▁, ▁answer ▁. ▁get ▁( ▁i ▁- ▁1 ▁) ▁+ ▁extra ▁) ▁; ▁answer ▁. ▁set ▁( ▁i ▁, ▁Max ▁) ▁; ▁Max ▁-- ▁; ▁} ▁else ▁break ▁; ▁} ▁for ▁( ▁int ▁x ▁: ▁answer ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁x ▁+ ▁" ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁S ▁= ▁15 ▁, ▁K ▁= ▁4 ▁, ▁N ▁= ▁8 ▁; ▁solve ▁( ▁S ▁, ▁K ▁, ▁N ▁)
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁minSize Arr ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁sum ▁+= ▁A ▁[ ▁i ▁] ▁; ▁if ▁( ▁K ▁> ▁sum ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁- ▁1 ▁) ▁; ▁return ▁; ▁} ▁if ▁( ▁K ▁== ▁sum ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁A ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁return ▁; ▁} ▁int ▁tar ▁= ▁sum ▁- ▁K ▁; ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁um ▁= ▁new ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁( ▁) ▁; ▁um ▁. ▁put ▁( ▁0 ▁, ▁- ▁1 ▁) ▁; ▁int ▁left ▁= ▁0 ▁, ▁right ▁= ▁0 ▁; ▁int ▁cur ▁= ▁0 ▁, ▁max i ▁= ▁- ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁cur ▁+= ▁A ▁[ ▁i ▁] ▁; ▁if ▁( ▁um ▁. ▁containsKey ▁( ▁cur ▁- ▁tar ▁) ▁&& ▁i ▁- ▁um ▁. ▁get ▁( ▁cur ▁- ▁tar ▁) ▁> ▁max i ▁) ▁{ ▁max i ▁= ▁i ▁- ▁um ▁. ▁get ▁( ▁cur ▁- ▁tar ▁) ▁; ▁right ▁= ▁i ▁; ▁left ▁= ▁um ▁. ▁get ▁( ▁cur ▁- ▁tar ▁) ▁; ▁} ▁if ▁( ▁! ▁um ▁. ▁containsKey ▁( ▁cur ▁) ▁) ▁um ▁. ▁put ▁( ▁cur ▁, ▁i ▁) ▁; ▁} ▁if ▁( ▁max i ▁== ▁- ▁1 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁- ▁1 ▁) ▁; ▁else ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁left ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁A ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁right ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁A ▁[ ▁N ▁- ▁i ▁- ▁1 ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁7 ▁; ▁int ▁A ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁2 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁3 ▁} ▁; ▁int ▁K ▁=
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁find Equ ation ▁( ▁int ▁A ▁, ▁int ▁B ▁, ▁int ▁C ▁, ▁int ▁K ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁A ▁+ ▁" ▁" ▁+ ▁K ▁* ▁B ▁+ ▁" ▁" ▁+ ▁K ▁* ▁K ▁* ▁C ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁A ▁= ▁1 ▁, ▁B ▁= ▁2 ▁, ▁C ▁= ▁1 ▁, ▁K ▁= ▁2 ▁; ▁find Equ ation ▁( ▁A ▁, ▁B ▁, ▁C ▁, ▁K ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁can Array Be Red uced ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁N ▁) ▁{ ▁if ▁( ▁N ▁== ▁1 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁return ▁; ▁} ▁if ▁( ▁arr ▁[ ▁0 ▁] ▁< ▁arr ▁[ ▁N ▁- ▁1 ▁] ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁N ▁- ▁1 ▁] ▁) ▁; ▁} ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Not ▁Possible ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁6 ▁, ▁5 ▁, ▁2 ▁, ▁4 ▁, ▁1 ▁, ▁3 ▁, ▁7 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁can Array Be Red uced ▁( ▁arr ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁construct Array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁br r ▁[ ▁] ▁= ▁new ▁int ▁[ ▁N ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁int ▁K ▁= ▁( ▁int ▁) ▁( ▁Math ▁. ▁log ▁( ▁arr ▁[ ▁i ▁] ▁) ▁/ ▁Math ▁. ▁log ▁( ▁2 ▁) ▁) ▁; ▁int ▁R ▁= ▁( ▁int ▁) ▁Math ▁. ▁pow ▁( ▁2 ▁, ▁K ▁) ▁; ▁br r ▁[ ▁i ▁] ▁= ▁R ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁br r ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁11 ▁, ▁5 ▁, ▁7 ▁, ▁3 ▁, ▁2 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁construct Array ▁( ▁arr ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁min Ops To Turn Arr To Zero ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁N ▁) ▁{ ▁Set ▁< ▁Integer ▁> ▁st ▁= ▁new ▁HashSet ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁st ▁. ▁contains ▁( ▁arr ▁[ ▁i ▁] ▁) ▁arr ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁continue ▁; ▁} ▁else ▁{ ▁st ▁. ▁add ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁st ▁. ▁size ▁( ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁7 ▁, ▁3 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁min Ops To Turn Arr To Zero ▁( ▁arr ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁Check All Equal ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁0 ▁] ▁!= ▁arr ▁[ ▁i ▁] ▁) ▁{ ▁return ▁false ▁; ▁} ▁} ▁return ▁true ▁; ▁} ▁static ▁int ▁min Cnt Operations ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁Max ▁= ▁Arrays ▁. ▁stream ▁( ▁arr ▁) ▁. ▁max ▁( ▁) ▁. ▁getAs Int ▁( ▁) ▁; ▁boolean ▁is Power 2 ▁; ▁if ▁( ▁( ▁int ▁) ▁( ▁Math ▁. ▁ceil ▁( ▁( ▁Math ▁. ▁log ▁( ▁N ▁) ▁/ ▁Math ▁. ▁log ▁( ▁N ▁) ▁) ▁) ▁) ▁== ▁( ▁int ▁) ▁( ▁Math ▁. ▁floor ▁( ▁( ▁( ▁Math ▁. ▁log ▁( ▁N ▁) ▁/ ▁Math ▁. ▁log ▁( ▁2 ▁) ▁) ▁) ▁) ▁) ▁) ▁{ ▁is Power 2 ▁= ▁true ▁; ▁} ▁else ▁{ ▁is Power 2 ▁= ▁false ▁; ▁} ▁if ▁( ▁is Power 2 ▁&& ▁Check All Equal ▁( ▁arr ▁, ▁N ▁) ▁) ▁{ ▁return ▁( ▁int ▁) ▁( ▁Math ▁. ▁log ▁( ▁Max ▁) ▁/ ▁Math ▁. ▁log ▁( ▁2 ▁) ▁) ▁; ▁} ▁else ▁{ ▁return ▁( ▁int ▁) ▁Math ▁. ▁ceil ▁( ▁Math ▁. ▁log ▁( ▁Max ▁) ▁/ ▁Math ▁. ▁log ▁( ▁2 ▁) ▁) ▁+ ▁1 ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁new ▁int ▁[ ▁] ▁{ ▁2 ▁, ▁4 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁min Cnt Operations ▁( ▁arr ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁find Max Val By Re arr Arr ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁arr ▁) ▁; ▁int ▁res ▁= ▁0 ▁; ▁do ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁__ g cd ▁( ▁i ▁+ ▁1 ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁res ▁= ▁Math ▁. ▁max ▁( ▁res ▁, ▁sum ▁) ▁; ▁} ▁while ▁( ▁next _ perm utation ▁( ▁arr ▁) ▁) ▁; ▁return ▁res ▁; ▁} ▁static ▁int ▁__ g cd ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁return ▁b ▁== ▁0 ▁? ▁a ▁: ▁__ g cd ▁( ▁b ▁, ▁a ▁% ▁b ▁) ▁; ▁} ▁static ▁boolean ▁next _ perm utation ▁( ▁int ▁[ ▁] ▁p ▁) ▁{ ▁for ▁( ▁int ▁a ▁= ▁p ▁. ▁length ▁- ▁2 ▁; ▁a ▁>= ▁0 ▁; ▁-- ▁a ▁) ▁if ▁( ▁p ▁[ ▁a ▁] ▁< ▁p ▁[ ▁a ▁+ ▁1 ▁] ▁) ▁for ▁( ▁int ▁b ▁= ▁p ▁. ▁length ▁- ▁1 ▁; ▁; ▁-- ▁b ▁) ▁if ▁( ▁p ▁[ ▁b ▁] ▁> ▁p ▁[ ▁a ▁] ▁) ▁{ ▁int ▁t ▁= ▁p ▁[ ▁a ▁] ▁; ▁p ▁[ ▁a ▁] ▁= ▁p ▁[ ▁b ▁] ▁; ▁p ▁[ ▁b ▁] ▁= ▁t ▁; ▁for ▁( ▁++ ▁a ▁, ▁b ▁= ▁p ▁. ▁length ▁- ▁1 ▁; ▁a ▁< ▁b ▁; ▁++ ▁a ▁, ▁-- ▁b ▁) ▁{ ▁t ▁= ▁p ▁[ ▁a ▁] ▁; ▁p ▁[ ▁a ▁] ▁= ▁p ▁[ ▁b ▁] ▁; ▁p ▁[ ▁b ▁] ▁= ▁t ▁; ▁} ▁return ▁true ▁; ▁} ▁return ▁false ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁2 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁find Max Val By Re arr Arr ▁( ▁arr ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁sum zero ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁if ▁( ▁sum ▁== ▁0 ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁if ▁( ▁sum ▁> ▁0 ▁) ▁{ ▁if ▁( ▁sum ▁% ▁K ▁== ▁0 ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁No ▁" ▁) ▁; ▁return ▁0 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁K ▁, ▁N ▁; ▁int ▁arr 1 ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁- ▁6 ▁, ▁2 ▁, ▁2 ▁} ▁; ▁K ▁= ▁1 ▁; ▁N ▁= ▁arr 1 ▁. ▁length ▁; ▁sum zero ▁( ▁arr 1 ▁, ▁N ▁, ▁K ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁path _ to _ root ▁( ▁int ▁node ▁) ▁{ ▁while ▁( ▁node ▁>= ▁1 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁node ▁+ ▁" ▁" ▁) ▁; ▁node ▁/= ▁2 ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁7 ▁; ▁path _ to _ root ▁( ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁find Small est Number Possible ▁( ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁if ▁( ▁N ▁> ▁45 ▁* ▁K ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁- ▁1" ▁) ▁; ▁return ▁; ▁} ▁StringBuilder ▁res ▁= ▁new ▁StringBuilder ▁( ▁) ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁9 ▁; ▁i ▁>= ▁1 ▁{ ▁if ▁( ▁count ▁== ▁K ▁) ▁{ ▁i ▁-- ▁; ▁count ▁= ▁0 ▁; ▁} ▁if ▁( ▁N ▁> ▁i ▁) ▁{ ▁N ▁-= ▁i ▁; ▁res ▁. ▁append ▁( ▁( ▁char ▁) ▁( ▁'0' ▁+ ▁i ▁) ▁) ▁; ▁} ▁else ▁{ ▁res ▁. ▁append ▁( ▁( ▁char ▁) ▁( ▁'0' ▁+ ▁N ▁) ▁) ▁; ▁N ▁= ▁0 ▁; ▁break ▁; ▁} ▁count ▁++ ▁; ▁} ▁res ▁. ▁reverse ▁( ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁res ▁. ▁toString ▁( ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁25 ▁, ▁K ▁= ▁3 ▁; ▁find Small est Number Possible ▁( ▁N ▁, ▁K ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁result ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁> ▁45 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁- ▁1 ▁) ▁; ▁return ▁; ▁} ▁String ▁res ▁= ▁" ▁" ▁; ▁int ▁digit ▁= ▁9 ▁; ▁while ▁( ▁n ▁> ▁digit ▁) ▁{ ▁res ▁= ▁( ▁char ▁) ▁( ▁'0' ▁+ ▁digit ▁) ▁+ ▁res ▁; ▁n ▁-= ▁digit ▁; ▁digit ▁-= ▁1 ▁; ▁} ▁if ▁( ▁n ▁> ▁0 ▁) ▁{ ▁res ▁= ▁( ▁char ▁) ▁( ▁'0' ▁+ ▁n ▁) ▁+ ▁res ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁res ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁19 ▁; ▁result ▁( ▁N ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁find Numbers ▁( ▁int ▁a X OR b ▁, ▁int ▁a AND b ▁, ▁int ▁a X OR c ▁, ▁int ▁a AND c ▁, ▁int ▁b X OR c ▁, ▁int ▁b AND c ▁) ▁{ ▁int ▁a ▁, ▁b ▁, ▁c ▁; ▁int ▁a SUM b ▁; ▁int ▁a SUM c ▁; ▁int ▁b SUM c ▁; ▁a SUM b ▁= ▁a X OR b ▁+ ▁a AND b ▁* ▁2 ▁; ▁a SUM c ▁= ▁a X OR c ▁+ ▁a AND c ▁* ▁2 ▁; ▁b SUM c ▁= ▁b X OR c ▁+ ▁b AND c ▁* ▁2 ▁; ▁a ▁= ▁( ▁a SUM b ▁- ▁b SUM c ▁+ ▁a SUM c ▁) ▁/ ▁2 ▁; ▁b ▁= ▁a SUM b ▁- ▁a ▁; ▁c ▁= ▁a SUM c ▁- ▁a ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁a ▁= ▁" ▁+ ▁a ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁, ▁b ▁= ▁" ▁+ ▁b ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁, ▁c ▁= ▁" ▁+ ▁c ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a X OR b ▁= ▁30 ▁, ▁a AND b ▁= ▁0 ▁, ▁a X OR c ▁= ▁20 ▁, ▁a AND c ▁= ▁10 ▁, ▁b X OR c ▁= ▁10 ▁, ▁b AND c ▁= ▁20 ▁; ▁find Numbers ▁( ▁a X OR b ▁, ▁a AND b ▁, ▁a X OR c ▁, ▁a AND c ▁, ▁b X OR c ▁, ▁b AND c ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁find Number ▁( ▁int ▁N ▁) ▁{ ▁return ▁N ▁& ▁( ▁N ▁+ ▁1 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁39 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁find Number ▁( ▁N ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁find Bit wise OR Given X OR AND ▁( ▁int ▁X ▁, ▁int ▁Y ▁) ▁{ ▁return ▁X ▁+ ▁Y ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁X ▁= ▁5 ▁, ▁Y ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁find Bit wise OR Given X OR AND ▁( ▁X ▁, ▁Y ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁min Operation ▁( ▁int ▁X ▁[ ▁] ▁, ▁int ▁Y ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁C ▁= ▁0 ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁= ▁i ▁+ ▁2 ▁) ▁{ ▁if ▁( ▁X ▁[ ▁i ▁] ▁!= ▁Y ▁[ ▁i ▁] ▁) ▁{ ▁count ▁++ ▁; ▁} ▁else ▁{ ▁if ▁( ▁count ▁!= ▁0 ▁) ▁C ▁++ ▁; ▁count ▁= ▁0 ▁; ▁} ▁} ▁if ▁( ▁count ▁!= ▁0 ▁) ▁C ▁++ ▁; ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁= ▁i ▁+ ▁2 ▁) ▁{ ▁if ▁( ▁X ▁[ ▁i ▁] ▁!= ▁Y ▁[ ▁i ▁] ▁) ▁{ ▁count ▁++ ▁; ▁} ▁else ▁{ ▁if ▁( ▁count ▁!= ▁0 ▁) ▁C ▁++ ▁; ▁count ▁= ▁0 ▁; ▁} ▁} ▁if ▁( ▁count ▁!= ▁0 ▁) ▁C ▁++ ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁C ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁X ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁} ▁; ▁int ▁Y ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁X ▁. ▁length ▁; ▁min Operation ▁( ▁X ▁, ▁Y ▁, ▁N ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁Remove _ one _ element ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁post _ odd ▁= ▁0 ▁, ▁post _ even ▁= ▁0 ▁; ▁int ▁curr _ odd ▁= ▁0 ▁, ▁curr _ even ▁= ▁0 ▁; ▁int ▁res ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁i ▁% ▁2 ▁!= ▁0 ▁) ▁post _ odd ▁^= ▁arr ▁[ ▁i ▁] ▁; ▁else ▁post _ even ▁^= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁% ▁2 ▁!= ▁0 ▁) ▁post _ odd ▁^= ▁arr ▁[ ▁i ▁] ▁; ▁else ▁post _ even ▁^= ▁arr ▁[ ▁i ▁] ▁; ▁int ▁X ▁= ▁curr _ odd ▁^ ▁post _ even ▁; ▁int ▁Y ▁= ▁curr _ even ▁^ ▁post _ odd ▁; ▁if ▁( ▁X ▁== ▁Y ▁) ▁res ▁++ ▁; ▁if ▁( ▁i ▁% ▁2 ▁!= ▁0 ▁) ▁curr _ odd ▁^= ▁arr ▁[ ▁i ▁] ▁; ▁else ▁curr _ even ▁^= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁res ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁Remove _ one _ element ▁( ▁arr ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁void ▁min Cost ▁( ▁int ▁[ ▁] ▁arr ▁) ▁{ ▁int ▁odd ▁= ▁0 ▁, ▁even ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁arr ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁% ▁2 ▁== ▁0 ▁) ▁even ▁++ ▁; ▁else ▁odd ▁++ ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁Math ▁. ▁min ▁( ▁even ▁, ▁odd ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁G F G ▁obj ▁= ▁new ▁G F G ▁( ▁) ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁; ▁obj ▁. ▁min Cost ▁( ▁arr ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁solution ▁{ ▁static ▁int ▁GC D ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁if ▁( ▁b ▁== ▁0 ▁) ▁return ▁a ▁; ▁return ▁GC D ▁( ▁b ▁, ▁a ▁% ▁b ▁) ▁; ▁} ▁static ▁int ▁find Partition ▁( ▁int ▁nums ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁[ ▁] ▁prefix ▁= ▁new ▁int ▁[ ▁N ▁] ▁; ▁int ▁[ ▁] ▁suffix ▁= ▁new ▁int ▁[ ▁N ▁] ▁; ▁int ▁i ▁, ▁k ▁; ▁prefix ▁[ ▁0 ▁] ▁= ▁nums ▁[ ▁0 ▁] ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁prefix ▁[ ▁i ▁] ▁= ▁prefix ▁[ ▁i ▁- ▁1 ▁] ▁* ▁nums ▁[ ▁i ▁] ▁; ▁} ▁suffix ▁[ ▁N ▁- ▁1 ▁] ▁= ▁nums ▁[ ▁N ▁- ▁1 ▁] ▁; ▁for ▁( ▁i ▁= ▁N ▁- ▁2 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁suffix ▁[ ▁i ▁] ▁= ▁suffix ▁[ ▁i ▁+ ▁1 ▁] ▁* ▁nums ▁[ ▁i ▁] ▁; ▁} ▁for ▁( ▁k ▁= ▁0 ▁; ▁k ▁< ▁N ▁- ▁1 ▁; ▁k ▁++ ▁) ▁{ ▁if ▁( ▁GC D ▁( ▁prefix ▁[ ▁k ▁] ▁, ▁suffix ▁[ ▁k ▁+ ▁1 ▁] ▁) ▁== ▁1 ▁) ▁{ ▁return ▁k ▁; ▁} ▁} ▁return ▁- ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Partition ▁( ▁arr ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁class ▁pair ▁{ ▁int ▁first ▁, ▁second ▁; ▁public ▁pair ▁( ▁int ▁first ▁, ▁int ▁second ▁) ▁{ ▁this ▁. ▁first ▁= ▁first ▁; ▁this ▁. ▁second ▁= ▁second ▁; ▁} ▁} ▁static ▁void ▁pal indrome Matrix ▁( ▁int ▁N ▁, ▁int ▁M ▁, ▁int ▁[ ▁] ▁[ ▁] ▁arr ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁( ▁N ▁+ ▁1 ▁) ▁/ ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁( ▁M ▁+ ▁1 ▁) ▁/ ▁2 ▁; ▁j ▁++ ▁) ▁{ ▁HashSet ▁< ▁pair ▁> ▁s ▁= ▁new ▁HashSet ▁< ▁> ▁( ▁) ▁; ▁s ▁. ▁add ▁( ▁new ▁pair ▁( ▁i ▁, ▁j ▁) ▁) ▁; ▁s ▁. ▁add ▁( ▁new ▁pair ▁( ▁i ▁, ▁M ▁- ▁j ▁- ▁1 ▁) ▁) ▁; ▁s ▁. ▁add ▁( ▁new ▁pair ▁( ▁N ▁- ▁i ▁- ▁1 ▁, ▁j ▁) ▁) ▁; ▁s ▁. ▁add ▁( ▁new ▁pair ▁( ▁N ▁- ▁i ▁- ▁1 ▁, ▁M ▁- ▁j ▁- ▁1 ▁) ▁) ▁; ▁Vector ▁< ▁Integer ▁> ▁values ▁= ▁new ▁Vector ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁pair ▁p ▁: ▁s ▁) ▁{ ▁values ▁. ▁add ▁( ▁arr ▁[ ▁p ▁. ▁first ▁] ▁[ ▁p ▁. ▁second ▁] ▁) ▁; ▁} ▁int ▁max ▁= ▁Collections ▁. ▁max ▁( ▁values ▁) ▁; ▁for ▁( ▁int ▁k ▁= ▁1 ▁; ▁k ▁< ▁values ▁. ▁size ▁( ▁) ▁; ▁k ▁++ ▁) ▁{ ▁ans ▁+= ▁max ▁- ▁values ▁. ▁get ▁( ▁k ▁) ▁; ▁} ▁} ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁ans ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁3 ▁, ▁M ▁= ▁3 ▁; ▁int ▁[ ▁] ▁[ ▁] ▁arr ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁, ▁1 ▁} ▁, ▁{ ▁3 ▁, ▁4 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁2 ▁, ▁1 ▁} ▁} ▁; ▁pal indrome Matrix ▁( ▁N ▁, ▁M ▁, ▁arr ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁ArrayList ▁< ▁Integer ▁> ▁re arrange Array ▁( ▁ArrayList ▁< ▁Integer ▁> ▁A ▁, ▁ArrayList ▁< ▁Integer ▁> ▁B ▁, ▁int ▁N ▁) ▁{ ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁m ▁= ▁new ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁( ▁) ▁; ▁int ▁xor _ value ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁xor _ value ▁^= ▁A ▁. ▁get ▁( ▁i ▁) ▁; ▁xor _ value ▁^= ▁B ▁. ▁get ▁( ▁i ▁) ▁; ▁m ▁. ▁put ▁( ▁B ▁. ▁get ▁( ▁i ▁) ▁, ▁m ▁. ▁getOr Default ▁( ▁B ▁. ▁get ▁( ▁i ▁) ▁+ ▁1 ▁, ▁0 ▁) ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁B ▁. ▁set ▁( ▁i ▁, ▁A ▁. ▁get ▁( ▁i ▁) ▁^ ▁xor _ value ▁) ▁; ▁if ▁( ▁m ▁. ▁getOr Default ▁( ▁B ▁. ▁get ▁( ▁i ▁) ▁, ▁- ▁1 ▁) ▁!= ▁- ▁1 ▁) ▁{ ▁m ▁. ▁put ▁( ▁B ▁. ▁get ▁( ▁i ▁) ▁, ▁m ▁. ▁getOr Default ▁( ▁B ▁. ▁get ▁( ▁i ▁) ▁, ▁0 ▁) ▁- ▁1 ▁) ▁; ▁} ▁else ▁return ▁( ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁) ▁; ▁} ▁return ▁B ▁; ▁} ▁static ▁void ▁re arrange Array Util ▁( ▁ArrayList ▁< ▁Integer ▁> ▁A ▁, ▁ArrayList ▁< ▁Integer ▁> ▁B ▁, ▁int ▁N ▁) ▁{ ▁ArrayList ▁< ▁Integer ▁> ▁ans ▁= ▁re arrange Array ▁( ▁A ▁, ▁B ▁, ▁N ▁) ▁; ▁if ▁( ▁ans ▁. ▁size ▁( ▁) ▁!= ▁0 ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁ans ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁ans ▁. ▁get ▁( ▁i ▁) ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁- ▁1" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁ArrayList ▁< ▁Integer ▁> ▁A ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁Arrays ▁. ▁asList ▁( ▁13 ▁, ▁21 ▁, ▁33 ▁, ▁49 ▁, ▁53 ▁) ▁) ▁; ▁ArrayList ▁< ▁Integer ▁> ▁B ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁Arrays ▁. ▁asList ▁( ▁54 ▁, ▁50
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁count Of Sub array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁Map ▁< ▁Integer ▁, ▁Integer ▁> ▁mp ▁= ▁new ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁( ▁) ▁; ▁int ▁answer ▁= ▁0 ▁; ▁int ▁sum ▁= ▁0 ▁; ▁if ▁( ▁mp ▁. ▁get ▁( ▁1 ▁) ▁!= ▁null ▁) ▁mp ▁. ▁put ▁( ▁1 ▁, ▁mp ▁. ▁get ▁( ▁1 ▁) ▁+ ▁1 ▁) ▁; ▁else ▁mp ▁. ▁put ▁( ▁1 ▁, ▁1 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁if ▁( ▁mp ▁. ▁get ▁( ▁sum ▁- ▁i ▁) ▁!= ▁null ▁) ▁answer ▁+= ▁mp ▁. ▁get ▁( ▁sum ▁- ▁i ▁) ▁; ▁if ▁( ▁mp ▁. ▁get ▁( ▁sum ▁- ▁i ▁) ▁!= ▁null ▁) ▁mp ▁. ▁put ▁( ▁sum ▁- ▁i ▁, ▁mp ▁. ▁get ▁( ▁sum ▁- ▁i ▁) ▁+ ▁1 ▁) ▁; ▁else ▁mp ▁. ▁put ▁( ▁sum ▁- ▁i ▁, ▁1 ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁answer ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁0 ▁, ▁2 ▁, ▁1 ▁, ▁2 ▁, ▁- ▁2 ▁, ▁2 ▁, ▁4 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁count Of Sub array ▁( ▁arr ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁gcd ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁if ▁( ▁a ▁== ▁0 ▁) ▁return ▁b ▁; ▁return ▁gcd ▁( ▁b ▁% ▁a ▁, ▁a ▁) ▁; ▁} ▁static ▁void ▁count Inverse ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁N ▁, ▁int ▁M ▁) ▁{ ▁int ▁XOR ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁int ▁gcd Of M and element ▁= ▁gcd ▁( ▁M ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁if ▁( ▁gcd Of M and element ▁== ▁1 ▁) ▁{ ▁XOR ▁^= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁XOR ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁; ▁int ▁M ▁= ▁4 ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁count Inverse ▁( ▁arr ▁, ▁N ▁, ▁M ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁public ▁static ▁int ▁Total X or Pair ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁total X OR ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁total X OR ▁^= ▁arr ▁[ ▁i ▁] ▁^ ▁arr ▁[ ▁j ▁] ▁; ▁} ▁} ▁return ▁total X OR ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁Total X or Pair ▁( ▁arr ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁possible A cy c lic Graph ▁( ▁int ▁N ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁( ▁int ▁) ▁Math ▁. ▁pow ▁( ▁2 ▁, ▁N ▁- ▁1 ▁) ▁) ▁; ▁return ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁4 ▁; ▁possible A cy c lic Graph ▁( ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁is Composite ▁( ▁int ▁N ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁* ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁N ▁% ▁i ▁== ▁0 ▁) ▁{ ▁return ▁true ▁; ▁} ▁} ▁return ▁false ▁; ▁} ▁static ▁int ▁composite Pair ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁res ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁int ▁prod ▁= ▁arr ▁[ ▁i ▁] ▁* ▁arr ▁[ ▁j ▁] ▁; ▁if ▁( ▁is Composite ▁( ▁prod ▁) ▁) ▁{ ▁res ▁++ ▁; ▁} ▁} ▁} ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁1 ▁, ▁2 ▁, ▁2 ▁, ▁8 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁composite Pair ▁( ▁arr ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁find _ next ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁M ▁= ▁n ▁+ ▁1 ▁; ▁while ▁( ▁true ▁) ▁{ ▁if ▁( ▁( ▁M ▁& ▁( ▁1 L ▁<< ▁k ▁) ▁) ▁> ▁0 ▁) ▁break ▁; ▁M ▁++ ▁; ▁} ▁return ▁M ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁15 ▁, ▁K ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁find _ next ▁( ▁N ▁, ▁K ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁maximum Sub arrays ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁target ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁int ▁avail Idx ▁= ▁- ▁1 ▁; ▁int ▁cur _ sum ▁= ▁0 ▁; ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁mp ▁= ▁new ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁( ▁) ▁; ▁mp ▁. ▁put ▁( ▁0 ▁, ▁1 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁cur _ sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁if ▁( ▁mp ▁. ▁containsKey ▁( ▁cur _ sum ▁- ▁target ▁) ▁&& ▁mp ▁. ▁get ▁( ▁cur _ sum ▁- ▁target ▁) ▁>= ▁avail Idx ▁) ▁{ ▁ans ▁++ ▁; ▁avail Idx ▁= ▁i ▁; ▁} ▁mp ▁. ▁put ▁( ▁cur _ sum ▁, ▁i ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁- ▁1 ▁, ▁4 ▁, ▁3 ▁, ▁6 ▁, ▁4 ▁, ▁5 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁int ▁target ▁= ▁6 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁maximum Sub arrays ▁( ▁arr ▁, ▁N ▁, ▁target ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁getCount ▁( ▁int ▁N ▁, ▁int ▁M ▁) ▁{ ▁int ▁total _ count ▁= ▁0 ▁; ▁total _ count ▁+= ▁( ▁N ▁/ ▁10 ▁) ▁; ▁int ▁x ▁= ▁( ▁N ▁/ ▁10 ▁) ▁* ▁10 ▁; ▁if ▁( ▁( ▁N ▁- ▁x ▁) ▁>= ▁M ▁) ▁{ ▁total _ count ▁= ▁total _ count ▁+ ▁1 ▁; ▁} ▁return ▁total _ count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁100 ▁, ▁M ▁= ▁1 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁getCount ▁( ▁N ▁, ▁M ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁digits Of ▁( ▁int ▁num ▁) ▁{ ▁return ▁Integer ▁. ▁toString ▁( ▁num ▁) ▁. ▁length ▁( ▁) ▁; ▁} ▁static ▁int ▁count ▁( ▁int ▁a ▁, ▁int ▁tn ▁) ▁{ ▁int ▁diff ▁= ▁( ▁int ▁) ▁Math ▁. ▁pow ▁( ▁10 ▁, ▁digits Of ▁( ▁a ▁) ▁) ▁; ▁return ▁( ▁( ▁tn ▁- ▁a ▁) ▁/ ▁diff ▁) ▁+ ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁25 ▁, ▁m ▁= ▁4 500 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count ▁( ▁n ▁, ▁m ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁min Operations ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁num _ of _ ops 1 ▁, ▁num _ of _ ops 2 ▁, ▁sum ▁; ▁num _ of _ ops 1 ▁= ▁num _ of _ ops 2 ▁= ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁a ▁[ ▁i ▁] ▁; ▁if ▁( ▁i ▁% ▁2 ▁== ▁0 ▁&& ▁sum ▁>= ▁0 ▁) ▁{ ▁num _ of _ ops 1 ▁+= ▁( ▁1 ▁+ ▁Math ▁. ▁abs ▁( ▁sum ▁) ▁) ▁; ▁sum ▁= ▁- ▁1 ▁; ▁} ▁else ▁if ▁( ▁i ▁% ▁2 ▁== ▁1 ▁&& ▁sum ▁<= ▁0 ▁) ▁{ ▁num _ of _ ops 1 ▁+= ▁( ▁1 ▁+ ▁Math ▁. ▁abs ▁( ▁sum ▁) ▁) ▁; ▁sum ▁= ▁1 ▁; ▁} ▁} ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁a ▁[ ▁i ▁] ▁; ▁if ▁( ▁i ▁% ▁2 ▁== ▁1 ▁&& ▁sum ▁>= ▁0 ▁) ▁{ ▁num _ of _ ops 2 ▁+= ▁( ▁1 ▁+ ▁Math ▁. ▁abs ▁( ▁sum ▁) ▁) ▁; ▁sum ▁= ▁- ▁1 ▁; ▁} ▁else ▁if ▁( ▁i ▁% ▁2 ▁== ▁0 ▁&& ▁sum ▁<= ▁0 ▁) ▁{ ▁num _ of _ ops 2 ▁+= ▁( ▁1 ▁+ ▁Math ▁. ▁abs ▁( ▁sum ▁) ▁) ▁; ▁sum ▁= ▁1 ▁; ▁} ▁} ▁return ▁Math ▁. ▁min ▁( ▁num _ of _ ops 1 ▁, ▁num _ of _ ops 2 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁- ▁4 ▁, ▁5 ▁, ▁0 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁min Operations ▁( ▁arr ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁count Set Bits ▁( ▁int ▁L ▁, ▁int ▁R ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁L ▁; ▁i ▁<= ▁R ▁; ▁i ▁++ ▁) ▁{ ▁count ▁+= ▁Integer ▁. ▁bit Count ▁( ▁i ▁) ▁; ▁} ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁L ▁= ▁3 ▁, ▁R ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Total ▁set ▁bit ▁count ▁is ▁" ▁+ ▁count Set Bits ▁( ▁L ▁, ▁R ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁count Sw aps ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁A ▁) ▁; ▁int ▁ind ▁= ▁1 ▁, ▁res ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁while ▁( ▁ind ▁< ▁n ▁&& ▁A ▁[ ▁ind ▁] ▁== ▁A ▁[ ▁i ▁] ▁) ▁ind ▁++ ▁; ▁if ▁( ▁ind ▁< ▁n ▁&& ▁A ▁[ ▁ind ▁] ▁> ▁A ▁[ ▁i ▁] ▁) ▁{ ▁res ▁++ ▁; ▁ind ▁++ ▁; ▁} ▁if ▁( ▁ind ▁>= ▁n ▁) ▁break ▁; ▁} ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁3 ▁, ▁3 ▁, ▁2 ▁, ▁5 ▁} ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁count Sw aps ▁( ▁A ▁, ▁5 ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁int ▁numberOf Pairs ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁% ▁2 ▁== ▁0 ▁) ▁return ▁n ▁/ ▁2 ▁- ▁1 ▁; ▁else ▁return ▁n ▁/ ▁2 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁8 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁numberOf Pairs ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁N ▁= ▁100000 ▁; ▁static ▁int ▁can Take ▁; ▁static ▁int ▁best ▁; ▁static ▁int ▁[ ▁] ▁dp ▁= ▁new ▁int ▁[ ▁N ▁] ▁; ▁static ▁boolean ▁[ ▁] ▁vis ▁= ▁new ▁boolean ▁[ ▁N ▁] ▁; ▁static ▁boolean ▁dfs ▁( ▁Vector ▁< ▁Integer ▁> ▁[ ▁] ▁g ▁, ▁int ▁[ ▁] ▁cost ▁, ▁int ▁u ▁, ▁int ▁pre ▁) ▁{ ▁vis ▁[ ▁u ▁] ▁= ▁true ▁; ▁dp ▁[ ▁u ▁] ▁= ▁cost ▁[ ▁u ▁] ▁; ▁boolean ▁check ▁= ▁true ▁; ▁int ▁cur ▁= ▁cost ▁[ ▁u ▁] ▁; ▁for ▁( ▁int ▁x ▁: ▁g ▁[ ▁u ▁] ▁) ▁{ ▁if ▁( ▁vis ▁[ ▁x ▁] ▁&& ▁x ▁!= ▁pre ▁) ▁{ ▁check ▁= ▁false ▁; ▁} ▁else ▁if ▁( ▁! ▁vis ▁[ ▁x ▁] ▁) ▁{ ▁check ▁= ▁dfs ▁( ▁g ▁, ▁cost ▁, ▁x ▁, ▁u ▁) ▁? ▁false ▁: ▁true ▁; ▁cur ▁= ▁Math ▁. ▁max ▁( ▁cur ▁, ▁cost ▁[ ▁u ▁] ▁+ ▁dp ▁[ ▁x ▁] ▁) ▁; ▁} ▁} ▁dp ▁[ ▁u ▁] ▁= ▁cur ▁; ▁if ▁( ▁! ▁check ▁) ▁{ ▁can Take ▁+= ▁cost ▁[ ▁u ▁] ▁; ▁} ▁else ▁{ ▁best ▁= ▁Math ▁. ▁max ▁( ▁best ▁, ▁dp ▁[ ▁u ▁] ▁) ▁; ▁} ▁return ▁check ▁; ▁} ▁static ▁void ▁Find Max Cost ▁( ▁Vector ▁< ▁Integer ▁> ▁[ ▁] ▁g ▁, ▁int ▁[ ▁] ▁cost ▁, ▁int ▁source ▁) ▁{ ▁dfs ▁( ▁g ▁, ▁cost ▁, ▁source ▁, ▁- ▁1 ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁can Take ▁+ ▁best ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁5 ▁, ▁m ▁= ▁5 ▁; ▁int ▁cost ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁2 ▁, ▁8 ▁, ▁6 ▁, ▁9 ▁} ▁; ▁@ ▁Suppress Warnings ▁( ▁" ▁unchecked ▁" ▁) ▁Vector ▁< ▁Integer ▁> ▁[ ▁] ▁g ▁= ▁new ▁Vector ▁[ ▁n ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁g ▁. ▁length ▁; ▁i ▁++ ▁) ▁g ▁[ ▁i ▁] ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁g ▁[ ▁0 ▁] ▁. ▁add ▁( ▁1 ▁) ▁; ▁g ▁[ ▁1 ▁] ▁. ▁add ▁( ▁0 ▁) ▁; ▁g ▁[ ▁0 ▁] ▁. ▁add ▁( ▁2 ▁) ▁; ▁g ▁[ ▁2 ▁] ▁. ▁add ▁( ▁0 ▁) ▁;
▁class ▁G F G ▁{ ▁static ▁int ▁min Points ▁( ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁if ▁( ▁( ▁n ▁% ▁2 ▁!= ▁0 ▁) ▁&& ▁( ▁m ▁% ▁2 ▁!= ▁0 ▁) ▁) ▁{ ▁ans ▁= ▁( ▁( ▁n ▁* ▁m ▁) ▁/ ▁2 ▁) ▁+ ▁1 ▁; ▁} ▁else ▁{ ▁ans ▁= ▁( ▁n ▁* ▁m ▁) ▁/ ▁2 ▁; ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁5 ▁, ▁M ▁= ▁7 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁min Points ▁( ▁N ▁, ▁M ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁create Array ▁( ▁int ▁n ▁, ▁int ▁s ▁) ▁{ ▁if ▁( ▁2 ▁* ▁n ▁<= ▁s ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁2 ▁+ ▁" ▁" ▁) ▁; ▁s ▁-= ▁2 ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁s ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁1 ▁) ▁; ▁} ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁- ▁1" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁1 ▁; ▁int ▁S ▁= ▁4 ▁; ▁create Array ▁( ▁N ▁, ▁S ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁maximum Sum Sub array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁Map ▁< ▁Integer ▁, ▁Integer ▁> ▁mp ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁>= ▁0 ▁) ▁mp ▁. ▁put ▁( ▁arr ▁[ ▁i ▁] ▁, ▁1 ▁) ▁; ▁} ▁int ▁first ▁= ▁0 ▁; ▁int ▁last ▁= ▁0 ▁; ▁int ▁ans ▁= ▁0 ▁; ▁int ▁INF ▁= ▁( ▁int ▁) ▁1 e 6 ▁; ▁for ▁( ▁Map ▁. ▁Entry ▁< ▁Integer ▁, ▁Integer ▁> ▁i ▁: ▁mp ▁. ▁entrySet ▁( ▁) ▁) ▁{ ▁int ▁mx ▁= ▁i ▁. ▁getKey ▁( ▁) ▁; ▁int ▁curr ▁= ▁0 ▁; ▁int ▁curr _ start ▁= ▁- ▁1 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁curr ▁== ▁0 ▁) ▁curr _ start ▁= ▁j ▁; ▁int ▁val ▁= ▁arr ▁[ ▁j ▁] ▁> ▁mx ▁? ▁- ▁INF ▁: ▁arr ▁[ ▁j ▁] ▁; ▁curr ▁+= ▁val ▁; ▁if ▁( ▁curr ▁< ▁0 ▁) ▁curr ▁= ▁0 ▁; ▁if ▁( ▁curr ▁> ▁ans ▁) ▁{ ▁ans ▁= ▁curr ▁; ▁first ▁= ▁curr _ start ▁; ▁last ▁= ▁j ▁; ▁} ▁} ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁( ▁first ▁+ ▁1 ▁) ▁+ ▁" ▁" ▁+ ▁( ▁last ▁+ ▁1 ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁- ▁2 ▁, ▁10 ▁, ▁- ▁1 ▁, ▁4 ▁} ▁; ▁int ▁size ▁= ▁arr ▁. ▁length ▁; ▁maximum Sum Sub array ▁( ▁arr ▁, ▁size ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁min F lip ▁( ▁String ▁s ▁, ▁int ▁n ▁, ▁int ▁k ▁, ▁char ▁a ▁[ ▁] ▁, ▁int ▁p ▁) ▁{ ▁boolean ▁allowed ▁[ ▁] ▁= ▁new ▁boolean ▁[ ▁26 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁p ▁; ▁i ▁++ ▁) ▁{ ▁allowed ▁[ ▁a ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁] ▁= ▁true ▁; ▁} ▁char ▁[ ▁] ▁[ ▁] ▁freq ▁= ▁new ▁char ▁[ ▁k ▁] ▁[ ▁26 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁k ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁26 ▁; ▁j ▁++ ▁) ▁freq ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁freq ▁[ ▁i ▁% ▁k ▁] ▁[ ▁s ▁. ▁charAt ▁( ▁i ▁) ▁- ▁' ▁a ▁' ▁] ▁+= ▁1 ▁; ▁} ▁int ▁ans ▁= ▁0 ▁; ▁int ▁total positions ▁= ▁n ▁/ ▁k ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁k ▁; ▁i ▁++ ▁) ▁{ ▁int ▁max frequency ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁26 ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁freq ▁[ ▁i ▁] ▁[ ▁j ▁] ▁> ▁max frequency ▁&& ▁allowed ▁[ ▁j ▁] ▁== ▁true ▁) ▁max frequency ▁= ▁freq ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁} ▁ans ▁+= ▁( ▁total positions ▁- ▁max frequency ▁+ ▁( ▁( ▁i ▁% ▁k ▁< ▁n ▁% ▁k ▁) ▁? ▁1 ▁: ▁0 ▁) ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁ans ▁+ ▁" NEW _ LINE "); ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁S ▁= ▁" ▁n ih si ak y t ▁" ▁; ▁int ▁n ▁= ▁S ▁. ▁length ▁( ▁) ▁; ▁int ▁K ▁= ▁3 ▁; ▁char ▁[ ▁] ▁A ▁= ▁{ ▁' ▁n ▁' ▁, ▁' ▁i ▁' ▁, ▁' ▁p ▁' ▁, ▁' ▁s ▁' ▁, ▁' ▁q ▁' ▁} ▁; ▁int ▁p ▁= ▁A ▁. ▁length ▁; ▁min F lip ▁( ▁S ▁, ▁n ▁, ▁K ▁, ▁A ▁, ▁p ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁lang ▁. ▁Math ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁void ▁Min Diff ▁( ▁int ▁n ▁) ▁{ ▁int ▁val ▁= ▁( ▁int ▁) ▁Math ▁. ▁pow ▁( ▁2 ▁, ▁n ▁) ▁; ▁int ▁sep ▁= ▁n ▁/ ▁2 ▁; ▁int ▁grp 1 ▁= ▁0 ▁; ▁int ▁grp 2 ▁= ▁0 ▁; ▁grp 1 ▁= ▁grp 1 ▁+ ▁val ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁sep ▁; ▁i ▁++ ▁) ▁grp 1 ▁= ▁grp 1 ▁+ ▁( ▁int ▁) ▁Math ▁. ▁pow ▁( ▁2 ▁, ▁i ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁sep ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁grp 2 ▁= ▁grp 2 ▁+ ▁( ▁int ▁) ▁Math ▁. ▁pow ▁( ▁2 ▁, ▁i ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁Math ▁. ▁abs ▁( ▁grp 1 ▁- ▁grp 2 ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁4 ▁; ▁Min Diff ▁( ▁n ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁Minimum Value ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁answer ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁answer ▁= ▁Math ▁. ▁min ▁( ▁answer ▁, ▁( ▁( ▁a ▁[ ▁i ▁] ▁& ▁a ▁[ ▁j ▁] ▁) ▁^ ▁( ▁a ▁[ ▁i ▁] ▁a ▁[ ▁j ▁] ▁) ▁) ▁) ▁; ▁} ▁} ▁return ▁answer ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁6 ▁; ▁int ▁[ ▁] ▁A ▁= ▁new ▁int ▁[ ▁] ▁{ ▁12 ▁, ▁3 ▁, ▁14 ▁, ▁5 ▁, ▁9 ▁, ▁8 ▁} ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁Minimum Value ▁( ▁A ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁count Of Sub Strings ▁( ▁String ▁s ▁) ▁{ ▁int ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁int ▁[ ▁] ▁prefix _ sum ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'1' ▁) ▁prefix _ sum ▁[ ▁i ▁] ▁= ▁1 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁prefix _ sum ▁[ ▁i ▁] ▁+= ▁prefix _ sum ▁[ ▁i ▁- ▁1 ▁] ▁; ▁int ▁answer ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁int ▁count Of On es ▁= ▁prefix _ sum ▁[ ▁j ▁] ▁- ▁( ▁i ▁- ▁1 ▁>= ▁0 ▁? ▁prefix _ sum ▁[ ▁i ▁- ▁1 ▁] ▁: ▁0 ▁) ▁; ▁int ▁length ▁= ▁j ▁- ▁i ▁+ ▁1 ▁; ▁if ▁( ▁count Of On es ▁> ▁0 ▁&& ▁length ▁% ▁count Of On es ▁== ▁0 ▁) ▁answer ▁++ ▁; ▁} ▁} ▁return ▁answer ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁S ▁= ▁" 1111 100 000" ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁count Of Sub Strings ▁( ▁S ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁digit _ xor ▁( ▁int ▁x ▁) ▁{ ▁int ▁xor r ▁= ▁0 ▁; ▁while ▁( ▁x ▁> ▁0 ▁) ▁{ ▁xor r ▁^= ▁x ▁% ▁10 ▁; ▁x ▁= ▁x ▁/ ▁10 ▁; ▁} ▁return ▁xor r ▁; ▁} ▁static ▁int ▁find _ count ▁( ▁int ▁n ▁) ▁{ ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁m pp ▁= ▁new ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁m pp ▁. ▁containsKey ▁( ▁digit _ xor ▁( ▁i ▁) ▁) ▁) ▁m pp ▁. ▁put ▁( ▁digit _ xor ▁( ▁i ▁) ▁, ▁m pp ▁. ▁get ▁( ▁digit _ xor ▁( ▁i ▁) ▁) ▁+ ▁1 ▁) ▁; ▁else ▁m pp ▁. ▁put ▁( ▁digit _ xor ▁( ▁i ▁) ▁, ▁1 ▁) ▁; ▁} ▁int ▁max m ▁= ▁0 ▁; ▁for ▁( ▁Map ▁. ▁Entry ▁< ▁Integer ▁, ▁Integer ▁> ▁x ▁: ▁m pp ▁. ▁entrySet ▁( ▁) ▁) ▁{ ▁if ▁( ▁x ▁. ▁getValue ▁( ▁) ▁> ▁max m ▁) ▁max m ▁= ▁x ▁. ▁getValue ▁( ▁) ▁; ▁} ▁return ▁max m ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁13 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁find _ count ▁( ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁min _ val ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁static ▁int ▁min _ steps ▁= ▁0 ▁; ▁static ▁int ▁sum Of Digits ▁( ▁int ▁n ▁) ▁{ ▁String ▁s ▁= ▁String ▁. ▁valueOf ▁( ▁n ▁) ▁; ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁- ▁'0' ▁) ▁; ▁} ▁return ▁sum ▁; ▁} ▁static ▁void ▁Transform ▁( ▁int ▁n ▁, ▁int ▁d ▁, ▁int ▁steps ▁) ▁{ ▁if ▁( ▁n ▁< ▁min _ val ▁) ▁{ ▁min _ val ▁= ▁n ▁; ▁min _ steps ▁= ▁steps ▁; ▁} ▁else ▁if ▁( ▁n ▁== ▁min _ val ▁) ▁{ ▁min _ steps ▁= ▁Math ▁. ▁min ▁( ▁min _ steps ▁, ▁steps ▁) ▁; ▁} ▁if ▁( ▁steps ▁< ▁15 ▁) ▁{ ▁Transform ▁( ▁sum Of Digits ▁( ▁n ▁) ▁, ▁d ▁, ▁steps ▁+ ▁1 ▁) ▁; ▁Transform ▁( ▁n ▁+ ▁d ▁, ▁d ▁, ▁steps ▁+ ▁1 ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁9 ▁, ▁D ▁= ▁3 ▁; ▁Transform ▁( ▁N ▁, ▁D ▁, ▁0 ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁min _ val ▁+ ▁" ▁" ▁+ ▁min _ steps ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁sum Div is ib les ▁( ▁int ▁A ▁, ▁int ▁B ▁, ▁int ▁M ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁A ▁; ▁i ▁<= ▁B ▁; ▁i ▁++ ▁) ▁if ▁( ▁i ▁% ▁M ▁== ▁0 ▁) ▁sum ▁+= ▁i ▁; ▁return ▁sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁A ▁= ▁6 ▁, ▁B ▁= ▁15 ▁, ▁M ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁sum Div is ib les ▁( ▁A ▁, ▁B ▁, ▁M ▁) ▁+ ▁" NEW _ LINE "); ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁count Pairs ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁frequency ▁= ▁new ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁frequency ▁. ▁containsKey ▁( ▁arr ▁[ ▁i ▁] ▁) ▁) ▁{ ▁frequency ▁. ▁put ▁( ▁arr ▁[ ▁i ▁] ▁, ▁frequency ▁. ▁get ▁( ▁arr ▁[ ▁i ▁] ▁) ▁+ ▁1 ▁) ▁; ▁} ▁else ▁{ ▁frequency ▁. ▁put ▁( ▁arr ▁[ ▁i ▁] ▁, ▁1 ▁) ▁; ▁} ▁} ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁Map ▁. ▁Entry ▁< ▁Integer ▁, ▁Integer ▁> ▁x ▁: ▁frequency ▁. ▁entrySet ▁( ▁) ▁) ▁{ ▁int ▁f ▁= ▁x ▁. ▁getValue ▁( ▁) ▁; ▁count ▁+= ▁f ▁* ▁( ▁f ▁- ▁1 ▁) ▁/ ▁2 ▁; ▁} ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁1 ▁, ▁1 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁count Pairs ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁dec Binary ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁k ▁= ▁( ▁int ▁) ▁( ▁Math ▁. ▁log ▁( ▁n ▁) ▁/ ▁Math ▁. ▁log ▁( ▁2 ▁) ▁) ▁; ▁while ▁( ▁n ▁> ▁0 ▁) ▁{ ▁arr ▁[ ▁k ▁-- ▁] ▁= ▁n ▁% ▁2 ▁; ▁n ▁/= ▁2 ▁; ▁} ▁} ▁static ▁int ▁binary Dec ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁ans ▁+= ▁arr ▁[ ▁i ▁] ▁<< ▁( ▁n ▁- ▁i ▁- ▁1 ▁) ▁; ▁return ▁ans ▁; ▁} ▁static ▁int ▁max Num ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁l ▁= ▁( ▁int ▁) ▁( ▁Math ▁. ▁log ▁( ▁n ▁) ▁/ ▁Math ▁. ▁log ▁( ▁2 ▁) ▁) ▁+ ▁1 ▁; ▁int ▁a ▁[ ▁] ▁= ▁new ▁int ▁[ ▁l ▁] ▁; ▁dec Binary ▁( ▁a ▁, ▁n ▁) ▁; ▁int ▁cn ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁l ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁== ▁0 ▁&& ▁cn ▁< ▁k ▁) ▁{ ▁a ▁[ ▁i ▁] ▁= ▁1 ▁; ▁cn ▁++ ▁; ▁} ▁} ▁return ▁binary Dec ▁( ▁a ▁, ▁l ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁4 ▁, ▁k ▁= ▁1 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁max Num ▁( ▁n ▁, ▁k ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁MAX ▁= ▁26 ▁; ▁static ▁char ▁max Alpha ▁( ▁String ▁str ▁, ▁int ▁len ▁) ▁{ ▁int ▁[ ▁] ▁first ▁= ▁new ▁int ▁[ ▁MAX ▁] ▁; ▁int ▁[ ▁] ▁last ▁= ▁new ▁int ▁[ ▁MAX ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁MAX ▁; ▁i ▁++ ▁) ▁{ ▁first ▁[ ▁i ▁] ▁= ▁- ▁1 ▁; ▁last ▁[ ▁i ▁] ▁= ▁- ▁1 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁len ▁; ▁i ▁++ ▁) ▁{ ▁int ▁index ▁= ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁- ▁' ▁a ▁' ▁) ▁; ▁if ▁( ▁first ▁[ ▁index ▁] ▁== ▁- ▁1 ▁) ▁first ▁[ ▁index ▁] ▁= ▁i ▁; ▁last ▁[ ▁index ▁] ▁= ▁i ▁; ▁} ▁int ▁ans ▁= ▁- ▁1 ▁, ▁max Val ▁= ▁- ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁MAX ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁first ▁[ ▁i ▁] ▁== ▁- ▁1 ▁) ▁continue ▁; ▁if ▁( ▁( ▁last ▁[ ▁i ▁] ▁- ▁first ▁[ ▁i ▁] ▁) ▁> ▁max Val ▁) ▁{ ▁max Val ▁= ▁last ▁[ ▁i ▁] ▁- ▁first ▁[ ▁i ▁] ▁; ▁ans ▁= ▁i ▁; ▁} ▁} ▁return ▁( ▁char ▁) ▁( ▁ans ▁+ ▁' ▁a ▁' ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁" ▁ab bb a ▁" ▁; ▁int ▁len ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁max Alpha ▁( ▁str ▁, ▁len ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁boolean ▁is V ow el ▁( ▁char ▁ch ▁) ▁{ ▁switch ▁( ▁ch ▁) ▁{ ▁case ▁' ▁a ▁' ▁: ▁case ▁' ▁e ▁' ▁: ▁case ▁' ▁i ▁' ▁: ▁case ▁' ▁o ▁' ▁: ▁case ▁' ▁u ▁' ▁: ▁return ▁true ▁; ▁default ▁: ▁return ▁false ▁; ▁} ▁} ▁static ▁int ▁vow el Pairs ▁( ▁String ▁s ▁, ▁int ▁n ▁) ▁{ ▁int ▁cnt ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁is V ow el ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁) ▁&& ▁is V ow el ▁( ▁s ▁. ▁charAt ▁( ▁i ▁+ ▁1 ▁) ▁) ▁) ▁cnt ▁++ ▁; ▁} ▁return ▁cnt ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁String ▁s ▁= ▁" ▁ab a eb io ▁" ▁; ▁int ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁vow el Pairs ▁( ▁s ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁min _ el im ination ▁( ▁int ▁n ▁, ▁int ▁[ ▁] ▁arr ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁int ▁prev _ val ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁curr _ val ▁= ▁arr ▁[ ▁i ▁] ▁; ▁if ▁( ▁curr _ val ▁% ▁2 ▁== ▁prev _ val ▁% ▁2 ▁) ▁count ▁++ ▁; ▁prev _ val ▁= ▁curr _ val ▁; ▁} ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁new ▁int ▁[ ▁] ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁7 ▁, ▁9 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁min _ el im ination ▁( ▁n ▁, ▁arr ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁checkIf Overlap ▁( ▁String ▁str ▁) ▁{ ▁int ▁len ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁int ▁[ ▁] ▁visited ▁= ▁new ▁int ▁[ ▁len ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁len ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁== ▁' ▁. ▁' ▁) ▁continue ▁; ▁for ▁( ▁int ▁j ▁= ▁Math ▁. ▁max ▁( ▁0 ▁, ▁i ▁- ▁str ▁. ▁charAt ▁( ▁i ▁) ▁) ▁; ▁j ▁<= ▁Math ▁. ▁min ▁( ▁len ▁, ▁i ▁+ ▁str ▁. ▁charAt ▁( ▁i ▁) ▁) ▁; ▁j ▁++ ▁) ▁visited ▁[ ▁j ▁] ▁++ ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁len ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁visited ▁[ ▁i ▁] ▁> ▁1 ▁) ▁{ ▁return ▁true ▁; ▁} ▁} ▁return ▁false ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁" ▁. ▁2 ▁. ▁. ▁2 ▁. ▁" ▁; ▁if ▁( ▁checkIf Overlap ▁( ▁str ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁YES ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁NO ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁is Correct Order ▁( ▁int ▁n ▁) ▁{ ▁boolean ▁flag ▁= ▁true ▁; ▁int ▁prev ▁= ▁- ▁1 ▁; ▁int ▁type ▁= ▁- ▁1 ▁; ▁while ▁( ▁n ▁!= ▁0 ▁) ▁{ ▁if ▁( ▁type ▁== ▁- ▁1 ▁) ▁{ ▁if ▁( ▁prev ▁== ▁- ▁1 ▁) ▁{ ▁prev ▁= ▁n ▁% ▁10 ▁; ▁n ▁= ▁n ▁/ ▁10 ▁; ▁continue ▁; ▁} ▁if ▁( ▁prev ▁== ▁n ▁% ▁10 ▁) ▁{ ▁flag ▁= ▁false ▁; ▁break ▁; ▁} ▁if ▁( ▁prev ▁> ▁n ▁% ▁10 ▁) ▁{ ▁type ▁= ▁1 ▁; ▁prev ▁= ▁n ▁% ▁10 ▁; ▁n ▁= ▁n ▁/ ▁10 ▁; ▁continue ▁; ▁} ▁prev ▁= ▁n ▁% ▁10 ▁; ▁n ▁= ▁n ▁/ ▁10 ▁; ▁} ▁else ▁{ ▁if ▁( ▁prev ▁== ▁n ▁% ▁10 ▁) ▁{ ▁flag ▁= ▁false ▁; ▁break ▁; ▁} ▁if ▁( ▁prev ▁< ▁n ▁% ▁10 ▁) ▁{ ▁flag ▁= ▁false ▁; ▁break ▁; ▁} ▁prev ▁= ▁n ▁% ▁10 ▁; ▁n ▁= ▁n ▁/ ▁10 ▁; ▁} ▁} ▁return ▁flag ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁1234 54 321 ▁; ▁if ▁( ▁is Correct Order ▁( ▁n ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁YES ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁NO ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁V ▁= ▁5 ▁; ▁static ▁int ▁INT _ MAX ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁static ▁boolean ▁isValid Edge ▁( ▁int ▁u ▁, ▁int ▁v ▁, ▁boolean ▁[ ▁] ▁in M ST ▁) ▁{ ▁if ▁( ▁u ▁== ▁v ▁) ▁return ▁false ▁; ▁if ▁( ▁in M ST ▁[ ▁u ▁] ▁== ▁false ▁&& ▁in M ST ▁[ ▁v ▁] ▁== ▁false ▁) ▁return ▁false ▁; ▁else ▁if ▁( ▁in M ST ▁[ ▁u ▁] ▁== ▁true ▁&& ▁in M ST ▁[ ▁v ▁] ▁== ▁true ▁) ▁return ▁false ▁; ▁return ▁true ▁; ▁} ▁static ▁void ▁prim M ST ▁( ▁int ▁cost ▁[ ▁] ▁[ ▁] ▁) ▁{ ▁boolean ▁[ ▁] ▁in M ST ▁= ▁new ▁boolean ▁[ ▁V ▁] ▁; ▁in M ST ▁[ ▁0 ▁] ▁= ▁true ▁; ▁int ▁edge _ count ▁= ▁0 ▁, ▁min cost ▁= ▁0 ▁; ▁while ▁( ▁edge _ count ▁< ▁V ▁- ▁1 ▁) ▁{ ▁int ▁min ▁= ▁INT _ MAX ▁, ▁a ▁= ▁- ▁1 ▁, ▁b ▁= ▁- ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁V ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁V ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁cost ▁[ ▁i ▁] ▁[ ▁j ▁] ▁< ▁min ▁) ▁{ ▁if ▁( ▁isValid Edge ▁( ▁i ▁, ▁j ▁, ▁in M ST ▁) ▁) ▁{ ▁min ▁= ▁cost ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁a ▁= ▁i ▁; ▁b ▁= ▁j ▁; ▁} ▁} ▁} ▁} ▁if ▁( ▁a ▁!= ▁- ▁1 ▁&& ▁b ▁!= ▁- ▁1 ▁) ▁{ ▁System ▁. ▁out ▁. ▁printf ▁( ▁" Edge ▁% d :( % d , ▁% d ) ▁cost : ▁% d ▁NEW _ LINE ", ▁edge _ count ++, ▁a , ▁b , ▁min ); ▁min cost ▁= ▁min cost ▁+ ▁min ▁; ▁in M ST ▁[ ▁b ▁] ▁= ▁in M ST ▁[ ▁a ▁] ▁= ▁true ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁Minimum ▁cost ▁= ▁% ▁d ▁", ▁min cost ); ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁cost ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁INT _ MAX ▁, ▁2 ▁, ▁INT _ MAX ▁, ▁6 ▁, ▁INT _ MAX ▁} ▁, ▁{ ▁2 ▁, ▁INT _ MAX ▁,
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁class ▁pair ▁{ ▁double ▁first ▁, ▁second ▁; ▁public ▁pair ▁( ▁double ▁first ▁, ▁double ▁second ▁) ▁{ ▁this ▁. ▁first ▁= ▁first ▁; ▁this ▁. ▁second ▁= ▁second ▁; ▁} ▁} ▁static ▁void ▁construct ▁( ▁int ▁n ▁, ▁pair ▁ans _ pair ▁) ▁{ ▁if ▁( ▁ans _ pair ▁. ▁first ▁== ▁- ▁1 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Not ▁possible ▁" ▁) ▁; ▁return ▁; ▁} ▁double ▁a 1 ▁= ▁ans _ pair ▁. ▁first ▁; ▁double ▁a 2 ▁= ▁ans _ pair ▁. ▁second ▁; ▁double ▁r ▁= ▁a 2 ▁/ ▁a 1 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" The ▁result ant ▁sequence ▁is : NEW _ LINE "); ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁ai ▁= ▁( ▁int ▁) ▁( ▁a 1 ▁* ▁Math ▁. ▁pow ▁( ▁r ▁, ▁i ▁- ▁1 ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁ai ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁static ▁void ▁find Minimum Operations ▁( ▁double ▁[ ▁] ▁a ▁, ▁int ▁n ▁) ▁{ ▁int ▁ans ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁int ▁c ▁[ ▁] ▁= ▁{ ▁- ▁1 ▁, ▁0 ▁, ▁1 ▁} ▁; ▁int ▁possibilities ▁= ▁3 ▁; ▁int ▁pos 1 ▁= ▁- ▁1 ▁, ▁pos 2 ▁= ▁- ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁possibilities ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁possibilities ▁; ▁j ▁++ ▁) ▁{ ▁double ▁a 1 ▁= ▁a ▁[ ▁1 ▁] ▁+ ▁c ▁[ ▁i ▁] ▁; ▁double ▁a 2 ▁= ▁a ▁[ ▁2 ▁] ▁+ ▁c ▁[ ▁j ▁] ▁; ▁int ▁temp ▁= ▁( ▁int ▁) ▁( ▁Math ▁. ▁abs ▁( ▁a 1 ▁- ▁a ▁[ ▁1 ▁] ▁) ▁+ ▁Math ▁. ▁abs ▁( ▁a 2 ▁- ▁a ▁[ ▁2 ▁] ▁) ▁) ▁; ▁if ▁( ▁a 1 ▁== ▁0 ▁a 2 ▁== ▁0 ▁) ▁continue ▁; ▁double ▁r ▁= ▁a 2 ▁/ ▁a 1 ▁; ▁for ▁( ▁int ▁pos ▁= ▁3 ▁; ▁pos ▁<= ▁n ▁; ▁pos ▁++ ▁) ▁{ ▁double ▁ai ▁= ▁a 1 ▁* ▁Math ▁. ▁pow ▁( ▁r ▁, ▁pos ▁- ▁1 ▁) ▁; ▁if ▁( ▁a ▁[ ▁pos ▁] ▁== ▁ai ▁) ▁{ ▁continue ▁; ▁} ▁else ▁if ▁(
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁solution ▁{ ▁static ▁int ▁find Minimum Ad jacent Sw aps ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁boolean ▁[ ▁] ▁visited ▁= ▁new ▁boolean ▁[ ▁N ▁+ ▁1 ▁] ▁; ▁int ▁minimum Sw aps ▁= ▁0 ▁; ▁Arrays ▁. ▁fill ▁( ▁visited ▁, ▁false ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁2 ▁* ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁visited ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁== ▁false ▁) ▁{ ▁visited ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁= ▁true ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁2 ▁* ▁N ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁visited ▁[ ▁arr ▁[ ▁j ▁] ▁] ▁== ▁false ▁) ▁count ▁++ ▁; ▁else ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁arr ▁[ ▁j ▁] ▁) ▁minimum Sw aps ▁+= ▁count ▁; ▁} ▁} ▁} ▁return ▁minimum Sw aps ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁3 ▁, ▁1 ▁, ▁2 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁N ▁/= ▁2 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Minimum Ad jacent Sw aps ▁( ▁arr ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁Min Operation ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁result ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁!= ▁1 ▁&& ▁a ▁[ ▁i ▁] ▁> ▁k ▁) ▁{ ▁result ▁= ▁result ▁+ ▁Math ▁. ▁min ▁( ▁a ▁[ ▁i ▁] ▁% ▁k ▁, ▁k ▁- ▁a ▁[ ▁i ▁] ▁% ▁k ▁) ▁; ▁} ▁else ▁{ ▁result ▁= ▁result ▁+ ▁k ▁- ▁a ▁[ ▁i ▁] ▁; ▁} ▁} ▁return ▁result ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁int ▁k ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁Min Operation ▁( ▁arr ▁, ▁n ▁, ▁k ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁print Vector ▁( ▁Vector ▁< ▁Integer ▁> ▁v ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁v ▁. ▁size ▁( ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁v ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁v ▁. ▁get ▁( ▁i ▁) ▁+ ▁" ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁} ▁static ▁void ▁find Two Group ▁( ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁n ▁* ▁( ▁n ▁+ ▁1 ▁) ▁/ ▁2 ▁; ▁int ▁group 1 Sum ▁= ▁sum ▁/ ▁2 ▁; ▁Vector ▁< ▁Integer ▁> ▁group 1 ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁Vector ▁< ▁Integer ▁> ▁group 2 ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁; ▁i ▁> ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁group 1 Sum ▁- ▁i ▁>= ▁0 ▁) ▁{ ▁group 1 ▁. ▁add ▁( ▁i ▁) ▁; ▁group 1 Sum ▁-= ▁i ▁; ▁} ▁else ▁{ ▁group 2 ▁. ▁add ▁( ▁i ▁) ▁; ▁} ▁} ▁print Vector ▁( ▁group 1 ▁) ▁; ▁print Vector ▁( ▁group 2 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁5 ▁; ▁find Two Group ▁( ▁n ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁long ▁swap Count ▁( ▁String ▁s ▁) ▁{ ▁Vector ▁< ▁Integer ▁> ▁pos ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁length ▁( ▁) ▁; ▁++ ▁i ▁) ▁if ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁== ▁' ▁[ ▁' ▁) ▁pos ▁. ▁add ▁( ▁i ▁) ▁; ▁int ▁count ▁= ▁0 ▁; ▁int ▁p ▁= ▁0 ▁; ▁long ▁sum ▁= ▁0 ▁; ▁char ▁[ ▁] ▁S ▁= ▁s ▁. ▁toCharArray ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁length ▁( ▁) ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁S ▁[ ▁i ▁] ▁== ▁' ▁[ ▁' ▁) ▁{ ▁++ ▁count ▁; ▁++ ▁p ▁; ▁} ▁else ▁if ▁( ▁S ▁[ ▁i ▁] ▁== ▁' ▁] ▁' ▁) ▁-- ▁count ▁; ▁if ▁( ▁count ▁< ▁0 ▁) ▁{ ▁sum ▁+= ▁pos ▁. ▁get ▁( ▁p ▁) ▁- ▁i ▁; ▁char ▁temp ▁= ▁S ▁[ ▁i ▁] ▁; ▁S ▁[ ▁i ▁] ▁= ▁S ▁[ ▁pos ▁. ▁get ▁( ▁p ▁) ▁] ▁; ▁S ▁[ ▁pos ▁. ▁get ▁( ▁p ▁) ▁] ▁= ▁temp ▁; ▁++ ▁p ▁; ▁count ▁= ▁1 ▁; ▁} ▁} ▁return ▁sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁s ▁= ▁" ▁[ ▁] ▁] ▁[ ▁] ▁[ ▁" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁swap Count ▁( ▁s ▁) ▁) ▁; ▁s ▁= ▁" ▁[ ▁[ ▁] ▁[ ▁] ▁] ▁" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁swap Count ▁( ▁s ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁mod ▁= ▁100 000000 7 ▁; ▁static ▁void ▁count Of Numbers ▁( ▁int ▁N ▁) ▁{ ▁int ▁ans ▁= ▁1 ▁; ▁for ▁( ▁int ▁index ▁= ▁1 ▁; ▁index ▁<= ▁N ▁; ▁++ ▁index ▁) ▁{ ▁int ▁choices ▁= ▁0 ▁; ▁for ▁( ▁int ▁digit ▁= ▁1 ▁; ▁digit ▁<= ▁9 ▁; ▁++ ▁digit ▁) ▁{ ▁if ▁( ▁index ▁% ▁digit ▁== ▁0 ▁) ▁{ ▁++ ▁choices ▁; ▁} ▁} ▁ans ▁= ▁( ▁ans ▁* ▁choices ▁) ▁% ▁mod ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁ans ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁5 ▁; ▁count Of Numbers ▁( ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁int ▁dfs ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁left ▁, ▁int ▁K ▁) ▁{ ▁int ▁q ▁= ▁0 ▁; ▁if ▁( ▁left ▁== ▁0 ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁K ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁0 ▁) ▁{ ▁arr ▁[ ▁i ▁] ▁-- ▁; ▁q ▁= ▁Math ▁. ▁max ▁( ▁q ▁, ▁1 ▁+ ▁dfs ▁( ▁arr ▁, ▁K ▁- ▁i ▁, ▁K ▁) ▁) ▁; ▁arr ▁[ ▁i ▁] ▁++ ▁; ▁} ▁} ▁} ▁else ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁K ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁0 ▁) ▁{ ▁arr ▁[ ▁i ▁] ▁-- ▁; ▁int ▁n left ▁= ▁( ▁i ▁<= ▁left ▁? ▁left ▁- ▁i ▁: ▁K ▁+ ▁left ▁- ▁i ▁) ▁; ▁q ▁= ▁Math ▁. ▁max ▁( ▁q ▁, ▁dfs ▁( ▁arr ▁, ▁n left ▁, ▁K ▁) ▁) ▁; ▁arr ▁[ ▁i ▁] ▁++ ▁; ▁} ▁} ▁} ▁return ▁q ▁; ▁} ▁public ▁static ▁int ▁max Groups ▁( ▁int ▁K ▁, ▁int ▁[ ▁] ▁arr ▁) ▁{ ▁int ▁V ▁[ ▁] ▁= ▁new ▁int ▁[ ▁K ▁] ▁; ▁for ▁( ▁int ▁x ▁: ▁arr ▁) ▁V ▁[ ▁x ▁% ▁K ▁] ▁++ ▁; ▁int ▁ans ▁= ▁V ▁[ ▁0 ▁] ▁+ ▁dfs ▁( ▁V ▁, ▁0 ▁, ▁K ▁) ▁; ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁int ▁K ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁max Groups ▁( ▁K ▁, ▁arr ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁longest Sub sequence ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁N ▁) ▁{ ▁int ▁dp ▁[ ▁] ▁[ ▁] ▁= ▁new ▁int ▁[ ▁N ▁] ▁[ ▁N ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁++ ▁i ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁N ▁+ ▁1 ▁; ▁++ ▁j ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁- ▁1 ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁++ ▁i ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁} ▁dp ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁= ▁( ▁arr ▁[ ▁0 ▁] ▁>= ▁0 ▁? ▁arr ▁[ ▁0 ▁] ▁: ▁- ▁1 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁++ ▁i ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁<= ▁( ▁i ▁+ ▁1 ▁) ▁; ▁++ ▁j ▁) ▁{ ▁if ▁( ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁!= ▁- ▁1 ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁Math ▁. ▁max ▁( ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁, ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁) ▁; ▁} ▁if ▁( ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁- ▁1 ▁] ▁>= ▁0 ▁&& ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁- ▁1 ▁] ▁+ ▁arr ▁[ ▁i ▁] ▁>= ▁0 ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁Math ▁. ▁max ▁( ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁, ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁- ▁1 ▁] ▁+ ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁} ▁} ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁<= ▁N ▁; ▁++ ▁j ▁) ▁{ ▁if ▁( ▁dp ▁[ ▁N ▁- ▁1 ▁] ▁[ ▁j ▁] ▁>= ▁0 ▁) ▁{ ▁ans ▁= ▁j ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁ans ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁- ▁4 ▁, ▁1 ▁, ▁- ▁3 ▁, ▁1 ▁, ▁- ▁3 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁longest Sub
▁class ▁G F G ▁{ ▁static ▁int ▁K visible From Left ▁( ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁if ▁( ▁N ▁== ▁K ▁) ▁return ▁1 ▁; ▁if ▁( ▁K ▁== ▁1 ▁) ▁{ ▁int ▁ans ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁ans ▁*= ▁i ▁; ▁return ▁ans ▁; ▁} ▁return ▁K visible From Left ▁( ▁N ▁- ▁1 ▁, ▁K ▁- ▁1 ▁) ▁+ ▁( ▁N ▁- ▁1 ▁) ▁* ▁K visible From Left ▁( ▁N ▁- ▁1 ▁, ▁K ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁5 ▁, ▁K ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁K visible From Left ▁( ▁N ▁, ▁K ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁numOf W ays ▁( ▁int ▁a ▁[ ▁] ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁i ▁, ▁HashSet ▁< ▁Integer ▁> ▁blue ▁) ▁{ ▁if ▁( ▁i ▁== ▁n ▁) ▁return ▁1 ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁[ ▁j ▁] ▁== ▁1 ▁&& ▁! ▁blue ▁. ▁contains ▁( ▁j ▁) ▁) ▁{ ▁blue ▁. ▁add ▁( ▁j ▁) ▁; ▁count ▁+= ▁numOf W ays ▁( ▁a ▁, ▁n ▁, ▁i ▁+ ▁1 ▁, ▁blue ▁) ▁; ▁blue ▁. ▁remove ▁( ▁j ▁) ▁; ▁} ▁} ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁3 ▁; ▁int ▁mat ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁0 ▁, ▁1 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁0 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁1 ▁, ▁1 ▁} ▁} ▁; ▁HashSet ▁< ▁Integer ▁> ▁m pp ▁= ▁new ▁HashSet ▁< ▁> ▁( ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁( ▁numOf W ays ▁( ▁mat ▁, ▁n ▁, ▁0 ▁, ▁m pp ▁) ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁total Arrays ▁( ▁int ▁N ▁, ▁int ▁M ▁) ▁{ ▁int ▁[ ▁] ▁end _ with _ one ▁= ▁new ▁int ▁[ ▁N ▁+ ▁1 ▁] ▁; ▁int ▁[ ▁] ▁end _ not _ with _ one ▁= ▁new ▁int ▁[ ▁N ▁+ ▁1 ▁] ▁; ▁end _ with _ one ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁end _ not _ with _ one ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁end _ with _ one ▁[ ▁1 ▁] ▁= ▁0 ▁; ▁end _ not _ with _ one ▁[ ▁1 ▁] ▁= ▁M ▁- ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁end _ with _ one ▁[ ▁i ▁] ▁= ▁end _ not _ with _ one ▁[ ▁i ▁- ▁1 ▁] ▁; ▁end _ not _ with _ one ▁[ ▁i ▁] ▁= ▁end _ with _ one ▁[ ▁i ▁- ▁1 ▁] ▁* ▁( ▁M ▁- ▁1 ▁) ▁+ ▁end _ not _ with _ one ▁[ ▁i ▁- ▁1 ▁] ▁* ▁( ▁M ▁- ▁2 ▁) ▁; ▁} ▁return ▁end _ with _ one ▁[ ▁N ▁- ▁1 ▁] ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁3 ▁, ▁M ▁= ▁3 ▁; ▁int ▁temp ▁= ▁total Arrays ▁( ▁N ▁, ▁M ▁) ▁; ▁int ▁ans ▁= ▁M ▁* ▁temp ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁ans ▁+ ▁" NEW _ LINE "); ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁M ▁= ▁100 000000 7 ▁; ▁static ▁int ▁power ▁( ▁int ▁X ▁, ▁int ▁Y ▁) ▁{ ▁int ▁res ▁= ▁1 ▁; ▁X ▁= ▁X ▁% ▁M ▁; ▁if ▁( ▁X ▁== ▁0 ▁) ▁return ▁0 ▁; ▁while ▁( ▁Y ▁> ▁0 ▁) ▁{ ▁if ▁( ▁( ▁Y ▁& ▁1 ▁) ▁!= ▁0 ▁) ▁{ ▁res ▁= ▁( ▁res ▁* ▁X ▁) ▁% ▁M ▁; ▁} ▁Y ▁= ▁Y ▁>> ▁1 ▁; ▁X ▁= ▁( ▁X ▁* ▁X ▁) ▁% ▁M ▁; ▁} ▁return ▁res ▁; ▁} ▁static ▁int ▁find Value ▁( ▁int ▁n ▁) ▁{ ▁int ▁X ▁= ▁0 ▁; ▁int ▁pow _10 ▁= ▁1 ▁; ▁while ▁( ▁n ▁!= ▁0 ▁) ▁{ ▁if ▁( ▁( ▁n ▁& ▁1 ▁) ▁!= ▁0 ▁) ▁{ ▁X ▁+= ▁pow _10 ▁; ▁} ▁pow _10 ▁*= ▁10 ▁; ▁n ▁/= ▁2 ▁; ▁} ▁X ▁= ▁( ▁X ▁* ▁2 ▁) ▁% ▁M ▁; ▁int ▁res ▁= ▁power ▁( ▁2 ▁, ▁X ▁) ▁; ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Value ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁count W ays To Tile Board ▁( ▁int ▁N ▁) ▁{ ▁int ▁dp ▁[ ▁] ▁= ▁new ▁int ▁[ ▁N ▁+ ▁1 ▁] ▁; ▁dp ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁dp ▁[ ▁1 ▁] ▁= ▁2 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁= ▁( ▁2 ▁* ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁dp ▁[ ▁i ▁- ▁2 ▁] ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁dp ▁[ ▁N ▁] ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁2 ▁; ▁count W ays To Tile Board ▁( ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁remove Small est Sub array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁S ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁target _ rem ainder ▁= ▁S ▁% ▁k ▁; ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁map 1 ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁map 1 ▁. ▁put ▁( ▁0 ▁, ▁- ▁1 ▁) ▁; ▁int ▁curr _ rem ainder ▁= ▁0 ▁; ▁int ▁res ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁curr _ rem ainder ▁= ▁( ▁curr _ rem ainder ▁+ ▁arr ▁[ ▁i ▁] ▁+ ▁k ▁) ▁% ▁k ▁; ▁map 1 ▁. ▁put ▁( ▁curr _ rem ainder ▁, ▁i ▁) ▁; ▁int ▁mod ▁= ▁( ▁curr _ rem ainder ▁- ▁target _ rem ainder ▁+ ▁k ▁) ▁% ▁k ▁; ▁if ▁( ▁map 1 ▁. ▁containsKey ▁( ▁mod ▁) ▁) ▁{ ▁res ▁= ▁Math ▁. ▁min ▁( ▁res ▁, ▁i ▁- ▁map 1 ▁. ▁get ▁( ▁mod ▁) ▁) ▁; ▁} ▁} ▁if ▁( ▁res ▁== ▁Integer ▁. ▁MAX _ VALUE ▁res ▁== ▁n ▁) ▁{ ▁res ▁= ▁- ▁1 ▁; ▁} ▁return ▁res ▁; ▁} ▁static ▁int ▁sm st Sub mat Deleted ▁( ▁int ▁[ ▁] ▁[ ▁] ▁mat ▁, ▁int ▁N ▁, ▁int ▁M ▁, ▁int ▁K ▁) ▁{ ▁int ▁S ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁M ▁; ▁j ▁++ ▁) ▁S ▁+= ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁} ▁int ▁min _ area ▁= ▁N ▁* ▁M ▁; ▁int ▁left ▁= ▁0 ▁; ▁int ▁right ▁= ▁0 ▁; ▁int ▁width ▁; ▁int ▁area ▁; ▁int ▁[ ▁] ▁prefix Row Sum ▁= ▁new ▁int ▁[ ▁N ▁] ▁; ▁for ▁( ▁left ▁= ▁0 ▁; ▁left ▁< ▁M ▁; ▁left ▁++ ▁) ▁{ ▁Arrays ▁. ▁fill ▁( ▁prefix Row Sum ▁, ▁0 ▁) ▁; ▁for ▁( ▁right ▁= ▁left ▁; ▁right ▁< ▁M ▁; ▁right ▁++ ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁prefix Row Sum ▁[ ▁i ▁] ▁+= ▁mat ▁[ ▁i ▁] ▁[ ▁right ▁] ▁; ▁} ▁width ▁= ▁remove Small est Sub array ▁( ▁prefix
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁public ▁class ▁Main ▁{ ▁static ▁int ▁count strings ▁( ▁int ▁n ▁, ▁int ▁start ▁) ▁{ ▁if ▁( ▁n ▁== ▁0 ▁) ▁{ ▁return ▁1 ▁; ▁} ▁int ▁cnt ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁start ▁; ▁i ▁< ▁5 ▁; ▁i ▁++ ▁) ▁{ ▁cnt ▁+= ▁count strings ▁( ▁n ▁- ▁1 ▁, ▁i ▁) ▁; ▁} ▁return ▁cnt ▁; ▁} ▁static ▁int ▁count V ow el Strings ▁( ▁int ▁n ▁) ▁{ ▁return ▁count strings ▁( ▁n ▁, ▁0 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁count V ow el Strings ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁find NumberOf Strings ▁( ▁int ▁n ▁) ▁{ ▁return ▁( ▁n ▁+ ▁1 ▁) ▁* ▁( ▁n ▁+ ▁2 ▁) ▁* ▁( ▁n ▁+ ▁3 ▁) ▁* ▁( ▁n ▁+ ▁4 ▁) ▁/ ▁24 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁find NumberOf Strings ▁( ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁mod ▁= ▁( ▁int ▁) ▁1 e 9 ▁+ ▁7 ▁; ▁static ▁int ▁find Total Path ▁( ▁int ▁X ▁, ▁int ▁n ▁, ▁ArrayList ▁< ▁Integer ▁> ▁dp ▁) ▁{ ▁if ▁( ▁X ▁== ▁0 ▁) ▁{ ▁return ▁1 ▁; ▁} ▁int ▁ans ▁= ▁0 ▁; ▁if ▁( ▁dp ▁. ▁get ▁( ▁X ▁) ▁!= ▁- ▁1 ▁) ▁{ ▁return ▁dp ▁. ▁get ▁( ▁X ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁Math ▁. ▁min ▁( ▁X ▁, ▁n ▁) ▁; ▁++ ▁i ▁) ▁{ ▁ans ▁+= ▁find Total Path ▁( ▁X ▁- ▁i ▁, ▁n ▁, ▁dp ▁) ▁% ▁mod ▁; ▁ans ▁% = ▁mod ▁; ▁} ▁dp ▁. ▁set ▁( ▁X ▁, ▁ans ▁) ▁; ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁3 ▁, ▁X ▁= ▁2 ▁; ▁ArrayList ▁< ▁Integer ▁> ▁dp ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁Collections ▁. ▁n Copies ▁( ▁X ▁+ ▁1 ▁, ▁- ▁1 ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁find Total Path ▁( ▁X ▁, ▁n ▁, ▁dp ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁MAX ▁= ▁10000 5 ▁; ▁static ▁Vector ▁< ▁Integer ▁> ▁S ieve Of E rat ost hen es ▁( ▁) ▁{ ▁boolean ▁[ ▁] ▁se ive ▁= ▁new ▁boolean ▁[ ▁MAX ▁] ▁; ▁Arrays ▁. ▁fill ▁( ▁se ive ▁, ▁true ▁) ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁* ▁p ▁< ▁MAX ▁; ▁p ▁++ ▁) ▁{ ▁if ▁( ▁se ive ▁[ ▁p ▁] ▁== ▁true ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁p ▁* ▁p ▁; ▁i ▁< ▁MAX ▁; ▁i ▁+= ▁p ▁) ▁{ ▁se ive ▁[ ▁i ▁] ▁= ▁false ▁; ▁} ▁} ▁} ▁Vector ▁< ▁Integer ▁> ▁v ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁< ▁MAX ▁; ▁p ▁++ ▁) ▁{ ▁if ▁( ▁se ive ▁[ ▁p ▁] ▁) ▁{ ▁v ▁. ▁add ▁( ▁p ▁) ▁; ▁} ▁} ▁return ▁v ▁; ▁} ▁static ▁void ▁build ▁( ▁int ▁dp ▁[ ▁] ▁, ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁dp ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁dp ▁[ ▁1 ▁] ▁= ▁0 ▁; ▁Vector ▁< ▁Integer ▁> ▁prime ▁= ▁S ieve Of E rat ost hen es ▁( ▁) ▁; ▁int ▁[ ▁] ▁pref ▁= ▁new ▁int ▁[ ▁N ▁+ ▁1 ▁] ▁; ▁pref ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁pref ▁[ ▁i ▁] ▁= ▁pref ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁<= ▁prime ▁. ▁size ▁( ▁) ▁; ▁j ▁++ ▁) ▁{ ▁int ▁r ▁= ▁i ▁- ▁1 ▁; ▁int ▁l ▁= ▁r ▁- ▁prime ▁. ▁get ▁( ▁j ▁) ▁+ ▁1 ▁; ▁if ▁( ▁l ▁< ▁0 ▁) ▁break ▁; ▁int ▁temp ▁= ▁0 ▁; ▁temp ▁= ▁pref ▁[ ▁r ▁+ ▁1 ▁] ▁- ▁pref ▁[ ▁l ▁] ▁; ▁if ▁( ▁l ▁- ▁2 ▁>= ▁0 ▁) ▁temp ▁+= ▁dp ▁[ ▁l ▁- ▁2 ▁+ ▁1 ▁] ▁; ▁dp ▁[ ▁i ▁] ▁= ▁Math ▁. ▁max ▁( ▁dp ▁[ ▁i ▁] ▁, ▁temp ▁) ▁; ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁bin C off ▁( ▁int ▁N ▁, ▁int ▁R ▁) ▁{ ▁int ▁res ▁= ▁1 ▁; ▁if ▁( ▁R ▁> ▁( ▁N ▁- ▁R ▁) ▁) ▁{ ▁R ▁= ▁( ▁N ▁- ▁R ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁R ▁; ▁i ▁++ ▁) ▁{ ▁res ▁*= ▁( ▁N ▁- ▁i ▁) ▁; ▁res ▁/= ▁( ▁i ▁+ ▁1 ▁) ▁; ▁} ▁return ▁res ▁; ▁} ▁static ▁int ▁cnt Perm utation ▁( ▁int ▁N ▁) ▁{ ▁int ▁cnt Perm ▁; ▁int ▁C _2 N _ N ▁= ▁bin C off ▁( ▁2 ▁* ▁N ▁, ▁N ▁) ▁; ▁cnt Perm ▁= ▁C _2 N _ N ▁/ ▁( ▁N ▁+ ▁1 ▁) ▁; ▁return ▁cnt Perm ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁cnt Perm utation ▁( ▁N ▁/ ▁2 ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁check Equal Sum Util ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁sm 1 ▁, ▁int ▁sm 2 ▁, ▁int ▁sm 3 ▁, ▁int ▁j ▁) ▁{ ▁if ▁( ▁j ▁== ▁N ▁) ▁{ ▁if ▁( ▁sm 1 ▁== ▁sm 2 ▁&& ▁sm 2 ▁== ▁sm 3 ▁) ▁return ▁1 ▁; ▁else ▁return ▁0 ▁; ▁} ▁else ▁{ ▁int ▁l ▁= ▁check Equal Sum Util ▁( ▁arr ▁, ▁N ▁, ▁sm 1 ▁+ ▁arr ▁[ ▁j ▁] ▁, ▁sm 2 ▁, ▁sm 3 ▁, ▁j ▁+ ▁1 ▁) ▁; ▁int ▁m ▁= ▁check Equal Sum Util ▁( ▁arr ▁, ▁N ▁, ▁sm 1 ▁, ▁sm 2 ▁+ ▁arr ▁[ ▁j ▁] ▁, ▁sm 3 ▁, ▁j ▁+ ▁1 ▁) ▁; ▁int ▁r ▁= ▁check Equal Sum Util ▁( ▁arr ▁, ▁N ▁, ▁sm 1 ▁, ▁sm 2 ▁, ▁sm 3 ▁+ ▁arr ▁[ ▁j ▁] ▁, ▁j ▁+ ▁1 ▁) ▁; ▁return ▁Math ▁. ▁max ▁( ▁Math ▁. ▁max ▁( ▁l ▁, ▁m ▁) ▁, ▁r ▁) ▁; ▁} ▁} ▁static ▁void ▁check Equal Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁sum 1 ▁, ▁sum 2 ▁, ▁sum 3 ▁; ▁sum 1 ▁= ▁sum 2 ▁= ▁sum 3 ▁= ▁0 ▁; ▁if ▁( ▁check Equal Sum Util ▁( ▁arr ▁, ▁N ▁, ▁sum 1 ▁, ▁sum 2 ▁, ▁sum 3 ▁, ▁0 ▁) ▁== ▁1 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Yes ▁" ▁) ▁; ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁17 ▁, ▁34 ▁, ▁59 ▁, ▁23 ▁, ▁17 ▁, ▁67 ▁, ▁57 ▁, ▁2 ▁, ▁18 ▁, ▁59 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁check Equal Sum ▁( ▁arr ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁Sub array With Max Sum ▁( ▁Vector ▁< ▁Integer ▁> ▁nums ▁) ▁{ ▁int ▁endIndex ▁= ▁0 ▁, ▁curr Max ▁= ▁nums ▁. ▁get ▁( ▁0 ▁) ▁; ▁int ▁global Max ▁= ▁nums ▁. ▁get ▁( ▁0 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁nums ▁. ▁size ▁( ▁) ▁; ▁++ ▁i ▁) ▁{ ▁curr Max ▁= ▁Math ▁. ▁max ▁( ▁nums ▁. ▁get ▁( ▁i ▁) ▁, ▁nums ▁. ▁get ▁( ▁i ▁) ▁+ ▁curr Max ▁) ▁; ▁if ▁( ▁curr Max ▁> ▁global Max ▁) ▁{ ▁global Max ▁= ▁curr Max ▁; ▁endIndex ▁= ▁i ▁; ▁} ▁} ▁int ▁startIndex ▁= ▁endIndex ▁; ▁while ▁( ▁startIndex ▁>= ▁0 ▁) ▁{ ▁global Max ▁-= ▁nums ▁. ▁get ▁( ▁startIndex ▁) ▁; ▁if ▁( ▁global Max ▁== ▁0 ▁) ▁break ▁; ▁startIndex ▁-- ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁startIndex ▁; ▁i ▁<= ▁endIndex ▁; ▁++ ▁i ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁nums ▁. ▁get ▁( ▁i ▁) ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Vector ▁< ▁Integer ▁> ▁arr ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁arr ▁. ▁add ▁( ▁- ▁2 ▁) ▁; ▁arr ▁. ▁add ▁( ▁- ▁5 ▁) ▁; ▁arr ▁. ▁add ▁( ▁6 ▁) ▁; ▁arr ▁. ▁add ▁( ▁- ▁2 ▁) ▁; ▁arr ▁. ▁add ▁( ▁- ▁3 ▁) ▁; ▁arr ▁. ▁add ▁( ▁1 ▁) ▁; ▁arr ▁. ▁add ▁( ▁5 ▁) ▁; ▁arr ▁. ▁add ▁( ▁- ▁6 ▁) ▁; ▁Sub array With Max Sum ▁( ▁arr ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁int ▁max imize Sum ▁( ▁int ▁[ ▁] ▁arr ▁) ▁{ ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁= ▁i ▁+ ▁2 ▁) ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁int ▁left DP ▁[ ▁] ▁= ▁new ▁int ▁[ ▁n ▁/ ▁2 ▁] ▁; ▁int ▁right DP ▁[ ▁] ▁= ▁new ▁int ▁[ ▁n ▁/ ▁2 ▁] ▁; ▁int ▁c ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁= ▁i ▁+ ▁2 ▁) ▁{ ▁int ▁left Diff ▁= ▁arr ▁[ ▁i ▁] ▁- ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁; ▁if ▁( ▁c ▁- ▁1 ▁< ▁0 ▁) ▁left DP ▁= ▁left Diff ▁; ▁else ▁{ ▁if ▁( ▁left DP ▁> ▁0 ▁) ▁left DP ▁= ▁left Diff ▁+ ▁left DP ▁; ▁else ▁left DP ▁[ ▁i ▁] ▁= ▁left Diff ▁; ▁} ▁int ▁right Diff ▁; ▁if ▁( ▁i ▁+ ▁1 ▁>= ▁arr ▁. ▁length ▁) ▁right Diff ▁= ▁0 ▁; ▁else ▁right Diff ▁= ▁arr ▁[ ▁i ▁] ▁- ▁arr ▁[ ▁i ▁+ ▁1 ▁] ▁; ▁if ▁( ▁c ▁- ▁1 ▁< ▁0 ▁) ▁right DP ▁= ▁right Diff ▁; ▁else ▁{ ▁if ▁( ▁right DP ▁> ▁0 ▁) ▁right DP ▁= ▁right Diff ▁+ ▁right DP ▁; ▁else ▁right DP ▁= ▁right Diff ▁; ▁} ▁c ▁++ ▁; ▁} ▁int ▁max ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁/ ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁max ▁= ▁Math ▁. ▁max ▁( ▁max ▁, ▁Math ▁. ▁max ▁( ▁left DP ▁[ ▁i ▁] ▁, ▁right DP ▁[ ▁i ▁] ▁) ▁) ▁; ▁} ▁return ▁max ▁+ ▁sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁7 ▁, ▁8 ▁, ▁4 ▁, ▁5 ▁, ▁7 ▁, ▁6 ▁, ▁8 ▁, ▁9 ▁, ▁7 ▁, ▁3 ▁} ▁; ▁int ▁ans ▁= ▁max imize Sum ▁( ▁arr ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁ans ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁valid sub sequences ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁long ▁dp ▁[ ▁] ▁[ ▁] ▁= ▁new ▁long ▁[ ▁n ▁+ ▁1 ▁] ▁[ ▁2 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁dp ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁= ▁0 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁% ▁2 ▁!= ▁0 ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁+= ▁1 ▁; ▁dp ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁+= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁0 ▁] ▁; ▁dp ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁+= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁1 ▁] ▁; ▁dp ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁+= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁0 ▁] ▁; ▁} ▁else ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁+= ▁1 ▁; ▁dp ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁+= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁1 ▁] ▁; ▁dp ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁+= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁0 ▁] ▁; ▁dp ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁+= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁1 ▁] ▁; ▁} ▁} ▁return ▁( ▁int ▁) ▁( ▁dp ▁[ ▁n ▁] ▁[ ▁0 ▁] ▁+ ▁dp ▁[ ▁n ▁] ▁[ ▁1 ▁] ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁6 ▁, ▁9 ▁, ▁7 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁valid sub sequences ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁class ▁pair ▁{ ▁int ▁first ▁, ▁second ▁; ▁public ▁pair ▁( ▁int ▁first ▁, ▁int ▁second ▁) ▁{ ▁this ▁. ▁first ▁= ▁first ▁; ▁this ▁. ▁second ▁= ▁second ▁; ▁} ▁} ▁static ▁void ▁O dd Div is ors Count ▁( ▁int ▁n ▁, ▁int ▁q ▁, ▁int ▁a ▁[ ▁] ▁, ▁pair ▁[ ▁] ▁Query ▁) ▁{ ▁int ▁D P ▁[ ▁] ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁x ▁= ▁( ▁int ▁) ▁Math ▁. ▁sqrt ▁( ▁a ▁[ ▁i ▁] ▁) ▁; ▁if ▁( ▁x ▁* ▁x ▁== ▁a ▁[ ▁i ▁] ▁) ▁D P ▁[ ▁i ▁] ▁= ▁1 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁D P ▁[ ▁i ▁] ▁= ▁D P ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁D P ▁[ ▁i ▁] ▁; ▁} ▁int ▁l ▁, ▁r ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁q ▁; ▁i ▁++ ▁) ▁{ ▁l ▁= ▁Query ▁[ ▁i ▁] ▁. ▁first ▁; ▁r ▁= ▁Query ▁[ ▁i ▁] ▁. ▁second ▁; ▁if ▁( ▁l ▁== ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁D P ▁[ ▁r ▁] ▁+ ▁" NEW _ LINE "); ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁D P ▁[ ▁r ▁] ▁- ▁D P ▁[ ▁l ▁- ▁1 ▁] ▁+ ▁" NEW _ LINE "); ▁} ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁5 ▁; ▁int ▁Q ▁= ▁3 ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁, ▁9 ▁} ▁; ▁pair ▁[ ▁] ▁Query ▁= ▁{ ▁new ▁pair ▁( ▁0 ▁, ▁2 ▁) ▁, ▁new ▁pair ▁( ▁1 ▁, ▁3 ▁) ▁, ▁new ▁pair ▁( ▁1 ▁, ▁4 ▁) ▁} ▁; ▁O dd Div is ors Count ▁( ▁N ▁, ▁Q ▁, ▁arr ▁, ▁Query ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁count Stable Num ▁( ▁String ▁str ▁, ▁int ▁N ▁) ▁{ ▁int ▁count 1 ▁[ ▁] ▁[ ▁] ▁= ▁new ▁int ▁[ ▁N ▁] ▁[ ▁10 ▁] ▁; ▁int ▁count 2 ▁[ ▁] ▁[ ▁] ▁= ▁new ▁int ▁[ ▁N ▁] ▁[ ▁10 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁10 ▁; ▁j ▁++ ▁) ▁count 1 ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁count 2 ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁!= ▁0 ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁10 ▁; ▁j ▁++ ▁) ▁{ ▁count 1 ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+= ▁count 1 ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁; ▁} ▁} ▁count 1 ▁[ ▁i ▁] ▁[ ▁str ▁. ▁charAt ▁( ▁i ▁) ▁- ▁'0' ▁] ▁++ ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁N ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁i ▁!= ▁N ▁- ▁1 ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁10 ▁; ▁j ▁++ ▁) ▁{ ▁count 2 ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+= ▁count 2 ▁[ ▁i ▁+ ▁1 ▁] ▁[ ▁j ▁] ▁; ▁} ▁} ▁count 2 ▁[ ▁i ▁] ▁[ ▁str ▁. ▁charAt ▁( ▁i ▁) ▁- ▁'0' ▁] ▁++ ▁; ▁} ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'9' ▁) ▁continue ▁; ▁int ▁c 1 ▁= ▁count 1 ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁str ▁. ▁charAt ▁( ▁i ▁) ▁- ▁'0' ▁] ▁; ▁int ▁c 2 ▁= ▁count 2 ▁[ ▁i ▁+ ▁1 ▁] ▁[ ▁str ▁. ▁charAt ▁( ▁i ▁) ▁- ▁'0' ▁+ ▁1 ▁] ▁; ▁if ▁( ▁c 2 ▁== ▁0 ▁) ▁continue ▁; ▁ans ▁= ▁( ▁ans ▁+ ▁( ▁c 1 ▁* ▁( ▁( ▁c 2 ▁* ▁( ▁c 2 ▁- ▁1 ▁) ▁/ ▁2 ▁) ▁) ▁) ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str
▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁final ▁long ▁MAX ▁= ▁( ▁long ▁) ▁1 e 18 ▁; ▁static ▁long ▁n ▁, ▁m ▁; ▁static ▁List ▁< ▁List ▁< ▁Long ▁> ▁> ▁v ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁15 1 ▁) ▁; ▁static ▁long ▁[ ▁] ▁[ ▁] ▁dp ▁= ▁new ▁long ▁[ ▁15 1 ▁] ▁[ ▁15 1 ▁] ▁; ▁static ▁long ▁min _ operation ▁( ▁long ▁i ▁, ▁long ▁j ▁, ▁long ▁val ▁, ▁long ▁x ▁) ▁{ ▁if ▁( ▁i ▁== ▁n ▁- ▁1 ▁&& ▁j ▁== ▁m ▁- ▁1 ▁) ▁{ ▁if ▁( ▁val ▁> ▁v ▁. ▁get ▁( ▁( ▁int ▁) ▁i ▁) ▁. ▁get ▁( ▁( ▁int ▁) ▁j ▁) ▁) ▁{ ▁return ▁dp ▁[ ▁( ▁int ▁) ▁i ▁] ▁[ ▁( ▁int ▁) ▁j ▁] ▁= ▁MAX ▁; ▁} ▁else ▁{ ▁return ▁dp ▁[ ▁( ▁int ▁) ▁i ▁] ▁[ ▁( ▁int ▁) ▁j ▁] ▁= ▁v ▁. ▁get ▁( ▁( ▁int ▁) ▁i ▁) ▁. ▁get ▁( ▁( ▁int ▁) ▁j ▁) ▁- ▁val ▁; ▁} ▁} ▁if ▁( ▁i ▁== ▁n ▁j ▁== ▁m ▁) ▁{ ▁return ▁dp ▁[ ▁( ▁int ▁) ▁i ▁] ▁[ ▁( ▁int ▁) ▁j ▁] ▁= ▁MAX ▁; ▁} ▁if ▁( ▁dp ▁[ ▁( ▁int ▁) ▁i ▁] ▁[ ▁( ▁int ▁) ▁j ▁] ▁!= ▁- ▁1 ▁) ▁{ ▁return ▁dp ▁[ ▁( ▁int ▁) ▁i ▁] ▁[ ▁( ▁int ▁) ▁j ▁] ▁; ▁} ▁if ▁( ▁val ▁> ▁v ▁. ▁get ▁( ▁( ▁int ▁) ▁i ▁) ▁. ▁get ▁( ▁( ▁int ▁) ▁j ▁) ▁) ▁{ ▁return ▁dp ▁[ ▁( ▁int ▁) ▁i ▁] ▁[ ▁( ▁int ▁) ▁j ▁] ▁= ▁MAX ▁; ▁} ▁long ▁tmp ▁= ▁v ▁. ▁get ▁( ▁( ▁int ▁) ▁i ▁) ▁. ▁get ▁( ▁( ▁int ▁) ▁j ▁) ▁- ▁val ▁; ▁tmp ▁+= ▁Math ▁. ▁min ▁( ▁min _ operation ▁( ▁i ▁+ ▁1 ▁, ▁j ▁, ▁val ▁+ ▁x ▁, ▁x ▁) ▁, ▁min _ operation ▁( ▁i ▁, ▁j ▁+ ▁1 ▁, ▁val ▁+ ▁x ▁, ▁x ▁) ▁) ▁; ▁return ▁dp ▁[ ▁( ▁int ▁) ▁i ▁] ▁[ ▁( ▁int ▁) ▁j ▁] ▁= ▁tmp ▁; ▁} ▁static ▁long ▁solve ▁( ▁long ▁x ▁) ▁{ ▁long ▁ans ▁= ▁Long ▁. ▁MAX _ VALUE ▁; ▁for ▁( ▁long ▁i ▁= ▁0 ▁;
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁K ▁; ▁static ▁int ▁N ▁; ▁static ▁Vector ▁< ▁Integer ▁> ▁v ▁= ▁new ▁Vector ▁< ▁> ▁( ▁) ▁; ▁static ▁int ▁[ ▁] ▁[ ▁] ▁[ ▁] ▁[ ▁] ▁[ ▁] ▁dp ▁= ▁new ▁int ▁[ ▁20 ▁] ▁[ ▁1000 ▁] ▁[ ▁10 ▁] ▁[ ▁2 ▁] ▁[ ▁2 ▁] ▁; ▁static ▁void ▁init ▁( ▁int ▁x ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁20 ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁1000 ▁; ▁j ▁++ ▁) ▁for ▁( ▁int ▁k ▁= ▁0 ▁; ▁k ▁< ▁10 ▁; ▁k ▁++ ▁) ▁for ▁( ▁int ▁l ▁= ▁0 ▁; ▁l ▁< ▁2 ▁; ▁l ▁++ ▁) ▁for ▁( ▁int ▁m ▁= ▁0 ▁; ▁m ▁< ▁2 ▁; ▁m ▁++ ▁) ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁[ ▁k ▁] ▁[ ▁l ▁] ▁[ ▁m ▁] ▁= ▁- ▁1 ▁; ▁v ▁. ▁clear ▁( ▁) ▁; ▁while ▁( ▁x ▁> ▁0 ▁) ▁{ ▁v ▁. ▁add ▁( ▁x ▁% ▁10 ▁) ▁; ▁x ▁/= ▁10 ▁; ▁} ▁Collections ▁. ▁reverse ▁( ▁v ▁) ▁; ▁N ▁= ▁v ▁. ▁size ▁( ▁) ▁; ▁} ▁static ▁int ▁fun ▁( ▁int ▁pos ▁, ▁int ▁sum ▁, ▁int ▁st ▁, ▁int ▁check ▁, ▁int ▁f ▁) ▁{ ▁if ▁( ▁pos ▁== ▁N ▁) ▁{ ▁return ▁( ▁sum ▁== ▁0 ▁&& ▁check ▁== ▁1 ▁) ▁? ▁1 ▁: ▁0 ▁; ▁} ▁if ▁( ▁dp ▁[ ▁pos ▁] ▁[ ▁sum ▁] ▁[ ▁st ▁] ▁[ ▁check ▁] ▁[ ▁f ▁] ▁!= ▁- ▁1 ▁) ▁return ▁dp ▁[ ▁pos ▁] ▁[ ▁sum ▁] ▁[ ▁st ▁] ▁[ ▁check ▁] ▁[ ▁f ▁] ▁; ▁int ▁l mt ▁= ▁9 ▁; ▁if ▁( ▁f ▁== ▁0 ▁) ▁l mt ▁= ▁v ▁. ▁get ▁( ▁pos ▁) ▁; ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁digit ▁= ▁0 ▁; ▁digit ▁<= ▁l mt ▁; ▁digit ▁++ ▁) ▁{ ▁int ▁nf ▁= ▁f ▁; ▁int ▁new _ sum ▁= ▁( ▁sum ▁+ ▁digit ▁) ▁% ▁K ▁; ▁int ▁new _ check ▁= ▁check ▁; ▁int ▁new _ st ▁= ▁st ▁; ▁if ▁( ▁f ▁== ▁0 ▁&& ▁digit ▁< ▁l mt ▁) ▁nf ▁= ▁1 ▁; ▁if ▁( ▁check ▁== ▁0 ▁&& ▁digit ▁!= ▁0 ▁) ▁{ ▁new _ st ▁= ▁digit ▁; ▁new _ check
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁is Perf ect Square ▁( ▁double ▁x ▁) ▁{ ▁double ▁sr ▁= ▁Math ▁. ▁sqrt ▁( ▁x ▁) ▁; ▁return ▁( ▁( ▁sr ▁- ▁Math ▁. ▁floor ▁( ▁sr ▁) ▁) ▁== ▁0 ▁) ▁; ▁} ▁static ▁int ▁find Sub array Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁K ▁) ▁{ ▁Map ▁< ▁Integer ▁, ▁Integer ▁> ▁prev Sum ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁int ▁res ▁= ▁0 ▁; ▁int ▁curr sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁curr sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁if ▁( ▁curr sum ▁== ▁K ▁) ▁{ ▁res ▁++ ▁; ▁} ▁if ▁( ▁prev Sum ▁. ▁containsKey ▁( ▁curr sum ▁- ▁K ▁) ▁) ▁res ▁+= ▁( ▁prev Sum ▁. ▁get ▁( ▁curr sum ▁- ▁K ▁) ▁) ▁; ▁prev Sum ▁. ▁put ▁( ▁curr sum ▁, ▁prev Sum ▁. ▁getOr Default ▁( ▁curr sum ▁, ▁0 ▁) ▁+ ▁1 ▁) ▁; ▁} ▁return ▁res ▁; ▁} ▁static ▁void ▁count Sub array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁K ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁is Perf ect Square ▁( ▁arr ▁[ ▁i ▁] ▁) ▁) ▁{ ▁arr ▁[ ▁i ▁] ▁= ▁1 ▁; ▁} ▁else ▁{ ▁arr ▁[ ▁i ▁] ▁= ▁0 ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁find Sub array Sum ▁( ▁arr ▁, ▁n ▁, ▁K ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁4 ▁, ▁9 ▁, ▁2 ▁} ▁; ▁int ▁K ▁= ▁2 ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁count Sub array ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁final ▁int ▁dim ▁= ▁5 ▁; ▁static ▁void ▁createTable ▁( ▁int ▁m tr x ▁[ ▁] ▁[ ▁] ▁, ▁int ▁k ▁, ▁int ▁p ▁, ▁int ▁dp ▁[ ▁] ▁[ ▁] ▁) ▁{ ▁dp ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁= ▁m tr x ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁< ▁dim ▁; ▁j ▁++ ▁) ▁{ ▁dp ▁[ ▁0 ▁] ▁[ ▁j ▁] ▁= ▁m tr x ▁[ ▁0 ▁] ▁[ ▁j ▁] ▁+ ▁dp ▁[ ▁0 ▁] ▁[ ▁j ▁- ▁1 ▁] ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁dim ▁; ▁i ▁++ ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁= ▁m tr x ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁+ ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁0 ▁] ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁dim ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁< ▁dim ▁; ▁j ▁++ ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁m tr x ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+ ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁+ ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁- ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁- ▁1 ▁] ▁; ▁} ▁} ▁} ▁static ▁int ▁count Sub Matrix Util ▁( ▁int ▁dp ▁[ ▁] ▁[ ▁] ▁, ▁int ▁k ▁, ▁int ▁p ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁int ▁sub Mat Sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁k ▁- ▁1 ▁; ▁i ▁< ▁dim ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁k ▁- ▁1 ▁; ▁j ▁< ▁dim ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁i ▁== ▁( ▁k ▁- ▁1 ▁) ▁|| ▁j ▁== ▁( ▁k ▁- ▁1 ▁) ▁) ▁{ ▁if ▁( ▁i ▁== ▁( ▁k ▁- ▁1 ▁) ▁&& ▁j ▁== ▁( ▁k ▁- ▁1 ▁) ▁) ▁{ ▁sub Mat Sum ▁= ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁} ▁else ▁if ▁( ▁i ▁== ▁( ▁k ▁- ▁1 ▁) ▁) ▁{ ▁sub Mat Sum ▁= ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁- ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁- ▁k ▁] ▁; ▁} ▁else ▁{ ▁sub Mat Sum ▁= ▁dp ▁[ ▁i ▁] ▁[ ▁j
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁count W ays ▁( ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁int ▁[ ▁] ▁[ ▁] ▁dp ▁= ▁new ▁int ▁[ ▁m ▁+ ▁1 ▁] ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁dp ▁[ ▁1 ▁] ▁[ ▁i ▁] ▁= ▁1 ▁; ▁if ▁( ▁i ▁!= ▁0 ▁) ▁{ ▁dp ▁[ ▁1 ▁] ▁[ ▁i ▁] ▁+= ▁dp ▁[ ▁1 ▁] ▁[ ▁i ▁- ▁1 ▁] ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁m ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁<= ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁j ▁== ▁0 ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁; ▁} ▁else ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁; ▁if ▁( ▁i ▁== ▁m ▁&& ▁j ▁== ▁n ▁) ▁{ ▁return ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁} ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+= ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁; ▁} ▁} ▁} ▁return ▁Integer ▁. ▁MIN _ VALUE ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁2 ▁, ▁K ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁count W ays ▁( ▁N ▁, ▁K ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁check ▁( ▁Vector ▁< ▁Integer ▁> ▁v ▁) ▁{ ▁HashSet ▁< ▁Integer ▁> ▁digits ▁= ▁new ▁HashSet ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁v ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁HashSet ▁< ▁Integer ▁> ▁d ▁= ▁new ▁HashSet ▁< ▁Integer ▁> ▁( ▁) ▁; ▁while ▁( ▁v ▁. ▁get ▁( ▁i ▁) ▁> ▁0 ▁) ▁{ ▁d ▁. ▁add ▁( ▁v ▁. ▁get ▁( ▁i ▁) ▁% ▁10 ▁) ▁; ▁v ▁. ▁set ▁( ▁i ▁, ▁v ▁. ▁get ▁( ▁i ▁) ▁/ ▁10 ▁) ▁; ▁} ▁for ▁( ▁int ▁it ▁: ▁d ▁) ▁{ ▁if ▁( ▁digits ▁. ▁contains ▁( ▁it ▁) ▁) ▁return ▁false ▁; ▁} ▁for ▁( ▁int ▁it ▁: ▁d ▁) ▁digits ▁. ▁add ▁( ▁it ▁) ▁; ▁} ▁return ▁true ▁; ▁} ▁static ▁int ▁numberOf Sub arrays ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁answer ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁( ▁1 ▁<< ▁n ▁) ▁; ▁i ▁++ ▁) ▁{ ▁Vector ▁< ▁Integer ▁> ▁temp ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁( ▁i ▁& ▁( ▁1 ▁<< ▁j ▁) ▁) ▁> ▁0 ▁) ▁temp ▁. ▁add ▁( ▁a ▁[ ▁j ▁] ▁) ▁; ▁} ▁if ▁( ▁check ▁( ▁temp ▁) ▁) ▁answer ▁++ ▁; ▁} ▁return ▁answer ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁4 ▁; ▁int ▁A ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁12 ▁, ▁23 ▁, ▁34 ▁} ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁numberOf Sub arrays ▁( ▁A ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁maximum Occurrence ▁( ▁String ▁s ▁) ▁{ ▁int ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁HashMap ▁< ▁String ▁, ▁Integer ▁> ▁freq ▁= ▁new ▁HashMap ▁< ▁String ▁, ▁Integer ▁> ▁( ▁) ▁; ▁int ▁i ▁, ▁j ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁String ▁temp ▁= ▁" ▁" ▁; ▁temp ▁+= ▁s ▁. ▁charAt ▁( ▁i ▁) ▁; ▁if ▁( ▁freq ▁. ▁containsKey ▁( ▁temp ▁) ▁) ▁{ ▁freq ▁. ▁put ▁( ▁temp ▁, ▁freq ▁. ▁get ▁( ▁temp ▁) ▁+ ▁1 ▁) ▁; ▁} ▁else ▁{ ▁freq ▁. ▁put ▁( ▁temp ▁, ▁1 ▁) ▁; ▁} ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁String ▁temp ▁= ▁" ▁" ▁; ▁temp ▁+= ▁s ▁. ▁charAt ▁( ▁i ▁) ▁; ▁temp ▁+= ▁s ▁. ▁charAt ▁( ▁j ▁) ▁; ▁if ▁( ▁freq ▁. ▁containsKey ▁( ▁temp ▁) ▁) ▁freq ▁. ▁put ▁( ▁temp ▁, ▁freq ▁. ▁get ▁( ▁temp ▁) ▁+ ▁1 ▁) ▁; ▁else ▁freq ▁. ▁put ▁( ▁temp ▁, ▁1 ▁) ▁; ▁} ▁} ▁int ▁answer ▁= ▁Integer ▁. ▁MIN _ VALUE ▁; ▁for ▁( ▁int ▁it ▁: ▁freq ▁. ▁values ▁( ▁) ▁) ▁answer ▁= ▁Math ▁. ▁max ▁( ▁answer ▁, ▁it ▁) ▁; ▁return ▁answer ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁s ▁= ▁" ▁xx xy y ▁" ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁maximum Occurrence ▁( ▁s ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁maxLength ▁( ▁int ▁[ ▁] ▁a ▁, ▁int ▁n ▁) ▁{ ▁int ▁maximum ▁= ▁1 ▁; ▁int ▁left ▁[ ▁] ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁int ▁right ▁[ ▁] ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁left ▁[ ▁i ▁] ▁= ▁1 ▁; ▁right ▁[ ▁i ▁] ▁= ▁1 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁2 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁> ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁{ ▁right ▁[ ▁i ▁] ▁= ▁right ▁[ ▁i ▁+ ▁1 ▁] ▁+ ▁1 ▁; ▁} ▁maximum ▁= ▁Math ▁. ▁max ▁( ▁maximum ▁, ▁right ▁[ ▁i ▁] ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁< ▁a ▁[ ▁i ▁- ▁1 ▁] ▁) ▁{ ▁left ▁[ ▁i ▁] ▁= ▁left ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁1 ▁; ▁} ▁} ▁if ▁( ▁n ▁> ▁2 ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁- ▁1 ▁] ▁> ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁{ ▁maximum ▁= ▁Math ▁. ▁max ▁( ▁maximum ▁, ▁left ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁right ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁; ▁} ▁} ▁} ▁return ▁maximum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁8 ▁, ▁7 ▁, ▁3 ▁, ▁5 ▁, ▁2 ▁, ▁9 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁maxLength ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁Map ▁< ▁String ▁, ▁Integer ▁> ▁dp ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁static ▁Integer ▁solve ▁( ▁char ▁[ ▁] ▁s ▁, ▁char ▁c ▁) ▁{ ▁if ▁( ▁s ▁. ▁length ▁== ▁1 ▁) ▁return ▁0 ▁; ▁if ▁( ▁s ▁. ▁length ▁== ▁2 ▁) ▁{ ▁if ▁( ▁s ▁[ ▁0 ▁] ▁== ▁s ▁[ ▁1 ▁] ▁&& ▁s ▁[ ▁0 ▁] ▁== ▁c ▁) ▁return ▁1 ▁; ▁else ▁return ▁0 ▁; ▁} ▁if ▁( ▁dp ▁. ▁containsKey ▁( ▁String ▁. ▁valueOf ▁( ▁s ▁) ▁+ ▁" ▁" ▁+ ▁c ▁) ▁) ▁return ▁dp ▁. ▁get ▁( ▁String ▁. ▁valueOf ▁( ▁s ▁) ▁+ ▁" ▁" ▁+ ▁c ▁) ▁; ▁Integer ▁ans ▁= ▁0 ▁; ▁if ▁( ▁s ▁[ ▁0 ▁] ▁== ▁s ▁[ ▁s ▁. ▁length ▁- ▁1 ▁] ▁&& ▁s ▁[ ▁0 ▁] ▁== ▁c ▁) ▁{ ▁for ▁( ▁char ▁c 1 ▁= ▁' ▁a ▁' ▁; ▁c 1 ▁<= ▁' ▁z ▁' ▁; ▁c 1 ▁++ ▁) ▁if ▁( ▁c 1 ▁!= ▁c ▁) ▁ans ▁= ▁Math ▁. ▁max ▁( ▁ans ▁, ▁1 ▁+ ▁solve ▁( ▁Arrays ▁. ▁copyOf Range ▁( ▁s ▁, ▁1 ▁, ▁s ▁. ▁length ▁- ▁1 ▁) ▁, ▁c 1 ▁) ▁) ▁; ▁} ▁else ▁{ ▁for ▁( ▁Integer ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁[ ▁i ▁] ▁== ▁c ▁) ▁{ ▁for ▁( ▁Integer ▁j ▁= ▁s ▁. ▁length ▁- ▁1 ▁; ▁j ▁> ▁i ▁; ▁j ▁-- ▁) ▁if ▁( ▁s ▁[ ▁j ▁] ▁== ▁c ▁) ▁{ ▁if ▁( ▁j ▁== ▁i ▁) ▁break ▁; ▁ans ▁= ▁solve ▁( ▁Arrays ▁. ▁copyOf Range ▁( ▁s ▁, ▁i ▁, ▁j ▁+ ▁1 ▁) ▁, ▁c ▁) ▁; ▁break ▁; ▁} ▁break ▁; ▁} ▁} ▁} ▁dp ▁. ▁put ▁( ▁String ▁. ▁valueOf ▁( ▁s ▁) ▁+ ▁" ▁" ▁+ ▁c ▁, ▁ans ▁) ▁; ▁return ▁dp ▁. ▁get ▁( ▁String ▁. ▁valueOf ▁( ▁s ▁) ▁+ ▁" ▁" ▁+ ▁c ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁s ▁= ▁" ▁ab sc rc db a ▁" ▁; ▁Integer ▁ma ▁= ▁0 ▁; ▁for ▁( ▁char ▁c 1 ▁= ▁' ▁a ▁' ▁; ▁c 1 ▁<= ▁' ▁z ▁' ▁; ▁c 1 ▁++ ▁) ▁ma ▁= ▁Math ▁.
▁class ▁G F G ▁{ ▁static ▁int ▁max Inc Sub arr ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁pre ▁[ ▁] ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁int ▁pos ▁[ ▁] ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁pre ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁pos ▁[ ▁n ▁- ▁1 ▁] ▁= ▁1 ▁; ▁int ▁l ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁> ▁a ▁[ ▁i ▁- ▁1 ▁] ▁) ▁pre ▁[ ▁i ▁] ▁= ▁pre ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁1 ▁; ▁else ▁pre ▁[ ▁i ▁] ▁= ▁1 ▁; ▁} ▁l ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁2 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁< ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁pos ▁[ ▁i ▁] ▁= ▁pos ▁[ ▁i ▁+ ▁1 ▁] ▁+ ▁1 ▁; ▁else ▁pos ▁[ ▁i ▁] ▁= ▁1 ▁; ▁} ▁int ▁ans ▁= ▁0 ▁; ▁l ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁> ▁a ▁[ ▁i ▁- ▁1 ▁] ▁) ▁l ▁++ ▁; ▁else ▁l ▁= ▁1 ▁; ▁ans ▁= ▁Math ▁. ▁max ▁( ▁ans ▁, ▁l ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁- ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁- ▁1 ▁] ▁< ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁ans ▁= ▁Math ▁. ▁max ▁( ▁pre ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁pos ▁[ ▁i ▁+ ▁1 ▁] ▁, ▁ans ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁max Inc Sub arr ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁max N ▁= ▁20 ▁; ▁static ▁int ▁max M ▁= ▁64 ▁; ▁static ▁int ▁[ ▁] ▁[ ▁] ▁dp ▁= ▁new ▁int ▁[ ▁max N ▁] ▁[ ▁max M ▁] ▁; ▁static ▁boolean ▁[ ▁] ▁[ ▁] ▁v ▁= ▁new ▁boolean ▁[ ▁max N ▁] ▁[ ▁max M ▁] ▁; ▁static ▁int ▁find Len ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁i ▁, ▁int ▁curr ▁, ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁if ▁( ▁i ▁== ▁n ▁) ▁{ ▁if ▁( ▁curr ▁== ▁m ▁) ▁return ▁0 ▁; ▁else ▁return ▁- ▁1 ▁; ▁} ▁if ▁( ▁v ▁[ ▁i ▁] ▁[ ▁curr ▁] ▁) ▁return ▁dp ▁[ ▁i ▁] ▁[ ▁curr ▁] ▁; ▁v ▁[ ▁i ▁] ▁[ ▁curr ▁] ▁= ▁true ▁; ▁int ▁l ▁= ▁find Len ▁( ▁arr ▁, ▁i ▁+ ▁1 ▁, ▁curr ▁, ▁n ▁, ▁m ▁) ▁; ▁int ▁r ▁= ▁find Len ▁( ▁arr ▁, ▁i ▁+ ▁1 ▁, ▁curr ▁arr ▁[ ▁i ▁] ▁, ▁n ▁, ▁m ▁) ▁; ▁dp ▁[ ▁i ▁] ▁[ ▁curr ▁] ▁= ▁l ▁; ▁if ▁( ▁r ▁!= ▁- ▁1 ▁) ▁dp ▁[ ▁i ▁] ▁[ ▁curr ▁] ▁= ▁Math ▁. ▁max ▁( ▁dp ▁[ ▁i ▁] ▁[ ▁curr ▁] ▁, ▁r ▁+ ▁1 ▁) ▁; ▁return ▁dp ▁[ ▁i ▁] ▁[ ▁curr ▁] ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁7 ▁, ▁2 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁int ▁m ▁= ▁3 ▁; ▁int ▁ans ▁= ▁find Len ▁( ▁arr ▁, ▁0 ▁, ▁0 ▁, ▁n ▁, ▁m ▁) ▁; ▁if ▁( ▁ans ▁== ▁- ▁1 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁0 ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁ans ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁max N ▁= ▁20 ▁; ▁static ▁int ▁max M ▁= ▁64 ▁; ▁static ▁int ▁[ ▁] ▁[ ▁] ▁dp ▁= ▁new ▁int ▁[ ▁max N ▁] ▁[ ▁max M ▁] ▁; ▁static ▁boolean ▁[ ▁] ▁[ ▁] ▁v ▁= ▁new ▁boolean ▁[ ▁max N ▁] ▁[ ▁max M ▁] ▁; ▁static ▁int ▁find Len ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁i ▁, ▁int ▁curr ▁, ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁if ▁( ▁i ▁== ▁n ▁) ▁{ ▁if ▁( ▁curr ▁== ▁0 ▁) ▁return ▁0 ▁; ▁else ▁return ▁- ▁1 ▁; ▁} ▁if ▁( ▁v ▁[ ▁i ▁] ▁[ ▁curr ▁] ▁) ▁return ▁dp ▁[ ▁i ▁] ▁[ ▁curr ▁] ▁; ▁v ▁[ ▁i ▁] ▁[ ▁curr ▁] ▁= ▁true ▁; ▁int ▁l ▁= ▁find Len ▁( ▁arr ▁, ▁i ▁+ ▁1 ▁, ▁curr ▁, ▁n ▁, ▁m ▁) ▁; ▁int ▁r ▁= ▁find Len ▁( ▁arr ▁, ▁i ▁+ ▁1 ▁, ▁( ▁curr ▁+ ▁arr ▁[ ▁i ▁] ▁) ▁% ▁m ▁, ▁n ▁, ▁m ▁) ▁; ▁dp ▁[ ▁i ▁] ▁[ ▁curr ▁] ▁= ▁l ▁; ▁if ▁( ▁r ▁!= ▁- ▁1 ▁) ▁dp ▁[ ▁i ▁] ▁[ ▁curr ▁] ▁= ▁Math ▁. ▁max ▁( ▁dp ▁[ ▁i ▁] ▁[ ▁curr ▁] ▁, ▁r ▁+ ▁1 ▁) ▁; ▁return ▁dp ▁[ ▁i ▁] ▁[ ▁curr ▁] ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁2 ▁, ▁2 ▁, ▁1 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁int ▁m ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Len ▁( ▁arr ▁, ▁0 ▁, ▁0 ▁, ▁n ▁, ▁m ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁divide Array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁dp ▁[ ▁] ▁[ ▁] ▁= ▁new ▁int ▁[ ▁500 ▁] ▁[ ▁500 ▁] ▁; ▁int ▁i ▁, ▁j ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁500 ▁; ▁i ▁++ ▁) ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁500 ▁; ▁j ▁++ ▁) ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁0 ▁; ▁k ▁-= ▁1 ▁; ▁for ▁( ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁<= ▁k ▁; ▁j ▁++ ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁int ▁max _ ▁= ▁- ▁1 ▁, ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁l ▁= ▁i ▁; ▁l ▁< ▁n ▁; ▁l ▁++ ▁) ▁{ ▁max _ ▁= ▁Math ▁. ▁max ▁( ▁max _ ▁, ▁arr ▁[ ▁l ▁] ▁) ▁; ▁sum ▁+= ▁arr ▁[ ▁l ▁] ▁; ▁int ▁diff ▁= ▁( ▁l ▁- ▁i ▁+ ▁1 ▁) ▁* ▁max _ ▁- ▁sum ▁; ▁if ▁( ▁j ▁> ▁0 ▁) ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁Math ▁. ▁min ▁( ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁, ▁diff ▁+ ▁dp ▁[ ▁l ▁+ ▁1 ▁] ▁[ ▁j ▁- ▁1 ▁] ▁) ▁; ▁else ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁diff ▁; ▁} ▁} ▁} ▁return ▁dp ▁[ ▁0 ▁] ▁[ ▁k ▁] ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁9 ▁, ▁5 ▁, ▁4 ▁, ▁8 ▁, ▁3 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁int ▁k ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁divide Array ▁( ▁arr ▁, ▁n ▁, ▁k ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁max H app iness ▁( ▁int ▁A ▁, ▁int ▁N ▁, ▁String ▁[ ▁] ▁v ▁) ▁{ ▁String ▁str ▁; ▁int ▁[ ▁] ▁val ▁= ▁new ▁int ▁[ ▁N ▁] ▁; ▁int ▁[ ▁] ▁wt ▁= ▁new ▁int ▁[ ▁N ▁] ▁; ▁int ▁c ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁str ▁= ▁v ▁[ ▁i ▁] ▁; ▁c ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁str ▁. ▁length ▁( ▁) ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁str ▁. ▁charAt ▁( ▁j ▁) ▁== ▁' ▁c ▁' ▁) ▁c ▁+= ▁4 ▁; ▁else ▁if ▁( ▁str ▁. ▁charAt ▁( ▁j ▁) ▁== ▁' ▁w ▁' ▁) ▁c ▁+= ▁3 ▁; ▁else ▁if ▁( ▁str ▁. ▁charAt ▁( ▁j ▁) ▁== ▁' ▁m ▁' ▁) ▁c ▁+= ▁2 ▁; ▁else ▁c ▁++ ▁; ▁} ▁c ▁*= ▁str ▁. ▁length ▁( ▁) ▁; ▁val ▁[ ▁i ▁] ▁= ▁c ▁; ▁wt ▁[ ▁i ▁] ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁} ▁int ▁[ ▁] ▁[ ▁] ▁k ▁= ▁new ▁int ▁[ ▁N ▁+ ▁1 ▁] ▁[ ▁A ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁w ▁= ▁0 ▁; ▁w ▁<= ▁A ▁; ▁w ▁++ ▁) ▁{ ▁if ▁( ▁i ▁== ▁0 ▁w ▁== ▁0 ▁) ▁k ▁[ ▁i ▁] ▁[ ▁w ▁] ▁= ▁0 ▁; ▁else ▁if ▁( ▁wt ▁[ ▁i ▁- ▁1 ▁] ▁<= ▁w ▁) ▁{ ▁k ▁[ ▁i ▁] ▁[ ▁w ▁] ▁= ▁Math ▁. ▁max ▁( ▁val ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁k ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁w ▁- ▁wt ▁[ ▁i ▁- ▁1 ▁] ▁] ▁, ▁k ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁w ▁] ▁) ▁; ▁} ▁else ▁{ ▁k ▁[ ▁i ▁] ▁[ ▁w ▁] ▁= ▁k ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁w ▁] ▁; ▁} ▁} ▁} ▁return ▁k ▁[ ▁N ▁] ▁[ ▁A ▁] ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁A ▁= ▁5 ▁; ▁String ▁[ ▁] ▁v ▁= ▁{ ▁" ▁mm o ▁" ▁, ▁" ▁oo ▁" ▁, ▁" ▁cm w ▁" ▁, ▁" ▁cc ▁" ▁, ▁" ▁c ▁" ▁} ▁; ▁int ▁N ▁= ▁v ▁. ▁length ▁; ▁System
▁class ▁G F G ▁{ ▁static ▁int ▁N ▁= ▁10000 5 ▁; ▁static ▁int ▁LI S ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁dp ▁[ ▁] ▁= ▁new ▁int ▁[ ▁N ▁] ▁, ▁d ▁[ ▁] ▁= ▁new ▁int ▁[ ▁N ▁] ▁; ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁dp ▁[ ▁a ▁[ ▁i ▁] ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁j ▁= ▁2 ▁; ▁j ▁* ▁j ▁<= ▁a ▁[ ▁i ▁] ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁% ▁j ▁== ▁0 ▁) ▁{ ▁dp ▁[ ▁a ▁[ ▁i ▁] ▁] ▁= ▁Math ▁. ▁max ▁( ▁dp ▁[ ▁a ▁[ ▁i ▁] ▁] ▁, ▁dp ▁[ ▁d ▁[ ▁j ▁] ▁] ▁+ ▁1 ▁) ▁; ▁dp ▁[ ▁a ▁[ ▁i ▁] ▁] ▁= ▁Math ▁. ▁max ▁( ▁dp ▁[ ▁a ▁[ ▁i ▁] ▁] ▁, ▁dp ▁[ ▁d ▁[ ▁a ▁[ ▁i ▁] ▁/ ▁j ▁] ▁] ▁+ ▁1 ▁) ▁; ▁d ▁[ ▁j ▁] ▁= ▁a ▁[ ▁i ▁] ▁; ▁d ▁[ ▁a ▁[ ▁i ▁] ▁/ ▁j ▁] ▁= ▁a ▁[ ▁i ▁] ▁; ▁} ▁} ▁ans ▁= ▁Math ▁. ▁max ▁( ▁ans ▁, ▁dp ▁[ ▁a ▁[ ▁i ▁] ▁] ▁) ▁; ▁d ▁[ ▁a ▁[ ▁i ▁] ▁] ▁= ▁a ▁[ ▁i ▁] ▁; ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁a ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁LI S ▁( ▁a ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁lang ▁. ▁Math ▁; ▁class ▁G f G ▁{ ▁static ▁boolean ▁check Combin ations ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁pow _ set _ size ▁= ▁( ▁int ▁) ▁Math ▁. ▁pow ▁( ▁2 ▁, ▁n ▁) ▁; ▁int ▁counter ▁, ▁j ▁; ▁for ▁( ▁counter ▁= ▁0 ▁; ▁counter ▁< ▁pow _ set _ size ▁; ▁counter ▁++ ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁( ▁counter ▁& ▁( ▁1 ▁<< ▁j ▁) ▁) ▁!= ▁0 ▁) ▁else ▁} ▁if ▁( ▁sum ▁% ▁( ▁24 ▁* ▁60 ▁) ▁== ▁0 ▁) ▁return ▁true ▁; ▁} ▁return ▁false ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁60 ▁, ▁60 ▁, ▁120 ▁} ▁; ▁int ▁n ▁= ▁a ▁. ▁length ▁; ▁if ▁( ▁check Combin ations ▁( ▁a ▁, ▁n ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁YES ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁NO ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁GC D ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁if ▁( ▁b ▁== ▁0 ▁) ▁return ▁a ▁; ▁return ▁GC D ▁( ▁b ▁, ▁a ▁% ▁b ▁) ▁; ▁} ▁static ▁void ▁make Pairs ▁( ▁Vector ▁< ▁Integer ▁> ▁pairs ▁, ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁a ▁; ▁i ▁<= ▁b ▁; ▁i ▁++ ▁) ▁{ ▁int ▁sum Of Digits ▁= ▁0 ▁, ▁k ▁= ▁i ▁; ▁while ▁( ▁k ▁> ▁0 ▁) ▁{ ▁sum Of Digits ▁+= ▁k ▁% ▁10 ▁; ▁k ▁/= ▁10 ▁; ▁} ▁if ▁( ▁sum Of Digits ▁<= ▁16 2 ▁) ▁pairs ▁. ▁add ▁( ▁sum Of Digits ▁) ▁; ▁} ▁} ▁static ▁int ▁count Co Prime ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁Vector ▁< ▁Integer ▁> ▁pairs ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁make Pairs ▁( ▁pairs ▁, ▁a ▁, ▁b ▁) ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁pairs ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁pairs ▁. ▁size ▁( ▁) ▁; ▁j ▁++ ▁) ▁if ▁( ▁GC D ▁( ▁pairs ▁. ▁get ▁( ▁i ▁) ▁, ▁pairs ▁. ▁get ▁( ▁j ▁) ▁) ▁== ▁1 ▁) ▁count ▁++ ▁; ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁a ▁= ▁12 ▁, ▁b ▁= ▁15 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Co Prime ▁( ▁a ▁, ▁b ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁MAX ▁= ▁100 ▁; ▁static ▁int ▁dp ▁[ ▁] ▁[ ▁] ▁= ▁new ▁int ▁[ ▁MAX ▁] ▁[ ▁MAX ▁] ▁; ▁static ▁int ▁count Rem ovals ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁i ▁, ▁int ▁j ▁, ▁int ▁k ▁) ▁{ ▁if ▁( ▁i ▁>= ▁j ▁) ▁return ▁0 ▁; ▁else ▁if ▁( ▁( ▁a ▁[ ▁j ▁] ▁- ▁a ▁[ ▁i ▁] ▁) ▁<= ▁k ▁) ▁return ▁0 ▁; ▁else ▁if ▁( ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁!= ▁- ▁1 ▁) ▁return ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁else ▁if ▁( ▁( ▁a ▁[ ▁j ▁] ▁- ▁a ▁[ ▁i ▁] ▁) ▁> ▁k ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁1 ▁+ ▁Math ▁. ▁min ▁( ▁count Rem ovals ▁( ▁a ▁, ▁i ▁+ ▁1 ▁, ▁j ▁, ▁k ▁) ▁, ▁count Rem ovals ▁( ▁a ▁, ▁i ▁, ▁j ▁- ▁1 ▁, ▁k ▁) ▁) ▁; ▁} ▁return ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁} ▁static ▁int ▁rem ovals ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁a ▁) ▁; ▁for ▁( ▁int ▁[ ▁] ▁rows ▁: ▁dp ▁) ▁Arrays ▁. ▁fill ▁( ▁rows ▁, ▁- ▁1 ▁) ▁; ▁if ▁( ▁n ▁== ▁1 ▁) ▁return ▁0 ▁; ▁else ▁return ▁count Rem ovals ▁( ▁a ▁, ▁0 ▁, ▁n ▁- ▁1 ▁, ▁k ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁4 ▁, ▁9 ▁, ▁10 ▁, ▁11 ▁, ▁12 ▁, ▁17 ▁, ▁20 ▁} ▁; ▁int ▁n ▁= ▁a ▁. ▁length ▁; ▁int ▁k ▁= ▁4 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁rem ovals ▁( ▁a ▁, ▁n ▁, ▁k ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁public ▁class ▁G f G ▁{ ▁public ▁static ▁int ▁find Step ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁1 ▁n ▁== ▁0 ▁) ▁return ▁1 ▁; ▁else ▁if ▁( ▁n ▁== ▁2 ▁) ▁return ▁2 ▁; ▁else ▁return ▁find Step ▁( ▁n ▁- ▁3 ▁) ▁+ ▁find Step ▁( ▁n ▁- ▁2 ▁) ▁+ ▁find Step ▁( ▁n ▁- ▁1 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁arg c ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁4 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Step ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁public ▁class ▁G f G ▁{ ▁public ▁static ▁int ▁deal n no y ▁( ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁if ▁( ▁m ▁== ▁0 ▁n ▁== ▁0 ▁) ▁return ▁1 ▁; ▁return ▁deal n no y ▁( ▁m ▁- ▁1 ▁, ▁n ▁) ▁+ ▁deal n no y ▁( ▁m ▁- ▁1 ▁, ▁n ▁- ▁1 ▁) ▁+ ▁deal n no y ▁( ▁m ▁, ▁n ▁- ▁1 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁3 ▁, ▁m ▁= ▁4 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁deal n no y ▁( ▁n ▁, ▁m ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁class ▁G F G ▁{ ▁static ▁final ▁int ▁MAX ▁= ▁100 ▁; ▁static ▁boolean ▁all ones ▁( ▁String ▁s ▁, ▁int ▁n ▁) ▁{ ▁int ▁co ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁if ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'1' ▁) ▁co ▁+= ▁1 ▁; ▁return ▁( ▁co ▁== ▁n ▁) ▁; ▁} ▁static ▁int ▁find length ▁( ▁int ▁arr ▁[ ▁] ▁, ▁String ▁s ▁, ▁int ▁n ▁, ▁int ▁ind ▁, ▁int ▁st ▁, ▁int ▁dp ▁[ ▁] ▁[ ▁] ▁) ▁{ ▁if ▁( ▁ind ▁>= ▁n ▁) ▁return ▁0 ▁; ▁if ▁( ▁dp ▁[ ▁ind ▁] ▁[ ▁st ▁] ▁!= ▁- ▁1 ▁) ▁return ▁dp ▁[ ▁ind ▁] ▁[ ▁st ▁] ▁; ▁if ▁( ▁st ▁== ▁0 ▁) ▁return ▁dp ▁[ ▁ind ▁] ▁[ ▁st ▁] ▁= ▁Math ▁. ▁max ▁( ▁arr ▁[ ▁ind ▁] ▁+ ▁find length ▁( ▁arr ▁, ▁s ▁, ▁n ▁, ▁ind ▁+ ▁1 ▁, ▁1 ▁, ▁dp ▁) ▁, ▁find length ▁( ▁arr ▁, ▁s ▁, ▁n ▁, ▁ind ▁+ ▁1 ▁, ▁0 ▁, ▁dp ▁) ▁) ▁; ▁else ▁return ▁dp ▁[ ▁ind ▁] ▁[ ▁st ▁] ▁= ▁Math ▁. ▁max ▁( ▁arr ▁[ ▁ind ▁] ▁+ ▁find length ▁( ▁arr ▁, ▁s ▁, ▁n ▁, ▁ind ▁+ ▁1 ▁, ▁1 ▁, ▁dp ▁) ▁, ▁0 ▁) ▁; ▁} ▁static ▁int ▁max Len ▁( ▁String ▁s ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁all ones ▁( ▁s ▁, ▁n ▁) ▁) ▁return ▁- ▁1 ▁; ▁int ▁arr ▁[ ▁] ▁= ▁new ▁int ▁[ ▁MAX ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁arr ▁[ ▁i ▁] ▁= ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'0' ▁? ▁1 ▁: ▁- ▁1 ▁) ▁; ▁int ▁dp ▁[ ▁] ▁[ ▁] ▁= ▁new ▁int ▁[ ▁MAX ▁] ▁[ ▁3 ▁] ▁; ▁for ▁( ▁int ▁[ ▁] ▁row ▁: ▁dp ▁) ▁Arrays ▁. ▁fill ▁( ▁row ▁, ▁- ▁1 ▁) ▁; ▁return ▁find length ▁( ▁arr ▁, ▁s ▁, ▁n ▁, ▁0 ▁, ▁0 ▁, ▁dp ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁s ▁= ▁"11 0000 100 01" ▁; ▁int ▁n ▁= ▁11 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁max Len ▁( ▁s ▁,
▁class ▁G F G ▁{ ▁static ▁boolean ▁is Safe ▁( ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁return ▁( ▁x ▁< ▁4 ▁&& ▁y ▁< ▁3 ▁) ▁; ▁} ▁static ▁int ▁min Jump ▁( ▁int ▁height ▁[ ▁] ▁[ ▁] ▁, ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁if ▁( ▁x ▁== ▁4 ▁- ▁1 ▁&& ▁y ▁== ▁3 ▁- ▁1 ▁) ▁return ▁0 ▁; ▁int ▁diag ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁if ▁( ▁is Safe ▁( ▁x ▁+ ▁1 ▁, ▁y ▁+ ▁1 ▁) ▁) ▁diag ▁= ▁min Jump ▁( ▁height ▁, ▁x ▁+ ▁1 ▁, ▁y ▁+ ▁1 ▁) ▁+ ▁Math ▁. ▁abs ▁( ▁height ▁[ ▁x ▁] ▁[ ▁y ▁] ▁- ▁height ▁[ ▁x ▁+ ▁1 ▁] ▁[ ▁y ▁+ ▁1 ▁] ▁) ▁; ▁int ▁down ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁if ▁( ▁is Safe ▁( ▁x ▁+ ▁1 ▁, ▁y ▁) ▁) ▁down ▁= ▁min Jump ▁( ▁height ▁, ▁x ▁+ ▁1 ▁, ▁y ▁) ▁+ ▁Math ▁. ▁abs ▁( ▁height ▁[ ▁x ▁] ▁[ ▁y ▁] ▁- ▁height ▁[ ▁x ▁+ ▁1 ▁] ▁[ ▁y ▁] ▁) ▁; ▁int ▁right ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁if ▁( ▁is Safe ▁( ▁x ▁, ▁y ▁+ ▁1 ▁) ▁) ▁right ▁= ▁min Jump ▁( ▁height ▁, ▁x ▁, ▁y ▁+ ▁1 ▁) ▁+ ▁Math ▁. ▁abs ▁( ▁height ▁[ ▁x ▁] ▁[ ▁y ▁] ▁- ▁height ▁[ ▁x ▁] ▁[ ▁y ▁+ ▁1 ▁] ▁) ▁; ▁return ▁Math ▁. ▁min ▁( ▁down ▁, ▁Math ▁. ▁min ▁( ▁right ▁, ▁diag ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁height ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁5 ▁, ▁4 ▁, ▁2 ▁} ▁, ▁{ ▁9 ▁, ▁2 ▁, ▁1 ▁} ▁, ▁{ ▁2 ▁, ▁5 ▁, ▁9 ▁} ▁, ▁{ ▁1 ▁, ▁3 ▁, ▁11 ▁} ▁} ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁min Jump ▁( ▁height ▁, ▁0 ▁, ▁0 ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁G F G ▁{ ▁static ▁long ▁count W ays ▁( ▁int ▁n ▁) ▁{ ▁long ▁dp ▁[ ▁] ▁[ ▁] ▁= ▁new ▁long ▁[ ▁2 ▁] ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁dp ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁= ▁1 ▁; ▁dp ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁= ▁2 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁dp ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁= ▁dp ▁[ ▁0 ▁] ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁dp ▁[ ▁1 ▁] ▁[ ▁i ▁- ▁1 ▁] ▁; ▁dp ▁[ ▁1 ▁] ▁[ ▁i ▁] ▁= ▁dp ▁[ ▁0 ▁] ▁[ ▁i ▁- ▁1 ▁] ▁* ▁2 ▁+ ▁dp ▁[ ▁1 ▁] ▁[ ▁i ▁- ▁1 ▁] ▁; ▁} ▁return ▁dp ▁[ ▁0 ▁] ▁[ ▁n ▁] ▁+ ▁dp ▁[ ▁1 ▁] ▁[ ▁n ▁] ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Total ▁no ▁of ▁ways ▁with ▁n ▁= ▁" ▁+ ▁n ▁+ ▁" ▁are ▁: ▁" ▁+ ▁count W ays ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁count W ays To Jump ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁count _ jump ▁[ ▁] ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁Arrays ▁. ▁fill ▁( ▁count _ jump ▁, ▁0 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁2 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁>= ▁n ▁- ▁i ▁- ▁1 ▁) ▁count _ jump ▁[ ▁i ▁] ▁++ ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁- ▁1 ▁&& ▁j ▁<= ▁arr ▁[ ▁i ▁] ▁+ ▁i ▁; ▁j ▁++ ▁) ▁if ▁( ▁count _ jump ▁[ ▁j ▁] ▁!= ▁- ▁1 ▁) ▁count _ jump ▁[ ▁i ▁] ▁+= ▁count _ jump ▁[ ▁j ▁] ▁; ▁if ▁( ▁count _ jump ▁[ ▁i ▁] ▁== ▁0 ▁) ▁count _ jump ▁[ ▁i ▁] ▁= ▁- ▁1 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁count _ jump ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁5 ▁, ▁8 ▁, ▁9 ▁, ▁1 ▁, ▁0 ▁, ▁7 ▁, ▁6 ▁, ▁8 ▁, ▁9 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁count W ays To Jump ▁( ▁arr ▁, ▁n ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁final ▁int ▁N ▁= ▁4 ▁; ▁static ▁int ▁max Decimal Value ▁( ▁int ▁mat ▁[ ▁] ▁[ ▁] ▁, ▁int ▁i ▁, ▁int ▁j ▁, ▁int ▁p ▁) ▁{ ▁if ▁( ▁i ▁>= ▁N ▁j ▁>= ▁N ▁) ▁{ ▁return ▁0 ▁; ▁} ▁int ▁result ▁= ▁Math ▁. ▁max ▁( ▁max Decimal Value ▁( ▁mat ▁, ▁i ▁, ▁j ▁+ ▁1 ▁, ▁p ▁+ ▁1 ▁) ▁, ▁max Decimal Value ▁( ▁mat ▁, ▁i ▁+ ▁1 ▁, ▁j ▁, ▁p ▁+ ▁1 ▁) ▁) ▁; ▁if ▁( ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁== ▁1 ▁) ▁{ ▁return ▁( ▁int ▁) ▁( ▁Math ▁. ▁pow ▁( ▁2 ▁, ▁p ▁) ▁+ ▁result ▁) ▁; ▁} ▁else ▁{ ▁return ▁result ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁mat ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁} ▁, ▁{ ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁0 ▁} ▁, ▁{ ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁} ▁, ▁} ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁max Decimal Value ▁( ▁mat ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁G F G ▁{ ▁final ▁static ▁int ▁N ▁= ▁4 ▁; ▁static ▁int ▁Maximum Decimal Value ▁( ▁int ▁mat ▁[ ▁] ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁dp ▁[ ▁] ▁[ ▁] ▁= ▁new ▁int ▁[ ▁n ▁] ▁[ ▁n ▁] ▁; ▁if ▁( ▁mat ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁== ▁1 ▁) ▁{ ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁mat ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁== ▁1 ▁) ▁{ ▁dp ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁= ▁( ▁int ▁) ▁( ▁dp ▁[ ▁0 ▁] ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁Math ▁. ▁pow ▁( ▁2 ▁, ▁i ▁) ▁) ▁; ▁else ▁{ ▁dp ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁= ▁dp ▁[ ▁0 ▁] ▁[ ▁i ▁- ▁1 ▁] ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁mat ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁== ▁1 ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁= ▁( ▁int ▁) ▁( ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁0 ▁] ▁+ ▁Math ▁. ▁pow ▁( ▁2 ▁, ▁i ▁) ▁) ▁; ▁else ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁0 ▁] ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁== ▁1 ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁( ▁int ▁) ▁( ▁Math ▁. ▁max ▁( ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁, ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁) ▁+ ▁Math ▁. ▁pow ▁( ▁2 ▁, ▁i ▁+ ▁j ▁) ▁) ▁; ▁} ▁else ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁Math ▁. ▁max ▁( ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁, ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁) ▁; ▁} ▁} ▁} ▁return ▁dp ▁[ ▁n ▁- ▁1 ▁] ▁[ ▁n ▁- ▁1 ▁] ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁mat ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁} ▁, ▁{ ▁0
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁max Sum Pair With Difference LessThan K ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁arr ▁) ▁; ▁int ▁dp ▁[ ▁] ▁= ▁new ▁int ▁[ ▁N ▁] ▁; ▁dp ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁; ▁if ▁( ▁arr ▁[ ▁i ▁] ▁- ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁< ▁K ▁) ▁{ ▁if ▁( ▁i ▁>= ▁2 ▁) ▁dp ▁[ ▁i ▁] ▁= ▁Math ▁. ▁max ▁( ▁dp ▁[ ▁i ▁] ▁, ▁dp ▁[ ▁i ▁- ▁2 ▁] ▁+ ▁arr ▁[ ▁i ▁] ▁+ ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁) ▁; ▁else ▁dp ▁[ ▁i ▁] ▁= ▁Math ▁. ▁max ▁( ▁dp ▁[ ▁i ▁] ▁, ▁arr ▁[ ▁i ▁] ▁+ ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁) ▁; ▁} ▁} ▁return ▁dp ▁[ ▁N ▁- ▁1 ▁] ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁5 ▁, ▁10 ▁, ▁15 ▁, ▁17 ▁, ▁12 ▁, ▁9 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁int ▁K ▁= ▁4 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁max Sum Pair With Difference LessThan K ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁max Sum IS ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁i ▁, ▁j ▁, ▁max ▁= ▁0 ▁; ▁int ▁ms is ▁[ ▁] ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁ms is ▁[ ▁i ▁] ▁= ▁arr ▁[ ▁i ▁] ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁i ▁; ▁j ▁++ ▁) ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁arr ▁[ ▁j ▁] ▁&& ▁ms is ▁[ ▁i ▁] ▁< ▁ms is ▁[ ▁j ▁] ▁+ ▁arr ▁[ ▁i ▁] ▁) ▁ms is ▁[ ▁i ▁] ▁= ▁ms is ▁[ ▁j ▁] ▁+ ▁arr ▁[ ▁i ▁] ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁max ▁< ▁ms is ▁[ ▁i ▁] ▁) ▁max ▁= ▁ms is ▁[ ▁i ▁] ▁; ▁return ▁max ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁new ▁int ▁[ ▁] ▁{ ▁1 ▁, ▁101 ▁, ▁2 ▁, ▁3 ▁, ▁100 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Sum ▁of ▁maximum ▁sum ▁" ▁+ ▁" ▁increasing ▁sub sequence ▁is ▁" ▁+ ▁max Sum IS ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁Matrix Chain Multip lication ▁{ ▁static ▁int ▁Matrix Chain Order ▁( ▁int ▁p ▁[ ▁] ▁, ▁int ▁i ▁, ▁int ▁j ▁) ▁{ ▁if ▁( ▁i ▁== ▁j ▁) ▁return ▁0 ▁; ▁int ▁min ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁for ▁( ▁int ▁k ▁= ▁i ▁; ▁k ▁< ▁j ▁; ▁k ▁++ ▁) ▁{ ▁int ▁count ▁= ▁Matrix Chain Order ▁( ▁p ▁, ▁i ▁, ▁k ▁) ▁+ ▁Matrix Chain Order ▁( ▁p ▁, ▁k ▁+ ▁1 ▁, ▁j ▁) ▁+ ▁p ▁[ ▁i ▁- ▁1 ▁] ▁* ▁p ▁[ ▁k ▁] ▁* ▁p ▁[ ▁j ▁] ▁; ▁if ▁( ▁count ▁< ▁min ▁) ▁min ▁= ▁count ▁; ▁} ▁return ▁min ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁new ▁int ▁[ ▁] ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Minimum ▁number ▁of ▁multiplication s ▁is ▁" ▁+ ▁Matrix Chain Order ▁( ▁arr ▁, ▁1 ▁, ▁n ▁- ▁1 ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁encode String ▁( ▁String ▁str ▁) ▁{ ▁String ▁res ▁= ▁" ▁" ▁; ▁int ▁small ▁[ ▁] ▁= ▁new ▁int ▁[ ▁26 ▁] ▁; ▁int ▁capital ▁[ ▁] ▁= ▁new ▁int ▁[ ▁26 ▁] ▁; ▁int ▁num ▁[ ▁] ▁= ▁new ▁int ▁[ ▁10 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁26 ▁; ▁i ▁++ ▁) ▁{ ▁small ▁[ ▁i ▁] ▁= ▁0 ▁; ▁capital ▁[ ▁i ▁] ▁= ▁0 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁10 ▁; ▁i ▁++ ▁) ▁{ ▁num ▁[ ▁i ▁] ▁= ▁0 ▁; ▁} ▁int ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁>= ▁'0' ▁&& ▁str ▁. ▁charAt ▁( ▁i ▁) ▁<= ▁'9' ▁) ▁{ ▁num ▁[ ▁str ▁. ▁charAt ▁( ▁i ▁) ▁- ▁48 ▁] ▁= ▁i ▁; ▁} ▁else ▁if ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁>= ▁' ▁a ▁' ▁&& ▁str ▁. ▁charAt ▁( ▁i ▁) ▁<= ▁' ▁z ▁' ▁) ▁{ ▁small ▁[ ▁str ▁. ▁charAt ▁( ▁i ▁) ▁- ▁97 ▁] ▁= ▁i ▁; ▁} ▁else ▁if ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁>= ▁' ▁A ▁' ▁&& ▁str ▁. ▁charAt ▁( ▁i ▁) ▁<= ▁' ▁Z ▁' ▁) ▁{ ▁capital ▁[ ▁str ▁. ▁charAt ▁( ▁i ▁) ▁- ▁65 ▁] ▁= ▁i ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁>= ▁' ▁a ▁' ▁&& ▁str ▁. ▁charAt ▁( ▁i ▁) ▁<= ▁' ▁z ▁' ▁) ▁&& ▁small ▁[ ▁str ▁. ▁charAt ▁( ▁i ▁) ▁- ▁97 ▁] ▁== ▁i ▁) ▁{ ▁int ▁occ ▁= ▁str ▁. ▁charAt ▁( ▁i ▁) ▁- ▁96 ▁; ▁while ▁( ▁occ ▁-- ▁> ▁0 ▁) ▁{ ▁res ▁+= ▁str ▁. ▁charAt ▁( ▁i ▁) ▁; ▁} ▁} ▁else ▁if ▁( ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁>= ▁' ▁A ▁' ▁&& ▁str ▁. ▁charAt ▁( ▁i ▁) ▁<= ▁' ▁Z ▁' ▁) ▁&& ▁capital ▁[ ▁str ▁. ▁charAt ▁( ▁i ▁) ▁- ▁65 ▁] ▁== ▁i ▁) ▁{ ▁int ▁occ ▁= ▁str ▁. ▁charAt ▁( ▁i ▁) ▁- ▁64 ▁; ▁while ▁( ▁occ
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁void ▁create Grid ▁( ▁char ▁[ ▁] ▁[ ▁] ▁grid ▁, ▁boolean ▁is 1 ▁, ▁int ▁N ▁, ▁int ▁M ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁M ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁is 1 ▁) ▁{ ▁grid ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁'0' ▁; ▁is 1 ▁= ▁false ▁; ▁} ▁else ▁{ ▁grid ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁'1' ▁; ▁is 1 ▁= ▁true ▁; ▁} ▁} ▁if ▁( ▁M ▁% ▁2 ▁== ▁0 ▁) ▁is 1 ▁= ▁! ▁is 1 ▁; ▁} ▁} ▁public ▁static ▁boolean ▁test Grid ▁( ▁char ▁[ ▁] ▁[ ▁] ▁test Grid ▁, ▁char ▁[ ▁] ▁[ ▁] ▁Grid ▁, ▁int ▁N ▁, ▁int ▁M ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁M ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁Grid ▁[ ▁i ▁] ▁[ ▁j ▁] ▁!= ▁' ▁* ▁' ▁) ▁{ ▁if ▁( ▁Grid ▁[ ▁i ▁] ▁[ ▁j ▁] ▁!= ▁test Grid ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁{ ▁return ▁false ▁; ▁} ▁} ▁} ▁} ▁return ▁true ▁; ▁} ▁public ▁static ▁void ▁print Grid ▁( ▁char ▁[ ▁] ▁[ ▁] ▁grid ▁, ▁int ▁N ▁, ▁int ▁M ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁M ▁; ▁j ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁grid ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁find Possible Grid ▁( ▁int ▁N ▁, ▁int ▁M ▁, ▁char ▁[ ▁] ▁[ ▁] ▁grid ▁) ▁{ ▁char ▁[ ▁] ▁[ ▁] ▁grid Test 1 ▁= ▁new ▁char ▁[ ▁N ▁] ▁[ ▁1001 ▁] ▁; ▁char ▁[ ▁] ▁[ ▁] ▁grid Test 2 ▁= ▁new ▁char ▁[ ▁N ▁] ▁[ ▁1001 ▁] ▁; ▁create Grid ▁( ▁grid Test 1 ▁, ▁true ▁, ▁N ▁, ▁M ▁) ▁; ▁create Grid ▁( ▁grid Test 2 ▁, ▁false ▁, ▁N ▁, ▁M ▁) ▁; ▁if ▁( ▁test Grid ▁( ▁grid Test 1
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁find Min M oves ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁N ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁if ▁( ▁sum ▁% ▁N ▁!= ▁0 ▁) ▁return ▁- ▁1 ▁; ▁int ▁avg ▁= ▁sum ▁/ ▁N ▁; ▁int ▁total ▁= ▁0 ▁; ▁int ▁need Count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁need Count ▁+= ▁( ▁arr ▁[ ▁i ▁] ▁- ▁avg ▁) ▁; ▁total ▁= ▁Math ▁. ▁max ▁( ▁Math ▁. ▁max ▁( ▁Math ▁. ▁abs ▁( ▁need Count ▁) ▁, ▁arr ▁[ ▁i ▁] ▁- ▁avg ▁) ▁, ▁total ▁) ▁; ▁} ▁return ▁total ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁1 ▁, ▁0 ▁, ▁5 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Min M oves ▁( ▁arr ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁getZ arr ▁( ▁String ▁str ▁, ▁int ▁Z ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁int ▁k ▁; ▁int ▁L ▁= ▁0 ▁; ▁int ▁R ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁i ▁> ▁R ▁) ▁{ ▁L ▁= ▁R ▁= ▁i ▁; ▁while ▁( ▁R ▁< ▁n ▁&& ▁str ▁. ▁charAt ▁( ▁R ▁- ▁L ▁) ▁== ▁str ▁. ▁charAt ▁( ▁R ▁) ▁) ▁{ ▁R ▁++ ▁; ▁} ▁Z ▁[ ▁i ▁] ▁= ▁R ▁- ▁L ▁; ▁R ▁-- ▁; ▁} ▁else ▁{ ▁k ▁= ▁i ▁- ▁L ▁; ▁if ▁( ▁Z ▁[ ▁k ▁] ▁< ▁R ▁- ▁i ▁+ ▁1 ▁) ▁{ ▁Z ▁[ ▁i ▁] ▁= ▁Z ▁[ ▁k ▁] ▁; ▁} ▁else ▁{ ▁L ▁= ▁i ▁; ▁while ▁( ▁R ▁< ▁n ▁&& ▁str ▁. ▁charAt ▁( ▁R ▁- ▁L ▁) ▁== ▁str ▁. ▁charAt ▁( ▁R ▁) ▁) ▁{ ▁R ▁++ ▁; ▁} ▁Z ▁[ ▁i ▁] ▁= ▁R ▁- ▁L ▁; ▁R ▁-- ▁; ▁} ▁} ▁} ▁} ▁static ▁String ▁good Str ▁( ▁String ▁str ▁, ▁String ▁word ▁) ▁{ ▁String ▁concat ▁= ▁word ▁+ ▁" ▁$ ▁" ▁+ ▁str ▁; ▁int ▁l ▁= ▁concat ▁. ▁length ▁( ▁) ▁; ▁int ▁[ ▁] ▁Z ▁= ▁new ▁int ▁[ ▁l ▁] ▁; ▁getZ arr ▁( ▁concat ▁, ▁Z ▁) ▁; ▁String ▁res ▁= ▁" ▁" ▁; ▁int ▁p Size ▁= ▁word ▁. ▁length ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁l ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁i ▁+ ▁p Size ▁< ▁l ▁- ▁1 ▁&& ▁Z ▁[ ▁i ▁+ ▁p Size ▁+ ▁1 ▁] ▁== ▁p Size ▁) ▁{ ▁i ▁+= ▁p Size ▁- ▁1 ▁; ▁} ▁else ▁if ▁( ▁i ▁< ▁str ▁. ▁length ▁( ▁) ▁) ▁{ ▁res ▁+= ▁str ▁. ▁charAt ▁( ▁i ▁) ▁; ▁} ▁} ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁" ▁Z ▁- ▁km algorithm km isk mk mk m help ful km ink m search ing ▁" ▁; ▁String ▁word ▁= ▁" ▁km ▁" ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁good Str ▁( ▁str ▁, ▁word ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁sum Of Sub array Prod ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁int ▁res ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁int ▁incr ▁= ▁arr ▁[ ▁i ▁] ▁* ▁( ▁1 ▁+ ▁res ▁) ▁; ▁ans ▁+= ▁incr ▁; ▁res ▁= ▁incr ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁ans ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁sum Of Sub array Prod ▁( ▁arr ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁phi ▁( ▁int ▁n ▁) ▁{ ▁int ▁result ▁= ▁1 ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁< ▁n ▁; ▁p ▁++ ▁) ▁{ ▁if ▁( ▁__ g cd ▁( ▁p ▁, ▁n ▁) ▁== ▁1 ▁) ▁{ ▁result ▁++ ▁; ▁} ▁} ▁return ▁result ▁; ▁} ▁static ▁boolean ▁same E uler T ot ient ▁( ▁int ▁n ▁) ▁{ ▁return ▁phi ▁( ▁n ▁) ▁== ▁phi ▁( ▁2 ▁* ▁n ▁) ▁; ▁} ▁static ▁int ▁__ g cd ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁return ▁b ▁== ▁0 ▁? ▁a ▁: ▁__ g cd ▁( ▁b ▁, ▁a ▁% ▁b ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁13 ▁; ▁if ▁( ▁same E uler T ot ient ▁( ▁N ▁) ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁print Odd Factor Number ▁( ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁n ▁; ▁i ▁<= ▁m ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁i ▁> ▁0 ▁) ▁&& ▁( ▁( ▁i ▁& ▁( ▁i ▁- ▁1 ▁) ▁) ▁!= ▁0 ▁) ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁i ▁+ ▁" ▁" ▁) ▁; ▁} ▁return ▁0 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁2 ▁, ▁M ▁= ▁10 ▁; ▁print Odd Factor Number ▁( ▁N ▁, ▁M ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁print Series ▁( ▁int ▁n ▁) ▁{ ▁int ▁k ▁= ▁2 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁k ▁* ▁( ▁2 ▁* ▁k ▁- ▁1 ▁) ▁+ ▁" ▁" ▁) ▁; ▁k ▁+= ▁2 ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁N ▁= ▁12 ▁; ▁print Series ▁( ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁print S in X ▁( ▁int ▁N ▁) ▁{ ▁int ▁X i ▁= ▁0 ▁; ▁int ▁num ▁= ▁1 ▁; ▁while ▁( ▁N ▁-- ▁> ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁X ▁" ▁+ ▁num ▁+ ▁" ▁= ▁" ▁+ ▁X i ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁sin ▁( ▁X ▁" ▁+ ▁num ▁+ ▁" ▁) ▁= ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁% ▁. 6 f ▁" ▁, ▁Math ▁. ▁sin ▁( ▁X i ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁num ▁+= ▁1 ▁; ▁X i ▁+= ▁7 10 ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁5 ▁; ▁print S in X ▁( ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁sum Between Zero ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁i ▁= ▁0 ▁; ▁Vector ▁< ▁Integer ▁> ▁A ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁i ▁++ ▁; ▁break ▁; ▁} ▁} ▁for ▁( ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁A ▁. ▁add ▁( ▁sum ▁) ▁; ▁sum ▁= ▁0 ▁; ▁} ▁else ▁{ ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁} ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁A ▁. ▁size ▁( ▁) ▁; ▁j ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁A ▁. ▁get ▁( ▁j ▁) ▁+ ▁" ▁" ▁) ▁; ▁} ▁if ▁( ▁A ▁. ▁size ▁( ▁) ▁== ▁0 ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁- ▁1" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁0 ▁, ▁3 ▁, ▁4 ▁, ▁0 ▁, ▁4 ▁, ▁4 ▁, ▁0 ▁, ▁2 ▁, ▁1 ▁, ▁4 ▁, ▁0 ▁, ▁3 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁sum Between Zero ▁( ▁arr ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁count Characters ▁( ▁List ▁< ▁String ▁> ▁strings ▁, ▁String ▁chars ▁) ▁{ ▁int ▁res ▁= ▁0 ▁; ▁Map ▁< ▁Character ▁, ▁Integer ▁> ▁freq ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁chars ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁freq ▁. ▁put ▁( ▁chars ▁. ▁charAt ▁( ▁i ▁) ▁, ▁freq ▁. ▁getOr Default ▁( ▁chars ▁. ▁charAt ▁( ▁i ▁) ▁, ▁0 ▁) ▁+ ▁1 ▁) ▁; ▁} ▁for ▁( ▁String ▁st ▁: ▁strings ▁) ▁{ ▁boolean ▁flag ▁= ▁true ▁; ▁for ▁( ▁char ▁c ▁: ▁st ▁. ▁toCharArray ▁( ▁) ▁) ▁{ ▁if ▁( ▁! ▁freq ▁. ▁containsKey ▁( ▁c ▁) ▁) ▁{ ▁flag ▁= ▁false ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁flag ▁) ▁res ▁+= ▁st ▁. ▁length ▁( ▁) ▁; ▁} ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁List ▁< ▁String ▁> ▁strings ▁= ▁Arrays ▁. ▁asList ▁( ▁" ▁hi ▁" ▁, ▁" ▁data ▁" ▁, ▁" ▁g eek s forge ek s ▁" ▁) ▁; ▁String ▁chars ▁= ▁" ▁ti ad ha e ▁" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Characters ▁( ▁strings ▁, ▁chars ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁find Numbers ▁( ▁int ▁n ▁) ▁{ ▁int ▁i ▁= ▁1 ▁; ▁while ▁( ▁i ▁<= ▁n ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁( ▁3 ▁* ▁i ▁* ▁( ▁i ▁- ▁1 ▁) ▁+ ▁1 ▁) ▁+ ▁" ▁" ▁) ▁; ▁i ▁++ ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁4 ▁; ▁find Numbers ▁( ▁n ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁getEnd ing Index ▁( ▁String ▁str ▁, ▁int ▁n ▁, ▁int ▁i ▁) ▁{ ▁i ▁++ ▁; ▁while ▁( ▁i ▁< ▁n ▁) ▁{ ▁char ▁curr ▁= ▁str ▁. ▁charAt ▁( ▁i ▁) ▁; ▁char ▁prev ▁= ▁str ▁. ▁charAt ▁( ▁i ▁- ▁1 ▁) ▁; ▁if ▁( ▁( ▁curr ▁== ▁' ▁a ▁' ▁&& ▁prev ▁== ▁' ▁z ▁' ▁) ▁|| ▁( ▁curr ▁- ▁prev ▁== ▁1 ▁) ▁) ▁i ▁++ ▁; ▁else ▁break ▁; ▁} ▁return ▁i ▁- ▁1 ▁; ▁} ▁static ▁int ▁largest Sub Str ▁( ▁String ▁str ▁, ▁int ▁n ▁) ▁{ ▁int ▁len ▁= ▁0 ▁; ▁int ▁i ▁= ▁0 ▁; ▁while ▁( ▁i ▁< ▁n ▁) ▁{ ▁int ▁end ▁= ▁getEnd ing Index ▁( ▁str ▁, ▁n ▁, ▁i ▁) ▁; ▁len ▁= ▁Math ▁. ▁max ▁( ▁end ▁- ▁i ▁+ ▁1 ▁, ▁len ▁) ▁; ▁i ▁= ▁end ▁+ ▁1 ▁; ▁} ▁return ▁len ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁String ▁str ▁= ▁" ▁abc abcdef abc ▁" ▁; ▁int ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁largest Sub Str ▁( ▁str ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁HashMap ▁; ▁class ▁G F G ▁{ ▁static ▁String ▁smallest Freq ▁( ▁String ▁S 1 ▁, ▁String ▁S 2 ▁) ▁{ ▁HashMap ▁< ▁String ▁, ▁Integer ▁> ▁ban ned ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁S 2 ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁String ▁s ▁= ▁" ▁" ▁; ▁while ▁( ▁i ▁< ▁S 2 ▁. ▁length ▁( ▁) ▁&& ▁S 2 ▁. ▁charAt ▁( ▁i ▁) ▁!= ▁' ▁' ▁) ▁s ▁+= ▁S 2 ▁. ▁charAt ▁( ▁i ▁++ ▁) ▁; ▁ban ned ▁. ▁put ▁( ▁s ▁, ▁ban ned ▁. ▁get ▁( ▁s ▁) ▁== ▁null ▁? ▁1 ▁: ▁ban ned ▁. ▁get ▁( ▁s ▁) ▁+ ▁1 ▁) ▁; ▁} ▁HashMap ▁< ▁String ▁, ▁Integer ▁> ▁result ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁String ▁ans ▁= ▁" ▁" ▁; ▁int ▁freq ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁S 1 ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁String ▁s ▁= ▁" ▁" ▁; ▁while ▁( ▁i ▁< ▁S 1 ▁. ▁length ▁( ▁) ▁&& ▁S 1 ▁. ▁charAt ▁( ▁i ▁) ▁!= ▁' ▁' ▁) ▁s ▁+= ▁S 1 ▁. ▁charAt ▁( ▁i ▁++ ▁) ▁; ▁if ▁( ▁ban ned ▁. ▁get ▁( ▁s ▁) ▁== ▁null ▁) ▁{ ▁result ▁. ▁put ▁( ▁s ▁, ▁result ▁. ▁get ▁( ▁s ▁) ▁== ▁null ▁? ▁1 ▁: ▁result ▁. ▁get ▁( ▁s ▁) ▁+ ▁1 ▁) ▁; ▁if ▁( ▁result ▁. ▁get ▁( ▁s ▁) ▁> ▁freq ▁|| ▁( ▁result ▁. ▁get ▁( ▁s ▁) ▁== ▁freq ▁&& ▁s ▁. ▁compareTo ▁( ▁ans ▁) ▁< ▁0 ▁) ▁) ▁{ ▁ans ▁= ▁s ▁; ▁freq ▁= ▁result ▁. ▁get ▁( ▁s ▁) ▁; ▁} ▁} ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁S 1 ▁= ▁" ▁g eek s ▁for ▁g eek s ▁is ▁best ▁place ▁to ▁learn ▁" ▁; ▁String ▁S 2 ▁= ▁" ▁bad ▁place ▁" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁smallest Freq ▁( ▁S 1 ▁, ▁S 2 ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁is Sub string ▁( ▁String ▁s 1 ▁, ▁String ▁s 2 ▁) ▁{ ▁int ▁M ▁= ▁s 1 ▁. ▁length ▁( ▁) ▁; ▁int ▁N ▁= ▁s 2 ▁. ▁length ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁N ▁- ▁M ▁; ▁i ▁++ ▁) ▁{ ▁int ▁j ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁M ▁; ▁j ▁++ ▁) ▁if ▁( ▁s 2 ▁. ▁charAt ▁( ▁i ▁+ ▁j ▁) ▁!= ▁s 1 ▁. ▁charAt ▁( ▁j ▁) ▁) ▁break ▁; ▁if ▁( ▁j ▁== ▁M ▁) ▁return ▁i ▁; ▁} ▁return ▁- ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁String ▁s 1 ▁= ▁" ▁for ▁" ▁; ▁String ▁s 2 ▁= ▁" ▁g eek s forge ek s ▁" ▁; ▁int ▁res ▁= ▁is Sub string ▁( ▁s 1 ▁, ▁s 2 ▁) ▁; ▁if ▁( ▁res ▁== ▁- ▁1 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Not ▁present ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁P resent ▁at ▁index ▁" ▁+ ▁res ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁pattern Count ▁( ▁String ▁str ▁) ▁{ ▁char ▁last ▁= ▁str ▁. ▁charAt ▁( ▁0 ▁) ▁; ▁int ▁i ▁= ▁1 ▁, ▁counter ▁= ▁0 ▁; ▁while ▁( ▁i ▁< ▁str ▁. ▁length ▁( ▁) ▁) ▁{ ▁if ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'0' ▁&& ▁last ▁== ▁'1' ▁) ▁{ ▁while ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'0' ▁) ▁i ▁++ ▁; ▁if ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'1' ▁) ▁counter ▁++ ▁; ▁} ▁last ▁= ▁str ▁. ▁charAt ▁( ▁i ▁) ▁; ▁i ▁++ ▁; ▁} ▁return ▁counter ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁"100 1 ab 010 abc 0100 1" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁pattern Count ▁( ▁str ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁public ▁class ▁index ▁{ ▁static ▁int ▁max ▁= ▁0 ▁; ▁static ▁String ▁ans 1 ▁= ▁" ▁" ▁; ▁static ▁void ▁calculate ▁( ▁String ▁ans ▁) ▁{ ▁int ▁dp ▁[ ▁] ▁= ▁new ▁int ▁[ ▁26 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁ans ▁. ▁length ▁( ▁) ▁; ▁++ ▁i ▁) ▁{ ▁dp ▁[ ▁ans ▁. ▁charAt ▁( ▁i ▁) ▁- ▁' ▁A ▁' ▁] ▁++ ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁dp ▁. ▁length ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁dp ▁[ ▁i ▁] ▁% ▁2 ▁== ▁1 ▁) ▁{ ▁return ▁; ▁} ▁} ▁if ▁( ▁max ▁< ▁ans ▁. ▁length ▁( ▁) ▁) ▁{ ▁max ▁= ▁ans ▁. ▁length ▁( ▁) ▁; ▁ans 1 ▁= ▁ans ▁; ▁} ▁} ▁static ▁void ▁longest String ▁( ▁List ▁< ▁String ▁> ▁arr ▁, ▁int ▁index ▁, ▁String ▁str ▁) ▁{ ▁if ▁( ▁index ▁== ▁arr ▁. ▁size ▁( ▁) ▁) ▁{ ▁return ▁; ▁} ▁longest String ▁( ▁arr ▁, ▁index ▁+ ▁1 ▁, ▁str ▁) ▁; ▁str ▁+= ▁arr ▁. ▁get ▁( ▁index ▁) ▁; ▁calculate ▁( ▁str ▁) ▁; ▁longest String ▁( ▁arr ▁, ▁index ▁+ ▁1 ▁, ▁str ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁ArrayList ▁< ▁String ▁> ▁A ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁A ▁. ▁add ▁( ▁" ▁AB AB ▁" ▁) ▁; ▁A ▁. ▁add ▁( ▁" ▁AB F ▁" ▁) ▁; ▁A ▁. ▁add ▁( ▁" ▁C DA ▁" ▁) ▁; ▁A ▁. ▁add ▁( ▁" ▁AD ▁" ▁) ▁; ▁A ▁. ▁add ▁( ▁" ▁C CC ▁" ▁) ▁; ▁longest String ▁( ▁A ▁, ▁0 ▁, ▁" ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁ans 1 ▁+ ▁" ▁" ▁+ ▁ans 1 ▁. ▁length ▁( ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁find Sub sequence ▁( ▁String ▁str ▁) ▁{ ▁int ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁char ▁[ ▁] ▁res ▁= ▁new ▁char ▁[ ▁n ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁res ▁[ ▁i ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁pos ▁= ▁0 ▁; ▁pos ▁<= ▁9 ▁; ▁pos ▁++ ▁) ▁{ ▁char ▁lst 1 ▁= ▁'0' ▁; ▁boolean ▁flag ▁= ▁true ▁; ▁char ▁lst 2 ▁= ▁( ▁char ▁) ▁( ▁pos ▁+ ▁'0' ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁lst 2 ▁<= ▁str ▁. ▁charAt ▁( ▁i ▁) ▁) ▁{ ▁res ▁[ ▁i ▁] ▁= ▁'2' ▁; ▁lst 2 ▁= ▁str ▁. ▁charAt ▁( ▁i ▁) ▁; ▁} ▁else ▁if ▁( ▁lst 1 ▁<= ▁str ▁. ▁charAt ▁( ▁i ▁) ▁) ▁{ ▁res ▁[ ▁i ▁] ▁= ▁'1' ▁; ▁lst 1 ▁= ▁str ▁. ▁charAt ▁( ▁i ▁) ▁; ▁} ▁else ▁flag ▁= ▁false ▁; ▁} ▁if ▁( ▁lst 1 ▁> ▁pos ▁+ ▁'0' ▁) ▁flag ▁= ▁false ▁; ▁if ▁( ▁flag ▁) ▁{ ▁String ▁S 1 ▁= ▁" ▁" ▁; ▁String ▁S 2 ▁= ▁" ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁res ▁[ ▁i ▁] ▁== ▁'1' ▁) ▁{ ▁S 1 ▁+= ▁str ▁. ▁charAt ▁( ▁i ▁) ▁; ▁} ▁else ▁{ ▁S 2 ▁+= ▁str ▁. ▁charAt ▁( ▁i ▁) ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁S 1 ▁+ ▁" ▁" ▁+ ▁S 2 ▁+ ▁" NEW _ LINE "); ▁return ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁- ▁1" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁S ▁= ▁"0 404 255 24 64 4" ▁; ▁find Sub sequence ▁( ▁S ▁) ▁; ▁S ▁= ▁"1234 56789 " ▁; ▁find Sub sequence ▁( ▁S ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁String ▁ans ▁, ▁s ▁; ▁static ▁int ▁K ▁; ▁static ▁void ▁getString ▁( ▁int ▁curl en ▁, ▁int ▁N ▁, ▁int ▁[ ▁] ▁prod ▁) ▁{ ▁if ▁( ▁curl en ▁== ▁N ▁) ▁{ ▁K ▁-- ▁; ▁if ▁( ▁K ▁== ▁0 ▁) ▁ans ▁= ▁s ▁; ▁return ▁; ▁} ▁char ▁ch ▁; ▁int ▁ok ▁, ▁t ▁, ▁i ▁; ▁for ▁( ▁ch ▁= ▁'2' ▁; ▁ch ▁<= ▁'9' ▁; ▁ch ▁++ ▁) ▁{ ▁s ▁+= ▁ch ▁; ▁ok ▁= ▁1 ▁; ▁t ▁= ▁1 ▁; ▁for ▁( ▁i ▁= ▁curl en ▁; ▁i ▁>= ▁0 ▁&& ▁s ▁. ▁length ▁( ▁) ▁> ▁i ▁; ▁i ▁-- ▁) ▁{ ▁t ▁*= ▁s ▁. ▁charAt ▁( ▁i ▁) ▁- ▁48 ▁; ▁if ▁( ▁prod ▁[ ▁t ▁] ▁!= ▁0 ▁) ▁ok ▁= ▁0 ▁; ▁prod ▁[ ▁t ▁] ▁++ ▁; ▁} ▁if ▁( ▁ok ▁!= ▁0 ▁) ▁getString ▁( ▁curl en ▁+ ▁1 ▁, ▁N ▁, ▁prod ▁) ▁; ▁t ▁= ▁1 ▁; ▁for ▁( ▁i ▁= ▁curl en ▁; ▁i ▁>= ▁0 ▁&& ▁s ▁. ▁length ▁( ▁) ▁> ▁i ▁; ▁i ▁-- ▁) ▁{ ▁t ▁*= ▁s ▁. ▁charAt ▁( ▁i ▁) ▁- ▁48 ▁; ▁prod ▁[ ▁t ▁] ▁-- ▁; ▁} ▁if ▁( ▁s ▁. ▁length ▁( ▁) ▁> ▁0 ▁) ▁s ▁= ▁s ▁. ▁substring ▁( ▁0 ▁, ▁s ▁. ▁length ▁( ▁) ▁- ▁1 ▁) ▁; ▁} ▁} ▁static ▁String ▁k th Valid String ▁( ▁int ▁N ▁) ▁{ ▁if ▁( ▁N ▁> ▁10 ▁) ▁{ ▁return ▁" ▁- ▁1" ▁; ▁} ▁if ▁( ▁N ▁== ▁1 ▁) ▁{ ▁if ▁( ▁K ▁> ▁10 ▁) ▁{ ▁return ▁" ▁- ▁1" ▁; ▁} ▁String ▁s ▁= ▁" ▁" ▁; ▁K ▁-- ▁; ▁s ▁+= ▁( ▁K ▁+ ▁'0' ▁) ▁; ▁return ▁s ▁; ▁} ▁ans ▁= ▁" ▁- ▁1" ▁; ▁s ▁= ▁" ▁" ▁; ▁int ▁[ ▁] ▁prod ▁= ▁new ▁int ▁[ ▁1000 5 ▁] ▁; ▁getString ▁( ▁0 ▁, ▁N ▁, ▁prod ▁) ▁; ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁3 ▁; ▁K ▁= ▁4 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁k th Valid String ▁( ▁N ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁G F G ▁{ ▁static ▁String ▁checkIf Possible ▁( ▁int ▁N ▁, ▁String ▁[ ▁] ▁arr ▁, ▁String ▁T ▁) ▁{ ▁int ▁[ ▁] ▁freq S ▁= ▁new ▁int ▁[ ▁256 ▁] ▁; ▁int ▁[ ▁] ▁freq T ▁= ▁new ▁int ▁[ ▁256 ▁] ▁; ▁for ▁( ▁char ▁ch ▁: ▁T ▁. ▁toCharArray ▁( ▁) ▁) ▁{ ▁freq T ▁[ ▁ch ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁char ▁ch ▁: ▁arr ▁[ ▁i ▁] ▁. ▁toCharArray ▁( ▁) ▁) ▁{ ▁freq S ▁[ ▁ch ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁256 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁freq T ▁[ ▁i ▁] ▁== ▁0 ▁&& ▁freq S ▁[ ▁i ▁] ▁!= ▁0 ▁) ▁{ ▁return ▁" ▁No ▁" ▁; ▁} ▁else ▁if ▁( ▁freq S ▁[ ▁i ▁] ▁== ▁0 ▁&& ▁freq T ▁[ ▁i ▁] ▁!= ▁0 ▁) ▁{ ▁return ▁" ▁No ▁" ▁; ▁} ▁else ▁if ▁( ▁freq T ▁[ ▁i ▁] ▁!= ▁0 ▁&& ▁freq S ▁[ ▁i ▁] ▁!= ▁( ▁freq T ▁[ ▁i ▁] ▁* ▁N ▁) ▁) ▁{ ▁return ▁" ▁No ▁" ▁; ▁} ▁} ▁return ▁" ▁Yes ▁" ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁[ ▁] ▁arr ▁= ▁{ ▁" ▁abc ▁" ▁, ▁" ▁ab b ▁" ▁, ▁" ▁acc ▁" ▁} ▁; ▁String ▁T ▁= ▁" ▁abc ▁" ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁checkIf Possible ▁( ▁N ▁, ▁arr ▁, ▁T ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁Stack ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁groups Of On es ▁( ▁String ▁S ▁, ▁int ▁N ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁Stack ▁< ▁Integer ▁> ▁st ▁= ▁new ▁Stack ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁S ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'1' ▁) ▁st ▁. ▁push ▁( ▁1 ▁) ▁; ▁else ▁{ ▁if ▁( ▁! ▁st ▁. ▁empty ▁( ▁) ▁) ▁{ ▁count ▁++ ▁; ▁while ▁( ▁! ▁st ▁. ▁empty ▁( ▁) ▁) ▁{ ▁st ▁. ▁pop ▁( ▁) ▁; ▁} ▁} ▁} ▁} ▁if ▁( ▁! ▁st ▁. ▁empty ▁( ▁) ▁) ▁count ▁++ ▁; ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁S ▁= ▁"100 11 01 11" ▁; ▁int ▁N ▁= ▁S ▁. ▁length ▁( ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁groups Of On es ▁( ▁S ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁find Minimum Cost ▁( ▁String ▁s ▁, ▁int ▁N ▁) ▁{ ▁int ▁count _1 ▁= ▁0 ▁, ▁count _0 ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'1' ▁) ▁count _1 ▁++ ▁; ▁else ▁count _0 ▁++ ▁; ▁} ▁int ▁k ▁= ▁Math ▁. ▁abs ▁( ▁count _0 ▁- ▁count _1 ▁) ▁; ▁if ▁( ▁count _1 ▁== ▁N ▁count _0 ▁== ▁N ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁- ▁1 ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁k ▁/ ▁2 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁S ▁= ▁"11 01 10" ▁; ▁int ▁N ▁= ▁S ▁. ▁length ▁( ▁) ▁; ▁find Minimum Cost ▁( ▁S ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁public ▁class ▁G F G ▁{ ▁static ▁int ▁min Length ▁( ▁String ▁S ▁) ▁{ ▁Stack ▁< ▁Character ▁> ▁st ▁= ▁new ▁Stack ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁char ▁ch ▁: ▁S ▁. ▁toCharArray ▁( ▁) ▁) ▁{ ▁if ▁( ▁st ▁. ▁isEmpty ▁( ▁) ▁) ▁st ▁. ▁push ▁( ▁ch ▁) ▁; ▁else ▁{ ▁char ▁top ▁= ▁st ▁. ▁peek ▁( ▁) ▁; ▁if ▁( ▁Math ▁. ▁abs ▁( ▁ch ▁- ▁top ▁) ▁== ▁1 ▁) ▁st ▁. ▁pop ▁( ▁) ▁; ▁else ▁{ ▁st ▁. ▁push ▁( ▁ch ▁) ▁; ▁} ▁} ▁} ▁return ▁st ▁. ▁size ▁( ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁S ▁= ▁"12 21 3" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁min Length ▁( ▁S ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁minimum Del et ions ▁( ▁String ▁s ▁) ▁{ ▁int ▁right _0 ▁= ▁( ▁int ▁) ▁( ▁s ▁. ▁chars ▁( ▁) ▁. ▁filter ▁( ▁ch ▁-> ▁ch ▁== ▁'0' ▁) ▁. ▁count ▁( ▁) ▁) ▁; ▁int ▁left _1 ▁= ▁0 ▁; ▁int ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁int ▁res ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'0' ▁) ▁{ ▁right _0 ▁-= ▁1 ▁; ▁} ▁else ▁{ ▁left _1 ▁+= ▁1 ▁; ▁} ▁res ▁= ▁Math ▁. ▁min ▁( ▁res ▁, ▁right _0 ▁+ ▁left _1 ▁) ▁; ▁} ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁s ▁= ▁"00 11 01" ▁; ▁int ▁count ▁= ▁minimum Del et ions ▁( ▁s ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁count ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁cnt Bal anced Parent hesis ▁( ▁String ▁s ▁, ▁int ▁N ▁) ▁{ ▁int ▁cnt Pairs ▁= ▁0 ▁; ▁int ▁cnt Cur ly ▁= ▁0 ▁; ▁int ▁cnt S ml ▁= ▁0 ▁; ▁int ▁cnt S qr ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁== ▁' ▁{ ▁' ▁) ▁{ ▁cnt Cur ly ▁++ ▁; ▁} ▁else ▁if ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁== ▁' ▁( ▁' ▁) ▁{ ▁cnt S ml ▁++ ▁; ▁} ▁else ▁if ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁== ▁' ▁[ ▁' ▁) ▁{ ▁cnt S qr ▁++ ▁; ▁} ▁else ▁if ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁== ▁' ▁} ▁' ▁&& ▁cnt Cur ly ▁> ▁0 ▁) ▁{ ▁cnt Cur ly ▁-- ▁; ▁cnt Pairs ▁++ ▁; ▁} ▁else ▁if ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁== ▁' ▁) ▁' ▁&& ▁cnt S ml ▁> ▁0 ▁) ▁{ ▁cnt S ml ▁-- ▁; ▁cnt Pairs ▁++ ▁; ▁} ▁else ▁if ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁== ▁' ▁] ▁' ▁&& ▁cnt S qr ▁> ▁0 ▁) ▁{ ▁cnt S qr ▁-- ▁; ▁cnt Pairs ▁++ ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁cnt Pairs ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁s ▁= ▁" ▁{ ▁( ▁} ▁) ▁" ▁; ▁int ▁N ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁cnt Bal anced Parent hesis ▁( ▁s ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁canBe Bal anced ▁( ▁String ▁sequence ▁) ▁{ ▁if ▁( ▁sequence ▁. ▁length ▁( ▁) ▁% ▁2 ▁== ▁1 ▁) ▁return ▁false ▁; ▁Stack ▁< ▁Character ▁> ▁stack _ ▁= ▁new ▁Stack ▁< ▁Character ▁> ▁( ▁) ▁; ▁Stack ▁< ▁Character ▁> ▁stack 2_ ▁= ▁new ▁Stack ▁< ▁Character ▁> ▁( ▁) ▁; ▁int ▁count Open ▁= ▁0 ▁, ▁count Closed ▁= ▁0 ▁; ▁int ▁count Symbol ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁sequence ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁sequence ▁. ▁charAt ▁( ▁i ▁) ▁== ▁' ▁) ▁' ▁) ▁{ ▁count Closed ▁++ ▁; ▁if ▁( ▁stack _ ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁else ▁{ ▁stack _ ▁. ▁pop ▁( ▁) ▁; ▁} ▁} ▁else ▁{ ▁if ▁( ▁sequence ▁. ▁charAt ▁( ▁i ▁) ▁== ▁' ▁$ ▁' ▁) ▁{ ▁count Symbol ▁++ ▁; ▁} ▁else ▁{ ▁count Open ▁++ ▁; ▁} ▁stack _ ▁. ▁add ▁( ▁sequence ▁. ▁charAt ▁( ▁i ▁) ▁) ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁sequence ▁. ▁length ▁( ▁) ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁sequence ▁. ▁charAt ▁( ▁i ▁) ▁== ▁' ▁( ▁' ▁) ▁{ ▁if ▁( ▁stack 2_ ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁else ▁{ ▁stack 2_ ▁. ▁pop ▁( ▁) ▁; ▁} ▁} ▁else ▁{ ▁stack 2_ ▁. ▁add ▁( ▁sequence ▁. ▁charAt ▁( ▁i ▁) ▁) ▁; ▁} ▁} ▁int ▁extra ▁= ▁Math ▁. ▁abs ▁( ▁count Closed ▁- ▁count Open ▁) ▁; ▁if ▁( ▁count Symbol ▁< ▁extra ▁) ▁{ ▁return ▁false ▁; ▁} ▁else ▁{ ▁count Symbol ▁-= ▁extra ▁; ▁if ▁( ▁count Symbol ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁return ▁true ▁; ▁} ▁} ▁return ▁false ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁S ▁= ▁" ▁( ▁) ▁( ▁$ ▁" ▁; ▁if ▁( ▁canBe Bal anced ▁( ▁S ▁) ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Yes ▁" ▁) ▁; ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁max Diff Freq ▁( ▁int ▁[ ▁] ▁[ ▁] ▁queries ▁, ▁String ▁S ▁) ▁{ ▁int ▁N ▁= ▁S ▁. ▁length ▁( ▁) ▁; ▁int ▁Q ▁= ▁queries ▁. ▁length ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁Q ▁; ▁++ ▁i ▁) ▁{ ▁int ▁l ▁= ▁queries ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁- ▁1 ▁; ▁int ▁r ▁= ▁queries ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁- ▁1 ▁; ▁int ▁freq ▁[ ▁] ▁= ▁new ▁int ▁[ ▁26 ▁] ▁; ▁for ▁( ▁int ▁j ▁= ▁l ▁; ▁j ▁<= ▁r ▁; ▁j ▁++ ▁) ▁{ ▁freq ▁[ ▁S ▁. ▁charAt ▁( ▁j ▁) ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁} ▁int ▁mx ▁= ▁0 ▁; ▁int ▁mn ▁= ▁9 9999 999 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁26 ▁; ▁j ▁++ ▁) ▁{ ▁mx ▁= ▁Math ▁. ▁max ▁( ▁mx ▁, ▁freq ▁[ ▁j ▁] ▁) ▁; ▁if ▁( ▁freq ▁[ ▁j ▁] ▁> ▁0 ▁) ▁mn ▁= ▁Math ▁. ▁min ▁( ▁mn ▁, ▁freq ▁[ ▁j ▁] ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁mx ▁- ▁mn ▁+ ▁" NEW _ LINE "); ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁S ▁= ▁" ▁ab a ab ac ▁" ▁; ▁int ▁[ ▁] ▁[ ▁] ▁queries ▁= ▁{ ▁{ ▁2 ▁, ▁6 ▁} ▁, ▁{ ▁1 ▁, ▁7 ▁} ▁} ▁; ▁max Diff Freq ▁( ▁queries ▁, ▁S ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁boolean ▁isEqual Strings ▁( ▁String ▁[ ▁] ▁arr ▁, ▁int ▁N ▁) ▁{ ▁int ▁M ▁= ▁arr ▁[ ▁0 ▁] ▁. ▁length ▁( ▁) ▁; ▁int ▁[ ▁] ▁cnt Freq ▁= ▁new ▁int ▁[ ▁256 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁cnt Freq ▁[ ▁i ▁] ▁= ▁0 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁M ▁; ▁j ▁++ ▁) ▁{ ▁cnt Freq ▁[ ▁arr ▁[ ▁i ▁] ▁. ▁charAt ▁( ▁j ▁) ▁- ▁' ▁a ▁' ▁] ▁+= ▁1 ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁256 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁cnt Freq ▁[ ▁i ▁] ▁% ▁N ▁!= ▁0 ▁) ▁{ ▁return ▁false ▁; ▁} ▁} ▁return ▁true ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁[ ▁] ▁arr ▁= ▁{ ▁" ▁a ab ▁" ▁, ▁" ▁bb c ▁" ▁, ▁" ▁c ca ▁" ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁if ▁( ▁isEqual Strings ▁( ▁arr ▁, ▁N ▁) ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁YES ▁" ▁) ▁; ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁NO ▁" ▁) ▁; ▁} ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁public ▁class ▁G F G ▁{ ▁public ▁static ▁void ▁find Freq ▁( ▁String ▁str ▁, ▁int ▁N ▁) ▁{ ▁int ▁[ ▁] ▁freq ▁= ▁new ▁int ▁[ ▁256 ▁] ▁; ▁int ▁max ▁= ▁0 ▁; ▁char ▁char Max ▁= ▁'0' ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁char ▁ch ▁= ▁str ▁. ▁charAt ▁( ▁i ▁) ▁; ▁freq ▁[ ▁ch ▁] ▁++ ▁; ▁if ▁( ▁freq ▁[ ▁ch ▁] ▁>= ▁max ▁) ▁{ ▁max ▁= ▁freq ▁[ ▁ch ▁] ▁; ▁char Max ▁= ▁ch ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁char Max ▁+ ▁" ▁- ▁> ▁" ▁+ ▁max ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁" ▁ab bc ▁" ▁; ▁int ▁N ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁find Freq ▁( ▁str ▁, ▁N ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁count Of Sub string With Only On es ▁( ▁String ▁s ▁) ▁{ ▁int ▁res ▁= ▁0 ▁, ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁count ▁= ▁s ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'1' ▁? ▁count ▁+ ▁1 ▁: ▁0 ▁; ▁res ▁= ▁( ▁res ▁+ ▁count ▁) ▁; ▁} ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁s ▁= ▁"01 101 11" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Of Sub string With Only On es ▁( ▁s ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁N ▁= ▁1000000 ▁+ ▁5 ▁; ▁static ▁int ▁[ ▁] ▁prefix ▁= ▁new ▁int ▁[ ▁N ▁] ▁; ▁static ▁int ▁[ ▁] ▁sum ▁= ▁new ▁int ▁[ ▁N ▁] ▁; ▁static ▁int ▁is Special ▁( ▁char ▁c ▁, ▁char ▁[ ▁] ▁special ▁) ▁{ ▁for ▁( ▁char ▁i ▁: ▁special ▁) ▁if ▁( ▁i ▁== ▁c ▁) ▁return ▁1 ▁; ▁return ▁0 ▁; ▁} ▁static ▁double ▁count Ratio ▁( ▁char ▁[ ▁] ▁s ▁, ▁char ▁[ ▁] ▁special ▁) ▁{ ▁int ▁n ▁= ▁s ▁. ▁length ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁prefix ▁[ ▁i ▁] ▁= ▁( ▁is Special ▁( ▁s ▁[ ▁i ▁] ▁, ▁special ▁) ▁) ▁; ▁if ▁( ▁i ▁> ▁0 ▁) ▁prefix ▁[ ▁i ▁] ▁+= ▁prefix ▁[ ▁i ▁- ▁1 ▁] ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁[ ▁i ▁] ▁= ▁prefix ▁[ ▁i ▁] ▁; ▁if ▁( ▁i ▁> ▁0 ▁) ▁sum ▁[ ▁i ▁] ▁+= ▁sum ▁[ ▁i ▁- ▁1 ▁] ▁; ▁} ▁double ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁count ▁= ▁sum ▁[ ▁n ▁- ▁1 ▁] ▁- ▁( ▁i ▁> ▁1 ▁? ▁sum ▁[ ▁i ▁- ▁2 ▁] ▁: ▁0 ▁) ▁; ▁count ▁-= ▁( ▁i ▁< ▁n ▁? ▁sum ▁[ ▁n ▁- ▁i ▁- ▁1 ▁] ▁: ▁0 ▁) ▁; ▁ans ▁+= ▁( ▁double ▁) ▁count ▁/ ▁( ▁double ▁) ▁i ▁; ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁s ▁= ▁" ▁abcd ▁" ▁; ▁char ▁[ ▁] ▁special ▁= ▁{ ▁' ▁b ▁' ▁, ▁' ▁c ▁' ▁} ▁; ▁double ▁ans ▁= ▁count Ratio ▁( ▁s ▁. ▁toCharArray ▁( ▁) ▁, ▁special ▁) ▁; ▁System ▁. ▁out ▁. ▁format ▁( ▁" ▁% ▁. 6 f ▁" ▁, ▁ans ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁public ▁static ▁boolean ▁isP al indrome ▁( ▁String ▁str ▁) ▁{ ▁int ▁l ▁= ▁0 ▁; ▁int ▁h ▁= ▁str ▁. ▁length ▁( ▁) ▁- ▁1 ▁; ▁while ▁( ▁h ▁> ▁l ▁) ▁{ ▁if ▁( ▁str ▁. ▁charAt ▁( ▁l ▁) ▁!= ▁str ▁. ▁charAt ▁( ▁h ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁l ▁++ ▁; ▁h ▁-- ▁; ▁} ▁return ▁true ▁; ▁} ▁public ▁static ▁String ▁make Odd String ▁( ▁String ▁str ▁) ▁{ ▁String ▁odd ▁= ▁" ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁str ▁. ▁length ▁( ▁) ▁; ▁i ▁+= ▁2 ▁) ▁{ ▁odd ▁+= ▁str ▁. ▁charAt ▁( ▁i ▁) ▁; ▁} ▁return ▁odd ▁; ▁} ▁public ▁static ▁void ▁check Odd ly Pal indrome ▁( ▁String ▁str ▁) ▁{ ▁String ▁odd ▁= ▁make Odd String ▁( ▁str ▁) ▁; ▁if ▁( ▁isP al indrome ▁( ▁odd ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁" ▁dd w f ef w de ▁" ▁; ▁check Odd ly Pal indrome ▁( ▁str ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁public ▁static ▁boolean ▁check Suffix ▁( ▁int ▁A ▁, ▁int ▁B ▁) ▁{ ▁String ▁s 1 ▁= ▁String ▁. ▁valueOf ▁( ▁A ▁) ▁; ▁String ▁s 2 ▁= ▁String ▁. ▁valueOf ▁( ▁B ▁) ▁; ▁int ▁n 1 ▁= ▁s 1 ▁. ▁length ▁( ▁) ▁; ▁int ▁n 2 ▁= ▁s 2 ▁. ▁length ▁( ▁) ▁; ▁if ▁( ▁n 1 ▁< ▁n 2 ▁) ▁{ ▁return ▁false ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n 2 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s 1 ▁. ▁charAt ▁( ▁n 1 ▁- ▁i ▁- ▁1 ▁) ▁!= ▁s 2 ▁. ▁charAt ▁( ▁n 2 ▁- ▁i ▁- ▁1 ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁} ▁return ▁true ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁A ▁= ▁12345 ▁, ▁B ▁= ▁45 ▁; ▁boolean ▁result ▁= ▁check Suffix ▁( ▁A ▁, ▁B ▁) ▁; ▁if ▁( ▁result ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Yes ▁" ▁) ▁; ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁is Prime ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁<= ▁1 ▁) ▁return ▁false ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁Math ▁. ▁sqrt ▁( ▁n ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁return ▁false ▁; ▁} ▁return ▁true ▁; ▁} ▁static ▁boolean ▁isP ossible Sum ▁( ▁int ▁N ▁) ▁{ ▁if ▁( ▁is Prime ▁( ▁N ▁) ▁&& ▁is Prime ▁( ▁N ▁- ▁2 ▁) ▁) ▁{ ▁return ▁true ▁; ▁} ▁else ▁{ ▁return ▁false ▁; ▁} ▁} ▁static ▁boolean ▁check Sem ip r ime ▁( ▁int ▁num ▁) ▁{ ▁int ▁cnt ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁cnt ▁< ▁2 ▁&& ▁i ▁* ▁i ▁<= ▁num ▁; ▁++ ▁i ▁) ▁{ ▁while ▁( ▁num ▁% ▁i ▁== ▁0 ▁) ▁{ ▁num ▁/= ▁i ▁; ▁++ ▁cnt ▁; ▁} ▁} ▁if ▁( ▁num ▁> ▁1 ▁) ▁{ ▁++ ▁cnt ▁; ▁} ▁return ▁cnt ▁== ▁2 ▁; ▁} ▁static ▁void ▁make C y pher String ▁( ▁int ▁N ▁) ▁{ ▁String ▁semi Prime ▁= ▁" ▁" ▁; ▁String ▁sum Of Prime ▁= ▁" ▁" ▁; ▁String ▁str ▁= ▁String ▁. ▁valueOf ▁( ▁N ▁) ▁; ▁if ▁( ▁check Sem ip r ime ▁( ▁N ▁) ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁str ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁% ▁2 ▁== ▁1 ▁) ▁{ ▁semi Prime ▁+= ▁str ▁. ▁charAt ▁( ▁i ▁) ▁; ▁} ▁else ▁{ ▁semi Prime ▁+= ▁( ▁char ▁) ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁- ▁'0' ▁+ ▁65 ▁) ▁; ▁} ▁} ▁} ▁if ▁( ▁isP ossible Sum ▁( ▁N ▁) ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁str ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁% ▁2 ▁== ▁1 ▁) ▁{ ▁sum Of Prime ▁+= ▁( ▁char ▁) ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁- ▁'0' ▁+ ▁65 ▁) ▁; ▁} ▁else ▁{ ▁sum Of Prime ▁+= ▁str ▁. ▁charAt ▁( ▁i ▁) ▁; ▁} ▁} ▁} ▁if ▁( ▁semi Prime ▁+ ▁sum Of Prime ▁== ▁" ▁" ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁- ▁1" ▁) ▁; ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁semi Prime ▁+
▁class ▁G F G ▁{ ▁static ▁void ▁k th _ String ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁2 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁k ▁<= ▁( ▁n ▁- ▁i ▁- ▁1 ▁) ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁j ▁== ▁i ▁j ▁== ▁n ▁- ▁k ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁' ▁Y ▁' ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁' ▁X ▁' ▁) ▁; ▁} ▁break ▁; ▁} ▁k ▁-= ▁( ▁n ▁- ▁i ▁- ▁1 ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁5 ▁, ▁k ▁= ▁7 ▁; ▁k th _ String ▁( ▁n ▁, ▁k ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁String ▁remove Duplicates ▁( ▁String ▁str ▁) ▁{ ▁int ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁String ▁res ▁= ▁" ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁j ▁; ▁for ▁( ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁if ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁== ▁str ▁. ▁charAt ▁( ▁j ▁) ▁) ▁break ▁; ▁if ▁( ▁j ▁== ▁n ▁) ▁res ▁= ▁res ▁+ ▁str ▁. ▁charAt ▁( ▁i ▁) ▁; ▁} ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁" ▁g eek s forge ek s ▁" ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁remove Duplicates ▁( ▁str ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁value ▁( ▁char ▁x ▁) ▁{ ▁return ▁( ▁int ▁) ▁( ▁x ▁- ▁' ▁a ▁' ▁) ▁; ▁} ▁static ▁String ▁maximum Product ▁( ▁String ▁str ▁, ▁int ▁n ▁) ▁{ ▁String ▁answer ▁= ▁" ▁" ▁, ▁curr ▁= ▁" ▁" ▁; ▁long ▁max Product ▁= ▁0 ▁, ▁product ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁product ▁*= ▁1 L ▁* ▁value ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁) ▁; ▁curr ▁+= ▁str ▁. ▁charAt ▁( ▁i ▁) ▁; ▁if ▁( ▁product ▁>= ▁max Product ▁) ▁{ ▁max Product ▁= ▁product ▁; ▁answer ▁= ▁curr ▁; ▁} ▁if ▁( ▁product ▁== ▁0 ▁) ▁{ ▁product ▁= ▁1 ▁; ▁curr ▁= ▁" ▁" ▁; ▁} ▁} ▁return ▁answer ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁" ▁sd tf ak dh da hd zz ▁" ▁; ▁int ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁maximum Product ▁( ▁str ▁, ▁n ▁) ▁+ ▁" NEW _ LINE "); ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁k th String ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁total ▁= ▁0 ▁; ▁int ▁i ▁= ▁1 ▁; ▁while ▁( ▁total ▁< ▁k ▁) ▁{ ▁total ▁= ▁total ▁+ ▁n ▁- ▁i ▁; ▁i ▁++ ▁; ▁} ▁int ▁first _ y _ position ▁= ▁i ▁- ▁1 ▁; ▁int ▁second _ y _ position ▁= ▁k ▁- ▁( ▁total ▁- ▁n ▁+ ▁first _ y _ position ▁) ▁; ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁< ▁first _ y _ position ▁; ▁j ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁x ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁y ▁" ▁) ▁; ▁int ▁j ▁= ▁first _ y _ position ▁+ ▁1 ▁; ▁while ▁( ▁second _ y _ position ▁> ▁1 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁x ▁" ▁) ▁; ▁second _ y _ position ▁-- ▁; ▁j ▁++ ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁y ▁" ▁) ▁; ▁while ▁( ▁j ▁< ▁n ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁x ▁" ▁) ▁; ▁j ▁++ ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁5 ▁; ▁int ▁k ▁= ▁7 ▁; ▁k th String ▁( ▁n ▁, ▁k ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁X or Ascii ▁( ▁String ▁str ▁, ▁int ▁len ▁) ▁{ ▁int ▁ans ▁= ▁( ▁str ▁. ▁charAt ▁( ▁0 ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁len ▁; ▁i ▁++ ▁) ▁{ ▁ans ▁= ▁( ▁ans ▁^ ▁( ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁) ▁) ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁" ▁g eek s forge ek s ▁" ▁; ▁int ▁len ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁X or Ascii ▁( ▁str ▁, ▁len ▁) ▁+ ▁" NEW _ LINE "); ▁str ▁= ▁" ▁G f G ▁" ▁; ▁len ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁X or Ascii ▁( ▁str ▁, ▁len ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁i ▁; ▁static ▁int ▁product At K th Level ▁( ▁String ▁tree ▁, ▁int ▁k ▁, ▁int ▁level ▁) ▁{ ▁if ▁( ▁tree ▁. ▁charAt ▁( ▁i ▁++ ▁) ▁== ▁' ▁( ▁' ▁) ▁{ ▁if ▁( ▁tree ▁. ▁charAt ▁( ▁i ▁) ▁== ▁' ▁) ▁' ▁) ▁return ▁1 ▁; ▁int ▁product ▁= ▁1 ▁; ▁if ▁( ▁level ▁== ▁k ▁) ▁product ▁= ▁tree ▁. ▁charAt ▁( ▁i ▁) ▁- ▁'0' ▁; ▁++ ▁i ▁; ▁int ▁le ftp ro duct ▁= ▁product At K th Level ▁( ▁tree ▁, ▁k ▁, ▁level ▁+ ▁1 ▁) ▁; ▁++ ▁i ▁; ▁int ▁right product ▁= ▁product At K th Level ▁( ▁tree ▁, ▁k ▁, ▁level ▁+ ▁1 ▁) ▁; ▁++ ▁i ▁; ▁return ▁product ▁* ▁le ftp ro duct ▁* ▁right product ▁; ▁} ▁return ▁Integer ▁. ▁MIN _ VALUE ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁tree ▁= ▁" ▁( ▁0 (5 (6 ▁( ▁) ▁( ▁) ▁) ▁( ▁4 ▁( ▁) ▁" ▁+ ▁" ▁( ▁9 ▁( ▁) ▁( ▁) ▁) ▁) ▁) ▁( ▁7 (1 ▁( ▁) ▁( ▁) ▁) ▁( ▁3 ▁( ▁) ▁( ▁) ▁) ▁) ▁) ▁" ▁; ▁int ▁k ▁= ▁2 ▁; ▁i ▁= ▁0 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁product At K th Level ▁( ▁tree ▁, ▁k ▁, ▁0 ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁String ▁CHAR S ▁= ▁" ▁q w erty ui op asdf gh j kl z xc v bn m ▁" ▁; ▁static ▁int ▁MAX ▁= ▁26 ▁; ▁static ▁String ▁getString ▁( ▁char ▁[ ▁] ▁str ▁, ▁int ▁n ▁) ▁{ ▁Map ▁< ▁Character ▁, ▁Character ▁> ▁u Map ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁MAX ▁; ▁i ▁++ ▁) ▁{ ▁u Map ▁. ▁put ▁( ▁CHAR S ▁. ▁charAt ▁( ▁i ▁) ▁, ▁CHAR S ▁. ▁charAt ▁( ▁( ▁i ▁+ ▁1 ▁) ▁% ▁MAX ▁) ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁str ▁[ ▁i ▁] ▁= ▁u Map ▁. ▁get ▁( ▁str ▁[ ▁i ▁] ▁) ▁; ▁} ▁return ▁String ▁. ▁valueOf ▁( ▁str ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁" ▁g eek s ▁" ▁; ▁int ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁getString ▁( ▁str ▁. ▁toCharArray ▁( ▁) ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁final ▁static ▁int ▁MOD ▁= ▁100 000000 7 ▁; ▁static ▁long ▁count Strings ▁( ▁int ▁N ▁) ▁{ ▁int ▁i ▁, ▁j ▁; ▁int ▁dp ▁[ ▁] ▁[ ▁] ▁= ▁new ▁int ▁[ ▁N ▁+ ▁1 ▁] ▁[ ▁3 ▁] ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁j ▁= ▁9 ▁; ▁j ▁< ▁3 ▁; ▁j ▁++ ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁0 ▁; ▁} ▁} ▁dp ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁dp ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁= ▁1 ▁; ▁dp ▁[ ▁1 ▁] ▁[ ▁2 ▁] ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁2 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁= ▁( ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁0 ▁] ▁+ ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁1 ▁] ▁+ ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁2 ▁] ▁) ▁% ▁MOD ▁; ▁dp ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁0 ▁] ▁% ▁MOD ▁; ▁dp ▁[ ▁i ▁] ▁[ ▁2 ▁] ▁= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁1 ▁] ▁% ▁MOD ▁; ▁} ▁int ▁ans ▁= ▁( ▁dp ▁[ ▁N ▁] ▁[ ▁0 ▁] ▁+ ▁dp ▁[ ▁N ▁] ▁[ ▁1 ▁] ▁+ ▁dp ▁[ ▁N ▁] ▁[ ▁2 ▁] ▁) ▁% ▁MOD ▁; ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Strings ▁( ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁String ▁max Number ▁( ▁String ▁str ▁, ▁int ▁n ▁) ▁{ ▁int ▁[ ▁] ▁freq ▁= ▁new ▁int ▁[ ▁2 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁== ▁' ▁z ▁' ▁) ▁freq ▁[ ▁0 ▁] ▁++ ▁; ▁else ▁if ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁== ▁' ▁n ▁' ▁) ▁freq ▁[ ▁1 ▁] ▁++ ▁; ▁} ▁String ▁num ▁= ▁" ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁freq ▁[ ▁1 ▁] ▁; ▁i ▁++ ▁) ▁num ▁+= ▁'1' ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁freq ▁[ ▁0 ▁] ▁; ▁i ▁++ ▁) ▁num ▁+= ▁'0' ▁; ▁return ▁num ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁" ▁ro en en z oo e ▁" ▁; ▁int ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁max Number ▁( ▁str ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁public ▁class ▁Main ▁{ ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁string ▁= ▁" ▁{ ▁[ ▁( ▁) ▁] ▁} ▁[ ▁] ▁" ▁; ▁char ▁[ ▁] ▁lst 1 ▁= ▁{ ▁' ▁{ ▁' ▁, ▁' ▁( ▁' ▁, ▁' ▁[ ▁' ▁} ▁; ▁char ▁[ ▁] ▁lst 2 ▁= ▁{ ▁' ▁} ▁' ▁, ▁' ▁) ▁' ▁, ▁' ▁] ▁' ▁} ▁; ▁Vector ▁< ▁Character ▁> ▁lst ▁= ▁new ▁Vector ▁< ▁Character ▁> ▁( ▁) ▁; ▁HashMap ▁< ▁Character ▁, ▁Character ▁> ▁Dict ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁Dict ▁. ▁put ▁( ▁' ▁) ▁' ▁, ▁' ▁( ▁' ▁) ▁; ▁Dict ▁. ▁put ▁( ▁' ▁} ▁' ▁, ▁' ▁{ ▁' ▁) ▁; ▁Dict ▁. ▁put ▁( ▁' ▁] ▁' ▁, ▁' ▁[ ▁' ▁) ▁; ▁int ▁a ▁= ▁0 ▁, ▁b ▁= ▁0 ▁, ▁c ▁= ▁0 ▁; ▁if ▁( ▁Arrays ▁. ▁asList ▁( ▁lst 2 ▁) ▁. ▁contains ▁( ▁string ▁. ▁charAt ▁( ▁0 ▁) ▁) ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁1 ▁) ▁; ▁} ▁else ▁{ ▁int ▁k ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁string ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁Arrays ▁. ▁asList ▁( ▁lst 1 ▁) ▁. ▁contains ▁( ▁string ▁. ▁charAt ▁( ▁i ▁) ▁) ▁) ▁{ ▁lst ▁. ▁add ▁( ▁string ▁. ▁charAt ▁( ▁i ▁) ▁) ▁; ▁k ▁= ▁i ▁+ ▁2 ▁; ▁} ▁else ▁{ ▁if ▁( ▁lst ▁. ▁size ▁( ▁) ▁== ▁0 ▁&& ▁Arrays ▁. ▁asList ▁( ▁lst 2 ▁) ▁. ▁contains ▁( ▁string ▁. ▁charAt ▁( ▁i ▁) ▁) ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁( ▁i ▁+ ▁1 ▁) ▁) ▁; ▁c ▁= ▁1 ▁; ▁break ▁; ▁} ▁else ▁{ ▁if ▁( ▁lst ▁. ▁size ▁( ▁) ▁> ▁0 ▁&& ▁Dict ▁. ▁get ▁( ▁string ▁. ▁charAt ▁( ▁i ▁) ▁) ▁== ▁lst ▁. ▁get ▁( ▁lst ▁. ▁size ▁( ▁) ▁- ▁1 ▁) ▁) ▁{ ▁lst ▁. ▁remove ▁( ▁lst ▁. ▁size ▁( ▁) ▁- ▁1 ▁) ▁; ▁} ▁else ▁{ ▁a ▁= ▁1 ▁; ▁break ▁; ▁} ▁} ▁} ▁} ▁if ▁( ▁lst ▁. ▁size ▁( ▁) ▁== ▁0 ▁&& ▁c ▁== ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁0 ▁) ▁; ▁b ▁= ▁1 ▁; ▁} ▁if ▁(
▁public ▁class ▁G F G ▁{ ▁static ▁final ▁int ▁MAX ▁= ▁26 ▁; ▁static ▁String ▁encrypt Str ▁( ▁String ▁str ▁, ▁int ▁n ▁, ▁int ▁x ▁) ▁{ ▁x ▁= ▁x ▁% ▁MAX ▁; ▁char ▁arr ▁[ ▁] ▁= ▁str ▁. ▁toCharArray ▁( ▁) ▁; ▁int ▁freq ▁[ ▁] ▁= ▁new ▁int ▁[ ▁MAX ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁freq ▁[ ▁arr ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁freq ▁[ ▁arr ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁] ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁int ▁pos ▁= ▁( ▁arr ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁+ ▁x ▁) ▁% ▁MAX ▁; ▁arr ▁[ ▁i ▁] ▁= ▁( ▁char ▁) ▁( ▁pos ▁+ ▁' ▁a ▁' ▁) ▁; ▁} ▁else ▁{ ▁int ▁pos ▁= ▁( ▁arr ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁- ▁x ▁) ▁; ▁if ▁( ▁pos ▁< ▁0 ▁) ▁pos ▁+= ▁MAX ▁; ▁arr ▁[ ▁i ▁] ▁= ▁( ▁char ▁) ▁( ▁pos ▁+ ▁' ▁a ▁' ▁) ▁; ▁} ▁} ▁return ▁String ▁. ▁valueOf ▁( ▁arr ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁s ▁= ▁" ▁abc da ▁" ▁; ▁int ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁int ▁x ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁encrypt Str ▁( ▁s ▁, ▁n ▁, ▁x ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁count Occurrence ▁( ▁String ▁s ▁, ▁int ▁position ▁) ▁{ ▁int ▁[ ▁] ▁alpha ▁= ▁new ▁int ▁[ ▁26 ▁] ▁; ▁int ▁[ ▁] ▁b ▁= ▁new ▁int ▁[ ▁s ▁. ▁length ▁( ▁) ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁b ▁[ ▁i ▁] ▁= ▁alpha ▁[ ▁( ▁int ▁) ▁s ▁. ▁charAt ▁( ▁i ▁) ▁- ▁97 ▁] ▁; ▁alpha ▁[ ▁( ▁int ▁) ▁s ▁. ▁charAt ▁( ▁i ▁) ▁- ▁97 ▁] ▁++ ▁; ▁} ▁return ▁b ▁[ ▁position ▁- ▁1 ▁] ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁s ▁= ▁" ▁ab ab ab ab ab ▁" ▁; ▁int ▁p ▁= ▁9 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Occurrence ▁( ▁s ▁, ▁p ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁isP ossible ▁( ▁char ▁[ ▁] ▁str ▁) ▁{ ▁Map ▁< ▁Character ▁, ▁Integer ▁> ▁freq ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁int ▁max _ freq ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁( ▁str ▁. ▁length ▁) ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁freq ▁. ▁containsKey ▁( ▁str ▁[ ▁j ▁] ▁) ▁) ▁{ ▁freq ▁. ▁put ▁( ▁str ▁[ ▁j ▁] ▁, ▁freq ▁. ▁get ▁( ▁str ▁[ ▁j ▁] ▁) ▁+ ▁1 ▁) ▁; ▁if ▁( ▁freq ▁. ▁get ▁( ▁str ▁[ ▁j ▁] ▁) ▁> ▁max _ freq ▁) ▁max _ freq ▁= ▁freq ▁. ▁get ▁( ▁str ▁[ ▁j ▁] ▁) ▁; ▁} ▁else ▁{ ▁freq ▁. ▁put ▁( ▁str ▁[ ▁j ▁] ▁, ▁1 ▁) ▁; ▁if ▁( ▁freq ▁. ▁get ▁( ▁str ▁[ ▁j ▁] ▁) ▁> ▁max _ freq ▁) ▁max _ freq ▁= ▁freq ▁. ▁get ▁( ▁str ▁[ ▁j ▁] ▁) ▁; ▁} ▁} ▁if ▁( ▁max _ freq ▁<= ▁( ▁str ▁. ▁length ▁- ▁max _ freq ▁+ ▁1 ▁) ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁" ▁g eek s forge ek s ▁" ▁; ▁if ▁( ▁isP ossible ▁( ▁str ▁. ▁toCharArray ▁( ▁) ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁print Un common ▁( ▁String ▁str 1 ▁, ▁String ▁str 2 ▁) ▁{ ▁int ▁a 1 ▁= ▁0 ▁, ▁a 2 ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁str 1 ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁int ▁ch ▁= ▁( ▁str 1 ▁. ▁charAt ▁( ▁i ▁) ▁) ▁- ▁' ▁a ▁' ▁; ▁a 1 ▁= ▁a 1 ▁| ▁( ▁1 ▁<< ▁ch ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁str 2 ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁int ▁ch ▁= ▁( ▁str 2 ▁. ▁charAt ▁( ▁i ▁) ▁) ▁- ▁' ▁a ▁' ▁; ▁a 2 ▁= ▁a 2 ▁| ▁( ▁1 ▁<< ▁ch ▁) ▁; ▁} ▁int ▁ans ▁= ▁a 1 ▁^ ▁a 2 ▁; ▁int ▁i ▁= ▁0 ▁; ▁while ▁( ▁i ▁< ▁26 ▁) ▁{ ▁if ▁( ▁ans ▁% ▁2 ▁== ▁1 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁( ▁char ▁) ▁( ▁' ▁a ▁' ▁+ ▁i ▁) ▁) ▁; ▁} ▁ans ▁= ▁ans ▁/ ▁2 ▁; ▁i ▁++ ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str 1 ▁= ▁" ▁g eek s forge ek s ▁" ▁; ▁String ▁str 2 ▁= ▁" ▁g eek s quiz ▁" ▁; ▁print Un common ▁( ▁str 1 ▁, ▁str 2 ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁cnt ▁= ▁0 ▁; ▁static ▁Vector ▁< ▁Integer ▁> ▁[ ▁] ▁graph ▁= ▁new ▁Vector ▁[ ▁100 ▁] ▁; ▁static ▁String ▁[ ▁] ▁weight ▁= ▁new ▁String ▁[ ▁100 ▁] ▁; ▁static ▁boolean ▁unique Chars ▁( ▁char ▁[ ▁] ▁arr ▁) ▁{ ▁HashMap ▁< ▁Character ▁, ▁Integer ▁> ▁mp ▁= ▁new ▁HashMap ▁< ▁Character ▁, ▁Integer ▁> ▁( ▁) ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁mp ▁. ▁containsKey ▁( ▁arr ▁[ ▁i ▁] ▁) ▁) ▁{ ▁mp ▁. ▁put ▁( ▁arr ▁[ ▁i ▁] ▁, ▁mp ▁. ▁get ▁( ▁arr ▁[ ▁i ▁] ▁) ▁+ ▁1 ▁) ▁; ▁} ▁else ▁{ ▁mp ▁. ▁put ▁( ▁arr ▁[ ▁i ▁] ▁, ▁1 ▁) ▁; ▁} ▁if ▁( ▁mp ▁. ▁size ▁( ▁) ▁== ▁arr ▁. ▁length ▁) ▁return ▁true ▁; ▁else ▁return ▁false ▁; ▁} ▁static ▁void ▁dfs ▁( ▁int ▁node ▁, ▁int ▁parent ▁) ▁{ ▁if ▁( ▁unique Chars ▁( ▁weight ▁[ ▁node ▁] ▁. ▁toCharArray ▁( ▁) ▁) ▁) ▁cnt ▁+= ▁1 ▁; ▁for ▁( ▁int ▁to ▁: ▁graph ▁[ ▁node ▁] ▁) ▁{ ▁if ▁( ▁to ▁== ▁parent ▁) ▁continue ▁; ▁dfs ▁( ▁to ▁, ▁node ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁100 ▁; ▁i ▁++ ▁) ▁graph ▁[ ▁i ▁] ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁weight ▁[ ▁1 ▁] ▁= ▁" ▁abc ▁" ▁; ▁weight ▁[ ▁2 ▁] ▁= ▁" ▁ab a ▁" ▁; ▁weight ▁[ ▁3 ▁] ▁= ▁" ▁b cb ▁" ▁; ▁weight ▁[ ▁4 ▁] ▁= ▁" ▁m oh ▁" ▁; ▁weight ▁[ ▁5 ▁] ▁= ▁" ▁aa ▁" ▁; ▁graph ▁[ ▁1 ▁] ▁. ▁add ▁( ▁2 ▁) ▁; ▁graph ▁[ ▁2 ▁] ▁. ▁add ▁( ▁3 ▁) ▁; ▁graph ▁[ ▁2 ▁] ▁. ▁add ▁( ▁4 ▁) ▁; ▁graph ▁[ ▁1 ▁] ▁. ▁add ▁( ▁5 ▁) ▁; ▁dfs ▁( ▁1 ▁, ▁1 ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁cnt ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁check ▁( ▁String ▁s ▁, ▁int ▁l ▁) ▁{ ▁Vector ▁< ▁Integer ▁> ▁pos ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁l ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'1' ▁) ▁pos ▁. ▁add ▁( ▁i ▁) ▁; ▁} ▁int ▁t ▁= ▁pos ▁. ▁size ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁t ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁pos ▁. ▁get ▁( ▁i ▁) ▁- ▁pos ▁. ▁get ▁( ▁i ▁- ▁1 ▁) ▁) ▁!= ▁( ▁pos ▁. ▁get ▁( ▁1 ▁) ▁- ▁pos ▁. ▁get ▁( ▁0 ▁) ▁) ▁) ▁return ▁false ▁; ▁} ▁return ▁true ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁String ▁s ▁= ▁"100 01 0001 000" ▁; ▁int ▁l ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁if ▁( ▁check ▁( ▁s ▁, ▁l ▁) ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁boolean ▁is Prefix ▁( ▁String ▁str ▁, ▁int ▁len ▁, ▁int ▁i ▁, ▁int ▁k ▁) ▁{ ▁if ▁( ▁i ▁+ ▁k ▁> ▁len ▁) ▁return ▁false ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁k ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁!= ▁str ▁. ▁charAt ▁( ▁j ▁) ▁) ▁return ▁false ▁; ▁i ▁++ ▁; ▁} ▁return ▁true ▁; ▁} ▁static ▁boolean ▁is K Period ic ▁( ▁String ▁str ▁, ▁int ▁len ▁, ▁int ▁k ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁k ▁; ▁i ▁< ▁len ▁; ▁i ▁+= ▁k ▁) ▁if ▁( ▁! ▁is Prefix ▁( ▁str ▁, ▁len ▁, ▁i ▁, ▁k ▁) ▁) ▁return ▁false ▁; ▁return ▁true ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁" ▁g eek sg eek s ▁" ▁; ▁int ▁len ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁int ▁k ▁= ▁5 ▁; ▁if ▁( ▁is K Period ic ▁( ▁str ▁, ▁len ▁, ▁k ▁) ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁p ang ram Cost ▁( ▁int ▁arr ▁[ ▁] ▁, ▁String ▁str ▁) ▁{ ▁int ▁cost ▁= ▁0 ▁; ▁boolean ▁[ ▁] ▁occurred ▁= ▁new ▁boolean ▁[ ▁26 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁26 ▁; ▁i ▁++ ▁) ▁occurred ▁[ ▁i ▁] ▁= ▁false ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁str ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁occurred ▁[ ▁str ▁. ▁charAt ▁( ▁i ▁) ▁- ▁' ▁a ▁' ▁] ▁= ▁true ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁26 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁occurred ▁[ ▁i ▁] ▁== ▁false ▁) ▁cost ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁return ▁cost ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁, ▁7 ▁, ▁8 ▁, ▁9 ▁, ▁10 ▁, ▁11 ▁, ▁12 ▁, ▁13 ▁, ▁14 ▁, ▁15 ▁, ▁16 ▁, ▁17 ▁, ▁18 ▁, ▁19 ▁, ▁20 ▁, ▁21 ▁, ▁22 ▁, ▁23 ▁, ▁24 ▁, ▁25 ▁, ▁26 ▁} ▁; ▁String ▁str ▁= ▁" ▁abcdef ghijkl m op qrst uvw z ▁" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁p ang ram Cost ▁( ▁arr ▁, ▁str ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁G F G ▁{ ▁static ▁int ▁check ▁( ▁String ▁s ▁) ▁{ ▁int ▁i ▁, ▁j ▁; ▁int ▁fr ▁[ ▁] ▁= ▁new ▁int ▁[ ▁26 ▁] ▁; ▁int ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁char ▁x ▁= ▁s ▁. ▁charAt ▁( ▁i ▁) ▁; ▁fr ▁[ ▁x ▁- ▁' ▁a ▁' ▁] ▁+= ▁1 ▁; ▁} ▁int ▁minimum ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁26 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁26 ▁; ▁j ▁++ ▁) ▁{ ▁int ▁z ▁= ▁fr ▁[ ▁i ▁] ▁+ ▁fr ▁[ ▁j ▁] ▁; ▁minimum ▁= ▁Math ▁. ▁min ▁( ▁minimum ▁, ▁n ▁- ▁z ▁) ▁; ▁} ▁} ▁return ▁minimum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁s ▁= ▁" ▁g eek s forge ek s ▁" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁check ▁( ▁s ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁Solution ▁{ ▁static ▁String ▁separate Char ▁( ▁String ▁str ▁) ▁{ ▁int ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁, ▁digit Sum ▁= ▁0 ▁; ▁int ▁alphabet Sum ▁= ▁0 ▁, ▁j ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁>= ▁'0' ▁&& ▁str ▁. ▁charAt ▁( ▁i ▁) ▁<= ▁'9' ▁) ▁{ ▁digit Sum ▁+= ▁( ▁int ▁) ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁- ▁'0' ▁) ▁; ▁} ▁else ▁{ ▁alphabet Sum ▁+= ▁str ▁. ▁charAt ▁( ▁i ▁) ▁- ▁' ▁a ▁' ▁+ ▁1 ▁; ▁alphabet Sum ▁% = ▁26 ▁; ▁} ▁} ▁String ▁sum Str ▁= ▁" ▁" ▁+ ▁( ▁digit Sum ▁) ▁; ▁char ▁alphabet Str ▁= ▁( ▁char ▁) ▁( ▁alphabet Sum ▁+ ▁' ▁a ▁' ▁- ▁1 ▁) ▁; ▁sum Str ▁+= ▁alphabet Str ▁; ▁return ▁sum Str ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁String ▁str ▁= ▁" 36 52 ad yz 34 2 3" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁separate Char ▁( ▁str ▁) ▁) ▁; ▁} ▁}
▁class ▁solution ▁{ ▁static ▁int ▁count Words ▁( ▁String ▁str ▁) ▁{ ▁int ▁count ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁str ▁. ▁length ▁( ▁) ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁>= ▁65 ▁&& ▁str ▁. ▁charAt ▁( ▁i ▁) ▁<= ▁90 ▁) ▁count ▁++ ▁; ▁} ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁String ▁str ▁= ▁" ▁g eek s For G eek s ▁" ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁count Words ▁( ▁str ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁g fg ▁{ ▁int ▁find ▁( ▁String ▁s ▁) ▁{ ▁int ▁max ▁= ▁0 ▁, ▁i ▁, ▁j ▁= ▁0 ▁, ▁count k ▁= ▁0 ▁, ▁c oun tr ▁= ▁0 ▁; ▁int ▁table ▁[ ▁] ▁[ ▁] ▁= ▁new ▁int ▁[ ▁s ▁. ▁length ▁( ▁) ▁] ▁[ ▁2 ▁] ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁== ▁' ▁R ▁' ▁) ▁c oun tr ▁++ ▁; ▁else ▁table ▁[ ▁j ▁++ ▁] ▁[ ▁0 ▁] ▁= ▁c oun tr ▁; ▁} ▁j ▁-- ▁; ▁for ▁( ▁i ▁= ▁s ▁. ▁length ▁( ▁) ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁== ▁' ▁K ▁' ▁) ▁{ ▁count k ▁++ ▁; ▁table ▁[ ▁j ▁-- ▁] ▁[ ▁1 ▁] ▁= ▁count k ▁; ▁} ▁if ▁( ▁Math ▁. ▁min ▁( ▁table ▁[ ▁j ▁+ ▁1 ▁] ▁[ ▁0 ▁] ▁, ▁table ▁[ ▁j ▁+ ▁1 ▁] ▁[ ▁1 ▁] ▁) ▁> ▁max ▁) ▁max ▁= ▁Math ▁. ▁min ▁( ▁table ▁[ ▁j ▁+ ▁1 ▁] ▁[ ▁0 ▁] ▁, ▁table ▁[ ▁j ▁+ ▁1 ▁] ▁[ ▁1 ▁] ▁) ▁; ▁} ▁return ▁max ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁sr gs ▁[ ▁] ▁) ▁{ ▁String ▁s ▁= ▁" ▁R K RR R K K RR K K K K RR ▁" ▁; ▁g fg ▁ob ▁= ▁new ▁g fg ▁( ▁) ▁; ▁int ▁n ▁= ▁ob ▁. ▁find ▁( ▁s ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁n ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁ArrayList ▁; ▁public ▁class ▁string _ sort ▁{ ▁public ▁static ▁int ▁power Of Jump ▁( ▁String ▁s ▁) ▁{ ▁int ▁count ▁= ▁1 ▁; ▁int ▁max _ so _ far ▁= ▁Integer ▁. ▁MIN _ VALUE ▁; ▁char ▁ch ▁= ▁s ▁. ▁charAt ▁( ▁s ▁. ▁length ▁( ▁) ▁- ▁1 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁== ▁ch ▁) ▁{ ▁if ▁( ▁count ▁> ▁max _ so _ far ▁) ▁{ ▁max _ so _ far ▁= ▁count ▁; ▁} ▁count ▁= ▁1 ▁; ▁} ▁else ▁count ▁++ ▁; ▁} ▁return ▁max _ so _ far ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁st ▁= ▁"1 0101 01" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁power Of Jump ▁( ▁st ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁public ▁static ▁String ▁multiply ▁( ▁String ▁num 1 ▁, ▁String ▁num 2 ▁) ▁{ ▁int ▁n 1 ▁= ▁num 1 ▁. ▁length ▁( ▁) ▁; ▁int ▁n 2 ▁= ▁num 2 ▁. ▁length ▁( ▁) ▁; ▁if ▁( ▁n 1 ▁== ▁0 ▁n 2 ▁== ▁0 ▁) ▁return ▁"0" ▁; ▁int ▁[ ▁] ▁result ▁= ▁new ▁int ▁[ ▁n 1 ▁+ ▁n 2 ▁] ▁; ▁int ▁i _ n 1 ▁= ▁0 ▁; ▁int ▁i _ n 2 ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁n 1 ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁int ▁carry ▁= ▁0 ▁; ▁int ▁n _1 ▁= ▁num 1 ▁. ▁charAt ▁( ▁i ▁) ▁- ▁'0' ▁; ▁i _ n 2 ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁n 2 ▁- ▁1 ▁; ▁j ▁>= ▁0 ▁; ▁j ▁-- ▁) ▁{ ▁int ▁n _2 ▁= ▁num 2 ▁. ▁charAt ▁( ▁j ▁) ▁- ▁'0' ▁; ▁int ▁sum ▁= ▁n _1 ▁* ▁n _2 ▁+ ▁result ▁[ ▁i _ n 1 ▁+ ▁i _ n 2 ▁] ▁+ ▁carry ▁; ▁carry ▁= ▁sum ▁/ ▁10 ▁; ▁result ▁[ ▁i _ n 1 ▁+ ▁i _ n 2 ▁] ▁= ▁sum ▁% ▁10 ▁; ▁i _ n 2 ▁++ ▁; ▁} ▁if ▁( ▁carry ▁> ▁0 ▁) ▁result ▁[ ▁i _ n 1 ▁+ ▁i _ n 2 ▁] ▁+= ▁carry ▁; ▁i _ n 1 ▁++ ▁; ▁} ▁int ▁i ▁= ▁result ▁. ▁length ▁- ▁1 ▁; ▁while ▁( ▁i ▁>= ▁0 ▁&& ▁result ▁[ ▁i ▁] ▁== ▁0 ▁) ▁i ▁-- ▁; ▁if ▁( ▁i ▁== ▁- ▁1 ▁) ▁return ▁"0" ▁; ▁String ▁s ▁= ▁" ▁" ▁; ▁while ▁( ▁i ▁>= ▁0 ▁) ▁s ▁+= ▁Integer ▁. ▁toString ▁( ▁result ▁[ ▁i ▁-- ▁] ▁) ▁; ▁return ▁s ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str 1 ▁= ▁" 45 45 45 45 45 45 45 45 45 " ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁multiply ▁( ▁str 1 ▁, ▁str 1 ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁match _ words ▁( ▁String ▁dictionary ▁[ ▁] ▁, ▁String ▁sentence ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁Map ▁< ▁String ▁, ▁Integer ▁> ▁mp ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁mp ▁. ▁containsKey ▁( ▁dictionary ▁[ ▁i ▁] ▁) ▁) ▁{ ▁mp ▁. ▁put ▁( ▁dictionary ▁[ ▁i ▁] ▁, ▁mp ▁. ▁get ▁( ▁dictionary ▁[ ▁i ▁] ▁) ▁+ ▁1 ▁) ▁; ▁} ▁else ▁{ ▁mp ▁. ▁put ▁( ▁dictionary ▁[ ▁i ▁] ▁, ▁1 ▁) ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁m ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁mp ▁. ▁containsKey ▁( ▁sentence ▁[ ▁i ▁] ▁) ▁) ▁mp ▁. ▁put ▁( ▁sentence ▁[ ▁i ▁] ▁, ▁mp ▁. ▁get ▁( ▁sentence ▁[ ▁i ▁] ▁) ▁- ▁1 ▁) ▁; ▁else ▁return ▁false ▁; ▁} ▁return ▁true ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁dictionary ▁[ ▁] ▁= ▁{ ▁" ▁find ▁" ▁, ▁" ▁a ▁" ▁, ▁" ▁g eek s ▁" ▁, ▁" ▁all ▁" ▁, ▁" ▁for ▁" ▁, ▁" ▁on ▁" ▁, ▁" ▁g eek s ▁" ▁, ▁" ▁answers ▁" ▁, ▁" ▁inter ▁" ▁} ▁; ▁int ▁n ▁= ▁dictionary ▁. ▁length ▁; ▁String ▁sentence ▁[ ▁] ▁= ▁{ ▁" ▁find ▁" ▁, ▁" ▁all ▁" ▁, ▁" ▁answers ▁" ▁, ▁" ▁on ▁" ▁, ▁" ▁g eek s ▁" ▁, ▁" ▁for ▁" ▁, ▁" ▁g eek s ▁" ▁} ▁; ▁int ▁m ▁= ▁sentence ▁. ▁length ▁; ▁if ▁( ▁match _ words ▁( ▁dictionary ▁, ▁sentence ▁, ▁n ▁, ▁m ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁YES ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁NO ▁" ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁find _ sub ▁( ▁String ▁s ▁, ▁int ▁k ▁) ▁{ ▁int ▁len ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁int ▁lp ▁= ▁0 ▁, ▁rp ▁= ▁0 ▁; ▁int ▁ans ▁= ▁0 ▁; ▁int ▁[ ▁] ▁hash _ char ▁= ▁new ▁int ▁[ ▁26 ▁] ▁; ▁for ▁( ▁; ▁rp ▁< ▁len ▁; ▁rp ▁++ ▁) ▁{ ▁hash _ char ▁[ ▁s ▁. ▁charAt ▁( ▁rp ▁) ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁while ▁( ▁hash _ char ▁[ ▁s ▁. ▁charAt ▁( ▁rp ▁) ▁- ▁' ▁a ▁' ▁] ▁> ▁k ▁) ▁{ ▁hash _ char ▁[ ▁s ▁. ▁charAt ▁( ▁lp ▁) ▁- ▁' ▁a ▁' ▁] ▁-- ▁; ▁lp ▁++ ▁; ▁} ▁ans ▁+= ▁rp ▁- ▁lp ▁+ ▁1 ▁; ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁S ▁= ▁" ▁aa abb ▁" ▁; ▁int ▁k ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find _ sub ▁( ▁S ▁, ▁k ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁public ▁class ▁G F G ▁{ ▁static ▁boolean ▁transform String ▁( ▁StringBuilder ▁s ▁) ▁{ ▁char ▁ch ▁= ▁' ▁a ▁' ▁; ▁if ▁( ▁s ▁. ▁length ▁( ▁) ▁< ▁26 ▁) ▁return ▁false ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁int ▁) ▁ch ▁> ▁( ▁int ▁) ▁' ▁z ▁' ▁) ▁break ▁; ▁if ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁<= ▁ch ▁) ▁{ ▁s ▁. ▁set Char At ▁( ▁i ▁, ▁ch ▁) ▁; ▁ch ▁= ▁( ▁char ▁) ▁( ▁( ▁int ▁) ▁ch ▁+ ▁1 ▁) ▁; ▁} ▁} ▁if ▁( ▁ch ▁<= ▁' ▁z ▁' ▁) ▁return ▁false ▁; ▁return ▁true ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁StringBuilder ▁str ▁= ▁new ▁StringBuilder ▁( ▁" ▁a aaaaaaaaaaaaaaaa aaaaaaaa a ▁" ▁) ▁; ▁if ▁( ▁transform String ▁( ▁str ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁str ▁. ▁toString ▁( ▁) ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Not ▁Possible ▁" ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁boolean ▁isP al indrome ▁( ▁String ▁str ▁) ▁{ ▁int ▁i ▁= ▁0 ▁, ▁j ▁= ▁str ▁. ▁length ▁( ▁) ▁- ▁1 ▁; ▁while ▁( ▁i ▁< ▁j ▁) ▁{ ▁if ▁( ▁str ▁. ▁charAt ▁( ▁i ▁++ ▁) ▁!= ▁str ▁. ▁charAt ▁( ▁j ▁-- ▁) ▁) ▁return ▁false ▁; ▁} ▁return ▁true ▁; ▁} ▁static ▁String ▁remove Pal in Words ▁( ▁String ▁str ▁) ▁{ ▁String ▁final _ str ▁= ▁" ▁" ▁, ▁word ▁= ▁" ▁" ▁; ▁str ▁= ▁str ▁+ ▁" ▁" ▁; ▁int ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁!= ▁' ▁' ▁) ▁word ▁= ▁word ▁+ ▁str ▁. ▁charAt ▁( ▁i ▁) ▁; ▁else ▁{ ▁if ▁( ▁! ▁( ▁isP al indrome ▁( ▁word ▁) ▁) ▁) ▁final _ str ▁+= ▁word ▁+ ▁" ▁" ▁; ▁word ▁= ▁" ▁" ▁; ▁} ▁} ▁return ▁final _ str ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁" ▁Text ▁contains ▁m al ay al am ▁and ▁level ▁words ▁" ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁remove Pal in Words ▁( ▁str ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁class ▁G eek s for G eek s ▁{ ▁static ▁void ▁ASC I IS ent ence ▁( ▁String ▁str ▁) ▁{ ▁int ▁l ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁int ▁convert ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁l ▁; ▁i ▁++ ▁) ▁{ ▁convert ▁= ▁str ▁. ▁charAt ▁( ▁i ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁convert ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁String ▁str ▁= ▁" ▁G eek s for G eek s ▁" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁ASCII ▁Sentence ▁: ▁" ▁) ▁; ▁ASC I IS ent ence ▁( ▁str ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁convert ▁( ▁String ▁str ▁) ▁{ ▁int ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁String ▁str 1 ▁= ▁" ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁== ▁' ▁' ▁) ▁str 1 ▁= ▁str 1 ▁+ ▁' ▁_ ▁' ▁; ▁else ▁str 1 ▁= ▁str 1 ▁+ ▁Character ▁. ▁toLowerCase ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁str 1 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁String ▁str ▁= ▁" ▁I ▁got ▁intern ▁at ▁g eek s forge ek s ▁" ▁; ▁convert ▁( ▁str ▁) ▁; ▁} ▁}
▁public ▁class ▁G F G ▁{ ▁static ▁void ▁find Next Word ▁( ▁char ▁[ ▁] ▁s ▁, ▁int ▁m ▁) ▁{ ▁m ▁+= ▁97 ▁; ▁int ▁n ▁= ▁s ▁. ▁length ▁; ▁int ▁i ▁= ▁s ▁. ▁length ▁- ▁1 ▁; ▁s ▁[ ▁i ▁] ▁++ ▁; ▁while ▁( ▁i ▁>= ▁0 ▁&& ▁i ▁<= ▁n ▁- ▁1 ▁) ▁{ ▁if ▁( ▁s ▁[ ▁i ▁] ▁>= ▁m ▁) ▁{ ▁s ▁[ ▁i ▁] ▁= ▁' ▁a ▁' ▁; ▁s ▁[ ▁-- ▁i ▁] ▁++ ▁; ▁} ▁else ▁if ▁( ▁s ▁[ ▁i ▁] ▁== ▁s ▁[ ▁i ▁- ▁1 ▁] ▁s ▁[ ▁i ▁] ▁== ▁s ▁[ ▁i ▁- ▁2 ▁] ▁) ▁{ ▁s ▁[ ▁i ▁] ▁++ ▁; ▁} ▁else ▁{ ▁i ▁++ ▁; ▁} ▁} ▁if ▁( ▁i ▁<= ▁- ▁1 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁- ▁1" ▁) ▁; ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁s ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁char ▁[ ▁] ▁str ▁= ▁" ▁abcd ▁" ▁. ▁toCharArray ▁( ▁) ▁; ▁int ▁k ▁= ▁4 ▁; ▁find Next Word ▁( ▁str ▁, ▁k ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁String ▁next Word ▁( ▁String ▁str ▁) ▁{ ▁if ▁( ▁str ▁== ▁" ▁" ▁) ▁return ▁" ▁a ▁" ▁; ▁int ▁i ▁= ▁str ▁. ▁length ▁( ▁) ▁- ▁1 ▁; ▁while ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁== ▁' ▁z ▁' ▁&& ▁i ▁>= ▁0 ▁) ▁i ▁-- ▁; ▁if ▁( ▁i ▁== ▁- ▁1 ▁) ▁str ▁= ▁str ▁+ ▁' ▁a ▁' ▁; ▁else ▁str ▁= ▁str ▁. ▁substring ▁( ▁0 ▁, ▁i ▁) ▁+ ▁( ▁char ▁) ▁( ▁( ▁int ▁) ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁) ▁+ ▁1 ▁) ▁+ ▁str ▁. ▁substring ▁( ▁i ▁+ ▁1 ▁) ▁; ▁return ▁str ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁" ▁same z ▁" ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁next Word ▁( ▁str ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁public ▁class ▁G F G ▁{ ▁static ▁int ▁MAX _ CHAR ▁= ▁26 ▁; ▁static ▁int ▁least Count ▁( ▁String ▁s 1 ▁, ▁String ▁s 2 ▁, ▁int ▁n ▁) ▁{ ▁int ▁[ ▁] ▁count 1 ▁= ▁new ▁int ▁[ ▁MAX _ CHAR ▁] ▁; ▁int ▁[ ▁] ▁count 2 ▁= ▁new ▁int ▁[ ▁MAX _ CHAR ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁count 1 ▁[ ▁s 1 ▁. ▁charAt ▁( ▁i ▁) ▁- ▁' ▁a ▁' ▁] ▁+= ▁1 ▁; ▁count 2 ▁[ ▁s 2 ▁. ▁charAt ▁( ▁i ▁) ▁- ▁' ▁a ▁' ▁] ▁+= ▁1 ▁; ▁} ▁int ▁res ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁MAX _ CHAR ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁count 1 ▁[ ▁i ▁] ▁!= ▁0 ▁) ▁{ ▁res ▁+= ▁Math ▁. ▁abs ▁( ▁count 1 ▁[ ▁i ▁] ▁- ▁count 2 ▁[ ▁i ▁] ▁) ▁; ▁} ▁} ▁return ▁res ▁; ▁} ▁static ▁public ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁s 1 ▁= ▁" ▁abc ▁" ▁; ▁String ▁s 2 ▁= ▁" ▁c dd ▁" ▁; ▁int ▁len ▁= ▁s 1 ▁. ▁length ▁( ▁) ▁; ▁int ▁res ▁= ▁least Count ▁( ▁s 1 ▁, ▁s 2 ▁, ▁len ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁res ▁) ▁; ▁} ▁}
▁public ▁class ▁Long est _ common _ substr ▁{ ▁static ▁void ▁print LC Sub Str ▁( ▁String ▁X ▁, ▁String ▁Y ▁, ▁int ▁m ▁, ▁int ▁n ▁) ▁{ ▁int ▁[ ▁] ▁[ ▁] ▁L CS uff ▁= ▁new ▁int ▁[ ▁m ▁+ ▁1 ▁] ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁int ▁len ▁= ▁0 ▁; ▁int ▁row ▁= ▁0 ▁, ▁col ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁m ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁<= ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁i ▁== ▁0 ▁j ▁== ▁0 ▁) ▁L CS uff ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁0 ▁; ▁else ▁if ▁( ▁X ▁. ▁charAt ▁( ▁i ▁- ▁1 ▁) ▁== ▁Y ▁. ▁charAt ▁( ▁j ▁- ▁1 ▁) ▁) ▁{ ▁L CS uff ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁L CS uff ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁- ▁1 ▁] ▁+ ▁1 ▁; ▁if ▁( ▁len ▁< ▁L CS uff ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁{ ▁len ▁= ▁L CS uff ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁row ▁= ▁i ▁; ▁col ▁= ▁j ▁; ▁} ▁} ▁else ▁L CS uff ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁0 ▁; ▁} ▁} ▁if ▁( ▁len ▁== ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁Common ▁Sub string ▁" ▁) ▁; ▁return ▁; ▁} ▁String ▁result Str ▁= ▁" ▁" ▁; ▁while ▁( ▁L CS uff ▁[ ▁row ▁] ▁[ ▁col ▁] ▁!= ▁0 ▁) ▁{ ▁-- ▁len ▁; ▁row ▁-- ▁; ▁col ▁-- ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁result Str ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁String ▁X ▁= ▁" ▁Old Site ▁: ▁G eek s for G eek s ▁. ▁org ▁" ▁; ▁String ▁Y ▁= ▁" ▁New Site ▁: ▁G eek s Qu iz ▁. ▁com ▁" ▁; ▁int ▁m ▁= ▁X ▁. ▁length ▁( ▁) ▁; ▁int ▁n ▁= ▁Y ▁. ▁length ▁( ▁) ▁; ▁print LC Sub Str ▁( ▁X ▁, ▁Y ▁, ▁m ▁, ▁n ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁substring Con versions ▁( ▁String ▁str ▁, ▁int ▁k ▁, ▁int ▁b ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁+ ▁k ▁<= ▁str ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁String ▁sub ▁= ▁str ▁. ▁substring ▁( ▁i ▁, ▁i ▁+ ▁k ▁) ▁; ▁int ▁sum ▁= ▁0 ▁, ▁counter ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁sub ▁. ▁length ▁( ▁) ▁- ▁1 ▁; ▁j ▁>= ▁0 ▁; ▁j ▁-- ▁) ▁{ ▁sum ▁= ▁( ▁int ▁) ▁( ▁sum ▁+ ▁( ▁( ▁sub ▁. ▁charAt ▁( ▁j ▁) ▁- ▁'0' ▁) ▁* ▁Math ▁. ▁pow ▁( ▁b ▁, ▁counter ▁) ▁) ▁) ▁; ▁counter ▁++ ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁sum ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁"12 2 12" ▁; ▁int ▁b ▁= ▁3 ▁, ▁k ▁= ▁3 ▁; ▁substring Con versions ▁( ▁str ▁, ▁b ▁, ▁k ▁) ▁; ▁} ▁}
▁public ▁class ▁G F G ▁{ ▁static ▁final ▁int ▁MAX _ CHAR ▁= ▁26 ▁; ▁static ▁boolean ▁check Correct Or Not ▁( ▁String ▁s ▁) ▁{ ▁int ▁[ ▁] ▁count 1 ▁= ▁new ▁int ▁[ ▁MAX _ CHAR ▁] ▁; ▁int ▁[ ▁] ▁count 2 ▁= ▁new ▁int ▁[ ▁MAX _ CHAR ▁] ▁; ▁int ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁if ▁( ▁n ▁== ▁1 ▁) ▁return ▁true ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁, ▁j ▁= ▁n ▁- ▁1 ▁; ▁i ▁< ▁j ▁; ▁i ▁++ ▁, ▁j ▁-- ▁) ▁{ ▁count 1 ▁[ ▁s ▁. ▁charAt ▁( ▁i ▁) ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁count 2 ▁[ ▁s ▁. ▁charAt ▁( ▁j ▁) ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁MAX _ CHAR ▁; ▁i ▁++ ▁) ▁if ▁( ▁count 1 ▁[ ▁i ▁] ▁!= ▁count 2 ▁[ ▁i ▁] ▁) ▁return ▁false ▁; ▁return ▁true ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁String ▁s ▁= ▁" ▁ab ab ▁" ▁; ▁if ▁( ▁check Correct Or Not ▁( ▁s ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁remainder With 7 ▁( ▁String ▁num ▁) ▁{ ▁int ▁series ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁2 ▁, ▁- ▁1 ▁, ▁- ▁3 ▁, ▁- ▁2 ▁} ▁; ▁int ▁series _ index ▁= ▁0 ▁; ▁int ▁result ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁num ▁. ▁length ▁( ▁) ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁int ▁digit ▁= ▁num ▁. ▁charAt ▁( ▁i ▁) ▁- ▁'0' ▁; ▁result ▁+= ▁digit ▁* ▁series ▁[ ▁series _ index ▁] ▁; ▁series _ index ▁= ▁( ▁series _ index ▁+ ▁1 ▁) ▁% ▁6 ▁; ▁result ▁% = ▁7 ▁; ▁} ▁if ▁( ▁result ▁< ▁0 ▁) ▁result ▁= ▁( ▁result ▁+ ▁7 ▁) ▁% ▁7 ▁; ▁return ▁result ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁"1234 5" ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Rem ainder ▁with ▁7 ▁is ▁" ▁+ ▁remainder With 7 ▁( ▁str ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁G F G ▁{ ▁static ▁int ▁CHAR S ▁= ▁26 ▁; ▁static ▁boolean ▁isValid String ▁( ▁String ▁str ▁) ▁{ ▁int ▁freq ▁[ ▁] ▁= ▁new ▁int ▁[ ▁CHAR S ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁str ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁freq ▁[ ▁str ▁. ▁charAt ▁( ▁i ▁) ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁} ▁int ▁i ▁, ▁freq 1 ▁= ▁0 ▁, ▁count _ freq 1 ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁CHAR S ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁freq ▁[ ▁i ▁] ▁!= ▁0 ▁) ▁{ ▁freq 1 ▁= ▁freq ▁[ ▁i ▁] ▁; ▁count _ freq 1 ▁= ▁1 ▁; ▁break ▁; ▁} ▁} ▁int ▁j ▁, ▁freq 2 ▁= ▁0 ▁, ▁count _ freq 2 ▁= ▁0 ▁; ▁for ▁( ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁CHAR S ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁freq ▁[ ▁j ▁] ▁!= ▁0 ▁) ▁{ ▁if ▁( ▁freq ▁[ ▁j ▁] ▁== ▁freq 1 ▁) ▁{ ▁count _ freq 1 ▁++ ▁; ▁} ▁else ▁{ ▁count _ freq 2 ▁= ▁1 ▁; ▁freq 2 ▁= ▁freq ▁[ ▁j ▁] ▁; ▁break ▁; ▁} ▁} ▁} ▁for ▁( ▁int ▁k ▁= ▁j ▁+ ▁1 ▁; ▁k ▁< ▁CHAR S ▁; ▁k ▁++ ▁) ▁{ ▁if ▁( ▁freq ▁[ ▁k ▁] ▁!= ▁0 ▁) ▁{ ▁if ▁( ▁freq ▁[ ▁k ▁] ▁== ▁freq 1 ▁) ▁{ ▁count _ freq 1 ▁++ ▁; ▁} ▁if ▁( ▁freq ▁[ ▁k ▁] ▁== ▁freq 2 ▁) ▁{ ▁count _ freq 2 ▁++ ▁; ▁{ ▁return ▁false ▁; ▁} ▁} ▁if ▁( ▁count _ freq 1 ▁> ▁1 ▁&& ▁count _ freq 2 ▁> ▁1 ▁) ▁{ ▁return ▁false ▁; ▁} ▁} ▁return ▁true ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁" ▁abc bc ▁" ▁; ▁if ▁( ▁isValid String ▁( ▁str ▁) ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁YES ▁" ▁) ▁; ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁NO ▁" ▁) ▁; ▁} ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁is Re vers ible ▁( ▁String ▁str ▁) ▁{ ▁int ▁i ▁= ▁0 ▁, ▁j ▁= ▁str ▁. ▁length ▁( ▁) ▁- ▁1 ▁; ▁while ▁( ▁i ▁< ▁j ▁) ▁{ ▁if ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁!= ▁str ▁. ▁charAt ▁( ▁j ▁) ▁) ▁return ▁false ▁; ▁i ▁++ ▁; ▁j ▁-- ▁; ▁} ▁return ▁true ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁" ▁ab a ▁" ▁; ▁if ▁( ▁is Re vers ible ▁( ▁str ▁) ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁YES ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁NO ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁String ▁encode String ▁( ▁String ▁str ▁) ▁{ ▁HashMap ▁< ▁Character ▁, ▁Integer ▁> ▁map ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁String ▁res ▁= ▁" ▁" ▁; ▁int ▁i ▁= ▁0 ▁; ▁char ▁ch ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁str ▁. ▁length ▁( ▁) ▁; ▁j ▁++ ▁) ▁{ ▁ch ▁= ▁str ▁. ▁charAt ▁( ▁j ▁) ▁; ▁if ▁( ▁! ▁map ▁. ▁containsKey ▁( ▁ch ▁) ▁) ▁map ▁. ▁put ▁( ▁ch ▁, ▁i ▁++ ▁) ▁; ▁res ▁+= ▁map ▁. ▁get ▁( ▁ch ▁) ▁; ▁} ▁return ▁res ▁; ▁} ▁static ▁void ▁find Matched Words ▁( ▁String ▁[ ▁] ▁dict ▁, ▁String ▁pattern ▁) ▁{ ▁int ▁len ▁= ▁pattern ▁. ▁length ▁( ▁) ▁; ▁String ▁hash ▁= ▁encode String ▁( ▁pattern ▁) ▁; ▁for ▁( ▁String ▁word ▁: ▁dict ▁) ▁{ ▁if ▁( ▁word ▁. ▁length ▁( ▁) ▁== ▁len ▁&& ▁encode String ▁( ▁word ▁) ▁. ▁equals ▁( ▁hash ▁) ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁word ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁String ▁[ ▁] ▁dict ▁= ▁{ ▁" ▁ab b ▁" ▁, ▁" ▁abc ▁" ▁, ▁" ▁xyz ▁" ▁, ▁" ▁x yy ▁" ▁} ▁; ▁String ▁pattern ▁= ▁" ▁foo ▁" ▁; ▁find Matched Words ▁( ▁dict ▁, ▁pattern ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁check ▁( ▁String ▁pattern ▁, ▁String ▁word ▁) ▁{ ▁if ▁( ▁pattern ▁. ▁length ▁( ▁) ▁!= ▁word ▁. ▁length ▁( ▁) ▁) ▁return ▁false ▁; ▁int ▁[ ▁] ▁ch ▁= ▁new ▁int ▁[ ▁128 ▁] ▁; ▁int ▁Len ▁= ▁word ▁. ▁length ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁Len ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁ch ▁[ ▁( ▁int ▁) ▁pattern ▁. ▁charAt ▁( ▁i ▁) ▁] ▁== ▁0 ▁) ▁{ ▁ch ▁[ ▁( ▁int ▁) ▁pattern ▁. ▁charAt ▁( ▁i ▁) ▁] ▁= ▁word ▁. ▁charAt ▁( ▁i ▁) ▁; ▁} ▁else ▁if ▁( ▁ch ▁[ ▁( ▁int ▁) ▁pattern ▁. ▁charAt ▁( ▁i ▁) ▁] ▁!= ▁word ▁. ▁charAt ▁( ▁i ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁} ▁return ▁true ▁; ▁} ▁static ▁void ▁find Matched Words ▁( ▁HashSet ▁< ▁String ▁> ▁dict ▁, ▁String ▁pattern ▁) ▁{ ▁int ▁Len ▁= ▁pattern ▁. ▁length ▁( ▁) ▁; ▁String ▁result ▁= ▁" ▁" ▁; ▁for ▁( ▁String ▁word ▁: ▁dict ▁) ▁{ ▁if ▁( ▁check ▁( ▁pattern ▁, ▁word ▁) ▁) ▁{ ▁result ▁= ▁word ▁+ ▁" ▁" ▁+ ▁result ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁result ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁HashSet ▁< ▁String ▁> ▁dict ▁= ▁new ▁HashSet ▁< ▁String ▁> ▁( ▁) ▁; ▁dict ▁. ▁add ▁( ▁" ▁ab b ▁" ▁) ▁; ▁dict ▁. ▁add ▁( ▁" ▁abc ▁" ▁) ▁; ▁dict ▁. ▁add ▁( ▁" ▁xyz ▁" ▁) ▁; ▁dict ▁. ▁add ▁( ▁" ▁x yy ▁" ▁) ▁; ▁String ▁pattern ▁= ▁" ▁foo ▁" ▁; ▁find Matched Words ▁( ▁dict ▁, ▁pattern ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁String ▁int To R oman ▁( ▁int ▁num ▁) ▁{ ▁String ▁m ▁[ ▁] ▁= ▁{ ▁" ▁" ▁, ▁" ▁M ▁" ▁, ▁" ▁MM ▁" ▁, ▁" ▁M MM ▁" ▁} ▁; ▁String ▁c ▁[ ▁] ▁= ▁{ ▁" ▁" ▁, ▁" ▁C ▁" ▁, ▁" ▁CC ▁" ▁, ▁" ▁C CC ▁" ▁, ▁" ▁CD ▁" ▁, ▁" ▁D ▁" ▁, ▁" ▁DC ▁" ▁, ▁" ▁D CC ▁" ▁, ▁" ▁D CC C ▁" ▁, ▁" ▁CM ▁" ▁} ▁; ▁String ▁x ▁[ ▁] ▁= ▁{ ▁" ▁" ▁, ▁" ▁X ▁" ▁, ▁" ▁XX ▁" ▁, ▁" ▁XXX ▁" ▁, ▁" ▁X L ▁" ▁, ▁" ▁L ▁" ▁, ▁" ▁L X ▁" ▁, ▁" ▁L XX ▁" ▁, ▁" ▁L XXX ▁" ▁, ▁" ▁X C ▁" ▁} ▁; ▁String ▁i ▁[ ▁] ▁= ▁{ ▁" ▁" ▁, ▁" ▁I ▁" ▁, ▁" ▁II ▁" ▁, ▁" ▁I II ▁" ▁, ▁" ▁IV ▁" ▁, ▁" ▁V ▁" ▁, ▁" ▁VI ▁" ▁, ▁" ▁VI I ▁" ▁, ▁" ▁VI II ▁" ▁, ▁" ▁I X ▁" ▁} ▁; ▁String ▁thousands ▁= ▁m ▁[ ▁num ▁/ ▁1000 ▁] ▁; ▁String ▁h under ed s ▁= ▁c ▁[ ▁( ▁num ▁% ▁1000 ▁) ▁/ ▁100 ▁] ▁; ▁String ▁t ens ▁= ▁x ▁[ ▁( ▁num ▁% ▁100 ▁) ▁/ ▁10 ▁] ▁; ▁String ▁ones ▁= ▁i ▁[ ▁num ▁% ▁10 ▁] ▁; ▁String ▁ans ▁= ▁thousands ▁+ ▁h under ed s ▁+ ▁t ens ▁+ ▁ones ▁; ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁number ▁= ▁35 49 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁int To R oman ▁( ▁number ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁class ▁Solution ▁{ ▁private ▁static ▁String ▁z ig Z ag Concat ▁( ▁String ▁s ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁<= ▁1 ▁) ▁{ ▁return ▁s ▁; ▁} ▁StringBuilder ▁result ▁= ▁new ▁StringBuilder ▁( ▁) ▁; ▁for ▁( ▁int ▁row Num ▁= ▁0 ▁; ▁row Num ▁< ▁n ▁; ▁row Num ▁++ ▁) ▁{ ▁int ▁i ▁= ▁row Num ▁; ▁boolean ▁up ▁= ▁true ▁; ▁while ▁( ▁i ▁< ▁s ▁. ▁length ▁( ▁) ▁) ▁{ ▁result ▁= ▁result ▁. ▁append ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁) ▁; ▁if ▁( ▁row Num ▁== ▁0 ▁row Num ▁== ▁n ▁- ▁1 ▁) ▁{ ▁i ▁+= ▁( ▁2 ▁* ▁n ▁- ▁2 ▁) ▁; ▁} ▁else ▁{ ▁if ▁( ▁up ▁) ▁{ ▁i ▁+= ▁( ▁2 ▁* ▁( ▁n ▁- ▁row Num ▁) ▁- ▁2 ▁) ▁; ▁} ▁else ▁{ ▁i ▁+= ▁row Num ▁* ▁2 ▁; ▁} ▁up ▁^= ▁true ▁; ▁} ▁} ▁} ▁return ▁result ▁. ▁toString ▁( ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁" ▁G EEK S FOR GE EK S ▁" ▁; ▁int ▁n ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁z ig Z ag Concat ▁( ▁str ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁maximum X OR ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁K ▁) ▁{ ▁K ▁++ ▁; ▁int ▁maxX or ▁= ▁Integer ▁. ▁MIN _ VALUE ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁( ▁1 ▁<< ▁n ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁Integer ▁. ▁bit Count ▁( ▁i ▁) ▁== ▁K ▁) ▁{ ▁int ▁cur _ xor ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁( ▁i ▁& ▁( ▁1 ▁<< ▁j ▁) ▁) ▁!= ▁0 ▁) ▁cur _ xor ▁= ▁cur _ xor ▁^ ▁arr ▁[ ▁j ▁] ▁; ▁} ▁maxX or ▁= ▁Math ▁. ▁max ▁( ▁maxX or ▁, ▁cur _ xor ▁) ▁; ▁} ▁} ▁return ▁maxX or ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁int ▁M ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁maximum X OR ▁( ▁arr ▁, ▁N ▁, ▁M ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁T ower Of H ano i ▁( ▁int ▁N ▁) ▁{ ▁for ▁( ▁int ▁x ▁= ▁1 ▁; ▁x ▁<= ▁Math ▁. ▁pow ▁( ▁2 ▁, ▁N ▁) ▁- ▁1 ▁; ▁x ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Move ▁from ▁R od ▁" ▁+ ▁( ▁( ▁x ▁& ▁x ▁- ▁1 ▁) ▁% ▁3 ▁+ ▁1 ▁) ▁+ ▁" ▁to ▁R od ▁" ▁+ ▁( ▁( ▁( ▁x ▁x ▁- ▁1 ▁) ▁+ ▁1 ▁) ▁% ▁3 ▁+ ▁1 ▁) ▁+ ▁" NEW _ LINE "); ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁3 ▁; ▁T ower Of H ano i ▁( ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁isValid ▁( ▁int ▁[ ▁] ▁[ ▁] ▁board ▁, ▁int ▁i ▁, ▁int ▁j ▁, ▁int ▁K ▁) ▁{ ▁if ▁( ▁board ▁[ ▁i ▁] ▁[ ▁j ▁] ▁<= ▁K ▁) ▁{ ▁return ▁true ▁; ▁} ▁return ▁false ▁; ▁} ▁static ▁boolean ▁find Path ▁( ▁int ▁[ ▁] ▁[ ▁] ▁board ▁, ▁int ▁X ▁, ▁int ▁Y ▁, ▁int ▁M ▁, ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁if ▁( ▁X ▁< ▁0 ▁X ▁== ▁M ▁Y ▁< ▁0 ▁Y ▁== ▁N ▁) ▁{ ▁return ▁true ▁; ▁} ▁if ▁( ▁isValid ▁( ▁board ▁, ▁X ▁, ▁Y ▁, ▁K ▁) ▁) ▁{ ▁int ▁board _ XY ▁= ▁board ▁[ ▁X ▁] ▁[ ▁Y ▁] ▁; ▁board ▁[ ▁X ▁] ▁[ ▁Y ▁] ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁if ▁( ▁find Path ▁( ▁board ▁, ▁X ▁+ ▁1 ▁, ▁Y ▁, ▁M ▁, ▁N ▁, ▁K ▁- ▁board _ XY ▁) ▁|| ▁find Path ▁( ▁board ▁, ▁X ▁- ▁1 ▁, ▁Y ▁, ▁M ▁, ▁N ▁, ▁K ▁- ▁board _ XY ▁) ▁|| ▁find Path ▁( ▁board ▁, ▁X ▁, ▁Y ▁+ ▁1 ▁, ▁M ▁, ▁N ▁, ▁K ▁- ▁board _ XY ▁) ▁|| ▁find Path ▁( ▁board ▁, ▁X ▁, ▁Y ▁- ▁1 ▁, ▁M ▁, ▁N ▁, ▁K ▁- ▁board _ XY ▁) ▁) ▁{ ▁return ▁true ▁; ▁} ▁board ▁[ ▁X ▁] ▁[ ▁Y ▁] ▁= ▁board _ XY ▁; ▁} ▁return ▁false ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁[ ▁] ▁grid ▁= ▁{ ▁{ ▁25 ▁, ▁5 ▁, ▁25 ▁, ▁25 ▁, ▁25 ▁, ▁25 ▁} ▁, ▁{ ▁25 ▁, ▁1 ▁, ▁1 ▁, ▁5 ▁, ▁12 ▁, ▁25 ▁} ▁, ▁{ ▁25 ▁, ▁1 ▁, ▁12 ▁, ▁0 ▁, ▁15 ▁, ▁25 ▁} ▁, ▁{ ▁22 ▁, ▁1 ▁, ▁11 ▁, ▁2 ▁, ▁19 ▁, ▁15 ▁} ▁, ▁{ ▁25 ▁, ▁2 ▁, ▁2 ▁, ▁1 ▁, ▁12 ▁, ▁15 ▁} ▁, ▁{ ▁25 ▁, ▁9 ▁, ▁10 ▁, ▁1 ▁, ▁11 ▁, ▁25 ▁} ▁, ▁{ ▁25 ▁, ▁25 ▁, ▁25 ▁, ▁25 ▁, ▁25 ▁, ▁25 ▁} ▁} ▁; ▁int ▁K ▁= ▁17 ▁; ▁int ▁M ▁= ▁grid ▁. ▁length ▁; ▁int ▁N ▁= ▁grid ▁[ ▁0 ▁] ▁. ▁length ▁; ▁int ▁X ▁= ▁2 ▁,
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁public ▁class ▁G F G ▁{ ▁static ▁void ▁solve ▁( ▁int ▁N ▁, ▁int ▁P 1 ▁, ▁int ▁P 2 ▁, ▁int ▁X ▁, ▁int ▁Move ▁, ▁boolean ▁Qu it P 1 ▁, ▁boolean ▁Qu it P 2 ▁) ▁{ ▁if ▁( ▁N ▁== ▁0 ▁|| ▁( ▁Qu it P 1 ▁&& ▁Qu it P 2 ▁) ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Number ▁of ▁p ens ▁remaining ▁" ▁+ ▁" ▁in ▁the ▁box ▁: ▁" ▁+ ▁N ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Number ▁of ▁p ens ▁collected ▁" ▁+ ▁" ▁by ▁P 1 ▁: ▁" ▁+ ▁P 1 ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Number ▁of ▁p ens ▁collected ▁" ▁+ ▁" ▁by ▁P 2 ▁: ▁" ▁+ ▁P 2 ▁) ▁; ▁return ▁; ▁} ▁if ▁( ▁Move ▁== ▁0 ▁&& ▁Qu it P 1 ▁== ▁false ▁) ▁{ ▁int ▁req _ P 1 ▁= ▁( ▁int ▁) ▁( ▁Math ▁. ▁pow ▁( ▁2 ▁, ▁X ▁) ▁) ▁; ▁if ▁( ▁req _ P 1 ▁<= ▁N ▁) ▁{ ▁P 1 ▁+= ▁req _ P 1 ▁; ▁N ▁-= ▁req _ P 1 ▁; ▁} ▁else ▁{ ▁Qu it P 1 ▁= ▁true ▁; ▁} ▁} ▁else ▁if ▁( ▁Move ▁== ▁1 ▁&& ▁Qu it P 2 ▁== ▁false ▁) ▁{ ▁int ▁req _ P 2 ▁= ▁( ▁int ▁) ▁( ▁Math ▁. ▁pow ▁( ▁3 ▁, ▁X ▁) ▁) ▁; ▁if ▁( ▁req _ P 2 ▁<= ▁N ▁) ▁{ ▁P 2 ▁+= ▁req _ P 2 ▁; ▁N ▁-= ▁req _ P 2 ▁; ▁} ▁else ▁{ ▁Qu it P 2 ▁= ▁true ▁; ▁} ▁} ▁X ▁++ ▁; ▁Move ▁= ▁( ▁( ▁Move ▁== ▁1 ▁) ▁? ▁0 ▁: ▁1 ▁) ▁; ▁solve ▁( ▁N ▁, ▁P 1 ▁, ▁P 2 ▁, ▁X ▁, ▁Move ▁, ▁Qu it P 1 ▁, ▁Qu it P 2 ▁) ▁; ▁} ▁static ▁void ▁P en Game ▁( ▁int ▁N ▁) ▁{ ▁int ▁P 1 ▁= ▁0 ▁; ▁int ▁P 2 ▁= ▁0 ▁; ▁int ▁X ▁= ▁0 ▁; ▁int ▁Move ▁= ▁0 ▁; ▁boolean ▁Qu it P 1 ▁= ▁false ▁; ▁boolean ▁Qu it P 2 ▁= ▁false ▁; ▁solve ▁( ▁N ▁, ▁P 1 ▁, ▁P 2 ▁, ▁X ▁, ▁Move ▁, ▁Qu it
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁can Place ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁p ▁, ▁int ▁sep ▁) ▁{ ▁int ▁pr ison ers _ pla ced ▁= ▁1 ▁; ▁int ▁last _ pr ison er _ pla ced ▁= ▁a ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁current _ cell ▁= ▁a ▁[ ▁i ▁] ▁; ▁if ▁( ▁current _ cell ▁- ▁last _ pr ison er _ pla ced ▁>= ▁sep ▁) ▁{ ▁pr ison ers _ pla ced ▁++ ▁; ▁last _ pr ison er _ pla ced ▁= ▁current _ cell ▁; ▁if ▁( ▁pr ison ers _ pla ced ▁== ▁p ▁) ▁{ ▁return ▁true ▁; ▁} ▁} ▁} ▁return ▁false ▁; ▁} ▁static ▁int ▁max Distance ▁( ▁int ▁cell ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁p ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁cell ▁) ▁; ▁int ▁start ▁= ▁0 ▁; ▁int ▁end ▁= ▁cell ▁[ ▁n ▁- ▁1 ▁] ▁- ▁cell ▁[ ▁0 ▁] ▁; ▁int ▁ans ▁= ▁0 ▁; ▁while ▁( ▁start ▁<= ▁end ▁) ▁{ ▁int ▁mid ▁= ▁start ▁+ ▁( ▁( ▁end ▁- ▁start ▁) ▁/ ▁2 ▁) ▁; ▁if ▁( ▁can Place ▁( ▁cell ▁, ▁n ▁, ▁p ▁, ▁mid ▁) ▁) ▁{ ▁ans ▁= ▁mid ▁; ▁start ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁else ▁{ ▁end ▁= ▁mid ▁- ▁1 ▁; ▁} ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁cell ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁8 ▁, ▁4 ▁, ▁9 ▁} ▁; ▁int ▁n ▁= ▁cell ▁. ▁length ▁; ▁int ▁p ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁max Distance ▁( ▁cell ▁, ▁n ▁, ▁p ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁max Len ▁= ▁30 ▁; ▁static ▁int ▁[ ▁] ▁seg ▁= ▁new ▁int ▁[ ▁3 ▁* ▁max Len ▁] ▁; ▁static ▁int ▁build ▁( ▁int ▁l ▁, ▁int ▁r ▁, ▁int ▁in ▁, ▁int ▁[ ▁] ▁arr ▁) ▁{ ▁if ▁( ▁l ▁== ▁r ▁) ▁return ▁seg ▁[ ▁in ▁] ▁= ▁arr ▁[ ▁l ▁] ▁; ▁int ▁mid ▁= ▁( ▁l ▁+ ▁r ▁) ▁/ ▁2 ▁; ▁return ▁seg ▁[ ▁in ▁] ▁= ▁__ g cd ▁( ▁build ▁( ▁l ▁, ▁mid ▁, ▁2 ▁* ▁in ▁+ ▁1 ▁, ▁arr ▁) ▁, ▁build ▁( ▁mid ▁+ ▁1 ▁, ▁r ▁, ▁2 ▁* ▁in ▁+ ▁2 ▁, ▁arr ▁) ▁) ▁; ▁} ▁static ▁int ▁query ▁( ▁int ▁l ▁, ▁int ▁r ▁, ▁int ▁l 1 ▁, ▁int ▁r 1 ▁, ▁int ▁in ▁) ▁{ ▁if ▁( ▁l 1 ▁<= ▁l ▁&& ▁r ▁<= ▁r 1 ▁) ▁return ▁seg ▁[ ▁in ▁] ▁; ▁if ▁( ▁l ▁> ▁r 1 ▁r ▁< ▁l 1 ▁) ▁return ▁0 ▁; ▁int ▁mid ▁= ▁( ▁l ▁+ ▁r ▁) ▁/ ▁2 ▁; ▁return ▁__ g cd ▁( ▁query ▁( ▁l ▁, ▁mid ▁, ▁l 1 ▁, ▁r 1 ▁, ▁2 ▁* ▁in ▁+ ▁1 ▁) ▁, ▁query ▁( ▁mid ▁+ ▁1 ▁, ▁r ▁, ▁l 1 ▁, ▁r 1 ▁, ▁2 ▁* ▁in ▁+ ▁2 ▁) ▁) ▁; ▁} ▁static ▁int ▁find Len ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁n ▁) ▁{ ▁build ▁( ▁0 ▁, ▁n ▁- ▁1 ▁, ▁0 ▁, ▁arr ▁) ▁; ▁int ▁i ▁= ▁0 ▁, ▁j ▁= ▁0 ▁; ▁int ▁ans ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁while ▁( ▁i ▁< ▁n ▁) ▁{ ▁while ▁( ▁j ▁< ▁n ▁&& ▁query ▁( ▁0 ▁, ▁n ▁- ▁1 ▁, ▁i ▁, ▁j ▁, ▁0 ▁) ▁!= ▁1 ▁) ▁j ▁++ ▁; ▁if ▁( ▁j ▁== ▁n ▁) ▁break ▁; ▁ans ▁= ▁Math ▁. ▁min ▁( ▁( ▁j ▁- ▁i ▁+ ▁1 ▁) ▁, ▁ans ▁) ▁; ▁i ▁++ ▁; ▁j ▁= ▁Math ▁. ▁max ▁( ▁j ▁, ▁i ▁) ▁; ▁} ▁if ▁( ▁ans ▁== ▁Integer ▁. ▁MAX _ VALUE ▁) ▁return ▁- ▁1 ▁; ▁else ▁return ▁ans ▁; ▁} ▁static ▁int ▁__ g cd ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁return ▁b ▁== ▁0 ▁? ▁a ▁: ▁__ g cd ▁( ▁b ▁, ▁a ▁% ▁b ▁) ▁; ▁} ▁public
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁find Area ▁( ▁double ▁a ▁, ▁double ▁b ▁, ▁double ▁c ▁) ▁{ ▁double ▁area ▁= ▁4 ▁* ▁3.14 159 26 53 ▁* ▁Math ▁. ▁pow ▁( ▁( ▁Math ▁. ▁pow ▁( ▁a ▁* ▁b ▁, ▁1.6 ▁) ▁+ ▁Math ▁. ▁pow ▁( ▁a ▁* ▁c ▁, ▁1.6 ▁) ▁+ ▁Math ▁. ▁pow ▁( ▁b ▁* ▁c ▁, ▁1.6 ▁) ▁) ▁/ ▁3 ▁, ▁1 ▁/ ▁1.6 ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁String ▁. ▁format ▁( ▁" ▁% ▁.2 f ▁" ▁, ▁area ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁double ▁A ▁= ▁11 ▁, ▁B ▁= ▁12 ▁, ▁C ▁= ▁13 ▁; ▁find Area ▁( ▁A ▁, ▁B ▁, ▁C ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁double ▁find Radius ▁( ▁double ▁r 1 ▁, ▁double ▁r 2 ▁, ▁double ▁r 3 ▁) ▁{ ▁double ▁r 4 ▁= ▁( ▁r 1 ▁* ▁r 2 ▁* ▁r 3 ▁) ▁/ ▁( ▁r 1 ▁* ▁r 2 ▁+ ▁r 2 ▁* ▁r 3 ▁+ ▁r 1 ▁* ▁r 3 ▁+ ▁2.0 ▁* ▁Math ▁. ▁sqrt ▁( ▁r 1 ▁* ▁r 2 ▁* ▁r 3 ▁* ▁( ▁r 1 ▁+ ▁r 2 ▁+ ▁r 3 ▁) ▁) ▁) ▁; ▁return ▁r 4 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁double ▁r 1 ▁= ▁1 ▁; ▁double ▁r 2 ▁= ▁1 ▁; ▁double ▁r 3 ▁= ▁1 ▁; ▁double ▁r 4 ▁= ▁find Radius ▁( ▁r 1 ▁, ▁r 2 ▁, ▁r 3 ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁The ▁radius ▁of ▁fourth ▁circle ▁: ▁" ▁+ ▁r 4 ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁int ▁minimum Rectangle Area ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁ans ▁; ▁Arrays ▁. ▁sort ▁( ▁A ▁) ▁; ▁ans ▁= ▁( ▁A ▁[ ▁N ▁- ▁1 ▁] ▁- ▁A ▁[ ▁0 ▁] ▁) ▁* ▁( ▁A ▁[ ▁2 ▁* ▁N ▁- ▁1 ▁] ▁- ▁A ▁[ ▁N ▁] ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁ans ▁= ▁Math ▁. ▁min ▁( ▁ans ▁, ▁( ▁A ▁[ ▁2 ▁* ▁N ▁- ▁1 ▁] ▁- ▁A ▁[ ▁0 ▁] ▁) ▁* ▁( ▁A ▁[ ▁i ▁+ ▁N ▁- ▁1 ▁] ▁- ▁A ▁[ ▁i ▁] ▁) ▁) ▁; ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁4 ▁, ▁1 ▁, ▁5 ▁, ▁3 ▁, ▁6 ▁, ▁7 ▁, ▁8 ▁} ▁; ▁int ▁N ▁= ▁A ▁. ▁length ▁; ▁N ▁= ▁( ▁int ▁) ▁N ▁/ ▁2 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁minimum Rectangle Area ▁( ▁A ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁double ▁e cc Hyper b ola ▁( ▁double ▁A ▁, ▁double ▁B ▁) ▁{ ▁double ▁r ▁= ▁( ▁double ▁) ▁B ▁* ▁B ▁/ ▁A ▁* ▁A ▁; ▁r ▁+= ▁1 ▁; ▁return ▁Math ▁. ▁sqrt ▁( ▁r ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁double ▁A ▁= ▁3.0 ▁, ▁B ▁= ▁2.0 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁e cc Hyper b ola ▁( ▁A ▁, ▁B ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁float ▁calculate Area ▁( ▁float ▁A ▁, ▁float ▁B ▁, ▁float ▁C ▁, ▁float ▁D ▁) ▁{ ▁float ▁S ▁= ▁( ▁A ▁+ ▁B ▁+ ▁C ▁+ ▁D ▁) ▁/ ▁2 ▁; ▁float ▁area ▁= ▁( ▁float ▁) ▁Math ▁. ▁sqrt ▁( ▁( ▁S ▁- ▁A ▁) ▁* ▁( ▁S ▁- ▁B ▁) ▁* ▁( ▁S ▁- ▁C ▁) ▁* ▁( ▁S ▁- ▁D ▁) ▁) ▁; ▁return ▁area ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁float ▁A ▁= ▁10 ▁; ▁float ▁B ▁= ▁15 ▁; ▁float ▁C ▁= ▁20 ▁; ▁float ▁D ▁= ▁25 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁calculate Area ▁( ▁A ▁, ▁B ▁, ▁C ▁, ▁D ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁total C ir cles ▁( ▁int ▁L ▁, ▁int ▁B ▁) ▁{ ▁if ▁( ▁L ▁> ▁B ▁) ▁{ ▁int ▁temp ▁= ▁L ▁; ▁L ▁= ▁B ▁; ▁B ▁= ▁temp ▁; ▁} ▁return ▁B ▁/ ▁L ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁L ▁= ▁3 ▁; ▁int ▁B ▁= ▁8 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁total C ir cles ▁( ▁L ▁, ▁B ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁double ▁find Radius ▁( ▁double ▁r 1 ▁, ▁double ▁r 2 ▁) ▁{ ▁double ▁a 1 ▁, ▁a 2 ▁, ▁a 3 ▁, ▁r 3 ▁; ▁a 1 ▁= ▁3.14 ▁* ▁r 1 ▁* ▁r 1 ▁; ▁a 2 ▁= ▁3.14 ▁* ▁r 2 ▁* ▁r 2 ▁; ▁a 3 ▁= ▁a 1 ▁+ ▁a 2 ▁; ▁r 3 ▁= ▁Math ▁. ▁sqrt ▁( ▁a 3 ▁/ ▁3.14 ▁) ▁; ▁return ▁r 3 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁double ▁r 1 ▁= ▁8 ▁, ▁r 2 ▁= ▁6 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁( ▁int ▁) ▁find Radius ▁( ▁r 1 ▁, ▁r 2 ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁find _ l cm ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁int ▁c ▁) ▁{ ▁int ▁g ▁= ▁__ g cd ▁( ▁a ▁, ▁b ▁) ▁; ▁int ▁L CM 1 ▁= ▁( ▁a ▁* ▁b ▁) ▁/ ▁g ▁; ▁g ▁= ▁__ g cd ▁( ▁L CM 1 ▁, ▁c ▁) ▁; ▁int ▁L CM ▁= ▁( ▁L CM 1 ▁* ▁c ▁) ▁/ ▁g ▁; ▁return ▁L CM ▁; ▁} ▁static ▁void ▁minimum C ub oid s ▁( ▁int ▁L ▁, ▁int ▁B ▁, ▁int ▁H ▁) ▁{ ▁int ▁l cm ▁= ▁find _ l cm ▁( ▁L ▁, ▁B ▁, ▁H ▁) ▁; ▁int ▁volume _ cube ▁= ▁l cm ▁* ▁l cm ▁* ▁l cm ▁; ▁int ▁volume _ c ub oid ▁= ▁L ▁* ▁B ▁* ▁H ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁( ▁volume _ cube ▁/ ▁volume _ c ub oid ▁) ▁) ▁; ▁} ▁static ▁int ▁__ g cd ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁return ▁b ▁== ▁0 ▁? ▁a ▁: ▁__ g cd ▁( ▁b ▁, ▁a ▁% ▁b ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁L ▁= ▁1 ▁, ▁B ▁= ▁1 ▁, ▁H ▁= ▁2 ▁; ▁minimum C ub oid s ▁( ▁L ▁, ▁B ▁, ▁H ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁Cross Product ▁( ▁int ▁A ▁[ ▁] ▁[ ▁] ▁) ▁{ ▁int ▁X 1 ▁= ▁( ▁A ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁- ▁A ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁) ▁; ▁int ▁Y 1 ▁= ▁( ▁A ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁- ▁A ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁) ▁; ▁int ▁X 2 ▁= ▁( ▁A ▁[ ▁2 ▁] ▁[ ▁0 ▁] ▁- ▁A ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁) ▁; ▁int ▁Y 2 ▁= ▁( ▁A ▁[ ▁2 ▁] ▁[ ▁1 ▁] ▁- ▁A ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁) ▁; ▁return ▁( ▁X 1 ▁* ▁Y 2 ▁- ▁Y 1 ▁* ▁X 2 ▁) ▁; ▁} ▁static ▁boolean ▁is Conv ex ▁( ▁int ▁points ▁[ ▁] ▁[ ▁] ▁) ▁{ ▁int ▁N ▁= ▁points ▁. ▁length ▁; ▁int ▁prev ▁= ▁0 ▁; ▁int ▁curr ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁int ▁temp ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁points ▁[ ▁i ▁] ▁, ▁points ▁[ ▁( ▁i ▁+ ▁1 ▁) ▁% ▁N ▁] ▁, ▁points ▁[ ▁( ▁i ▁+ ▁2 ▁) ▁% ▁N ▁] ▁} ▁; ▁curr ▁= ▁Cross Product ▁( ▁temp ▁) ▁; ▁if ▁( ▁curr ▁!= ▁0 ▁) ▁{ ▁if ▁( ▁curr ▁* ▁prev ▁< ▁0 ▁) ▁{ ▁return ▁false ▁; ▁} ▁else ▁{ ▁prev ▁= ▁curr ▁; ▁} ▁} ▁} ▁return ▁true ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁points ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁0 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁0 ▁} ▁} ▁; ▁if ▁( ▁is Conv ex ▁( ▁points ▁) ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁double ▁distance ▁( ▁int ▁r ▁, ▁int ▁R ▁) ▁{ ▁double ▁d ▁= ▁Math ▁. ▁sqrt ▁( ▁Math ▁. ▁pow ▁( ▁R ▁, ▁2 ▁) ▁- ▁( ▁2 ▁* ▁r ▁* ▁R ▁) ▁) ▁; ▁return ▁d ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁r ▁= ▁2 ▁; ▁int ▁R ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁Math ▁. ▁round ▁( ▁distance ▁( ▁r ▁, ▁R ▁) ▁* ▁100.0 ▁) ▁/ ▁100.0 ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁double ▁min An gl Rot ▁( ▁int ▁N ▁) ▁{ ▁double ▁res ▁; ▁res ▁= ▁360 ▁/ ▁( ▁double ▁) ▁N ▁; ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁4 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁An gle ▁of ▁Rot ational ▁Sym m etry ▁: ▁" ▁+ ▁min An gl Rot ▁( ▁N ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁double ▁Area _ of _ Triangle ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁int ▁c ▁) ▁{ ▁int ▁s ▁= ▁( ▁a ▁+ ▁b ▁+ ▁c ▁) ▁/ ▁2 ▁; ▁int ▁x ▁= ▁s ▁* ▁( ▁s ▁- ▁a ▁) ▁; ▁x ▁= ▁x ▁* ▁( ▁s ▁- ▁b ▁) ▁; ▁x ▁= ▁x ▁* ▁( ▁s ▁- ▁c ▁) ▁; ▁double ▁area ▁= ▁( ▁4 ▁/ ▁( ▁double ▁) ▁3 ▁) ▁* ▁Math ▁. ▁sqrt ▁( ▁x ▁) ▁; ▁return ▁area ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁= ▁9 ▁; ▁int ▁b ▁= ▁12 ▁; ▁int ▁c ▁= ▁15 ▁; ▁double ▁ans ▁= ▁Area _ of _ Triangle ▁( ▁a ▁, ▁b ▁, ▁c ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁ans ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁boolean ▁is T rid ec agon ▁( ▁int ▁N ▁) ▁{ ▁float ▁n ▁= ▁( ▁float ▁) ▁( ▁( ▁9 ▁+ ▁Math ▁. ▁sqrt ▁( ▁88 ▁* ▁N ▁+ ▁81 ▁) ▁) ▁/ ▁22 ▁) ▁; ▁return ▁( ▁n ▁- ▁( ▁int ▁) ▁n ▁) ▁== ▁0 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁i ▁= ▁13 ▁; ▁if ▁( ▁is T rid ec agon ▁( ▁i ▁) ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Yes ▁" ▁) ▁; ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁boolean ▁check Overlap ▁( ▁int ▁R ▁, ▁int ▁X c ▁, ▁int ▁Y c ▁, ▁int ▁X 1 ▁, ▁int ▁Y 1 ▁, ▁int ▁X 2 ▁, ▁int ▁Y 2 ▁) ▁{ ▁int ▁X n ▁= ▁Math ▁. ▁max ▁( ▁X 1 ▁, ▁Math ▁. ▁min ▁( ▁X c ▁, ▁X 2 ▁) ▁) ▁; ▁int ▁Y n ▁= ▁Math ▁. ▁max ▁( ▁Y 1 ▁, ▁Math ▁. ▁min ▁( ▁Y c ▁, ▁Y 2 ▁) ▁) ▁; ▁int ▁D x ▁= ▁X n ▁- ▁X c ▁; ▁int ▁D y ▁= ▁Y n ▁- ▁Y c ▁; ▁return ▁( ▁D x ▁* ▁D x ▁+ ▁D y ▁* ▁D y ▁) ▁<= ▁R ▁* ▁R ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁R ▁= ▁1 ▁; ▁int ▁X c ▁= ▁0 ▁, ▁Y c ▁= ▁0 ▁; ▁int ▁X 1 ▁= ▁1 ▁, ▁Y 1 ▁= ▁- ▁1 ▁; ▁int ▁X 2 ▁= ▁3 ▁, ▁Y 2 ▁= ▁1 ▁; ▁if ▁( ▁check Overlap ▁( ▁R ▁, ▁X c ▁, ▁Y c ▁, ▁X 1 ▁, ▁Y 1 ▁, ▁X 2 ▁, ▁Y 2 ▁) ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁True ▁" ▁+ ▁" NEW _ LINE "); ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁False ▁" ▁) ▁; ▁} ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁class ▁pair ▁{ ▁int ▁first ▁, ▁second ▁; ▁public ▁pair ▁( ▁int ▁first ▁, ▁int ▁second ▁) ▁{ ▁this ▁. ▁first ▁= ▁first ▁; ▁this ▁. ▁second ▁= ▁second ▁; ▁} ▁} ▁static ▁int ▁check Intersection ▁( ▁pair ▁p 1 ▁, ▁pair ▁p 2 ▁, ▁pair ▁p ▁) ▁{ ▁int ▁val ▁; ▁if ▁( ▁p 1 ▁. ▁second ▁== ▁p 2 ▁. ▁second ▁&& ▁p 1 ▁. ▁second ▁== ▁p ▁. ▁second ▁) ▁{ ▁if ▁( ▁p ▁. ▁first ▁<= ▁Math ▁. ▁max ▁( ▁p 1 ▁. ▁first ▁, ▁p 2 ▁. ▁first ▁) ▁&& ▁( ▁p ▁. ▁first ▁>= ▁Math ▁. ▁min ▁( ▁p 1 ▁. ▁first ▁, ▁p 2 ▁. ▁first ▁) ▁) ▁) ▁return ▁1 ▁; ▁} ▁if ▁( ▁p 1 ▁. ▁first ▁== ▁p 2 ▁. ▁first ▁&& ▁p 1 ▁. ▁first ▁== ▁p ▁. ▁first ▁) ▁{ ▁if ▁( ▁p ▁. ▁second ▁<= ▁Math ▁. ▁max ▁( ▁p 1 ▁. ▁second ▁, ▁p 2 ▁. ▁second ▁) ▁&& ▁( ▁p ▁. ▁second ▁>= ▁Math ▁. ▁min ▁( ▁p 1 ▁. ▁second ▁, ▁p 2 ▁. ▁second ▁) ▁) ▁) ▁return ▁1 ▁; ▁} ▁else ▁{ ▁val ▁= ▁( ▁p ▁. ▁second ▁- ▁p 1 ▁. ▁second ▁) ▁* ▁( ▁p 2 ▁. ▁first ▁- ▁p 1 ▁. ▁first ▁) ▁- ▁( ▁p ▁. ▁first ▁- ▁p 1 ▁. ▁first ▁) ▁* ▁( ▁p 2 ▁. ▁second ▁- ▁p 1 ▁. ▁second ▁) ▁; ▁if ▁( ▁val ▁== ▁0 ▁) ▁if ▁( ▁( ▁p ▁. ▁first ▁<= ▁Math ▁. ▁max ▁( ▁p 1 ▁. ▁first ▁, ▁p 2 ▁. ▁first ▁) ▁&& ▁( ▁p ▁. ▁first ▁>= ▁Math ▁. ▁min ▁( ▁p 1 ▁. ▁first ▁, ▁p 2 ▁. ▁first ▁) ▁) ▁) ▁&& ▁( ▁p ▁. ▁second ▁<= ▁Math ▁. ▁max ▁( ▁p 1 ▁. ▁second ▁, ▁p 2 ▁. ▁second ▁) ▁&& ▁( ▁p ▁. ▁second ▁>= ▁Math ▁. ▁min ▁( ▁p 1 ▁. ▁second ▁, ▁p 2 ▁. ▁second ▁) ▁) ▁) ▁) ▁return ▁1 ▁; ▁} ▁return ▁0 ▁; ▁} ▁static ▁void ▁tower Of S ight ▁( ▁pair ▁a ▁, ▁pair ▁b ▁, ▁pair ▁c ▁, ▁pair ▁d ▁) ▁{ ▁int ▁flag ▁= ▁0 ▁; ▁if ▁( ▁check Intersection ▁( ▁a ▁, ▁c ▁, ▁b ▁) ▁== ▁1 ▁) ▁flag ▁= ▁1 ▁; ▁else ▁if ▁( ▁check Intersection ▁( ▁a ▁, ▁c ▁, ▁d ▁) ▁==
▁class ▁G F G ▁{ ▁static ▁double ▁area ▁( ▁int ▁R ▁) ▁{ ▁double ▁base ▁= ▁1.7 32 ▁* ▁R ▁; ▁double ▁height ▁= ▁( ▁1.5 ▁) ▁* ▁R ▁; ▁double ▁area ▁= ▁0.5 ▁* ▁base ▁* ▁height ▁; ▁return ▁area ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁R ▁= ▁7 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁area ▁( ▁R ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁count Pairs ▁( ▁int ▁[ ▁] ▁P ▁, ▁int ▁[ ▁] ▁Q ▁, ▁int ▁N ▁, ▁int ▁M ▁) ▁{ ▁int ▁[ ▁] ▁A ▁= ▁new ▁int ▁[ ▁2 ▁] ▁, ▁B ▁= ▁new ▁int ▁[ ▁2 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁A ▁[ ▁P ▁[ ▁i ▁] ▁% ▁2 ▁] ▁++ ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁M ▁; ▁i ▁++ ▁) ▁B ▁[ ▁Q ▁[ ▁i ▁] ▁% ▁2 ▁] ▁++ ▁; ▁return ▁( ▁A ▁[ ▁0 ▁] ▁* ▁B ▁[ ▁0 ▁] ▁+ ▁A ▁[ ▁1 ▁] ▁* ▁B ▁[ ▁1 ▁] ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁P ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁2 ▁} ▁; ▁int ▁[ ▁] ▁Q ▁= ▁{ ▁3 ▁, ▁0 ▁} ▁; ▁int ▁N ▁= ▁P ▁. ▁length ▁; ▁int ▁M ▁= ▁Q ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁count Pairs ▁( ▁P ▁, ▁Q ▁, ▁N ▁, ▁M ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁new _ vol ▁( ▁double ▁x ▁) ▁{ ▁if ▁( ▁x ▁> ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁% ▁change ▁in ▁the ▁" ▁+ ▁" ▁volume ▁of ▁the ▁h em is phere ▁: ▁" ▁+ ▁( ▁Math ▁. ▁pow ▁( ▁x ▁, ▁3 ▁) ▁/ ▁10000 ▁+ ▁3 ▁* ▁x ▁+ ▁( ▁3 ▁* ▁Math ▁. ▁pow ▁( ▁x ▁, ▁2 ▁) ▁) ▁/ ▁100 ▁) ▁+ ▁" ▁% ▁" ▁+ ▁" ▁increase NEW _ LINE "); ▁} ▁else ▁if ▁( ▁x ▁< ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁% ▁change ▁in ▁the ▁" ▁+ ▁" ▁volume ▁of ▁the ▁h em is phere ▁: ▁" ▁+ ▁( ▁Math ▁. ▁pow ▁( ▁x ▁, ▁3 ▁) ▁/ ▁10000 ▁+ ▁3 ▁* ▁x ▁+ ▁( ▁3 ▁* ▁Math ▁. ▁pow ▁( ▁x ▁, ▁2 ▁) ▁) ▁/ ▁100 ▁) ▁+ ▁"% ▁decrease NEW _ LINE "); ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Volume ▁remains ▁the ▁same ▁. ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁double ▁x ▁= ▁- ▁10.0 ▁; ▁new _ vol ▁( ▁x ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁count Inter sections ▁( ▁int ▁n ▁) ▁{ ▁return ▁n ▁* ▁( ▁n ▁- ▁1 ▁) ▁/ ▁2 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Inter sections ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁float ▁Area ▁( ▁int ▁d ▁, ▁int ▁h 1 ▁, ▁int ▁h 2 ▁) ▁{ ▁float ▁area ▁; ▁area ▁= ▁( ▁float ▁) ▁0.5 ▁* ▁d ▁* ▁( ▁h 1 ▁+ ▁h 2 ▁) ▁; ▁return ▁area ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁d ▁= ▁6 ▁, ▁h 1 ▁= ▁4 ▁, ▁h 2 ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Area ▁of ▁Quad r il ater al ▁= ▁" ▁+ ▁Area ▁( ▁d ▁, ▁h 1 ▁, ▁h 2 ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁angle ext cy c quad ▁( ▁int ▁z ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁The ▁ex ter ior ▁angle ▁of ▁the ▁" ▁+ ▁" ▁cyclic ▁quad r il ater al ▁is ▁" ▁+ ▁z ▁+ ▁" ▁degrees ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁z ▁= ▁48 ▁; ▁angle ext cy c quad ▁( ▁z ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁is Perf ect ▁( ▁int ▁N ▁) ▁{ ▁int ▁sum Of Div is ors ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁N ▁/ ▁2 ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁N ▁% ▁i ▁== ▁0 ▁) ▁{ ▁sum Of Div is ors ▁+= ▁i ▁; ▁} ▁} ▁if ▁( ▁sum Of Div is ors ▁== ▁N ▁) ▁{ ▁return ▁true ▁; ▁} ▁else ▁return ▁false ▁; ▁} ▁static ▁int ▁sum Of Digits ▁( ▁int ▁N ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁while ▁( ▁N ▁!= ▁0 ▁) ▁{ ▁sum ▁+= ▁( ▁N ▁% ▁10 ▁) ▁; ▁N ▁= ▁N ▁/ ▁10 ▁; ▁} ▁return ▁sum ▁; ▁} ▁static ▁void ▁count Perf ect Numbers ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁is Perf ect ▁( ▁arr ▁[ ▁i ▁] ▁) ▁) ▁{ ▁int ▁sum ▁= ▁sum Of Digits ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁if ▁( ▁is Perf ect ▁( ▁sum ▁) ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁8 ▁, ▁12 ▁, ▁28 ▁, ▁6 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁count Perf ect Numbers ▁( ▁arr ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁f izz B uzz ▁( ▁int ▁N ▁) ▁{ ▁int ▁count 3 ▁= ▁0 ▁; ▁int ▁count 5 ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁count 3 ▁++ ▁; ▁count 5 ▁++ ▁; ▁boolean ▁flag ▁= ▁false ▁; ▁if ▁( ▁count 3 ▁== ▁3 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁F izz ▁" ▁) ▁; ▁count 3 ▁= ▁0 ▁; ▁flag ▁= ▁true ▁; ▁} ▁if ▁( ▁count 5 ▁== ▁5 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁B uzz ▁" ▁) ▁; ▁count 5 ▁= ▁0 ▁; ▁flag ▁= ▁true ▁; ▁} ▁if ▁( ▁! ▁flag ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁i ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁15 ▁; ▁f izz B uzz ▁( ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁count Pairs ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁j ▁] ▁!= ▁0 ▁&& ▁a ▁[ ▁i ▁] ▁% ▁a ▁[ ▁j ▁] ▁== ▁0 ▁) ▁{ ▁if ▁( ▁( ▁a ▁[ ▁i ▁] ▁+ ▁a ▁[ ▁j ▁] ▁) ▁== ▁( ▁a ▁[ ▁i ▁] ▁/ ▁a ▁[ ▁j ▁] ▁) ▁) ▁count ▁++ ▁; ▁} ▁} ▁} ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁- ▁4 ▁, ▁- ▁3 ▁, ▁0 ▁, ▁2 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁count Pairs ▁( ▁arr ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁numberOf Tiles ▁( ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁if ▁( ▁n ▁% ▁2 ▁== ▁1 ▁) ▁{ ▁return ▁- ▁1 ▁; ▁} ▁return ▁( ▁m ▁* ▁n ▁) ▁/ ▁2 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁2 ▁, ▁m ▁= ▁4 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁numberOf Tiles ▁( ▁n ▁, ▁m ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁check Same Position ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁n ▁) ▁{ ▁Map ▁< ▁Integer ▁, ▁Integer ▁> ▁mp ▁= ▁new ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁temp ▁= ▁( ▁( ▁i ▁+ ▁arr ▁[ ▁i ▁] ▁) ▁% ▁n ▁+ ▁n ▁) ▁% ▁n ▁; ▁if ▁( ▁mp ▁. ▁get ▁( ▁temp ▁) ▁== ▁null ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁return ▁; ▁} ▁mp ▁. ▁get ▁( ▁temp ▁+ ▁1 ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁5 ▁, ▁4 ▁, ▁3 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁check Same Position ▁( ▁arr ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁convertTo ASCII ▁( ▁int ▁N ▁) ▁{ ▁String ▁num ▁= ▁Integer ▁. ▁toString ▁( ▁N ▁) ▁; ▁for ▁( ▁char ▁ch ▁: ▁num ▁. ▁toCharArray ▁( ▁) ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁ch ▁+ ▁" ▁( ▁" ▁+ ▁( ▁int ▁) ▁ch ▁+ ▁") NEW _ LINE "); ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁36 ▁; ▁convertTo ASCII ▁( ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁check Possible ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" No NEW _ LINE "); ▁return ▁; ▁} ▁else ▁{ ▁arr ▁[ ▁i ▁] ▁-= ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁; ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁= ▁0 ▁; ▁} ▁} ▁if ▁( ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁== ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" Yes NEW _ LINE "); ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" No NEW _ LINE "); ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁3 ▁, ▁4 ▁, ▁2 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁check Possible ▁( ▁arr ▁, ▁N ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁single Digit Sub array Count ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁res ▁= ▁0 ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁<= ▁9 ▁) ▁{ ▁count ▁++ ▁; ▁res ▁+= ▁count ▁; ▁} ▁else ▁{ ▁count ▁= ▁0 ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁res ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁1 ▁, ▁14 ▁, ▁2 ▁, ▁5 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁single Digit Sub array Count ▁( ▁arr ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁Fact ▁( ▁int ▁N ▁) ▁{ ▁int ▁result ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁result ▁= ▁( ▁result ▁* ▁i ▁) ▁; ▁} ▁return ▁result ▁; ▁} ▁static ▁void ▁numberOf W ays ▁( ▁int ▁M ▁, ▁int ▁[ ▁] ▁arr ▁, ▁int ▁N ▁) ▁{ ▁int ▁[ ▁] ▁B ▁= ▁new ▁int ▁[ ▁M ▁] ▁; ▁int ▁[ ▁] ▁counter ▁= ▁new ▁int ▁[ ▁M ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁!= ▁0 ▁) ▁{ ▁if ▁( ▁B ▁[ ▁i ▁% ▁M ▁] ▁== ▁0 ▁) ▁{ ▁B ▁[ ▁i ▁% ▁M ▁] ▁= ▁arr ▁[ ▁i ▁] ▁; ▁counter ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁++ ▁; ▁if ▁( ▁counter ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁> ▁1 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁0 ▁) ▁; ▁return ▁; ▁} ▁} ▁else ▁if ▁( ▁B ▁[ ▁i ▁% ▁M ▁] ▁!= ▁arr ▁[ ▁i ▁] ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁0 ▁) ▁; ▁return ▁; ▁} ▁} ▁} ▁int ▁cnt ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁M ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁B ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁cnt ▁++ ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁Fact ▁( ▁cnt ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁M ▁= ▁4 ▁; ▁int ▁[ ▁] ▁arr ▁= ▁new ▁int ▁[ ▁] ▁{ ▁1 ▁, ▁0 ▁, ▁3 ▁, ▁0 ▁, ▁0 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁numberOf W ays ▁( ▁M ▁, ▁arr ▁, ▁N ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁no Of Arrays Possible ▁( ▁int ▁N ▁, ▁int ▁M ▁) ▁{ ▁int ▁ans ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁++ ▁i ▁) ▁{ ▁ans ▁= ▁ans ▁* ▁( ▁M ▁- ▁i ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁ans ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁2 ▁, ▁M ▁= ▁3 ▁; ▁no Of Arrays Possible ▁( ▁N ▁, ▁M ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁Minimum Operation Req ▁( ▁int ▁N ▁) ▁{ ▁int ▁cnt Dec r ▁= ▁0 ▁; ▁int ▁temp ▁= ▁N ▁; ▁while ▁( ▁temp ▁> ▁0 ▁) ▁{ ▁int ▁X ▁= ▁( ▁int ▁) ▁Math ▁. ▁sqrt ▁( ▁temp ▁) ▁; ▁if ▁( ▁X ▁* ▁X ▁== ▁temp ▁) ▁{ ▁break ▁; ▁} ▁temp ▁= ▁temp ▁- ▁2 ▁; ▁cnt Dec r ▁+= ▁1 ▁; ▁} ▁int ▁cnt In cr ▁= ▁0 ▁; ▁while ▁( ▁true ▁) ▁{ ▁int ▁X ▁= ▁( ▁int ▁) ▁Math ▁. ▁sqrt ▁( ▁N ▁) ▁; ▁if ▁( ▁X ▁* ▁X ▁== ▁N ▁) ▁{ ▁break ▁; ▁} ▁N ▁= ▁N ▁+ ▁2 ▁; ▁cnt In cr ▁+= ▁1 ▁; ▁} ▁return ▁Math ▁. ▁min ▁( ▁cnt In cr ▁, ▁cnt Dec r ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁N ▁= ▁15 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁Minimum Operation Req ▁( ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁max Disconnected ▁( ▁int ▁N ▁, ▁int ▁E ▁) ▁{ ▁int ▁curr ▁= ▁1 ▁; ▁int ▁rem ▁= ▁E ▁; ▁while ▁( ▁rem ▁> ▁0 ▁) ▁{ ▁rem ▁= ▁rem ▁- ▁Math ▁. ▁min ▁( ▁curr ▁, ▁rem ▁) ▁; ▁curr ▁++ ▁; ▁} ▁if ▁( ▁curr ▁> ▁1 ▁) ▁{ ▁return ▁N ▁- ▁curr ▁; ▁} ▁else ▁{ ▁return ▁N ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁5 ▁, ▁E ▁= ▁1 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁max Disconnected ▁( ▁N ▁, ▁E ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁is Prime ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁<= ▁1 ▁) ▁return ▁false ▁; ▁if ▁( ▁n ▁<= ▁3 ▁) ▁return ▁true ▁; ▁if ▁( ▁n ▁% ▁2 ▁== ▁0 ▁n ▁% ▁3 ▁== ▁0 ▁) ▁return ▁false ▁; ▁for ▁( ▁int ▁i ▁= ▁5 ▁; ▁i ▁* ▁i ▁<= ▁n ▁; ▁i ▁= ▁i ▁+ ▁6 ▁) ▁if ▁( ▁n ▁% ▁i ▁== ▁0 ▁|| ▁n ▁% ▁( ▁i ▁+ ▁2 ▁) ▁== ▁0 ▁) ▁return ▁false ▁; ▁return ▁true ▁; ▁} ▁static ▁String ▁delete I th ▁( ▁String ▁str ▁, ▁int ▁i ▁) ▁{ ▁str ▁= ▁str ▁. ▁substring ▁( ▁0 ▁, ▁i ▁) ▁+ ▁str ▁. ▁substring ▁( ▁i ▁+ ▁1 ▁) ▁; ▁return ▁str ▁; ▁} ▁static ▁boolean ▁is Prime Possible ▁( ▁int ▁N ▁) ▁{ ▁String ▁s ▁= ▁String ▁. ▁valueOf ▁( ▁N ▁) ▁; ▁int ▁l ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁if ▁( ▁l ▁< ▁2 ▁) ▁return ▁false ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁l ▁; ▁i ▁++ ▁) ▁{ ▁String ▁str ▁= ▁delete I th ▁( ▁s ▁, ▁i ▁) ▁; ▁int ▁num ▁= ▁Integer ▁. ▁valueOf ▁( ▁str ▁) ▁; ▁if ▁( ▁is Prime ▁( ▁num ▁) ▁) ▁return ▁true ▁; ▁} ▁return ▁false ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁6 10 ▁; ▁if ▁( ▁is Prime Possible ▁( ▁N ▁) ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁Find _ min ▁( ▁HashSet ▁< ▁Integer ▁> ▁diff _ mod ▁, ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁count _ mod ▁, ▁int ▁k ▁) ▁{ ▁int ▁min _ op rn ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁int ▁op rn ▁= ▁0 ▁; ▁for ▁( ▁int ▁x ▁= ▁0 ▁; ▁x ▁< ▁k ▁; ▁x ▁++ ▁) ▁{ ▁op rn ▁= ▁0 ▁; ▁for ▁( ▁int ▁w ▁: ▁diff _ mod ▁) ▁{ ▁if ▁( ▁w ▁!= ▁x ▁) ▁{ ▁if ▁( ▁w ▁== ▁0 ▁) ▁{ ▁op rn ▁+= ▁Math ▁. ▁min ▁( ▁x ▁, ▁k ▁- ▁x ▁) ▁* ▁count _ mod ▁. ▁get ▁( ▁w ▁) ▁; ▁} ▁else ▁{ ▁op rn ▁+= ▁Math ▁. ▁min ▁( ▁Math ▁. ▁abs ▁( ▁x ▁- ▁w ▁) ▁, ▁k ▁+ ▁x ▁- ▁w ▁) ▁* ▁count _ mod ▁. ▁get ▁( ▁w ▁) ▁; ▁} ▁} ▁} ▁if ▁( ▁op rn ▁< ▁min _ op rn ▁) ▁min _ op rn ▁= ▁op rn ▁; ▁} ▁return ▁min _ op rn ▁; ▁} ▁static ▁int ▁Cal _ min ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁HashSet ▁< ▁Integer ▁> ▁diff _ mod ▁= ▁new ▁HashSet ▁< ▁> ▁( ▁) ▁; ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁count _ mod ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁diff _ mod ▁. ▁add ▁( ▁arr ▁[ ▁i ▁] ▁% ▁k ▁) ▁; ▁count _ mod ▁. ▁put ▁( ▁arr ▁[ ▁i ▁] ▁% ▁k ▁, ▁count _ mod ▁. ▁getOr Default ▁( ▁arr ▁[ ▁i ▁] ▁% ▁k ▁, ▁0 ▁) ▁+ ▁1 ▁) ▁; ▁} ▁return ▁Find _ min ▁( ▁diff _ mod ▁, ▁count _ mod ▁, ▁k ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁35 ▁, ▁48 ▁, ▁23 ▁, ▁52 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁int ▁k ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁Cal _ min ▁( ▁arr ▁, ▁n ▁, ▁k ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁inverse Equal ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁[ ▁] ▁br r ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁present _ index ▁= ▁arr ▁[ ▁i ▁] ▁- ▁1 ▁; ▁br r ▁[ ▁present _ index ▁] ▁= ▁i ▁+ ▁1 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁!= ▁br r ▁[ ▁i ▁] ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁return ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁4 ▁; ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁1 ▁, ▁4 ▁, ▁3 ▁, ▁2 ▁} ▁; ▁inverse Equal ▁( ▁arr ▁, ▁n ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁public ▁static ▁int ▁Square Root ▁( ▁int ▁num ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁n ▁= ▁1 ▁; ▁n ▁<= ▁num ▁; ▁n ▁+= ▁2 ▁) ▁{ ▁num ▁= ▁num ▁- ▁n ▁; ▁count ▁+= ▁1 ▁; ▁if ▁( ▁num ▁== ▁0 ▁) ▁break ▁; ▁} ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁81 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁Square Root ▁( ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁void ▁find W inner ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁cnt ▁= ▁0 ▁; ▁if ▁( ▁n ▁== ▁1 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁else ▁if ▁( ▁( ▁n ▁& ▁1 ▁) ▁!= ▁0 ▁n ▁== ▁2 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁{ ▁int ▁tmp ▁= ▁n ▁; ▁int ▁val ▁= ▁1 ▁; ▁while ▁( ▁tmp ▁> ▁k ▁&& ▁tmp ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁tmp ▁/= ▁2 ▁; ▁val ▁*= ▁2 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁3 ▁; ▁i ▁<= ▁Math ▁. ▁sqrt ▁( ▁tmp ▁) ▁; ▁i ▁++ ▁) ▁{ ▁while ▁( ▁tmp ▁% ▁i ▁== ▁0 ▁) ▁{ ▁cnt ▁++ ▁; ▁tmp ▁/= ▁i ▁; ▁} ▁} ▁if ▁( ▁tmp ▁> ▁1 ▁) ▁cnt ▁++ ▁; ▁if ▁( ▁val ▁== ▁n ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁else ▁if ▁( ▁n ▁/ ▁tmp ▁== ▁2 ▁&& ▁cnt ▁== ▁1 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁1 ▁, ▁k ▁= ▁1 ▁; ▁find W inner ▁( ▁n ▁, ▁k ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁count _ c ra zy _ pr imes ▁( ▁int ▁L ▁, ▁int ▁R ▁) ▁{ ▁int ▁prime ▁[ ▁] ▁= ▁new ▁int ▁[ ▁R ▁+ ▁1 ▁] ▁; ▁int ▁count Prime ▁[ ▁] ▁= ▁new ▁int ▁[ ▁R ▁+ ▁1 ▁] ▁; ▁int ▁freq Prime ▁[ ▁] ▁= ▁new ▁int ▁[ ▁R ▁+ ▁1 ▁] ▁; ▁prime ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁prime ▁[ ▁1 ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁* ▁p ▁<= ▁R ▁; ▁p ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁p ▁] ▁== ▁0 ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁p ▁* ▁p ▁; ▁i ▁<= ▁R ▁; ▁i ▁+= ▁p ▁) ▁prime ▁[ ▁i ▁] ▁= ▁1 ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁R ▁; ▁i ▁++ ▁) ▁{ ▁count Prime ▁[ ▁i ▁] ▁= ▁count Prime ▁[ ▁i ▁- ▁1 ▁] ▁; ▁if ▁( ▁prime ▁[ ▁i ▁] ▁!= ▁0 ▁) ▁{ ▁count Prime ▁[ ▁i ▁] ▁++ ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁R ▁; ▁i ▁++ ▁) ▁{ ▁freq Prime ▁[ ▁i ▁] ▁= ▁freq Prime ▁[ ▁i ▁- ▁1 ▁] ▁; ▁if ▁( ▁prime ▁[ ▁count Prime ▁[ ▁i ▁] ▁] ▁!= ▁0 ▁) ▁{ ▁freq Prime ▁[ ▁i ▁] ▁++ ▁; ▁} ▁} ▁return ▁( ▁freq Prime ▁[ ▁R ▁] ▁- ▁freq Prime ▁[ ▁L ▁- ▁1 ▁] ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁L ▁= ▁4 ▁, ▁R ▁= ▁12 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count _ c ra zy _ pr imes ▁( ▁L ▁, ▁R ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁compute ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁Map ▁< ▁Long ▁, ▁Long ▁> ▁eq Val ▁= ▁new ▁HashMap ▁< ▁Long ▁, ▁Long ▁> ▁( ▁) ▁; ▁long ▁maxX ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁long ▁val ▁= ▁a ▁[ ▁i ▁] ▁% ▁K ▁; ▁val ▁= ▁( ▁val ▁== ▁0 ▁? ▁0 ▁: ▁K ▁- ▁val ▁) ▁; ▁if ▁( ▁val ▁== ▁0 ▁) ▁continue ▁; ▁if ▁( ▁eq Val ▁. ▁containsKey ▁( ▁val ▁) ▁) ▁{ ▁long ▁num Val ▁= ▁eq Val ▁. ▁get ▁( ▁val ▁) ▁; ▁maxX ▁= ▁Math ▁. ▁max ▁( ▁maxX ▁, ▁val ▁+ ▁( ▁K ▁* ▁num Val ▁) ▁) ▁; ▁eq Val ▁. ▁put ▁( ▁val ▁, ▁eq Val ▁. ▁getOr Default ▁( ▁val ▁, ▁0 l ▁) ▁+ ▁1 l ▁) ▁; ▁} ▁else ▁{ ▁eq Val ▁. ▁put ▁( ▁val ▁, ▁1 l ▁) ▁; ▁maxX ▁= ▁Math ▁. ▁max ▁( ▁maxX ▁, ▁val ▁) ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁maxX ▁== ▁0 ▁? ▁0 ▁: ▁maxX ▁+ ▁1 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁K ▁= ▁3 ▁; ▁int ▁a ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁2 ▁, ▁18 ▁} ▁; ▁int ▁N ▁= ▁a ▁. ▁length ▁; ▁compute ▁( ▁a ▁, ▁N ▁, ▁K ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁getSum ▁( ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁while ▁( ▁n ▁!= ▁0 ▁) ▁{ ▁sum ▁= ▁sum ▁+ ▁n ▁% ▁10 ▁; ▁n ▁= ▁n ▁/ ▁10 ▁; ▁} ▁return ▁sum ▁; ▁} ▁static ▁boolean ▁is Self Num ▁( ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁m ▁= ▁1 ▁; ▁m ▁<= ▁n ▁; ▁m ▁++ ▁) ▁{ ▁if ▁( ▁m ▁+ ▁getSum ▁( ▁m ▁) ▁== ▁n ▁) ▁return ▁false ▁; ▁} ▁return ▁true ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁20 ▁; ▁if ▁( ▁is Self Num ▁( ▁n ▁) ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁series Sum Util ▁( ▁int ▁k ▁, ▁int ▁n ▁, ▁int ▁prev Sum ▁, ▁int ▁multi ▁, ▁int ▁add ▁) ▁{ ▁if ▁( ▁k ▁== ▁n ▁+ ▁1 ▁) ▁{ ▁return ▁prev Sum ▁; ▁} ▁multi ▁= ▁multi ▁* ▁k ▁; ▁add ▁= ▁add ▁+ ▁k ▁; ▁prev Sum ▁= ▁prev Sum ▁+ ▁multi ▁- ▁add ▁; ▁return ▁series Sum Util ▁( ▁k ▁+ ▁1 ▁, ▁n ▁, ▁prev Sum ▁, ▁multi ▁, ▁add ▁) ▁; ▁} ▁static ▁int ▁series Sum ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁1 ▁) ▁return ▁0 ▁; ▁int ▁prev Sum ▁= ▁0 ▁; ▁int ▁multi ▁= ▁1 ▁; ▁int ▁add ▁= ▁1 ▁; ▁return ▁series Sum Util ▁( ▁2 ▁, ▁n ▁, ▁prev Sum ▁, ▁multi ▁, ▁add ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁series Sum ▁( ▁N ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁getSum ▁( ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁while ▁( ▁n ▁!= ▁0 ▁) ▁{ ▁sum ▁= ▁sum ▁+ ▁n ▁% ▁10 ▁; ▁n ▁= ▁n ▁/ ▁10 ▁; ▁} ▁return ▁sum ▁; ▁} ▁static ▁void ▁smallest Number ▁( ▁int ▁N ▁) ▁{ ▁int ▁i ▁= ▁1 ▁; ▁while ▁( ▁1 ▁!= ▁0 ▁) ▁{ ▁if ▁( ▁getSum ▁( ▁i ▁) ▁== ▁N ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁i ▁) ▁; ▁break ▁; ▁} ▁i ▁++ ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁10 ▁; ▁smallest Number ▁( ▁N ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁boolean ▁is z yg od rome Num ▁( ▁int ▁N ▁) ▁{ ▁String ▁s ▁= ▁Integer ▁. ▁toString ▁( ▁N ▁) ▁; ▁s ▁= ▁' ▁' ▁+ ▁s ▁+ ▁' ▁' ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁s ▁. ▁length ▁( ▁) ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁!= ▁s ▁. ▁charAt ▁( ▁i ▁- ▁1 ▁) ▁&& ▁s ▁. ▁charAt ▁( ▁i ▁) ▁!= ▁s ▁. ▁charAt ▁( ▁i ▁+ ▁1 ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁} ▁return ▁true ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁112 2 ▁; ▁if ▁( ▁is z yg od rome Num ▁( ▁n ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁public ▁class ▁g eek s ▁{ ▁public ▁static ▁int ▁can Replace ▁( ▁int ▁[ ▁] ▁array ▁) ▁{ ▁int ▁i ▁= ▁0 ▁, ▁count ▁= ▁0 ▁; ▁while ▁( ▁i ▁< ▁array ▁. ▁length ▁) ▁{ ▁if ▁( ▁array ▁[ ▁i ▁] ▁== ▁0 ▁&& ▁( ▁i ▁== ▁0 ▁array ▁[ ▁i ▁- ▁1 ▁] ▁== ▁0 ▁) ▁&& ▁( ▁i ▁== ▁array ▁. ▁length ▁- ▁1 ▁array ▁[ ▁i ▁+ ▁1 ▁] ▁== ▁0 ▁) ▁) ▁{ ▁array ▁[ ▁i ▁] ▁= ▁1 ▁; ▁count ▁++ ▁; ▁} ▁i ▁++ ▁; ▁} ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁array ▁= ▁{ ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁} ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁can Replace ▁( ▁array ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁M eg agon Num ▁( ▁int ▁n ▁) ▁{ ▁return ▁( ▁9 9999 8 ▁* ▁n ▁* ▁n ▁- ▁9 9999 6 ▁* ▁n ▁) ▁/ ▁2 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁M eg agon Num ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁T et ra cont ao ct ag onal Num ▁( ▁int ▁n ▁) ▁{ ▁return ▁( ▁46 ▁* ▁n ▁* ▁n ▁- ▁44 ▁* ▁n ▁) ▁/ ▁2 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁T et ra cont ao ct ag onal Num ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁double ▁find Index ▁( ▁int ▁n ▁) ▁{ ▁double ▁x ▁= ▁Math ▁. ▁sqrt ▁( ▁2 ▁* ▁Math ▁. ▁pow ▁( ▁10 ▁, ▁( ▁n ▁- ▁1 ▁) ▁) ▁) ▁; ▁return ▁Math ▁. ▁round ▁( ▁x ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁find Index ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁smallest Number ▁( ▁int ▁N ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁N ▁* ▁Math ▁. ▁floor ▁( ▁( ▁Math ▁. ▁pow ▁( ▁10 ▁, ▁N ▁) ▁- ▁1 ▁) ▁/ ▁N ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁N ▁= ▁2 ▁; ▁smallest Number ▁( ▁N ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁ic os ik ai he pt ag onal Num ▁( ▁int ▁n ▁) ▁{ ▁return ▁( ▁25 ▁* ▁n ▁* ▁n ▁- ▁23 ▁* ▁n ▁) ▁/ ▁2 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁"3 rd ▁ic os ik ai he pt ag onal ▁Number ▁is ▁" ▁+ ▁ic os ik ai he pt ag onal Num ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁boolean ▁i stri a cont ag onal ▁( ▁int ▁N ▁) ▁{ ▁float ▁n ▁= ▁( ▁float ▁) ▁( ▁( ▁26 ▁+ ▁Math ▁. ▁sqrt ▁( ▁224 ▁* ▁N ▁+ ▁6 76 ▁) ▁) ▁/ ▁56 ▁) ▁; ▁return ▁( ▁n ▁- ▁( ▁int ▁) ▁n ▁) ▁== ▁0 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁30 ▁; ▁if ▁( ▁i stri a cont ag onal ▁( ▁N ▁) ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Yes ▁" ▁) ▁; ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁Max length ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁Vector ▁< ▁Integer ▁> ▁zero index ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁int ▁maxlen ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁0 ▁) ▁zero index ▁. ▁add ▁( ▁i ▁) ▁; ▁} ▁if ▁( ▁zero index ▁. ▁size ▁( ▁) ▁== ▁0 ▁) ▁{ ▁maxlen ▁= ▁N ▁; ▁} ▁else ▁{ ▁maxlen ▁= ▁( ▁int ▁) ▁zero index ▁. ▁get ▁( ▁0 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁zero index ▁. ▁size ▁( ▁) ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁int ▁) ▁zero index ▁. ▁get ▁( ▁i ▁+ ▁1 ▁) ▁- ▁( ▁int ▁) ▁zero index ▁. ▁get ▁( ▁i ▁) ▁- ▁1 ▁> ▁maxlen ▁) ▁{ ▁maxlen ▁= ▁( ▁int ▁) ▁zero index ▁. ▁get ▁( ▁i ▁+ ▁1 ▁) ▁- ▁( ▁int ▁) ▁zero index ▁. ▁get ▁( ▁i ▁) ▁- ▁1 ▁; ▁} ▁} ▁if ▁( ▁N ▁- ▁( ▁int ▁) ▁zero index ▁. ▁get ▁( ▁zero index ▁. ▁size ▁( ▁) ▁- ▁1 ▁) ▁- ▁1 ▁> ▁maxlen ▁) ▁{ ▁maxlen ▁= ▁N ▁- ▁( ▁int ▁) ▁zero index ▁. ▁get ▁( ▁zero index ▁. ▁size ▁( ▁) ▁- ▁1 ▁) ▁- ▁1 ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁maxlen ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁N ▁= ▁9 ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁7 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁2 ▁, ▁0 ▁, ▁9 ▁, ▁2 ▁, ▁1 ▁} ▁; ▁Max length ▁( ▁arr ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁solve ▁( ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁x ▁= ▁1 ▁; ▁x ▁<= ▁Math ▁. ▁sqrt ▁( ▁n ▁) ▁; ▁x ▁++ ▁) ▁{ ▁if ▁( ▁n ▁% ▁x ▁== ▁0 ▁) ▁{ ▁int ▁small ▁= ▁x ▁; ▁int ▁big ▁= ▁n ▁/ ▁x ▁; ▁if ▁( ▁small ▁% ▁2 ▁== ▁big ▁% ▁2 ▁) ▁{ ▁int ▁a ▁= ▁( ▁small ▁+ ▁big ▁) ▁/ ▁2 ▁; ▁int ▁b ▁= ▁( ▁big ▁- ▁small ▁) ▁/ ▁2 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁a ▁+ ▁" ▁" ▁+ ▁b ▁) ▁; ▁return ▁; ▁} ▁} ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁- ▁1 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁7 ▁; ▁solve ▁( ▁n ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁inv ▁( ▁int ▁a ▁, ▁int ▁m ▁) ▁{ ▁int ▁m 0 ▁= ▁m ▁, ▁t ▁, ▁q ▁; ▁int ▁x 0 ▁= ▁0 ▁, ▁x 1 ▁= ▁1 ▁; ▁if ▁( ▁m ▁== ▁1 ▁) ▁return ▁0 ▁; ▁while ▁( ▁a ▁> ▁1 ▁) ▁{ ▁q ▁= ▁a ▁/ ▁m ▁; ▁t ▁= ▁m ▁; ▁m ▁= ▁a ▁% ▁m ▁; ▁a ▁= ▁t ▁; ▁t ▁= ▁x 0 ▁; ▁x 0 ▁= ▁x 1 ▁- ▁q ▁* ▁x 0 ▁; ▁x 1 ▁= ▁t ▁; ▁} ▁if ▁( ▁x 1 ▁< ▁0 ▁) ▁x 1 ▁+= ▁m 0 ▁; ▁return ▁x 1 ▁; ▁} ▁static ▁int ▁derivative ▁( ▁int ▁x ▁) ▁{ ▁return ▁3 ▁* ▁x ▁* ▁x ▁; ▁} ▁static ▁int ▁Image ▁( ▁int ▁x ▁, ▁int ▁k ▁) ▁{ ▁return ▁x ▁* ▁x ▁* ▁x ▁- ▁k ▁; ▁} ▁static ▁int ▁next _ power ▁( ▁int ▁a _ t ▁, ▁int ▁t ▁, ▁int ▁a 1 ▁, ▁int ▁prime ▁, ▁int ▁k ▁) ▁{ ▁int ▁power _ p ▁= ▁( ▁int ▁) ▁Math ▁. ▁pow ▁( ▁prime ▁, ▁t ▁+ ▁1 ▁) ▁; ▁int ▁next _ a ▁= ▁( ▁a _ t ▁- ▁Image ▁( ▁a _ t ▁, ▁k ▁) ▁* ▁inv ▁( ▁derivative ▁( ▁a 1 ▁) ▁, ▁prime ▁) ▁) ▁% ▁power _ p ▁; ▁if ▁( ▁next _ a ▁< ▁0 ▁) ▁return ▁next _ a ▁+= ▁power _ p ▁; ▁return ▁next _ a ▁; ▁} ▁static ▁int ▁power Of Prime ▁( ▁int ▁prime ▁, ▁int ▁power ▁, ▁int ▁k ▁, ▁int ▁a 1 ▁) ▁{ ▁if ▁( ▁derivative ▁( ▁a 1 ▁) ▁!= ▁0 ▁) ▁{ ▁int ▁a _ t ▁= ▁a 1 ▁; ▁for ▁( ▁int ▁p ▁= ▁1 ▁; ▁p ▁< ▁power ▁; ▁p ▁++ ▁) ▁{ ▁a _ t ▁= ▁next _ power ▁( ▁a _ t ▁, ▁p ▁, ▁a 1 ▁, ▁prime ▁, ▁k ▁) ▁; ▁} ▁return ▁a _ t ▁; ▁} ▁return ▁- ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁prime ▁= ▁7 ▁, ▁a 1 ▁= ▁3 ▁; ▁int ▁power ▁= ▁2 ▁, ▁k ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁power Of Prime ▁( ▁prime ▁, ▁power ▁, ▁k ▁, ▁a 1 ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁final ▁int ▁mod ▁= ▁100 000000 7 ▁; ▁static ▁int ▁product Pairs ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁product ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁product ▁*= ▁( ▁arr ▁[ ▁i ▁] ▁% ▁mod ▁* ▁arr ▁[ ▁j ▁] ▁% ▁mod ▁) ▁% ▁mod ▁; ▁product ▁= ▁product ▁% ▁mod ▁; ▁} ▁} ▁return ▁product ▁% ▁mod ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁product Pairs ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁getMin Steps ▁( ▁int ▁n ▁, ▁int ▁jump ▁) ▁{ ▁int ▁quot ient ▁= ▁n ▁/ ▁jump ▁; ▁int ▁remainder ▁= ▁n ▁% ▁jump ▁; ▁int ▁steps ▁= ▁quot ient ▁+ ▁remainder ▁; ▁return ▁steps ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁6 ▁, ▁K ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁getMin Steps ▁( ▁N ▁, ▁K ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁boolean ▁is Center ed non ad ec ag onal ▁( ▁int ▁N ▁) ▁{ ▁float ▁n ▁= ▁( ▁float ▁) ▁( ▁( ▁19 ▁+ ▁Math ▁. ▁sqrt ▁( ▁15 2 ▁* ▁N ▁+ ▁20 9 ▁) ▁) ▁/ ▁38 ▁) ▁; ▁return ▁( ▁n ▁- ▁( ▁int ▁) ▁n ▁) ▁== ▁0 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁20 ▁; ▁if ▁( ▁is Center ed non ad ec ag onal ▁( ▁n ▁) ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Yes ▁" ▁) ▁; ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁} ▁}
▁public ▁class ▁Main ▁{ ▁public ▁static ▁void ▁cnt Array ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁result ▁= ▁0 ▁; ▁int ▁[ ▁] ▁frequency ▁= ▁new ▁int ▁[ ▁N ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁frequency ▁[ ▁A ▁[ ▁i ▁] ▁] ▁++ ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁int ▁frequency _ of _ i ▁= ▁frequency ▁[ ▁i ▁] ▁; ▁result ▁+= ▁( ▁( ▁frequency _ of _ i ▁) ▁* ▁( ▁frequency _ of _ i ▁+ ▁1 ▁) ▁) ▁/ ▁2 ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁result ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁A ▁= ▁{ ▁1 ▁, ▁5 ▁, ▁6 ▁, ▁1 ▁, ▁9 ▁, ▁5 ▁, ▁8 ▁, ▁10 ▁, ▁8 ▁, ▁9 ▁} ▁; ▁int ▁N ▁= ▁A ▁. ▁length ▁; ▁cnt Array ▁( ▁A ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁sub array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁ans ▁= ▁1 ▁, ▁temp ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁) ▁{ ▁++ ▁temp ▁; ▁} ▁else ▁{ ▁ans ▁= ▁Math ▁. ▁max ▁( ▁ans ▁, ▁temp ▁) ▁; ▁temp ▁= ▁1 ▁; ▁} ▁} ▁ans ▁= ▁Math ▁. ▁max ▁( ▁ans ▁, ▁temp ▁) ▁; ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁2 ▁, ▁1 ▁, ▁1 ▁, ▁2 ▁, ▁2 ▁, ▁2 ▁, ▁3 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁sub array ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁find Max Min Sub Array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁K ▁, ▁int ▁n ▁) ▁{ ▁int ▁min ▁= ▁n ▁; ▁int ▁max ▁= ▁0 ▁; ▁int ▁left ▁; ▁int ▁right ▁; ▁int ▁tmp ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁tmp ▁= ▁1 ▁; ▁left ▁= ▁i ▁; ▁while ▁( ▁left ▁- ▁1 ▁>= ▁0 ▁&& ▁Math ▁. ▁abs ▁( ▁arr ▁[ ▁left ▁] ▁- ▁arr ▁[ ▁left ▁- ▁1 ▁] ▁) ▁<= ▁K ▁) ▁{ ▁left ▁-- ▁; ▁tmp ▁++ ▁; ▁} ▁right ▁= ▁i ▁; ▁while ▁( ▁right ▁+ ▁1 ▁<= ▁n ▁- ▁1 ▁&& ▁Math ▁. ▁abs ▁( ▁arr ▁[ ▁right ▁] ▁- ▁arr ▁[ ▁right ▁+ ▁1 ▁] ▁) ▁<= ▁K ▁) ▁{ ▁right ▁++ ▁; ▁tmp ▁++ ▁; ▁} ▁if ▁( ▁min ▁> ▁tmp ▁) ▁min ▁= ▁tmp ▁; ▁if ▁( ▁max ▁< ▁tmp ▁) ▁max ▁= ▁tmp ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁min ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁, ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁max ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁5 ▁, ▁6 ▁, ▁7 ▁} ▁; ▁int ▁K ▁= ▁2 ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁find Max Min Sub Array ▁( ▁arr ▁, ▁K ▁, ▁n ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁minimum Steps ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁int ▁c ▁) ▁{ ▁if ▁( ▁a ▁< ▁1 ▁b ▁< ▁1 ▁) ▁return ▁- ▁1 ▁; ▁if ▁( ▁a ▁== ▁1 ▁&& ▁b ▁== ▁1 ▁) ▁return ▁c ▁; ▁if ▁( ▁a ▁< ▁b ▁) ▁{ ▁a ▁= ▁a ▁+ ▁b ▁; ▁b ▁= ▁a ▁- ▁b ▁; ▁a ▁= ▁a ▁- ▁b ▁; ▁} ▁return ▁minimum Steps ▁( ▁a ▁- ▁b ▁, ▁b ▁, ▁c ▁+ ▁1 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁= ▁75 ▁; ▁int ▁b ▁= ▁17 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁minimum Steps ▁( ▁a ▁, ▁b ▁, ▁0 ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁boolean ▁is Perf ect Square ▁( ▁double ▁x ▁) ▁{ ▁double ▁sr ▁= ▁Math ▁. ▁sqrt ▁( ▁x ▁) ▁; ▁return ▁( ▁( ▁sr ▁- ▁Math ▁. ▁floor ▁( ▁sr ▁) ▁) ▁== ▁0 ▁) ▁; ▁} ▁static ▁int ▁count Square s ▁( ▁int ▁n ▁) ▁{ ▁int ▁cnt ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁( ▁int ▁) ▁Math ▁. ▁pow ▁( ▁10 ▁, ▁( ▁n ▁- ▁1 ▁) ▁) ▁; ▁i ▁< ▁Math ▁. ▁pow ▁( ▁10 ▁, ▁n ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁!= ▁0 ▁&& ▁is Perf ect Square ▁( ▁i ▁) ▁) ▁cnt ▁++ ▁; ▁} ▁return ▁cnt ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁count Square s ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁print Arr ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁% ▁4 ▁== ▁0 ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁/ ▁2 ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁i ▁* ▁2 ▁+ ▁" ▁" ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁/ ▁2 ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁i ▁* ▁2 ▁- ▁1 ▁+ ▁" ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁n ▁+ ▁n ▁/ ▁2 ▁- ▁1 ▁) ▁; ▁} ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁- ▁1" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁22 ▁; ▁print Arr ▁( ▁n ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁Scanner ▁; ▁class ▁CG PA ▁{ ▁public ▁static ▁double ▁C g pa Calc ▁( ▁double ▁[ ▁] ▁marks ▁, ▁int ▁n ▁) ▁{ ▁double ▁grade ▁[ ▁] ▁= ▁new ▁double ▁[ ▁n ▁] ▁; ▁double ▁cg pa ▁, ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁grade ▁[ ▁i ▁] ▁= ▁( ▁marks ▁[ ▁i ▁] ▁/ ▁10 ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁grade ▁[ ▁i ▁] ▁; ▁} ▁cg pa ▁= ▁sum ▁/ ▁n ▁; ▁return ▁cg pa ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁5 ▁; ▁double ▁[ ▁] ▁marks ▁= ▁{ ▁90 ▁, ▁80 ▁, ▁70 ▁, ▁80 ▁, ▁90 ▁} ▁; ▁double ▁cg pa ▁= ▁C g pa Calc ▁( ▁marks ▁, ▁n ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁CG PA ▁= ▁" ▁+ ▁cg pa ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁CG PA ▁Percent age ▁= ▁" ▁+ ▁String ▁. ▁format ▁( ▁" ▁% ▁.2 f ▁" ▁, ▁cg pa ▁* ▁9. 5 ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁public ▁static ▁Boolean ▁check G olden Ratio ▁( ▁float ▁a ▁, ▁float ▁b ▁) ▁{ ▁if ▁( ▁a ▁<= ▁b ▁) ▁{ ▁float ▁temp ▁= ▁a ▁; ▁a ▁= ▁b ▁; ▁b ▁= ▁temp ▁; ▁} ▁String ▁ratio 1 ▁= ▁String ▁. ▁format ▁( ▁" ▁% ▁.3 f ▁" ▁, ▁a ▁/ ▁b ▁) ▁; ▁String ▁ratio 2 ▁= ▁String ▁. ▁format ▁( ▁" ▁% ▁.3 f ▁" ▁, ▁( ▁a ▁+ ▁b ▁) ▁/ ▁a ▁) ▁; ▁if ▁( ▁ratio 1 ▁. ▁equals ▁( ▁ratio 2 ▁) ▁&& ▁ratio 1 ▁. ▁equals ▁( ▁"1. 6 18 " ▁) ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁return ▁true ▁; ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁return ▁false ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁float ▁a ▁= ▁( ▁float ▁) ▁0.6 18 ▁; ▁float ▁b ▁= ▁1 ▁; ▁check G olden Ratio ▁( ▁a ▁, ▁b ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁min Num ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁x ▁= ▁( ▁int ▁) ▁( ▁Math ▁. ▁log ▁( ▁n ▁) ▁/ ▁Math ▁. ▁log ▁( ▁k ▁) ▁) ▁+ ▁1 ▁; ▁int ▁mn ▁= ▁( ▁int ▁) ▁( ▁Math ▁. ▁pow ▁( ▁k ▁, ▁x ▁) ▁- ▁n ▁) ▁; ▁return ▁mn ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁20 ▁, ▁k ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁min Num ▁( ▁n ▁, ▁k ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁class ▁pair ▁{ ▁int ▁first ▁, ▁second ▁; ▁public ▁pair ▁( ▁int ▁first ▁, ▁int ▁second ▁) ▁{ ▁this ▁. ▁first ▁= ▁first ▁; ▁this ▁. ▁second ▁= ▁second ▁; ▁} ▁} ▁static ▁int ▁C nt cont Sub s ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁prod ▁= ▁1 ▁; ▁Vector ▁< ▁pair ▁> ▁vect ▁= ▁new ▁Vector ▁< ▁pair ▁> ▁( ▁) ▁; ▁vect ▁. ▁add ▁( ▁new ▁pair ▁( ▁0 ▁, ▁2 ▁) ▁) ▁; ▁Vector ▁< ▁Integer ▁> ▁two ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁Vector ▁< ▁Integer ▁> ▁zero ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁a ▁[ ▁i ▁] ▁= ▁a ▁[ ▁i ▁] ▁% ▁4 ▁; ▁if ▁( ▁a ▁[ ▁i ▁] ▁< ▁0 ▁) ▁a ▁[ ▁i ▁] ▁= ▁a ▁[ ▁i ▁] ▁+ ▁4 ▁; ▁if ▁( ▁a ▁[ ▁i ▁] ▁== ▁2 ▁) ▁two ▁. ▁add ▁( ▁i ▁+ ▁1 ▁) ▁; ▁if ▁( ▁a ▁[ ▁i ▁] ▁== ▁0 ▁) ▁zero ▁. ▁add ▁( ▁i ▁+ ▁1 ▁) ▁; ▁if ▁( ▁a ▁[ ▁i ▁] ▁== ▁0 ▁a ▁[ ▁i ▁] ▁== ▁2 ▁) ▁vect ▁. ▁add ▁( ▁new ▁pair ▁( ▁i ▁+ ▁1 ▁, ▁a ▁[ ▁i ▁] ▁) ▁) ▁; ▁} ▁vect ▁. ▁add ▁( ▁new ▁pair ▁( ▁n ▁+ ▁1 ▁, ▁2 ▁) ▁) ▁; ▁int ▁total ▁= ▁( ▁n ▁* ▁( ▁n ▁+ ▁1 ▁) ▁) ▁/ ▁2 ▁; ▁if ▁( ▁two ▁. ▁isEmpty ▁( ▁) ▁) ▁return ▁total ▁; ▁else ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁int ▁pos 1 ▁= ▁- ▁1 ▁, ▁pos 2 ▁= ▁- ▁1 ▁, ▁pos 3 ▁= ▁- ▁1 ▁; ▁int ▁sz ▁= ▁vect ▁. ▁size ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁+ ▁1 ▁< ▁sz ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁vect ▁. ▁get ▁( ▁i ▁) ▁. ▁second ▁== ▁2 ▁) ▁{ ▁sum ▁+= ▁( ▁vect ▁. ▁get ▁( ▁i ▁) ▁. ▁first ▁- ▁vect ▁. ▁get ▁( ▁i ▁- ▁1 ▁) ▁. ▁first ▁) ▁* ▁( ▁vect ▁. ▁get ▁( ▁i ▁+ ▁1 ▁) ▁. ▁first ▁- ▁vect ▁. ▁get ▁( ▁i ▁) ▁. ▁first ▁) ▁- ▁1 ▁; ▁} ▁} ▁return ▁total ▁-
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁mod ▁= ▁100 000000 7 ▁; ▁static ▁int ▁count Sub sets ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁answer ▁= ▁0 ▁; ▁int ▁[ ▁] ▁power Of Two ▁= ▁new ▁int ▁[ ▁10000 5 ▁] ▁; ▁power Of Two ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁10000 5 ▁; ▁i ▁++ ▁) ▁power Of Two ▁[ ▁i ▁] ▁= ▁( ▁power Of Two ▁[ ▁i ▁- ▁1 ▁] ▁* ▁2 ▁) ▁% ▁mod ▁; ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁frequency ▁= ▁new ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁frequency ▁. ▁containsKey ▁( ▁a ▁[ ▁i ▁] ▁) ▁) ▁{ ▁frequency ▁. ▁put ▁( ▁a ▁[ ▁i ▁] ▁, ▁frequency ▁. ▁get ▁( ▁a ▁[ ▁i ▁] ▁) ▁+ ▁1 ▁) ▁; ▁} ▁else ▁{ ▁frequency ▁. ▁put ▁( ▁a ▁[ ▁i ▁] ▁, ▁1 ▁) ▁; ▁} ▁for ▁( ▁Map ▁. ▁Entry ▁< ▁Integer ▁, ▁Integer ▁> ▁el ▁: ▁frequency ▁. ▁entrySet ▁( ▁) ▁) ▁{ ▁if ▁( ▁el ▁. ▁getKey ▁( ▁) ▁!= ▁0 ▁) ▁answer ▁= ▁( ▁answer ▁% ▁mod ▁+ ▁power Of Two ▁[ ▁el ▁. ▁getValue ▁( ▁) ▁- ▁1 ▁] ▁) ▁% ▁mod ▁; ▁else ▁answer ▁= ▁( ▁answer ▁% ▁mod ▁+ ▁power Of Two ▁[ ▁el ▁. ▁getValue ▁( ▁) ▁] ▁- ▁1 ▁+ ▁mod ▁) ▁% ▁mod ▁; ▁} ▁return ▁answer ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁6 ▁; ▁int ▁A ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁2 ▁, ▁1 ▁, ▁2 ▁, ▁1 ▁} ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁count Sub sets ▁( ▁A ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁long ▁product ▁( ▁int ▁[ ▁] ▁[ ▁] ▁mat ▁, ▁int ▁n ▁) ▁{ ▁long ▁d 1 ▁= ▁0 ▁, ▁d 2 ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁d 1 ▁+= ▁mat ▁[ ▁i ▁] ▁[ ▁i ▁] ▁; ▁d 2 ▁+= ▁mat ▁[ ▁i ▁] ▁[ ▁n ▁- ▁i ▁- ▁1 ▁] ▁; ▁} ▁return ▁1 L ▁* ▁d 1 ▁* ▁d 2 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁[ ▁] ▁mat ▁= ▁{ ▁{ ▁5 ▁, ▁8 ▁, ▁1 ▁} ▁, ▁{ ▁5 ▁, ▁10 ▁, ▁3 ▁} ▁, ▁{ ▁- ▁6 ▁, ▁17 ▁, ▁- ▁9 ▁} ▁} ▁; ▁int ▁n ▁= ▁mat ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁product ▁( ▁mat ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁find Sum ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁n ▁, ▁int ▁left ▁, ▁int ▁right ▁) ▁{ ▁int ▁k ▁= ▁right ▁- ▁left ▁; ▁int ▁d ▁= ▁arr ▁[ ▁1 ▁] ▁- ▁arr ▁[ ▁0 ▁] ▁; ▁int ▁ans ▁= ▁arr ▁[ ▁left ▁- ▁1 ▁] ▁* ▁( ▁k ▁+ ▁1 ▁) ▁; ▁ans ▁= ▁ans ▁+ ▁( ▁d ▁* ▁( ▁k ▁* ▁( ▁k ▁+ ▁1 ▁) ▁) ▁) ▁/ ▁2 ▁; ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁4 ▁, ▁6 ▁, ▁8 ▁, ▁10 ▁, ▁12 ▁, ▁14 ▁, ▁16 ▁} ▁; ▁int ▁queries ▁= ▁3 ▁; ▁int ▁q ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁2 ▁, ▁4 ▁} ▁, ▁{ ▁2 ▁, ▁6 ▁} ▁, ▁{ ▁5 ▁, ▁6 ▁} ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁queries ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁find Sum ▁( ▁arr ▁, ▁n ▁, ▁q ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁, ▁q ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁) ▁+ ▁" NEW _ LINE "); ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁sub array Possible ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁if ▁( ▁sum ▁<= ▁0 ▁) ▁return ▁true ▁; ▁} ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁if ▁( ▁sum ▁<= ▁0 ▁) ▁return ▁true ▁; ▁} ▁return ▁false ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁5 ▁, ▁- ▁12 ▁, ▁7 ▁, ▁- ▁10 ▁, ▁20 ▁, ▁30 ▁, ▁- ▁10 ▁, ▁50 ▁, ▁60 ▁} ▁; ▁int ▁size ▁= ▁arr ▁. ▁length ▁; ▁if ▁( ▁sub array Possible ▁( ▁arr ▁, ▁size ▁) ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Yes ▁" ▁+ ▁" NEW _ LINE "); ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁No ▁" ▁+ ▁" NEW _ LINE "); ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁final ▁int ▁limit ▁= ▁10000 000 ▁; ▁static ▁int ▁[ ▁] ▁position ▁= ▁new ▁int ▁[ ▁limit ▁+ ▁1 ▁] ▁; ▁static ▁void ▁s ieve ▁( ▁) ▁{ ▁position ▁[ ▁0 ▁] ▁= ▁- ▁1 ▁; ▁position ▁[ ▁1 ▁] ▁= ▁- ▁1 ▁; ▁int ▁pos ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁limit ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁position ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁position ▁[ ▁i ▁] ▁= ▁++ ▁pos ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁* ▁2 ▁; ▁j ▁<= ▁limit ▁; ▁j ▁+= ▁i ▁) ▁position ▁[ ▁j ▁] ▁= ▁- ▁1 ▁; ▁} ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁s ieve ▁( ▁) ▁; ▁int ▁n ▁= ▁11 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁position ▁[ ▁n ▁] ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁double ▁max Sub Array Sum ▁( ▁double ▁a ▁[ ▁] ▁, ▁int ▁size ▁) ▁{ ▁double ▁max _ so _ far ▁= ▁Integer ▁. ▁MIN _ VALUE ▁, ▁max _ ending _ here ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁{ ▁max _ ending _ here ▁= ▁max _ ending _ here ▁+ ▁a ▁[ ▁i ▁] ▁; ▁if ▁( ▁max _ so _ far ▁< ▁max _ ending _ here ▁) ▁max _ so _ far ▁= ▁max _ ending _ here ▁; ▁if ▁( ▁max _ ending _ here ▁< ▁0 ▁) ▁max _ ending _ here ▁= ▁0 ▁; ▁} ▁return ▁max _ so _ far ▁; ▁} ▁static ▁void ▁min Possible Sum ▁( ▁double ▁a ▁[ ▁] ▁, ▁int ▁n ▁, ▁double ▁x ▁) ▁{ ▁double ▁mx Sum ▁= ▁max Sub Array Sum ▁( ▁a ▁, ▁n ▁) ▁; ▁double ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁a ▁[ ▁i ▁] ▁; ▁} ▁sum ▁= ▁sum ▁- ▁mx Sum ▁+ ▁mx Sum ▁/ ▁x ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁sum ▁+ ▁" NEW _ LINE "); ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁3 ▁; ▁double ▁X ▁= ▁2 ▁; ▁double ▁A ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁- ▁2 ▁, ▁3 ▁} ▁; ▁min Possible Sum ▁( ▁A ▁, ▁N ▁, ▁X ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁int ▁reverse ▁( ▁int ▁num ▁) ▁{ ▁int ▁rev _ num ▁= ▁0 ▁; ▁while ▁( ▁num ▁> ▁0 ▁) ▁{ ▁rev _ num ▁= ▁rev _ num ▁* ▁10 ▁+ ▁num ▁% ▁10 ▁; ▁num ▁= ▁num ▁/ ▁10 ▁; ▁} ▁return ▁rev _ num ▁; ▁} ▁public ▁static ▁int ▁count Reverse ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁freq ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁freq ▁. ▁containsKey ▁( ▁arr ▁[ ▁i ▁] ▁) ▁) ▁{ ▁freq ▁. ▁replace ▁( ▁arr ▁[ ▁i ▁] ▁, ▁freq ▁. ▁get ▁( ▁arr ▁[ ▁i ▁] ▁) ▁+ ▁1 ▁) ▁; ▁} ▁else ▁{ ▁freq ▁. ▁put ▁( ▁arr ▁[ ▁i ▁] ▁, ▁1 ▁) ▁; ▁} ▁} ▁int ▁res ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁freq ▁. ▁containsKey ▁( ▁arr ▁[ ▁i ▁] ▁) ▁) ▁{ ▁freq ▁. ▁replace ▁( ▁arr ▁[ ▁i ▁] ▁, ▁freq ▁. ▁get ▁( ▁arr ▁[ ▁i ▁] ▁) ▁- ▁1 ▁) ▁; ▁} ▁else ▁{ ▁freq ▁. ▁put ▁( ▁arr ▁[ ▁i ▁] ▁, ▁- ▁1 ▁) ▁; ▁} ▁if ▁( ▁freq ▁. ▁containsKey ▁( ▁reverse ▁( ▁arr ▁[ ▁i ▁] ▁) ▁) ▁) ▁{ ▁res ▁+= ▁freq ▁. ▁get ▁( ▁reverse ▁( ▁arr ▁[ ▁i ▁] ▁) ▁) ▁; ▁} ▁} ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁16 ▁, ▁61 ▁, ▁12 ▁, ▁21 ▁, ▁25 ▁} ▁; ▁int ▁n ▁= ▁a ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Reverse ▁( ▁a ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁isP ossible ▁( ▁int ▁[ ▁] ▁A ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁count Of Two ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁A ▁[ ▁i ▁] ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁count Of Two ▁++ ▁; ▁} ▁} ▁if ▁( ▁k ▁== ▁0 ▁&& ▁count Of Two ▁== ▁n ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁NO ▁" ▁) ▁; ▁else ▁if ▁( ▁count Of Two ▁>= ▁k ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁YES ▁" ▁) ▁; ▁} ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁K ▁= ▁2 ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁isP ossible ▁( ▁arr ▁, ▁n ▁, ▁K ▁) ▁; ▁} ▁}
▁public ▁class ▁G F G ▁{ ▁final ▁static ▁int ▁size ▁= ▁100 01 ▁; ▁static ▁int ▁prime ▁[ ▁] ▁= ▁new ▁int ▁[ ▁size ▁] ▁; ▁static ▁int ▁freq ▁[ ▁] ▁= ▁new ▁int ▁[ ▁size ▁] ▁; ▁static ▁void ▁s ieve ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁prime ▁[ ▁1 ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁* ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁* ▁2 ▁; ▁j ▁< ▁size ▁; ▁j ▁+= ▁i ▁) ▁prime ▁[ ▁j ▁] ▁= ▁1 ▁; ▁} ▁} ▁for ▁( ▁int ▁p ▁= ▁1 ▁; ▁p ▁< ▁size ▁; ▁p ▁++ ▁) ▁{ ▁for ▁( ▁int ▁q ▁= ▁1 ▁; ▁q ▁< ▁size ▁; ▁q ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁p ▁] ▁== ▁0 ▁&& ▁prime ▁[ ▁q ▁] ▁== ▁0 ▁&& ▁a ▁* ▁p ▁+ ▁b ▁* ▁q ▁< ▁size ▁) ▁{ ▁freq ▁[ ▁a ▁* ▁p ▁+ ▁b ▁* ▁q ▁] ▁++ ▁; ▁} ▁} ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁queries ▁= ▁2 ▁, ▁a ▁= ▁1 ▁, ▁b ▁= ▁2 ▁; ▁s ieve ▁( ▁a ▁, ▁b ▁) ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁15 ▁, ▁25 ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁queries ▁; ▁i ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁freq ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁print Mod ulus ▁( ▁int ▁X ▁, ▁int ▁Y ▁) ▁{ ▁int ▁n ▁= ▁Math ▁. ▁max ▁( ▁X ▁, ▁Y ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁X ▁% ▁i ▁== ▁Y ▁% ▁i ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁i ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁X ▁, ▁Y ▁; ▁X ▁= ▁10 ▁; ▁Y ▁= ▁20 ▁; ▁print Mod ulus ▁( ▁X ▁, ▁Y ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁String ▁check ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁n ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁arr ▁[ ▁i ▁] ▁& ▁1 ▁) ▁!= ▁0 ▁) ▁count ▁++ ▁; ▁} ▁if ▁( ▁( ▁count ▁& ▁1 ▁) ▁!= ▁0 ▁) ▁return ▁" ▁O dd ▁" ▁; ▁else ▁return ▁" ▁Even ▁" ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁3 ▁, ▁9 ▁, ▁12 ▁, ▁13 ▁, ▁15 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁check ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁is Div isible ▁( ▁int ▁n ▁) ▁{ ▁int ▁d ▁; ▁while ▁( ▁( ▁n ▁/ ▁100 ▁) ▁> ▁0 ▁) ▁{ ▁d ▁= ▁n ▁% ▁10 ▁; ▁n ▁/= ▁10 ▁; ▁n ▁= ▁Math ▁. ▁abs ▁( ▁n ▁- ▁( ▁d ▁* ▁14 ▁) ▁) ▁; ▁} ▁return ▁( ▁n ▁% ▁47 ▁== ▁0 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁59 17 3 ▁; ▁if ▁( ▁is Div isible ▁( ▁N ▁) ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁proper Div isor Sum ▁( ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁++ ▁i ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁* ▁j ▁<= ▁i ▁; ▁++ ▁j ▁) ▁{ ▁if ▁( ▁i ▁% ▁j ▁== ▁0 ▁) ▁{ ▁if ▁( ▁i ▁/ ▁j ▁== ▁j ▁) ▁sum ▁+= ▁j ▁; ▁else ▁sum ▁+= ▁j ▁+ ▁i ▁/ ▁j ▁; ▁} ▁} ▁sum ▁= ▁sum ▁- ▁i ▁; ▁} ▁return ▁sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁4 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁proper Div isor Sum ▁( ▁n ▁) ▁) ▁; ▁n ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁proper Div isor Sum ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁proper Div isor Sum ▁( ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁++ ▁i ▁) ▁sum ▁+= ▁( ▁n ▁/ ▁i ▁) ▁* ▁i ▁; ▁return ▁sum ▁- ▁n ▁* ▁( ▁n ▁+ ▁1 ▁) ▁/ ▁2 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁4 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁proper Div isor Sum ▁( ▁n ▁) ▁) ▁; ▁n ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁proper Div isor Sum ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁sz ▁= ▁( ▁int ▁) ▁1 e 5 ▁; ▁static ▁boolean ▁[ ▁] ▁is Prime ▁= ▁new ▁boolean ▁[ ▁sz ▁+ ▁1 ▁] ▁; ▁static ▁void ▁generate Prime ▁( ▁) ▁{ ▁int ▁i ▁, ▁j ▁; ▁for ▁( ▁i ▁= ▁2 ▁; ▁i ▁<= ▁sz ▁; ▁i ▁++ ▁) ▁is Prime ▁[ ▁i ▁] ▁= ▁true ▁; ▁for ▁( ▁i ▁= ▁2 ▁; ▁i ▁* ▁i ▁<= ▁sz ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁is Prime ▁[ ▁i ▁] ▁) ▁{ ▁for ▁( ▁j ▁= ▁i ▁* ▁i ▁; ▁j ▁< ▁sz ▁; ▁j ▁+= ▁i ▁) ▁{ ▁is Prime ▁[ ▁j ▁] ▁= ▁false ▁; ▁} ▁} ▁} ▁} ▁static ▁void ▁Pair _ of _ Prime X or ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁is Prime ▁[ ▁( ▁A ▁[ ▁i ▁] ▁^ ▁A ▁[ ▁j ▁] ▁) ▁] ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁( ▁" ▁+ ▁A ▁[ ▁i ▁] ▁+ ▁" ▁, ▁" ▁+ ▁A ▁[ ▁j ▁] ▁+ ▁" ▁) ▁" ▁) ▁; ▁} ▁} ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁6 ▁, ▁11 ▁} ▁; ▁int ▁n ▁= ▁A ▁. ▁length ▁; ▁generate Prime ▁( ▁) ▁; ▁Pair _ of _ Prime X or ▁( ▁A ▁, ▁n ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁boolean ▁is Prime ▁( ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁* ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁{ ▁return ▁false ▁; ▁} ▁} ▁return ▁true ▁; ▁} ▁static ▁void ▁print Min Count Prime ▁( ▁int ▁N ▁) ▁{ ▁int ▁min Count ▁; ▁if ▁( ▁is Prime ▁( ▁N ▁) ▁) ▁{ ▁min Count ▁= ▁1 ▁; ▁} ▁else ▁if ▁( ▁N ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁min Count ▁= ▁2 ▁; ▁} ▁else ▁{ ▁if ▁( ▁is Prime ▁( ▁N ▁- ▁2 ▁) ▁) ▁{ ▁min Count ▁= ▁2 ▁; ▁} ▁else ▁{ ▁min Count ▁= ▁3 ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁min Count ▁+ ▁" NEW _ LINE "); ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁100 ▁; ▁print Min Count Prime ▁( ▁N ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁count Steps ▁( ▁int ▁n ▁) ▁{ ▁int ▁steps ▁= ▁0 ▁; ▁while ▁( ▁n ▁> ▁0 ▁) ▁{ ▁int ▁largest ▁= ▁( ▁int ▁) ▁Math ▁. ▁c br t ▁( ▁n ▁) ▁; ▁n ▁-= ▁( ▁largest ▁* ▁largest ▁* ▁largest ▁) ▁; ▁steps ▁++ ▁; ▁} ▁return ▁steps ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁150 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁count Steps ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁rad ▁( ▁double ▁d ▁, ▁double ▁h ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁The ▁radius ▁of ▁the ▁circle ▁is ▁" ▁+ ▁( ▁( ▁d ▁* ▁d ▁) ▁/ ▁( ▁8 ▁* ▁h ▁) ▁+ ▁h ▁/ ▁2 ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁double ▁d ▁= ▁4 ▁, ▁h ▁= ▁1 ▁; ▁rad ▁( ▁d ▁, ▁h ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁lang ▁. ▁Math ▁; ▁class ▁G F G ▁{ ▁static ▁float ▁Area ▁( ▁float ▁r ▁) ▁{ ▁if ▁( ▁r ▁< ▁0 ▁) ▁return ▁- ▁1 ▁; ▁float ▁x ▁= ▁( ▁2 ▁* ▁r ▁) ▁/ ▁( ▁float ▁) ▁( ▁Math ▁. ▁sqrt ▁( ▁5 ▁) ▁) ▁; ▁float ▁A ▁= ▁0. 704 77 f ▁* ▁( ▁float ▁) ▁( ▁Math ▁. ▁pow ▁( ▁x ▁, ▁2 ▁) ▁) ▁; ▁return ▁A ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁float ▁r ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁Area ▁( ▁r ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁float ▁poly diag onal ▁( ▁float ▁n ▁, ▁float ▁a ▁) ▁{ ▁if ▁( ▁a ▁< ▁0 ▁&& ▁n ▁< ▁0 ▁) ▁{ ▁return ▁- ▁1 ▁; ▁} ▁return ▁( ▁float ▁) ▁( ▁2 ▁* ▁a ▁* ▁Math ▁. ▁sin ▁( ▁( ▁( ▁( ▁n ▁- ▁2 ▁) ▁* ▁180 ▁) ▁/ ▁( ▁2 ▁* ▁n ▁) ▁) ▁* ▁3.14 159 ▁/ ▁180 ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁float ▁a ▁= ▁9 ▁, ▁n ▁= ▁10 ▁; ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁% ▁.3 f ▁" ▁, ▁poly diag onal ▁( ▁n ▁, ▁a ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁double ▁PI ▁= ▁3.14 159 265 ▁; ▁public ▁static ▁double ▁area _ c ic um scri bed ▁( ▁double ▁c ▁) ▁{ ▁return ▁( ▁c ▁* ▁c ▁* ▁( ▁PI ▁/ ▁4 ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁double ▁c ▁= ▁8.0 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁area _ c ic um scri bed ▁( ▁c ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁max Area ▁( ▁float ▁per imeter ▁) ▁{ ▁int ▁length ▁= ▁( ▁int ▁) ▁Math ▁. ▁ceil ▁( ▁per imeter ▁/ ▁4 ▁) ▁; ▁int ▁b readth ▁= ▁( ▁int ▁) ▁Math ▁. ▁floor ▁( ▁per imeter ▁/ ▁4 ▁) ▁; ▁return ▁length ▁* ▁b readth ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁float ▁n ▁= ▁38 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Maximum ▁Area ▁= ▁" ▁+ ▁max Area ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁double ▁Per imeter ▁( ▁double ▁s ▁, ▁int ▁n ▁) ▁{ ▁double ▁per imeter ▁= ▁1 ▁; ▁per imeter ▁= ▁n ▁* ▁s ▁; ▁return ▁per imeter ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁5 ▁; ▁double ▁s ▁= ▁2.5 ▁, ▁per i ▁; ▁per i ▁= ▁Per imeter ▁( ▁s ▁, ▁n ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Per imeter ▁of ▁Regular ▁Polygon ▁" ▁+ ▁" ▁with ▁" ▁+ ▁n ▁+ ▁" ▁sides ▁of ▁length ▁" ▁+ ▁s ▁+ ▁" ▁= ▁" ▁+ ▁per i ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁float ▁hex ad iag onal ▁( ▁float ▁a ▁) ▁{ ▁if ▁( ▁a ▁< ▁0 ▁) ▁return ▁- ▁1 ▁; ▁return ▁2 ▁* ▁a ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁float ▁a ▁= ▁4 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁hex ad iag onal ▁( ▁a ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁float ▁find Radius Of c irc um circle ▁( ▁float ▁l ▁, ▁float ▁b ▁) ▁{ ▁if ▁( ▁l ▁< ▁0 ▁b ▁< ▁0 ▁) ▁return ▁- ▁1 ▁; ▁float ▁radius ▁= ▁( ▁float ▁) ▁Math ▁. ▁sqrt ▁( ▁Math ▁. ▁pow ▁( ▁l ▁, ▁2 ▁) ▁+ ▁Math ▁. ▁pow ▁( ▁b ▁, ▁2 ▁) ▁) ▁/ ▁2 ▁; ▁return ▁radius ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁float ▁l ▁= ▁4 ▁, ▁b ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Radius Of c irc um circle ▁( ▁l ▁, ▁b ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁hal fs quare ▁( ▁int ▁n ▁, ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁int ▁half ▁= ▁n ▁/ ▁2 ▁; ▁if ▁( ▁( ▁half ▁== ▁x ▁half ▁== ▁x ▁- ▁1 ▁) ▁&& ▁( ▁half ▁== ▁y ▁half ▁== ▁y ▁- ▁1 ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁NO ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁YES ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁100 ▁; ▁int ▁x ▁= ▁51 ▁, ▁y ▁= ▁100 ▁; ▁hal fs quare ▁( ▁n ▁, ▁x ▁, ▁y ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁boolean ▁Find Point ▁( ▁int ▁x 1 ▁, ▁int ▁y 1 ▁, ▁int ▁x 2 ▁, ▁int ▁y 2 ▁, ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁if ▁( ▁x ▁> ▁x 1 ▁&& ▁x ▁< ▁x 2 ▁&& ▁y ▁> ▁y 1 ▁&& ▁y ▁< ▁y 2 ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁x 1 ▁= ▁0 ▁, ▁y 1 ▁= ▁0 ▁, ▁x 2 ▁= ▁10 ▁, ▁y 2 ▁= ▁8 ▁; ▁int ▁x ▁= ▁1 ▁, ▁y ▁= ▁5 ▁; ▁if ▁( ▁Find Point ▁( ▁x 1 ▁, ▁y 1 ▁, ▁x 2 ▁, ▁y 2 ▁, ▁x ▁, ▁y ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁shortest _ distance ▁( ▁float ▁x 1 ▁, ▁float ▁y 1 ▁, ▁float ▁z 1 ▁, ▁float ▁a ▁, ▁float ▁b ▁, ▁float ▁c ▁, ▁float ▁d ▁) ▁{ ▁d ▁= ▁Math ▁. ▁abs ▁( ▁( ▁a ▁* ▁x 1 ▁+ ▁b ▁* ▁y 1 ▁+ ▁c ▁* ▁z 1 ▁+ ▁d ▁) ▁) ▁; ▁float ▁e ▁= ▁( ▁float ▁) ▁Math ▁. ▁sqrt ▁( ▁a ▁* ▁a ▁+ ▁b ▁* ▁b ▁+ ▁c ▁* ▁c ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Per p end icular ▁distance ▁" ▁+ ▁" ▁is ▁" ▁+ ▁d ▁/ ▁e ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁float ▁x 1 ▁= ▁4 ▁; ▁float ▁y 1 ▁= ▁- ▁4 ▁; ▁float ▁z 1 ▁= ▁3 ▁; ▁float ▁a ▁= ▁2 ▁; ▁float ▁b ▁= ▁- ▁2 ▁; ▁float ▁c ▁= ▁5 ▁; ▁float ▁d ▁= ▁8 ▁; ▁shortest _ distance ▁( ▁x 1 ▁, ▁y 1 ▁, ▁z 1 ▁, ▁a ▁, ▁b ▁, ▁c ▁, ▁d ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁p ent agon _ py ramid al ▁( ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁p ▁= ▁( ▁3 ▁* ▁i ▁* ▁i ▁- ▁i ▁) ▁/ ▁2 ▁; ▁sum ▁= ▁sum ▁+ ▁p ▁; ▁} ▁return ▁sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁4 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁p ent agon _ py ramid al ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁boolean ▁is Rectangle ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁int ▁c ▁, ▁int ▁d ▁) ▁{ ▁if ▁( ▁a ▁== ▁b ▁&& ▁a ▁== ▁c ▁&& ▁a ▁== ▁d ▁&& ▁c ▁== ▁d ▁&& ▁b ▁== ▁c ▁&& ▁b ▁== ▁d ▁) ▁return ▁true ▁; ▁else ▁if ▁( ▁a ▁== ▁b ▁&& ▁c ▁== ▁d ▁) ▁return ▁true ▁; ▁else ▁if ▁( ▁a ▁== ▁d ▁&& ▁c ▁== ▁b ▁) ▁return ▁true ▁; ▁else ▁if ▁( ▁a ▁== ▁c ▁&& ▁d ▁== ▁b ▁) ▁return ▁true ▁; ▁else ▁return ▁false ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁= ▁1 ▁, ▁b ▁= ▁2 ▁, ▁c ▁= ▁3 ▁, ▁d ▁= ▁4 ▁; ▁if ▁( ▁is Rectangle ▁( ▁a ▁, ▁b ▁, ▁c ▁, ▁d ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁double ▁max Area ▁( ▁double ▁a ▁, ▁double ▁b ▁, ▁double ▁c ▁, ▁double ▁d ▁) ▁{ ▁double ▁semi per imeter ▁= ▁( ▁a ▁+ ▁b ▁+ ▁c ▁+ ▁d ▁) ▁/ ▁2 ▁; ▁return ▁Math ▁. ▁sqrt ▁( ▁( ▁semi per imeter ▁- ▁a ▁) ▁* ▁( ▁semi per imeter ▁- ▁b ▁) ▁* ▁( ▁semi per imeter ▁- ▁c ▁) ▁* ▁( ▁semi per imeter ▁- ▁d ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁double ▁a ▁= ▁1 ▁, ▁b ▁= ▁2 ▁, ▁c ▁= ▁1 ▁, ▁d ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁max Area ▁( ▁a ▁, ▁b ▁, ▁c ▁, ▁d ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁check Collision ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁int ▁c ▁, ▁int ▁x ▁, ▁int ▁y ▁, ▁int ▁radius ▁) ▁{ ▁double ▁dist ▁= ▁( ▁Math ▁. ▁abs ▁( ▁a ▁* ▁x ▁+ ▁b ▁* ▁y ▁+ ▁c ▁) ▁) ▁/ ▁Math ▁. ▁sqrt ▁( ▁a ▁* ▁a ▁+ ▁b ▁* ▁b ▁) ▁; ▁if ▁( ▁radius ▁== ▁dist ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Touch ▁" ▁) ▁; ▁else ▁if ▁( ▁radius ▁> ▁dist ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Inter sect ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Out side ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁radius ▁= ▁5 ▁; ▁int ▁x ▁= ▁0 ▁, ▁y ▁= ▁0 ▁; ▁int ▁a ▁= ▁3 ▁, ▁b ▁= ▁4 ▁, ▁c ▁= ▁25 ▁; ▁check Collision ▁( ▁a ▁, ▁b ▁, ▁c ▁, ▁x ▁, ▁y ▁, ▁radius ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁circle ▁( ▁int ▁x 1 ▁, ▁int ▁y 1 ▁, ▁int ▁x 2 ▁, ▁int ▁y 2 ▁, ▁int ▁r 1 ▁, ▁int ▁r 2 ▁) ▁{ ▁int ▁dist Sq ▁= ▁( ▁x 1 ▁- ▁x 2 ▁) ▁* ▁( ▁x 1 ▁- ▁x 2 ▁) ▁+ ▁( ▁y 1 ▁- ▁y 2 ▁) ▁* ▁( ▁y 1 ▁- ▁y 2 ▁) ▁; ▁int ▁rad Sum Sq ▁= ▁( ▁r 1 ▁+ ▁r 2 ▁) ▁* ▁( ▁r 1 ▁+ ▁r 2 ▁) ▁; ▁if ▁( ▁dist Sq ▁== ▁rad Sum Sq ▁) ▁return ▁1 ▁; ▁else ▁if ▁( ▁dist Sq ▁> ▁rad Sum Sq ▁) ▁return ▁- ▁1 ▁; ▁else ▁return ▁0 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁x 1 ▁= ▁- ▁10 ▁, ▁y 1 ▁= ▁8 ▁; ▁int ▁x 2 ▁= ▁14 ▁, ▁y 2 ▁= ▁- ▁24 ▁; ▁int ▁r 1 ▁= ▁30 ▁, ▁r 2 ▁= ▁10 ▁; ▁int ▁t ▁= ▁circle ▁( ▁x 1 ▁, ▁y 1 ▁, ▁x 2 ▁, ▁y 2 ▁, ▁r 1 ▁, ▁r 2 ▁) ▁; ▁if ▁( ▁t ▁== ▁1 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Circle ▁touch ▁to ▁" ▁+ ▁" ▁each ▁other ▁. ▁" ▁) ▁; ▁else ▁if ▁( ▁t ▁< ▁0 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Circle ▁not ▁touch ▁" ▁+ ▁" ▁to ▁each ▁other ▁. ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Circle ▁intersect ▁" ▁+ ▁" ▁to ▁each ▁other ▁. ▁" ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁public ▁static ▁int ▁minimum Cost ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁X ▁, ▁int ▁Y ▁) ▁{ ▁int ▁even _ count ▁= ▁0 ▁, ▁odd _ count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁arr ▁[ ▁i ▁] ▁& ▁1 ▁) ▁> ▁0 ▁&& ▁( ▁i ▁% ▁2 ▁== ▁0 ▁) ▁) ▁{ ▁odd _ count ▁++ ▁; ▁} ▁if ▁( ▁( ▁arr ▁[ ▁i ▁] ▁% ▁2 ▁) ▁== ▁0 ▁&& ▁( ▁i ▁& ▁1 ▁) ▁> ▁0 ▁) ▁{ ▁even _ count ▁++ ▁; ▁} ▁} ▁int ▁cost 1 ▁= ▁X ▁* ▁Math ▁. ▁min ▁( ▁odd _ count ▁, ▁even _ count ▁) ▁; ▁int ▁cost 2 ▁= ▁Y ▁* ▁( ▁Math ▁. ▁max ▁( ▁odd _ count ▁, ▁even _ count ▁) ▁- ▁Math ▁. ▁min ▁( ▁odd _ count ▁, ▁even _ count ▁) ▁) ▁; ▁int ▁cost 3 ▁= ▁( ▁odd _ count ▁+ ▁even _ count ▁) ▁* ▁Y ▁; ▁return ▁Math ▁. ▁min ▁( ▁cost 1 ▁+ ▁cost 2 ▁, ▁cost 3 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁3 ▁, ▁7 ▁, ▁2 ▁, ▁1 ▁} ▁, ▁X ▁= ▁10 ▁, ▁Y ▁= ▁2 ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁minimum Cost ▁( ▁arr ▁, ▁N ▁, ▁X ▁, ▁Y ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁max imize Subset ▁( ▁int ▁N ▁, ▁int ▁[ ▁] ▁arr ▁, ▁int ▁M ▁, ▁int ▁x ▁) ▁{ ▁if ▁( ▁x ▁== ▁M ▁) ▁{ ▁return ▁0 ▁; ▁} ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁x ▁; ▁i ▁< ▁M ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁N ▁% ▁arr ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁ans ▁= ▁Math ▁. ▁max ▁( ▁ans ▁, ▁max imize Subset ▁( ▁N ▁/ ▁arr ▁[ ▁i ▁] ▁, ▁arr ▁, ▁M ▁, ▁x ▁+ ▁1 ▁) ▁+ ▁1 ▁) ▁; ▁} ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁64 ▁; ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁4 ▁, ▁8 ▁, ▁16 ▁, ▁32 ▁} ▁; ▁int ▁M ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁max imize Subset ▁( ▁N ▁, ▁arr ▁, ▁M ▁, ▁0 ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁public ▁static ▁int ▁getProduct ▁( ▁int ▁n ▁) ▁{ ▁int ▁product ▁= ▁1 ▁; ▁while ▁( ▁n ▁!= ▁0 ▁) ▁{ ▁product ▁= ▁product ▁* ▁( ▁n ▁% ▁10 ▁) ▁; ▁n ▁= ▁n ▁/ ▁10 ▁; ▁} ▁return ▁product ▁; ▁} ▁public ▁static ▁int ▁count Pairs ▁( ▁int ▁L ▁, ▁int ▁R ▁) ▁{ ▁int ▁cnt Pair ▁= ▁0 ▁; ▁for ▁( ▁int ▁a ▁= ▁L ▁; ▁a ▁<= ▁R ▁; ▁a ▁++ ▁) ▁{ ▁for ▁( ▁int ▁b ▁= ▁a ▁+ ▁1 ▁; ▁b ▁<= ▁R ▁; ▁b ▁++ ▁) ▁{ ▁int ▁x ▁= ▁getProduct ▁( ▁a ▁) ▁; ▁int ▁y ▁= ▁getProduct ▁( ▁b ▁) ▁; ▁if ▁( ▁x ▁!= ▁0 ▁&& ▁y ▁!= ▁0 ▁&& ▁( ▁a ▁* ▁y ▁) ▁== ▁( ▁b ▁* ▁x ▁) ▁) ▁{ ▁cnt Pair ▁++ ▁; ▁} ▁} ▁} ▁return ▁cnt Pair ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁L ▁= ▁1 ▁; ▁int ▁R ▁= ▁100 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Pairs ▁( ▁L ▁, ▁R ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁max Sum ▁( ▁int ▁[ ▁] ▁[ ▁] ▁matrix ▁) ▁{ ▁int ▁r ▁= ▁matrix ▁. ▁length ▁; ▁int ▁c ▁= ▁matrix ▁[ ▁0 ▁] ▁. ▁length ▁; ▁int ▁sum ▁= ▁0 ▁; ▁int ▁mini ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁r ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁c ▁; ▁j ▁++ ▁) ▁{ ▁int ▁k ▁= ▁matrix ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁mini ▁= ▁Math ▁. ▁min ▁( ▁mini ▁, ▁Math ▁. ▁abs ▁( ▁k ▁) ▁) ▁; ▁if ▁( ▁k ▁< ▁0 ▁) ▁count ▁++ ▁; ▁sum ▁+= ▁Math ▁. ▁abs ▁( ▁k ▁) ▁; ▁} ▁} ▁if ▁( ▁count ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁return ▁sum ▁; ▁} ▁else ▁{ ▁return ▁( ▁sum ▁- ▁2 ▁* ▁mini ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁[ ▁] ▁matrix ▁= ▁{ ▁{ ▁2 ▁, ▁- ▁2 ▁} ▁, ▁{ ▁- ▁2 ▁, ▁2 ▁} ▁} ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁max Sum ▁( ▁matrix ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁count Sub sequences ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁odd ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁arr ▁[ ▁i ▁] ▁& ▁1 ▁) ▁% ▁2 ▁== ▁1 ▁) ▁odd ▁++ ▁; ▁} ▁return ▁( ▁1 ▁<< ▁odd ▁) ▁- ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁3 ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁3 ▁} ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Sub sequences ▁( ▁arr ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁update Array ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁K ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁ArrayList ▁< ▁Integer ▁> ▁res ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁arr ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁K ▁) ▁{ ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁else ▁{ ▁if ▁( ▁sum ▁!= ▁0 ▁) ▁{ ▁res ▁. ▁add ▁( ▁sum ▁) ▁; ▁} ▁sum ▁= ▁0 ▁; ▁res ▁. ▁add ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁} ▁if ▁( ▁sum ▁!= ▁0 ▁) ▁res ▁. ▁add ▁( ▁sum ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁res ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁res ▁. ▁get ▁( ▁i ▁) ▁+ ▁" ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁200 ▁, ▁6 ▁, ▁36 ▁, ▁6 12 ▁, ▁12 1 ▁, ▁66 ▁, ▁63 ▁, ▁39 ▁, ▁6 68 ▁, ▁108 ▁} ▁; ▁int ▁K ▁= ▁100 ▁; ▁update Array ▁( ▁arr ▁, ▁K ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁count Quad ru ples ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁freq ▁= ▁new ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁freq ▁. ▁containsKey ▁( ▁A ▁[ ▁i ▁] ▁) ▁) ▁ans ▁+= ▁freq ▁. ▁get ▁( ▁A ▁[ ▁i ▁] ▁) ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁i ▁; ▁j ▁++ ▁) ▁{ ▁for ▁( ▁int ▁k ▁= ▁0 ▁; ▁k ▁< ▁j ▁; ▁k ▁++ ▁) ▁{ ▁if ▁( ▁freq ▁. ▁containsKey ▁( ▁A ▁[ ▁i ▁] ▁* ▁A ▁[ ▁j ▁] ▁* ▁A ▁[ ▁k ▁] ▁) ▁) ▁{ ▁freq ▁. ▁put ▁( ▁A ▁[ ▁i ▁] ▁* ▁A ▁[ ▁j ▁] ▁* ▁A ▁[ ▁k ▁] ▁, ▁freq ▁. ▁get ▁( ▁A ▁[ ▁i ▁] ▁* ▁A ▁[ ▁j ▁] ▁* ▁A ▁[ ▁k ▁] ▁) ▁+ ▁1 ▁) ▁; ▁} ▁else ▁{ ▁freq ▁. ▁put ▁( ▁A ▁[ ▁i ▁] ▁* ▁A ▁[ ▁j ▁] ▁* ▁A ▁[ ▁k ▁] ▁, ▁1 ▁) ▁; ▁} ▁} ▁} ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁2 ▁, ▁2 ▁, ▁7 ▁, ▁40 ▁, ▁160 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁count Quad ru ples ▁( ▁arr ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁public ▁static ▁long ▁count Cells ▁( ▁int ▁n ▁, ▁int ▁m ▁, ▁int ▁s ▁) ▁{ ▁int ▁mx 1 ▁= ▁- ▁1 ▁; ▁int ▁cont 1 ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁&& ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁{ ▁int ▁aux ▁= ▁( ▁n ▁- ▁( ▁i ▁+ ▁1 ▁) ▁) ▁/ ▁s ▁+ ▁1 ▁; ▁if ▁( ▁aux ▁> ▁mx 1 ▁) ▁{ ▁mx 1 ▁= ▁cont 1 ▁= ▁aux ▁; ▁} ▁else ▁if ▁( ▁aux ▁== ▁mx 1 ▁) ▁cont 1 ▁+= ▁aux ▁; ▁} ▁int ▁mx 2 ▁= ▁- ▁1 ▁; ▁int ▁cont 2 ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁&& ▁i ▁< ▁m ▁; ▁++ ▁i ▁) ▁{ ▁int ▁aux ▁= ▁( ▁m ▁- ▁( ▁i ▁+ ▁1 ▁) ▁) ▁/ ▁s ▁+ ▁1 ▁; ▁if ▁( ▁aux ▁> ▁mx 2 ▁) ▁mx 2 ▁= ▁cont 2 ▁= ▁aux ▁; ▁else ▁if ▁( ▁aux ▁== ▁mx 2 ▁) ▁cont 2 ▁+= ▁aux ▁; ▁} ▁return ▁( ▁long ▁) ▁( ▁cont 1 ▁* ▁cont 2 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁N ▁= ▁5 ▁, ▁M ▁= ▁5 ▁, ▁K ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Cells ▁( ▁N ▁, ▁M ▁, ▁K ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁int ▁minimum Sub array ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁int ▁[ ▁] ▁map u ▁= ▁new ▁int ▁[ ▁m ▁+ ▁1 ▁] ▁; ▁Arrays ▁. ▁fill ▁( ▁map u ▁, ▁0 ▁) ▁; ▁int ▁c ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁map u ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁++ ▁; ▁if ▁( ▁map u ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁== ▁( ▁n ▁/ ▁m ▁) ▁+ ▁1 ▁) ▁c ▁++ ▁; ▁} ▁if ▁( ▁c ▁== ▁0 ▁) ▁return ▁0 ▁; ▁int ▁ans ▁= ▁n ▁; ▁int ▁l ▁= ▁0 ▁, ▁r ▁= ▁0 ▁; ▁while ▁( ▁r ▁< ▁n ▁) ▁{ ▁if ▁( ▁-- ▁map u ▁[ ▁arr ▁[ ▁r ▁] ▁] ▁== ▁( ▁n ▁/ ▁m ▁) ▁) ▁c ▁-- ▁; ▁if ▁( ▁c ▁== ▁0 ▁) ▁{ ▁while ▁( ▁l ▁<= ▁r ▁&& ▁c ▁== ▁0 ▁) ▁{ ▁ans ▁= ▁Math ▁. ▁min ▁( ▁ans ▁, ▁r ▁- ▁l ▁+ ▁1 ▁) ▁; ▁if ▁( ▁++ ▁map u ▁[ ▁arr ▁[ ▁l ▁] ▁] ▁> ▁( ▁n ▁/ ▁m ▁) ▁) ▁c ▁++ ▁; ▁l ▁++ ▁; ▁} ▁} ▁r ▁++ ▁; ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁1 ▁, ▁1 ▁, ▁2 ▁, ▁1 ▁, ▁1 ▁, ▁2 ▁} ▁; ▁int ▁M ▁= ▁2 ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁minimum Sub array ▁( ▁arr ▁, ▁N ▁, ▁M ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁ArrayList ▁; ▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁import ▁java ▁. ▁util ▁. ▁HashMap ▁; ▁import ▁java ▁. ▁util ▁. ▁Map ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁fact ▁( ▁int ▁n ▁) ▁{ ▁int ▁res ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁res ▁= ▁res ▁* ▁i ▁; ▁} ▁return ▁res ▁; ▁} ▁static ▁int ▁n Cr ▁( ▁int ▁n ▁, ▁int ▁r ▁) ▁{ ▁return ▁fact ▁( ▁n ▁) ▁/ ▁( ▁fact ▁( ▁r ▁) ▁* ▁fact ▁( ▁n ▁- ▁r ▁) ▁) ▁; ▁} ▁static ▁void ▁count W ays ▁( ▁String ▁s ▁, ▁String ▁t ▁) ▁{ ▁int ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁int ▁sum 1 ▁= ▁0 ▁, ▁sum 2 ▁= ▁0 ▁, ▁K ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'1' ▁) ▁{ ▁sum 1 ▁++ ▁; ▁} ▁else ▁sum 1 ▁-- ▁; ▁} ▁int ▁m ▁= ▁t ▁. ▁length ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁m ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁t ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'1' ▁) ▁{ ▁sum 2 ▁++ ▁; ▁} ▁else ▁if ▁( ▁t ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'0' ▁) ▁{ ▁sum 2 ▁-- ▁; ▁} ▁else ▁K ▁++ ▁; ▁} ▁int ▁P ▁= ▁Math ▁. ▁abs ▁( ▁sum 1 ▁- ▁sum 2 ▁) ▁; ▁if ▁( ▁( ▁P ▁> ▁K ▁) ▁|| ▁( ▁K ▁- ▁P ▁) ▁% ▁2 ▁== ▁1 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁0 ▁) ▁; ▁return ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁n Cr ▁( ▁K ▁, ▁( ▁P ▁+ ▁K ▁) ▁/ ▁2 ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁S 1 ▁= ▁"1 01 0" ▁; ▁String ▁S 2 ▁= ▁"10 ▁? ▁? ▁" ▁; ▁count W ays ▁( ▁S 1 ▁, ▁S 2 ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁long ▁AB S ▁( ▁long ▁x ▁) ▁{ ▁return ▁Math ▁. ▁max ▁( ▁x ▁, ▁- ▁x ▁) ▁; ▁} ▁static ▁void ▁find Fraction ▁( ▁long ▁x ▁, ▁long ▁y ▁, ▁long ▁n ▁) ▁{ ▁long ▁A ▁= ▁- ▁1 ▁, ▁B ▁= ▁- ▁1 ▁; ▁for ▁( ▁long ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁long ▁d ▁= ▁( ▁i ▁* ▁x ▁) ▁/ ▁y ▁; ▁if ▁( ▁d ▁>= ▁0 ▁&& ▁( ▁A ▁== ▁- ▁1 ▁|| ▁AB S ▁( ▁B ▁* ▁x ▁- ▁y ▁* ▁A ▁) ▁* ▁AB S ▁( ▁i ▁* ▁y ▁) ▁> ▁AB S ▁( ▁i ▁* ▁x ▁- ▁y ▁* ▁d ▁) ▁* ▁AB S ▁( ▁B ▁* ▁y ▁) ▁) ▁) ▁A ▁= ▁d ▁; ▁B ▁= ▁i ▁; ▁d ▁++ ▁; ▁if ▁( ▁d ▁>= ▁0 ▁&& ▁( ▁A ▁== ▁- ▁1 ▁|| ▁AB S ▁( ▁B ▁* ▁x ▁- ▁y ▁* ▁A ▁) ▁* ▁AB S ▁( ▁i ▁* ▁y ▁) ▁> ▁AB S ▁( ▁i ▁* ▁x ▁- ▁y ▁* ▁d ▁) ▁* ▁AB S ▁( ▁B ▁* ▁y ▁) ▁) ▁) ▁A ▁= ▁d ▁; ▁B ▁= ▁i ▁; ▁} ▁A ▁-- ▁; ▁B ▁-- ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁A ▁+ ▁" ▁/ ▁" ▁+ ▁B ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁long ▁x ▁= ▁3 ▁; ▁long ▁y ▁= ▁7 ▁; ▁long ▁n ▁= ▁6 ▁; ▁find Fraction ▁( ▁x ▁, ▁y ▁, ▁n ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁Vector ▁; ▁public ▁class ▁G F G ▁{ ▁static ▁Vector ▁< ▁String ▁> ▁Fraction Split ▁( ▁long ▁n ▁, ▁long ▁d ▁) ▁{ ▁Vector ▁< ▁String ▁> ▁Unit F actions ▁= ▁new ▁Vector ▁< ▁> ▁( ▁) ▁; ▁while ▁( ▁n ▁> ▁0 ▁) ▁{ ▁long ▁x ▁= ▁( ▁d ▁+ ▁n ▁- ▁1 ▁) ▁/ ▁n ▁; ▁String ▁s ▁= ▁"1 ▁/ ▁" ▁+ ▁String ▁. ▁valueOf ▁( ▁x ▁) ▁; ▁Unit F actions ▁. ▁add ▁( ▁s ▁) ▁; ▁n ▁= ▁n ▁* ▁x ▁- ▁d ▁; ▁d ▁= ▁d ▁* ▁x ▁; ▁} ▁return ▁Unit F actions ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁long ▁n ▁= ▁13 ▁, ▁d ▁= ▁18 ▁; ▁Vector ▁< ▁String ▁> ▁res ▁= ▁Fraction Split ▁( ▁n ▁, ▁d ▁) ▁; ▁for ▁( ▁String ▁s ▁: ▁res ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁s ▁+ ▁" ▁, ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁void ▁minimum Distance ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁ind ▁= ▁0 ▁; ▁int ▁prev ▁= ▁arr ▁[ ▁ind ▁] ▁; ▁int ▁s ▁= ▁arr ▁. ▁length ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁int ▁distance ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁if ▁( ▁i ▁< ▁arr ▁[ ▁0 ▁] ▁) ▁{ ▁distance ▁= ▁arr ▁[ ▁0 ▁] ▁- ▁i ▁; ▁} ▁else ▁if ▁( ▁i ▁>= ▁prev ▁&& ▁ind ▁+ ▁1 ▁< ▁s ▁&& ▁i ▁<= ▁arr ▁[ ▁ind ▁+ ▁1 ▁] ▁) ▁{ ▁distance ▁= ▁Math ▁. ▁min ▁( ▁i ▁- ▁prev ▁, ▁arr ▁[ ▁ind ▁+ ▁1 ▁] ▁- ▁i ▁) ▁; ▁if ▁( ▁i ▁== ▁arr ▁[ ▁ind ▁+ ▁1 ▁] ▁) ▁{ ▁distance ▁= ▁0 ▁; ▁prev ▁= ▁arr ▁[ ▁ind ▁+ ▁1 ▁] ▁; ▁ind ▁++ ▁; ▁} ▁} ▁else ▁{ ▁distance ▁= ▁i ▁- ▁prev ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁distance ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁5 ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁4 ▁} ▁; ▁minimum Distance ▁( ▁arr ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁count Of Pairs ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁N ▁, ▁int ▁X ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁M ▁= ▁new ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁M ▁. ▁containsKey ▁( ▁arr ▁[ ▁i ▁] ▁& ▁X ▁) ▁) ▁M ▁. ▁put ▁( ▁( ▁arr ▁[ ▁i ▁] ▁& ▁X ▁) ▁, ▁M ▁. ▁get ▁( ▁arr ▁[ ▁i ▁] ▁& ▁X ▁) ▁+ ▁1 ▁) ▁; ▁else ▁M ▁. ▁put ▁( ▁arr ▁[ ▁i ▁] ▁& ▁X ▁, ▁1 ▁) ▁; ▁} ▁for ▁( ▁Integer ▁entry ▁: ▁M ▁. ▁keySet ▁( ▁) ▁) ▁{ ▁int ▁p ▁= ▁M ▁. ▁get ▁( ▁entry ▁) ▁; ▁count ▁+= ▁p ▁* ▁( ▁p ▁- ▁1 ▁) ▁/ ▁2 ▁; ▁} ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁3 ▁, ▁2 ▁, ▁5 ▁, ▁4 ▁, ▁6 ▁, ▁7 ▁} ▁; ▁int ▁X ▁= ▁6 ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁count Of Pairs ▁( ▁arr ▁, ▁N ▁, ▁X ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁HashMap ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁prime Factor ization ▁( ▁int ▁N ▁) ▁{ ▁int ▁[ ▁] ▁s ieve ▁= ▁new ▁int ▁[ ▁N ▁/ ▁2 ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁N ▁/ ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁s ieve ▁[ ▁i ▁] ▁= ▁0 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁N ▁/ ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ieve ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁* ▁i ▁; ▁j ▁<= ▁N ▁/ ▁2 ▁; ▁j ▁+= ▁i ▁) ▁{ ▁s ieve ▁[ ▁j ▁] ▁= ▁1 ▁; ▁} ▁} ▁} ▁ArrayList ▁< ▁Integer ▁> ▁prime ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁3 ▁; ▁i ▁<= ▁N ▁/ ▁2 ▁; ▁i ▁++ ▁) ▁if ▁( ▁s ieve ▁[ ▁i ▁] ▁== ▁0 ▁) ▁prime ▁. ▁add ▁( ▁i ▁) ▁; ▁int ▁x ▁= ▁prime ▁. ▁size ▁( ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁"2 ▁- ▁> ▁" ▁+ ▁x ▁) ▁; ▁for ▁( ▁int ▁i ▁: ▁prime ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁i ▁+ ▁" ▁- ▁> ▁1" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁N ▁= ▁18 ▁; ▁prime Factor ization ▁( ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁no Of W ays ▁( ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁String ▁S ▁= ▁String ▁. ▁valueOf ▁( ▁N ▁) ▁; ▁int ▁ans ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁S ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁int ▁count ▁= ▁1 ▁; ▁while ▁( ▁i ▁< ▁S ▁. ▁length ▁( ▁) ▁&& ▁( ▁int ▁) ▁S ▁. ▁charAt ▁( ▁i ▁) ▁- ▁48 ▁+ ▁( ▁int ▁) ▁S ▁. ▁charAt ▁( ▁i ▁- ▁1 ▁) ▁- ▁48 ▁== ▁K ▁) ▁{ ▁count ▁++ ▁; ▁i ▁++ ▁; ▁} ▁if ▁( ▁count ▁% ▁2 ▁== ▁1 ▁) ▁ans ▁*= ▁( ▁count ▁+ ▁1 ▁) ▁/ ▁2 ▁; ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁145 4 78 1 ▁; ▁int ▁K ▁= ▁9 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁no Of W ays ▁( ▁N ▁, ▁K ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁gcd ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁return ▁b ▁== ▁0 ▁? ▁a ▁: ▁gcd ▁( ▁b ▁, ▁a ▁% ▁b ▁) ▁; ▁} ▁static ▁void ▁print Unit ary Div is ors ▁( ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁( ▁int ▁) ▁Math ▁. ▁sqrt ▁( ▁n ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁{ ▁if ▁( ▁n ▁/ ▁i ▁== ▁i ▁&& ▁gcd ▁( ▁i ▁, ▁n ▁/ ▁i ▁) ▁== ▁1 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁i ▁+ ▁" ▁" ▁) ▁; ▁} ▁else ▁{ ▁if ▁( ▁gcd ▁( ▁i ▁, ▁n ▁/ ▁i ▁) ▁== ▁1 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁i ▁+ ▁" ▁" ▁+ ▁n ▁/ ▁i ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁} ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁12 ▁; ▁print Unit ary Div is ors ▁( ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁getPerm utation ▁( ▁int ▁N ▁) ▁{ ▁if ▁( ▁N ▁<= ▁3 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁- ▁1 ▁) ▁; ▁return ▁; ▁} ▁int ▁i ▁= ▁N ▁; ▁if ▁( ▁N ▁% ▁2 ▁== ▁0 ▁) ▁i ▁-- ▁; ▁while ▁( ▁i ▁>= ▁1 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁i ▁+ ▁" ▁" ▁) ▁; ▁i ▁-= ▁2 ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁4 ▁+ ▁" ▁" ▁+ ▁2 ▁+ ▁" ▁" ▁) ▁; ▁i ▁= ▁6 ▁; ▁while ▁( ▁i ▁<= ▁N ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁i ▁+ ▁" ▁" ▁) ▁; ▁i ▁+= ▁2 ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁9 ▁; ▁getPerm utation ▁( ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁max Score Sub Array ▁( ▁int ▁[ ▁] ▁a ▁, ▁int ▁[ ▁] ▁b ▁, ▁int ▁n ▁) ▁{ ▁int ▁res ▁= ▁0 ▁; ▁for ▁( ▁int ▁mid ▁= ▁0 ▁; ▁mid ▁< ▁n ▁; ▁mid ▁++ ▁) ▁{ ▁int ▁straight Score ▁= ▁a ▁[ ▁mid ▁] ▁* ▁b ▁[ ▁mid ▁] ▁, ▁reverse Score ▁= ▁a ▁[ ▁mid ▁] ▁* ▁a ▁[ ▁mid ▁] ▁; ▁int ▁prev ▁= ▁mid ▁- ▁1 ▁, ▁next ▁= ▁mid ▁+ ▁1 ▁; ▁res ▁= ▁Math ▁. ▁max ▁( ▁res ▁, ▁Math ▁. ▁max ▁( ▁straight Score ▁, ▁reverse Score ▁) ▁) ▁; ▁while ▁( ▁prev ▁>= ▁0 ▁&& ▁next ▁< ▁n ▁) ▁{ ▁straight Score ▁+= ▁( ▁a ▁[ ▁prev ▁] ▁* ▁b ▁[ ▁prev ▁] ▁+ ▁a ▁[ ▁next ▁] ▁* ▁b ▁[ ▁next ▁] ▁) ▁; ▁reverse Score ▁+= ▁( ▁a ▁[ ▁prev ▁] ▁* ▁b ▁[ ▁next ▁] ▁+ ▁a ▁[ ▁next ▁] ▁* ▁b ▁[ ▁prev ▁] ▁) ▁; ▁res ▁= ▁Math ▁. ▁max ▁( ▁res ▁, ▁Math ▁. ▁max ▁( ▁straight Score ▁, ▁reverse Score ▁) ▁) ▁; ▁prev ▁-- ▁; ▁next ▁++ ▁; ▁} ▁straight Score ▁= ▁0 ▁; ▁reverse Score ▁= ▁0 ▁; ▁prev ▁= ▁mid ▁- ▁1 ▁; ▁next ▁= ▁mid ▁; ▁while ▁( ▁prev ▁>= ▁0 ▁&& ▁next ▁< ▁n ▁) ▁{ ▁straight Score ▁+= ▁( ▁a ▁[ ▁prev ▁] ▁* ▁b ▁[ ▁prev ▁] ▁+ ▁a ▁[ ▁next ▁] ▁* ▁b ▁[ ▁next ▁] ▁) ▁; ▁reverse Score ▁+= ▁( ▁a ▁[ ▁prev ▁] ▁* ▁b ▁[ ▁next ▁] ▁+ ▁a ▁[ ▁next ▁] ▁* ▁b ▁[ ▁prev ▁] ▁) ▁; ▁res ▁= ▁Math ▁. ▁max ▁( ▁res ▁, ▁Math ▁. ▁max ▁( ▁straight Score ▁, ▁reverse Score ▁) ▁) ▁; ▁prev ▁-- ▁; ▁next ▁++ ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁res ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁13 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁B ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁22 ▁, ▁2 ▁} ▁; ▁int ▁N ▁= ▁A ▁. ▁length ▁; ▁max Score Sub Array ▁( ▁A ▁, ▁B ▁, ▁N ▁) ▁; ▁} ▁}
▁public ▁class ▁MyClass ▁{ ▁static ▁void ▁count Values ▁( ▁int ▁A ▁, ▁int ▁B ▁, ▁int ▁C ▁) ▁{ ▁if ▁( ▁B ▁>= ▁A ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁0 ▁) ▁; ▁return ▁; ▁} ▁if ▁( ▁B ▁== ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁C ▁/ ▁A ▁) ▁; ▁return ▁; ▁} ▁int ▁ans ▁= ▁C ▁/ ▁A ▁; ▁if ▁( ▁ans ▁* ▁A ▁+ ▁B ▁<= ▁C ▁) ▁{ ▁ans ▁++ ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁ans ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁A ▁= ▁6 ▁, ▁B ▁= ▁3 ▁, ▁N ▁= ▁15 ▁; ▁count Values ▁( ▁A ▁, ▁B ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁max Frequency ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁arr ▁) ▁; ▁int ▁start ▁= ▁0 ▁, ▁end ▁= ▁0 ▁; ▁int ▁sum ▁= ▁0 ▁, ▁res ▁= ▁0 ▁; ▁for ▁( ▁end ▁= ▁0 ▁; ▁end ▁< ▁N ▁; ▁end ▁++ ▁) ▁{ ▁sum ▁+= ▁arr ▁[ ▁end ▁] ▁; ▁while ▁( ▁( ▁end ▁- ▁start ▁+ ▁1 ▁) ▁* ▁arr ▁[ ▁end ▁] ▁- ▁sum ▁> ▁K ▁) ▁{ ▁sum ▁-= ▁arr ▁[ ▁start ▁] ▁; ▁start ▁++ ▁; ▁} ▁res ▁= ▁Math ▁. ▁max ▁( ▁res ▁, ▁end ▁- ▁start ▁+ ▁1 ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁res ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁4 ▁, ▁8 ▁, ▁13 ▁} ▁; ▁int ▁N ▁= ▁4 ▁; ▁int ▁K ▁= ▁5 ▁; ▁max Frequency ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁count Pairs ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁x ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁mp ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁mp ▁. ▁put ▁( ▁arr ▁[ ▁i ▁] ▁- ▁x ▁* ▁i ▁, ▁mp ▁. ▁getOr Default ▁( ▁arr ▁[ ▁i ▁] ▁- ▁x ▁* ▁i ▁, ▁0 ▁) ▁+ ▁1 ▁) ▁; ▁} ▁for ▁( ▁int ▁v ▁: ▁mp ▁. ▁values ▁( ▁) ▁) ▁{ ▁count ▁+= ▁( ▁v ▁* ▁( ▁v ▁- ▁1 ▁) ▁) ▁/ ▁2 ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁count ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁6 ▁, ▁x ▁= ▁3 ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁4 ▁, ▁8 ▁, ▁11 ▁, ▁13 ▁, ▁16 ▁} ▁; ▁count Pairs ▁( ▁arr ▁, ▁n ▁, ▁x ▁) ▁; ▁} ▁}
▁public ▁class ▁G F G ▁{ ▁static ▁int ▁sum Of Div is ors ▁( ▁int ▁N ▁) ▁{ ▁return ▁N ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁sum Of Div is ors ▁( ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁find X ORS ▁( ▁int ▁arr 1 ▁[ ▁] ▁, ▁int ▁arr 2 ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁M ▁) ▁{ ▁int ▁X ORS 1 ▁= ▁0 ▁; ▁int ▁X ORS 2 ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁X ORS 1 ▁^= ▁arr 1 ▁[ ▁i ▁] ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁M ▁; ▁i ▁++ ▁) ▁{ ▁X ORS 2 ▁^= ▁arr 2 ▁[ ▁i ▁] ▁; ▁} ▁return ▁( ▁X ORS 1 ▁& ▁X ORS 2 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr 1 ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁; ▁int ▁arr 2 ▁[ ▁] ▁= ▁{ ▁6 ▁, ▁5 ▁} ▁; ▁int ▁N ▁= ▁arr 1 ▁. ▁length ▁; ▁int ▁M ▁= ▁arr 2 ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find X ORS ▁( ▁arr 1 ▁, ▁arr 2 ▁, ▁N ▁, ▁M ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁G F G ▁{ ▁static ▁int ▁ceil Difference ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁x ▁) ▁{ ▁int ▁total Sum ▁= ▁0 ▁; ▁int ▁per Element Sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁total Sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁per Element Sum ▁+= ▁Math ▁. ▁ceil ▁( ▁( ▁double ▁) ▁( ▁arr ▁[ ▁i ▁] ▁) ▁/ ▁( ▁double ▁) ▁( ▁x ▁) ▁) ▁; ▁} ▁int ▁total C e il Sum ▁= ▁( ▁int ▁) ▁Math ▁. ▁ceil ▁( ▁( ▁double ▁) ▁( ▁total Sum ▁) ▁/ ▁( ▁double ▁) ▁( ▁x ▁) ▁) ▁; ▁return ▁Math ▁. ▁abs ▁( ▁per Element Sum ▁- ▁total C e il Sum ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁int ▁K ▁= ▁4 ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁ceil Difference ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁count Tri pl ets ▁( ▁int ▁N ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁<= ▁N ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁i ▁* ▁j ▁> ▁N ▁) ▁break ▁; ▁ans ▁+= ▁N ▁/ ▁( ▁i ▁* ▁j ▁) ▁; ▁} ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁10 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁count Tri pl ets ▁( ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁min Step K ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁int ▁E ▁= ▁0 ▁; ▁int ▁S ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁S ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁if ▁( ▁arr ▁[ ▁i ▁] ▁% ▁2 ▁== ▁0 ▁) ▁E ▁+= ▁1 ▁; ▁} ▁if ▁( ▁S ▁>= ▁K ▁) ▁return ▁0 ▁; ▁else ▁if ▁( ▁S ▁+ ▁E ▁< ▁K ▁) ▁return ▁- ▁1 ▁; ▁else ▁return ▁K ▁- ▁S ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁int ▁K ▁= ▁4 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁min Step K ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁S ieve Of E rat ost hen es ▁( ▁int ▁n ▁, ▁boolean ▁prime ▁[ ▁] ▁) ▁{ ▁prime ▁[ ▁0 ▁] ▁= ▁false ▁; ▁prime ▁[ ▁1 ▁] ▁= ▁false ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁* ▁p ▁<= ▁n ▁; ▁p ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁p ▁] ▁== ▁true ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁p ▁* ▁p ▁; ▁i ▁<= ▁n ▁; ▁i ▁+= ▁p ▁) ▁{ ▁prime ▁[ ▁i ▁] ▁= ▁false ▁; ▁} ▁} ▁} ▁} ▁static ▁void ▁count Prime ▁( ▁int ▁n ▁) ▁{ ▁boolean ▁prime ▁[ ▁] ▁= ▁new ▁boolean ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁prime ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁prime ▁[ ▁i ▁] ▁= ▁true ▁; ▁} ▁S ieve Of E rat ost hen es ▁( ▁n ▁, ▁prime ▁) ▁; ▁int ▁dp ▁[ ▁] ▁= ▁new ▁int ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁dp ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁= ▁0 ▁; ▁} ▁dp ▁[ ▁1 ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁+= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁; ▁if ▁( ▁prime ▁[ ▁i ▁] ▁== ▁true ▁&& ▁prime ▁[ ▁i ▁- ▁2 ▁] ▁== ▁true ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁++ ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁dp ▁[ ▁n ▁] ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁6 ▁; ▁count Prime ▁( ▁N ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁sum Of S quared D ifferences ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁int ▁sum A ▁= ▁0 ▁, ▁sum B ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁sum A ▁+= ▁( ▁arr ▁[ ▁i ▁] ▁* ▁arr ▁[ ▁i ▁] ▁) ▁; ▁sum B ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁sum A ▁= ▁N ▁* ▁sum A ▁; ▁sum B ▁= ▁( ▁sum B ▁* ▁sum B ▁) ▁; ▁ans ▁= ▁sum A ▁- ▁sum B ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁ans ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁8 ▁, ▁4 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁sum Of S quared D ifferences ▁( ▁arr ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁count AP s ▁( ▁int ▁S ▁, ▁int ▁D ▁) ▁{ ▁S ▁= ▁S ▁* ▁2 ▁; ▁int ▁answer ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁Math ▁. ▁sqrt ▁( ▁S ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁S ▁% ▁i ▁== ▁0 ▁) ▁{ ▁if ▁( ▁( ▁( ▁S ▁/ ▁i ▁) ▁- ▁D ▁* ▁i ▁+ ▁D ▁) ▁% ▁2 ▁== ▁0 ▁) ▁answer ▁++ ▁; ▁if ▁( ▁( ▁D ▁* ▁i ▁- ▁( ▁S ▁/ ▁i ▁) ▁+ ▁D ▁) ▁% ▁2 ▁== ▁0 ▁) ▁answer ▁++ ▁; ▁} ▁} ▁return ▁answer ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁S ▁= ▁12 ▁, ▁D ▁= ▁1 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count AP s ▁( ▁S ▁, ▁D ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁distinct ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁Set ▁< ▁Integer ▁> ▁set ▁= ▁new ▁HashSet ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁set ▁. ▁add ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁return ▁set ▁. ▁size ▁( ▁) ▁; ▁} ▁static ▁int ▁max Sub array Sum Util ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁K ▁, ▁int ▁total Distinct ▁) ▁{ ▁if ▁( ▁K ▁> ▁N ▁) ▁return ▁0 ▁; ▁int ▁max ▁= ▁0 ▁; ▁int ▁sum ▁= ▁0 ▁; ▁Map ▁< ▁Integer ▁, ▁Integer ▁> ▁map ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁map ▁. ▁put ▁( ▁arr ▁[ ▁i ▁] ▁, ▁map ▁. ▁getOr Default ▁( ▁arr ▁[ ▁i ▁] ▁, ▁0 ▁) ▁+ ▁1 ▁) ▁; ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁if ▁( ▁i ▁>= ▁K ▁) ▁{ ▁map ▁. ▁put ▁( ▁arr ▁[ ▁i ▁- ▁K ▁] ▁, ▁map ▁. ▁get ▁( ▁arr ▁[ ▁i ▁- ▁K ▁] ▁) ▁- ▁1 ▁) ▁; ▁sum ▁-= ▁arr ▁[ ▁i ▁- ▁K ▁] ▁; ▁if ▁( ▁map ▁. ▁get ▁( ▁arr ▁[ ▁i ▁- ▁K ▁] ▁) ▁== ▁0 ▁) ▁map ▁. ▁remove ▁( ▁arr ▁[ ▁i ▁- ▁K ▁] ▁) ▁; ▁} ▁if ▁( ▁map ▁. ▁size ▁( ▁) ▁== ▁total Distinct ▁) ▁max ▁= ▁Math ▁. ▁max ▁( ▁max ▁, ▁sum ▁) ▁; ▁} ▁return ▁max ▁; ▁} ▁static ▁void ▁max Sub array Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁K ▁) ▁{ ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁int ▁total Distinct ▁= ▁distinct ▁( ▁arr ▁, ▁N ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁max Sub array Sum Util ▁( ▁arr ▁, ▁N ▁, ▁K ▁, ▁total Distinct ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁7 ▁, ▁7 ▁, ▁2 ▁, ▁4 ▁, ▁2 ▁, ▁7 ▁, ▁4 ▁, ▁6 ▁, ▁6 ▁, ▁6 ▁} ▁; ▁int ▁K ▁= ▁6 ▁; ▁max Sub array Sum ▁( ▁arr ▁, ▁K ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁process Diag onal ▁( ▁ArrayList ▁< ▁Integer ▁> ▁arr ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁int ▁getBit ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁32 ▁; ▁i ▁++ ▁) ▁{ ▁int ▁S ▁= ▁0 ▁; ▁int ▁NS ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁: ▁arr ▁) ▁{ ▁if ▁( ▁( ▁getBit ▁& ▁j ▁) ▁!= ▁0 ▁) ▁S ▁+= ▁1 ▁; ▁else ▁NS ▁+= ▁1 ▁; ▁} ▁if ▁( ▁S ▁> ▁NS ▁) ▁ans ▁+= ▁Math ▁. ▁pow ▁( ▁2 ▁, ▁i ▁) ▁; ▁getBit ▁<<= ▁1 ▁; ▁} ▁return ▁ans ▁; ▁} ▁static ▁int ▁find Sum ▁( ▁int ▁[ ▁] ▁[ ▁] ▁mat ▁) ▁{ ▁int ▁i ▁= ▁0 ▁; ▁int ▁j ▁= ▁0 ▁; ▁ArrayList ▁< ▁Integer ▁> ▁pri Diag ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁while ▁( ▁i ▁< ▁mat ▁. ▁length ▁) ▁{ ▁pri Diag ▁. ▁add ▁( ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁; ▁i ▁+= ▁1 ▁; ▁j ▁+= ▁1 ▁; ▁} ▁i ▁= ▁0 ▁; ▁j ▁= ▁mat ▁. ▁length ▁- ▁1 ▁; ▁ArrayList ▁< ▁Integer ▁> ▁sec Diag ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁while ▁( ▁i ▁< ▁mat ▁. ▁length ▁) ▁{ ▁sec Diag ▁. ▁add ▁( ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁; ▁i ▁+= ▁1 ▁; ▁j ▁-= ▁1 ▁; ▁} ▁return ▁( ▁process Diag onal ▁( ▁pri Diag ▁) ▁+ ▁process Diag onal ▁( ▁sec Diag ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁[ ▁] ▁mat ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁, ▁{ ▁4 ▁, ▁5 ▁, ▁6 ▁} ▁, ▁{ ▁7 ▁, ▁8 ▁, ▁9 ▁} ▁} ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁find Sum ▁( ▁mat ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁boolean ▁is pal in ▁( ▁int ▁num ▁) ▁{ ▁String ▁s ▁= ▁Integer ▁. ▁toString ▁( ▁num ▁) ▁; ▁int ▁st ▁= ▁0 ▁, ▁ed ▁= ▁s ▁. ▁length ▁( ▁) ▁- ▁1 ▁; ▁while ▁( ▁st ▁<= ▁ed ▁) ▁{ ▁if ▁( ▁s ▁. ▁charAt ▁( ▁st ▁) ▁!= ▁s ▁. ▁charAt ▁( ▁ed ▁) ▁) ▁return ▁false ▁; ▁st ▁++ ▁; ▁ed ▁-- ▁; ▁} ▁return ▁true ▁; ▁} ▁static ▁void ▁Calculate X OR and OR ▁( ▁int ▁n ▁) ▁{ ▁int ▁Calculate X OR ▁= ▁0 ▁; ▁int ▁Calculate OR ▁= ▁0 ▁; ▁int ▁start ▁= ▁( ▁int ▁) ▁Math ▁. ▁pow ▁( ▁10 ▁, ▁n ▁- ▁1 ▁) ▁; ▁int ▁end ▁= ▁( ▁int ▁) ▁Math ▁. ▁pow ▁( ▁10 ▁, ▁n ▁) ▁- ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁start ▁; ▁i ▁<= ▁end ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁is pal in ▁( ▁i ▁) ▁) ▁{ ▁Calculate X OR ▁= ▁Calculate X OR ▁^ ▁i ▁; ▁Calculate OR ▁= ▁Calculate OR ▁| ▁i ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁XOR ▁= ▁" ▁+ ▁Calculate X OR ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁OR ▁= ▁" ▁+ ▁Calculate OR ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁4 ▁; ▁Calculate X OR and OR ▁( ▁n ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁pow Of Positive ▁( ▁int ▁n ▁) ▁{ ▁int ▁pos ▁= ▁( ▁int ▁) ▁Math ▁. ▁floor ▁( ▁( ▁Math ▁. ▁log ▁( ▁n ▁) ▁/ ▁Math ▁. ▁log ▁( ▁2 ▁) ▁) ▁) ▁; ▁return ▁( ▁int ▁) ▁Math ▁. ▁pow ▁( ▁2 ▁, ▁pos ▁) ▁; ▁} ▁static ▁int ▁pow Of Negative ▁( ▁int ▁n ▁) ▁{ ▁int ▁pos ▁= ▁( ▁int ▁) ▁Math ▁. ▁ceil ▁( ▁( ▁Math ▁. ▁log ▁( ▁n ▁) ▁/ ▁Math ▁. ▁log ▁( ▁2 ▁) ▁) ▁) ▁; ▁return ▁( ▁int ▁) ▁( ▁- ▁1 ▁* ▁Math ▁. ▁pow ▁( ▁2 ▁, ▁pos ▁) ▁) ▁; ▁} ▁static ▁void ▁highest Power Of 2 ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁> ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁pow Of Positive ▁( ▁n ▁) ▁) ▁; ▁} ▁else ▁{ ▁n ▁= ▁- ▁n ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁pow Of Negative ▁( ▁n ▁) ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁- ▁24 ▁; ▁highest Power Of 2 ▁( ▁n ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁summ ation ▁( ▁int ▁n ▁) ▁{ ▁int ▁abs _ sum ▁= ▁n ▁* ▁( ▁n ▁+ ▁1 ▁) ▁/ ▁2 ▁; ▁int ▁sign ▁= ▁n ▁+ ▁1 ▁% ▁2 ▁== ▁0 ▁? ▁1 ▁: ▁- ▁1 ▁; ▁int ▁result _ sum ▁= ▁sign ▁* ▁abs _ sum ▁; ▁return ▁result _ sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁summ ation ▁( ▁N ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁boolean ▁is Power ▁( ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁int ▁res 1 ▁= ▁( ▁int ▁) ▁( ▁Math ▁. ▁log ▁( ▁y ▁) ▁/ ▁Math ▁. ▁log ▁( ▁x ▁) ▁) ▁; ▁double ▁res 2 ▁= ▁Math ▁. ▁log ▁( ▁y ▁) ▁/ ▁Math ▁. ▁log ▁( ▁x ▁) ▁; ▁return ▁( ▁res 1 ▁== ▁res 2 ▁) ▁; ▁} ▁static ▁int ▁count Power ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁res ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁if ▁( ▁is Power ▁( ▁arr ▁[ ▁i ▁] ▁, ▁arr ▁[ ▁j ▁] ▁) ▁|| ▁is Power ▁( ▁arr ▁[ ▁j ▁] ▁, ▁arr ▁[ ▁i ▁] ▁) ▁) ▁res ▁++ ▁; ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁16 ▁, ▁2 ▁, ▁3 ▁, ▁9 ▁} ▁; ▁int ▁n ▁= ▁a ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Power ▁( ▁a ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁int ▁no Of Cards ▁( ▁int ▁n ▁) ▁{ ▁return ▁n ▁* ▁( ▁3 ▁* ▁n ▁+ ▁1 ▁) ▁/ ▁2 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁no Of Cards ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁pair Count ▁( ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁int ▁cnt ▁= ▁0 ▁, ▁b ▁, ▁a ▁; ▁for ▁( ▁b ▁= ▁0 ▁; ▁b ▁<= ▁Math ▁. ▁sqrt ▁( ▁m ▁) ▁; ▁b ▁++ ▁) ▁{ ▁a ▁= ▁m ▁- ▁b ▁* ▁b ▁; ▁if ▁( ▁a ▁* ▁a ▁+ ▁b ▁== ▁n ▁) ▁{ ▁cnt ▁++ ▁; ▁} ▁} ▁return ▁cnt ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁9 ▁, ▁m ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁pair Count ▁( ▁n ▁, ▁m ▁) ▁+ ▁" NEW _ LINE "); ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁bin omial Co eff ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁[ ▁] ▁C ▁= ▁new ▁int ▁[ ▁k ▁+ ▁1 ▁] ▁; ▁C ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁Math ▁. ▁min ▁( ▁i ▁, ▁k ▁) ▁; ▁j ▁> ▁0 ▁; ▁j ▁-- ▁) ▁C ▁[ ▁j ▁] ▁= ▁C ▁[ ▁j ▁] ▁+ ▁C ▁[ ▁j ▁- ▁1 ▁] ▁; ▁} ▁return ▁C ▁[ ▁k ▁] ▁; ▁} ▁static ▁int ▁count _ of _ sub arrays ▁( ▁int ▁N ▁) ▁{ ▁int ▁count ▁= ▁bin omial Co eff ▁( ▁2 ▁* ▁N ▁- ▁1 ▁, ▁N ▁) ▁; ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁count _ of _ sub arrays ▁( ▁N ▁) ▁+ ▁" NEW _ LINE "); ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁Math ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁max G CD ▁( ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁int ▁min Sum ▁= ▁( ▁K ▁* ▁( ▁K ▁+ ▁1 ▁) ▁) ▁/ ▁2 ▁; ▁if ▁( ▁N ▁< ▁min Sum ▁) ▁return ▁- ▁1 ▁; ▁int ▁i ▁= ▁( ▁int ▁) ▁Math ▁. ▁sqrt ▁( ▁N ▁) ▁; ▁int ▁res ▁= ▁1 ▁; ▁while ▁( ▁i ▁>= ▁1 ▁) ▁{ ▁if ▁( ▁N ▁% ▁i ▁== ▁0 ▁) ▁{ ▁if ▁( ▁i ▁>= ▁min Sum ▁) ▁res ▁= ▁Math ▁. ▁max ▁( ▁res ▁, ▁N ▁/ ▁i ▁) ▁; ▁if ▁( ▁N ▁/ ▁i ▁>= ▁min Sum ▁) ▁res ▁= ▁Math ▁. ▁max ▁( ▁res ▁, ▁i ▁) ▁; ▁} ▁i ▁-- ▁; ▁} ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁18 ▁, ▁K ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁max G CD ▁( ▁N ▁, ▁K ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁double ▁getSum ▁( ▁int ▁n ▁) ▁{ ▁double ▁sum ▁= ▁0 ▁; ▁if ▁( ▁n ▁== ▁1 ▁) ▁{ ▁sum ▁= ▁45 .0 ▁; ▁} ▁else ▁{ ▁sum ▁= ▁( ▁99 .0 ▁/ ▁2.0 ▁) ▁* ▁Math ▁. ▁pow ▁( ▁10 ▁, ▁n ▁- ▁1 ▁) ▁* ▁Math ▁. ▁pow ▁( ▁10 ▁, ▁( ▁n ▁- ▁1 ▁) ▁/ ▁2 ▁) ▁; ▁} ▁return ▁sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁3 ▁; ▁double ▁ans ▁= ▁getSum ▁( ▁n ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁ans ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁find Min ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁m ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁m ▁= ▁Math ▁. ▁max ▁( ▁m ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁int ▁freq ▁[ ▁] ▁= ▁new ▁int ▁[ ▁m ▁+ ▁2 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁freq ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁++ ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁m ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁int ▁j ▁= ▁i ▁; ▁int ▁cnt ▁= ▁0 ▁; ▁while ▁( ▁j ▁<= ▁m ▁) ▁{ ▁cnt ▁+= ▁freq ▁[ ▁j ▁] ▁; ▁j ▁+= ▁i ▁; ▁} ▁if ▁( ▁cnt ▁== ▁0 ▁) ▁return ▁i ▁; ▁} ▁return ▁m ▁+ ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁12 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Min ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁find Min Del ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁n ▁) ▁{ ▁int ▁min _ num ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁min _ num ▁= ▁Math ▁. ▁min ▁( ▁arr ▁[ ▁i ▁] ▁, ▁min _ num ▁) ▁; ▁int ▁cnt ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁min _ num ▁) ▁cnt ▁++ ▁; ▁return ▁n ▁- ▁cnt ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁3 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁find Min Del ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁count Digits ▁( ▁int ▁n ▁) ▁{ ▁int ▁cnt ▁= ▁0 ▁; ▁while ▁( ▁n ▁> ▁0 ▁) ▁{ ▁cnt ▁++ ▁; ▁n ▁/= ▁10 ▁; ▁} ▁return ▁cnt ▁; ▁} ▁static ▁int ▁digit Pow Sum ▁( ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁int ▁pw ▁= ▁count Digits ▁( ▁n ▁) ▁; ▁while ▁( ▁n ▁> ▁0 ▁) ▁{ ▁int ▁d ▁= ▁n ▁% ▁10 ▁; ▁sum ▁+= ▁Math ▁. ▁pow ▁( ▁d ▁, ▁pw ▁) ▁; ▁pw ▁-- ▁; ▁n ▁/= ▁10 ▁; ▁} ▁return ▁sum ▁; ▁} ▁static ▁int ▁count Num ▁( ▁int ▁n ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁== ▁digit Pow Sum ▁( ▁i ▁) ▁) ▁{ ▁count ▁++ ▁; ▁} ▁} ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁200 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Num ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁perfect Square s ▁( ▁int ▁l ▁, ▁int ▁r ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁l ▁; ▁i ▁<= ▁r ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁Math ▁. ▁sqrt ▁( ▁i ▁) ▁== ▁( ▁int ▁) ▁Math ▁. ▁sqrt ▁( ▁i ▁) ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁i ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁l ▁= ▁2 ▁, ▁r ▁= ▁24 ▁; ▁perfect Square s ▁( ▁l ▁, ▁r ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁find W inner ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁( ▁n ▁- ▁1 ▁) ▁% ▁6 ▁== ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Second ▁Player ▁wins ▁the ▁game ▁" ▁) ▁; ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁First ▁Player ▁wins ▁the ▁game ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁7 ▁; ▁find W inner ▁( ▁n ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁l cm ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁int ▁GC D ▁= ▁__ g cd ▁( ▁a ▁, ▁b ▁) ▁; ▁return ▁( ▁a ▁* ▁b ▁) ▁/ ▁GC D ▁; ▁} ▁static ▁int ▁Min L CM ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁[ ▁] ▁Prefix ▁= ▁new ▁int ▁[ ▁n ▁+ ▁2 ▁] ▁; ▁int ▁[ ▁] ▁S uffix ▁= ▁new ▁int ▁[ ▁n ▁+ ▁2 ▁] ▁; ▁Prefix ▁[ ▁1 ▁] ▁= ▁a ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁n ▁; ▁i ▁+= ▁1 ▁) ▁{ ▁Prefix ▁[ ▁i ▁] ▁= ▁l cm ▁( ▁Prefix ▁[ ▁i ▁- ▁1 ▁] ▁, ▁a ▁[ ▁i ▁- ▁1 ▁] ▁) ▁; ▁} ▁S uffix ▁[ ▁n ▁] ▁= ▁a ▁[ ▁n ▁- ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁1 ▁; ▁i ▁-= ▁1 ▁) ▁{ ▁S uffix ▁[ ▁i ▁] ▁= ▁l cm ▁( ▁S uffix ▁[ ▁i ▁+ ▁1 ▁] ▁, ▁a ▁[ ▁i ▁- ▁1 ▁] ▁) ▁; ▁} ▁int ▁ans ▁= ▁Math ▁. ▁min ▁( ▁S uffix ▁[ ▁2 ▁] ▁, ▁Prefix ▁[ ▁n ▁- ▁1 ▁] ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁< ▁n ▁; ▁i ▁+= ▁1 ▁) ▁{ ▁ans ▁= ▁Math ▁. ▁min ▁( ▁ans ▁, ▁l cm ▁( ▁Prefix ▁[ ▁i ▁- ▁1 ▁] ▁, ▁S uffix ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁static ▁int ▁__ g cd ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁return ▁b ▁== ▁0 ▁? ▁a ▁: ▁__ g cd ▁( ▁b ▁, ▁a ▁% ▁b ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁15 ▁, ▁9 ▁, ▁36 ▁} ▁; ▁int ▁n ▁= ▁a ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁Min L CM ▁( ▁a ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁MOD ▁= ▁100 000000 7 ▁; ▁static ▁int ▁fact Mod ▁( ▁int ▁n ▁) ▁{ ▁long ▁fact ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁fact ▁*= ▁( ▁i ▁% ▁MOD ▁) ▁; ▁fact ▁% = ▁MOD ▁; ▁} ▁return ▁( ▁int ▁) ▁fact ▁; ▁} ▁static ▁int ▁count W ays ▁( ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁return ▁fact Mod ▁( ▁m ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁2 ▁, ▁m ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁count W ays ▁( ▁n ▁, ▁m ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁boolean ▁is Composite ▁( ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁Math ▁. ▁sqrt ▁( ▁n ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁return ▁true ▁; ▁} ▁return ▁false ▁; ▁} ▁static ▁int ▁Power ▁( ▁int ▁x ▁, ▁int ▁y ▁, ▁int ▁p ▁) ▁{ ▁int ▁res ▁= ▁1 ▁; ▁x ▁= ▁x ▁% ▁p ▁; ▁while ▁( ▁y ▁> ▁0 ▁) ▁{ ▁if ▁( ▁y ▁% ▁2 ▁== ▁1 ▁) ▁{ ▁res ▁= ▁( ▁res ▁* ▁x ▁) ▁% ▁p ▁; ▁} ▁x ▁= ▁( ▁x ▁* ▁x ▁) ▁% ▁p ▁; ▁} ▁return ▁res ▁; ▁} ▁static ▁boolean ▁is E uler P seud op r ime ▁( ▁int ▁N ▁, ▁int ▁A ▁) ▁{ ▁if ▁( ▁A ▁<= ▁0 ▁) ▁return ▁false ▁; ▁if ▁( ▁N ▁% ▁2 ▁== ▁0 ▁|| ▁! ▁is Composite ▁( ▁N ▁) ▁) ▁return ▁false ▁; ▁if ▁( ▁__ g cd ▁( ▁A ▁, ▁N ▁) ▁!= ▁1 ▁) ▁return ▁false ▁; ▁int ▁mod ▁= ▁Power ▁( ▁A ▁, ▁( ▁N ▁- ▁1 ▁) ▁/ ▁2 ▁, ▁N ▁) ▁; ▁if ▁( ▁mod ▁!= ▁1 ▁&& ▁mod ▁!= ▁N ▁- ▁1 ▁) ▁return ▁false ▁; ▁return ▁true ▁; ▁} ▁static ▁int ▁__ g cd ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁if ▁( ▁b ▁== ▁0 ▁) ▁return ▁a ▁; ▁return ▁__ g cd ▁( ▁b ▁, ▁a ▁% ▁b ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁12 1 ▁, ▁A ▁= ▁3 ▁; ▁if ▁( ▁is E uler P seud op r ime ▁( ▁N ▁, ▁A ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁geom etric Mean ▁( ▁int ▁n ▁) ▁{ ▁return ▁( ▁int ▁) ▁Math ▁. ▁sqrt ▁( ▁n ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁16 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁geom etric Mean ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁find _ k ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁if ▁( ▁( ▁a ▁+ ▁b ▁) ▁% ▁2 ▁== ▁0 ▁) ▁return ▁( ▁( ▁a ▁+ ▁b ▁) ▁/ ▁2 ▁) ▁; ▁return ▁- ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁= ▁2 ▁, ▁b ▁= ▁16 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find _ k ▁( ▁a ▁, ▁b ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁cnt Sub Sets ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁max Val ▁= ▁Arrays ▁. ▁stream ▁( ▁arr ▁) ▁. ▁max ▁( ▁) ▁. ▁getAs Int ▁( ▁) ▁; ▁int ▁cnt ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁max Val ▁) ▁cnt ▁++ ▁; ▁} ▁return ▁( ▁int ▁) ▁( ▁Math ▁. ▁pow ▁( ▁2 ▁, ▁cnt ▁) ▁- ▁1 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁1 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁cnt Sub Sets ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁getSum ▁( ▁int ▁n ▁) ▁{ ▁return ▁( ▁( ▁n ▁- ▁1 ▁) ▁+ ▁( ▁int ▁) ▁Math ▁. ▁pow ▁( ▁n ▁, ▁2 ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁getSum ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁cnt Edges ▁( ▁int ▁n ▁) ▁{ ▁int ▁edges ▁= ▁( ▁int ▁) ▁Math ▁. ▁pow ▁( ▁2 ▁, ▁n ▁) ▁- ▁2 ▁; ▁return ▁edges ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁4 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁cnt Edges ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁count ▁( ▁int ▁n ▁) ▁{ ▁return ▁( ▁int ▁) ▁( ▁15 ▁* ▁Math ▁. ▁pow ▁( ▁16 ▁, ▁n ▁- ▁1 ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁float ▁find Prob ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁long ▁max Sum ▁= ▁Integer ▁. ▁MIN _ VALUE ▁, ▁max Count ▁= ▁0 ▁, ▁total Pairs ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁int ▁sum ▁= ▁arr ▁[ ▁i ▁] ▁+ ▁arr ▁[ ▁j ▁] ▁; ▁if ▁( ▁sum ▁== ▁max Sum ▁) ▁{ ▁max Count ▁++ ▁; ▁} ▁else ▁if ▁( ▁sum ▁> ▁max Sum ▁) ▁{ ▁max Sum ▁= ▁sum ▁; ▁max Count ▁= ▁1 ▁; ▁} ▁total Pairs ▁++ ▁; ▁} ▁} ▁float ▁prob ▁= ▁( ▁float ▁) ▁max Count ▁/ ▁( ▁float ▁) ▁total Pairs ▁; ▁return ▁prob ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁2 ▁, ▁2 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Prob ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁previous F ib onacci ▁( ▁int ▁n ▁) ▁{ ▁double ▁a ▁= ▁n ▁/ ▁( ▁( ▁1 ▁+ ▁Math ▁. ▁sqrt ▁( ▁5 ▁) ▁) ▁/ ▁2.0 ▁) ▁; ▁return ▁( ▁int ▁) ▁Math ▁. ▁round ▁( ▁a ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁8 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁previous F ib onacci ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁count ▁( ▁int ▁n ▁) ▁{ ▁return ▁3 ▁* ▁n ▁* ▁( ▁n ▁- ▁1 ▁) ▁+ ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁ways ▁( ▁int ▁n ▁) ▁{ ▁return ▁n ▁/ ▁2 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁ways ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁find Min Value ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁long ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁return ▁( ▁( ▁int ▁) ▁( ▁sum ▁/ ▁n ▁) ▁+ ▁1 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁2 ▁, ▁1 ▁, ▁10 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁find Min Value ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁sum Pairs ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁= ▁sum ▁+ ▁( ▁arr ▁[ ▁i ▁] ▁* ▁( ▁2 ▁* ▁n ▁) ▁) ▁; ▁} ▁return ▁sum ▁; ▁} ▁static ▁public ▁void ▁main ▁( ▁String ▁[ ▁] ▁arg ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁sum Pairs ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁min Sum ▁( ▁Integer ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁Arrays ▁. ▁sort ▁( ▁arr ▁, ▁Collections ▁. ▁reverse Order ▁( ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁% ▁4 ▁< ▁2 ▁) ▁sum ▁= ▁sum ▁+ ▁arr ▁[ ▁i ▁] ▁; ▁} ▁return ▁sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Integer ▁[ ▁] ▁arr ▁= ▁{ ▁1 ▁, ▁1 ▁, ▁10 ▁, ▁2 ▁, ▁2 ▁, ▁2 ▁, ▁1 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁min Sum ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁long ▁getCount ▁( ▁int ▁A ▁, ▁int ▁B 2 ▁, ▁int ▁C ▁) ▁{ ▁long ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁A ▁; ▁i ▁++ ▁) ▁{ ▁long ▁j ▁= ▁( ▁B 2 ▁/ ▁i ▁) ▁+ ▁1 ▁; ▁if ▁( ▁C ▁>= ▁j ▁) ▁count ▁= ▁( ▁count ▁+ ▁C ▁- ▁j ▁+ ▁1 ▁) ▁; ▁if ▁( ▁A ▁>= ▁j ▁&& ▁C ▁>= ▁i ▁) ▁count ▁= ▁( ▁count ▁+ ▁( ▁C ▁- ▁i ▁+ ▁1 ▁) ▁* ▁( ▁A ▁- ▁j ▁+ ▁1 ▁) ▁) ▁; ▁if ▁( ▁A ▁>= ▁j ▁) ▁A ▁= ▁( ▁int ▁) ▁( ▁j ▁- ▁1 ▁) ▁; ▁} ▁return ▁count ▁; ▁} ▁static ▁long ▁count Tri pl ets ▁( ▁int ▁A ▁, ▁int ▁B ▁, ▁int ▁C ▁) ▁{ ▁long ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁B ▁; ▁i ▁++ ▁) ▁{ ▁ans ▁= ▁( ▁ans ▁+ ▁getCount ▁( ▁A ▁, ▁i ▁* ▁i ▁, ▁C ▁) ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁A ▁, ▁B ▁, ▁C ▁; ▁A ▁= ▁3 ▁; ▁B ▁= ▁2 ▁; ▁C ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Tri pl ets ▁( ▁A ▁, ▁B ▁, ▁C ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁sum ▁( ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁( ▁n ▁* ▁( ▁n ▁+ ▁1 ▁) ▁) ▁/ ▁2 ▁; ▁return ▁sum ▁; ▁} ▁static ▁int ▁repeated Sum ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁k ▁; ▁i ▁++ ▁) ▁{ ▁n ▁= ▁sum ▁( ▁n ▁) ▁; ▁} ▁return ▁n ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁2 ▁, ▁k ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁repeated Sum ▁( ▁n ▁, ▁k ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁MAX ▁= ▁100000 ▁; ▁static ▁boolean ▁[ ▁] ▁prime ▁= ▁new ▁boolean ▁[ ▁MAX ▁+ ▁1 ▁] ▁; ▁static ▁void ▁S ieve Of E rat ost hen es ▁( ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁MAX ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁prime ▁[ ▁i ▁] ▁= ▁true ▁; ▁} ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁* ▁p ▁<= ▁MAX ▁; ▁p ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁p ▁] ▁== ▁true ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁p ▁* ▁p ▁; ▁i ▁<= ▁MAX ▁; ▁i ▁+= ▁p ▁) ▁prime ▁[ ▁i ▁] ▁= ▁false ▁; ▁} ▁} ▁} ▁static ▁int ▁smallest Prime ▁( ▁int ▁d ▁) ▁{ ▁int ▁l ▁= ▁( ▁int ▁) ▁Math ▁. ▁pow ▁( ▁10 ▁, ▁d ▁- ▁1 ▁) ▁; ▁int ▁r ▁= ▁( ▁int ▁) ▁Math ▁. ▁pow ▁( ▁10 ▁, ▁d ▁) ▁- ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁l ▁; ▁i ▁<= ▁r ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁i ▁] ▁) ▁{ ▁return ▁i ▁; ▁} ▁} ▁return ▁- ▁1 ▁; ▁} ▁static ▁int ▁largest Prime ▁( ▁int ▁d ▁) ▁{ ▁int ▁l ▁= ▁( ▁int ▁) ▁Math ▁. ▁pow ▁( ▁10 ▁, ▁d ▁- ▁1 ▁) ▁; ▁int ▁r ▁= ▁( ▁int ▁) ▁Math ▁. ▁pow ▁( ▁10 ▁, ▁d ▁) ▁- ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁r ▁; ▁i ▁>= ▁l ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁i ▁] ▁) ▁{ ▁return ▁i ▁; ▁} ▁} ▁return ▁- ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁S ieve Of E rat ost hen es ▁( ▁) ▁; ▁int ▁queries ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁5 ▁} ▁; ▁int ▁q ▁= ▁queries ▁. ▁length ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁q ▁; ▁i ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁smallest Prime ▁( ▁queries ▁[ ▁i ▁] ▁) ▁+ ▁" ▁" ▁+ ▁largest Prime ▁( ▁queries ▁[ ▁i ▁] ▁) ▁) ▁; ▁} ▁} ▁}
▁import ▁java ▁. ▁math ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁boolean ▁possible ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁> ▁3 ▁) ▁{ ▁int ▁sum ▁= ▁( ▁n ▁* ▁( ▁n ▁+ ▁1 ▁) ▁) ▁/ ▁2 ▁; ▁if ▁( ▁sum ▁% ▁3 ▁== ▁0 ▁) ▁{ ▁return ▁true ▁; ▁} ▁} ▁return ▁false ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁5 ▁; ▁if ▁( ▁possible ▁( ▁n ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁math ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁void ▁check Type ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁0 ▁] ▁<= ▁arr ▁[ ▁1 ▁] ▁&& ▁arr ▁[ ▁n ▁- ▁2 ▁] ▁<= ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁In cre asing ▁" ▁) ▁; ▁else ▁if ▁( ▁arr ▁[ ▁0 ▁] ▁>= ▁arr ▁[ ▁1 ▁] ▁&& ▁arr ▁[ ▁n ▁- ▁2 ▁] ▁>= ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Dec re asing ▁" ▁) ▁; ▁else ▁if ▁( ▁arr ▁[ ▁0 ▁] ▁<= ▁arr ▁[ ▁1 ▁] ▁&& ▁arr ▁[ ▁n ▁- ▁2 ▁] ▁>= ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁In cre asing ▁then ▁decre asing ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Dec re asing ▁then ▁increasing ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁new ▁int ▁[ ▁] ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁check Type ▁( ▁arr ▁, ▁n ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁double ▁sum ▁( ▁double ▁a ▁, ▁double ▁b ▁, ▁double ▁c ▁, ▁double ▁d ▁, ▁double ▁x ▁) ▁{ ▁double ▁ans ▁= ▁( ▁x ▁* ▁( ▁a ▁+ ▁b ▁) ▁* ▁( ▁c ▁- ▁d ▁) ▁) ▁/ ▁( ▁( ▁a ▁* ▁d ▁) ▁- ▁( ▁b ▁* ▁c ▁) ▁) ▁; ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁double ▁a ▁= ▁1 ▁, ▁b ▁= ▁2 ▁, ▁c ▁= ▁9 ▁, ▁d ▁= ▁13 ▁, ▁x ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁sum ▁( ▁a ▁, ▁b ▁, ▁c ▁, ▁d ▁, ▁x ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁print Roots ▁( ▁long ▁a ▁, ▁long ▁b ▁, ▁long ▁c ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁1 ▁+ ▁" ▁, ▁" ▁+ ▁c ▁/ ▁( ▁a ▁* ▁1.0 ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁long ▁a ▁= ▁2 ▁; ▁long ▁b ▁= ▁3 ▁; ▁long ▁c ▁= ▁- ▁5 ▁; ▁print Roots ▁( ▁a ▁, ▁b ▁, ▁c ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁Max _ sum ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁pos ▁= ▁0 ▁, ▁neg ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁> ▁0 ▁) ▁pos ▁= ▁1 ▁; ▁else ▁if ▁( ▁a ▁[ ▁i ▁] ▁< ▁0 ▁) ▁neg ▁= ▁1 ▁; ▁if ▁( ▁( ▁pos ▁== ▁1 ▁) ▁&& ▁( ▁neg ▁== ▁1 ▁) ▁) ▁break ▁; ▁} ▁int ▁sum ▁= ▁0 ▁; ▁if ▁( ▁( ▁pos ▁== ▁1 ▁) ▁&& ▁( ▁neg ▁== ▁1 ▁) ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁sum ▁+= ▁Math ▁. ▁abs ▁( ▁a ▁[ ▁i ▁] ▁) ▁; ▁} ▁else ▁if ▁( ▁pos ▁== ▁1 ▁) ▁{ ▁int ▁mini ▁= ▁a ▁[ ▁0 ▁] ▁; ▁sum ▁= ▁a ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁mini ▁= ▁Math ▁. ▁min ▁( ▁mini ▁, ▁a ▁[ ▁i ▁] ▁) ▁; ▁sum ▁+= ▁a ▁[ ▁i ▁] ▁; ▁} ▁sum ▁-= ▁2 ▁* ▁mini ▁; ▁} ▁else ▁if ▁( ▁neg ▁== ▁1 ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁a ▁[ ▁i ▁] ▁= ▁Math ▁. ▁abs ▁( ▁a ▁[ ▁i ▁] ▁) ▁; ▁int ▁mini ▁= ▁a ▁[ ▁0 ▁] ▁; ▁sum ▁= ▁a ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁mini ▁= ▁Math ▁. ▁min ▁( ▁mini ▁, ▁a ▁[ ▁i ▁] ▁) ▁; ▁sum ▁+= ▁a ▁[ ▁i ▁] ▁; ▁} ▁sum ▁-= ▁2 ▁* ▁mini ▁; ▁} ▁return ▁sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁a ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁5 ▁, ▁- ▁2 ▁, ▁- ▁6 ▁} ▁; ▁int ▁n ▁= ▁a ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁Max _ sum ▁( ▁a ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁decimal To Binary ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁"0" ▁) ▁; ▁return ▁; ▁} ▁decimal To Binary ▁( ▁n ▁/ ▁2 ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁n ▁% ▁2 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁13 ▁; ▁decimal To Binary ▁( ▁n ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁Vert ices ▁( ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁int ▁val ▁= ▁Math ▁. ▁abs ▁( ▁x ▁) ▁+ ▁Math ▁. ▁abs ▁( ▁y ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁val ▁* ▁( ▁x ▁< ▁0 ▁? ▁- ▁1 ▁: ▁1 ▁) ▁+ ▁" ▁0 ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁"0 ▁" ▁+ ▁val ▁* ▁( ▁y ▁< ▁0 ▁? ▁- ▁1 ▁: ▁1 ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁x ▁= ▁3 ▁, ▁y ▁= ▁3 ▁; ▁Vert ices ▁( ▁x ▁, ▁y ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁MAX ▁= ▁32 ▁; ▁static ▁int ▁count Set Bits ▁( ▁int ▁n ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁while ▁( ▁n ▁> ▁0 ▁) ▁{ ▁n ▁&= ▁( ▁n ▁- ▁1 ▁) ▁; ▁count ▁++ ▁; ▁} ▁return ▁count ▁; ▁} ▁static ▁int ▁pairs ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁int ▁[ ▁] ▁f ▁= ▁new ▁int ▁[ ▁MAX ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁f ▁[ ▁count Set Bits ▁( ▁arr ▁[ ▁i ▁] ▁) ▁] ▁++ ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁MAX ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁<= ▁MAX ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁i ▁+ ▁j ▁== ▁k ▁) ▁{ ▁if ▁( ▁i ▁== ▁j ▁) ▁count ▁+= ▁( ▁( ▁f ▁[ ▁i ▁] ▁* ▁( ▁f ▁[ ▁i ▁] ▁- ▁1 ▁) ▁) ▁/ ▁2 ▁) ▁; ▁else ▁count ▁+= ▁( ▁f ▁[ ▁i ▁] ▁* ▁f ▁[ ▁j ▁] ▁) ▁; ▁} ▁} ▁} ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁int ▁k ▁= ▁4 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁pairs ▁( ▁arr ▁, ▁n ▁, ▁k ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁cnt _ neg ▁; ▁static ▁boolean ▁exists _ zero ▁; ▁static ▁void ▁pre Process ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁0 ▁) ▁cnt _ neg ▁++ ▁; ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁0 ▁) ▁exists _ zero ▁= ▁true ▁; ▁} ▁} ▁static ▁boolean ▁isP ossible ▁( ▁int ▁k ▁) ▁{ ▁if ▁( ▁! ▁exists _ zero ▁) ▁{ ▁if ▁( ▁k ▁>= ▁cnt _ neg ▁&& ▁( ▁k ▁- ▁cnt _ neg ▁) ▁% ▁2 ▁== ▁0 ▁) ▁return ▁true ▁; ▁else ▁return ▁false ▁; ▁} ▁else ▁{ ▁if ▁( ▁k ▁>= ▁cnt _ neg ▁) ▁return ▁true ▁; ▁else ▁return ▁false ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁- ▁1 ▁, ▁2 ▁, ▁- ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁pre Process ▁( ▁arr ▁, ▁n ▁) ▁; ▁int ▁queries ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁q ▁= ▁arr ▁. ▁length ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁q ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁isP ossible ▁( ▁queries ▁[ ▁i ▁] ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁MAX ▁= ▁1000000 ▁; ▁static ▁int ▁[ ▁] ▁prime ▁= ▁new ▁int ▁[ ▁MAX ▁+ ▁1 ▁] ▁; ▁static ▁void ▁update Pr imes ▁( ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁MAX ▁; ▁i ▁++ ▁) ▁{ ▁prime ▁[ ▁i ▁] ▁= ▁1 ▁; ▁} ▁prime ▁[ ▁0 ▁] ▁= ▁prime ▁[ ▁1 ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁* ▁i ▁<= ▁MAX ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁i ▁] ▁== ▁1 ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁* ▁i ▁; ▁j ▁<= ▁MAX ▁; ▁j ▁+= ▁i ▁) ▁{ ▁prime ▁[ ▁j ▁] ▁= ▁0 ▁; ▁} ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁MAX ▁; ▁i ▁++ ▁) ▁{ ▁prime ▁[ ▁i ▁] ▁+= ▁prime ▁[ ▁i ▁- ▁1 ▁] ▁; ▁} ▁} ▁static ▁int ▁getD ifference ▁( ▁int ▁l ▁, ▁int ▁r ▁) ▁{ ▁int ▁total ▁= ▁r ▁- ▁l ▁+ ▁1 ▁; ▁int ▁primes ▁= ▁prime ▁[ ▁r ▁] ▁- ▁prime ▁[ ▁l ▁- ▁1 ▁] ▁; ▁int ▁comp osit es ▁= ▁total ▁- ▁primes ▁; ▁return ▁( ▁Math ▁. ▁abs ▁( ▁primes ▁- ▁comp osit es ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁queries ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁10 ▁} ▁, ▁{ ▁5 ▁, ▁30 ▁} ▁} ▁; ▁int ▁q ▁= ▁queries ▁. ▁length ▁; ▁update Pr imes ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁q ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁getD ifference ▁( ▁queries ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁, ▁queries ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁find Index ▁( ▁int ▁[ ▁] ▁a ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁index ▁= ▁- ▁1 ▁, ▁max _ ceil ▁= ▁Integer ▁. ▁MIN _ VALUE ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁a ▁[ ▁i ▁] ▁= ▁( ▁a ▁[ ▁i ▁] ▁+ ▁k ▁- ▁1 ▁) ▁/ ▁k ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁>= ▁max _ ceil ▁) ▁{ ▁max _ ceil ▁= ▁a ▁[ ▁i ▁] ▁; ▁index ▁= ▁i ▁; ▁} ▁} ▁return ▁index ▁; ▁} ▁static ▁public ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁31 ▁, ▁12 ▁, ▁25 ▁, ▁27 ▁, ▁32 ▁, ▁19 ▁} ▁; ▁int ▁K ▁= ▁5 ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁find Index ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁Count _ Segment ▁( ▁int ▁p ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁int ▁[ ▁] ▁upto ▁= ▁new ▁int ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁upto ▁[ ▁i ▁] ▁= ▁0 ▁; ▁int ▁j ▁= ▁0 ▁, ▁curr ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁p ▁[ ▁i ▁] ▁> ▁p ▁[ ▁i ▁- ▁1 ▁] ▁&& ▁p ▁[ ▁i ▁] ▁> ▁p ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁{ ▁curr ▁= ▁p ▁[ ▁i ▁] ▁; ▁j ▁= ▁i ▁- ▁1 ▁; ▁while ▁( ▁j ▁>= ▁0 ▁&& ▁p ▁[ ▁j ▁] ▁< ▁curr ▁) ▁{ ▁upto ▁[ ▁p ▁[ ▁j ▁] ▁] ▁= ▁curr ▁; ▁j ▁-= ▁1 ▁; ▁} ▁j ▁= ▁i ▁+ ▁1 ▁; ▁while ▁( ▁j ▁< ▁n ▁&& ▁p ▁[ ▁j ▁] ▁< ▁curr ▁) ▁{ ▁if ▁( ▁upto ▁[ ▁curr ▁- ▁p ▁[ ▁j ▁] ▁] ▁== ▁curr ▁) ▁count ▁+= ▁1 ▁; ▁j ▁+= ▁1 ▁; ▁} ▁} ▁} ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁p ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁4 ▁, ▁1 ▁, ▁5 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁p ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁Count _ Segment ▁( ▁p ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁valid Position ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁int ▁count ▁= ▁0 ▁, ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁K ▁) ▁> ▁( ▁sum ▁- ▁arr ▁[ ▁i ▁] ▁) ▁) ▁count ▁++ ▁; ▁} ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁1 ▁, ▁6 ▁, ▁7 ▁} ▁, ▁K ▁= ▁4 ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁valid Position ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁N ▁= ▁1000 ▁; ▁static ▁int ▁count Pairs ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁size ▁= ▁( ▁2 ▁* ▁N ▁) ▁+ ▁1 ▁; ▁int ▁freq ▁[ ▁] ▁= ▁new ▁int ▁[ ▁size ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁x ▁= ▁arr ▁[ ▁i ▁] ▁; ▁freq ▁[ ▁x ▁+ ▁N ▁] ▁++ ▁; ▁} ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁freq ▁[ ▁i ▁] ▁> ▁0 ▁) ▁{ ▁ans ▁+= ▁( ▁( ▁freq ▁[ ▁i ▁] ▁) ▁* ▁( ▁freq ▁[ ▁i ▁] ▁- ▁1 ▁) ▁) ▁/ ▁2 ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁2 ▁; ▁j ▁< ▁2001 ▁; ▁j ▁+= ▁2 ▁) ▁{ ▁if ▁( ▁freq ▁[ ▁j ▁] ▁> ▁0 ▁&& ▁( ▁freq ▁[ ▁( ▁i ▁+ ▁j ▁) ▁/ ▁2 ▁] ▁> ▁0 ▁) ▁) ▁{ ▁ans ▁+= ▁( ▁freq ▁[ ▁i ▁] ▁* ▁freq ▁[ ▁j ▁] ▁) ▁; ▁} ▁} ▁} ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁2 ▁, ▁5 ▁, ▁1 ▁, ▁3 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Pairs ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁highest Power ▁( ▁String ▁str ▁, ▁int ▁len ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁len ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'0' ▁) ▁ans ▁++ ▁; ▁else ▁break ▁; ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁"100 100 " ▁; ▁int ▁len ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁highest Power ▁( ▁str ▁, ▁len ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁boolean ▁isP ossible ▁( ▁int ▁n ▁) ▁{ ▁int ▁fac ▁[ ▁] ▁= ▁new ▁int ▁[ ▁10 ▁] ▁; ▁fac ▁[ ▁0 ▁] ▁= ▁fac ▁[ ▁1 ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁< ▁10 ▁; ▁i ▁++ ▁) ▁fac ▁[ ▁i ▁] ▁= ▁fac ▁[ ▁i ▁- ▁1 ▁] ▁* ▁i ▁; ▁int ▁sum ▁= ▁0 ▁; ▁int ▁x ▁= ▁n ▁; ▁while ▁( ▁x ▁!= ▁0 ▁) ▁{ ▁sum ▁+= ▁fac ▁[ ▁x ▁% ▁10 ▁] ▁; ▁x ▁/= ▁10 ▁; ▁} ▁if ▁( ▁sum ▁% ▁n ▁== ▁0 ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁19 ▁; ▁if ▁( ▁isP ossible ▁( ▁n ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁is Perf ect Square ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁n ▁) ▁{ ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁u map ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁u map ▁. ▁containsKey ▁( ▁arr ▁[ ▁i ▁] ▁) ▁) ▁u map ▁. ▁put ▁( ▁arr ▁[ ▁i ▁] ▁, ▁u map ▁. ▁get ▁( ▁arr ▁[ ▁i ▁] ▁) ▁+ ▁1 ▁) ▁; ▁else ▁u map ▁. ▁put ▁( ▁arr ▁[ ▁i ▁] ▁, ▁1 ▁) ▁; ▁} ▁Iterator ▁< ▁Map ▁. ▁Entry ▁< ▁Integer ▁, ▁Integer ▁> ▁> ▁iterator ▁= ▁u map ▁. ▁entrySet ▁( ▁) ▁. ▁iterator ▁( ▁) ▁; ▁while ▁( ▁iterator ▁. ▁hasNext ▁( ▁) ▁) ▁{ ▁Map ▁. ▁Entry ▁< ▁Integer ▁, ▁Integer ▁> ▁entry ▁= ▁iterator ▁. ▁next ▁( ▁) ▁; ▁if ▁( ▁entry ▁. ▁getValue ▁( ▁) ▁% ▁2 ▁== ▁1 ▁) ▁return ▁false ▁; ▁} ▁return ▁true ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁2 ▁, ▁7 ▁, ▁7 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁if ▁( ▁is Perf ect Square ▁( ▁arr ▁, ▁n ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁print Max Val Pair ▁( ▁Vector ▁< ▁Long ▁> ▁v ▁, ▁int ▁n ▁) ▁{ ▁Collections ▁. ▁sort ▁( ▁v ▁) ▁; ▁long ▁N ▁= ▁v ▁. ▁get ▁( ▁( ▁int ▁) ▁n ▁- ▁1 ▁) ▁; ▁if ▁( ▁N ▁% ▁2 ▁== ▁1 ▁) ▁{ ▁long ▁first _ max ima ▁= ▁N ▁/ ▁2 ▁; ▁long ▁second _ max ima ▁= ▁first _ max ima ▁+ ▁1 ▁; ▁long ▁ans 1 ▁= ▁( ▁long ▁) ▁3 e 18 ▁, ▁ans 2 ▁= ▁( ▁long ▁) ▁3 e 18 ▁; ▁long ▁from _ left ▁= ▁- ▁1 ▁, ▁from _ right ▁= ▁- ▁1 ▁; ▁long ▁from ▁= ▁- ▁1 ▁; ▁for ▁( ▁long ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁v ▁. ▁get ▁( ▁( ▁int ▁) ▁i ▁) ▁> ▁first _ max ima ▁) ▁{ ▁from ▁= ▁i ▁; ▁break ▁; ▁} ▁else ▁{ ▁long ▁diff ▁= ▁first _ max ima ▁- ▁v ▁. ▁get ▁( ▁( ▁int ▁) ▁i ▁) ▁; ▁if ▁( ▁diff ▁< ▁ans 1 ▁) ▁{ ▁ans 1 ▁= ▁diff ▁; ▁from _ left ▁= ▁v ▁. ▁get ▁( ▁( ▁int ▁) ▁i ▁) ▁; ▁} ▁} ▁} ▁from _ right ▁= ▁v ▁. ▁get ▁( ▁( ▁int ▁) ▁from ▁) ▁; ▁long ▁diff 1 ▁= ▁first _ max ima ▁- ▁from _ left ▁; ▁long ▁diff 2 ▁= ▁from _ right ▁- ▁second _ max ima ▁; ▁if ▁( ▁diff 1 ▁< ▁diff 2 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁N ▁+ ▁" ▁" ▁+ ▁from _ left ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁N ▁+ ▁" ▁" ▁+ ▁from _ right ▁) ▁; ▁} ▁else ▁{ ▁long ▁max ima ▁= ▁N ▁/ ▁2 ▁; ▁long ▁ans 1 ▁= ▁( ▁int ▁) ▁3 e 18 ▁; ▁long ▁R ▁= ▁- ▁1 ▁; ▁for ▁( ▁long ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁++ ▁i ▁) ▁{ ▁long ▁diff ▁= ▁Math ▁. ▁abs ▁( ▁v ▁. ▁get ▁( ▁( ▁int ▁) ▁i ▁) ▁- ▁max ima ▁) ▁; ▁if ▁( ▁diff ▁< ▁ans 1 ▁) ▁{ ▁ans 1 ▁= ▁diff ▁; ▁R ▁= ▁v ▁. ▁get ▁( ▁( ▁int ▁) ▁i ▁) ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁N ▁+ ▁" ▁" ▁+
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁count Quad ru ples ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁mp ▁= ▁new ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁mp ▁. ▁containsKey ▁( ▁a ▁[ ▁i ▁] ▁) ▁) ▁{ ▁mp ▁. ▁put ▁( ▁a ▁[ ▁i ▁] ▁, ▁mp ▁. ▁get ▁( ▁a ▁[ ▁i ▁] ▁) ▁+ ▁1 ▁) ▁; ▁} ▁else ▁{ ▁mp ▁. ▁put ▁( ▁a ▁[ ▁i ▁] ▁, ▁1 ▁) ▁; ▁} ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁for ▁( ▁int ▁k ▁= ▁0 ▁; ▁k ▁< ▁n ▁; ▁k ▁++ ▁) ▁{ ▁if ▁( ▁j ▁== ▁k ▁) ▁continue ▁; ▁mp ▁. ▁put ▁( ▁a ▁[ ▁j ▁] ▁, ▁mp ▁. ▁get ▁( ▁a ▁[ ▁j ▁] ▁) ▁- ▁1 ▁) ▁; ▁mp ▁. ▁put ▁( ▁a ▁[ ▁k ▁] ▁, ▁mp ▁. ▁get ▁( ▁a ▁[ ▁k ▁] ▁) ▁- ▁1 ▁) ▁; ▁int ▁first ▁= ▁a ▁[ ▁j ▁] ▁- ▁( ▁a ▁[ ▁k ▁] ▁- ▁a ▁[ ▁j ▁] ▁) ▁; ▁int ▁fourth ▁= ▁( ▁a ▁[ ▁k ▁] ▁* ▁a ▁[ ▁k ▁] ▁) ▁/ ▁a ▁[ ▁j ▁] ▁; ▁if ▁( ▁( ▁a ▁[ ▁k ▁] ▁* ▁a ▁[ ▁k ▁] ▁) ▁% ▁a ▁[ ▁j ▁] ▁== ▁0 ▁) ▁{ ▁if ▁( ▁a ▁[ ▁j ▁] ▁!= ▁a ▁[ ▁k ▁] ▁) ▁{ ▁if ▁( ▁mp ▁. ▁containsKey ▁( ▁first ▁) ▁&& ▁mp ▁. ▁containsKey ▁( ▁fourth ▁) ▁) ▁count ▁+= ▁mp ▁. ▁get ▁( ▁first ▁) ▁* ▁mp ▁. ▁get ▁( ▁fourth ▁) ▁; ▁} ▁else ▁if ▁( ▁mp ▁. ▁containsKey ▁( ▁first ▁) ▁&& ▁mp ▁. ▁containsKey ▁( ▁fourth ▁) ▁) ▁count ▁+= ▁mp ▁. ▁get ▁( ▁first ▁) ▁* ▁( ▁mp ▁. ▁get ▁( ▁fourth ▁) ▁- ▁1 ▁) ▁; ▁} ▁if ▁( ▁mp ▁. ▁containsKey ▁( ▁a ▁[ ▁j ▁] ▁) ▁) ▁{ ▁mp ▁. ▁put ▁( ▁a ▁[ ▁j ▁] ▁, ▁mp ▁. ▁get ▁( ▁a ▁[ ▁j ▁] ▁) ▁+ ▁1 ▁) ▁; ▁} ▁else ▁{ ▁mp ▁. ▁put ▁( ▁a ▁[ ▁j ▁] ▁, ▁1 ▁) ▁; ▁} ▁if ▁( ▁mp ▁. ▁containsKey
▁class ▁Sol ▁{ ▁static ▁int ▁getPosition ▁( ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁if ▁( ▁m ▁> ▁( ▁n ▁/ ▁2 ▁) ▁) ▁return ▁( ▁m ▁- ▁( ▁n ▁/ ▁2 ▁) ▁) ▁; ▁return ▁( ▁m ▁+ ▁( ▁n ▁/ ▁2 ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁8 ▁, ▁m ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁getPosition ▁( ▁n ▁, ▁m ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁par ity ▁( ▁int ▁a ▁) ▁{ ▁return ▁a ▁% ▁3 ▁; ▁} ▁static ▁int ▁solve ▁( ▁int ▁[ ▁] ▁array ▁, ▁int ▁size ▁) ▁{ ▁int ▁operations ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁par ity ▁( ▁array ▁[ ▁i ▁] ▁) ▁== ▁par ity ▁( ▁array ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁) ▁{ ▁operations ▁++ ▁; ▁if ▁( ▁i ▁+ ▁2 ▁< ▁size ▁) ▁{ ▁int ▁par i 1 ▁= ▁par ity ▁( ▁array ▁[ ▁i ▁] ▁) ▁; ▁int ▁par i 2 ▁= ▁par ity ▁( ▁array ▁[ ▁i ▁+ ▁2 ▁] ▁) ▁; ▁if ▁( ▁par i 1 ▁== ▁par i 2 ▁) ▁{ ▁if ▁( ▁par i 1 ▁== ▁0 ▁) ▁array ▁[ ▁i ▁+ ▁1 ▁] ▁= ▁1 ▁; ▁else ▁if ▁( ▁par i 1 ▁== ▁1 ▁) ▁array ▁[ ▁i ▁+ ▁1 ▁] ▁= ▁0 ▁; ▁else ▁array ▁[ ▁i ▁+ ▁1 ▁] ▁= ▁1 ▁; ▁} ▁else ▁{ ▁if ▁( ▁( ▁par i 1 ▁== ▁0 ▁&& ▁par i 2 ▁== ▁1 ▁) ▁|| ▁( ▁par i 1 ▁== ▁1 ▁&& ▁par i 2 ▁== ▁0 ▁) ▁) ▁array ▁[ ▁i ▁+ ▁1 ▁] ▁= ▁2 ▁; ▁if ▁( ▁( ▁par i 1 ▁== ▁1 ▁&& ▁par i 2 ▁== ▁2 ▁) ▁|| ▁( ▁par i 1 ▁== ▁2 ▁&& ▁par i 2 ▁== ▁1 ▁) ▁) ▁array ▁[ ▁i ▁+ ▁1 ▁] ▁= ▁0 ▁; ▁if ▁( ▁( ▁par i 1 ▁== ▁2 ▁&& ▁par i 2 ▁== ▁0 ▁) ▁|| ▁( ▁par i 1 ▁== ▁0 ▁&& ▁par i 2 ▁== ▁2 ▁) ▁) ▁array ▁[ ▁i ▁+ ▁1 ▁] ▁= ▁1 ▁; ▁} ▁} ▁} ▁} ▁return ▁operations ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁arg ▁[ ▁] ▁) ▁{ ▁int ▁[ ▁] ▁array ▁= ▁{ ▁2 ▁, ▁1 ▁, ▁3 ▁, ▁0 ▁} ▁; ▁int ▁size ▁= ▁array ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁solve ▁( ▁array ▁, ▁size ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁check Array ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁n ▁) ▁{ ▁return ▁( ▁( ▁arr ▁[ ▁0 ▁] ▁% ▁2 ▁) ▁> ▁0 ▁&& ▁( ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁% ▁2 ▁) ▁> ▁0 ▁&& ▁( ▁n ▁% ▁2 ▁) ▁> ▁0 ▁) ▁? ▁1 ▁: ▁0 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁check Array ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁class ▁pair ▁{ ▁int ▁first ▁, ▁second ▁; ▁public ▁pair ▁( ▁int ▁first ▁, ▁int ▁second ▁) ▁{ ▁this ▁. ▁first ▁= ▁first ▁; ▁this ▁. ▁second ▁= ▁second ▁; ▁} ▁} ▁static ▁int ▁count Tri pl ets ▁( ▁int ▁n ▁, ▁Vector ▁< ▁pair ▁> ▁points ▁) ▁{ ▁Set ▁< ▁pair ▁> ▁pts ▁= ▁new ▁HashSet ▁< ▁pair ▁> ▁( ▁) ▁; ▁int ▁ct ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁pts ▁. ▁add ▁( ▁points ▁. ▁get ▁( ▁i ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁int ▁x ▁= ▁points ▁. ▁get ▁( ▁i ▁) ▁. ▁first ▁+ ▁points ▁. ▁get ▁( ▁j ▁) ▁. ▁first ▁; ▁int ▁y ▁= ▁points ▁. ▁get ▁( ▁i ▁) ▁. ▁second ▁+ ▁points ▁. ▁get ▁( ▁j ▁) ▁. ▁second ▁; ▁if ▁( ▁x ▁% ▁2 ▁== ▁0 ▁&& ▁y ▁% ▁2 ▁== ▁0 ▁) ▁if ▁( ▁! ▁pts ▁. ▁contains ▁( ▁new ▁pair ▁( ▁x ▁/ ▁2 ▁, ▁y ▁/ ▁2 ▁) ▁) ▁) ▁ct ▁++ ▁; ▁} ▁return ▁ct ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁Vector ▁< ▁pair ▁> ▁points ▁= ▁new ▁Vector ▁< ▁> ▁( ▁) ▁; ▁points ▁. ▁add ▁( ▁new ▁pair ▁( ▁1 ▁, ▁1 ▁) ▁) ▁; ▁points ▁. ▁add ▁( ▁new ▁pair ▁( ▁2 ▁, ▁2 ▁) ▁) ▁; ▁points ▁. ▁add ▁( ▁new ▁pair ▁( ▁3 ▁, ▁3 ▁) ▁) ▁; ▁int ▁n ▁= ▁points ▁. ▁size ▁( ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Tri pl ets ▁( ▁n ▁, ▁points ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁gcd ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁if ▁( ▁b ▁== ▁0 ▁) ▁return ▁a ▁; ▁else ▁return ▁gcd ▁( ▁b ▁, ▁a ▁% ▁b ▁) ▁; ▁} ▁static ▁int ▁l cm Of Array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁< ▁1 ▁) ▁return ▁0 ▁; ▁int ▁l cm ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁l cm ▁= ▁( ▁l cm ▁* ▁arr ▁[ ▁i ▁] ▁) ▁/ ▁gcd ▁( ▁l cm ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁return ▁l cm ▁; ▁} ▁static ▁int ▁min Perf ect Cube ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁min Perf ect Cube ▁; ▁int ▁l cm ▁= ▁l cm Of Array ▁( ▁arr ▁, ▁n ▁) ▁; ▁min Perf ect Cube ▁= ▁l cm ▁; ▁int ▁cnt ▁= ▁0 ▁; ▁while ▁( ▁l cm ▁> ▁1 ▁&& ▁l cm ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁cnt ▁++ ▁; ▁l cm ▁/= ▁2 ▁; ▁} ▁if ▁( ▁cnt ▁% ▁3 ▁== ▁2 ▁) ▁min Perf ect Cube ▁*= ▁2 ▁; ▁else ▁if ▁( ▁cnt ▁% ▁3 ▁== ▁1 ▁) ▁min Perf ect Cube ▁*= ▁4 ▁; ▁int ▁i ▁= ▁3 ▁; ▁while ▁( ▁l cm ▁> ▁1 ▁) ▁{ ▁cnt ▁= ▁0 ▁; ▁while ▁( ▁l cm ▁% ▁i ▁== ▁0 ▁) ▁{ ▁cnt ▁++ ▁; ▁l cm ▁/= ▁i ▁; ▁} ▁if ▁( ▁cnt ▁% ▁3 ▁== ▁1 ▁) ▁min Perf ect Cube ▁*= ▁i ▁* ▁i ▁; ▁else ▁if ▁( ▁cnt ▁% ▁3 ▁== ▁2 ▁) ▁min Perf ect Cube ▁*= ▁i ▁; ▁i ▁+= ▁2 ▁; ▁} ▁return ▁min Perf ect Cube ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁125 ▁, ▁14 ▁, ▁42 ▁, ▁100 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁min Perf ect Cube ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁Solution ▁{ ▁static ▁int ▁max G CD ▁( ▁int ▁N ▁, ▁int ▁P ▁) ▁{ ▁int ▁ans ▁= ▁1 ▁; ▁Map ▁< ▁Integer ▁, ▁Integer ▁> ▁prime _ factors ▁= ▁new ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁* ▁i ▁<= ▁P ▁; ▁i ▁++ ▁) ▁{ ▁while ▁( ▁P ▁% ▁i ▁== ▁0 ▁) ▁{ ▁if ▁( ▁prime _ factors ▁. ▁get ▁( ▁i ▁) ▁== ▁null ▁) ▁prime _ factors ▁. ▁put ▁( ▁i ▁, ▁1 ▁) ▁; ▁else ▁prime _ factors ▁. ▁put ▁( ▁i ▁, ▁( ▁prime _ factors ▁. ▁get ▁( ▁i ▁) ▁+ ▁1 ▁) ▁) ▁; ▁P ▁/= ▁i ▁; ▁} ▁} ▁if ▁( ▁P ▁!= ▁1 ▁) ▁if ▁( ▁prime _ factors ▁. ▁get ▁( ▁P ▁) ▁== ▁null ▁) ▁prime _ factors ▁. ▁put ▁( ▁P ▁, ▁1 ▁) ▁; ▁else ▁prime _ factors ▁. ▁put ▁( ▁P ▁, ▁( ▁prime _ factors ▁. ▁get ▁( ▁P ▁) ▁+ ▁1 ▁) ▁) ▁; ▁Set ▁< ▁Map ▁. ▁Entry ▁< ▁Integer ▁, ▁Integer ▁> ▁> ▁st ▁= ▁prime _ factors ▁. ▁entrySet ▁( ▁) ▁; ▁for ▁( ▁Map ▁. ▁Entry ▁< ▁Integer ▁, ▁Integer ▁> ▁me ▁: ▁st ▁) ▁{ ▁ans ▁*= ▁Math ▁. ▁pow ▁( ▁me ▁. ▁getKey ▁( ▁) ▁, ▁me ▁. ▁getValue ▁( ▁) ▁/ ▁N ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁N ▁= ▁3 ▁, ▁P ▁= ▁24 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁max G CD ▁( ▁N ▁, ▁P ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁public ▁class ▁G F G ▁{ ▁public ▁static ▁ArrayList ▁< ▁Integer ▁> ▁getPer f ect Square s ▁( ▁int ▁n ▁) ▁{ ▁ArrayList ▁< ▁Integer ▁> ▁perfect Square s ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁int ▁current ▁= ▁1 ▁, ▁i ▁= ▁1 ▁; ▁while ▁( ▁current ▁<= ▁n ▁) ▁{ ▁perfect Square s ▁. ▁add ▁( ▁current ▁) ▁; ▁current ▁= ▁( ▁int ▁) ▁Math ▁. ▁pow ▁( ▁++ ▁i ▁, ▁2 ▁) ▁; ▁} ▁return ▁perfect Square s ▁; ▁} ▁public ▁static ▁int ▁count Tri pl ets ▁( ▁int ▁n ▁) ▁{ ▁ArrayList ▁< ▁Integer ▁> ▁perfect Square s ▁= ▁getPer f ect Square s ▁( ▁( ▁int ▁) ▁Math ▁. ▁pow ▁( ▁n ▁, ▁2 ▁) ▁) ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁a ▁= ▁1 ▁; ▁a ▁<= ▁n ▁; ▁a ▁++ ▁) ▁{ ▁int ▁a Square ▁= ▁( ▁int ▁) ▁Math ▁. ▁pow ▁( ▁a ▁, ▁2 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁perfect Square s ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁int ▁c Square ▁= ▁perfect Square s ▁. ▁get ▁( ▁i ▁) ▁; ▁int ▁b Square ▁= ▁c Square ▁- ▁a Square ▁; ▁int ▁b ▁= ▁( ▁int ▁) ▁Math ▁. ▁sqrt ▁( ▁b Square ▁) ▁; ▁int ▁c ▁= ▁( ▁int ▁) ▁Math ▁. ▁sqrt ▁( ▁c Square ▁) ▁; ▁if ▁( ▁c ▁< ▁a ▁|| ▁! ▁perfect Square s ▁. ▁contains ▁( ▁b Square ▁) ▁) ▁continue ▁; ▁if ▁( ▁( ▁b ▁>= ▁a ▁) ▁&& ▁( ▁b ▁<= ▁c ▁) ▁&& ▁( ▁a Square ▁+ ▁b Square ▁== ▁c Square ▁) ▁) ▁count ▁++ ▁; ▁} ▁} ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁10 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Tri pl ets ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁Min Steps ▁( ▁int ▁Source X ▁, ▁int ▁Source Y ▁, ▁int ▁Dest X ▁, ▁int ▁Dest Y ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁Math ▁. ▁max ▁( ▁Math ▁. ▁abs ▁( ▁Source X ▁- ▁Dest X ▁) ▁, ▁Math ▁. ▁abs ▁( ▁Source Y ▁- ▁Dest Y ▁) ▁) ▁) ▁; ▁while ▁( ▁( ▁Source X ▁!= ▁Dest X ▁) ▁|| ▁( ▁Source Y ▁!= ▁Dest Y ▁) ▁) ▁{ ▁if ▁( ▁Source X ▁< ▁Dest X ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁' ▁U ▁' ▁) ▁; ▁Source X ▁++ ▁; ▁} ▁if ▁( ▁Source X ▁> ▁Dest X ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁' ▁D ▁' ▁) ▁; ▁Source X ▁-- ▁; ▁} ▁if ▁( ▁Source Y ▁> ▁Dest Y ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁' ▁L ▁' ▁) ▁; ▁Source Y ▁-- ▁; ▁} ▁if ▁( ▁Source Y ▁< ▁Dest Y ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁' ▁R ▁' ▁) ▁; ▁Source Y ▁++ ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁source X ▁= ▁4 ▁, ▁source Y ▁= ▁4 ▁; ▁int ▁destination X ▁= ▁7 ▁, ▁destination Y ▁= ▁0 ▁; ▁Min Steps ▁( ▁source X ▁, ▁source Y ▁, ▁destination X ▁, ▁destination Y ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁boolean ▁isP al indrome ▁( ▁int ▁num ▁) ▁{ ▁int ▁reverse _ num ▁= ▁0 ▁, ▁remainder ▁, ▁temp ▁; ▁temp ▁= ▁num ▁; ▁while ▁( ▁temp ▁!= ▁0 ▁) ▁{ ▁remainder ▁= ▁temp ▁% ▁10 ▁; ▁reverse _ num ▁= ▁reverse _ num ▁* ▁10 ▁+ ▁remainder ▁; ▁temp ▁/= ▁10 ▁; ▁} ▁if ▁( ▁reverse _ num ▁== ▁num ▁) ▁{ ▁return ▁true ▁; ▁} ▁return ▁false ▁; ▁} ▁static ▁boolean ▁is Odd Length ▁( ▁int ▁num ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁while ▁( ▁num ▁> ▁0 ▁) ▁{ ▁num ▁/= ▁10 ▁; ▁count ▁++ ▁; ▁} ▁if ▁( ▁count ▁% ▁2 ▁!= ▁0 ▁) ▁{ ▁return ▁true ▁; ▁} ▁return ▁false ▁; ▁} ▁static ▁long ▁sum Of All Pal indrome ▁( ▁int ▁L ▁, ▁int ▁R ▁) ▁{ ▁long ▁sum ▁= ▁0 ▁; ▁if ▁( ▁L ▁<= ▁R ▁) ▁for ▁( ▁int ▁i ▁= ▁L ▁; ▁i ▁<= ▁R ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁isP al indrome ▁( ▁i ▁) ▁&& ▁is Odd Length ▁( ▁i ▁) ▁) ▁{ ▁sum ▁+= ▁i ▁; ▁} ▁} ▁return ▁sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁L ▁= ▁110 ▁, ▁R ▁= ▁11 30 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁sum Of All Pal indrome ▁( ▁L ▁, ▁R ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁boolean ▁product Sum Div isible ▁( ▁int ▁n ▁, ▁int ▁size ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁, ▁product ▁= ▁1 ▁; ▁while ▁( ▁n ▁> ▁0 ▁) ▁{ ▁if ▁( ▁size ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁product ▁*= ▁n ▁% ▁10 ▁; ▁} ▁else ▁{ ▁sum ▁+= ▁n ▁% ▁10 ▁; ▁} ▁n ▁= ▁n ▁/ ▁10 ▁; ▁size ▁-- ▁; ▁} ▁if ▁( ▁product ▁% ▁sum ▁== ▁0 ▁) ▁{ ▁return ▁true ▁; ▁} ▁return ▁false ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁1234 ▁; ▁int ▁len ▁= ▁4 ▁; ▁if ▁( ▁product Sum Div isible ▁( ▁n ▁, ▁len ▁) ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁TRUE ▁" ▁) ▁; ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁FALSE ▁" ▁) ▁; ▁} ▁} ▁}
▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁count Digit ▁( ▁int ▁n ▁) ▁{ ▁int ▁temp ▁= ▁n ▁, ▁sum ▁= ▁0 ▁, ▁product ▁= ▁1 ▁; ▁while ▁( ▁temp ▁!= ▁0 ▁) ▁{ ▁int ▁d ▁= ▁temp ▁% ▁10 ▁; ▁temp ▁/= ▁10 ▁; ▁if ▁( ▁d ▁> ▁0 ▁&& ▁n ▁% ▁d ▁== ▁0 ▁) ▁{ ▁sum ▁+= ▁d ▁; ▁product ▁*= ▁d ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Sum ▁= ▁" ▁+ ▁sum ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Product ▁= ▁" ▁+ ▁product ); ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁101 2 ▁; ▁count Digit ▁( ▁n ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁MAX ▁= ▁1000000 ▁; ▁static ▁boolean ▁[ ▁] ▁prime ▁= ▁new ▁boolean ▁[ ▁MAX ▁+ ▁1 ▁] ▁; ▁static ▁void ▁S ieve Of E rat ost hen es ▁( ▁) ▁{ ▁prime ▁[ ▁1 ▁] ▁= ▁true ▁; ▁prime ▁[ ▁0 ▁] ▁= ▁true ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁* ▁p ▁<= ▁MAX ▁; ▁p ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁p ▁] ▁== ▁false ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁p ▁* ▁2 ▁; ▁i ▁<= ▁MAX ▁; ▁i ▁+= ▁p ▁) ▁prime ▁[ ▁i ▁] ▁= ▁true ▁; ▁} ▁} ▁} ▁static ▁void ▁product Of K th Pr imes ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁c ▁= ▁0 ▁; ▁int ▁product ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁! ▁prime ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁) ▁{ ▁c ▁++ ▁; ▁if ▁( ▁c ▁% ▁k ▁== ▁0 ▁) ▁{ ▁product ▁*= ▁arr ▁[ ▁i ▁] ▁; ▁c ▁= ▁0 ▁; ▁} ▁} ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁product ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁S ieve Of E rat ost hen es ▁( ▁) ▁; ▁int ▁n ▁= ▁5 ▁, ▁k ▁= ▁2 ▁; ▁int ▁[ ▁] ▁arr ▁= ▁new ▁int ▁[ ▁] ▁{ ▁2 ▁, ▁3 ▁, ▁5 ▁, ▁7 ▁, ▁11 ▁} ▁; ▁product Of K th Pr imes ▁( ▁arr ▁, ▁n ▁, ▁k ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁long ▁nth K yn ea Number ▁( ▁int ▁n ▁) ▁{ ▁return ▁( ▁( ▁1 ▁<< ▁( ▁2 ▁* ▁n ▁) ▁) ▁+ ▁( ▁1 ▁<< ▁( ▁n ▁+ ▁1 ▁) ▁) ▁- ▁1 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁nth K yn ea Number ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁fn Mod ▁( ▁int ▁n ▁) ▁{ ▁int ▁rem ▁= ▁n ▁% ▁4 ▁; ▁if ▁( ▁rem ▁== ▁0 ▁rem ▁== ▁3 ▁) ▁return ▁0 ▁; ▁else ▁if ▁( ▁rem ▁== ▁1 ▁rem ▁== ▁2 ▁) ▁return ▁1 ▁; ▁return ▁0 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁6 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁fn Mod ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁mod Exp ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁int ▁result ▁= ▁1 ▁; ▁while ▁( ▁b ▁> ▁0 ▁) ▁{ ▁if ▁( ▁b ▁== ▁1 ▁) ▁result ▁= ▁result ▁* ▁a ▁; ▁a ▁= ▁a ▁* ▁a ▁; ▁b ▁/= ▁2 ▁; ▁} ▁return ▁result ▁; ▁} ▁static ▁int ▁check ▁( ▁int ▁num ▁) ▁{ ▁if ▁( ▁num ▁== ▁1 ▁num ▁< ▁3 ▁) ▁return ▁- ▁1 ▁; ▁else ▁if ▁( ▁num ▁% ▁4 ▁== ▁0 ▁) ▁return ▁mod Exp ▁( ▁num ▁/ ▁4 ▁, ▁4 ▁) ▁; ▁else ▁if ▁( ▁num ▁% ▁6 ▁== ▁0 ▁) ▁return ▁mod Exp ▁( ▁num ▁/ ▁3 ▁, ▁2 ▁) ▁* ▁mod Exp ▁( ▁num ▁/ ▁6 ▁, ▁2 ▁) ▁; ▁else ▁if ▁( ▁num ▁% ▁10 ▁== ▁0 ▁) ▁return ▁mod Exp ▁( ▁num ▁/ ▁5 ▁, ▁2 ▁) ▁* ▁( ▁num ▁/ ▁10 ▁) ▁* ▁( ▁num ▁/ ▁2 ▁) ▁; ▁else ▁return ▁- ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁num ▁= ▁10 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁check ▁( ▁num ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁G F G ▁{ ▁static ▁int ▁R ace ▁( ▁int ▁B ▁, ▁int ▁C ▁) ▁{ ▁int ▁result ▁= ▁0 ▁; ▁result ▁= ▁( ▁( ▁C ▁* ▁100 ▁) ▁/ ▁B ▁) ▁; ▁return ▁100 ▁- ▁result ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁B ▁= ▁10 ▁; ▁int ▁C ▁= ▁28 ▁; ▁B ▁= ▁100 ▁- ▁B ▁; ▁C ▁= ▁100 ▁- ▁C ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁R ace ▁( ▁B ▁, ▁C ▁) ▁+ ▁" ▁meters ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁long ▁bin omial Co eff ▁( ▁long ▁n ▁, ▁long ▁k ▁) ▁{ ▁long ▁res ▁= ▁1 ▁; ▁if ▁( ▁k ▁> ▁n ▁- ▁k ▁) ▁k ▁= ▁n ▁- ▁k ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁k ▁; ▁++ ▁i ▁) ▁{ ▁res ▁*= ▁( ▁n ▁- ▁i ▁) ▁; ▁res ▁/= ▁( ▁i ▁+ ▁1 ▁) ▁; ▁} ▁return ▁res ▁; ▁} ▁static ▁long ▁catal an ▁( ▁long ▁n ▁) ▁{ ▁long ▁c ▁= ▁bin omial Co eff ▁( ▁2 ▁* ▁n ▁, ▁n ▁) ▁; ▁return ▁c ▁/ ▁( ▁n ▁+ ▁1 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁catal an ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁Math ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁distance ▁( ▁float ▁x 1 ▁, ▁float ▁y 1 ▁, ▁float ▁z 1 ▁, ▁float ▁x 2 ▁, ▁float ▁y 2 ▁, ▁float ▁z 2 ▁) ▁{ ▁double ▁d ▁= ▁Math ▁. ▁pow ▁( ▁( ▁Math ▁. ▁pow ▁( ▁x 2 ▁- ▁x 1 ▁, ▁2 ▁) ▁+ ▁Math ▁. ▁pow ▁( ▁y 2 ▁- ▁y 1 ▁, ▁2 ▁) ▁+ ▁Math ▁. ▁pow ▁( ▁z 2 ▁- ▁z 1 ▁, ▁2 ▁) ▁* ▁1.0 ▁) ▁, ▁0.5 ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Distance ▁is ▁" ▁+ ▁d ▁) ▁; ▁return ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁float ▁x 1 ▁= ▁2 ▁; ▁float ▁y 1 ▁= ▁- ▁5 ▁; ▁float ▁z 1 ▁= ▁7 ▁; ▁float ▁x 2 ▁= ▁3 ▁; ▁float ▁y 2 ▁= ▁4 ▁; ▁float ▁z 2 ▁= ▁5 ▁; ▁distance ▁( ▁x 1 ▁, ▁y 1 ▁, ▁z 1 ▁, ▁x 2 ▁, ▁y 2 ▁, ▁z 2 ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁find Greater ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁! ▁( ▁( ▁n ▁& ▁1 ▁) ▁> ▁0 ▁) ▁) ▁{ ▁a ▁= ▁Math ▁. ▁abs ▁( ▁a ▁) ▁; ▁b ▁= ▁Math ▁. ▁abs ▁( ▁b ▁) ▁; ▁} ▁if ▁( ▁a ▁== ▁b ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁a ▁^ ▁n ▁is ▁" ▁+ ▁" ▁equal ▁to ▁b ▁^ ▁n ▁" ▁) ▁; ▁else ▁if ▁( ▁a ▁> ▁b ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁a ▁^ ▁n ▁is ▁greater ▁" ▁+ ▁" ▁than ▁b ▁^ ▁n ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁b ▁^ ▁n ▁is ▁greater ▁" ▁+ ▁" ▁than ▁a ▁^ ▁n ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁= ▁12 ▁, ▁b ▁= ▁24 ▁, ▁n ▁= ▁5 ▁; ▁find Greater ▁( ▁a ▁, ▁b ▁, ▁n ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁subtract One ▁( ▁int ▁x ▁) ▁{ ▁int ▁m ▁= ▁1 ▁; ▁while ▁( ▁! ▁( ▁( ▁x ▁& ▁m ▁) ▁> ▁0 ▁) ▁) ▁{ ▁x ▁= ▁x ▁^ ▁m ▁; ▁m ▁<<= ▁1 ▁; ▁} ▁x ▁= ▁x ▁^ ▁m ▁; ▁return ▁x ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁subtract One ▁( ▁13 ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁lang ▁. ▁Math ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁final ▁double ▁PI ▁= ▁3.1 42 ▁; ▁static ▁double ▁cos X S ert ies Sum ▁( ▁double ▁x ▁, ▁int ▁n ▁) ▁{ ▁x ▁= ▁x ▁* ▁( ▁PI ▁/ ▁180 .0 ▁) ▁; ▁double ▁res ▁= ▁1 ▁; ▁double ▁sign ▁= ▁1 ▁, ▁fact ▁= ▁1 ▁, ▁pow ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁5 ▁; ▁i ▁++ ▁) ▁{ ▁sign ▁= ▁sign ▁* ▁- ▁1 ▁; ▁fact ▁= ▁fact ▁* ▁( ▁2 ▁* ▁i ▁- ▁1 ▁) ▁* ▁( ▁2 ▁* ▁i ▁) ▁; ▁pow ▁= ▁pow ▁* ▁x ▁* ▁x ▁; ▁res ▁= ▁res ▁+ ▁sign ▁* ▁pow ▁/ ▁fact ▁; ▁} ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁float ▁x ▁= ▁50 ▁; ▁int ▁n ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁( ▁float ▁) ▁( ▁cos X S ert ies Sum ▁( ▁x ▁, ▁5 ▁) ▁* ▁1000000 ▁) ▁/ ▁1000000 .00 ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁lang ▁. ▁System ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁find Bucket No ▁( ▁int ▁p ▁) ▁{ ▁return ▁( ▁int ▁) ▁Math ▁. ▁ceil ▁( ▁( ▁Math ▁. ▁sqrt ▁( ▁8 ▁* ▁p ▁+ ▁1 ▁) ▁- ▁1 ▁) ▁/ ▁2 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁p ▁= ▁10 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Bucket No ▁( ▁p ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁MAX ▁= ▁5000 2 ▁; ▁static ▁ArrayList ▁< ▁Integer ▁> ▁primes ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁public ▁static ▁void ▁s ieve ▁( ▁) ▁{ ▁boolean ▁is Prime ▁[ ▁] ▁= ▁new ▁boolean ▁[ ▁MAX ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁MAX ▁; ▁i ▁++ ▁) ▁is Prime ▁[ ▁i ▁] ▁= ▁true ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁* ▁p ▁< ▁MAX ▁; ▁p ▁++ ▁) ▁{ ▁if ▁( ▁is Prime ▁[ ▁p ▁] ▁== ▁true ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁p ▁* ▁2 ▁; ▁i ▁< ▁MAX ▁; ▁i ▁+= ▁p ▁) ▁is Prime ▁[ ▁i ▁] ▁= ▁false ▁; ▁} ▁} ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁< ▁MAX ▁; ▁p ▁++ ▁) ▁if ▁( ▁is Prime ▁[ ▁p ▁] ▁== ▁true ▁) ▁primes ▁. ▁add ▁( ▁p ▁) ▁; ▁} ▁public ▁static ▁int ▁power ▁( ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁int ▁z ▁= ▁y ▁; ▁while ▁( ▁x ▁>= ▁z ▁) ▁{ ▁count ▁+= ▁( ▁x ▁/ ▁z ▁) ▁; ▁z ▁*= ▁y ▁; ▁} ▁return ▁count ▁; ▁} ▁public ▁static ▁int ▁mod Mult ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁int ▁mod ▁) ▁{ ▁int ▁res ▁= ▁0 ▁; ▁a ▁= ▁a ▁% ▁mod ▁; ▁while ▁( ▁b ▁> ▁0 ▁) ▁{ ▁if ▁( ▁b ▁% ▁2 ▁== ▁1 ▁) ▁res ▁= ▁( ▁res ▁+ ▁a ▁) ▁% ▁mod ▁; ▁a ▁= ▁( ▁a ▁* ▁2 ▁) ▁% ▁mod ▁; ▁b ▁/= ▁2 ▁; ▁} ▁return ▁res ▁% ▁mod ▁; ▁} ▁public ▁static ▁int ▁count W ays ▁( ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁int ▁ans ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁primes ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁int ▁powers ▁= ▁power ▁( ▁n ▁, ▁primes ▁. ▁get ▁( ▁i ▁) ▁) ▁; ▁if ▁( ▁powers ▁== ▁0 ▁) ▁break ▁; ▁ans ▁= ▁mod Mult ▁( ▁ans ▁, ▁powers ▁+ ▁1 ▁, ▁m ▁) ▁% ▁m ▁; ▁} ▁if ▁( ▁( ▁( ▁ans ▁- ▁1 ▁) ▁% ▁m ▁) ▁< ▁0 ▁) ▁return ▁( ▁ans ▁- ▁1 ▁+ ▁m ▁) ▁% ▁m ▁; ▁else ▁return ▁( ▁ans ▁- ▁1 ▁) ▁% ▁m ▁; ▁} ▁public ▁static ▁void ▁main
▁class ▁G F G ▁{ ▁static ▁void ▁p yth ag ore an Tri plet ▁( ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁/ ▁3 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁<= ▁n ▁/ ▁2 ▁; ▁j ▁++ ▁) ▁{ ▁int ▁k ▁= ▁n ▁- ▁i ▁- ▁j ▁; ▁if ▁( ▁i ▁* ▁i ▁+ ▁j ▁* ▁j ▁== ▁k ▁* ▁k ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁i ▁+ ▁" ▁, ▁" ▁+ ▁j ▁+ ▁" ▁, ▁" ▁+ ▁k ▁) ▁; ▁return ▁; ▁} ▁} ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁No ▁Tri plet ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁arg ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁12 ▁; ▁p yth ag ore an Tri plet ▁( ▁n ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁dig Sum ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁0 ▁) ▁return ▁0 ▁; ▁return ▁( ▁n ▁% ▁9 ▁== ▁0 ▁) ▁? ▁9 ▁: ▁( ▁n ▁% ▁9 ▁) ▁; ▁} ▁static ▁int ▁repeated Number Sum ▁( ▁int ▁n ▁, ▁int ▁x ▁) ▁{ ▁int ▁sum ▁= ▁x ▁* ▁dig Sum ▁( ▁n ▁) ▁; ▁return ▁dig Sum ▁( ▁sum ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁24 ▁, ▁x ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁repeated Number Sum ▁( ▁n ▁, ▁x ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁final ▁int ▁MAX ▁= ▁100000 ▁; ▁static ▁int ▁multiply ▁( ▁int ▁x ▁, ▁int ▁res ▁[ ▁] ▁, ▁int ▁res _ size ▁) ▁{ ▁int ▁carry ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁res _ size ▁; ▁i ▁++ ▁) ▁{ ▁int ▁prod ▁= ▁res ▁[ ▁i ▁] ▁* ▁x ▁+ ▁carry ▁; ▁res ▁[ ▁i ▁] ▁= ▁prod ▁% ▁10 ▁; ▁carry ▁= ▁prod ▁/ ▁10 ▁; ▁} ▁while ▁( ▁carry ▁> ▁0 ▁) ▁{ ▁res ▁[ ▁res _ size ▁] ▁= ▁carry ▁% ▁10 ▁; ▁carry ▁= ▁carry ▁/ ▁10 ▁; ▁res _ size ▁++ ▁; ▁} ▁return ▁res _ size ▁; ▁} ▁static ▁void ▁power ▁( ▁int ▁x ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁"1" ▁) ▁; ▁return ▁; ▁} ▁int ▁res ▁[ ▁] ▁= ▁new ▁int ▁[ ▁MAX ▁] ▁; ▁int ▁res _ size ▁= ▁0 ▁; ▁int ▁temp ▁= ▁x ▁; ▁while ▁( ▁temp ▁!= ▁0 ▁) ▁{ ▁res ▁[ ▁res _ size ▁++ ▁] ▁= ▁temp ▁% ▁10 ▁; ▁temp ▁= ▁temp ▁/ ▁10 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁res _ size ▁= ▁multiply ▁( ▁x ▁, ▁res ▁, ▁res _ size ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁x ▁+ ▁" ▁^ ▁" ▁+ ▁n ▁+ ▁" ▁= ▁" ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁res _ size ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁res ▁[ ▁i ▁] ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁exponent ▁= ▁100 ▁; ▁int ▁base ▁= ▁2 ▁; ▁power ▁( ▁base ▁, ▁exponent ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁double ▁find Area ▁( ▁double ▁d ▁) ▁{ ▁return ▁( ▁d ▁* ▁d ▁) ▁/ ▁2 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁double ▁d ▁= ▁10 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Area ▁( ▁d ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁find Numbers ▁( ▁int ▁n ▁, ▁int ▁d ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁2 ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁"1" ▁+ ▁" ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁"2" ▁+ ▁" ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁n ▁+ ▁d ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁N ▁= ▁3 ▁, ▁D ▁= ▁5 ▁; ▁find Numbers ▁( ▁N ▁, ▁D ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁public ▁class ▁G F G ▁{ ▁static ▁float ▁Avg of Square N ▁( ▁int ▁n ▁) ▁{ ▁float ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁sum ▁+= ▁( ▁i ▁* ▁i ▁) ▁; ▁return ▁sum ▁/ ▁n ▁; ▁} ▁static ▁public ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁Avg of Square N ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁class ▁pair ▁{ ▁int ▁first ▁, ▁second ▁; ▁public ▁pair ▁( ▁int ▁first ▁, ▁int ▁second ▁) ▁{ ▁this ▁. ▁first ▁= ▁first ▁; ▁this ▁. ▁second ▁= ▁second ▁; ▁} ▁} ▁static ▁int ▁L CM ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁return ▁( ▁a ▁* ▁b ▁) ▁/ ▁( ▁__ g cd ▁( ▁a ▁, ▁b ▁) ▁) ▁; ▁} ▁static ▁int ▁__ g cd ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁return ▁b ▁== ▁0 ▁? ▁a ▁: ▁__ g cd ▁( ▁b ▁, ▁a ▁% ▁b ▁) ▁; ▁} ▁static ▁int ▁l cm Of Num erator ▁( ▁Vector ▁< ▁pair ▁> ▁vect ▁) ▁{ ▁int ▁l cm ▁= ▁vect ▁. ▁get ▁( ▁0 ▁) ▁. ▁first ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁vect ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁l cm ▁= ▁L CM ▁( ▁vect ▁. ▁get ▁( ▁i ▁) ▁. ▁first ▁, ▁l cm ▁) ▁; ▁return ▁l cm ▁; ▁} ▁static ▁int ▁gcd Of D emon in ators ▁( ▁Vector ▁< ▁pair ▁> ▁vect ▁) ▁{ ▁int ▁gcd ▁= ▁vect ▁. ▁get ▁( ▁0 ▁) ▁. ▁second ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁vect ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁gcd ▁= ▁__ g cd ▁( ▁vect ▁. ▁get ▁( ▁i ▁) ▁. ▁second ▁, ▁gcd ▁) ▁; ▁return ▁gcd ▁; ▁} ▁static ▁void ▁l cm Of R ation als ▁( ▁Vector ▁< ▁pair ▁> ▁vect ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁l cm Of Num erator ▁( ▁vect ▁) ▁+ ▁" ▁/ ▁" ▁+ ▁gcd Of D emon in ators ▁( ▁vect ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Vector ▁< ▁pair ▁> ▁vect ▁= ▁new ▁Vector ▁< ▁pair ▁> ▁( ▁) ▁; ▁vect ▁. ▁add ▁( ▁new ▁pair ▁( ▁2 ▁, ▁7 ▁) ▁) ▁; ▁vect ▁. ▁add ▁( ▁new ▁pair ▁( ▁3 ▁, ▁14 ▁) ▁) ▁; ▁vect ▁. ▁add ▁( ▁new ▁pair ▁( ▁5 ▁, ▁3 ▁) ▁) ▁; ▁l cm Of R ation als ▁( ▁vect ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁sum of N term ▁( ▁int ▁a ▁, ▁int ▁d ▁, ▁int ▁b ▁, ▁int ▁r ▁, ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁sum ▁+= ▁( ▁( ▁a ▁+ ▁( ▁i ▁- ▁1 ▁) ▁* ▁d ▁) ▁* ▁( ▁b ▁* ▁Math ▁. ▁pow ▁( ▁r ▁, ▁i ▁- ▁1 ▁) ▁) ▁) ▁; ▁return ▁sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁a ▁= ▁1 ▁, ▁d ▁= ▁1 ▁, ▁b ▁= ▁2 ▁, ▁r ▁= ▁2 ▁, ▁n ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁sum of N term ▁( ▁a ▁, ▁d ▁, ▁b ▁, ▁r ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁public ▁class ▁G f G ▁{ ▁public ▁static ▁int ▁first ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁int ▁c ▁) ▁{ ▁a ▁% = ▁b ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁b ▁; ▁i ▁++ ▁) ▁{ ▁a ▁= ▁a ▁* ▁10 ▁; ▁if ▁( ▁a ▁/ ▁b ▁== ▁c ▁) ▁return ▁i ▁; ▁a ▁% = ▁b ▁; ▁} ▁return ▁- ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁arg c ▁[ ▁] ▁) ▁{ ▁int ▁a ▁= ▁1 ▁, ▁b ▁= ▁4 ▁, ▁c ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁first ▁( ▁a ▁, ▁b ▁, ▁c ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁is Prime ▁( ▁int ▁n ▁) ▁{ ▁int ▁i ▁= ▁2 ▁; ▁while ▁( ▁i ▁* ▁i ▁<= ▁n ▁) ▁{ ▁if ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁return ▁false ▁; ▁i ▁++ ▁; ▁} ▁return ▁true ▁; ▁} ▁static ▁int ▁minimum Sum ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁is Prime ▁( ▁n ▁) ▁) ▁return ▁1 ▁; ▁if ▁( ▁n ▁% ▁2 ▁== ▁0 ▁) ▁return ▁2 ▁; ▁if ▁( ▁is Prime ▁( ▁n ▁- ▁2 ▁) ▁) ▁return ▁2 ▁; ▁return ▁3 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁4 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁minimum Sum ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁term ▁( ▁int ▁n ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁ans ▁+= ▁i ▁; ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁4 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁term ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁double ▁sum ▁( ▁int ▁x ▁, ▁int ▁n ▁) ▁{ ▁double ▁i ▁, ▁total ▁= ▁1.0 ▁, ▁multi ▁= ▁x ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁total ▁= ▁total ▁+ ▁multi ▁/ ▁i ▁; ▁multi ▁= ▁multi ▁* ▁x ▁; ▁} ▁return ▁total ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁x ▁= ▁2 ▁; ▁int ▁n ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁% ▁.2 f ▁" ▁, ▁sum ▁( ▁x ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁double ▁gcd ▁( ▁double ▁a ▁, ▁double ▁b ▁) ▁{ ▁if ▁( ▁a ▁< ▁b ▁) ▁return ▁gcd ▁( ▁b ▁, ▁a ▁) ▁; ▁if ▁( ▁Math ▁. ▁abs ▁( ▁b ▁) ▁< ▁0.001 ▁) ▁return ▁a ▁; ▁else ▁return ▁( ▁gcd ▁( ▁b ▁, ▁a ▁- ▁Math ▁. ▁floor ▁( ▁a ▁/ ▁b ▁) ▁* ▁b ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁double ▁a ▁= ▁1. 20 ▁, ▁b ▁= ▁2 2.5 ▁; ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁% ▁.1 f ▁" ▁, ▁gcd ▁( ▁a ▁, ▁b ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁gcd Max ▁( ▁int ▁[ ▁] ▁a ▁, ▁int ▁[ ▁] ▁b ▁, ▁int ▁n ▁, ▁int ▁N ▁) ▁{ ▁int ▁[ ▁] ▁cnt ▁= ▁new ▁int ▁[ ▁N ▁] ▁; ▁int ▁[ ▁] ▁first ▁= ▁new ▁int ▁[ ▁N ▁] ▁; ▁int ▁[ ▁] ▁second ▁= ▁new ▁int ▁[ ▁N ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁cnt ▁[ ▁a ▁[ ▁i ▁] ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁++ ▁i ▁) ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁< ▁N ▁; ▁j ▁+= ▁i ▁) ▁if ▁( ▁cnt ▁[ ▁j ▁] ▁> ▁0 ▁) ▁first ▁[ ▁i ▁] ▁= ▁Math ▁. ▁max ▁( ▁first ▁[ ▁i ▁] ▁, ▁j ▁) ▁; ▁cnt ▁= ▁new ▁int ▁[ ▁N ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁cnt ▁[ ▁b ▁[ ▁i ▁] ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁++ ▁i ▁) ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁< ▁N ▁; ▁j ▁+= ▁i ▁) ▁if ▁( ▁cnt ▁[ ▁j ▁] ▁> ▁0 ▁) ▁second ▁[ ▁i ▁] ▁= ▁Math ▁. ▁max ▁( ▁second ▁[ ▁i ▁] ▁, ▁j ▁) ▁; ▁int ▁x ▁; ▁for ▁( ▁x ▁= ▁N ▁- ▁1 ▁; ▁x ▁>= ▁0 ▁; ▁x ▁-- ▁) ▁if ▁( ▁first ▁[ ▁x ▁] ▁> ▁0 ▁&& ▁second ▁[ ▁x ▁] ▁> ▁0 ▁) ▁break ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁first ▁[ ▁x ▁] ▁+ ▁" ▁" ▁+ ▁second ▁[ ▁x ▁] ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁a ▁= ▁{ ▁3 ▁, ▁1 ▁, ▁4 ▁, ▁2 ▁, ▁8 ▁} ▁; ▁int ▁[ ▁] ▁b ▁= ▁{ ▁5 ▁, ▁2 ▁, ▁12 ▁, ▁8 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁a ▁. ▁length ▁; ▁int ▁N ▁= ▁20 ▁; ▁gcd Max ▁( ▁a ▁, ▁b ▁, ▁n ▁, ▁N ▁) ▁; ▁} ▁}
▁class ▁Sub array ▁{ ▁static ▁int ▁calculate ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁r ▁= ▁i ▁+ ▁1 ▁; ▁for ▁( ▁int ▁j ▁= ▁r ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁== ▁a ▁[ ▁j ▁] ▁) ▁r ▁+= ▁1 ▁; ▁else ▁break ▁; ▁} ▁int ▁d ▁= ▁r ▁- ▁i ▁; ▁ans ▁+= ▁( ▁d ▁* ▁( ▁d ▁+ ▁1 ▁) ▁/ ▁2 ▁) ▁; ▁i ▁= ▁r ▁- ▁1 ▁; ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁4 ▁, ▁5 ▁, ▁3 ▁, ▁3 ▁, ▁3 ▁} ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁calculate ▁( ▁a ▁, ▁a ▁. ▁length ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁sum ▁( ▁int ▁n ▁) ▁{ ▁int ▁rem ▁= ▁0 ▁; ▁int ▁sum _ of _ digits ▁= ▁0 ▁; ▁while ▁( ▁n ▁> ▁0 ▁) ▁{ ▁rem ▁= ▁n ▁% ▁10 ▁; ▁sum _ of _ digits ▁+= ▁rem ▁; ▁n ▁= ▁n ▁/ ▁10 ▁; ▁} ▁return ▁sum _ of _ digits ▁; ▁} ▁static ▁int ▁count ▁( ▁int ▁n ▁) ▁{ ▁int ▁c ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁97 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁a ▁= ▁sum ▁( ▁i ▁) ▁; ▁int ▁b ▁= ▁sum ▁( ▁a ▁) ▁; ▁if ▁( ▁( ▁i ▁+ ▁a ▁+ ▁b ▁) ▁== ▁n ▁) ▁{ ▁c ▁+= ▁1 ▁; ▁} ▁} ▁return ▁c ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁99 39 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁Math ▁; ▁class ▁G F G ▁{ ▁static ▁ArrayList ▁< ▁Integer ▁> ▁S ieve Of E rat ost hen es ▁( ▁int ▁n ▁) ▁{ ▁boolean ▁[ ▁] ▁prime ▁= ▁new ▁boolean ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁* ▁p ▁<= ▁n ▁; ▁p ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁p ▁] ▁== ▁false ▁) ▁for ▁( ▁int ▁i ▁= ▁p ▁* ▁2 ▁; ▁i ▁< ▁n ▁+ ▁1 ▁; ▁i ▁+= ▁p ▁) ▁prime ▁[ ▁i ▁] ▁= ▁true ▁; ▁} ▁ArrayList ▁< ▁Integer ▁> ▁lis ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁<= ▁n ▁; ▁p ▁++ ▁) ▁if ▁( ▁prime ▁[ ▁p ▁] ▁== ▁false ▁) ▁lis ▁. ▁add ▁( ▁p ▁) ▁; ▁return ▁lis ▁; ▁} ▁static ▁int ▁set Bits ▁( ▁int ▁n ▁) ▁{ ▁return ▁Integer ▁. ▁bit Count ▁( ▁n ▁) ▁; ▁} ▁public ▁static ▁int ▁log 2 ▁( ▁int ▁x ▁) ▁{ ▁return ▁( ▁int ▁) ▁( ▁Math ▁. ▁log ▁( ▁x ▁) ▁/ ▁Math ▁. ▁log ▁( ▁2 ▁) ▁+ ▁1 e -10 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁x ▁= ▁4 ▁, ▁y ▁= ▁8 ▁; ▁int ▁count ▁= ▁0 ▁; ▁ArrayList ▁< ▁Integer ▁> ▁prime Arr ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁prime Arr ▁= ▁S ieve Of E rat ost hen es ▁( ▁( ▁int ▁) ▁Math ▁. ▁ceil ▁( ▁log 2 ▁( ▁y ▁) ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁x ▁; ▁i ▁< ▁y ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁int ▁temp ▁= ▁set Bits ▁( ▁i ▁) ▁; ▁if ▁( ▁prime Arr ▁. ▁contains ▁( ▁temp ▁) ▁) ▁count ▁+= ▁1 ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁count ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁int ▁count Trailing Zero es ▁( ▁int ▁N ▁) ▁{ ▁int ▁res ▁= ▁N ▁^ ▁( ▁N ▁- ▁1 ▁) ▁; ▁return ▁( ▁int ▁) ▁( ▁Math ▁. ▁log ▁( ▁temp ▁) ▁/ ▁Math ▁. ▁log ▁( ▁2 ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁12 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Trailing Zero es ▁( ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁int ▁formed _ no ▁( ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁if ▁( ▁K ▁== ▁1 ▁) ▁{ ▁return ▁N ▁; ▁} ▁int ▁answer ▁= ▁N ▁; ▁while ▁( ▁K ▁!= ▁0 ▁) ▁{ ▁int ▁a _ current ▁= ▁prod _ of _ max _ min ▁( ▁answer ▁) ▁; ▁if ▁( ▁a _ current ▁== ▁0 ▁) ▁break ▁; ▁answer ▁+= ▁a _ current ▁; ▁} ▁return ▁answer ▁; ▁} ▁static ▁int ▁prod _ of _ max _ min ▁( ▁int ▁n ▁) ▁{ ▁int ▁largest ▁= ▁0 ▁; ▁int ▁smallest ▁= ▁10 ▁; ▁while ▁( ▁n ▁!= ▁0 ▁) ▁{ ▁int ▁r ▁= ▁n ▁% ▁10 ▁; ▁largest ▁= ▁Math ▁. ▁max ▁( ▁r ▁, ▁largest ▁) ▁; ▁smallest ▁= ▁Math ▁. ▁min ▁( ▁r ▁, ▁smallest ▁) ▁; ▁n ▁= ▁n ▁/ ▁10 ▁; ▁} ▁return ▁largest ▁* ▁smallest ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁4 87 ▁, ▁K ▁= ▁100 000000 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁formed _ no ▁( ▁N ▁, ▁K ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁subset Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁sum ▁, ▁int ▁s ▁, ▁int ▁count ▁) ▁{ ▁if ▁( ▁n ▁== ▁0 ▁) ▁{ ▁if ▁( ▁sum ▁== ▁s ▁) ▁{ ▁count ▁++ ▁; ▁} ▁return ▁count ▁; ▁} ▁count ▁= ▁subset Sum ▁( ▁arr ▁, ▁n ▁- ▁1 ▁, ▁sum ▁, ▁s ▁, ▁count ▁) ▁; ▁count ▁= ▁subset Sum ▁( ▁arr ▁, ▁n ▁- ▁1 ▁, ▁sum ▁, ▁s ▁+ ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁, ▁count ▁) ▁; ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁sum ▁= ▁10 ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁subset Sum ▁( ▁arr ▁, ▁n ▁, ▁sum ▁, ▁s ▁, ▁0 ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁boolean ▁does Contain B ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁int ▁c ▁) ▁{ ▁if ▁( ▁a ▁== ▁b ▁) ▁{ ▁return ▁true ▁; ▁} ▁if ▁( ▁( ▁b ▁- ▁a ▁) ▁* ▁c ▁> ▁0 ▁&& ▁( ▁b ▁- ▁a ▁) ▁% ▁c ▁== ▁0 ▁) ▁{ ▁return ▁true ▁; ▁} ▁return ▁false ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁= ▁1 ▁, ▁b ▁= ▁7 ▁, ▁c ▁= ▁3 ▁; ▁if ▁( ▁does Contain B ▁( ▁a ▁, ▁b ▁, ▁c ▁) ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁subtract One ▁( ▁int ▁x ▁) ▁{ ▁return ▁( ▁( ▁x ▁<< ▁1 ▁) ▁+ ▁( ▁~ ▁x ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁% ▁d ▁" ▁, ▁subtract One ▁( ▁13 ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁digit Sum ▁( ▁long ▁n ▁) ▁{ ▁int ▁dig Sum ▁= ▁0 ▁; ▁while ▁( ▁n ▁> ▁0 ▁) ▁{ ▁dig Sum ▁+= ▁n ▁% ▁10 ▁; ▁n ▁/= ▁10 ▁; ▁} ▁return ▁dig Sum ▁; ▁} ▁public ▁static ▁long ▁count Integer ▁( ▁long ▁n ▁, ▁long ▁s ▁) ▁{ ▁if ▁( ▁n ▁< ▁s ▁) ▁return ▁0 ▁; ▁for ▁( ▁long ▁i ▁= ▁s ▁; ▁i ▁<= ▁Math ▁. ▁min ▁( ▁n ▁, ▁s ▁+ ▁16 3 ▁) ▁; ▁i ▁++ ▁) ▁if ▁( ▁( ▁i ▁- ▁digit Sum ▁( ▁i ▁) ▁) ▁> ▁s ▁) ▁return ▁( ▁n ▁- ▁i ▁+ ▁1 ▁) ▁; ▁return ▁0 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁long ▁n ▁= ▁1000 ▁, ▁s ▁= ▁100 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Integer ▁( ▁n ▁, ▁s ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁double ▁sum Of Series ▁( ▁int ▁n ▁) ▁{ ▁return ▁0.0 246 ▁* ▁( ▁Math ▁. ▁pow ▁( ▁10 ▁, ▁n ▁) ▁- ▁1 ▁- ▁( ▁9 ▁* ▁n ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁sum Of Series ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁print _ sequence ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁b ▁= ▁n ▁/ ▁( ▁k ▁* ▁( ▁k ▁+ ▁1 ▁) ▁/ ▁2 ▁) ▁; ▁if ▁( ▁b ▁== ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁- ▁1" ▁) ▁; ▁} ▁else ▁{ ▁int ▁r ▁= ▁1 ▁; ▁for ▁( ▁int ▁x ▁= ▁1 ▁; ▁x ▁* ▁x ▁<= ▁n ▁; ▁x ▁++ ▁) ▁{ ▁if ▁( ▁n ▁% ▁x ▁!= ▁0 ▁) ▁continue ▁; ▁if ▁( ▁x ▁<= ▁b ▁&& ▁x ▁> ▁r ▁) ▁r ▁= ▁x ▁; ▁if ▁( ▁n ▁/ ▁x ▁<= ▁b ▁&& ▁n ▁/ ▁x ▁> ▁r ▁) ▁r ▁= ▁n ▁/ ▁x ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁k ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁r ▁* ▁i ▁+ ▁" ▁" ▁) ▁; ▁int ▁res ▁= ▁n ▁- ▁( ▁r ▁* ▁( ▁k ▁* ▁( ▁k ▁- ▁1 ▁) ▁/ ▁2 ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁res ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁24 ▁; ▁int ▁k ▁= ▁4 ▁; ▁print _ sequence ▁( ▁n ▁, ▁k ▁) ▁; ▁n ▁= ▁24 ▁; ▁k ▁= ▁5 ▁; ▁print _ sequence ▁( ▁n ▁, ▁k ▁) ▁; ▁n ▁= ▁6 ▁; ▁k ▁= ▁4 ▁; ▁print _ sequence ▁( ▁n ▁, ▁k ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁count Digit ▁( ▁long ▁n ▁) ▁{ ▁if ▁( ▁n ▁/ ▁10 ▁== ▁0 ▁) ▁return ▁1 ▁; ▁return ▁1 ▁+ ▁count Digit ▁( ▁n ▁/ ▁10 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁long ▁n ▁= ▁3 45 289 46 7 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Number ▁of ▁digits ▁: ▁" ▁+ ▁count Digit ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁String ▁dec To Bin ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁0 ▁) ▁return ▁"0" ▁; ▁String ▁bin ▁= ▁" ▁" ▁; ▁while ▁( ▁n ▁> ▁0 ▁) ▁{ ▁bin ▁= ▁( ▁( ▁n ▁& ▁1 ▁) ▁== ▁0 ▁? ▁'0' ▁: ▁'1' ▁) ▁+ ▁bin ▁; ▁n ▁>>= ▁1 ▁; ▁} ▁return ▁bin ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁38 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁dec To Bin ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁boolean ▁find No Is Div isible Or Not ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁a ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁% ▁n ▁!= ▁0 ▁) ▁return ▁false ▁; ▁} ▁return ▁true ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁14 ▁, ▁12 ▁, ▁4 ▁, ▁18 ▁} ▁; ▁int ▁n ▁= ▁2 ▁; ▁if ▁( ▁find No Is Div isible Or Not ▁( ▁a ▁, ▁n ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁getTotal X or Of Sub array X ors ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁if ▁( ▁N ▁% ▁2 ▁== ▁0 ▁) ▁return ▁0 ▁; ▁int ▁res ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁+= ▁2 ▁) ▁res ▁^= ▁arr ▁[ ▁i ▁] ▁; ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁5 ▁, ▁2 ▁, ▁4 ▁, ▁6 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁getTotal X or Of Sub array X ors ▁( ▁arr ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁find N th Even Digit Number ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁1 ▁) ▁{ ▁return ▁0 ▁; ▁} ▁Vector ▁< ▁Integer ▁> ▁v ▁= ▁new ▁Vector ▁< ▁> ▁( ▁) ▁; ▁n ▁= ▁n ▁- ▁1 ▁; ▁while ▁( ▁n ▁> ▁0 ▁) ▁{ ▁v ▁. ▁add ▁( ▁n ▁% ▁5 ▁) ▁; ▁n ▁= ▁n ▁/ ▁5 ▁; ▁} ▁int ▁result ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁v ▁. ▁size ▁( ▁) ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁result ▁= ▁result ▁* ▁10 ▁; ▁result ▁= ▁result ▁+ ▁v ▁. ▁get ▁( ▁i ▁) ▁; ▁} ▁return ▁2 ▁* ▁result ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁find N th Even Digit Number ▁( ▁2 ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find N th Even Digit Number ▁( ▁10 ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁long ▁modulo Multip lication ▁( ▁long ▁a ▁, ▁long ▁b ▁, ▁long ▁mod ▁) ▁{ ▁long ▁res ▁= ▁0 ▁; ▁a ▁% = ▁mod ▁; ▁while ▁( ▁b ▁> ▁0 ▁) ▁{ ▁if ▁( ▁( ▁b ▁& ▁1 ▁) ▁> ▁0 ▁) ▁{ ▁res ▁= ▁( ▁res ▁+ ▁a ▁) ▁% ▁mod ▁; ▁} ▁a ▁= ▁( ▁2 ▁* ▁a ▁) ▁% ▁mod ▁; ▁} ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁long ▁a ▁= ▁101 234 65 234 8 78 998 L ▁; ▁long ▁b ▁= ▁6 57 46 3 115 45 64 64 31 L ▁; ▁long ▁m ▁= ▁1000 54 12 33 65 48 79 4 L ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁modulo Multip lication ▁( ▁a ▁, ▁b ▁, ▁m ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁k Fact ors ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁ArrayList ▁< ▁Integer ▁> ▁P ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁while ▁( ▁n ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁P ▁. ▁add ▁( ▁2 ▁) ▁; ▁n ▁/= ▁2 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁3 ▁; ▁i ▁* ▁i ▁<= ▁n ▁; ▁i ▁= ▁i ▁+ ▁2 ▁) ▁{ ▁while ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁{ ▁n ▁= ▁n ▁/ ▁i ▁; ▁P ▁. ▁add ▁( ▁i ▁) ▁; ▁} ▁} ▁if ▁( ▁n ▁> ▁2 ▁) ▁P ▁. ▁add ▁( ▁n ▁) ▁; ▁if ▁( ▁P ▁. ▁size ▁( ▁) ▁< ▁k ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁- ▁1" ▁) ▁; ▁return ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁k ▁- ▁1 ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁P ▁. ▁get ▁( ▁i ▁) ▁+ ▁" ▁, ▁" ▁) ▁; ▁int ▁product ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁k ▁- ▁1 ▁; ▁i ▁< ▁P ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁product ▁= ▁product ▁* ▁P ▁. ▁get ▁( ▁i ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁product ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁54 ▁, ▁k ▁= ▁3 ▁; ▁k Fact ors ▁( ▁n ▁, ▁k ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁MAX ▁= ▁10000 1 ▁; ▁static ▁int ▁[ ▁] ▁perfect Div ▁= ▁new ▁int ▁[ ▁MAX ▁] ▁; ▁static ▁void ▁pre compute Counts ▁( ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁* ▁i ▁< ▁MAX ▁; ▁++ ▁i ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁* ▁i ▁; ▁j ▁< ▁MAX ▁; ▁j ▁+= ▁i ▁* ▁i ▁) ▁++ ▁perfect Div ▁[ ▁j ▁] ▁; ▁} ▁} ▁static ▁int ▁count Perf ect Div is ors ▁( ▁int ▁n ▁) ▁{ ▁return ▁perfect Div ▁[ ▁n ▁] ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁pre compute Counts ▁( ▁) ▁; ▁int ▁n ▁= ▁16 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Total ▁perfect ▁div is ors ▁of ▁" ▁+ ▁n ▁+ ▁" ▁= ▁" ▁+ ▁count Perf ect Div is ors ▁( ▁n ▁) ▁) ▁; ▁n ▁= ▁12 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Total ▁perfect ▁div is ors ▁of ▁" ▁+ ▁n ▁+ ▁" ▁= ▁" ▁+ ▁count Perf ect Div is ors ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁find Min Number ▁( ▁int ▁n ▁) ▁{ ▁int ▁count ▁= ▁0 ▁, ▁ans ▁= ▁1 ▁; ▁while ▁( ▁n ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁count ▁++ ▁; ▁n ▁/= ▁2 ▁; ▁} ▁if ▁( ▁count ▁% ▁2 ▁== ▁1 ▁) ▁ans ▁*= ▁2 ▁; ▁for ▁( ▁int ▁i ▁= ▁3 ▁; ▁i ▁<= ▁Math ▁. ▁sqrt ▁( ▁n ▁) ▁; ▁i ▁+= ▁2 ▁) ▁{ ▁count ▁= ▁0 ▁; ▁while ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁{ ▁count ▁++ ▁; ▁n ▁/= ▁i ▁; ▁} ▁if ▁( ▁count ▁% ▁2 ▁== ▁1 ▁) ▁ans ▁*= ▁i ▁; ▁} ▁if ▁( ▁n ▁> ▁2 ▁) ▁ans ▁*= ▁n ▁; ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁72 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Min Number ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁S ieve Of E rat ost hen es ▁( ▁int ▁n ▁, ▁boolean ▁prime ▁[ ▁] ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁prime ▁[ ▁i ▁] ▁= ▁true ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁* ▁p ▁<= ▁n ▁; ▁p ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁p ▁] ▁== ▁true ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁p ▁* ▁2 ▁; ▁i ▁<= ▁n ▁; ▁i ▁+= ▁p ▁) ▁prime ▁[ ▁i ▁] ▁= ▁false ▁; ▁} ▁} ▁} ▁static ▁void ▁m ers en ne Pr imes ▁( ▁int ▁n ▁) ▁{ ▁boolean ▁prime ▁[ ▁] ▁= ▁new ▁boolean ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁S ieve Of E rat ost hen es ▁( ▁n ▁, ▁prime ▁) ▁; ▁for ▁( ▁int ▁k ▁= ▁2 ▁; ▁( ▁( ▁1 ▁<< ▁k ▁) ▁- ▁1 ▁) ▁<= ▁n ▁; ▁k ▁++ ▁) ▁{ ▁long ▁num ▁= ▁( ▁1 ▁<< ▁k ▁) ▁- ▁1 ▁; ▁if ▁( ▁prime ▁[ ▁( ▁int ▁) ▁( ▁num ▁) ▁] ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁num ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁31 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁M ers en ne ▁prime ▁" ▁+ ▁" ▁numbers ▁smaller ▁than ▁" ▁+ ▁" ▁or ▁equal ▁to ▁" ▁+ ▁n ▁) ▁; ▁m ers en ne Pr imes ▁( ▁n ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁math ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁is Perf ect ▁( ▁int ▁n ▁) ▁{ ▁int ▁s ▁= ▁( ▁int ▁) ▁( ▁Math ▁. ▁sqrt ▁( ▁n ▁) ▁) ▁; ▁return ▁( ▁s ▁* ▁s ▁== ▁n ▁) ▁; ▁} ▁static ▁int ▁div is ors Count ▁( ▁int ▁n ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁Math ▁. ▁sqrt ▁( ▁n ▁) ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁{ ▁if ▁( ▁n ▁/ ▁i ▁== ▁i ▁) ▁count ▁+= ▁1 ▁; ▁else ▁count ▁+= ▁2 ▁; ▁} ▁} ▁return ▁count ▁; ▁} ▁static ▁int ▁k Div is ors ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁int ▁k ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁a ▁; ▁i ▁<= ▁b ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁is Perf ect ▁( ▁i ▁) ▁) ▁if ▁( ▁div is ors Count ▁( ▁i ▁) ▁== ▁k ▁) ▁count ▁++ ▁; ▁} ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁a ▁= ▁21 ▁, ▁b ▁= ▁14 9 ▁, ▁k ▁= ▁3 33 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁k Div is ors ▁( ▁a ▁, ▁b ▁, ▁k ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁find Count Of Solution s ▁( ▁int ▁n ▁, ▁int ▁p ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁x ▁= ▁1 ▁; ▁x ▁< ▁p ▁; ▁x ▁++ ▁) ▁{ ▁if ▁( ▁( ▁x ▁* ▁x ▁) ▁% ▁p ▁== ▁1 ▁) ▁{ ▁int ▁last ▁= ▁x ▁+ ▁p ▁* ▁( ▁n ▁/ ▁p ▁) ▁; ▁if ▁( ▁last ▁> ▁n ▁) ▁last ▁-= ▁p ▁; ▁ans ▁+= ▁( ▁( ▁last ▁- ▁x ▁) ▁/ ▁p ▁+ ▁1 ▁) ▁; ▁} ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁10 ▁; ▁int ▁p ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Count Of Solution s ▁( ▁n ▁, ▁p ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁k ap re k ar Rec ▁( ▁int ▁n ▁, ▁int ▁prev ▁) ▁{ ▁if ▁( ▁n ▁== ▁0 ▁) ▁return ▁0 ▁; ▁prev ▁= ▁n ▁; ▁int ▁[ ▁] ▁digits ▁= ▁new ▁int ▁[ ▁4 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁4 ▁; ▁i ▁++ ▁) ▁{ ▁digits ▁[ ▁i ▁] ▁= ▁n ▁% ▁10 ▁; ▁n ▁= ▁n ▁/ ▁10 ▁; ▁} ▁Arrays ▁. ▁sort ▁( ▁digits ▁) ▁; ▁int ▁asc ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁4 ▁; ▁i ▁++ ▁) ▁asc ▁= ▁asc ▁* ▁10 ▁+ ▁digits ▁[ ▁i ▁] ▁; ▁Arrays ▁. ▁sort ▁( ▁digits ▁) ▁; ▁int ▁desc ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁3 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁desc ▁= ▁desc ▁* ▁10 ▁+ ▁digits ▁[ ▁i ▁] ▁; ▁int ▁diff ▁= ▁Math ▁. ▁abs ▁( ▁asc ▁- ▁desc ▁) ▁; ▁if ▁( ▁diff ▁== ▁prev ▁) ▁return ▁diff ▁; ▁return ▁k ap re k ar Rec ▁( ▁diff ▁, ▁prev ▁) ▁; ▁} ▁static ▁int ▁k ap re k ar ▁( ▁int ▁n ▁) ▁{ ▁int ▁prev ▁= ▁0 ▁; ▁return ▁k ap re k ar Rec ▁( ▁n ▁, ▁prev ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁k ap re k ar ▁( ▁1000 ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁k ap re k ar ▁( ▁11 12 ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁k ap re k ar ▁( ▁98 12 ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁code _ conversion ▁{ ▁char ▁xor _ c ▁( ▁char ▁a ▁, ▁char ▁b ▁) ▁{ ▁return ▁( ▁a ▁== ▁b ▁) ▁? ▁'0' ▁: ▁'1' ▁; ▁} ▁char ▁flip ▁( ▁char ▁c ▁) ▁{ ▁return ▁( ▁c ▁== ▁'0' ▁) ▁? ▁'1' ▁: ▁'0' ▁; ▁} ▁String ▁binary to Gray ▁( ▁String ▁binary ▁) ▁{ ▁String ▁gray ▁= ▁" ▁" ▁; ▁gray ▁+= ▁binary ▁. ▁charAt ▁( ▁0 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁binary ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁gray ▁+= ▁xor _ c ▁( ▁binary ▁. ▁charAt ▁( ▁i ▁- ▁1 ▁) ▁, ▁binary ▁. ▁charAt ▁( ▁i ▁) ▁) ▁; ▁} ▁return ▁gray ▁; ▁} ▁String ▁gray to Binary ▁( ▁String ▁gray ▁) ▁{ ▁String ▁binary ▁= ▁" ▁" ▁; ▁binary ▁+= ▁gray ▁. ▁charAt ▁( ▁0 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁gray ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁gray ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'0' ▁) ▁binary ▁+= ▁binary ▁. ▁charAt ▁( ▁i ▁- ▁1 ▁) ▁; ▁else ▁binary ▁+= ▁flip ▁( ▁binary ▁. ▁charAt ▁( ▁i ▁- ▁1 ▁) ▁) ▁; ▁} ▁return ▁binary ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁throws ▁IOException ▁{ ▁code _ conversion ▁ob ▁= ▁new ▁code _ conversion ▁( ▁) ▁; ▁String ▁binary ▁= ▁" 0100 1" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁G ray ▁code ▁of ▁" ▁+ ▁binary ▁+ ▁" ▁is ▁" ▁+ ▁ob ▁. ▁binary to Gray ▁( ▁binary ▁) ▁) ▁; ▁String ▁gray ▁= ▁"01 101 " ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Binary ▁code ▁of ▁" ▁+ ▁gray ▁+ ▁" ▁is ▁" ▁+ ▁ob ▁. ▁gray to Binary ▁( ▁gray ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁getSum ▁( ▁int ▁BIT ree ▁[ ▁] ▁, ▁int ▁index ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁while ▁( ▁index ▁> ▁0 ▁) ▁{ ▁sum ▁+= ▁BIT ree ▁[ ▁index ▁] ▁; ▁index ▁-= ▁index ▁& ▁( ▁- ▁index ▁) ▁; ▁} ▁return ▁sum ▁; ▁} ▁static ▁void ▁update BIT ▁( ▁int ▁BIT ree ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁index ▁, ▁int ▁val ▁) ▁{ ▁while ▁( ▁index ▁<= ▁n ▁) ▁{ ▁BIT ree ▁[ ▁index ▁] ▁+= ▁val ▁; ▁index ▁+= ▁index ▁& ▁( ▁- ▁index ▁) ▁; ▁} ▁} ▁static ▁void ▁convert ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁[ ▁] ▁temp ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁temp ▁[ ▁i ▁] ▁= ▁arr ▁[ ▁i ▁] ▁; ▁Arrays ▁. ▁sort ▁( ▁temp ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁arr ▁[ ▁i ▁] ▁= ▁lower _ bound ▁( ▁temp ▁, ▁0 ▁, ▁n ▁, ▁arr ▁[ ▁i ▁] ▁) ▁+ ▁1 ▁; ▁} ▁} ▁static ▁int ▁lower _ bound ▁( ▁int ▁[ ▁] ▁a ▁, ▁int ▁low ▁, ▁int ▁high ▁, ▁int ▁element ▁) ▁{ ▁while ▁( ▁low ▁< ▁high ▁) ▁{ ▁int ▁middle ▁= ▁low ▁+ ▁( ▁high ▁- ▁low ▁) ▁/ ▁2 ▁; ▁if ▁( ▁element ▁> ▁a ▁[ ▁middle ▁] ▁) ▁low ▁= ▁middle ▁+ ▁1 ▁; ▁else ▁high ▁= ▁middle ▁; ▁} ▁return ▁low ▁; ▁} ▁static ▁int ▁getIn v Count ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁inv count ▁= ▁0 ▁; ▁convert ▁( ▁arr ▁, ▁n ▁) ▁; ▁int ▁[ ▁] ▁BIT ▁= ▁new ▁int ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁BIT ▁[ ▁i ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁inv count ▁+= ▁getSum ▁( ▁BIT ▁, ▁arr ▁[ ▁i ▁] ▁- ▁1 ▁) ▁; ▁update BIT ▁( ▁BIT ▁, ▁n ▁, ▁arr ▁[ ▁i ▁] ▁, ▁1 ▁) ▁; ▁} ▁return ▁inv count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁mod ▁( ▁String ▁num ▁, ▁int ▁a ▁) ▁{ ▁int ▁res ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁num ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁res ▁= ▁( ▁res ▁* ▁10 ▁+ ▁( ▁int ▁) ▁num ▁. ▁charAt ▁( ▁i ▁) ▁- ▁'0' ▁) ▁% ▁a ▁; ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁num ▁= ▁"123 16 76 76 786 78 " ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁mod ▁( ▁num ▁, ▁10 ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁phi ▁( ▁int ▁n ▁) ▁{ ▁float ▁result ▁= ▁n ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁* ▁p ▁<= ▁n ▁; ▁++ ▁p ▁) ▁{ ▁if ▁( ▁n ▁% ▁p ▁== ▁0 ▁) ▁{ ▁while ▁( ▁n ▁% ▁p ▁== ▁0 ▁) ▁n ▁/= ▁p ▁; ▁result ▁*= ▁( ▁1.0 ▁- ▁( ▁1.0 ▁/ ▁( ▁float ▁) ▁p ▁) ▁) ▁; ▁} ▁} ▁if ▁( ▁n ▁> ▁1 ▁) ▁result ▁*= ▁( ▁1.0 ▁- ▁( ▁1.0 ▁/ ▁( ▁float ▁) ▁n ▁) ▁) ▁; ▁return ▁( ▁int ▁) ▁result ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁n ▁; ▁for ▁( ▁n ▁= ▁1 ▁; ▁n ▁<= ▁10 ▁; ▁n ▁++ ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁phi ▁( ▁" ▁+ ▁n ▁+ ▁" ▁) ▁= ▁" ▁+ ▁phi ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁L argest power ▁( ▁int ▁n ▁, ▁int ▁p ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁while ▁( ▁n ▁> ▁0 ▁) ▁{ ▁n ▁/= ▁p ▁; ▁ans ▁+= ▁n ▁; ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁10 ▁; ▁int ▁p ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁The ▁largest ▁power ▁of ▁" ▁+ ▁p ▁+ ▁" ▁that ▁div ides ▁" ▁+ ▁n ▁+ ▁" ▁! ▁is ▁" ▁+ ▁L argest power ▁( ▁n ▁, ▁p ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁print Square s ▁( ▁int ▁n ▁) ▁{ ▁int ▁square ▁= ▁0 ▁, ▁odd ▁= ▁1 ▁; ▁for ▁( ▁int ▁x ▁= ▁0 ▁; ▁x ▁< ▁n ▁; ▁x ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁square ▁+ ▁" ▁" ▁) ▁; ▁square ▁= ▁square ▁+ ▁odd ▁; ▁odd ▁= ▁odd ▁+ ▁2 ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁5 ▁; ▁print Square s ▁( ▁n ▁) ▁; ▁} ▁}
▁class ▁Factor ial ▁{ ▁int ▁factorial ▁( ▁int ▁n ▁) ▁{ ▁return ▁( ▁n ▁== ▁1 ▁n ▁== ▁0 ▁) ▁? ▁1 ▁: ▁n ▁* ▁factorial ▁( ▁n ▁- ▁1 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁Factor ial ▁obj ▁= ▁new ▁Factor ial ▁( ▁) ▁; ▁int ▁num ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Factor ial ▁of ▁" ▁+ ▁num ▁+ ▁" ▁is ▁" ▁+ ▁obj ▁. ▁factorial ▁( ▁num ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁Or _ of _ And s _ for _ each _ query ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁queries ▁[ ▁] ▁[ ▁] ▁, ▁int ▁q ▁) ▁{ ▁int ▁bits ▁[ ▁] ▁= ▁new ▁int ▁[ ▁32 ▁] ▁; ▁Arrays ▁. ▁fill ▁( ▁bits ▁, ▁0 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁32 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁( ▁( ▁1 ▁<< ▁i ▁) ▁& ▁arr ▁[ ▁j ▁] ▁) ▁!= ▁0 ▁) ▁{ ▁bits ▁[ ▁i ▁] ▁++ ▁; ▁} ▁} ▁} ▁for ▁( ▁int ▁p ▁= ▁0 ▁; ▁p ▁< ▁q ▁; ▁p ▁++ ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁32 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁( ▁1 ▁<< ▁i ▁) ▁& ▁arr ▁[ ▁queries ▁[ ▁p ▁] ▁[ ▁0 ▁] ▁] ▁) ▁!= ▁0 ▁) ▁{ ▁bits ▁[ ▁i ▁] ▁-- ▁; ▁} ▁if ▁( ▁( ▁queries ▁[ ▁p ▁] ▁[ ▁1 ▁] ▁& ▁( ▁1 ▁<< ▁i ▁) ▁) ▁!= ▁0 ▁) ▁{ ▁bits ▁[ ▁i ▁] ▁++ ▁; ▁} ▁} ▁arr ▁[ ▁queries ▁[ ▁p ▁] ▁[ ▁0 ▁] ▁] ▁= ▁queries ▁[ ▁p ▁] ▁[ ▁1 ▁] ▁; ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁32 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁bits ▁[ ▁i ▁] ▁!= ▁0 ▁) ▁{ ▁ans ▁|= ▁( ▁1 ▁<< ▁i ▁) ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁ans ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁3 ▁, ▁q ▁= ▁2 ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁5 ▁, ▁7 ▁} ▁; ▁int ▁queries ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁} ▁, ▁{ ▁2 ▁, ▁1 ▁} ▁} ▁; ▁Or _ of _ And s _ for _ each _ query ▁( ▁arr ▁, ▁n ▁, ▁queries ▁, ▁q ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁find max ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁tra v ▁, ▁i ▁; ▁int ▁c ▁= ▁0 ▁, ▁maximum ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁k ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁tra v ▁= ▁i ▁- ▁1 ▁; ▁c ▁= ▁0 ▁; ▁while ▁( ▁tra v ▁>= ▁0 ▁&& ▁arr ▁[ ▁tra v ▁] ▁== ▁1 ▁) ▁{ ▁tra v ▁-- ▁; ▁c ▁++ ▁; ▁} ▁tra v ▁= ▁i ▁+ ▁k ▁; ▁while ▁( ▁tra v ▁< ▁n ▁&& ▁arr ▁[ ▁tra v ▁] ▁== ▁1 ▁) ▁{ ▁tra v ▁++ ▁; ▁c ▁++ ▁; ▁} ▁c ▁+= ▁k ▁; ▁if ▁( ▁c ▁> ▁maximum ▁) ▁maximum ▁= ▁c ▁; ▁} ▁return ▁maximum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁k ▁= ▁3 ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁int ▁ans ▁= ▁find max ▁( ▁arr ▁, ▁n ▁, ▁k ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁ans ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁max And X or ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁ans ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁Arrays ▁. ▁sort ▁( ▁arr ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁ans ▁= ▁Math ▁. ▁min ▁( ▁ans ▁, ▁arr ▁[ ▁i ▁] ▁^ ▁arr ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁new ▁int ▁[ ▁] ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁max And X or ▁( ▁arr ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁count Sub array ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁K ▁, ▁int ▁N ▁) ▁{ ▁if ▁( ▁K ▁% ▁2 ▁!= ▁0 ▁) ▁return ▁0 ▁; ▁if ▁( ▁N ▁< ▁K ▁) ▁return ▁0 ▁; ▁int ▁start ▁= ▁0 ▁; ▁int ▁i ▁= ▁0 ▁; ▁int ▁count ▁= ▁0 ▁; ▁int ▁curr X or ▁= ▁arr ▁[ ▁i ▁++ ▁] ▁; ▁while ▁( ▁i ▁< ▁K ▁) ▁{ ▁curr X or ▁^= ▁arr ▁[ ▁i ▁] ▁; ▁i ▁++ ▁; ▁} ▁if ▁( ▁curr X or ▁== ▁0 ▁) ▁count ▁++ ▁; ▁curr X or ▁^= ▁arr ▁[ ▁start ▁++ ▁] ▁; ▁while ▁( ▁i ▁< ▁N ▁) ▁{ ▁curr X or ▁^= ▁arr ▁[ ▁i ▁] ▁; ▁i ▁++ ▁; ▁if ▁( ▁curr X or ▁== ▁0 ▁) ▁count ▁++ ▁; ▁curr X or ▁^= ▁arr ▁[ ▁start ▁++ ▁] ▁; ▁} ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁2 ▁, ▁4 ▁, ▁4 ▁, ▁2 ▁, ▁2 ▁, ▁4 ▁} ▁; ▁int ▁K ▁= ▁4 ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Sub array ▁( ▁arr ▁, ▁K ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁minimum F lips ▁( ▁int ▁X ▁, ▁int ▁Y ▁, ▁int ▁Z ▁) ▁{ ▁int ▁res ▁= ▁0 ▁; ▁while ▁( ▁X ▁> ▁0 ▁Y ▁> ▁0 ▁Z ▁> ▁0 ▁) ▁{ ▁if ▁( ▁( ▁( ▁X ▁% ▁2 ▁== ▁1 ▁) ▁|| ▁( ▁Y ▁% ▁2 ▁== ▁1 ▁) ▁) ▁&& ▁( ▁Z ▁% ▁2 ▁== ▁1 ▁) ▁) ▁{ ▁X ▁= ▁X ▁>> ▁1 ▁; ▁Y ▁= ▁Y ▁>> ▁1 ▁; ▁Z ▁= ▁Z ▁>> ▁1 ▁; ▁continue ▁; ▁} ▁else ▁if ▁( ▁! ▁( ▁X ▁% ▁2 ▁== ▁1 ▁) ▁&& ▁! ▁( ▁Y ▁% ▁2 ▁== ▁1 ▁) ▁&& ▁( ▁Z ▁% ▁2 ▁== ▁1 ▁) ▁) ▁{ ▁res ▁++ ▁; ▁} ▁else ▁if ▁( ▁( ▁X ▁% ▁2 ▁== ▁1 ▁) ▁|| ▁( ▁Y ▁% ▁2 ▁== ▁1 ▁) ▁) ▁{ ▁if ▁( ▁( ▁X ▁% ▁2 ▁== ▁1 ▁) ▁&& ▁( ▁Y ▁% ▁2 ▁== ▁1 ▁) ▁&& ▁! ▁( ▁Z ▁% ▁2 ▁== ▁1 ▁) ▁) ▁{ ▁res ▁+= ▁2 ▁; ▁} ▁else ▁if ▁( ▁( ▁( ▁X ▁% ▁2 ▁== ▁1 ▁) ▁|| ▁( ▁Y ▁% ▁2 ▁== ▁1 ▁) ▁) ▁&& ▁! ▁( ▁Z ▁% ▁2 ▁== ▁1 ▁) ▁) ▁{ ▁res ▁++ ▁; ▁} ▁} ▁X ▁= ▁X ▁>> ▁1 ▁; ▁Y ▁= ▁Y ▁>> ▁1 ▁; ▁Z ▁= ▁Z ▁>> ▁1 ▁; ▁} ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁X ▁= ▁5 ▁, ▁Y ▁= ▁8 ▁, ▁Z ▁= ▁6 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁minimum F lips ▁( ▁X ▁, ▁Y ▁, ▁Z ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁F lip Bits ▁( ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁bit ▁= ▁0 ▁; ▁bit ▁< ▁32 ▁; ▁bit ▁++ ▁) ▁{ ▁if ▁( ▁( ▁n ▁>> ▁bit ▁) ▁% ▁2 ▁> ▁0 ▁) ▁{ ▁n ▁= ▁n ▁^ ▁( ▁1 ▁<< ▁bit ▁) ▁; ▁break ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁The ▁number ▁after ▁un setting ▁the ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁right most ▁set ▁bit ▁" ▁+ ▁n ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁12 ▁; ▁F lip Bits ▁( ▁N ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁bitwise And Odd ▁( ▁int ▁n ▁) ▁{ ▁int ▁result ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁3 ▁; ▁i ▁<= ▁n ▁; ▁i ▁= ▁i ▁+ ▁2 ▁) ▁{ ▁result ▁= ▁( ▁result ▁& ▁i ▁) ▁; ▁} ▁return ▁result ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁10 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁bitwise And Odd ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁long ▁multiply By F if te en ▁( ▁long ▁n ▁) ▁{ ▁long ▁prod ▁= ▁( ▁n ▁<< ▁3 ▁) ▁; ▁prod ▁+= ▁( ▁n ▁<< ▁2 ▁) ▁; ▁prod ▁+= ▁( ▁n ▁<< ▁1 ▁) ▁; ▁prod ▁+= ▁n ▁; ▁return ▁prod ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁long ▁n ▁= ▁7 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁multiply By F if te en ▁( ▁n ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁G F G ▁{ ▁static ▁int ▁count X ▁( ▁int ▁n ▁) ▁{ ▁String ▁binary ▁= ▁Integer ▁. ▁to Binary String ▁( ▁n ▁) ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁binary ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁binary ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'1' ▁) ▁count ▁++ ▁; ▁} ▁int ▁answer ▁= ▁( ▁int ▁) ▁Math ▁. ▁pow ▁( ▁2 ▁, ▁count ▁) ▁; ▁return ▁answer ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁5 ▁; ▁int ▁answer ▁= ▁count X ▁( ▁n ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁answer ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁alternate ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁int ▁x ▁) ▁{ ▁return ▁x ▁= ▁a ▁^ ▁b ▁^ ▁x ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁= ▁- ▁10 ▁; ▁int ▁b ▁= ▁15 ▁; ▁int ▁x ▁= ▁a ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁x ▁is ▁: ▁" ▁+ ▁x ▁) ▁; ▁x ▁= ▁alternate ▁( ▁a ▁, ▁b ▁, ▁x ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁After ▁exchange ▁"); ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁x ▁is ▁: ▁" ▁+ ▁x ); ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁solve ▁( ▁int ▁A ▁, ▁int ▁B ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁32 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁( ▁A ▁>> ▁i ▁) ▁& ▁1 ▁) ▁!= ▁( ▁( ▁B ▁>> ▁i ▁) ▁& ▁1 ▁) ▁) ▁{ ▁count ▁++ ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Number ▁of ▁different ▁bits ▁: ▁" ▁+ ▁count ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁A ▁= ▁12 ▁, ▁B ▁= ▁15 ▁; ▁solve ▁( ▁A ▁, ▁B ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁class ▁Node ▁{ ▁int ▁data ▁; ▁Node ▁left ▁, ▁right ▁; ▁} ▁; ▁static ▁Node ▁newNode ▁( ▁int ▁data ▁) ▁{ ▁Node ▁node ▁= ▁new ▁Node ▁( ▁) ▁; ▁node ▁. ▁data ▁= ▁data ▁; ▁node ▁. ▁left ▁= ▁node ▁. ▁right ▁= ▁null ▁; ▁return ▁( ▁node ▁) ▁; ▁} ▁static ▁void ▁print Set Bit ▁( ▁Node ▁root ▁) ▁{ ▁if ▁( ▁root ▁== ▁null ▁) ▁return ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Set ▁bits ▁in ▁Node ▁" ▁+ ▁root ▁. ▁data ▁+ ▁" ▁= ▁" ▁+ ▁Integer ▁. ▁bit Count ▁( ▁root ▁. ▁data ▁) ▁+ ▁" NEW _ LINE "); ▁print Set Bit ▁( ▁root ▁. ▁left ▁) ▁; ▁print Set Bit ▁( ▁root ▁. ▁right ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Node ▁root ▁= ▁newNode ▁( ▁16 ▁) ▁; ▁root ▁. ▁left ▁= ▁newNode ▁( ▁13 ▁) ▁; ▁root ▁. ▁left ▁. ▁left ▁= ▁newNode ▁( ▁14 ▁) ▁; ▁root ▁. ▁left ▁. ▁right ▁= ▁newNode ▁( ▁12 ▁) ▁; ▁root ▁. ▁right ▁= ▁newNode ▁( ▁11 ▁) ▁; ▁root ▁. ▁right ▁. ▁left ▁= ▁newNode ▁( ▁10 ▁) ▁; ▁root ▁. ▁right ▁. ▁right ▁= ▁newNode ▁( ▁16 ▁) ▁; ▁print Set Bit ▁( ▁root ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁solution ▁{ ▁static ▁void ▁Make Pre Sum ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁[ ▁] ▁presum ▁, ▁int ▁n ▁) ▁{ ▁presum ▁[ ▁0 ▁] ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁presum ▁[ ▁i ▁] ▁= ▁presum ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁arr ▁[ ▁i ▁] ▁; ▁} ▁static ▁int ▁Binary L if ting ▁( ▁int ▁[ ▁] ▁presum ▁, ▁int ▁n ▁, ▁int ▁x ▁) ▁{ ▁int ▁pos ▁= ▁0 ▁; ▁int ▁LOG N ▁= ▁( ▁int ▁) ▁Math ▁. ▁log ▁( ▁n ▁) ▁; ▁if ▁( ▁x ▁<= ▁presum ▁[ ▁0 ▁] ▁) ▁return ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁LOG N ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁pos ▁+ ▁( ▁1 ▁<< ▁i ▁) ▁< ▁n ▁&& ▁presum ▁[ ▁pos ▁+ ▁( ▁1 ▁<< ▁i ▁) ▁] ▁< ▁x ▁) ▁{ ▁pos ▁+= ▁( ▁1 ▁<< ▁i ▁) ▁; ▁} ▁} ▁return ▁pos ▁+ ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁2 ▁, ▁5 ▁, ▁7 ▁, ▁1 ▁, ▁6 ▁, ▁9 ▁, ▁12 ▁, ▁4 ▁, ▁6 ▁} ▁; ▁int ▁x ▁= ▁8 ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁int ▁[ ▁] ▁presum ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁Arrays ▁. ▁fill ▁( ▁presum ▁, ▁0 ▁) ▁; ▁Make Pre Sum ▁( ▁arr ▁, ▁presum ▁, ▁n ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁Binary L if ting ▁( ▁presum ▁, ▁n ▁, ▁x ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁boolean ▁all Bits Set In The Given Range ▁( ▁int ▁n ▁, ▁int ▁l ▁, ▁int ▁r ▁) ▁{ ▁int ▁num ▁= ▁( ▁( ▁1 ▁<< ▁r ▁) ▁- ▁1 ▁) ▁^ ▁( ▁( ▁1 ▁<< ▁( ▁l ▁- ▁1 ▁) ▁) ▁- ▁1 ▁) ▁; ▁int ▁new _ num ▁= ▁n ▁& ▁num ▁; ▁if ▁( ▁new _ num ▁== ▁0 ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁17 ▁; ▁int ▁l ▁= ▁2 ▁, ▁r ▁= ▁4 ▁; ▁if ▁( ▁all Bits Set In The Given Range ▁( ▁n ▁, ▁l ▁, ▁r ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁boolean ▁only First And Last Are Set ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁1 ▁) ▁return ▁true ▁; ▁if ▁( ▁n ▁== ▁2 ▁) ▁return ▁false ▁; ▁return ▁( ▁( ▁( ▁n ▁- ▁1 ▁) ▁& ▁( ▁n ▁- ▁2 ▁) ▁) ▁== ▁0 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁9 ▁; ▁if ▁( ▁only First And Last Are Set ▁( ▁n ▁) ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁int ▁_ pop cnt 32 ▁( ▁long ▁number ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁while ▁( ▁number ▁> ▁0 ▁) ▁{ ▁count ▁+= ▁number ▁& ▁1 L ▁; ▁number ▁>>= ▁1 L ▁; ▁} ▁return ▁count ▁; ▁} ▁static ▁long ▁minimize ▁( ▁long ▁a ▁) ▁{ ▁int ▁n ▁= ▁_ pop cnt 32 ▁( ▁a ▁) ▁; ▁return ▁( ▁( ▁long ▁) ▁Math ▁. ▁pow ▁( ▁2 ▁, ▁n ▁) ▁- ▁1 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁long ▁a ▁= ▁11 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁minimize ▁( ▁a ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁getM id ▁( ▁int ▁s ▁, ▁int ▁e ▁) ▁{ ▁return ▁s ▁+ ▁( ▁e ▁- ▁s ▁) ▁/ ▁2 ▁; ▁} ▁static ▁void ▁construct ST Util ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁ss ▁, ▁int ▁se ▁, ▁int ▁st ▁[ ▁] ▁, ▁int ▁si ▁, ▁boolean ▁operation ▁) ▁{ ▁if ▁( ▁ss ▁== ▁se ▁) ▁{ ▁st ▁[ ▁si ▁] ▁= ▁arr ▁[ ▁ss ▁] ▁; ▁return ▁; ▁} ▁int ▁mid ▁= ▁getM id ▁( ▁ss ▁, ▁se ▁) ▁; ▁construct ST Util ▁( ▁arr ▁, ▁ss ▁, ▁mid ▁, ▁st ▁, ▁si ▁* ▁2 ▁+ ▁1 ▁, ▁! ▁operation ▁) ▁; ▁construct ST Util ▁( ▁arr ▁, ▁mid ▁+ ▁1 ▁, ▁se ▁, ▁st ▁, ▁si ▁* ▁2 ▁+ ▁2 ▁, ▁! ▁operation ▁) ▁; ▁if ▁( ▁operation ▁) ▁{ ▁st ▁[ ▁si ▁] ▁= ▁( ▁st ▁[ ▁2 ▁* ▁si ▁+ ▁1 ▁] ▁st ▁[ ▁2 ▁* ▁si ▁+ ▁2 ▁] ▁) ▁; ▁} ▁else ▁{ ▁st ▁[ ▁si ▁] ▁= ▁( ▁st ▁[ ▁2 ▁* ▁si ▁+ ▁1 ▁] ▁^ ▁st ▁[ ▁2 ▁* ▁si ▁+ ▁2 ▁] ▁) ▁; ▁} ▁} ▁static ▁int ▁[ ▁] ▁construct ST ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁x ▁= ▁( ▁int ▁) ▁( ▁Math ▁. ▁ceil ▁( ▁Math ▁. ▁log ▁( ▁n ▁) ▁/ ▁Math ▁. ▁log ▁( ▁2 ▁) ▁) ▁) ▁; ▁int ▁max _ size ▁= ▁2 ▁* ▁( ▁int ▁) ▁Math ▁. ▁pow ▁( ▁2 ▁, ▁x ▁) ▁- ▁1 ▁; ▁int ▁[ ▁] ▁st ▁= ▁new ▁int ▁[ ▁max _ size ▁] ▁; ▁boolean ▁operation At Root ▁= ▁! ▁( ▁x ▁% ▁2 ▁== ▁0 ▁) ▁; ▁construct ST Util ▁( ▁arr ▁, ▁0 ▁, ▁n ▁- ▁1 ▁, ▁st ▁, ▁0 ▁, ▁operation At Root ▁) ▁; ▁return ▁st ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁leaves ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁6 ▁, ▁3 ▁, ▁7 ▁, ▁5 ▁, ▁9 ▁, ▁10 ▁, ▁4 ▁} ▁; ▁int ▁n ▁= ▁leaves ▁. ▁length ▁; ▁int ▁[ ▁] ▁segment Tree ▁= ▁construct ST ▁( ▁leaves ▁, ▁n ▁) ▁; ▁int ▁root Index ▁= ▁0 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Value ▁at ▁Root ▁Node ▁= ▁" ▁+ ▁segment Tree ▁[ ▁root Index ▁] ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁boolean ▁isF ib binary Num ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁( ▁n ▁& ▁( ▁n ▁>> ▁1 ▁) ▁) ▁== ▁0 ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁10 ▁; ▁if ▁( ▁isF ib binary Num ▁( ▁n ▁) ▁== ▁true ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁long ▁divide ▁( ▁long ▁div id end ▁, ▁long ▁divisor ▁) ▁{ ▁long ▁sign ▁= ▁( ▁( ▁div id end ▁< ▁0 ▁) ▁^ ▁( ▁divisor ▁< ▁0 ▁) ▁) ▁? ▁- ▁1 ▁: ▁1 ▁; ▁div id end ▁= ▁Math ▁. ▁abs ▁( ▁div id end ▁) ▁; ▁divisor ▁= ▁Math ▁. ▁abs ▁( ▁divisor ▁) ▁; ▁long ▁quot ient ▁= ▁0 ▁, ▁temp ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁31 ▁; ▁i ▁>= ▁0 ▁; ▁-- ▁i ▁) ▁{ ▁if ▁( ▁temp ▁+ ▁( ▁divisor ▁<< ▁i ▁) ▁<= ▁div id end ▁) ▁{ ▁temp ▁+= ▁divisor ▁<< ▁i ▁; ▁quot ient ▁|= ▁1 L ▁<< ▁i ▁; ▁} ▁} ▁if ▁( ▁sign ▁== ▁- ▁1 ▁) ▁quot ient ▁= ▁- ▁quot ient ▁; ▁return ▁quot ient ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁a ▁= ▁10 ▁, ▁b ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁divide ▁( ▁a ▁, ▁b ▁) ▁) ▁; ▁int ▁a 1 ▁= ▁43 ▁, ▁b 1 ▁= ▁- ▁8 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁divide ▁( ▁a 1 ▁, ▁b 1 ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁public ▁class ▁G f G ▁{ ▁static ▁int ▁max AND ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁res ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁res ▁= ▁res ▁> ▁( ▁arr ▁[ ▁i ▁] ▁& ▁arr ▁[ ▁j ▁] ▁) ▁? ▁res ▁: ▁( ▁arr ▁[ ▁i ▁] ▁& ▁arr ▁[ ▁j ▁] ▁) ▁; ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁arg c ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁8 ▁, ▁6 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Maximum ▁AND ▁Value ▁= ▁" ▁+ ▁max AND ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁setAll Bits After MS B ▁( ▁int ▁n ▁) ▁{ ▁n ▁|= ▁n ▁>> ▁1 ▁; ▁n ▁|= ▁n ▁>> ▁2 ▁; ▁n ▁|= ▁n ▁>> ▁4 ▁; ▁n ▁|= ▁n ▁>> ▁8 ▁; ▁n ▁|= ▁n ▁>> ▁16 ▁; ▁return ▁n ▁; ▁} ▁static ▁int ▁toggle ▁( ▁int ▁n ▁) ▁{ ▁n ▁= ▁n ▁^ ▁setAll Bits After MS B ▁( ▁n ▁) ▁; ▁return ▁n ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁arg ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁10 ▁; ▁n ▁= ▁toggle ▁( ▁n ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁n ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁INT _ SIZE ▁= ▁32 ▁; ▁static ▁int ▁construct N th Number ▁( ▁int ▁group _ no ▁, ▁int ▁aux _ num ▁, ▁int ▁op ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁new ▁int ▁[ ▁INT _ SIZE ▁] ▁; ▁int ▁num ▁= ▁0 ▁, ▁len _ f ▁; ▁int ▁i ▁= ▁0 ▁; ▁if ▁( ▁op ▁== ▁2 ▁) ▁{ ▁len _ f ▁= ▁2 ▁* ▁group _ no ▁; ▁a ▁[ ▁len _ f ▁- ▁1 ▁] ▁= ▁a ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁while ▁( ▁aux _ num ▁> ▁0 ▁) ▁{ ▁a ▁[ ▁group _ no ▁+ ▁i ▁] ▁= ▁a ▁[ ▁group _ no ▁- ▁1 ▁- ▁i ▁] ▁= ▁aux _ num ▁& ▁1 ▁; ▁aux _ num ▁= ▁aux _ num ▁>> ▁1 ▁; ▁i ▁++ ▁; ▁} ▁} ▁else ▁if ▁( ▁op ▁== ▁0 ▁) ▁{ ▁len _ f ▁= ▁2 ▁* ▁group _ no ▁+ ▁1 ▁; ▁a ▁[ ▁len _ f ▁- ▁1 ▁] ▁= ▁a ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁a ▁[ ▁group _ no ▁] ▁= ▁0 ▁; ▁while ▁( ▁aux _ num ▁> ▁0 ▁) ▁{ ▁a ▁[ ▁group _ no ▁+ ▁1 ▁+ ▁i ▁] ▁= ▁a ▁[ ▁group _ no ▁- ▁1 ▁- ▁i ▁] ▁= ▁aux _ num ▁& ▁1 ▁; ▁aux _ num ▁= ▁aux _ num ▁>> ▁1 ▁; ▁i ▁++ ▁; ▁} ▁} ▁{ ▁len _ f ▁= ▁2 ▁* ▁group _ no ▁+ ▁1 ▁; ▁a ▁[ ▁len _ f ▁- ▁1 ▁] ▁= ▁a ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁a ▁[ ▁group _ no ▁] ▁= ▁1 ▁; ▁while ▁( ▁aux _ num ▁> ▁0 ▁) ▁{ ▁a ▁[ ▁group _ no ▁+ ▁1 ▁+ ▁i ▁] ▁= ▁a ▁[ ▁group _ no ▁- ▁1 ▁- ▁i ▁] ▁= ▁aux _ num ▁& ▁1 ▁; ▁aux _ num ▁= ▁aux _ num ▁>> ▁1 ▁; ▁i ▁++ ▁; ▁} ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁len _ f ▁; ▁i ▁++ ▁) ▁num ▁+= ▁( ▁1 ▁<< ▁i ▁) ▁* ▁a ▁[ ▁i ▁] ▁; ▁return ▁num ▁; ▁} ▁static ▁int ▁getN th Number ▁( ▁int ▁n ▁) ▁{ ▁int ▁group _ no ▁= ▁0 ▁, ▁group _ offset ▁; ▁int ▁count _ upt o _ group ▁= ▁0 ▁, ▁count _ temp ▁= ▁1 ▁;
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁public ▁class ▁G f G ▁{ ▁public ▁static ▁int ▁toggle Last MB its ▁( ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁int ▁num ▁= ▁( ▁1 ▁<< ▁m ▁) ▁- ▁1 ▁; ▁return ▁( ▁n ▁^ ▁num ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁arg c ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁107 ▁; ▁int ▁m ▁= ▁4 ▁; ▁n ▁= ▁toggle Last MB its ▁( ▁n ▁, ▁m ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁n ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁xor Pair Count ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁x ▁) ▁{ ▁Map ▁< ▁Integer ▁, ▁Integer ▁> ▁m ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁curr _ xor ▁= ▁x ▁^ ▁arr ▁[ ▁i ▁] ▁; ▁if ▁( ▁m ▁. ▁containsKey ▁( ▁curr _ xor ▁) ▁) ▁result ▁+= ▁m ▁. ▁get ▁( ▁curr _ xor ▁) ▁; ▁if ▁( ▁m ▁. ▁containsKey ▁( ▁arr ▁[ ▁i ▁] ▁) ▁) ▁{ ▁m ▁. ▁put ▁( ▁arr ▁[ ▁i ▁] ▁, ▁m ▁. ▁get ▁( ▁arr ▁[ ▁i ▁] ▁) ▁+ ▁1 ▁) ▁; ▁} ▁else ▁{ ▁m ▁. ▁put ▁( ▁arr ▁[ ▁i ▁] ▁, ▁1 ▁) ▁; ▁} ▁} ▁return ▁result ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁5 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁int ▁x ▁= ▁0 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Count ▁of ▁pairs ▁with ▁given ▁XOR ▁= ▁" ▁+ ▁xor Pair Count ▁( ▁arr ▁, ▁n ▁, ▁x ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁maxLength ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁max Len ▁= ▁0 ▁; ▁int ▁i ▁= ▁0 ▁; ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁while ▁( ▁j ▁< ▁n ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁!= ▁arr ▁[ ▁j ▁] ▁) ▁{ ▁max Len ▁= ▁Math ▁. ▁max ▁( ▁max Len ▁, ▁2 ▁) ▁; ▁int ▁l ▁= ▁i ▁- ▁1 ▁; ▁int ▁r ▁= ▁j ▁+ ▁1 ▁; ▁while ▁( ▁l ▁>= ▁0 ▁&& ▁r ▁< ▁n ▁&& ▁arr ▁[ ▁l ▁] ▁== ▁arr ▁[ ▁i ▁] ▁&& ▁arr ▁[ ▁r ▁] ▁== ▁arr ▁[ ▁j ▁] ▁) ▁{ ▁l ▁-- ▁; ▁r ▁++ ▁; ▁} ▁max Len ▁= ▁Math ▁. ▁max ▁( ▁max Len ▁, ▁2 ▁* ▁( ▁r ▁- ▁j ▁) ▁) ▁; ▁} ▁i ▁++ ▁; ▁j ▁= ▁i ▁+ ▁1 ▁; ▁} ▁return ▁max Len ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁maxLength ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁min Digits ▁( ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁int ▁digits _ num ▁= ▁( ▁int ▁) ▁Math ▁. ▁floor ▁( ▁Math ▁. ▁log ▁( ▁N ▁) ▁+ ▁1 ▁) ▁; ▁int ▁temp _ sum ▁= ▁0 ▁; ▁int ▁temp ▁= ▁digits _ num ▁; ▁int ▁result ▁= ▁0 ▁; ▁int ▁X ▁, ▁var ▁; ▁int ▁sum ▁= ▁0 ▁; ▁int ▁num 2 ▁= ▁N ▁; ▁while ▁( ▁num 2 ▁!= ▁0 ▁) ▁{ ▁sum ▁+= ▁num 2 ▁% ▁10 ▁; ▁num 2 ▁/= ▁10 ▁; ▁} ▁if ▁( ▁sum ▁<= ▁K ▁) ▁{ ▁X ▁= ▁0 ▁; ▁} ▁else ▁{ ▁while ▁( ▁temp ▁> ▁0 ▁) ▁{ ▁var ▁= ▁( ▁N ▁/ ▁( ▁( ▁int ▁) ▁Math ▁. ▁pow ▁( ▁10 ▁, ▁temp ▁- ▁1 ▁) ▁) ▁) ▁; ▁temp _ sum ▁+= ▁var ▁% ▁10 ▁; ▁if ▁( ▁temp _ sum ▁>= ▁K ▁) ▁{ ▁var ▁/= ▁10 ▁; ▁var ▁++ ▁; ▁result ▁= ▁var ▁* ▁( ▁int ▁) ▁Math ▁. ▁pow ▁( ▁10 ▁, ▁temp ▁) ▁; ▁break ▁; ▁} ▁temp ▁-- ▁; ▁} ▁X ▁= ▁result ▁- ▁N ▁; ▁return ▁X ▁; ▁} ▁return ▁- ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁N ▁= ▁11 ▁; ▁int ▁K ▁= ▁1 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁min Digits ▁( ▁N ▁, ▁K ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁upperBound ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁int ▁l ▁= ▁0 ▁; ▁int ▁r ▁= ▁N ▁; ▁while ▁( ▁l ▁< ▁r ▁) ▁{ ▁int ▁mid ▁= ▁( ▁l ▁+ ▁r ▁) ▁/ ▁2 ▁; ▁if ▁( ▁arr ▁[ ▁mid ▁] ▁<= ▁K ▁) ▁{ ▁l ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁else ▁{ ▁r ▁= ▁mid ▁; ▁} ▁} ▁return ▁l ▁; ▁} ▁static ▁void ▁N Div K With Freq ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁arr ▁) ▁; ▁int ▁i ▁= ▁0 ▁; ▁while ▁( ▁i ▁< ▁N ▁) ▁{ ▁int ▁X ▁= ▁upperBound ▁( ▁arr ▁, ▁N ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁if ▁( ▁( ▁X ▁- ▁i ▁) ▁> ▁N ▁/ ▁4 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁i ▁= ▁X ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁2 ▁, ▁6 ▁, ▁6 ▁, ▁6 ▁, ▁6 ▁, ▁7 ▁, ▁10 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁int ▁K ▁= ▁4 ▁; ▁N Div K With Freq ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁double ▁getMax Medi an ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁size ▁= ▁n ▁+ ▁k ▁; ▁Arrays ▁. ▁sort ▁( ▁arr ▁) ▁; ▁if ▁( ▁size ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁double ▁median ▁= ▁( ▁double ▁) ▁( ▁arr ▁[ ▁( ▁size ▁/ ▁2 ▁) ▁- ▁1 ▁] ▁+ ▁arr ▁[ ▁size ▁/ ▁2 ▁] ▁) ▁/ ▁2 ▁; ▁return ▁median ▁; ▁} ▁double ▁median 1 ▁= ▁arr ▁[ ▁size ▁/ ▁2 ▁] ▁; ▁return ▁median 1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁3 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁int ▁k ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁( ▁int ▁) ▁getMax Medi an ▁( ▁arr ▁, ▁n ▁, ▁k ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁class ▁G eek s for G eek s ▁{ ▁final ▁static ▁int ▁MAX ▁= ▁26 ▁; ▁static ▁boolean ▁function ▁( ▁String ▁str ▁) ▁{ ▁int ▁l ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁int ▁counter ▁[ ▁] ▁= ▁new ▁int ▁[ ▁MAX ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁MAX ▁; ▁i ▁++ ▁) ▁counter ▁[ ▁i ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁l ▁/ ▁2 ▁; ▁i ▁++ ▁) ▁counter ▁[ ▁str ▁. ▁charAt ▁( ▁i ▁) ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁for ▁( ▁int ▁i ▁= ▁l ▁/ ▁2 ▁; ▁i ▁< ▁l ▁; ▁i ▁++ ▁) ▁counter ▁[ ▁str ▁. ▁charAt ▁( ▁i ▁) ▁- ▁' ▁a ▁' ▁] ▁-- ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁MAX ▁; ▁i ▁++ ▁) ▁if ▁( ▁counter ▁[ ▁i ▁] ▁!= ▁0 ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁String ▁str ▁= ▁" ▁abc as ds ab ca e ▁" ▁; ▁if ▁( ▁function ▁( ▁str ▁) ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Yes ▁, ▁both ▁hal ves ▁" ▁+ ▁" ▁differ ▁by ▁at ▁least ▁one ▁character ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁No ▁, ▁both ▁hal ves ▁" ▁+ ▁" ▁do ▁not ▁differ ▁at ▁all ▁" ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁print Sorted ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁int ▁c ▁) ▁{ ▁int ▁get _ max ▁= ▁Math ▁. ▁max ▁( ▁a ▁, ▁Math ▁. ▁max ▁( ▁b ▁, ▁c ▁) ▁) ▁; ▁int ▁get _ min ▁= ▁- ▁Math ▁. ▁max ▁( ▁- ▁a ▁, ▁Math ▁. ▁max ▁( ▁- ▁b ▁, ▁- ▁c ▁) ▁) ▁; ▁int ▁get _ mid ▁= ▁( ▁a ▁+ ▁b ▁+ ▁c ▁) ▁- ▁( ▁get _ max ▁+ ▁get _ min ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁get _ min ▁+ ▁" ▁" ▁+ ▁get _ mid ▁+ ▁" ▁" ▁+ ▁get _ max ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁= ▁4 ▁, ▁b ▁= ▁1 ▁, ▁c ▁= ▁9 ▁; ▁print Sorted ▁( ▁a ▁, ▁b ▁, ▁c ▁) ▁; ▁} ▁}
▁class ▁Insert ion Sort ▁{ ▁void ▁sort ▁( ▁int ▁arr ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁{ ▁int ▁key ▁= ▁arr ▁[ ▁i ▁] ▁; ▁int ▁j ▁= ▁i ▁- ▁1 ▁; ▁while ▁( ▁j ▁>= ▁0 ▁&& ▁arr ▁[ ▁j ▁] ▁> ▁key ▁) ▁{ ▁arr ▁[ ▁j ▁+ ▁1 ▁] ▁= ▁arr ▁[ ▁j ▁] ▁; ▁j ▁= ▁j ▁- ▁1 ▁; ▁} ▁arr ▁[ ▁j ▁+ ▁1 ▁] ▁= ▁key ▁; ▁} ▁} ▁static ▁void ▁print Array ▁( ▁int ▁arr ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁12 ▁, ▁11 ▁, ▁13 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁Insert ion Sort ▁ob ▁= ▁new ▁Insert ion Sort ▁( ▁) ▁; ▁ob ▁. ▁sort ▁( ▁arr ▁) ▁; ▁print Array ▁( ▁arr ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁S ▁= ▁" ▁g eek s for g ▁" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁max Num Pal indrome ▁( ▁S ▁) ▁) ▁; ▁} ▁static ▁int ▁max Num Pal indrome ▁( ▁String ▁S ▁) ▁{ ▁int ▁i ▁= ▁0 ▁; ▁int ▁[ ▁] ▁freq ▁= ▁new ▁int ▁[ ▁26 ▁] ▁; ▁int ▁freq Pair ▁= ▁0 ▁; ▁int ▁len ▁= ▁S ▁. ▁length ▁( ▁) ▁/ ▁3 ▁; ▁while ▁( ▁i ▁< ▁S ▁. ▁length ▁( ▁) ▁) ▁{ ▁freq ▁[ ▁S ▁. ▁charAt ▁( ▁i ▁) ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁i ▁++ ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁26 ▁; ▁i ▁++ ▁) ▁{ ▁freq Pair ▁+= ▁( ▁freq ▁[ ▁i ▁] ▁/ ▁2 ▁) ▁; ▁} ▁return ▁Math ▁. ▁min ▁( ▁freq Pair ▁, ▁len ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁height ▁( ▁int ▁s ▁, ▁Vector ▁< ▁Integer ▁> ▁adj ▁[ ▁] ▁, ▁int ▁[ ▁] ▁visited ▁) ▁{ ▁visited ▁[ ▁s ▁] ▁= ▁1 ▁; ▁int ▁h ▁= ▁0 ▁; ▁for ▁( ▁int ▁child ▁: ▁adj ▁[ ▁s ▁] ▁) ▁{ ▁if ▁( ▁visited ▁[ ▁child ▁] ▁== ▁0 ▁) ▁{ ▁h ▁= ▁Math ▁. ▁max ▁( ▁h ▁, ▁1 ▁+ ▁height ▁( ▁child ▁, ▁adj ▁, ▁visited ▁) ▁) ▁; ▁} ▁} ▁return ▁h ▁; ▁} ▁static ▁int ▁minimum Groups ▁( ▁Vector ▁< ▁Integer ▁> ▁adj ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁[ ▁] ▁visited ▁= ▁new ▁int ▁[ ▁N ▁+ ▁1 ▁] ▁; ▁int ▁groups ▁= ▁Integer ▁. ▁MIN _ VALUE ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁visited ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁int ▁com Height ▁; ▁com Height ▁= ▁height ▁( ▁i ▁, ▁adj ▁, ▁visited ▁) ▁; ▁groups ▁= ▁Math ▁. ▁max ▁( ▁groups ▁, ▁com Height ▁) ▁; ▁} ▁} ▁return ▁groups ▁; ▁} ▁static ▁void ▁addEdge ▁( ▁Vector ▁< ▁Integer ▁> ▁adj ▁[ ▁] ▁, ▁int ▁u ▁, ▁int ▁v ▁) ▁{ ▁adj ▁[ ▁u ▁] ▁. ▁add ▁( ▁v ▁) ▁; ▁adj ▁[ ▁v ▁] ▁. ▁add ▁( ▁u ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁5 ▁; ▁Vector ▁< ▁Integer ▁> ▁[ ▁] ▁adj ▁= ▁new ▁Vector ▁[ ▁N ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁adj ▁[ ▁i ▁] ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁addEdge ▁( ▁adj ▁, ▁1 ▁, ▁2 ▁) ▁; ▁addEdge ▁( ▁adj ▁, ▁3 ▁, ▁2 ▁) ▁; ▁addEdge ▁( ▁adj ▁, ▁4 ▁, ▁3 ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁minimum Groups ▁( ▁adj ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁find _ sum ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁total _ sum ▁= ▁( ▁n ▁* ▁( ▁n ▁+ ▁1 ▁) ▁) ▁/ ▁2 ▁; ▁int ▁power ▁= ▁k ▁; ▁while ▁( ▁power ▁<= ▁n ▁) ▁{ ▁total _ sum ▁-= ▁power ▁; ▁power ▁*= ▁k ▁; ▁} ▁return ▁total _ sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁11 ▁, ▁k ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find _ sum ▁( ▁n ▁, ▁k ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁G F G ▁{ ▁static ▁int ▁min ▁( ▁int ▁x ▁, ▁int ▁y ▁, ▁int ▁z ▁) ▁{ ▁if ▁( ▁x ▁< ▁y ▁) ▁return ▁( ▁x ▁< ▁z ▁) ▁? ▁x ▁: ▁z ▁; ▁else ▁return ▁( ▁y ▁< ▁z ▁) ▁? ▁y ▁: ▁z ▁; ▁} ▁static ▁int ▁min Cost ▁( ▁int ▁cost ▁[ ▁] ▁[ ▁] ▁, ▁int ▁m ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁< ▁0 ▁m ▁< ▁0 ▁) ▁return ▁Integer ▁. ▁MAX _ VALUE ▁; ▁else ▁if ▁( ▁m ▁== ▁0 ▁&& ▁n ▁== ▁0 ▁) ▁return ▁cost ▁[ ▁m ▁] ▁[ ▁n ▁] ▁; ▁else ▁return ▁cost ▁[ ▁m ▁] ▁[ ▁n ▁] ▁+ ▁min ▁( ▁min Cost ▁( ▁cost ▁, ▁m ▁- ▁1 ▁, ▁n ▁- ▁1 ▁) ▁, ▁min Cost ▁( ▁cost ▁, ▁m ▁- ▁1 ▁, ▁n ▁) ▁, ▁min Cost ▁( ▁cost ▁, ▁m ▁, ▁n ▁- ▁1 ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁cost ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁, ▁{ ▁4 ▁, ▁8 ▁, ▁2 ▁} ▁, ▁{ ▁1 ▁, ▁5 ▁, ▁3 ▁} ▁} ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁min Cost ▁( ▁cost ▁, ▁2 ▁, ▁2 ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁count Small er ▁( ▁String ▁str ▁) ▁{ ▁int ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁int ▁arr ▁[ ▁] ▁= ▁new ▁int ▁[ ▁26 ▁] ▁; ▁int ▁ans ▁[ ▁] ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁arr ▁[ ▁str ▁. ▁charAt ▁( ▁i ▁) ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁int ▁ct ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁str ▁. ▁charAt ▁( ▁i ▁) ▁- ▁' ▁a ▁' ▁; ▁j ▁++ ▁) ▁{ ▁ct ▁+= ▁arr ▁[ ▁j ▁] ▁; ▁} ▁ans ▁[ ▁i ▁] ▁= ▁ct ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁ans ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁" ▁ed cb aa ▁" ▁; ▁count Small er ▁( ▁str ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁private ▁static ▁StringBuilder ▁char Buffer ▁= ▁new ▁StringBuilder ▁( ▁) ▁; ▁public ▁static ▁String ▁process Words ▁( ▁String ▁input ▁) ▁{ ▁String ▁s ▁[ ▁] ▁= ▁input ▁. ▁split ▁( ▁" ▁( ▁\\ ▁s ▁) ▁+ ▁" ▁) ▁; ▁for ▁( ▁String ▁values ▁: ▁s ▁) ▁{ ▁char Buffer ▁. ▁append ▁( ▁values ▁. ▁charAt ▁( ▁0 ▁) ▁) ▁; ▁} ▁return ▁char Buffer ▁. ▁toString ▁( ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁input ▁= ▁" ▁g eek s ▁for ▁TABSYMBOL ▁g eek s ▁g eek s ▁TABSYMBOL ▁for ▁g eek s ▁" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁process Words ▁( ▁input ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G f G ▁{ ▁static ▁void ▁generate Gray arr ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁<= ▁0 ▁) ▁return ▁; ▁ArrayList ▁< ▁String ▁> ▁arr ▁= ▁new ▁ArrayList ▁< ▁String ▁> ▁( ▁) ▁; ▁arr ▁. ▁add ▁( ▁"0" ▁) ▁; ▁arr ▁. ▁add ▁( ▁"1" ▁) ▁; ▁int ▁i ▁, ▁j ▁; ▁for ▁( ▁i ▁= ▁2 ▁; ▁i ▁< ▁( ▁1 ▁<< ▁n ▁) ▁; ▁i ▁= ▁i ▁<< ▁1 ▁) ▁{ ▁for ▁( ▁j ▁= ▁i ▁- ▁1 ▁; ▁j ▁>= ▁0 ▁; ▁j ▁-- ▁) ▁arr ▁. ▁add ▁( ▁arr ▁. ▁get ▁( ▁j ▁) ▁) ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁i ▁; ▁j ▁++ ▁) ▁arr ▁. ▁set ▁( ▁j ▁, ▁"0" ▁+ ▁arr ▁. ▁get ▁( ▁j ▁) ▁) ▁; ▁for ▁( ▁j ▁= ▁i ▁; ▁j ▁< ▁2 ▁* ▁i ▁; ▁j ▁++ ▁) ▁arr ▁. ▁set ▁( ▁j ▁, ▁"1" ▁+ ▁arr ▁. ▁get ▁( ▁j ▁) ▁) ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁arr ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁arr ▁. ▁get ▁( ▁i ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁generate Gray arr ▁( ▁3 ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁Vector ▁< ▁String ▁> ▁possible Paths ▁= ▁new ▁Vector ▁< ▁> ▁( ▁) ▁; ▁static ▁String ▁path ▁= ▁" ▁" ▁; ▁static ▁final ▁int ▁MAX ▁= ▁5 ▁; ▁static ▁boolean ▁is Safe ▁( ▁int ▁row ▁, ▁int ▁col ▁, ▁int ▁m ▁[ ▁] ▁[ ▁] ▁, ▁int ▁n ▁, ▁boolean ▁visited ▁[ ▁] ▁[ ▁] ▁) ▁{ ▁if ▁( ▁row ▁== ▁- ▁1 ▁row ▁== ▁n ▁col ▁== ▁- ▁1 ▁col ▁== ▁n ▁visited ▁[ ▁row ▁] ▁[ ▁col ▁] ▁m ▁[ ▁row ▁] ▁[ ▁col ▁] ▁== ▁0 ▁) ▁return ▁false ▁; ▁return ▁true ▁; ▁} ▁static ▁void ▁print Path Util ▁( ▁int ▁row ▁, ▁int ▁col ▁, ▁int ▁m ▁[ ▁] ▁[ ▁] ▁, ▁int ▁n ▁, ▁boolean ▁visited ▁[ ▁] ▁[ ▁] ▁) ▁{ ▁if ▁( ▁row ▁== ▁- ▁1 ▁row ▁== ▁n ▁col ▁== ▁- ▁1 ▁col ▁== ▁n ▁visited ▁[ ▁row ▁] ▁[ ▁col ▁] ▁m ▁[ ▁row ▁] ▁[ ▁col ▁] ▁== ▁0 ▁) ▁return ▁; ▁if ▁( ▁row ▁== ▁n ▁- ▁1 ▁&& ▁col ▁== ▁n ▁- ▁1 ▁) ▁{ ▁possible Paths ▁. ▁add ▁( ▁path ▁) ▁; ▁return ▁; ▁} ▁visited ▁[ ▁row ▁] ▁[ ▁col ▁] ▁= ▁true ▁; ▁if ▁( ▁is Safe ▁( ▁row ▁+ ▁1 ▁, ▁col ▁, ▁m ▁, ▁n ▁, ▁visited ▁) ▁) ▁{ ▁path ▁+= ▁' ▁D ▁' ▁; ▁print Path Util ▁( ▁row ▁+ ▁1 ▁, ▁col ▁, ▁m ▁, ▁n ▁, ▁visited ▁) ▁; ▁path ▁= ▁path ▁. ▁substring ▁( ▁0 ▁, ▁path ▁. ▁length ▁( ▁) ▁- ▁1 ▁) ▁; ▁} ▁if ▁( ▁is Safe ▁( ▁row ▁, ▁col ▁- ▁1 ▁, ▁m ▁, ▁n ▁, ▁visited ▁) ▁) ▁{ ▁path ▁+= ▁' ▁L ▁' ▁; ▁print Path Util ▁( ▁row ▁, ▁col ▁- ▁1 ▁, ▁m ▁, ▁n ▁, ▁visited ▁) ▁; ▁path ▁= ▁path ▁. ▁substring ▁( ▁0 ▁, ▁path ▁. ▁length ▁( ▁) ▁- ▁1 ▁) ▁; ▁} ▁if ▁( ▁is Safe ▁( ▁row ▁, ▁col ▁+ ▁1 ▁, ▁m ▁, ▁n ▁, ▁visited ▁) ▁) ▁{ ▁path ▁+= ▁' ▁R ▁' ▁; ▁print Path Util ▁( ▁row ▁, ▁col ▁+ ▁1 ▁, ▁m ▁, ▁n ▁, ▁visited ▁) ▁; ▁path ▁= ▁path ▁. ▁substring ▁( ▁0 ▁, ▁path ▁. ▁length ▁( ▁) ▁- ▁1 ▁) ▁; ▁} ▁if ▁( ▁is Safe ▁( ▁row ▁- ▁1 ▁,
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁count Direct Path ▁( ▁int ▁N ▁) ▁{ ▁return ▁N ▁+ ▁( ▁N ▁* ▁( ▁N ▁- ▁3 ▁) ▁) ▁/ ▁2 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁count Direct Path ▁( ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁solution ▁{ ▁static ▁int ▁checkpoint ▁( ▁int ▁h ▁, ▁int ▁k ▁, ▁int ▁x ▁, ▁int ▁y ▁, ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁int ▁p ▁= ▁( ▁( ▁int ▁) ▁Math ▁. ▁pow ▁( ▁( ▁x ▁- ▁h ▁) ▁, ▁2 ▁) ▁/ ▁( ▁int ▁) ▁Math ▁. ▁pow ▁( ▁a ▁, ▁2 ▁) ▁) ▁+ ▁( ▁( ▁int ▁) ▁Math ▁. ▁pow ▁( ▁( ▁y ▁- ▁k ▁) ▁, ▁2 ▁) ▁/ ▁( ▁int ▁) ▁Math ▁. ▁pow ▁( ▁b ▁, ▁2 ▁) ▁) ▁; ▁return ▁p ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁arr ▁[ ▁] ▁) ▁{ ▁int ▁h ▁= ▁0 ▁, ▁k ▁= ▁0 ▁, ▁x ▁= ▁2 ▁, ▁y ▁= ▁1 ▁, ▁a ▁= ▁4 ▁, ▁b ▁= ▁5 ▁; ▁if ▁( ▁checkpoint ▁( ▁h ▁, ▁k ▁, ▁x ▁, ▁y ▁, ▁a ▁, ▁b ▁) ▁> ▁1 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Out side ▁" ▁) ▁; ▁else ▁if ▁( ▁checkpoint ▁( ▁h ▁, ▁k ▁, ▁x ▁, ▁y ▁, ▁a ▁, ▁b ▁) ▁== ▁1 ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁On ▁the ▁ellipse ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Inside ▁" ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁center ▁( ▁int ▁x 1 ▁, ▁int ▁x 2 ▁, ▁int ▁y 1 ▁, ▁int ▁y 2 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁( ▁float ▁) ▁( ▁x 1 ▁+ ▁x 2 ▁) ▁/ ▁2 ▁+ ▁" ▁, ▁" ▁+ ▁( ▁float ▁) ▁( ▁y 1 ▁+ ▁y 2 ▁) ▁/ ▁2 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁arg ▁[ ▁] ▁) ▁{ ▁int ▁x 1 ▁= ▁- ▁9 ▁, ▁y 1 ▁= ▁3 ▁, ▁x 2 ▁= ▁5 ▁, ▁y 2 ▁= ▁- ▁7 ▁; ▁center ▁( ▁x 1 ▁, ▁x 2 ▁, ▁y 1 ▁, ▁y 2 ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁double ▁Area ▁( ▁int ▁b 1 ▁, ▁int ▁b 2 ▁, ▁int ▁h ▁) ▁{ ▁return ▁( ▁( ▁b 1 ▁+ ▁b 2 ▁) ▁/ ▁2 ▁) ▁* ▁h ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁base 1 ▁= ▁8 ▁, ▁base 2 ▁= ▁10 ▁, ▁height ▁= ▁6 ▁; ▁double ▁area ▁= ▁Area ▁( ▁base 1 ▁, ▁base 2 ▁, ▁height ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Area ▁is ▁: ▁" ▁+ ▁area ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁double ▁area Cube ▁( ▁double ▁a ▁) ▁{ ▁return ▁( ▁a ▁* ▁a ▁* ▁a ▁) ▁; ▁} ▁static ▁double ▁surface Cube ▁( ▁double ▁a ▁) ▁{ ▁return ▁( ▁6 ▁* ▁a ▁* ▁a ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁double ▁a ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Area ▁= ▁" ▁+ ▁area Cube ▁( ▁a ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Total ▁surface ▁area ▁= ▁" ▁+ ▁surface Cube ▁( ▁a ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁class ▁pair ▁{ ▁double ▁first ▁, ▁second ▁; ▁public ▁pair ▁( ▁double ▁first ▁, ▁double ▁second ▁) ▁{ ▁this ▁. ▁first ▁= ▁first ▁; ▁this ▁. ▁second ▁= ▁second ▁; ▁} ▁} ▁static ▁pair ▁mirror Image ▁( ▁double ▁a ▁, ▁double ▁b ▁, ▁double ▁c ▁, ▁double ▁x 1 ▁, ▁double ▁y 1 ▁) ▁{ ▁double ▁temp ▁= ▁- ▁2 ▁* ▁( ▁a ▁* ▁x 1 ▁+ ▁b ▁* ▁y 1 ▁+ ▁c ▁) ▁/ ▁( ▁a ▁* ▁a ▁+ ▁b ▁* ▁b ▁) ▁; ▁double ▁x ▁= ▁temp ▁* ▁a ▁+ ▁x 1 ▁; ▁double ▁y ▁= ▁temp ▁* ▁b ▁+ ▁y 1 ▁; ▁return ▁new ▁pair ▁( ▁x ▁, ▁y ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁double ▁a ▁= ▁- ▁1.0 ▁; ▁double ▁b ▁= ▁1.0 ▁; ▁double ▁c ▁= ▁0.0 ▁; ▁double ▁x 1 ▁= ▁1.0 ▁; ▁double ▁y 1 ▁= ▁0.0 ▁; ▁pair ▁image ▁= ▁mirror Image ▁( ▁a ▁, ▁b ▁, ▁c ▁, ▁x 1 ▁, ▁y 1 ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Image ▁of ▁point ▁( ▁" ▁+ ▁x 1 ▁+ ▁" ▁, ▁" ▁+ ▁y 1 ▁+ ▁" ▁) ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁by ▁mirror ▁( ▁" ▁+ ▁a ▁+ ▁" ▁) ▁x ▁+ ▁( ▁" ▁+ ▁b ▁+ ▁" ▁) ▁y ▁+ ▁( ▁" ▁+ ▁c ▁+ ▁" ▁) ▁= ▁0 ▁, ▁is ▁: ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁( ▁" ▁+ ▁image ▁. ▁first ▁+ ▁" ▁, ▁" ▁+ ▁image ▁. ▁second ▁+ ▁" ▁) ▁" ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁fact ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁1 ▁n ▁== ▁0 ▁) ▁return ▁1 ▁; ▁else ▁return ▁n ▁* ▁fact ▁( ▁n ▁- ▁1 ▁) ▁; ▁} ▁static ▁int ▁find Value ▁( ▁int ▁n ▁, ▁int ▁r ▁, ▁int ▁a ▁) ▁{ ▁int ▁k ▁= ▁( ▁a ▁- ▁1 ▁) ▁/ ▁fact ▁( ▁n ▁) ▁; ▁int ▁answer ▁= ▁k ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁answer ▁= ▁answer ▁* ▁( ▁n ▁+ ▁r ▁- ▁i ▁) ▁; ▁answer ▁= ▁answer ▁+ ▁1 ▁; ▁return ▁answer ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁N ▁= ▁1 ▁; ▁int ▁A ▁= ▁2 ▁; ▁int ▁R ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁find Value ▁( ▁N ▁, ▁R ▁, ▁A ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁count No ▁( ▁int ▁A ▁, ▁int ▁N ▁, ▁int ▁L ▁, ▁int ▁R ▁) ▁{ ▁int ▁ans ▁= ▁L ▁- ▁1 ▁+ ▁N ▁+ ▁( ▁int ▁) ▁Math ▁. ▁floor ▁( ▁( ▁N ▁- ▁1 ▁) ▁/ ▁( ▁A ▁- ▁1 ▁) ▁) ▁; ▁if ▁( ▁ans ▁% ▁A ▁== ▁0 ▁) ▁{ ▁ans ▁= ▁ans ▁+ ▁1 ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁ans ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁A ▁= ▁5 ▁, ▁N ▁= ▁10 ▁, ▁L ▁= ▁4 ▁, ▁R ▁= ▁20 ▁; ▁count No ▁( ▁A ▁, ▁N ▁, ▁L ▁, ▁R ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁MAX ▁= ▁1000000 ▁; ▁static ▁boolean ▁[ ▁] ▁prime ▁= ▁new ▁boolean ▁[ ▁MAX ▁] ▁; ▁static ▁void ▁S ieve Of E rat ost hen es ▁( ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁MAX ▁; ▁i ▁++ ▁) ▁prime ▁[ ▁i ▁] ▁= ▁true ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁* ▁p ▁< ▁MAX ▁; ▁p ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁p ▁] ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁p ▁* ▁p ▁; ▁i ▁< ▁MAX ▁; ▁i ▁+= ▁p ▁) ▁prime ▁[ ▁i ▁] ▁= ▁false ▁; ▁} ▁} ▁} ▁static ▁int ▁sum Prime ▁( ▁int ▁k ▁) ▁{ ▁S ieve Of E rat ost hen es ▁( ▁) ▁; ▁Vector ▁< ▁Integer ▁> ▁v ▁= ▁new ▁Vector ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁< ▁MAX ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁i ▁] ▁) ▁v ▁. ▁add ▁( ▁i ▁) ▁; ▁} ▁int ▁sum ▁= ▁0 ▁; ▁int ▁skip ▁= ▁( ▁k ▁* ▁( ▁k ▁- ▁1 ▁) ▁) ▁/ ▁2 ▁; ▁while ▁( ▁k ▁> ▁0 ▁) ▁{ ▁sum ▁+= ▁v ▁. ▁get ▁( ▁skip ▁) ▁; ▁skip ▁++ ▁; ▁k ▁-- ▁; ▁} ▁return ▁sum ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁k ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁sum Prime ▁( ▁k ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁next Occurrence ▁( ▁String ▁str ▁, ▁int ▁n ▁, ▁int ▁start ▁, ▁char ▁ch ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁start ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁== ▁ch ▁) ▁return ▁i ▁; ▁} ▁return ▁- ▁1 ▁; ▁} ▁static ▁int ▁count Sub Str ▁( ▁String ▁str ▁, ▁int ▁n ▁, ▁char ▁ch ▁) ▁{ ▁int ▁cnt ▁= ▁0 ▁; ▁int ▁j ▁= ▁next Occurrence ▁( ▁str ▁, ▁n ▁, ▁0 ▁, ▁ch ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁while ▁( ▁j ▁!= ▁- ▁1 ▁&& ▁j ▁< ▁i ▁) ▁{ ▁j ▁= ▁next Occurrence ▁( ▁str ▁, ▁n ▁, ▁j ▁+ ▁1 ▁, ▁ch ▁) ▁; ▁} ▁if ▁( ▁j ▁== ▁- ▁1 ▁) ▁break ▁; ▁cnt ▁+= ▁( ▁n ▁- ▁j ▁) ▁; ▁} ▁return ▁cnt ▁; ▁} ▁static ▁public ▁void ▁main ▁( ▁String ▁[ ▁] ▁arg ▁) ▁{ ▁String ▁str ▁= ▁" ▁g eek s forge ek s ▁" ▁; ▁int ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁char ▁ch ▁= ▁' ▁k ▁' ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Sub Str ▁( ▁str ▁, ▁n ▁, ▁ch ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁power ▁( ▁int ▁x ▁, ▁int ▁y ▁, ▁int ▁p ▁) ▁{ ▁int ▁res ▁= ▁1 ▁; ▁x ▁= ▁x ▁% ▁p ▁; ▁while ▁( ▁y ▁> ▁0 ▁) ▁{ ▁if ▁( ▁y ▁% ▁2 ▁== ▁1 ▁) ▁{ ▁res ▁= ▁( ▁res ▁* ▁x ▁) ▁% ▁p ▁; ▁} ▁x ▁= ▁( ▁x ▁* ▁x ▁) ▁% ▁p ▁; ▁} ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁L ▁= ▁2 ▁; ▁int ▁P ▁= ▁( ▁int ▁) ▁Math ▁. ▁pow ▁( ▁10 ▁, ▁9 ▁) ▁; ▁int ▁ans ▁= ▁power ▁( ▁3 25 ▁, ▁L ▁, ▁P ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁ans ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁void ▁re ver ese Array ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁n ▁) ▁{ ▁int ▁[ ▁] ▁rev ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁rev ▁[ ▁n ▁- ▁i ▁- ▁1 ▁] ▁= ▁arr ▁[ ▁i ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁arr ▁[ ▁i ▁] ▁= ▁rev ▁[ ▁i ▁] ▁; ▁} ▁public ▁static ▁void ▁print Array ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁size ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁print Array ▁( ▁arr ▁, ▁n ▁) ▁; ▁re ver ese Array ▁( ▁arr ▁, ▁n ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Rever sed ▁array ▁is ▁" ▁) ▁; ▁print Array ▁( ▁arr ▁, ▁n ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁static ▁java ▁. ▁lang ▁. ▁Math ▁. ▁min ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁void ▁find String ▁( ▁String ▁str ▁, ▁int ▁M ▁) ▁{ ▁int ▁N ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁M ▁= ▁Math ▁. ▁min ▁( ▁M ▁, ▁N ▁) ▁; ▁String ▁s 1 ▁= ▁" ▁" ▁; ▁while ▁( ▁M ▁!= ▁0 ▁) ▁{ ▁s 1 ▁= ▁" ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'0' ▁) ▁{ ▁if ▁( ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'1' ▁&& ▁str ▁. ▁charAt ▁( ▁i ▁) ▁!= ▁'1' ▁) ▁|| ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'1' ▁&& ▁str ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'1' ▁) ▁) ▁s 1 ▁+= ▁'1' ▁; ▁else ▁s 1 ▁+= ▁'0' ▁; ▁} ▁else ▁s 1 ▁+= ▁'1' ▁; ▁} ▁if ▁( ▁str ▁== ▁s 1 ▁) ▁break ▁; ▁str ▁= ▁s 1 ▁; ▁M ▁-- ▁; ▁} ▁System ▁. ▁out ▁. ▁print ▁( ▁s 1 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁"01 101 00" ▁; ▁int ▁M ▁= ▁3 ▁; ▁find String ▁( ▁str ▁, ▁M ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁ind iv isible Digits ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁N ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁" ▁: ▁" ▁) ▁; ▁for ▁( ▁int ▁j ▁= ▁2 ▁; ▁j ▁< ▁10 ▁; ▁j ▁++ ▁) ▁{ ▁int ▁temp ▁= ▁arr ▁[ ▁i ▁] ▁; ▁boolean ▁flag ▁= ▁true ▁; ▁while ▁( ▁temp ▁> ▁0 ▁) ▁{ ▁if ▁( ▁( ▁temp ▁% ▁10 ▁) ▁!= ▁0 ▁&& ▁( ▁temp ▁% ▁10 ▁) ▁% ▁j ▁== ▁0 ▁) ▁{ ▁flag ▁= ▁false ▁; ▁break ▁; ▁} ▁temp ▁/= ▁10 ▁; ▁} ▁if ▁( ▁flag ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁j ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁4 16 2 ▁, ▁115 2 ▁, ▁9 98 42 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁ind iv isible Digits ▁( ▁arr ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁check ▁( ▁String ▁s 1 ▁, ▁String ▁s 2 ▁) ▁{ ▁int ▁s 1 _0 ▁= ▁0 ▁, ▁s 2 _0 ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s 1 ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s 1 ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'0' ▁) ▁{ ▁s 1 _0 ▁++ ▁; ▁} ▁if ▁( ▁s 2 ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'0' ▁) ▁{ ▁s 2 _0 ▁++ ▁; ▁} ▁} ▁if ▁( ▁s 1 _0 ▁!= ▁s 2 _0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁NO ▁" ▁) ▁; ▁return ▁; ▁} ▁else ▁{ ▁int ▁Count 1 ▁= ▁0 ▁, ▁Count 2 ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s 1 ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s 1 ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'0' ▁) ▁{ ▁Count 1 ▁++ ▁; ▁} ▁if ▁( ▁s 2 ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'0' ▁) ▁{ ▁Count 2 ▁++ ▁; ▁} ▁if ▁( ▁Count 1 ▁< ▁Count 2 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁NO ▁" ▁) ▁; ▁return ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁YES ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁s 1 ▁= ▁"100 11 1" ▁; ▁String ▁s 2 ▁= ▁"11 101 0" ▁; ▁check ▁( ▁s 1 ▁, ▁s 2 ▁) ▁; ▁s 1 ▁= ▁"11 01 00" ▁; ▁s 2 ▁= ▁" 0101 01" ▁; ▁check ▁( ▁s 1 ▁, ▁s 2 ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁max Even Integ ers ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁M ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁N ▁- ▁M ▁; ▁i ▁++ ▁) ▁{ ▁int ▁cnt ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁M ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁+ ▁j ▁] ▁% ▁2 ▁== ▁0 ▁) ▁cnt ▁++ ▁; ▁} ▁ans ▁= ▁Math ▁. ▁max ▁( ▁ans ▁, ▁cnt ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁5 ▁, ▁4 ▁, ▁7 ▁, ▁6 ▁} ▁; ▁int ▁K ▁= ▁3 ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁max Even Integ ers ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁+ ▁" NEW _ LINE "); ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁String ▁check ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁Map ▁< ▁Integer ▁, ▁Integer ▁> ▁hm ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁hm ▁. ▁put ▁( ▁arr ▁[ ▁i ▁] ▁, ▁1 ▁) ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁hm ▁. ▁put ▁( ▁arr ▁[ ▁j ▁] ▁, ▁hm ▁. ▁getOr Default ▁( ▁arr ▁[ ▁j ▁] ▁, ▁0 ▁) ▁+ ▁1 ▁) ▁; ▁boolean ▁flag ▁= ▁false ▁; ▁for ▁( ▁Integer ▁k ▁: ▁hm ▁. ▁values ▁( ▁) ▁) ▁{ ▁if ▁( ▁k ▁== ▁1 ▁) ▁{ ▁flag ▁= ▁true ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁! ▁flag ▁) ▁return ▁" ▁No ▁" ▁; ▁} ▁hm ▁. ▁clear ▁( ▁) ▁; ▁} ▁return ▁" ▁Yes ▁" ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁check ▁( ▁arr ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁find _ index ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁n ▁, ▁int ▁K ▁) ▁{ ▁int ▁start ▁= ▁0 ▁; ▁int ▁end ▁= ▁n ▁- ▁1 ▁; ▁while ▁( ▁start ▁<= ▁end ▁) ▁{ ▁int ▁mid ▁= ▁( ▁start ▁+ ▁end ▁) ▁/ ▁2 ▁; ▁if ▁( ▁arr ▁[ ▁mid ▁] ▁== ▁K ▁) ▁return ▁mid ▁; ▁else ▁if ▁( ▁arr ▁[ ▁mid ▁] ▁< ▁K ▁) ▁start ▁= ▁mid ▁+ ▁1 ▁; ▁else ▁end ▁= ▁mid ▁- ▁1 ▁; ▁} ▁return ▁end ▁+ ▁1 ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁int ▁K ▁= ▁2 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find _ index ▁( ▁arr ▁, ▁n ▁, ▁K ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁isP al indrome ▁( ▁String ▁str ▁) ▁{ ▁int ▁i ▁= ▁0 ▁, ▁j ▁= ▁str ▁. ▁length ▁( ▁) ▁- ▁1 ▁; ▁while ▁( ▁i ▁< ▁j ▁) ▁{ ▁if ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁!= ▁str ▁. ▁charAt ▁( ▁j ▁) ▁) ▁return ▁false ▁; ▁i ▁++ ▁; ▁j ▁-- ▁; ▁} ▁return ▁true ▁; ▁} ▁static ▁void ▁form Pal indrome ▁( ▁String ▁a ▁, ▁String ▁b ▁, ▁int ▁n ▁) ▁{ ▁char ▁aa ▁[ ▁] ▁= ▁new ▁char ▁[ ▁n ▁+ ▁2 ▁] ▁; ▁char ▁bb ▁[ ▁] ▁= ▁new ▁char ▁[ ▁n ▁+ ▁2 ▁] ▁; ▁Arrays ▁. ▁fill ▁( ▁aa ▁, ▁' ▁' ▁) ▁; ▁Arrays ▁. ▁fill ▁( ▁bb ▁, ▁' ▁' ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁aa ▁[ ▁i ▁] ▁= ▁a ▁. ▁charAt ▁( ▁i ▁- ▁1 ▁) ▁; ▁bb ▁[ ▁i ▁] ▁= ▁b ▁. ▁charAt ▁( ▁i ▁- ▁1 ▁) ▁; ▁} ▁boolean ▁ok ▁= ▁false ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁n ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁StringBuilder ▁la ▁= ▁new ▁StringBuilder ▁( ▁) ▁; ▁StringBuilder ▁ra ▁= ▁new ▁StringBuilder ▁( ▁) ▁; ▁StringBuilder ▁lb ▁= ▁new ▁StringBuilder ▁( ▁) ▁; ▁StringBuilder ▁rb ▁= ▁new ▁StringBuilder ▁( ▁) ▁; ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁<= ▁i ▁- ▁1 ▁; ▁j ▁++ ▁) ▁{ ▁la ▁. ▁append ▁( ▁( ▁aa ▁[ ▁j ▁] ▁== ▁' ▁' ▁) ▁? ▁" ▁" ▁: ▁aa ▁[ ▁j ▁] ▁) ▁; ▁lb ▁. ▁append ▁( ▁( ▁bb ▁[ ▁j ▁] ▁== ▁' ▁' ▁) ▁? ▁" ▁" ▁: ▁bb ▁[ ▁j ▁] ▁) ▁; ▁} ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁<= ▁n ▁+ ▁1 ▁; ▁j ▁++ ▁) ▁{ ▁ra ▁. ▁append ▁( ▁( ▁aa ▁[ ▁j ▁] ▁== ▁' ▁' ▁) ▁? ▁" ▁" ▁: ▁aa ▁[ ▁j ▁] ▁) ▁; ▁rb ▁. ▁append ▁( ▁( ▁bb ▁[ ▁j ▁] ▁== ▁' ▁' ▁) ▁? ▁" ▁" ▁: ▁bb ▁[ ▁j ▁] ▁) ▁; ▁} ▁if ▁( ▁isP al indrome ▁( ▁la ▁. ▁toString ▁( ▁) ▁+ ▁rb ▁. ▁toString ▁( ▁) ▁) ▁|| ▁isP al indrome ▁( ▁lb ▁. ▁toString ▁( ▁) ▁+ ▁ra ▁.
▁import ▁java ▁. ▁awt ▁. ▁Point ▁; ▁import ▁java ▁. ▁util ▁. ▁HashSet ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁is Cross ed ▁( ▁String ▁path ▁) ▁{ ▁if ▁( ▁path ▁. ▁length ▁( ▁) ▁== ▁0 ▁) ▁return ▁; ▁boolean ▁ans ▁= ▁false ▁; ▁HashSet ▁< ▁Point ▁> ▁set ▁= ▁new ▁HashSet ▁< ▁Point ▁> ▁( ▁) ▁; ▁int ▁x ▁= ▁0 ▁, ▁y ▁= ▁0 ▁; ▁set ▁. ▁add ▁( ▁new ▁Point ▁( ▁x ▁, ▁y ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁path ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁path ▁. ▁charAt ▁( ▁i ▁) ▁== ▁' ▁N ▁' ▁) ▁set ▁. ▁add ▁( ▁new ▁Point ▁( ▁x ▁, ▁y ▁++ ▁) ▁) ▁; ▁if ▁( ▁path ▁. ▁charAt ▁( ▁i ▁) ▁== ▁' ▁S ▁' ▁) ▁set ▁. ▁add ▁( ▁new ▁Point ▁( ▁x ▁, ▁y ▁-- ▁) ▁) ▁; ▁if ▁( ▁path ▁. ▁charAt ▁( ▁i ▁) ▁== ▁' ▁E ▁' ▁) ▁set ▁. ▁add ▁( ▁new ▁Point ▁( ▁x ▁++ ▁, ▁y ▁) ▁) ▁; ▁if ▁( ▁path ▁. ▁charAt ▁( ▁i ▁) ▁== ▁' ▁W ▁' ▁) ▁set ▁. ▁add ▁( ▁new ▁Point ▁( ▁x ▁-- ▁, ▁y ▁) ▁) ▁; ▁if ▁( ▁set ▁. ▁contains ▁( ▁new ▁Point ▁( ▁x ▁, ▁y ▁) ▁) ▁) ▁{ ▁ans ▁= ▁true ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁ans ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Cross ed ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Not ▁Cross ed ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁path ▁= ▁" ▁NE SW ▁" ▁; ▁is Cross ed ▁( ▁path ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁len ght Of Long est AP ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁Map ▁< ▁Integer ▁, ▁Map ▁< ▁Integer ▁, ▁Integer ▁> ▁> ▁dp ▁= ▁new ▁HashMap ▁< ▁Integer ▁, ▁Map ▁< ▁Integer ▁, ▁Integer ▁> ▁> ▁( ▁) ▁; ▁int ▁res ▁= ▁2 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁++ ▁j ▁) ▁{ ▁int ▁d ▁= ▁A ▁[ ▁j ▁] ▁- ▁A ▁[ ▁i ▁] ▁; ▁Map ▁< ▁Integer ▁, ▁Integer ▁> ▁temp ▁; ▁if ▁( ▁dp ▁. ▁containsKey ▁( ▁d ▁) ▁) ▁{ ▁temp ▁= ▁dp ▁. ▁get ▁( ▁d ▁) ▁; ▁if ▁( ▁temp ▁. ▁containsKey ▁( ▁i ▁) ▁) ▁temp ▁. ▁put ▁( ▁j ▁, ▁temp ▁. ▁get ▁( ▁i ▁) ▁+ ▁1 ▁) ▁; ▁else ▁temp ▁. ▁put ▁( ▁j ▁, ▁2 ▁) ▁; ▁} ▁else ▁{ ▁temp ▁= ▁new ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁( ▁) ▁; ▁temp ▁. ▁put ▁( ▁j ▁, ▁2 ▁) ▁; ▁} ▁dp ▁. ▁put ▁( ▁d ▁, ▁temp ▁) ▁; ▁res ▁= ▁Math ▁. ▁max ▁( ▁res ▁, ▁temp ▁. ▁get ▁( ▁j ▁) ▁) ▁; ▁} ▁} ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁20 ▁, ▁1 ▁, ▁15 ▁, ▁3 ▁, ▁10 ▁, ▁5 ▁, ▁8 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁len ght Of Long est AP ▁( ▁arr ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁check Sum Of N atural ▁( ▁int ▁n ▁) ▁{ ▁int ▁i ▁= ▁1 ▁; ▁boolean ▁flag ▁= ▁false ▁; ▁while ▁( ▁i ▁* ▁( ▁i ▁+ ▁1 ▁) ▁< ▁n ▁* ▁2 ▁) ▁{ ▁int ▁X ▁= ▁i ▁* ▁( ▁i ▁+ ▁1 ▁) ▁; ▁int ▁t ▁= ▁n ▁* ▁2 ▁- ▁X ▁; ▁int ▁k ▁= ▁( ▁int ▁) ▁Math ▁. ▁sqrt ▁( ▁t ▁) ▁; ▁if ▁( ▁k ▁* ▁( ▁k ▁+ ▁1 ▁) ▁== ▁t ▁) ▁{ ▁flag ▁= ▁true ▁; ▁break ▁; ▁} ▁i ▁+= ▁1 ▁; ▁} ▁if ▁( ▁flag ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁YES ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁NO ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁25 ▁; ▁check Sum Of N atural ▁( ▁n ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁class ▁pair ▁{ ▁int ▁first ▁, ▁second ▁; ▁} ▁static ▁boolean ▁is Perf ect Square ▁( ▁int ▁n ▁) ▁{ ▁double ▁sr ▁= ▁Math ▁. ▁sqrt ▁( ▁n ▁) ▁; ▁return ▁( ▁( ▁sr ▁- ▁Math ▁. ▁floor ▁( ▁sr ▁) ▁) ▁== ▁0 ▁) ▁; ▁} ▁static ▁void ▁Sub array H aving Perf ect Square ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁k ▁) ▁{ ▁pair ▁ans ▁= ▁new ▁pair ▁( ▁) ▁; ▁int ▁sum ▁= ▁0 ▁, ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁k ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁boolean ▁found ▁= ▁false ▁; ▁if ▁( ▁is Perf ect Square ▁( ▁sum ▁) ▁) ▁{ ▁ans ▁. ▁first ▁= ▁0 ▁; ▁ans ▁. ▁second ▁= ▁i ▁- ▁1 ▁; ▁} ▁else ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁< ▁arr ▁. ▁length ▁; ▁j ▁++ ▁) ▁{ ▁sum ▁= ▁sum ▁+ ▁arr ▁[ ▁j ▁] ▁- ▁arr ▁[ ▁j ▁- ▁k ▁] ▁; ▁if ▁( ▁is Perf ect Square ▁( ▁sum ▁) ▁) ▁{ ▁found ▁= ▁true ▁; ▁ans ▁. ▁first ▁= ▁j ▁- ▁k ▁+ ▁1 ▁; ▁ans ▁. ▁second ▁= ▁j ▁; ▁} ▁} ▁for ▁( ▁int ▁k 1 ▁= ▁ans ▁. ▁first ▁; ▁k 1 ▁<= ▁ans ▁. ▁second ▁; ▁k 1 ▁++ ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁k 1 ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁} ▁if ▁( ▁found ▁== ▁false ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁- ▁1" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁20 ▁, ▁34 ▁, ▁51 ▁, ▁10 ▁, ▁99 ▁, ▁87 ▁, ▁23 ▁, ▁45 ▁} ▁; ▁int ▁K ▁= ▁3 ▁; ▁Sub array H aving Perf ect Square ▁( ▁arr ▁, ▁K ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁mirror Matrix ▁( ▁int ▁mat 1 ▁[ ▁] ▁[ ▁] ▁, ▁int ▁mat 2 ▁[ ▁] ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁row ▁= ▁0 ▁; ▁int ▁col ▁= ▁0 ▁; ▁boolean ▁is Mirror Image ▁= ▁true ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁N ▁- ▁1 ▁; ▁j ▁>= ▁0 ▁; ▁j ▁-- ▁) ▁{ ▁if ▁( ▁mat 2 ▁[ ▁row ▁] ▁[ ▁col ▁] ▁!= ▁mat 1 ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁{ ▁is Mirror Image ▁= ▁false ▁; ▁} ▁col ▁++ ▁; ▁} ▁col ▁= ▁0 ▁; ▁row ▁++ ▁; ▁} ▁if ▁( ▁is Mirror Image ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁4 ▁; ▁int ▁mat 1 ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁, ▁{ ▁0 ▁, ▁6 ▁, ▁7 ▁, ▁8 ▁} ▁, ▁{ ▁9 ▁, ▁10 ▁, ▁11 ▁, ▁12 ▁} ▁, ▁{ ▁13 ▁, ▁14 ▁, ▁15 ▁, ▁16 ▁} ▁} ▁; ▁int ▁mat 2 ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁4 ▁, ▁3 ▁, ▁2 ▁, ▁1 ▁} ▁, ▁{ ▁8 ▁, ▁7 ▁, ▁6 ▁, ▁0 ▁} ▁, ▁{ ▁12 ▁, ▁11 ▁, ▁10 ▁, ▁9 ▁} ▁, ▁{ ▁16 ▁, ▁15 ▁, ▁14 ▁, ▁13 ▁} ▁} ▁; ▁mirror Matrix ▁( ▁mat 1 ▁, ▁mat 2 ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁split string ▁( ▁String ▁s ▁) ▁{ ▁int ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁int ▁zeros ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'0' ▁) ▁zeros ▁++ ▁; ▁if ▁( ▁zeros ▁% ▁3 ▁!= ▁0 ▁) ▁return ▁0 ▁; ▁if ▁( ▁zeros ▁== ▁0 ▁) ▁return ▁( ▁( ▁n ▁- ▁1 ▁) ▁* ▁( ▁n ▁- ▁2 ▁) ▁) ▁/ ▁2 ▁; ▁int ▁zeros In Each Sub string ▁= ▁zeros ▁/ ▁3 ▁; ▁int ▁ways Of First Cut ▁= ▁0 ▁; ▁int ▁ways Of Second Cut ▁= ▁0 ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁. ▁charAt ▁( ▁i ▁) ▁== ▁'0' ▁) ▁count ▁++ ▁; ▁if ▁( ▁count ▁== ▁zeros In Each Sub string ▁) ▁ways Of First Cut ▁++ ▁; ▁else ▁if ▁( ▁count ▁== ▁2 ▁* ▁zeros In Each Sub string ▁) ▁ways Of Second Cut ▁++ ▁; ▁} ▁return ▁ways Of First Cut ▁* ▁ways Of Second Cut ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁String ▁s ▁= ▁" 0101 0" ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁The ▁number ▁of ▁" ▁+ ▁" ▁ways ▁to ▁split ▁is ▁" ▁+ ▁split string ▁( ▁s ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁can Transform ▁( ▁String ▁str 1 ▁, ▁String ▁str 2 ▁) ▁{ ▁String ▁s 1 ▁= ▁" ▁" ▁; ▁String ▁s 2 ▁= ▁" ▁" ▁; ▁for ▁( ▁char ▁c ▁: ▁str 1 ▁. ▁toCharArray ▁( ▁) ▁) ▁{ ▁if ▁( ▁c ▁!= ▁' ▁C ▁' ▁) ▁{ ▁s 1 ▁+= ▁c ▁; ▁} ▁} ▁for ▁( ▁char ▁c ▁: ▁str 2 ▁. ▁toCharArray ▁( ▁) ▁) ▁{ ▁if ▁( ▁c ▁!= ▁' ▁C ▁' ▁) ▁{ ▁s 2 ▁+= ▁c ▁; ▁} ▁} ▁if ▁( ▁! ▁s 1 ▁. ▁equals ▁( ▁s 2 ▁) ▁) ▁return ▁false ▁; ▁int ▁i ▁= ▁0 ▁; ▁int ▁j ▁= ▁0 ▁; ▁int ▁n ▁= ▁str 1 ▁. ▁length ▁( ▁) ▁; ▁while ▁( ▁i ▁< ▁n ▁&& ▁j ▁< ▁n ▁) ▁{ ▁if ▁( ▁str 1 ▁. ▁charAt ▁( ▁i ▁) ▁== ▁' ▁C ▁' ▁) ▁{ ▁i ▁++ ▁; ▁} ▁else ▁if ▁( ▁str 2 ▁. ▁charAt ▁( ▁j ▁) ▁== ▁' ▁C ▁' ▁) ▁{ ▁j ▁++ ▁; ▁} ▁else ▁{ ▁if ▁( ▁( ▁str 1 ▁. ▁charAt ▁( ▁i ▁) ▁== ▁' ▁A ▁' ▁&& ▁i ▁< ▁j ▁) ▁|| ▁( ▁str 1 ▁. ▁charAt ▁( ▁i ▁) ▁== ▁' ▁B ▁' ▁&& ▁i ▁> ▁j ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁i ▁++ ▁; ▁j ▁++ ▁; ▁} ▁} ▁return ▁true ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str 1 ▁= ▁" ▁B CC AB CB CA ▁" ▁; ▁String ▁str 2 ▁= ▁" ▁CB AC C BB AC ▁" ▁; ▁if ▁( ▁can Transform ▁( ▁str 1 ▁, ▁str 2 ▁) ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Yes ▁" ▁) ▁; ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁X ▁= ▁1 ▁; ▁static ▁int ▁diam eter ▁= ▁0 ▁; ▁static ▁HashMap ▁< ▁Integer ▁, ▁Boolean ▁> ▁mp ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁static ▁void ▁dfs ▁( ▁int ▁current _ node ▁, ▁int ▁prev _ node ▁, ▁int ▁len ▁, ▁boolean ▁add _ to _ map ▁, ▁Vector ▁< ▁Integer ▁> ▁[ ▁] ▁adj ▁) ▁{ ▁if ▁( ▁len ▁> ▁diam eter ▁) ▁{ ▁diam eter ▁= ▁len ▁; ▁X ▁= ▁current _ node ▁; ▁} ▁if ▁( ▁add _ to _ map ▁&& ▁len ▁== ▁diam eter ▁) ▁{ ▁mp ▁. ▁put ▁( ▁current _ node ▁, ▁true ▁) ▁; ▁} ▁for ▁( ▁int ▁it ▁: ▁adj ▁[ ▁current _ node ▁] ▁) ▁{ ▁if ▁( ▁it ▁!= ▁prev _ node ▁) ▁dfs ▁( ▁it ▁, ▁current _ node ▁, ▁len ▁+ ▁1 ▁, ▁add _ to _ map ▁, ▁adj ▁) ▁; ▁} ▁} ▁static ▁void ▁dfs Utility ▁( ▁Vector ▁< ▁Integer ▁> ▁[ ▁] ▁adj ▁) ▁{ ▁dfs ▁( ▁1 ▁, ▁- ▁1 ▁, ▁0 ▁, ▁false ▁, ▁adj ▁) ▁; ▁int ▁far th est _ node ▁= ▁X ▁; ▁dfs ▁( ▁far th est _ node ▁, ▁- ▁1 ▁, ▁0 ▁, ▁false ▁, ▁adj ▁) ▁; ▁dfs ▁( ▁far th est _ node ▁, ▁- ▁1 ▁, ▁0 ▁, ▁true ▁, ▁adj ▁) ▁; ▁dfs ▁( ▁X ▁, ▁- ▁1 ▁, ▁0 ▁, ▁true ▁, ▁adj ▁) ▁; ▁} ▁static ▁void ▁print D iam eters ▁( ▁Vector ▁< ▁Integer ▁> ▁[ ▁] ▁adj ▁) ▁{ ▁dfs Utility ▁( ▁adj ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁6 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁mp ▁. ▁containsKey ▁( ▁i ▁) ▁&& ▁mp ▁. ▁get ▁( ▁i ▁) ▁== ▁true ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁diam eter ▁+ ▁1 ▁+ ▁" ▁, ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁diam eter ▁+ ▁" ▁, ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Vector ▁< ▁Integer ▁> ▁[ ▁] ▁adj ▁= ▁new ▁Vector ▁[ ▁7 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁adj ▁. ▁length ▁; ▁i ▁++ ▁) ▁adj ▁[ ▁i ▁] ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁adj ▁[ ▁1 ▁] ▁. ▁add
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁kn ap S ack ▁( ▁int ▁[ ▁] ▁nums ▁, ▁int ▁S ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁: ▁nums ▁) ▁sum ▁+= ▁i ▁; ▁if ▁( ▁sum ▁< ▁S ▁|| ▁- ▁sum ▁> ▁- ▁S ▁|| ▁( ▁S ▁+ ▁sum ▁) ▁% ▁2 ▁== ▁1 ▁) ▁return ▁0 ▁; ▁int ▁[ ▁] ▁dp ▁= ▁new ▁int ▁[ ▁( ▁S ▁+ ▁sum ▁) ▁/ ▁2 ▁+ ▁1 ▁] ▁; ▁dp ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁num ▁: ▁nums ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁dp ▁. ▁length ▁- ▁1 ▁; ▁i ▁>= ▁num ▁; ▁i ▁-- ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁+= ▁dp ▁[ ▁i ▁- ▁num ▁] ▁; ▁} ▁} ▁return ▁dp ▁[ ▁dp ▁. ▁length ▁- ▁1 ▁] ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁S ▁= ▁3 ▁; ▁int ▁[ ▁] ▁arr ▁= ▁new ▁int ▁[ ▁] ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁answer ▁= ▁kn ap S ack ▁( ▁arr ▁, ▁S ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁answer ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁no _ of _ sub String ▁( ▁String ▁s ▁, ▁int ▁N ▁) ▁{ ▁int ▁fre ▁[ ▁] ▁= ▁new ▁int ▁[ ▁26 ▁] ▁; ▁int ▁str _ len ▁; ▁str _ len ▁= ▁( ▁int ▁) ▁s ▁. ▁length ▁( ▁) ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁str _ len ▁; ▁i ▁++ ▁) ▁{ ▁Arrays ▁. ▁fill ▁( ▁fre ▁, ▁0 ▁) ▁; ▁int ▁max _ index ▁= ▁0 ▁; ▁int ▁dist ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁< ▁str _ len ▁; ▁j ▁++ ▁) ▁{ ▁int ▁x ▁= ▁s ▁. ▁charAt ▁( ▁j ▁) ▁- ▁' ▁a ▁' ▁; ▁if ▁( ▁fre ▁[ ▁x ▁] ▁== ▁0 ▁) ▁dist ▁++ ▁; ▁fre ▁[ ▁x ▁] ▁++ ▁; ▁max _ index ▁= ▁Math ▁. ▁max ▁( ▁max _ index ▁, ▁fre ▁[ ▁x ▁] ▁) ▁; ▁if ▁( ▁dist ▁>= ▁N ▁&& ▁( ▁( ▁max _ index ▁* ▁dist ▁) ▁== ▁( ▁j ▁- ▁i ▁+ ▁1 ▁) ▁) ▁) ▁count ▁++ ▁; ▁} ▁} ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁s ▁= ▁" ▁ab h ay ▁" ▁; ▁int ▁N ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁no _ of _ sub String ▁( ▁s ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁class ▁pair ▁{ ▁int ▁first ▁, ▁second ▁; ▁public ▁pair ▁( ▁int ▁first ▁, ▁int ▁second ▁) ▁{ ▁this ▁. ▁first ▁= ▁first ▁; ▁this ▁. ▁second ▁= ▁second ▁; ▁} ▁} ▁static ▁int ▁[ ▁] ▁[ ▁] ▁mat ▁= ▁new ▁int ▁[ ▁1001 ▁] ▁[ ▁1001 ▁] ▁; ▁static ▁int ▁r ▁, ▁c ▁, ▁x ▁, ▁y ▁; ▁static ▁int ▁dx ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁} ▁; ▁static ▁int ▁dy ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁1 ▁, ▁0 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁0 ▁, ▁1 ▁} ▁; ▁static ▁void ▁Find Minimum Distance ▁( ▁) ▁{ ▁Queue ▁< ▁pair ▁> ▁q ▁= ▁new ▁LinkedList ▁< ▁> ▁( ▁) ▁; ▁q ▁. ▁add ▁( ▁new ▁pair ▁( ▁x ▁, ▁y ▁) ▁) ▁; ▁mat ▁[ ▁x ▁] ▁[ ▁y ▁] ▁= ▁0 ▁; ▁while ▁( ▁! ▁q ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁x ▁= ▁q ▁. ▁peek ▁( ▁) ▁. ▁first ▁; ▁y ▁= ▁q ▁. ▁peek ▁( ▁) ▁. ▁second ▁; ▁q ▁. ▁remove ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁8 ▁; ▁i ▁++ ▁) ▁{ ▁int ▁a ▁= ▁x ▁+ ▁dx ▁[ ▁i ▁] ▁; ▁int ▁b ▁= ▁y ▁+ ▁dy ▁[ ▁i ▁] ▁; ▁if ▁( ▁a ▁< ▁0 ▁a ▁>= ▁r ▁b ▁>= ▁c ▁b ▁< ▁0 ▁) ▁continue ▁; ▁if ▁( ▁mat ▁[ ▁a ▁] ▁[ ▁b ▁] ▁== ▁0 ▁) ▁{ ▁mat ▁[ ▁a ▁] ▁[ ▁b ▁] ▁= ▁mat ▁[ ▁x ▁] ▁[ ▁y ▁] ▁+ ▁1 ▁; ▁q ▁. ▁add ▁( ▁new ▁pair ▁( ▁a ▁, ▁b ▁) ▁) ▁; ▁} ▁} ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁r ▁= ▁5 ▁; ▁c ▁= ▁5 ▁; ▁x ▁= ▁1 ▁; ▁y ▁= ▁1 ▁; ▁int ▁t ▁= ▁x ▁; ▁int ▁l ▁= ▁y ▁; ▁mat ▁[ ▁x ▁] ▁[ ▁y ▁] ▁= ▁0 ▁; ▁Find Minimum Distance ▁( ▁) ▁; ▁mat ▁[ ▁t ▁] ▁[ ▁l ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁r ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁c ▁; ▁j ▁++ ▁) ▁{ ▁System
▁class ▁G F G ▁{ ▁static ▁boolean ▁is V ow el ▁( ▁char ▁c ▁) ▁{ ▁if ▁( ▁c ▁== ▁' ▁a ▁' ▁c ▁== ▁' ▁e ▁' ▁c ▁== ▁' ▁i ▁' ▁c ▁== ▁' ▁o ▁' ▁c ▁== ▁' ▁u ▁' ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁static ▁void ▁count Sub strings ▁( ▁String ▁s ▁, ▁int ▁n ▁) ▁{ ▁int ▁result ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁is V ow el ▁( ▁s ▁. ▁charAt ▁( ▁j ▁) ▁) ▁) ▁{ ▁count ▁++ ▁; ▁} ▁if ▁( ▁count ▁% ▁2 ▁== ▁0 ▁) ▁result ▁++ ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁result ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁5 ▁; ▁String ▁s ▁= ▁" ▁abc de ▁" ▁; ▁count Sub strings ▁( ▁s ▁, ▁n ▁) ▁; ▁} ▁}
▁public ▁class ▁Main ▁{ ▁public ▁static ▁void ▁check Pal indrome ▁( ▁String ▁S ▁) ▁{ ▁int ▁N ▁= ▁S ▁. ▁length ▁( ▁) ▁; ▁boolean ▁first _ half ▁= ▁true ▁; ▁boolean ▁second _ half ▁= ▁true ▁; ▁int ▁cnt ▁= ▁( ▁N ▁/ ▁2 ▁) ▁- ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁( ▁N ▁/ ▁2 ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁S ▁. ▁charAt ▁( ▁i ▁) ▁!= ▁S ▁. ▁charAt ▁( ▁cnt ▁) ▁) ▁{ ▁first _ half ▁= ▁false ▁; ▁break ▁; ▁} ▁if ▁( ▁S ▁. ▁charAt ▁( ▁N ▁/ ▁2 ▁+ ▁i ▁) ▁!= ▁S ▁. ▁charAt ▁( ▁N ▁/ ▁2 ▁+ ▁cnt ▁) ▁) ▁{ ▁second _ half ▁= ▁false ▁; ▁break ▁; ▁} ▁cnt ▁-- ▁; ▁} ▁if ▁( ▁first _ half ▁&& ▁second _ half ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁S ▁= ▁" ▁mom d ad ▁" ▁; ▁check Pal indrome ▁( ▁S ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁longest Sub array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁i ▁, ▁j ▁, ▁Max ▁= ▁1 ▁; ▁HashSet ▁< ▁Integer ▁> ▁s ▁= ▁new ▁HashSet ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁s ▁. ▁add ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁for ▁( ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁Math ▁. ▁abs ▁( ▁arr ▁[ ▁i ▁] ▁- ▁arr ▁[ ▁j ▁] ▁) ▁== ▁0 ▁|| ▁Math ▁. ▁abs ▁( ▁arr ▁[ ▁i ▁] ▁- ▁arr ▁[ ▁j ▁] ▁) ▁== ▁k ▁) ▁{ ▁if ▁( ▁! ▁s ▁. ▁contains ▁( ▁arr ▁[ ▁j ▁] ▁) ▁) ▁{ ▁if ▁( ▁s ▁. ▁size ▁( ▁) ▁== ▁2 ▁) ▁break ▁; ▁else ▁s ▁. ▁add ▁( ▁arr ▁[ ▁j ▁] ▁) ▁; ▁} ▁} ▁else ▁break ▁; ▁} ▁if ▁( ▁s ▁. ▁size ▁( ▁) ▁== ▁2 ▁) ▁{ ▁Max ▁= ▁Math ▁. ▁max ▁( ▁Max ▁, ▁j ▁- ▁i ▁) ▁; ▁s ▁. ▁clear ▁( ▁) ▁; ▁} ▁else ▁s ▁. ▁clear ▁( ▁) ▁; ▁} ▁return ▁Max ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁0 ▁, ▁2 ▁, ▁2 ▁, ▁5 ▁, ▁5 ▁, ▁5 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁int ▁K ▁= ▁1 ▁; ▁int ▁length ▁= ▁longest Sub array ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁; ▁if ▁( ▁length ▁== ▁1 ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁- ▁1 ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁length ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁[ ▁] ▁[ ▁] ▁prefix _2 D ▁= ▁new ▁int ▁[ ▁2005 ▁] ▁[ ▁2005 ▁] ▁; ▁static ▁int ▁sub Matrix Sum ▁( ▁int ▁i ▁, ▁int ▁j ▁, ▁int ▁len ▁) ▁{ ▁return ▁prefix _2 D ▁[ ▁i ▁] ▁[ ▁j ▁] ▁- ▁prefix _2 D ▁[ ▁i ▁] ▁[ ▁j ▁- ▁len ▁] ▁- ▁prefix _2 D ▁[ ▁i ▁- ▁len ▁] ▁[ ▁j ▁] ▁+ ▁prefix _2 D ▁[ ▁i ▁- ▁len ▁] ▁[ ▁j ▁- ▁len ▁] ▁; ▁} ▁static ▁int ▁numberOf W ays ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁b ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁m ▁, ▁int ▁k ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁<= ▁m ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁- ▁1 ▁] ▁== ▁b ▁[ ▁j ▁- ▁1 ▁] ▁) ▁prefix _2 D ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁1 ▁; ▁else ▁prefix _2 D ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁0 ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁<= ▁m ▁; ▁j ▁++ ▁) ▁{ ▁prefix _2 D ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+= ▁prefix _2 D ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁<= ▁m ▁; ▁j ▁++ ▁) ▁{ ▁prefix _2 D ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+= ▁prefix _2 D ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁; ▁} ▁} ▁int ▁answer ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁<= ▁m ▁; ▁j ▁++ ▁) ▁{ ▁int ▁low ▁= ▁1 ▁; ▁int ▁high ▁= ▁Math ▁. ▁min ▁( ▁i ▁, ▁j ▁) ▁; ▁while ▁( ▁low ▁< ▁high ▁) ▁{ ▁int ▁mid ▁= ▁( ▁low ▁+ ▁high ▁) ▁>> ▁1 ▁; ▁if ▁( ▁sub Matrix Sum ▁( ▁i ▁, ▁j ▁, ▁mid ▁) ▁>= ▁k ▁) ▁{ ▁high ▁= ▁mid ▁; ▁} ▁else ▁{ ▁low ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁} ▁if ▁(
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁NO _ OF _ CHARS ▁= ▁256 ▁; ▁static ▁int ▁first Repe ating ▁( ▁String ▁str ▁) ▁{ ▁boolean ▁[ ▁] ▁visited ▁= ▁new ▁boolean ▁[ ▁NO _ OF _ CHARS ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁NO _ OF _ CHARS ▁; ▁i ▁++ ▁) ▁visited ▁[ ▁i ▁] ▁= ▁false ▁; ▁int ▁res ▁= ▁- ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁str ▁. ▁length ▁( ▁) ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁visited ▁[ ▁str ▁. ▁charAt ▁( ▁i ▁) ▁] ▁== ▁false ▁) ▁visited ▁[ ▁str ▁. ▁charAt ▁( ▁i ▁) ▁] ▁= ▁true ▁; ▁else ▁res ▁= ▁i ▁; ▁} ▁return ▁res ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁str ▁= ▁" ▁g eek s forge ek s ▁" ▁; ▁int ▁index ▁= ▁first Repe ating ▁( ▁str ▁) ▁; ▁if ▁( ▁index ▁== ▁- ▁1 ▁) ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁Either ▁all ▁characters ▁are ▁" ▁+ ▁" ▁distinct ▁or ▁string ▁is ▁empty ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁First ▁Re pe ating ▁character ▁" ▁+ ▁" ▁is ▁% ▁c ▁" ▁, ▁str ▁. ▁charAt ▁( ▁index ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁find Sum Pairs ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁Map ▁< ▁Integer ▁, ▁Integer ▁> ▁m pp ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁m pp ▁. ▁put ▁( ▁a ▁[ ▁i ▁] ▁+ ▁a ▁[ ▁j ▁] ▁, ▁m pp ▁. ▁get ▁( ▁a ▁[ ▁i ▁] ▁+ ▁a ▁[ ▁j ▁] ▁) ▁== ▁null ▁? ▁1 ▁: ▁m pp ▁. ▁get ▁( ▁a ▁[ ▁i ▁] ▁+ ▁a ▁[ ▁j ▁] ▁) ▁+ ▁1 ▁) ▁; ▁} ▁} ▁int ▁occur ▁= ▁0 ▁; ▁for ▁( ▁Map ▁. ▁Entry ▁< ▁Integer ▁, ▁Integer ▁> ▁entry ▁: ▁m pp ▁. ▁entrySet ▁( ▁) ▁) ▁{ ▁if ▁( ▁entry ▁. ▁getValue ▁( ▁) ▁> ▁occur ▁) ▁{ ▁occur ▁= ▁entry ▁. ▁getValue ▁( ▁) ▁; ▁} ▁} ▁for ▁( ▁Map ▁. ▁Entry ▁< ▁Integer ▁, ▁Integer ▁> ▁entry ▁: ▁m pp ▁. ▁entrySet ▁( ▁) ▁) ▁{ ▁if ▁( ▁entry ▁. ▁getValue ▁( ▁) ▁== ▁occur ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁entry ▁. ▁getKey ▁( ▁) ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁8 ▁, ▁3 ▁, ▁11 ▁, ▁4 ▁, ▁9 ▁, ▁2 ▁, ▁7 ▁} ▁; ▁int ▁n ▁= ▁a ▁. ▁length ▁; ▁find Sum Pairs ▁( ▁a ▁, ▁n ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁find Small est After Del ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁m ▁, ▁int ▁del ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁mp ▁= ▁new ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁mp ▁. ▁containsKey ▁( ▁del ▁[ ▁i ▁] ▁) ▁) ▁{ ▁mp ▁. ▁put ▁( ▁del ▁[ ▁i ▁] ▁, ▁mp ▁. ▁get ▁( ▁del ▁[ ▁i ▁] ▁) ▁+ ▁1 ▁) ▁; ▁} ▁else ▁{ ▁mp ▁. ▁put ▁( ▁del ▁[ ▁i ▁] ▁, ▁1 ▁) ▁; ▁} ▁} ▁int ▁smallest Element ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁m ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁mp ▁. ▁containsKey ▁( ▁arr ▁[ ▁i ▁] ▁) ▁) ▁{ ▁mp ▁. ▁put ▁( ▁arr ▁[ ▁i ▁] ▁, ▁mp ▁. ▁get ▁( ▁arr ▁[ ▁i ▁] ▁) ▁- ▁1 ▁) ▁; ▁if ▁( ▁mp ▁. ▁get ▁( ▁arr ▁[ ▁i ▁] ▁) ▁== ▁0 ▁) ▁mp ▁. ▁remove ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁else ▁smallest Element ▁= ▁Math ▁. ▁min ▁( ▁smallest Element ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁return ▁smallest Element ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁array ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁12 ▁, ▁33 ▁, ▁4 ▁, ▁56 ▁, ▁12 ▁, ▁20 ▁} ▁; ▁int ▁m ▁= ▁array ▁. ▁length ▁; ▁int ▁del ▁[ ▁] ▁= ▁{ ▁12 ▁, ▁4 ▁, ▁56 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁del ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find Small est After Del ▁( ▁array ▁, ▁m ▁, ▁del ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁find l argest After Del ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁m ▁, ▁int ▁del ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁mp ▁= ▁new ▁HashMap ▁< ▁Integer ▁, ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁mp ▁. ▁containsKey ▁( ▁del ▁[ ▁i ▁] ▁) ▁) ▁{ ▁mp ▁. ▁put ▁( ▁del ▁[ ▁i ▁] ▁, ▁mp ▁. ▁get ▁( ▁del ▁[ ▁i ▁] ▁) ▁+ ▁1 ▁) ▁; ▁} ▁else ▁{ ▁mp ▁. ▁put ▁( ▁del ▁[ ▁i ▁] ▁, ▁1 ▁) ▁; ▁} ▁} ▁int ▁largest Element ▁= ▁Integer ▁. ▁MIN _ VALUE ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁m ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁mp ▁. ▁containsKey ▁( ▁arr ▁[ ▁i ▁] ▁) ▁) ▁{ ▁mp ▁. ▁put ▁( ▁arr ▁[ ▁i ▁] ▁, ▁mp ▁. ▁get ▁( ▁arr ▁[ ▁i ▁] ▁) ▁- ▁1 ▁) ▁; ▁if ▁( ▁mp ▁. ▁get ▁( ▁arr ▁[ ▁i ▁] ▁) ▁== ▁0 ▁) ▁mp ▁. ▁remove ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁else ▁largest Element ▁= ▁Math ▁. ▁max ▁( ▁largest Element ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁return ▁largest Element ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁array ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁12 ▁, ▁33 ▁, ▁4 ▁, ▁56 ▁, ▁12 ▁, ▁20 ▁} ▁; ▁int ▁m ▁= ▁array ▁. ▁length ▁; ▁int ▁del ▁[ ▁] ▁= ▁{ ▁12 ▁, ▁33 ▁, ▁56 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁del ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁find l argest After Del ▁( ▁array ▁, ▁m ▁, ▁del ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁solve ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁min 1 ▁= ▁a ▁[ ▁0 ▁] ▁; ▁int ▁max 1 ▁= ▁a ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁> ▁max 1 ▁) ▁max 1 ▁= ▁a ▁[ ▁i ▁] ▁; ▁if ▁( ▁a ▁[ ▁i ▁] ▁< ▁min 1 ▁) ▁min 1 ▁= ▁a ▁[ ▁i ▁] ▁; ▁} ▁return ▁Math ▁. ▁abs ▁( ▁min 1 ▁- ▁max 1 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁- ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁- ▁10 ▁} ▁; ▁int ▁size ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁L argest ▁gap ▁is ▁: ▁" ▁+ ▁solve ▁( ▁arr ▁, ▁size ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁getMinimum Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁ArrayList ▁< ▁Integer ▁> ▁res ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁ArrayList ▁< ▁Integer ▁> ▁pos ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁ArrayList ▁< ▁Integer ▁> ▁neg ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁0 ▁) ▁pos ▁. ▁add ▁( ▁i ▁) ▁; ▁else ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁0 ▁) ▁neg ▁. ▁add ▁( ▁i ▁) ▁; ▁} ▁if ▁( ▁pos ▁. ▁size ▁( ▁) ▁>= ▁2 ▁&& ▁neg ▁. ▁size ▁( ▁) ▁>= ▁2 ▁) ▁{ ▁int ▁pos Max ▁= ▁Integer ▁. ▁MIN _ VALUE ▁, ▁pos Max Idx ▁= ▁- ▁1 ▁; ▁int ▁pos Min ▁= ▁Integer ▁. ▁MAX _ VALUE ▁, ▁pos Min Idx ▁= ▁- ▁1 ▁; ▁int ▁neg Max ▁= ▁Integer ▁. ▁MIN _ VALUE ▁, ▁neg Max Idx ▁= ▁- ▁1 ▁; ▁int ▁neg Min ▁= ▁Integer ▁. ▁MAX _ VALUE ▁, ▁neg Min Idx ▁= ▁- ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁pos ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁pos ▁. ▁get ▁( ▁i ▁) ▁] ▁> ▁pos Max ▁) ▁{ ▁pos Max Idx ▁= ▁pos ▁. ▁get ▁( ▁i ▁) ▁; ▁pos Max ▁= ▁arr ▁[ ▁pos Max Idx ▁] ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁pos ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁pos ▁. ▁get ▁( ▁i ▁) ▁] ▁< ▁pos Min ▁&& ▁pos ▁. ▁get ▁( ▁i ▁) ▁!= ▁pos Max Idx ▁) ▁{ ▁pos Min Idx ▁= ▁pos ▁. ▁get ▁( ▁i ▁) ▁; ▁pos Min ▁= ▁arr ▁[ ▁pos Min Idx ▁] ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁neg ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁Math ▁. ▁abs ▁( ▁arr ▁[ ▁neg ▁. ▁get ▁( ▁i ▁) ▁] ▁) ▁> ▁neg Max ▁) ▁{ ▁neg Max Idx ▁= ▁neg ▁. ▁get ▁( ▁i ▁) ▁; ▁neg Max ▁= ▁Math ▁. ▁abs ▁( ▁arr ▁[ ▁neg Max
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁missing Num ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁List ▁< ▁Integer ▁> ▁list ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁arr ▁. ▁length ▁) ▁; ▁for ▁( ▁int ▁i ▁: ▁arr ▁) ▁{ ▁list ▁. ▁add ▁( ▁Integer ▁. ▁valueOf ▁( ▁i ▁) ▁) ▁; ▁} ▁int ▁min value ▁= ▁Collections ▁. ▁min ▁( ▁list ▁) ▁; ▁; ▁int ▁xor num ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁xor num ▁^= ▁( ▁min value ▁) ▁^ ▁arr ▁[ ▁i ▁] ▁; ▁min value ▁++ ▁; ▁} ▁return ▁xor num ▁^ ▁min value ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁13 ▁, ▁12 ▁, ▁11 ▁, ▁15 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁missing Num ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁maximum M ex ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁ans ▁[ ▁] ▁= ▁new ▁int ▁[ ▁2 ▁* ▁N ▁] ▁; ▁Arrays ▁. ▁sort ▁( ▁ans ▁) ▁; ▁int ▁j ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁== ▁0 ▁arr ▁[ ▁i ▁] ▁!= ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁) ▁{ ▁j ▁+= ▁1 ▁; ▁ans ▁[ ▁j ▁] ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁> ▁0 ▁&& ▁arr ▁[ ▁i ▁] ▁== ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁) ▁{ ▁j ▁+= ▁1 ▁; ▁ans ▁[ ▁j ▁] ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁ans ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁0 ▁, ▁0 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁maximum M ex ▁( ▁arr ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁ArrayList ▁< ▁Integer ▁> ▁bubble _ sort ▁( ▁ArrayList ▁< ▁Integer ▁> ▁ar ▁) ▁{ ▁if ▁( ▁ar ▁. ▁size ▁( ▁) ▁<= ▁1 ▁) ▁return ▁ar ▁; ▁if ▁( ▁ar ▁. ▁size ▁( ▁) ▁== ▁2 ▁) ▁{ ▁if ▁( ▁ar ▁. ▁get ▁( ▁0 ▁) ▁< ▁ar ▁. ▁get ▁( ▁1 ▁) ▁) ▁return ▁ar ▁; ▁else ▁return ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁Arrays ▁. ▁asList ▁( ▁ar ▁. ▁get ▁( ▁1 ▁) ▁, ▁ar ▁. ▁get ▁( ▁0 ▁) ▁) ▁) ▁; ▁} ▁int ▁a ▁= ▁ar ▁. ▁get ▁( ▁0 ▁) ▁; ▁int ▁b ▁= ▁ar ▁. ▁get ▁( ▁1 ▁) ▁; ▁ArrayList ▁< ▁Integer ▁> ▁bs ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁< ▁ar ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁bs ▁. ▁add ▁( ▁ar ▁. ▁get ▁( ▁i ▁) ▁) ▁; ▁ArrayList ▁< ▁Integer ▁> ▁res ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁if ▁( ▁a ▁< ▁b ▁) ▁{ ▁ArrayList ▁< ▁Integer ▁> ▁temp 1 ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁temp 1 ▁. ▁add ▁( ▁b ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁bs ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁temp 1 ▁. ▁add ▁( ▁bs ▁. ▁get ▁( ▁i ▁) ▁) ▁; ▁ArrayList ▁< ▁Integer ▁> ▁v ▁= ▁bubble _ sort ▁( ▁temp 1 ▁) ▁; ▁v ▁. ▁add ▁( ▁0 ▁, ▁a ▁) ▁; ▁res ▁= ▁v ▁; ▁} ▁else ▁{ ▁ArrayList ▁< ▁Integer ▁> ▁temp 1 ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁temp 1 ▁. ▁add ▁( ▁a ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁bs ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁temp 1 ▁. ▁add ▁( ▁bs ▁. ▁get ▁( ▁i ▁) ▁) ▁; ▁ArrayList ▁< ▁Integer ▁> ▁v ▁= ▁bubble _ sort ▁( ▁temp 1 ▁) ▁; ▁v ▁. ▁add ▁( ▁0 ▁, ▁b ▁) ▁; ▁res ▁= ▁v ▁; ▁} ▁ArrayList ▁< ▁Integer ▁> ▁pass ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁res ▁. ▁size ▁( ▁) ▁- ▁1 ▁; ▁i ▁++ ▁) ▁pass ▁. ▁add ▁( ▁res ▁.
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁int ▁solution ▁( ▁int ▁A ▁, ▁int ▁B ▁, ▁int ▁C ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁new ▁int ▁[ ▁3 ▁] ▁; ▁arr ▁[ ▁0 ▁] ▁= ▁A ▁; ▁arr ▁[ ▁1 ▁] ▁= ▁B ▁; ▁arr ▁[ ▁2 ▁] ▁= ▁C ▁; ▁Arrays ▁. ▁sort ▁( ▁arr ▁) ▁; ▁if ▁( ▁arr ▁[ ▁2 ▁] ▁< ▁arr ▁[ ▁0 ▁] ▁+ ▁arr ▁[ ▁1 ▁] ▁) ▁return ▁( ▁( ▁arr ▁[ ▁0 ▁] ▁+ ▁arr ▁[ ▁1 ▁] ▁+ ▁arr ▁[ ▁2 ▁] ▁) ▁/ ▁2 ▁) ▁; ▁else ▁return ▁( ▁arr ▁[ ▁0 ▁] ▁+ ▁arr ▁[ ▁1 ▁] ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁A ▁= ▁8 ▁, ▁B ▁= ▁1 ▁, ▁C ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁solution ▁( ▁A ▁, ▁B ▁, ▁C ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁max _ length ▁= ▁0 ▁; ▁static ▁Vector ▁< ▁Integer ▁> ▁store ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁static ▁Vector ▁< ▁Integer ▁> ▁ans ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁static ▁void ▁find _ max _ length ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁index ▁, ▁int ▁sum ▁, ▁int ▁k ▁) ▁{ ▁sum ▁= ▁sum ▁+ ▁arr ▁[ ▁index ▁] ▁; ▁store ▁. ▁add ▁( ▁arr ▁[ ▁index ▁] ▁) ▁; ▁if ▁( ▁sum ▁== ▁k ▁) ▁{ ▁if ▁( ▁max _ length ▁< ▁store ▁. ▁size ▁( ▁) ▁) ▁{ ▁max _ length ▁= ▁store ▁. ▁size ▁( ▁) ▁; ▁ans ▁= ▁store ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁index ▁+ ▁1 ▁; ▁i ▁< ▁arr ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁sum ▁+ ▁arr ▁[ ▁i ▁] ▁<= ▁k ▁) ▁{ ▁find _ max _ length ▁( ▁arr ▁, ▁i ▁, ▁sum ▁, ▁k ▁) ▁; ▁store ▁. ▁remove ▁( ▁store ▁. ▁size ▁( ▁) ▁- ▁1 ▁) ▁; ▁} ▁else ▁return ▁; ▁} ▁return ▁; ▁} ▁static ▁int ▁longest Sub sequence ▁( ▁int ▁[ ▁] ▁arr ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁arr ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁max _ length ▁>= ▁n ▁- ▁i ▁) ▁break ▁; ▁store ▁. ▁clear ▁( ▁) ▁; ▁find _ max _ length ▁( ▁arr ▁, ▁i ▁, ▁0 ▁, ▁k ▁) ▁; ▁} ▁return ▁max _ length ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁arr ▁= ▁{ ▁- ▁3 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁int ▁k ▁= ▁1 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁longest Sub sequence ▁( ▁arr ▁, ▁n ▁, ▁k ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁getNumber ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁pos ▁; ▁if ▁( ▁( ▁n ▁% ▁2 ▁) ▁== ▁0 ▁) ▁{ ▁pos ▁= ▁n ▁/ ▁2 ▁; ▁} ▁else ▁{ ▁pos ▁= ▁( ▁n ▁/ ▁2 ▁) ▁+ ▁1 ▁; ▁} ▁if ▁( ▁k ▁<= ▁pos ▁) ▁{ ▁return ▁( ▁k ▁* ▁2 ▁- ▁1 ▁) ▁; ▁} ▁else ▁return ▁( ▁( ▁k ▁- ▁pos ▁) ▁* ▁2 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁8 ▁, ▁k ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁getNumber ▁( ▁n ▁, ▁k ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁Arrays ▁; ▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁count Sequ ences ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁count ▁= ▁1 ▁; ▁Arrays ▁. ▁sort ▁( ▁arr ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁if ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁1 ▁!= ▁arr ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁count ▁++ ▁; ▁return ▁count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁7 ▁, ▁3 ▁, ▁5 ▁, ▁10 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count Sequ ences ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁check Fit ting Arrays ▁( ▁int ▁[ ▁] ▁A ▁, ▁int ▁[ ▁] ▁B ▁, ▁int ▁N ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁A ▁) ▁; ▁Arrays ▁. ▁sort ▁( ▁B ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁if ▁( ▁A ▁[ ▁i ▁] ▁> ▁B ▁[ ▁i ▁] ▁) ▁return ▁false ▁; ▁return ▁true ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁7 ▁, ▁5 ▁, ▁3 ▁, ▁2 ▁} ▁; ▁int ▁B ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁4 ▁, ▁8 ▁, ▁7 ▁} ▁; ▁int ▁N ▁= ▁A ▁. ▁length ▁; ▁if ▁( ▁check Fit ting Arrays ▁( ▁A ▁, ▁B ▁, ▁N ▁) ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁YES ▁" ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁NO ▁" ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁void ▁stable Selection Sort ▁( ▁int ▁[ ▁] ▁a ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁int ▁min ▁= ▁i ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁if ▁( ▁a ▁[ ▁min ▁] ▁> ▁a ▁[ ▁j ▁] ▁) ▁min ▁= ▁j ▁; ▁int ▁key ▁= ▁a ▁[ ▁min ▁] ▁; ▁while ▁( ▁min ▁> ▁i ▁) ▁{ ▁a ▁[ ▁min ▁] ▁= ▁a ▁[ ▁min ▁- ▁1 ▁] ▁; ▁min ▁-- ▁; ▁} ▁a ▁[ ▁i ▁] ▁= ▁key ▁; ▁} ▁} ▁static ▁void ▁print Array ▁( ▁int ▁[ ▁] ▁a ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁a ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁a ▁= ▁{ ▁4 ▁, ▁5 ▁, ▁3 ▁, ▁2 ▁, ▁4 ▁, ▁1 ▁} ▁; ▁int ▁n ▁= ▁a ▁. ▁length ▁; ▁stable Selection Sort ▁( ▁a ▁, ▁n ▁) ▁; ▁print Array ▁( ▁a ▁, ▁n ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁P anc ake Sort ▁{ ▁static ▁void ▁flip ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁i ▁) ▁{ ▁int ▁temp ▁, ▁start ▁= ▁0 ▁; ▁while ▁( ▁start ▁< ▁i ▁) ▁{ ▁temp ▁= ▁arr ▁[ ▁start ▁] ▁; ▁arr ▁[ ▁start ▁] ▁= ▁arr ▁[ ▁i ▁] ▁; ▁arr ▁[ ▁i ▁] ▁= ▁temp ▁; ▁start ▁++ ▁; ▁i ▁-- ▁; ▁} ▁} ▁static ▁int ▁find Max ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁mi ▁, ▁i ▁; ▁for ▁( ▁mi ▁= ▁0 ▁, ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁arr ▁[ ▁mi ▁] ▁) ▁mi ▁= ▁i ▁; ▁return ▁mi ▁; ▁} ▁static ▁int ▁p anc ake Sort ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁curr _ size ▁= ▁n ▁; ▁curr _ size ▁> ▁1 ▁; ▁-- ▁curr _ size ▁) ▁{ ▁int ▁mi ▁= ▁find Max ▁( ▁arr ▁, ▁curr _ size ▁) ▁; ▁if ▁( ▁mi ▁!= ▁curr _ size ▁- ▁1 ▁) ▁{ ▁flip ▁( ▁arr ▁, ▁mi ▁) ▁; ▁flip ▁( ▁arr ▁, ▁curr _ size ▁- ▁1 ▁) ▁; ▁} ▁} ▁return ▁0 ▁; ▁} ▁static ▁void ▁print Array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁arr _ size ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁arr _ size ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁23 ▁, ▁10 ▁, ▁20 ▁, ▁11 ▁, ▁12 ▁, ▁6 ▁, ▁7 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁p anc ake Sort ▁( ▁arr ▁, ▁n ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Sorted ▁Array ▁: ▁" ▁) ▁; ▁print Array ▁( ▁arr ▁, ▁n ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁find Array With Max Product ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁if ▁( ▁arr ▁[ ▁i ▁] ▁>= ▁0 ▁) ▁{ ▁arr ▁[ ▁i ▁] ▁= ▁- ▁arr ▁[ ▁i ▁] ▁- ▁1 ▁; ▁} ▁if ▁( ▁N ▁% ▁2 ▁== ▁1 ▁) ▁{ ▁int ▁max _ element ▁= ▁- ▁1 ▁; ▁int ▁index ▁= ▁- ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁if ▁( ▁Math ▁. ▁abs ▁( ▁arr ▁[ ▁i ▁] ▁) ▁> ▁max _ element ▁) ▁{ ▁max _ element ▁= ▁Math ▁. ▁abs ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁index ▁= ▁i ▁; ▁} ▁arr ▁[ ▁index ▁] ▁= ▁- ▁arr ▁[ ▁index ▁] ▁- ▁1 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁System ▁. ▁out ▁. ▁print ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁" ▁" ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁- ▁3 ▁, ▁0 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁length ▁; ▁find Array With Max Product ▁( ▁arr ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁lang ▁. ▁* ▁; ▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁N ▁= ▁100000 ▁+ ▁5 ▁; ▁static ▁int ▁visited ▁[ ▁] ▁= ▁new ▁int ▁[ ▁N ▁] ▁; ▁static ▁void ▁construct _ tree ▁( ▁int ▁weights ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁minimum ▁= ▁Arrays ▁. ▁stream ▁( ▁weights ▁) ▁. ▁min ▁( ▁) ▁. ▁getAs Int ▁( ▁) ▁; ▁int ▁maximum ▁= ▁Arrays ▁. ▁stream ▁( ▁weights ▁) ▁. ▁max ▁( ▁) ▁. ▁getAs Int ▁( ▁) ▁; ▁if ▁( ▁minimum ▁== ▁maximum ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁No ▁" ▁) ▁; ▁return ▁; ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁" ▁Yes ▁" ▁) ▁; ▁} ▁int ▁root ▁= ▁weights ▁[ ▁0 ▁] ▁; ▁visited ▁[ ▁1 ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁weights ▁[ ▁i ▁] ▁!= ▁root ▁&& ▁visited ▁[ ▁i ▁+ ▁1 ▁] ▁== ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁1 ▁+ ▁" ▁" ▁+ ▁( ▁i ▁+ ▁1 ▁) ▁+ ▁" ▁" ▁) ▁; ▁visited ▁[ ▁i ▁+ ▁1 ▁] ▁= ▁1 ▁; ▁} ▁} ▁int ▁not root ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁weights ▁[ ▁i ▁] ▁!= ▁root ▁) ▁{ ▁not root ▁= ▁i ▁+ ▁1 ▁; ▁break ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁weights ▁[ ▁i ▁] ▁== ▁root ▁&& ▁visited ▁[ ▁i ▁+ ▁1 ▁] ▁== ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁not root ▁+ ▁" ▁" ▁+ ▁( ▁i ▁+ ▁1 ▁) ▁) ▁; ▁visited ▁[ ▁i ▁+ ▁1 ▁] ▁= ▁1 ▁; ▁} ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁weights ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁1 ▁, ▁2 ▁, ▁5 ▁} ▁; ▁int ▁N ▁= ▁weights ▁. ▁length ▁; ▁construct _ tree ▁( ▁weights ▁, ▁N ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁addEdge ▁( ▁Vector ▁< ▁Integer ▁> ▁adj ▁[ ▁] ▁, ▁int ▁u ▁, ▁int ▁v ▁) ▁{ ▁adj ▁[ ▁u ▁] ▁. ▁add ▁( ▁v ▁) ▁; ▁adj ▁[ ▁v ▁] ▁. ▁add ▁( ▁u ▁) ▁; ▁} ▁static ▁int ▁cnt ▁= ▁0 ▁; ▁static ▁boolean ▁[ ▁] ▁visited ▁; ▁static ▁void ▁DFS ▁( ▁int ▁u ▁, ▁Vector ▁< ▁Integer ▁> ▁adj ▁[ ▁] ▁, ▁int ▁fre ▁[ ▁] ▁, ▁String ▁S ▁) ▁{ ▁visited ▁[ ▁u ▁] ▁= ▁true ▁; ▁cnt ▁++ ▁; ▁fre ▁[ ▁S ▁. ▁charAt ▁( ▁u ▁) ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁adj ▁[ ▁u ▁] ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁! ▁visited ▁[ ▁adj ▁[ ▁u ▁] ▁. ▁get ▁( ▁i ▁) ▁] ▁) ▁{ ▁DFS ▁( ▁adj ▁[ ▁u ▁] ▁. ▁get ▁( ▁i ▁) ▁, ▁adj ▁, ▁fre ▁, ▁S ▁) ▁; ▁} ▁} ▁} ▁static ▁void ▁minimum Operations ▁( ▁String ▁S ▁, ▁int ▁m ▁) ▁{ ▁int ▁V ▁= ▁100 ▁; ▁@ ▁Suppress Warnings ▁( ▁" ▁unchecked ▁" ▁) ▁Vector ▁< ▁Integer ▁> ▁[ ▁] ▁adj ▁= ▁new ▁Vector ▁[ ▁V ▁] ▁; ▁int ▁total ▁= ▁0 ▁, ▁N ▁= ▁S ▁. ▁length ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁adj ▁. ▁length ▁; ▁i ▁++ ▁) ▁adj ▁[ ▁i ▁] ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁addEdge ▁( ▁adj ▁, ▁i ▁, ▁N ▁- ▁i ▁- ▁1 ▁) ▁; ▁addEdge ▁( ▁adj ▁, ▁N ▁- ▁i ▁- ▁1 ▁, ▁i ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁- ▁m ▁; ▁i ▁++ ▁) ▁{ ▁addEdge ▁( ▁adj ▁, ▁i ▁, ▁i ▁+ ▁m ▁) ▁; ▁addEdge ▁( ▁adj ▁, ▁i ▁+ ▁m ▁, ▁i ▁) ▁; ▁} ▁visited ▁= ▁new ▁boolean ▁[ ▁V ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁! ▁visited ▁[ ▁i ▁] ▁) ▁{ ▁int ▁fre ▁[ ▁] ▁= ▁new ▁int ▁[ ▁26 ▁] ▁; ▁cnt ▁= ▁0 ▁; ▁int ▁max x ▁= ▁- ▁1 ▁; ▁DFS ▁( ▁i ▁, ▁adj ▁, ▁fre ▁, ▁S
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁clear Last Bit ▁( ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁int ▁mask ▁= ▁( ▁- ▁1 ▁<< ▁K ▁+ ▁1 ▁) ▁; ▁return ▁N ▁= ▁N ▁& ▁mask ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁7 30 ▁, ▁K ▁= ▁3 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁clear Last Bit ▁( ▁N ▁, ▁K ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁boolean ▁isP ossible ▁( ▁int ▁r ▁, ▁int ▁b ▁, ▁int ▁g ▁) ▁{ ▁r ▁= ▁r ▁% ▁3 ▁; ▁b ▁= ▁b ▁% ▁3 ▁; ▁g ▁= ▁g ▁% ▁3 ▁; ▁if ▁( ▁r ▁== ▁b ▁b ▁== ▁g ▁g ▁== ▁r ▁) ▁{ ▁return ▁true ▁; ▁} ▁else ▁{ ▁return ▁false ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁R ▁= ▁1 ▁, ▁B ▁= ▁3 ▁, ▁G ▁= ▁6 ▁; ▁if ▁( ▁isP ossible ▁( ▁R ▁, ▁B ▁, ▁G ▁) ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁Yes ▁" ▁+ ▁" NEW _ LINE "); ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁" ▁No ▁" ▁+ ▁" NEW _ LINE "); ▁} ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁count Set Bits Util ▁( ▁int ▁x ▁) ▁{ ▁if ▁( ▁x ▁<= ▁0 ▁) ▁return ▁0 ▁; ▁return ▁( ▁( ▁x ▁% ▁2 ▁== ▁0 ▁? ▁0 ▁: ▁1 ▁) ▁+ ▁count Set Bits Util ▁( ▁x ▁/ ▁2 ▁) ▁) ▁; ▁} ▁static ▁int ▁count Set Bits ▁( ▁int ▁L ▁, ▁int ▁R ▁) ▁{ ▁int ▁bit Count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁L ▁; ▁i ▁<= ▁R ▁; ▁i ▁++ ▁) ▁{ ▁bit Count ▁+= ▁count Set Bits Util ▁( ▁i ▁) ▁; ▁} ▁return ▁bit Count ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁L ▁= ▁3 ▁, ▁R ▁= ▁5 ▁; ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁Total ▁set ▁bit ▁count ▁is ▁% ▁d ▁" ▁, ▁count Set Bits ▁( ▁L ▁, ▁R ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁getMin Cost ▁( ▁int ▁[ ▁] ▁A ▁, ▁int ▁[ ▁] ▁B ▁, ▁int ▁N ▁) ▁{ ▁int ▁mini ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁mini ▁= ▁Math ▁. ▁min ▁( ▁mini ▁, ▁Math ▁. ▁min ▁( ▁A ▁[ ▁i ▁] ▁, ▁B ▁[ ▁i ▁] ▁) ▁) ▁; ▁} ▁return ▁mini ▁* ▁( ▁2 ▁* ▁N ▁- ▁1 ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁3 ▁; ▁int ▁[ ▁] ▁A ▁= ▁{ ▁1 ▁, ▁4 ▁, ▁2 ▁} ▁; ▁int ▁[ ▁] ▁B ▁= ▁{ ▁10 ▁, ▁6 ▁, ▁12 ▁} ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁getMin Cost ▁( ▁A ▁, ▁B ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁find M ▁( ▁int ▁N ▁) ▁{ ▁int ▁M ▁= ▁0 ▁; ▁int ▁MS B ▁= ▁( ▁int ▁) ▁Math ▁. ▁log ▁( ▁N ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁MS B ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁N ▁& ▁( ▁1 ▁<< ▁i ▁) ▁) ▁== ▁0 ▁) ▁M ▁+= ▁( ▁1 ▁<< ▁i ▁) ▁; ▁} ▁return ▁M ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁6 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁find M ▁( ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁max Mod ul os um ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁a ▁[ ▁i ▁] ▁; ▁} ▁return ▁sum ▁- ▁n ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁new ▁int ▁[ ▁] ▁{ ▁3 ▁, ▁4 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁a ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁max Mod ul os um ▁( ▁a ▁, ▁n ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁make Zero ▁( ▁int ▁x ▁, ▁int ▁y ▁, ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁if ▁( ▁x ▁> ▁y ▁) ▁{ ▁int ▁temp ▁= ▁x ▁; ▁x ▁= ▁y ▁; ▁y ▁= ▁temp ▁; ▁} ▁int ▁tot _ cost ▁= ▁( ▁y ▁- ▁x ▁) ▁* ▁a ▁; ▁int ▁cost 1 ▁= ▁2 ▁* ▁x ▁* ▁a ▁; ▁int ▁cost 2 ▁= ▁x ▁* ▁b ▁; ▁tot _ cost ▁+= ▁Math ▁. ▁min ▁( ▁cost 1 ▁, ▁cost 2 ▁) ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁tot _ cost ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁X ▁= ▁1 ▁, ▁Y ▁= ▁3 ▁; ▁int ▁cost 1 ▁= ▁3 91 ▁, ▁cost 2 ▁= ▁5 55 ▁; ▁make Zero ▁( ▁X ▁, ▁Y ▁, ▁cost 1 ▁, ▁cost 2 ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁Scanner ▁; ▁class ▁Solution ▁{ ▁public ▁static ▁void ▁split Fraction ▁( ▁int ▁n ▁, ▁int ▁d ▁) ▁{ ▁long ▁ar ▁[ ▁] ▁= ▁new ▁long ▁[ ▁n ▁] ▁; ▁long ▁first ▁= ▁d ▁+ ▁n ▁- ▁1 ▁; ▁ar ▁[ ▁0 ▁] ▁= ▁first ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁ar ▁[ ▁i ▁] ▁= ▁first ▁* ▁( ▁-- ▁first ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁ar ▁[ ▁i ▁] ▁% ▁n ▁== ▁0 ▁) ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁"1 ▁/ ▁" ▁+ ▁ar ▁[ ▁i ▁] ▁/ ▁n ▁+ ▁" ▁, ▁" ▁) ▁; ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁print ▁( ▁n ▁+ ▁" ▁/ ▁" ▁+ ▁ar ▁[ ▁i ▁] ▁+ ▁" ▁, ▁" ▁) ▁; ▁} ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁throws ▁Exception ▁{ ▁int ▁N ▁= ▁4 ▁; ▁int ▁D ▁= ▁2 ▁; ▁split Fraction ▁( ▁N ▁, ▁D ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁find Minimum Sub sequences ▁( ▁String ▁A ▁, ▁String ▁B ▁) ▁{ ▁int ▁numberOf Sub sequences ▁= ▁1 ▁; ▁int ▁sizeOf B ▁= ▁B ▁. ▁length ▁( ▁) ▁; ▁int ▁sizeOf A ▁= ▁A ▁. ▁length ▁( ▁) ▁; ▁int ▁inf ▁= ▁1000000 ▁; ▁int ▁[ ▁] ▁[ ▁] ▁next ▁= ▁new ▁int ▁[ ▁26 ▁] ▁[ ▁sizeOf B ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁26 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁sizeOf B ▁; ▁j ▁++ ▁) ▁{ ▁next ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁inf ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁sizeOf B ▁; ▁i ▁++ ▁) ▁{ ▁next ▁[ ▁B ▁. ▁charAt ▁( ▁i ▁) ▁- ▁' ▁a ▁' ▁] ▁[ ▁i ▁] ▁= ▁i ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁26 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁sizeOf B ▁- ▁2 ▁; ▁j ▁>= ▁0 ▁; ▁j ▁-- ▁) ▁{ ▁if ▁( ▁next ▁[ ▁i ▁] ▁[ ▁j ▁] ▁== ▁inf ▁) ▁{ ▁next ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁next ▁[ ▁i ▁] ▁[ ▁j ▁+ ▁1 ▁] ▁; ▁} ▁} ▁} ▁int ▁pos ▁= ▁0 ▁; ▁int ▁i ▁= ▁0 ▁; ▁while ▁( ▁i ▁< ▁sizeOf A ▁) ▁{ ▁if ▁( ▁pos ▁== ▁0 ▁&& ▁next ▁[ ▁A ▁. ▁charAt ▁( ▁i ▁) ▁- ▁' ▁a ▁' ▁] ▁[ ▁pos ▁] ▁== ▁inf ▁) ▁{ ▁numberOf Sub sequences ▁= ▁- ▁1 ▁; ▁break ▁; ▁} ▁else ▁if ▁( ▁pos ▁< ▁sizeOf B ▁&& ▁next ▁[ ▁A ▁. ▁charAt ▁( ▁i ▁) ▁- ▁' ▁a ▁' ▁] ▁[ ▁pos ▁] ▁< ▁inf ▁) ▁{ ▁int ▁nextIndex ▁= ▁next ▁[ ▁A ▁. ▁charAt ▁( ▁i ▁) ▁- ▁' ▁a ▁' ▁] ▁[ ▁pos ▁] ▁+ ▁1 ▁; ▁pos ▁= ▁nextIndex ▁; ▁i ▁++ ▁; ▁} ▁else ▁{ ▁numberOf Sub sequences ▁++ ▁; ▁pos ▁= ▁0 ▁; ▁} ▁} ▁return ▁numberOf Sub sequences ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁A ▁= ▁" ▁a ac be ▁" ▁; ▁String ▁B ▁= ▁" ▁ace ab ▁" ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁find Minimum Sub sequences ▁( ▁A ▁, ▁B ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁public ▁static ▁int ▁count _ minimum _ operations ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁2 ▁) ▁{ ▁return ▁1 ▁; ▁} ▁else ▁if ▁( ▁n ▁== ▁1 ▁) ▁{ ▁return ▁0 ▁; ▁} ▁if ▁( ▁n ▁% ▁3 ▁== ▁0 ▁) ▁{ ▁return ▁1 ▁+ ▁count _ minimum _ operations ▁( ▁n ▁/ ▁3 ▁) ▁; ▁} ▁else ▁if ▁( ▁n ▁% ▁3 ▁== ▁1 ▁) ▁{ ▁return ▁1 ▁+ ▁count _ minimum _ operations ▁( ▁n ▁- ▁1 ▁) ▁; ▁} ▁else ▁{ ▁return ▁1 ▁+ ▁count _ minimum _ operations ▁( ▁n ▁+ ▁1 ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁n ▁= ▁4 ▁; ▁int ▁ans ▁= ▁count _ minimum _ operations ▁( ▁n ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁ans ▁) ▁; ▁} ▁}
▁class ▁G fg ▁{ ▁public ▁static ▁int ▁problems Left ▁( ▁int ▁K ▁, ▁int ▁P ▁, ▁int ▁N ▁) ▁{ ▁if ▁( ▁K ▁<= ▁P ▁) ▁return ▁0 ▁; ▁else ▁return ▁( ▁( ▁K ▁- ▁P ▁) ▁* ▁N ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁args ▁[ ▁] ▁) ▁{ ▁int ▁K ▁, ▁P ▁, ▁N ▁; ▁K ▁= ▁4 ▁; ▁P ▁= ▁1 ▁; ▁N ▁= ▁10 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁problems Left ▁( ▁K ▁, ▁P ▁, ▁N ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁V ▁= ▁5 ▁; ▁static ▁int ▁[ ▁] ▁parent ▁= ▁new ▁int ▁[ ▁V ▁] ▁; ▁static ▁int ▁INF ▁= ▁Integer ▁. ▁MAX _ VALUE ▁; ▁static ▁int ▁find ▁( ▁int ▁i ▁) ▁{ ▁while ▁( ▁parent ▁[ ▁i ▁] ▁!= ▁i ▁) ▁i ▁= ▁parent ▁[ ▁i ▁] ▁; ▁return ▁i ▁; ▁} ▁static ▁void ▁union 1 ▁( ▁int ▁i ▁, ▁int ▁j ▁) ▁{ ▁int ▁a ▁= ▁find ▁( ▁i ▁) ▁; ▁int ▁b ▁= ▁find ▁( ▁j ▁) ▁; ▁parent ▁[ ▁a ▁] ▁= ▁b ▁; ▁} ▁static ▁void ▁k r us k al M ST ▁( ▁int ▁cost ▁[ ▁] ▁[ ▁] ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁V ▁; ▁i ▁++ ▁) ▁parent ▁[ ▁i ▁] ▁= ▁i ▁; ▁int ▁edge _ count ▁= ▁0 ▁; ▁while ▁( ▁edge _ count ▁< ▁V ▁- ▁1 ▁) ▁{ ▁int ▁min ▁= ▁INF ▁, ▁a ▁= ▁- ▁1 ▁, ▁b ▁= ▁- ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁V ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁V ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁find ▁( ▁i ▁) ▁!= ▁find ▁( ▁j ▁) ▁&& ▁cost ▁[ ▁i ▁] ▁[ ▁j ▁] ▁< ▁min ▁) ▁{ ▁min ▁= ▁cost ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁a ▁= ▁i ▁; ▁b ▁= ▁j ▁; ▁} ▁} ▁} ▁union 1 ▁( ▁a ▁, ▁b ▁) ▁; ▁System ▁. ▁out ▁. ▁printf ▁( ▁" Edge ▁% d :( % d , ▁% d ) ▁cost :% d ▁NEW _ LINE ", ▁edge _ count ++, ▁a , ▁b , ▁min ); ▁min cost ▁+= ▁min ▁; ▁} ▁System ▁. ▁out ▁. ▁printf ▁( ▁" ▁Minimum ▁cost ▁= ▁% ▁d ▁", ▁min cost ); ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁cost ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁INF ▁, ▁2 ▁, ▁INF ▁, ▁6 ▁, ▁INF ▁} ▁, ▁{ ▁2 ▁, ▁INF ▁, ▁3 ▁, ▁8 ▁, ▁5 ▁} ▁, ▁{ ▁INF ▁, ▁3 ▁, ▁INF ▁, ▁INF ▁, ▁7 ▁} ▁, ▁{ ▁6 ▁, ▁8 ▁, ▁INF ▁, ▁INF ▁, ▁9 ▁} ▁, ▁{ ▁INF ▁, ▁5 ▁, ▁7 ▁, ▁9 ▁, ▁INF ▁} ▁, ▁} ▁; ▁k r us k
▁class ▁G F G ▁{ ▁static ▁int ▁find Min Cost ▁( ▁int ▁[ ▁] ▁[ ▁] ▁arr ▁, ▁int ▁X ▁, ▁int ▁n ▁, ▁int ▁i ▁) ▁{ ▁if ▁( ▁X ▁<= ▁0 ▁) ▁return ▁0 ▁; ▁if ▁( ▁i ▁>= ▁n ▁) ▁return ▁Integer ▁. ▁MAX _ VALUE ▁; ▁int ▁inc ▁= ▁find Min Cost ▁( ▁arr ▁, ▁X ▁- ▁arr ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁, ▁n ▁, ▁i ▁+ ▁1 ▁) ▁; ▁if ▁( ▁inc ▁!= ▁Integer ▁. ▁MAX _ VALUE ▁) ▁inc ▁+= ▁arr ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁; ▁int ▁exc ▁= ▁find Min Cost ▁( ▁arr ▁, ▁X ▁, ▁n ▁, ▁i ▁+ ▁1 ▁) ▁; ▁return ▁Math ▁. ▁min ▁( ▁inc ▁, ▁exc ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁[ ▁] ▁arr ▁= ▁{ ▁{ ▁4 ▁, ▁3 ▁} ▁, ▁{ ▁3 ▁, ▁2 ▁} ▁, ▁{ ▁2 ▁, ▁4 ▁} ▁, ▁{ ▁1 ▁, ▁3 ▁} ▁, ▁{ ▁4 ▁, ▁2 ▁} ▁} ▁; ▁int ▁X ▁= ▁7 ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁int ▁ans ▁= ▁find Min Cost ▁( ▁arr ▁, ▁X ▁, ▁n ▁, ▁0 ▁) ▁; ▁if ▁( ▁ans ▁!= ▁Integer ▁. ▁MAX _ VALUE ▁) ▁System ▁. ▁out ▁. ▁println ▁( ▁ans ▁) ▁; ▁else ▁System ▁. ▁out ▁. ▁println ▁( ▁- ▁1 ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁Map ▁< ▁String ▁, ▁Integer ▁> ▁dp ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁static ▁int ▁max Score ▁( ▁String ▁s ▁, ▁int ▁[ ▁] ▁a ▁) ▁{ ▁if ▁( ▁dp ▁. ▁containsKey ▁( ▁s ▁) ▁) ▁return ▁dp ▁. ▁get ▁( ▁s ▁) ▁; ▁int ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁if ▁( ▁n ▁== ▁0 ▁) ▁return ▁0 ▁; ▁if ▁( ▁n ▁== ▁1 ▁) ▁return ▁a ▁[ ▁0 ▁] ▁; ▁int ▁head ▁= ▁0 ▁; ▁int ▁mx ▁= ▁- ▁1 ▁; ▁while ▁( ▁head ▁< ▁n ▁) ▁{ ▁int ▁tail ▁= ▁head ▁; ▁while ▁( ▁tail ▁< ▁n ▁) ▁{ ▁if ▁( ▁s ▁. ▁charAt ▁( ▁tail ▁) ▁!= ▁s ▁. ▁charAt ▁( ▁head ▁) ▁) ▁{ ▁head ▁= ▁tail ▁; ▁break ▁; ▁} ▁String ▁sub ▁= ▁s ▁. ▁substring ▁( ▁head ▁, ▁tail ▁+ ▁1 ▁) ▁; ▁mx ▁= ▁Math ▁. ▁max ▁( ▁mx ▁, ▁a ▁[ ▁sub ▁. ▁length ▁( ▁) ▁- ▁1 ▁] ▁+ ▁max Score ▁( ▁s ▁. ▁substring ▁( ▁0 ▁, ▁head ▁) ▁+ ▁s ▁. ▁substring ▁( ▁tail ▁+ ▁1 ▁, ▁s ▁. ▁length ▁( ▁) ▁) ▁, ▁a ▁) ▁) ▁; ▁tail ▁+= ▁1 ▁; ▁} ▁if ▁( ▁tail ▁== ▁n ▁) ▁break ▁; ▁} ▁dp ▁. ▁put ▁( ▁s ▁, ▁mx ▁) ▁; ▁return ▁mx ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁String ▁s ▁= ▁" ▁ab b ▁" ▁; ▁int ▁[ ▁] ▁a ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁1 ▁} ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁( ▁max Score ▁( ▁s ▁, ▁a ▁) ▁) ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁k ad ane ▁( ▁Vector ▁< ▁Integer ▁> ▁v ▁) ▁{ ▁int ▁curr Sum ▁= ▁0 ▁; ▁int ▁max Sum ▁= ▁Integer ▁. ▁MIN _ VALUE ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁( ▁int ▁) ▁v ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁curr Sum ▁+= ▁v ▁. ▁get ▁( ▁i ▁) ▁; ▁if ▁( ▁curr Sum ▁> ▁max Sum ▁) ▁{ ▁max Sum ▁= ▁curr Sum ▁; ▁} ▁if ▁( ▁curr Sum ▁< ▁0 ▁) ▁{ ▁curr Sum ▁= ▁0 ▁; ▁} ▁} ▁return ▁max Sum ▁; ▁} ▁static ▁void ▁max Sub matrix Sum ▁( ▁int ▁[ ▁] ▁[ ▁] ▁A ▁) ▁{ ▁int ▁r ▁= ▁A ▁. ▁length ▁; ▁int ▁c ▁= ▁A ▁[ ▁0 ▁] ▁. ▁length ▁; ▁int ▁[ ▁] ▁[ ▁] ▁prefix ▁= ▁new ▁int ▁[ ▁r ▁] ▁[ ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁r ▁; ▁i ▁++ ▁) ▁{ ▁prefix ▁[ ▁i ▁] ▁= ▁new ▁int ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁c ▁; ▁j ▁++ ▁) ▁{ ▁prefix ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁0 ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁r ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁c ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁j ▁== ▁0 ▁) ▁prefix ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁A ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁else ▁prefix ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁A ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+ ▁prefix ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁; ▁} ▁} ▁int ▁max Sum ▁= ▁Integer ▁. ▁MIN _ VALUE ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁c ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁< ▁c ▁; ▁j ▁++ ▁) ▁{ ▁Vector ▁< ▁Integer ▁> ▁v ▁= ▁new ▁Vector ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁k ▁= ▁0 ▁; ▁k ▁< ▁r ▁; ▁k ▁++ ▁) ▁{ ▁int ▁el ▁= ▁0 ▁; ▁if ▁( ▁i ▁== ▁0 ▁) ▁el ▁= ▁prefix ▁[ ▁k ▁] ▁[ ▁j ▁] ▁; ▁else ▁el ▁= ▁prefix ▁[ ▁k ▁] ▁[ ▁j ▁] ▁- ▁prefix ▁[ ▁k ▁] ▁[ ▁i ▁- ▁1 ▁] ▁; ▁v ▁.
▁import ▁java ▁. ▁io ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁void ▁number of pairs ▁( ▁int ▁[ ▁] ▁[ ▁] ▁v ▁, ▁int ▁k ▁) ▁{ ▁int ▁n ▁= ▁v ▁. ▁length ▁; ▁if ▁( ▁n ▁% ▁2 ▁== ▁1 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁0 ▁) ▁; ▁return ▁; ▁} ▁int ▁ans ▁= ▁0 ▁; ▁int ▁dp ▁[ ▁] ▁[ ▁] ▁= ▁new ▁int ▁[ ▁k ▁] ▁[ ▁2 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁k ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁2 ▁; ▁j ▁++ ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁0 ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁( ▁i ▁+ ▁j ▁) ▁% ▁2 ▁== ▁0 ▁) ▁dp ▁[ ▁v ▁[ ▁i ▁] ▁[ ▁j ▁] ▁- ▁1 ▁] ▁[ ▁0 ▁] ▁++ ▁; ▁else ▁dp ▁[ ▁v ▁[ ▁i ▁] ▁[ ▁j ▁] ▁- ▁1 ▁] ▁[ ▁1 ▁] ▁++ ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁k ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁k ▁; ▁j ▁++ ▁) ▁{ ▁ans ▁+= ▁dp ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁* ▁dp ▁[ ▁j ▁] ▁[ ▁1 ▁] ▁; ▁ans ▁+= ▁dp ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁* ▁dp ▁[ ▁j ▁] ▁[ ▁0 ▁] ▁; ▁} ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁ans ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁[ ▁] ▁[ ▁] ▁mat ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁} ▁, ▁{ ▁3 ▁, ▁4 ▁} ▁} ▁; ▁int ▁K ▁= ▁4 ▁; ▁number of pairs ▁( ▁mat ▁, ▁K ▁) ▁; ▁} ▁}
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁__ g cd ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁return ▁b ▁== ▁0 ▁? ▁a ▁: ▁__ g cd ▁( ▁b ▁, ▁a ▁% ▁b ▁) ▁; ▁} ▁static ▁int ▁find Max G CD ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁high ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁high ▁= ▁Math ▁. ▁max ▁( ▁high ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁int ▁[ ▁] ▁count ▁= ▁new ▁int ▁[ ▁high ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁count ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁+= ▁1 ▁; ▁} ▁int ▁counter ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁high ▁; ▁i ▁> ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁int ▁j ▁= ▁i ▁; ▁while ▁( ▁j ▁<= ▁high ▁) ▁{ ▁if ▁( ▁count ▁[ ▁j ▁] ▁> ▁0 ▁) ▁counter ▁+= ▁count ▁[ ▁j ▁] ▁; ▁j ▁+= ▁i ▁; ▁if ▁( ▁counter ▁== ▁2 ▁) ▁return ▁i ▁; ▁} ▁counter ▁= ▁0 ▁; ▁} ▁return ▁0 ▁; ▁} ▁static ▁int ▁maxlen ▁( ▁int ▁i ▁, ▁int ▁j ▁, ▁int ▁arr ▁[ ▁] ▁, ▁int ▁arr 1 ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁max g cd ▁) ▁{ ▁int ▁a ▁= ▁1 ▁; ▁if ▁( ▁i ▁>= ▁N ▁j ▁>= ▁N ▁) ▁return ▁0 ▁; ▁if ▁( ▁__ g cd ▁( ▁arr ▁[ ▁i ▁] ▁, ▁arr 1 ▁[ ▁j ▁] ▁) ▁== ▁max g cd ▁&& ▁arr ▁[ ▁i ▁] ▁!= ▁arr 1 ▁[ ▁j ▁] ▁) ▁{ ▁a ▁= ▁Math ▁. ▁max ▁( ▁a ▁, ▁1 ▁+ ▁maxlen ▁( ▁i ▁, ▁j ▁+ ▁1 ▁, ▁arr ▁, ▁arr 1 ▁, ▁N ▁, ▁max g cd ▁) ▁) ▁; ▁return ▁a ▁; ▁} ▁return ▁Math ▁. ▁max ▁( ▁maxlen ▁( ▁i ▁+ ▁1 ▁, ▁j ▁, ▁arr ▁, ▁arr 1 ▁, ▁N ▁, ▁max g cd ▁) ▁, ▁maxlen ▁( ▁i ▁, ▁j ▁+ ▁1 ▁, ▁arr ▁, ▁arr 1 ▁, ▁N ▁, ▁max g cd ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁8 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁int ▁arr 1 ▁[
▁import ▁java ▁. ▁util ▁. ▁* ▁; ▁class ▁G F G ▁{ ▁static ▁int ▁find W ays ▁( ▁int ▁N ▁, ▁int ▁dp ▁[ ▁] ▁) ▁{ ▁if ▁( ▁N ▁== ▁0 ▁) ▁{ ▁return ▁1 ▁; ▁} ▁if ▁( ▁dp ▁[ ▁N ▁] ▁!= ▁- ▁1 ▁) ▁{ ▁return ▁dp ▁[ ▁N ▁] ▁; ▁} ▁int ▁cnt ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁6 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁N ▁- ▁i ▁>= ▁0 ▁) ▁{ ▁cnt ▁= ▁cnt ▁+ ▁find W ays ▁( ▁N ▁- ▁i ▁, ▁dp ▁) ▁; ▁} ▁} ▁return ▁dp ▁[ ▁N ▁] ▁= ▁cnt ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁4 ▁; ▁int ▁[ ▁] ▁dp ▁= ▁new ▁int ▁[ ▁N ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁dp ▁. ▁length ▁; ▁i ▁++ ▁) ▁dp ▁[ ▁i ▁] ▁= ▁- ▁1 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁find W ays ▁( ▁N ▁, ▁dp ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁min Days ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁< ▁1 ▁) ▁return ▁n ▁; ▁int ▁cnt ▁= ▁1 ▁+ ▁Math ▁. ▁min ▁( ▁n ▁% ▁2 ▁+ ▁min Days ▁( ▁n ▁/ ▁2 ▁) ▁, ▁n ▁% ▁3 ▁+ ▁min Days ▁( ▁n ▁/ ▁3 ▁) ▁) ▁; ▁return ▁cnt ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁6 ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁min Days ▁( ▁N ▁) ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁public ▁static ▁void ▁count Num s ▁( ▁int ▁N ▁) ▁{ ▁int ▁dp ▁[ ▁] ▁[ ▁] ▁= ▁new ▁int ▁[ ▁N ▁] ▁[ ▁16 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁9 ▁; ▁i ▁++ ▁) ▁dp ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁10 ▁; ▁j ▁++ ▁) ▁{ ▁for ▁( ▁int ▁k ▁= ▁0 ▁; ▁k ▁< ▁16 ▁; ▁k ▁++ ▁) ▁{ ▁int ▁xor ▁= ▁j ▁^ ▁k ▁; ▁dp ▁[ ▁i ▁] ▁[ ▁xor ▁] ▁+= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁k ▁] ▁; ▁} ▁} ▁} ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁10 ▁; ▁i ▁++ ▁) ▁count ▁+= ▁dp ▁[ ▁N ▁- ▁1 ▁] ▁[ ▁i ▁] ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁count ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁N ▁= ▁1 ▁; ▁count Num s ▁( ▁N ▁) ▁; ▁} ▁}
▁class ▁G F G ▁{ ▁static ▁int ▁count ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁M ▁, ▁int ▁N ▁) ▁{ ▁int ▁cnt ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁M ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁i ▁% ▁a ▁[ ▁j ▁] ▁== ▁0 ▁) ▁{ ▁cnt ▁++ ▁; ▁break ▁; ▁} ▁} ▁} ▁return ▁cnt ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁5 ▁, ▁7 ▁} ▁; ▁int ▁m ▁= ▁100 ▁; ▁int ▁n ▁= ▁arr ▁. ▁length ▁; ▁System ▁. ▁out ▁. ▁print ▁( ▁count ▁( ▁arr ▁, ▁m ▁, ▁n ▁) ▁) ▁; ▁} ▁}
