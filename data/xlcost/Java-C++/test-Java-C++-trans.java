Find maximum of minimum for every window size in a given array 1057 | class Test { static int arr [ ] = { 10 , 20 , 30 , 50 , 10 , 70 , 30 } ; static void print@@ Max@@ Of@@ Min ( int n ) { for ( int k = 1 ; k <= n ; k ++ ) { int max@@ Of@@ Min = Integer . MIN_VALUE ; for ( int i = 0 ; i <= n - k ; i ++ ) { int min = arr [ i ] ; for ( int j = 1 ; j < k ; j ++ ) { if ( arr [ i + j ] < min ) min = arr [ i + j ] ; } if ( min > max@@ Of@@ Min ) max@@ Of@@ Min = min ; } System . out . print ( max@@ Of@@ Min + " ▁ " ) ; } } public static void main ( String [ ] args ) { print@@ Max@@ Of@@ Min ( arr . length ) ; } }
Find maximum of minimum for every window size in a given array 1058 | import java . util . Stack ; class Test { static int arr [ ] = { 10 , 20 , 30 , 50 , 10 , 70 , 30 } ; static void print@@ Max@@ Of@@ Min ( int n ) { Stack < Integer > s = new Stack < > ( ) ; int left [ ] = new int [ n + 1 ] ; int right [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { left [ i ] = - 1 ; right [ i ] = n ; } for ( int i = 0 ; i < n ; i ++ ) { while ( ! s . empty ( ) && arr [ s . peek ( ) ] >= arr [ i ] ) s . pop ( ) ; if ( ! s . empty ( ) ) left [ i ] = s . peek ( ) ; s . push ( i ) ; } while ( ! s . empty ( ) ) s . pop ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { while ( ! s . empty ( ) && arr [ s . peek ( ) ] >= arr [ i ] ) s . pop ( ) ; if ( ! s . empty ( ) ) right [ i ] = s . peek ( ) ; s . push ( i ) ; } int ans [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) ans [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int len = right [ i ] - left [ i ] - 1 ; ans [ len ] = Math . max ( ans [ len ] , arr [ i ] ) ; } for ( int i = n - 1 ; i >= 1 ; i -- ) ans [ i ] = Math . max ( ans [ i ] , ans [ i + 1 ] ) ; for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( ans [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { print@@ Max@@ Of@@ Min ( arr . length ) ; } }
Sum of all elements between k1 ' th ▁ and ▁ k@@ 2' th smallest elements 1134 | import java . util . Arrays ; class GF@@ G { static int sum@@ Between@@ Two@@ K@@ th ( int arr [ ] , int k1 , int k2 ) { Arrays . sort ( arr ) ; int result = 0 ; for ( int i = k1 ; i < k2 - 1 ; i ++ ) result += arr [ i ] ; return result ; } public static void main ( String [ ] args ) { int arr [ ] = { 20 , 8 , 22 , 4 , 12 , 10 , 14 } ; int k1 = 3 , k2 = 6 ; int n = arr . length ; System . out . print ( sum@@ Between@@ Two@@ K@@ th ( arr , k1 , k2 ) ) ; } }
Check if removing an edge can divide a Binary Tree in two hal@@ ves 118 | class Node { int key ; Node left , right ; public Node ( int key ) { this . key = key ; left = right = null ; } } class Res { boolean res = false ; } class Binary@@ Tree { Node root ; int count ( Node node ) { if ( node == null ) return 0 ; return count ( node . left ) + count ( node . right ) + 1 ; } int check@@ Rec ( Node root , int n , Res res ) { if ( root == null ) return 0 ; int c = check@@ Rec ( root . left , n , res ) + 1 + check@@ Rec ( root . right , n , res ) ; if ( c == n - c ) res . res = true ; return c ; } boolean check ( Node root ) { int n = count ( root ) ; Res res = new Res ( ) ; check@@ Rec ( root , n , res ) ; return res . res ; } public static void main ( String [ ] args ) { Binary@@ Tree tree = new Binary@@ Tree ( ) ; tree . root = new Node ( 5 ) ; tree . root . left = new Node ( 1 ) ; tree . root . right = new Node ( 6 ) ; tree . root . left . left = new Node ( 3 ) ; tree . root . right . left = new Node ( 7 ) ; tree . root . right . right = new Node ( 4 ) ; if ( tree . check ( tree . root ) == true ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
Given an array of pairs , find all symmetric pairs in it 1225 | import java . util . HashMap ; class Symmetric@@ Pairs { static void find@@ Sym@@ Pairs ( int arr [ ] [ ] ) { HashMap < Integer , Integer > h@@ M = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { int first = arr [ i ] [ 0 ] ; int sec = arr [ i ] [ 1 ] ; Integer val = h@@ M . get ( sec ) ; if ( val != null && val == first ) System . out . println ( " ( " + sec + " , ▁ " + first + " ) " ) ; else h@@ M . put ( first , sec ) ; } } public static void main ( String arg [ ] ) { int arr [ ] [ ] = new int [ 5 ] [ 2 ] ; arr [ 0 ] [ 0 ] = 11 ; arr [ 0 ] [ 1 ] = 20 ; arr [ 1 ] [ 0 ] = 30 ; arr [ 1 ] [ 1 ] = 40 ; arr [ 2 ] [ 0 ] = 5 ; arr [ 2 ] [ 1 ] = 10 ; arr [ 3 ] [ 0 ] = 40 ; arr [ 3 ] [ 1 ] = 30 ; arr [ 4 ] [ 0 ] = 10 ; arr [ 4 ] [ 1 ] = 5 ; find@@ Sym@@ Pairs ( arr ) ; } }
Count items common to both the lists but with different prices 1255 | class GF@@ G { static class item { String name ; int price ; public item ( String name , int price ) { this . name = name ; this . price = price ; } } ; static int count@@ Items ( item list1 [ ] , int m , item list2 [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( ( list1 [ i ] . name . compareTo ( list2 [ j ] . name ) == 0 ) && ( list1 [ i ] . price != list2 [ j ] . price ) ) count ++ ; return count ; } public static void main ( String [ ] args ) { item list1 [ ] = { new item ( " apple " , 60 ) , new item ( " brea@@ d " , 20 ) , new item ( " whe@@ at " , 50 ) , new item ( " o@@ il " , 30 ) } ; item list2 [ ] = { new item ( " mil@@ k " , 20 ) , new item ( " brea@@ d " , 15 ) , new item ( " whe@@ at " , 40 ) , new item ( " apple " , 60 ) } ; int m = list1 . length ; int n = list2 . length ; System . out . print ( " Count ▁ = ▁ " + count@@ Items ( list1 , m , list2 , n ) ) ; } }
Number of sub@@ arrays having sum exactly equal to k 1283 | import java . util . HashMap ; import java . util . Map ; public class Gf@@ G { static int find@@ Sub@@ array@@ Sum ( int arr [ ] , int n , int sum ) { HashMap < Integer , Integer > prev@@ Sum = new HashMap < > ( ) ; int res = 0 ; int curr@@ sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr@@ sum += arr [ i ] ; if ( curr@@ sum == sum ) res ++ ; if ( prev@@ Sum . containsKey ( curr@@ sum - sum ) ) res += prev@@ Sum . get ( curr@@ sum - sum ) ; Integer count = prev@@ Sum . get ( curr@@ sum ) ; if ( count == null ) prev@@ Sum . put ( curr@@ sum , 1 ) ; else prev@@ Sum . put ( curr@@ sum , count + 1 ) ; } return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 2 , - 2 , - 20 , 10 } ; int sum = - 10 ; int n = arr . length ; System . out . println ( find@@ Sub@@ array@@ Sum ( arr , n , sum ) ) ; } }
Count of index pairs with equal elements in an array 1387 | class GF@@ G { static int count@@ Pairs ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] == arr [ j ] ) ans ++ ; return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 2 } ; int n = arr . length ; System . out . println ( count@@ Pairs ( arr , n ) ) ; } }
Print all root to leaf paths with there relative positions 142 | import java . util . ArrayList ; class Graph { static final int MAX_@@ PATH@@ _SIZE = 1000 ; static class Node { char data ; Node left , right ; } ; static Node newNode ( char data ) { Node temp = new Node ( ) ; temp . data = data ; temp . left = temp . right = null ; return temp ; } static class PATH { int H@@ d ; char key ; public PATH ( int H@@ d , char key ) { this . H@@ d = H@@ d ; this . key = key ; } public PATH ( ) { } } ; static void print@@ Path ( ArrayList < PATH > path , int size ) { int minimum_@@ H@@ d = Integer . MAX_VALUE ; PATH p ; for ( int it = 0 ; it < size ; it ++ ) { p = path . get ( it ) ; minimum_@@ H@@ d = Math . min ( minimum_@@ H@@ d , p . H@@ d ) ; } for ( int it = 0 ; it < size ; it ++ ) { p = path . get ( it ) ; int noOf@@ Under@@ Scores = Math . abs ( p . H@@ d - minimum_@@ H@@ d ) ; for ( int i = 0 ; i < noOf@@ Under@@ Scores ; i ++ ) System . out . print ( " _ " ) ; System . out . println ( p . key ) ; } System . out . println ( " = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = " ) ; } static void print@@ All@@ Path@@ s@@ Util ( Node root , ArrayList < PATH > All@@ Path , int HD , int order ) { if ( root == null ) return ; if ( root . left == null && root . right == null ) { All@@ Path . set ( order , new PATH ( HD , root . data ) ) ; print@@ Path ( All@@ Path , order + 1 ) ; return ; } All@@ Path . set ( order , new PATH ( HD , root . data ) ) ; print@@ All@@ Path@@ s@@ Util ( root . left , All@@ Path , HD - 1 , order + 1 ) ; print@@ All@@ Path@@ s@@ Util ( root . right , All@@ Path , HD + 1 , order + 1 ) ; } static void print@@ All@@ Paths ( Node root ) { if ( root == null ) return ; ArrayList < PATH > All@@ paths = new ArrayList < > ( ) ; for ( int i = 0 ; i < MAX_@@ PATH@@ _SIZE ; i ++ ) { All@@ paths . add ( new PATH ( ) ) ; } print@@ All@@ Path@@ s@@ Util ( root , All@@ paths , 0 , 0 ) ; } public static void main ( String [ ] args ) { Node root = newNode ( ' A ' ) ; root . left = newNode ( ' B ' ) ; root . right = newNode ( ' C ' ) ; root . left . left = newNode ( ' D ' ) ; root . left . right = newNode ( ' E ' ) ; root . right . left = newNode ( ' F ' ) ; root . right . right = newNode ( ' G ' ) ; print@@ All@@ Paths ( root ) ; } }
Find the minimum element in a sorted and rotated array 1448 | import java . util . * ; import java . lang . * ; class GF@@ G { public static int find@@ Min ( int arr [ ] , int low , int high ) { while ( low < high ) { int mid = low + ( high - low ) / 2 ; if ( arr [ mid ] == arr [ high ] ) high -- ; else if ( arr [ mid ] > arr [ high ] ) low = mid + 1 ; else high = mid ; } return arr [ high ] ; } public static void main ( String args [ ] ) { int ar@@ r1 [ ] = { 5 , 6 , 1 , 2 , 3 , 4 } ; int n1 = ar@@ r1 . length ; System . out . println ( " The ▁ minimum ▁ element ▁ is ▁ " + find@@ Min ( ar@@ r1 , 0 , n1 - 1 ) ) ; int ar@@ r2 [ ] = { 1 , 2 , 3 , 4 } ; int n2 = ar@@ r2 . length ; System . out . println ( " The ▁ minimum ▁ element ▁ is ▁ " + find@@ Min ( ar@@ r2 , 0 , n2 - 1 ) ) ; int arr@@ 3 [ ] = { 1 } ; int n3 = arr@@ 3 . length ; System . out . println ( " The ▁ minimum ▁ element ▁ is ▁ " + find@@ Min ( arr@@ 3 , 0 , n3 - 1 ) ) ; int arr@@ 4 [ ] = { 1 , 2 } ; int n@@ 4 = arr@@ 4 . length ; System . out . println ( " The ▁ minimum ▁ element ▁ is ▁ " + find@@ Min ( arr@@ 4 , 0 , n@@ 4 - 1 ) ) ; int arr@@ 5 [ ] = { 2 , 1 } ; int n@@ 5 = arr@@ 5 . length ; System . out . println ( " The ▁ minimum ▁ element ▁ is ▁ " + find@@ Min ( arr@@ 5 , 0 , n@@ 5 - 1 ) ) ; int arr@@ 6 [ ] = { 5 , 6 , 7 , 1 , 2 , 3 , 4 } ; int n@@ 6 = arr@@ 6 . length ; System . out . println ( " The ▁ minimum ▁ element ▁ is ▁ " + find@@ Min ( arr@@ 6 , 0 , n@@ 6 - 1 ) ) ; int arr@@ 7 [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int n@@ 7 = arr@@ 7 . length ; System . out . println ( " The ▁ minimum ▁ element ▁ is ▁ " + find@@ Min ( arr@@ 7 , 0 , n@@ 7 - 1 ) ) ; int arr@@ 8 [ ] = { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 1 } ; int n@@ 8 = arr@@ 8 . length ; System . out . println ( " The ▁ minimum ▁ element ▁ is ▁ " + find@@ Min ( arr@@ 8 , 0 , n@@ 8 - 1 ) ) ; int arr@@ 9 [ ] = { 3 , 4 , 5 , 1 , 2 } ; int n@@ 9 = arr@@ 9 . length ; System . out . println ( " The ▁ minimum ▁ element ▁ is ▁ " + find@@ Min ( arr@@ 9 , 0 , n@@ 9 - 1 ) ) ; } }
Re@@ arrange positive and negative numbers using in@@ built sort function 1472 | import java . io . * ; class GF@@ G { static void print@@ Array ( int [ ] array , int length ) { System . out . print ( " [ " ) ; for ( int i = 0 ; i < length ; i ++ ) { System . out . print ( array [ i ] ) ; if ( i < ( length - 1 ) ) System . out . print ( " , " ) ; else System . out . print ( "@@ ]@@ NEW_@@ LINE@@ "@@ )@@ ; } } static void reverse ( int [ ] array , int start , int end ) { while ( start < end ) { int temp = array [ start ] ; array [ start ] = array [ end ] ; array [ end ] = temp ; start ++ ; end -- ; } } static void re@@ arrange ( int [ ] array , int start , int end ) { if ( start == end ) return ; re@@ arrange ( array , ( start + 1 ) , end ) ; if ( array [ start ] >= 0 ) { reverse ( array , ( start + 1 ) , end ) ; reverse ( array , start , end ) ; } } public static void main ( String [ ] args ) { int [ ] array = { - 12 , - 11 , - 13 , - 5 , - 6 , 7 , 5 , 3 , 6 } ; int length = array . length ; int count@@ Negative = 0 ; for ( int i = 0 ; i < length ; i ++ ) { if ( array [ i ] < 0 ) count@@ Negative ++ ; } System . out . print ( " array : ▁ " ) ; print@@ Array ( array , length ) ; re@@ arrange ( array , 0 , ( length - 1 ) ) ; reverse ( array , count@@ Negative , ( length - 1 ) ) ; System . out . print ( " re@@ arrange@@ d ▁ array : ▁ " ) ; print@@ Array ( array , length ) ; } }
Positive elements at even and negative at odd positions ( Relative order not maintained ) 1494 | import java . io . * ; class GF@@ G { static void re@@ arrange ( int a [ ] , int size ) { int positive = 0 , negative = 1 , temp ; while ( true ) { while ( positive < size && a [ positive ] >= 0 ) positive += 2 ; while ( negative < size && a [ negative ] <= 0 ) negative += 2 ; if ( positive < size && negative < size ) { temp = a [ positive ] ; a [ positive ] = a [ negative ] ; a [ negative ] = temp ; } else break ; } } public static void main ( String args [ ] ) { int arr [ ] = { 1 , - 3 , 5 , 6 , - 3 , 6 , 7 , - 4 , 9 , 10 } ; int n = arr . length ; re@@ arrange ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
Find the largest three distinct elements in an array 1513 | import java . io . * ; import java . util . Arrays ; class GF@@ G { void find@@ 3@@ largest ( int [ ] arr ) { Arrays . sort ( arr ) ; int n = arr . length ; int check = 0 , count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( count < 4 ) { if ( check != arr [ n - i ] ) { System . out . print ( arr [ n - i ] + " ▁ " ) ; check = arr [ n - i ] ; count ++ ; } } else break ; } } public static void main ( String [ ] args ) { GF@@ G obj = new GF@@ G ( ) ; int [ ] arr = { 12 , 45 , 1 , - 1 , 45 , 54 , 23 , 5 , 0 , - 10 } ; obj . find@@ 3@@ largest ( arr ) ; } }
Find the smallest and second smallest elements in an array 1534 | import java . io . * ; class Second@@ S@@ malle@@ st { static void print@@ 2@@ S@@ malle@@ st ( int arr [ ] ) { int first , second , arr_@@ size = arr . length ; if ( arr_@@ size < 2 ) { System . out . println ( " ▁ Invalid ▁ Input ▁ " ) ; return ; } first = second = Integer . MAX_VALUE ; for ( int i = 0 ; i < arr_@@ size ; i ++ ) { if ( arr [ i ] < first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] < second && arr [ i ] != first ) second = arr [ i ] ; } if ( second == Integer . MAX_VALUE ) System . out . println ( " There ▁ is ▁ no ▁ second " + " smallest ▁ element " ) ; else System . out . println ( " The ▁ smallest ▁ element ▁ is ▁ " + first + " ▁ and ▁ second ▁ S@@ malle@@ st " + " ▁ element ▁ is ▁ " + second ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 12 , 13 , 1 , 10 , 34 , 1 } ; print@@ 2@@ S@@ malle@@ st ( arr ) ; } }
Find the smallest missing number 1535 | class S@@ malle@@ st@@ Missing { int find@@ First@@ Missing ( int array [ ] , int start , int end ) { if ( start > end ) return end + 1 ; if ( start != array [ start ] ) return start ; int mid = ( start + end ) / 2 ; if ( array [ mid ] == mid ) return find@@ First@@ Missing ( array , mid + 1 , end ) ; return find@@ First@@ Missing ( array , start , mid ) ; } public static void main ( String [ ] args ) { S@@ malle@@ st@@ Missing small = new S@@ malle@@ st@@ Missing ( ) ; int arr [ ] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 10 } ; int n = arr . length ; System . out . println ( " First ▁ Missing ▁ element ▁ is ▁ : ▁ " + small . find@@ First@@ Missing ( arr , 0 , n - 1 ) ) ; } }
Range LC@@ M Queries 1552 | class GF@@ G { static final int MAX = 1000 ; static int tree [ ] = new int [ 4 * MAX ] ; static int arr [ ] = new int [ MAX ] ; static int gcd ( int a , int b ) { if ( a == 0 ) { return b ; } return gcd ( b % a , a ) ; } static int l@@ cm ( int a , int b ) { return a * b / gcd ( a , b ) ; } static void build ( int node , int start , int end ) { if ( start == end ) { tree [ node ] = arr [ start ] ; return ; } int mid = ( start + end ) / 2 ; build ( 2 * node , start , mid ) ; build ( 2 * node + 1 , mid + 1 , end ) ; int left_@@ l@@ cm = tree [ 2 * node ] ; int right_@@ l@@ cm = tree [ 2 * node + 1 ] ; tree [ node ] = l@@ cm ( left_@@ l@@ cm , right_@@ l@@ cm ) ; } static int query ( int node , int start , int end , int l , int r ) { if ( end < l start > r ) { return 1 ; } if ( l <= start && r >= end ) { return tree [ node ] ; } int mid = ( start + end ) / 2 ; int left_@@ l@@ cm = query ( 2 * node , start , mid , l , r ) ; int right_@@ l@@ cm = query ( 2 * node + 1 , mid + 1 , end , l , r ) ; return l@@ cm ( left_@@ l@@ cm , right_@@ l@@ cm ) ; } public static void main ( String [ ] args ) { arr [ 0 ] = 5 ; arr [ 1 ] = 7 ; arr [ 2 ] = 5 ; arr [ 3 ] = 2 ; arr [ 4 ] = 10 ; arr [ 5 ] = 12 ; arr [ 6 ] = 11 ; arr [ 7 ] = 17 ; arr [ 8 ] = 14 ; arr [ 9 ] = 1 ; arr [ 10 ] = 44 ; build ( 1 , 0 , 10 ) ; System . out . println ( query ( 1 , 0 , 10 , 2 , 5 ) ) ; System . out . println ( query ( 1 , 0 , 10 , 5 , 10 ) ) ; System . out . println ( query ( 1 , 0 , 10 , 0 , 10 ) ) ; } }
Queries for counts of array elements with values in given range 1557 | import java . io . * ; import java . util . Arrays ; class GF@@ G { static int lower@@ Index ( int arr [ ] , int n , int x ) { int l = 0 , h = n - 1 ; while ( l <= h ) { int mid = ( l + h ) / 2 ; if ( arr [ mid ] >= x ) h = mid - 1 ; else l = mid + 1 ; } return l ; } static int upper@@ Index ( int arr [ ] , int n , int y ) { int l = 0 , h = n - 1 ; while ( l <= h ) { int mid = ( l + h ) / 2 ; if ( arr [ mid ] <= y ) l = mid + 1 ; else h = mid - 1 ; } return h ; } static int count@@ InRange ( int arr [ ] , int n , int x , int y ) { int count = 0 ; count = upper@@ Index ( arr , n , y ) - lower@@ Index ( arr , n , x ) + 1 ; return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 4 , 4 , 9 , 10 , 3 } ; int n = arr . length ; Arrays . sort ( arr ) ; int i = 1 , j = 4 ; System . out . println ( count@@ InRange ( arr , n , i , j ) ) ; ; i = 9 ; j = 12 ; System . out . println ( count@@ InRange ( arr , n , i , j ) ) ; } }
Array range queries over range queries 1562 | import java . util . * ; class GF@@ G { static void type1 ( int [ ] arr , int start , int limit ) { for ( int i = start ; i <= limit ; i ++ ) arr [ i ] ++ ; } static void type2 ( int [ ] arr , int [ ] [ ] query , int start , int limit ) { for ( int i = start ; i <= limit ; i ++ ) { if ( query [ i ] [ 0 ] == 1 ) type1 ( arr , query [ i ] [ 1 ] , query [ i ] [ 2 ] ) ; else if ( query [ i ] [ 0 ] == 2 ) type2 ( arr , query , query [ i ] [ 1 ] , query [ i ] [ 2 ] ) ; } } public static void main ( String [ ] args ) { int n = 5 , m = 5 ; int [ ] arr = new int [ n + 1 ] ; int [ ] temp = { 1 , 1 , 2 , 1 , 4 , 5 , 2 , 1 , 2 , 2 , 1 , 3 , 2 , 3 , 4 } ; int [ ] [ ] query = new int [ 6 ] [ 4 ] ; int j = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { query [ i ] [ 0 ] = temp [ j ++ ] ; query [ i ] [ 1 ] = temp [ j ++ ] ; query [ i ] [ 2 ] = temp [ j ++ ] ; } for ( int i = 1 ; i <= m ; i ++ ) if ( query [ i ] [ 0 ] == 1 ) type1 ( arr , query [ i ] [ 1 ] , query [ i ] [ 2 ] ) ; else if ( query [ i ] [ 0 ] == 2 ) type2 ( arr , query , query [ i ] [ 1 ] , query [ i ] [ 2 ] ) ; for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; System . out . println ( ) ; } }
Sort an array in wave form 1608 | import java . util . * ; class Sort@@ Wave { void swap ( int arr [ ] , int a , int b ) { int temp = arr [ a ] ; arr [ a ] = arr [ b ] ; arr [ b ] = temp ; } void sort@@ In@@ Wave ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i += 2 ) swap ( arr , i , i + 1 ) ; } public static void main ( String args [ ] ) { Sort@@ Wave ob = new Sort@@ Wave ( ) ; int arr [ ] = { 10 , 90 , 49 , 2 , 1 , 5 , 23 } ; int n = arr . length ; ob . sort@@ In@@ Wave ( arr , n ) ; for ( int i : arr ) System . out . print ( i + " ▁ " ) ; } }
Merge an array of size n into another array of size m + n 1610 | class Merge@@ Arrays { void moveTo@@ End ( int m@@ Plus@@ N [ ] , int size ) { int i , j = size - 1 ; for ( i = size - 1 ; i >= 0 ; i -- ) { if ( m@@ Plus@@ N [ i ] != - 1 ) { m@@ Plus@@ N [ j ] = m@@ Plus@@ N [ i ] ; j -- ; } } } void merge ( int m@@ Plus@@ N [ ] , int N [ ] , int m , int n ) { int i = n ; int j = 0 ; int k = 0 ; while ( k < ( m + n ) ) { if ( ( i < ( m + n ) && m@@ Plus@@ N [ i ] <= N [ j ] ) || ( j == n ) ) { m@@ Plus@@ N [ k ] = m@@ Plus@@ N [ i ] ; k ++ ; i ++ ; } else { m@@ Plus@@ N [ k ] = N [ j ] ; k ++ ; j ++ ; } } } void print@@ Array ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; System . out . println ( " " ) ; } public static void main ( String [ ] args ) { Merge@@ Arrays merge@@ array = new Merge@@ Arrays ( ) ; int m@@ Plus@@ N [ ] = { 2 , 8 , - 1 , - 1 , - 1 , 13 , - 1 , 15 , 20 } ; int N [ ] = { 5 , 7 , 9 , 25 } ; int n = N . length ; int m = m@@ Plus@@ N . length - n ; merge@@ array . moveTo@@ End ( m@@ Plus@@ N , m + n ) ; merge@@ array . merge ( m@@ Plus@@ N , N , m , n ) ; merge@@ array . print@@ Array ( m@@ Plus@@ N , m + n ) ; } }
Count In@@ versions in an array | Set 1 ( Using Merge Sort ) 1614 | class Test { static int arr [ ] = new int [ ] { 1 , 20 , 6 , 4 , 5 } ; static int getIn@@ v@@ Count ( int n ) { int inv_@@ count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) inv_@@ count ++ ; return inv_@@ count ; } public static void main ( String [ ] args ) { System . out . println ( " Number ▁ of ▁ in@@ versions ▁ are ▁ " + getIn@@ v@@ Count ( arr . length ) ) ; } }
Two elements whose sum is closest to zero 1616 | import java . util . * ; import java . lang . * ; class Main { static void min@@ Abs@@ Sum@@ Pair ( int arr [ ] , int arr_@@ size ) { int inv_@@ count = 0 ; int l , r , min_@@ sum , sum , min_@@ l , min_@@ r ; if ( arr_@@ size < 2 ) { System . out . println ( " Invalid ▁ Input " ) ; return ; } min_@@ l = 0 ; min_@@ r = 1 ; min_@@ sum = arr [ 0 ] + arr [ 1 ] ; for ( l = 0 ; l < arr_@@ size - 1 ; l ++ ) { for ( r = l + 1 ; r < arr_@@ size ; r ++ ) { sum = arr [ l ] + arr [ r ] ; if ( Math . abs ( min_@@ sum ) > Math . abs ( sum ) ) { min_@@ sum = sum ; min_@@ l = l ; min_@@ r = r ; } } } System . out . println ( " ▁ The ▁ two ▁ elements ▁ whose ▁ " + " sum ▁ is ▁ minimum ▁ are ▁ " + arr [ min_@@ l ] + " ▁ and ▁ " + arr [ min_@@ r ] ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 60 , - 10 , 70 , - 80 , 85 } ; min@@ Abs@@ Sum@@ Pair ( arr , 6 ) ; } }
Sort an array of 0 s , 1 s and 2 s 1634 | import java . io . * ; class count@@ z@@ ot { static void sort@@ 012 ( int a [ ] , int arr_@@ size ) { int lo = 0 ; int hi = arr_@@ size - 1 ; int mid = 0 , temp = 0 ; while ( mid <= hi ) { switch ( a [ mid ] ) { case 0 : { temp = a [ lo ] ; a [ lo ] = a [ mid ] ; a [ mid ] = temp ; lo ++ ; mid ++ ; break ; } case 1 : mid ++ ; break ; case 2 : { temp = a [ mid ] ; a [ mid ] = a [ hi ] ; a [ hi ] = temp ; hi -- ; break ; } } } } static void print@@ Array ( int arr [ ] , int arr_@@ size ) { int i ; for ( i = 0 ; i < arr_@@ size ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; System . out . println ( " " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 0 , 1 , 1 , 0 , 1 , 2 , 1 , 2 , 0 , 0 , 0 , 1 } ; int arr_@@ size = arr . length ; sort@@ 012 ( arr , arr_@@ size ) ; System . out . println ( " Array ▁ after ▁ seg@@ greg@@ ation ▁ " ) ; print@@ Array ( arr , arr_@@ size ) ; } }
Find the Minimum length Un@@ sorted Sub@@ array , sorting which makes the complete array sorted 1636 | class Main { static void print@@ Un@@ sorted ( int arr [ ] , int n ) { int s = 0 , e = n - 1 , i , max , min ; for ( s = 0 ; s < n - 1 ; s ++ ) { if ( arr [ s ] > arr [ s + 1 ] ) break ; } if ( s == n - 1 ) { System . out . println ( " The ▁ complete ▁ array ▁ is ▁ sorted " ) ; return ; } for ( e = n - 1 ; e > 0 ; e -- ) { if ( arr [ e ] < arr [ e - 1 ] ) break ; } max = arr [ s ] ; min = arr [ s ] ; for ( i = s + 1 ; i <= e ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; if ( arr [ i ] < min ) min = arr [ i ] ; } for ( i = 0 ; i < s ; i ++ ) { if ( arr [ i ] > min ) { s = i ; break ; } } for ( i = n - 1 ; i >= e + 1 ; i -- ) { if ( arr [ i ] < max ) { e = i ; break ; } } System . out . println ( " ▁ The ▁ un@@ sorted ▁ sub@@ array ▁ which " + " ▁ makes ▁ the ▁ given ▁ array ▁ sorted ▁ lies " + " ▁ between ▁ the ▁ indices ▁ " + s + " ▁ and ▁ " + e ) ; return ; } public static void main ( String args [ ] ) { int arr [ ] = { 10 , 12 , 20 , 30 , 25 , 40 , 32 , 31 , 35 , 50 , 60 } ; int arr_@@ size = arr . length ; print@@ Un@@ sorted ( arr , arr_@@ size ) ; } }
Search , insert and delete in an un@@ sorted array 1656 | class Main { static int findElement ( int arr [ ] , int n , int key ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == key ) return i ; return - 1 ; } public static void main ( String args [ ] ) { int arr [ ] = { 12 , 34 , 10 , 6 , 40 } ; int n = arr . length ; int key = 40 ; int position = findElement ( arr , n , key ) ; if ( position == - 1 ) System . out . println ( " Element ▁ not ▁ found " ) ; else System . out . println ( " Element ▁ Found ▁ at ▁ Position : ▁ " + ( position + 1 ) ) ; } }
Search , insert and delete in a sorted array 1659 | class Main { static int binary@@ Search ( int arr [ ] , int low , int high , int key ) { if ( high < low ) return - 1 ; int mid = ( low + high ) / 2 ; if ( key == arr [ mid ] ) return mid ; if ( key > arr [ mid ] ) return binary@@ Search ( arr , ( mid + 1 ) , high , key ) ; return binary@@ Search ( arr , low , ( mid - 1 ) , key ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 6 , 7 , 8 , 9 , 10 } ; int n , key ; n = arr . length - 1 ; key = 10 ; System . out . println ( " Index : ▁ " + binary@@ Search ( arr , 0 , n , key ) ) ; } }
Equi@@ lib@@ ri@@ um index of an array 1683 | class Equi@@ lib@@ ri@@ um@@ Index { int equi@@ lib@@ ri@@ um ( int arr [ ] , int n ) { int sum = 0 ; int left@@ sum = 0 ; for ( int i = 0 ; i < n ; ++ i ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; ++ i ) { sum -= arr [ i ] ; if ( left@@ sum == sum ) return i ; left@@ sum += arr [ i ] ; } return - 1 ; } public static void main ( String [ ] args ) { Equi@@ lib@@ ri@@ um@@ Index equ@@ i = new Equi@@ lib@@ ri@@ um@@ Index ( ) ; int arr [ ] = { - 7 , 1 , 5 , 2 , - 4 , 3 , 0 } ; int arr_@@ size = arr . length ; System . out . println ( " First ▁ equi@@ lib@@ ri@@ um ▁ index ▁ is ▁ " + equ@@ i . equi@@ lib@@ ri@@ um ( arr , arr_@@ size ) ) ; } }
Ceil@@ ing in a sorted array 1688 | class Main { static int ceil@@ Search ( int arr [ ] , int low , int high , int x ) { int mid ; if ( x <= arr [ low ] ) return low ; if ( x > arr [ high ] ) return - 1 ; mid = ( low + high ) / 2 ; if ( arr [ mid ] == x ) return mid ; else if ( arr [ mid ] < x ) { if ( mid + 1 <= high && x <= arr [ mid + 1 ] ) return mid + 1 ; else return ceil@@ Search ( arr , mid + 1 , high , x ) ; } else { if ( mid - 1 >= low && x > arr [ mid - 1 ] ) return mid ; else return ceil@@ Search ( arr , low , mid - 1 , x ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 8 , 10 , 10 , 12 , 19 } ; int n = arr . length ; int x = 8 ; int index = ceil@@ Search ( arr , 0 , n - 1 , x ) ; if ( index == - 1 ) System . out . println ( " Ceil@@ ing ▁ of ▁ " + x + " ▁ doesn ' t ▁ exist ▁ in ▁ array " ) ; else System . out . println ( " ceiling ▁ of ▁ " + x + " ▁ is ▁ " + arr [ index ] ) ; } }
Sum of heights of all individual nodes in a binary tree 168 | class Gf@@ G { static class Node { int data ; Node left ; Node right ; } static int getHeight ( Node Node ) { if ( Node == null ) return 0 ; else { int l@@ Height = getHeight ( Node . left ) ; int r@@ Height = getHeight ( Node . right ) ; if ( l@@ Height > r@@ Height ) return ( l@@ Height + 1 ) ; else return ( r@@ Height + 1 ) ; } } static Node newNode ( int data ) { Node Node = new Node ( ) ; Node . data = data ; Node . left = null ; Node . right = null ; return ( Node ) ; } static int getTotal@@ Height ( Node root ) { if ( root == null ) return 0 ; return getTotal@@ Height ( root . left ) + getHeight ( root ) + getTotal@@ Height ( root . right ) ; } public static void main ( String [ ] args ) { Node root = newNode ( 1 ) ; root . left = newNode ( 2 ) ; root . right = newNode ( 3 ) ; root . left . left = newNode ( 4 ) ; root . left . right = newNode ( 5 ) ; System . out . println ( " Sum ▁ of ▁ heights ▁ of ▁ all ▁ Nodes ▁ = ▁ " + getTotal@@ Height ( root ) ) ; } }
Maj@@ ority Element 1693 | import java . io . * ; import java . util . * ; class GF@@ G { public static int maj@@ ority@@ Element ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; int count = 1 , max_@@ ele = - 1 , temp = arr [ 0 ] , ele = 0 , f = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( temp == arr [ i ] ) { count ++ ; } else { count = 1 ; temp = arr [ i ] ; } if ( max_@@ ele < count ) { max_@@ ele = count ; ele = arr [ i ] ; if ( max_@@ ele > ( n / 2 ) ) { f = 1 ; break ; } } } return ( f == 1 ? ele : - 1 ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 2 , 1 , 3 , 5 , 1 } ; int n = 7 ; System . out . println ( maj@@ ority@@ Element ( arr , n ) ) ; } }
Check for Maj@@ ority Element in a sorted array 1694 | import java . io . * ; class Maj@@ ority { static boolean is@@ Maj@@ ority ( int arr [ ] , int n , int x ) { int i , last_@@ index = 0 ; last_@@ index = ( n % 2 == 0 ) ? n / 2 : n / 2 + 1 ; for ( i = 0 ; i < last_@@ index ; i ++ ) { if ( arr [ i ] == x && arr [ i + n / 2 ] == x ) return true ; } return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 4 , 4 , 4 } ; int n = arr . length ; int x = 4 ; if ( is@@ Maj@@ ority ( arr , n , x ) == true ) System . out . println ( x + " ▁ appears ▁ more ▁ than ▁ " + n / 2 + " ▁ times ▁ in ▁ arr [ ] " ) ; else System . out . println ( x + " ▁ does ▁ not ▁ appear ▁ more ▁ than ▁ " + n / 2 + " ▁ times ▁ in ▁ arr [ ] " ) ; } }
Check for Maj@@ ority Element in a sorted array 169 | class GF@@ G { static class Node { int data ; Node left ; Node right ; } ; static int sum ; static Node newNode ( int data ) { Node Node = new Node ( ) ; Node . data = data ; Node . left = null ; Node . right = null ; return ( Node ) ; } static int getTotal@@ Height@@ Util ( Node root ) { if ( root == null ) { return 0 ; } int lh = getTotal@@ Height@@ Util ( root . left ) ; int rh = getTotal@@ Height@@ Util ( root . right ) ; int h = Math . max ( lh , rh ) + 1 ; sum = sum + h ; return h ; } static int getTotal@@ Height ( Node root ) { sum = 0 ; getTotal@@ Height@@ Util ( root ) ; return sum ; } public static void main ( String [ ] args ) { Node root = newNode ( 1 ) ; root . left = newNode ( 2 ) ; root . right = newNode ( 3 ) ; root . left . left = newNode ( 4 ) ; root . left . right = newNode ( 5 ) ; System . out . printf ( " Sum ▁ of ▁ heights ▁ of ▁ all ▁ Nodes ▁ = ▁ % d " , getTotal@@ Height ( root ) ) ; } }
Ste@@ pping Numbers 364 | import java . util . * ; class Main { public static void b@@ fs ( int n , int m , int num ) { Queue < Integer > q = new LinkedList < Integer > ( ) ; q . add ( num ) ; while ( ! q . isEmpty ( ) ) { int step@@ Num = q . poll ( ) ; if ( step@@ Num <= m && step@@ Num >= n ) { System . out . print ( step@@ Num + " ▁ " ) ; } if ( step@@ Num == 0 step@@ Num > m ) continue ; int last@@ Digit = step@@ Num % 10 ; int step@@ Num@@ A = step@@ Num * 10 + ( last@@ Digit - 1 ) ; int step@@ Num@@ B = step@@ Num * 10 + ( last@@ Digit + 1 ) ; if ( last@@ Digit == 0 ) q . add ( step@@ Num@@ B ) ; else if ( last@@ Digit == 9 ) q . add ( step@@ Num@@ A ) ; else { q . add ( step@@ Num@@ A ) ; q . add ( step@@ Num@@ B ) ; } } } public static void display@@ Ste@@ pping@@ Numbers ( int n , int m ) { for ( int i = 0 ; i <= 9 ; i ++ ) b@@ fs ( n , m , i ) ; } public static void main ( String args [ ] ) { int n = 0 , m = 21 ; display@@ Ste@@ pping@@ Numbers ( n , m ) ; } }
Level order traversal line by line | Set 3 ( Using One Queue ) 37 | import java . util . LinkedList ; import java . util . Queue ; public class GF@@ G { static class Node { int data ; Node left ; Node right ; Node ( int data ) { this . data = data ; left = null ; right = null ; } } static void level@@ Order ( Node root ) { if ( root == null ) return ; Queue < Node > q = new LinkedList < > ( ) ; q . add ( root ) ; q . add ( null ) ; while ( ! q . isEmpty ( ) ) { Node curr = q . poll ( ) ; if ( curr == null ) { if ( ! q . isEmpty ( ) ) { q . add ( null ) ; System . out . println ( ) ; } } else { if ( curr . left != null ) q . add ( curr . left ) ; if ( curr . right != null ) q . add ( curr . right ) ; System . out . print ( curr . data + " ▁ " ) ; } } } public static void main ( String [ ] args ) { Node root = new Node ( 1 ) ; root . left = new Node ( 2 ) ; root . right = new Node ( 3 ) ; root . left . left = new Node ( 4 ) ; root . left . right = new Node ( 5 ) ; root . right . right = new Node ( 6 ) ; level@@ Order ( root ) ; } }
Word L@@ adder ( Length of shortest chain to reach a target word ) 447 | import java . util . * ; class GF@@ G { static int shor@@ test@@ Chain@@ Len ( String start , String target , Set < String > D ) { if ( start == target ) return 0 ; if ( ! D . contains ( target ) ) return 0 ; int level = 0 , word@@ length = start . length ( ) ; Queue < String > Q = new LinkedList < > ( ) ; Q . add ( start ) ; while ( ! Q . isEmpty ( ) ) { ++ level ; int size@@ of@@ Q = Q . size ( ) ; for ( int i = 0 ; i < size@@ of@@ Q ; ++ i ) { char [ ] word = Q . peek ( ) . toCharArray ( ) ; Q . remove ( ) ; for ( int pos = 0 ; pos < word@@ length ; ++ pos ) { char orig_@@ char = word [ pos ] ; for ( char c = ' a ' ; c <= ' z ' ; ++ c ) { word [ pos ] = c ; if ( String . valueOf ( word ) . equals ( target ) ) return level + 1 ; if ( ! D . contains ( String . valueOf ( word ) ) ) continue ; D . remove ( String . valueOf ( word ) ) ; Q . add ( String . valueOf ( word ) ) ; } word [ pos ] = orig_@@ char ; } } } return 0 ; } public static void main ( String [ ] args ) { Set < String > D = new HashSet < String > ( ) ; D . add ( " po@@ on " ) ; D . add ( " p@@ lee " ) ; D . add ( " same " ) ; D . add ( " po@@ ie " ) ; D . add ( " p@@ lie " ) ; D . add ( " po@@ in " ) ; D . add ( " ple@@ a " ) ; String start = " to@@ on " ; String target = " ple@@ a " ; System . out . print ( " Length ▁ of ▁ shortest ▁ chain ▁ is : ▁ " + shor@@ test@@ Chain@@ Len ( start , target , D ) ) ; } }
Swap K@@ th node from beginning with K@@ th node from end in a Linked List 605 | class Node { int data ; Node next ; Node ( int d ) { data = d ; next = null ; } } class LinkedList { Node head ; void push ( int new_data ) { Node new_node = new Node ( new_data ) ; new_node . next = head ; head = new_node ; } void print@@ List ( ) { Node node = head ; while ( node != null ) { System . out . print ( node . data + " ▁ " ) ; node = node . next ; } System . out . println ( " " ) ; } int count@@ Nodes ( ) { int count = 0 ; Node s = head ; while ( s != null ) { count ++ ; s = s . next ; } return count ; } void swap@@ K@@ th ( int k ) { int n = count@@ Nodes ( ) ; if ( n < k ) return ; if ( 2 * k - 1 == n ) return ; Node x = head ; Node x_@@ prev = null ; for ( int i = 1 ; i < k ; i ++ ) { x_@@ prev = x ; x = x . next ; } Node y = head ; Node y_@@ prev = null ; for ( int i = 1 ; i < n - k + 1 ; i ++ ) { y_@@ prev = y ; y = y . next ; } if ( x_@@ prev != null ) x_@@ prev . next = y ; if ( y_@@ prev != null ) y_@@ prev . next = x ; Node temp = x . next ; x . next = y . next ; y . next = temp ; if ( k == 1 ) head = y ; if ( k == n ) head = x ; } public static void main ( String [ ] args ) { LinkedList l@@ list = new LinkedList ( ) ; for ( int i = 8 ; i >= 1 ; i -- ) l@@ list . push ( i ) ; System . out . print ( " Original ▁ linked ▁ list : ▁ " ) ; l@@ list . print@@ List ( ) ; System . out . println ( " " ) ; for ( int i = 1 ; i < 9 ; i ++ ) { l@@ list . swap@@ K@@ th ( i ) ; System . out . println ( " Modified ▁ List ▁ for ▁ k ▁ = ▁ " + i ) ; l@@ list . print@@ List ( ) ; System . out . println ( " " ) ; } } }
Count trip@@ lets in a sorted dou@@ bly linked list whose sum is equal to a given value x 612 | import java . util . * ; class GF@@ G { static class Node { int data ; Node next , prev ; } ; static int count@@ Pairs ( Node first , Node second , int value ) { int count = 0 ; while ( first != null && second != null && first != second && second . next != first ) { if ( ( first . data + second . data ) == value ) { count ++ ; first = first . next ; second = second . prev ; } else if ( ( first . data + second . data ) > value ) second = second . prev ; else first = first . next ; } return count ; } static int count@@ Trip@@ lets ( Node head , int x ) { if ( head == null ) return 0 ; Node current , first , last ; int count = 0 ; last = head ; while ( last . next != null ) last = last . next ; for ( current = head ; current != null ; current = current . next ) { first = current . next ; count += count@@ Pairs ( first , last , x - current . data ) ; } return count ; } static Node insert ( Node head , int data ) { Node temp = new Node ( ) ; temp . data = data ; temp . next = temp . prev = null ; if ( ( head ) == null ) ( head ) = temp ; else { temp . next = head ; ( head ) . prev = temp ; ( head ) = temp ; } return head ; } public static void main ( String [ ] args ) { Node head = null ; head = insert ( head , 9 ) ; head = insert ( head , 8 ) ; head = insert ( head , 6 ) ; head = insert ( head , 5 ) ; head = insert ( head , 4 ) ; head = insert ( head , 2 ) ; head = insert ( head , 1 ) ; int x = 17 ; System . out . print ( " Count ▁ = ▁ " + count@@ Trip@@ lets ( head , x ) ) ; } }
Ar@@ range con@@ son@@ ants and vo@@ w@@ els nodes in a linked list 647 | class Gf@@ G { static class Node { char data ; Node next ; } static Node newNode ( char key ) { Node temp = new Node ( ) ; temp . data = key ; temp . next = null ; return temp ; } static void print@@ list ( Node head ) { if ( head == null ) { System . out . println ( " Empty ▁ List " ) ; return ; } while ( head != null ) { System . out . print ( head . data + " ▁ " ) ; if ( head . next != null ) System . out . print ( " - > ▁ " ) ; head = head . next ; } System . out . println ( ) ; } static boolean is@@ Vo@@ wel ( char x ) { return ( x == ' a ' x == ' e ' x == ' i ' x == ' o ' x == ' u ' ) ; } static Node arrange ( Node head ) { Node new@@ Head = head ; Node latest@@ Vo@@ wel ; Node curr = head ; if ( head == null ) return null ; if ( is@@ Vo@@ wel ( head . data ) == true ) latest@@ Vo@@ wel = head ; else { while ( curr . next != null && ! is@@ Vo@@ wel ( curr . next . data ) ) curr = curr . next ; if ( curr . next == null ) return head ; latest@@ Vo@@ wel = new@@ Head = curr . next ; curr . next = curr . next . next ; latest@@ Vo@@ wel . next = head ; } while ( curr != null && curr . next != null ) { if ( is@@ Vo@@ wel ( curr . next . data ) == true ) { if ( curr == latest@@ Vo@@ wel ) { latest@@ Vo@@ wel = curr = curr . next ; } else { Node temp = latest@@ Vo@@ wel . next ; latest@@ Vo@@ wel . next = curr . next ; latest@@ Vo@@ wel = latest@@ Vo@@ wel . next ; curr . next = curr . next . next ; latest@@ Vo@@ wel . next = temp ; } } else { curr = curr . next ; } } return new@@ Head ; } public static void main ( String [ ] args ) { Node head = newNode ( ' a ' ) ; head . next = newNode ( ' b ' ) ; head . next . next = newNode ( ' c ' ) ; head . next . next . next = newNode ( ' e ' ) ; head . next . next . next . next = newNode ( ' d ' ) ; head . next . next . next . next . next = newNode ( ' o ' ) ; head . next . next . next . next . next . next = newNode ( ' x ' ) ; head . next . next . next . next . next . next . next = newNode ( ' i ' ) ; System . out . println ( " Linked ▁ list ▁ before ▁ : ▁ " ) ; print@@ list ( head ) ; head = arrange ( head ) ; System . out . println ( " Linked ▁ list ▁ after ▁ : " ) ; print@@ list ( head ) ; } }
Find k 688 | import java . io . * ; class Node { int data ; Node left , right ; Node ( int x ) { data = x ; left = right = null ; } } class GF@@ G { static int count = 0 ; public static Node insert ( Node root , int x ) { if ( root == null ) return new Node ( x ) ; if ( x < root . data ) root . left = insert ( root . left , x ) ; else if ( x > root . data ) root . right = insert ( root . right , x ) ; return root ; } public static Node k@@ th@@ S@@ malle@@ st ( Node root , int k ) { if ( root == null ) return null ; Node left = k@@ th@@ S@@ malle@@ st ( root . left , k ) ; if ( left != null ) return left ; count ++ ; if ( count == k ) return root ; return k@@ th@@ S@@ malle@@ st ( root . right , k ) ; } public static void print@@ K@@ th@@ S@@ malle@@ st ( Node root , int k ) { count = 0 ; Node res = k@@ th@@ S@@ malle@@ st ( root , k ) ; if ( res == null ) System . out . println ( " There ▁ are ▁ less ▁ " + " than ▁ k ▁ nodes ▁ in ▁ the ▁ B@@ ST " ) ; else System . out . println ( " K - th ▁ S@@ malle@@ st " + " ▁ Element ▁ is ▁ " + res . data ) ; } public static void main ( String [ ] args ) { Node root = null ; int keys [ ] = { 20 , 8 , 22 , 4 , 12 , 10 , 14 } ; for ( int x : keys ) root = insert ( root , x ) ; int k = 3 ; print@@ K@@ th@@ S@@ malle@@ st ( root , k ) ; } }
Shor@@ test distance between two nodes in B@@ ST 704 | class Gf@@ G { static class Node { Node left , right ; int key ; } static Node newNode ( int key ) { Node ptr = new Node ( ) ; ptr . key = key ; ptr . left = null ; ptr . right = null ; return ptr ; } static Node insert ( Node root , int key ) { if ( root == null ) root = newNode ( key ) ; else if ( root . key > key ) root . left = insert ( root . left , key ) ; else if ( root . key < key ) root . right = insert ( root . right , key ) ; return root ; } static int distance@@ From@@ Root ( Node root , int x ) { if ( root . key == x ) return 0 ; else if ( root . key > x ) return 1 + distance@@ From@@ Root ( root . left , x ) ; return 1 + distance@@ From@@ Root ( root . right , x ) ; } static int distance@@ Between@@ 2 ( Node root , int a , int b ) { if ( root == null ) return 0 ; if ( root . key > a && root . key > b ) return distance@@ Between@@ 2 ( root . left , a , b ) ; if ( root . key < a && root . key < b ) return distance@@ Between@@ 2 ( root . right , a , b ) ; if ( root . key >= a && root . key <= b ) return distance@@ From@@ Root ( root , a ) + distance@@ From@@ Root ( root , b ) ; return 0 ; } static int find@@ Dist@@ Wrapper ( Node root , int a , int b ) { int temp = 0 ; if ( a > b ) { temp = a ; a = b ; b = temp ; } return distance@@ Between@@ 2 ( root , a , b ) ; } public static void main ( String [ ] args ) { Node root = null ; root = insert ( root , 20 ) ; insert ( root , 10 ) ; insert ( root , 5 ) ; insert ( root , 15 ) ; insert ( root , 30 ) ; insert ( root , 25 ) ; insert ( root , 35 ) ; System . out . println ( find@@ Dist@@ Wrapper ( root , 5 , 35 ) ) ; } }
Count B@@ ST sub@@ trees that lie in given range 711 | class Gf@@ G { static class node { int data ; node left , right ; } ; static class INT { int a ; } static boolean in@@ Range ( node root , int low , int high ) { return root . data >= low && root . data <= high ; } static boolean get@@ Count@@ Util ( node root , int low , int high , INT count ) { if ( root == null ) return true ; boolean l = get@@ Count@@ Util ( root . left , low , high , count ) ; boolean r = get@@ Count@@ Util ( root . right , low , high , count ) ; if ( l && r && in@@ Range ( root , low , high ) ) { ++ count . a ; return true ; } return false ; } static INT getCount ( node root , int low , int high ) { INT count = new INT ( ) ; count . a = 0 ; get@@ Count@@ Util ( root , low , high , count ) ; return count ; } static node newNode ( int data ) { node temp = new node ( ) ; temp . data = data ; temp . left = temp . right = null ; return ( temp ) ; } public static void main ( String args [ ] ) { node root = newNode ( 10 ) ; root . left = newNode ( 5 ) ; root . right = newNode ( 50 ) ; root . left . left = newNode ( 1 ) ; root . right . left = newNode ( 40 ) ; root . right . right = newNode ( 100 ) ; int l = 5 ; int h = 45 ; System . out . println ( " Count ▁ of ▁ sub@@ trees ▁ in ▁ [ " + l + " , ▁ " + h + " ] ▁ is ▁ " + getCount ( root , l , h ) . a ) ; } }
Sorted order printing of a given array that represents a B@@ ST 747 | class GF@@ G { private static void print@@ Sorted ( int [ ] arr , int start , int end ) { if ( start > end ) return ; print@@ Sorted ( arr , start * 2 + 1 , end ) ; System . out . print ( arr [ start ] + " ▁ " ) ; print@@ Sorted ( arr , start * 2 + 2 , end ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 2 , 5 , 1 , 3 } ; print@@ Sorted ( arr , 0 , arr . length - 1 ) ; } }
Minimum operations required to make each row and column of matrix equals 823 | import java . io . * ; class GF@@ G { static int find@@ Min@@ Op@@ ear@@ tion ( int matrix [ ] [ ] , int n ) { int [ ] sum@@ Row = new int [ n ] ; int [ ] sum@@ Col = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { sum@@ Row [ i ] += matrix [ i ] [ j ] ; sum@@ Col [ j ] += matrix [ i ] [ j ] ; } int max@@ Sum = 0 ; for ( int i = 0 ; i < n ; ++ i ) { max@@ Sum = Math . max ( max@@ Sum , sum@@ Row [ i ] ) ; max@@ Sum = Math . max ( max@@ Sum , sum@@ Col [ i ] ) ; } int count = 0 ; for ( int i = 0 , j = 0 ; i < n && j < n ; ) { int diff = Math . min ( max@@ Sum - sum@@ Row [ i ] , max@@ Sum - sum@@ Col [ j ] ) ; matrix [ i ] [ j ] += diff ; sum@@ Row [ i ] += diff ; sum@@ Col [ j ] += diff ; count += diff ; if ( sum@@ Row [ i ] == max@@ Sum ) ++ i ; if ( sum@@ Col [ j ] == max@@ Sum ) ++ j ; } return count ; } static void print@@ Matrix ( int matrix [ ] [ ] , int n ) { for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) System . out . print ( matrix [ i ] [ j ] + " ▁ " ) ; System . out . println ( ) ; } } public static void main ( String [ ] args ) { int matrix [ ] [ ] = { { 1 , 2 } , { 3 , 4 } } ; System . out . println ( find@@ Min@@ Op@@ ear@@ tion ( matrix , 2 ) ) ; print@@ Matrix ( matrix , 2 ) ; } }
Search in a row wise and column wise sorted matrix 848 | class GF@@ G { private static void search ( int [ ] [ ] mat , int n , int x ) { int i = 0 , j = n - 1 ; while ( i < n && j >= 0 ) { if ( mat [ i ] [ j ] == x ) { System . out . print ( " n ▁ Found ▁ at ▁ " + i + " ▁ " + j ) ; return ; } if ( mat [ i ] [ j ] > x ) j -- ; else i ++ ; } System . out . print ( " n ▁ Element ▁ not ▁ found " ) ; return ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 10 , 20 , 30 , 40 } , { 15 , 25 , 35 , 45 } , { 27 , 29 , 37 , 48 } , { 32 , 33 , 39 , 50 } } ; search ( mat , 4 , 29 ) ; } }
Check if sums of i 859 | public class GF@@ G { static boolean are@@ Sum@@ Same ( int a [ ] [ ] , int n , int m ) { int sum@@ 1 = 0 , sum@@ 2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum@@ 1 = 0 ; sum@@ 2 = 0 ; for ( int j = 0 ; j < m ; j ++ ) { sum@@ 1 += a [ i ] [ j ] ; sum@@ 2 += a [ j ] [ i ] ; } if ( sum@@ 1 == sum@@ 2 ) return true ; } return false ; } public static void main ( String args [ ] ) { int n = 4 ; int m = 4 ; int M [ ] [ ] = { { 1 , 2 , 3 , 4 } , { 9 , 5 , 3 , 1 } , { 0 , 3 , 5 , 6 } , { 0 , 4 , 5 , 6 } } ; if ( are@@ Sum@@ Same ( M , n , m ) == true ) System . out . print ( "1@@ NEW_@@ LINE@@ "@@ )@@ ; else System . out . print ( "@@ 0@@ NEW_@@ LINE@@ "@@ )@@ ; } }
Minimum operations required to set all elements of binary matrix 884 | class GF@@ G { static final int N = 5 ; static final int M = 5 ; static int min@@ Operation ( boolean arr [ ] [ ] ) { int ans = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = M - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] [ j ] == false ) { ans ++ ; for ( int k = 0 ; k <= i ; k ++ ) { for ( int h = 0 ; h <= j ; h ++ ) { if ( arr [ k ] [ h ] == true ) { arr [ k ] [ h ] = false ; } else { arr [ k ] [ h ] = true ; } } } } } } return ans ; } public static void main ( String [ ] args ) { boolean mat [ ] [ ] = { { false , false , true , true , true } , { false , false , false , true , true } , { false , false , false , true , true } , { true , true , true , true , true } , { true , true , true , true , true } } ; System . out . println ( min@@ Operation ( mat ) ) ; } }
Sum of both diagon@@ als of a spir@@ al odd 896 | class GF@@ G { static int spir@@ al@@ Di@@ a@@ Sum ( int n ) { if ( n == 1 ) return 1 ; return ( 4 * n * n - 6 * n + 6 + spir@@ al@@ Di@@ a@@ Sum ( n - 2 ) ) ; } public static void main ( String [ ] args ) { int n = 7 ; System . out . print ( spir@@ al@@ Di@@ a@@ Sum ( n ) ) ; } }
Print matrix in diagonal pattern 901 | class GF@@ G { static final int MAX = 100 ; static void print@@ Matrix@@ Diagonal ( int mat [ ] [ ] , int n ) { int i = 0 , j = 0 ; boolean is@@ Up = true ; for ( int k = 0 ; k < n * n ; ) { if ( is@@ Up ) { for ( ; i >= 0 && j < n ; j ++ , i -- ) { System . out . print ( mat [ i ] [ j ] + " ▁ " ) ; k ++ ; } if ( i < 0 && j <= n - 1 ) i = 0 ; if ( j == n ) { i = i + 2 ; j -- ; } } else { for ( ; j >= 0 && i < n ; i ++ , j -- ) { System . out . print ( mat [ i ] [ j ] + " ▁ " ) ; k ++ ; } if ( j < 0 && i <= n - 1 ) j = 0 ; if ( i == n ) { j = j + 2 ; i -- ; } } is@@ Up = ! is@@ Up ; } } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; int n = 3 ; print@@ Matrix@@ Diagonal ( mat , n ) ; } }
Replace every matrix element with maximum of GC@@ D of row or column 907 | import java . io . * ; class GF@@ G { static int R = 3 ; static int C = 4 ; static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } static void replace@@ matrix ( int [ ] [ ] mat , int n , int m ) { int [ ] rg@@ cd = new int [ R ] ; int [ ] cg@@ cd = new int [ C ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { rg@@ cd [ i ] = gcd ( rg@@ cd [ i ] , mat [ i ] [ j ] ) ; cg@@ cd [ j ] = gcd ( cg@@ cd [ j ] , mat [ i ] [ j ] ) ; } } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) mat [ i ] [ j ] = Math . max ( rg@@ cd [ i ] , cg@@ cd [ j ] ) ; } static public void main ( String [ ] args ) { int [ ] [ ] m = { { 1 , 2 , 3 , 3 } , { 4 , 5 , 6 , 6 } , { 7 , 8 , 9 , 9 } , } ; replace@@ matrix ( m , R , C ) ; for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) System . out . print ( m [ i ] [ j ] + " ▁ " ) ; System . out . println ( ) ; } } }
Count all sorted rows in a matrix 908 | class GF@@ G { static int MAX = 100 ; static int sorted@@ Count ( int mat [ ] [ ] , int r , int c ) { int result = 0 ; for ( int i = 0 ; i < r ; i ++ ) { int j ; for ( j = 0 ; j < c - 1 ; j ++ ) if ( mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] ) break ; if ( j == c - 1 ) result ++ ; } for ( int i = 0 ; i < r ; i ++ ) { int j ; for ( j = c - 1 ; j > 0 ; j -- ) if ( mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] ) break ; if ( c > 1 && j == 0 ) result ++ ; } return result ; } public static void main ( String arg [ ] ) { int m = 4 , n = 5 ; int mat [ ] [ ] = { { 1 , 2 , 3 , 4 , 5 } , { 4 , 3 , 1 , 2 , 6 } , { 8 , 7 , 6 , 5 , 4 } , { 5 , 7 , 8 , 9 , 10 } } ; System . out . print ( sorted@@ Count ( mat , m , n ) ) ; } }
Find a specific pair in Matrix 927 | import java . io . * ; import java . util . * ; class GF@@ G { static int find@@ Max@@ Value ( int N , int mat [ ] [ ] ) { int maxValue = Integer . MIN_VALUE ; int max@@ Arr [ ] [ ] = new int [ N ] [ N ] ; max@@ Arr [ N - 1 ] [ N - 1 ] = mat [ N - 1 ] [ N - 1 ] ; int max@@ v = mat [ N - 1 ] [ N - 1 ] ; for ( int j = N - 2 ; j >= 0 ; j -- ) { if ( mat [ N - 1 ] [ j ] > max@@ v ) max@@ v = mat [ N - 1 ] [ j ] ; max@@ Arr [ N - 1 ] [ j ] = max@@ v ; } max@@ v = mat [ N - 1 ] [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( mat [ i ] [ N - 1 ] > max@@ v ) max@@ v = mat [ i ] [ N - 1 ] ; max@@ Arr [ i ] [ N - 1 ] = max@@ v ; } for ( int i = N - 2 ; i >= 0 ; i -- ) { for ( int j = N - 2 ; j >= 0 ; j -- ) { if ( max@@ Arr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] > maxValue ) maxValue = max@@ Arr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] ; max@@ Arr [ i ] [ j ] = Math . max ( mat [ i ] [ j ] , Math . max ( max@@ Arr [ i ] [ j + 1 ] , max@@ Arr [ i + 1 ] [ j ] ) ) ; } } return maxValue ; } public static void main ( String [ ] args ) { int N = 5 ; int mat [ ] [ ] = { { 1 , 2 , - 1 , - 4 , - 20 } , { - 8 , - 3 , 4 , 2 , 1 } , { 3 , 8 , 6 , 1 , 3 } , { - 4 , - 1 , 1 , 7 , - 6 } , { 0 , - 4 , 10 , - 5 , 1 } } ; System . out . print ( " Maximum ▁ Value ▁ is ▁ " + find@@ Max@@ Value ( N , mat ) ) ; } }
Print unique rows in a given boolean matrix 933 | class GF@@ G { static int ROW = 4 ; static int COL = 5 ; static void find@@ Unique@@ Rows ( int M [ ] [ ] ) { for ( int i = 0 ; i < ROW ; i ++ ) { int flag = 0 ; for ( int j = 0 ; j < i ; j ++ ) { flag = 1 ; for ( int k = 0 ; k < COL ; k ++ ) if ( M [ i ] [ k ] != M [ j ] [ k ] ) flag = 0 ; if ( flag == 1 ) break ; } if ( flag == 0 ) { for ( int j = 0 ; j < COL ; j ++ ) System . out . print ( M [ i ] [ j ] + " ▁ " ) ; System . out . println ( ) ; } } } public static void main ( String [ ] args ) { int M [ ] [ ] = { { 0 , 1 , 0 , 0 , 1 } , { 1 , 0 , 1 , 1 , 0 } , { 0 , 1 , 0 , 0 , 1 } , { 1 , 0 , 1 , 0 , 0 } } ; find@@ Unique@@ Rows ( M ) ; } }
Find sum of all elements in a matrix except the elements in row and / or column of given cell ? 943 | class GF@@ G { static int R = 3 ; static int C = 3 ; static class Cell { int r ; int c ; public Cell ( int r , int c ) { this . r = r ; this . c = c ; } } ; static void print@@ Sum@@ s ( int mat [ ] [ ] , Cell arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 , r = arr [ i ] . r , c = arr [ i ] . c ; for ( int j = 0 ; j < R ; j ++ ) { for ( int k = 0 ; k < C ; k ++ ) { if ( j != r && k != c ) { sum += mat [ j ] [ k ] ; } } } System . out . println ( sum ) ; } } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 1 , 2 } , { 3 , 4 , 6 } , { 5 , 3 , 2 } } ; Cell arr [ ] = { new Cell ( 0 , 0 ) , new Cell ( 1 , 1 ) , new Cell ( 0 , 1 ) } ; int n = arr . length ; print@@ Sum@@ s ( mat , arr , n ) ; } }
Given an n x n square matrix , find sum of all sub 956 | import java . io . * ; class GF@@ G { static int n = 5 ; static void print@@ Sum@@ Tri@@ ck@@ y ( int mat [ ] [ ] , int k ) { if ( k > n ) return ; int strip@@ Sum [ ] [ ] = new int [ n ] [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { int sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) sum += mat [ i ] [ j ] ; strip@@ Sum [ 0 ] [ j ] = sum ; for ( int i = 1 ; i < n - k + 1 ; i ++ ) { sum += ( mat [ i + k - 1 ] [ j ] - mat [ i - 1 ] [ j ] ) ; strip@@ Sum [ i ] [ j ] = sum ; } } for ( int i = 0 ; i < n - k + 1 ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < k ; j ++ ) sum += strip@@ Sum [ i ] [ j ] ; System . out . print ( sum + " ▁ " ) ; for ( int j = 1 ; j < n - k + 1 ; j ++ ) { sum += ( strip@@ Sum [ i ] [ j + k - 1 ] - strip@@ Sum [ i ] [ j - 1 ] ) ; System . out . print ( sum + " ▁ " ) ; } System . out . println ( ) ; } } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 , 4 } , { 5 , 5 , 5 , 5 , 5 } , } ; int k = 3 ; print@@ Sum@@ Tri@@ ck@@ y ( mat , k ) ; } }
Number of paths with exactly k coins 966 | class GF@@ G { static final int R = 3 ; static final int C = 3 ; static final int MAX_@@ K = 100 ; static int [ ] [ ] [ ] dp = new int [ R ] [ C ] [ MAX_@@ K ] ; static int path@@ Count@@ DP@@ Rec@@ DP ( int [ ] [ ] mat , int m , int n , int k ) { if ( m < 0 n < 0 ) return 0 ; if ( m == 0 && n == 0 ) return ( k == mat [ m ] [ n ] ? 1 : 0 ) ; if ( dp [ m ] [ n ] [ k ] != - 1 ) return dp [ m ] [ n ] [ k ] ; dp [ m ] [ n ] [ k ] = path@@ Count@@ DP@@ Rec@@ DP ( mat , m - 1 , n , k - mat [ m ] [ n ] ) + path@@ Count@@ DP@@ Rec@@ DP ( mat , m , n - 1 , k - mat [ m ] [ n ] ) ; return dp [ m ] [ n ] [ k ] ; } static int path@@ Count@@ DP ( int [ ] [ ] mat , int k ) { for ( int i = 0 ; i < R ; i ++ ) for ( int j = 0 ; j < C ; j ++ ) for ( int l = 0 ; l < MAX_@@ K ; l ++ ) dp [ i ] [ j ] [ l ] = - 1 ; return path@@ Count@@ DP@@ Rec@@ DP ( mat , R - 1 , C - 1 , k ) ; } public static void main ( String [ ] args ) { int k = 12 ; int [ ] [ ] mat = new int [ ] [ ] { new int [ ] { 1 , 2 , 3 } , new int [ ] { 4 , 6 , 5 } , new int [ ] { 3 , 2 , 1 } } ; System . out . println ( path@@ Count@@ DP ( mat , k ) ) ; } }
Find length of the longest consecutive path from a given starting character 967 | class path { static int x [ ] = { 0 , 1 , 1 , - 1 , 1 , 0 , - 1 , - 1 } ; static int y [ ] = { 1 , 0 , 1 , 1 , - 1 , - 1 , 0 , - 1 } ; static int R = 3 ; static int C = 3 ; static int dp [ ] [ ] = new int [ R ] [ C ] ; static boolean is@@ valid ( int i , int j ) { if ( i < 0 j < 0 i >= R j >= C ) return false ; return true ; } static boolean is@@ adjacent ( char prev , char curr ) { return ( ( curr - prev ) == 1 ) ; } static int get@@ Len@@ Util ( char mat [ ] [ ] , int i , int j , char prev ) { if ( ! is@@ valid ( i , j ) || ! is@@ adjacent ( prev , mat [ i ] [ j ] ) ) return 0 ; if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ; int ans = 0 ; for ( int k = 0 ; k < 8 ; k ++ ) ans = Math . max ( ans , 1 + get@@ Len@@ Util ( mat , i + x [ k ] , j + y [ k ] , mat [ i ] [ j ] ) ) ; return dp [ i ] [ j ] = ans ; } static int get@@ Len ( char mat [ ] [ ] , char s ) { for ( int i = 0 ; i < R ; ++ i ) for ( int j = 0 ; j < C ; ++ j ) dp [ i ] [ j ] = - 1 ; int ans = 0 ; for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) { if ( mat [ i ] [ j ] == s ) { for ( int k = 0 ; k < 8 ; k ++ ) ans = Math . max ( ans , 1 + get@@ Len@@ Util ( mat , i + x [ k ] , j + y [ k ] , s ) ) ; } } } return ans ; } public static void main ( String args [ ] ) { char mat [ ] [ ] = { { ' a ' , ' c ' , ' d ' } , { ' h ' , ' b ' , ' a ' } , { ' i ' , ' g ' , ' f ' } } ; System . out . println ( get@@ Len ( mat , ' a ' ) ) ; System . out . println ( get@@ Len ( mat , ' e ' ) ) ; System . out . println ( get@@ Len ( mat , ' b ' ) ) ; System . out . println ( get@@ Len ( mat , ' f ' ) ) ; } }
Find the two repe@@ ating elements in a given array 1703 | class Repeat@@ Element { void print@@ Repe@@ ating ( int arr [ ] , int size ) { int count [ ] = new int [ size ] ; int i ; System . out . println ( " Repe@@ ated ▁ elements ▁ are ▁ : ▁ " ) ; for ( i = 0 ; i < size ; i ++ ) { if ( count [ arr [ i ] ] == 1 ) System . out . print ( arr [ i ] + " ▁ " ) ; else count [ arr [ i ] ] ++ ; } } public static void main ( String [ ] args ) { Repeat@@ Element repeat = new Repeat@@ Element ( ) ; int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_@@ size = arr . length ; repeat . print@@ Repe@@ ating ( arr , arr_@@ size ) ; } }
Find the two repe@@ ating elements in a given array 1706 | class Repeat@@ Element { void print@@ Repe@@ ating ( int arr [ ] , int size ) { int i ; System . out . println ( " The ▁ repe@@ ating ▁ elements ▁ are ▁ : ▁ " ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ Math . abs ( arr [ i ] ) ] > 0 ) arr [ Math . abs ( arr [ i ] ) ] = - arr [ Math . abs ( arr [ i ] ) ] ; else System . out . print ( Math . abs ( arr [ i ] ) + " ▁ " ) ; } } public static void main ( String [ ] args ) { Repeat@@ Element repeat = new Repeat@@ Element ( ) ; int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_@@ size = arr . length ; repeat . print@@ Repe@@ ating ( arr , arr_@@ size ) ; } }
Find a Fixed Point ( Value equal to index ) in a given array 1708 | class Main { static int binary@@ Search ( int arr [ ] , int low , int high ) { if ( high >= low ) { int mid = ( low + high ) / 2 ; if ( mid == arr [ mid ] ) return mid ; if ( mid > arr [ mid ] ) return binary@@ Search ( arr , ( mid + 1 ) , high ) ; else return binary@@ Search ( arr , low , ( mid - 1 ) ) ; } return - 1 ; } public static void main ( String args [ ] ) { int arr [ ] = { - 10 , - 1 , 0 , 3 , 10 , 11 , 30 , 50 , 100 } ; int n = arr . length ; System . out . println ( " Fixed ▁ Point ▁ is ▁ " + binary@@ Search ( arr , 0 , n - 1 ) ) ; } }
Find sub@@ array with given sum | Set 1 ( Non@@ negative Numbers ) 1709 | class Sub@@ array@@ Sum { int sub@@ Array@@ Sum ( int arr [ ] , int n , int sum ) { int curr_@@ sum , i , j ; for ( i = 0 ; i < n ; i ++ ) { curr_@@ sum = arr [ i ] ; for ( j = i + 1 ; j <= n ; j ++ ) { if ( curr_@@ sum == sum ) { int p = j - 1 ; System . out . println ( " Sum ▁ found ▁ between ▁ indexes ▁ " + i + " ▁ and ▁ " + p ) ; return 1 ; } if ( curr_@@ sum > sum j == n ) break ; curr_@@ sum = curr_@@ sum + arr [ j ] ; } } System . out . println ( " No ▁ sub@@ array ▁ found " ) ; return 0 ; } public static void main ( String [ ] args ) { Sub@@ array@@ Sum array@@ sum = new Sub@@ array@@ Sum ( ) ; int arr [ ] = { 15 , 2 , 4 , 8 , 9 , 5 , 10 , 23 } ; int n = arr . length ; int sum = 23 ; array@@ sum . sub@@ Array@@ Sum ( arr , n , sum ) ; } }
Min Cost Path | DP 1843 | public class GF@@ G { static int min ( int x , int y , int z ) { if ( x < y ) return ( x < z ) ? x : z ; else return ( y < z ) ? y : z ; } static int min@@ Cost ( int cost [ ] [ ] , int m , int n ) { if ( n < 0 m < 0 ) return Integer . MAX_VALUE ; else if ( m == 0 && n == 0 ) return cost [ m ] [ n ] ; else return cost [ m ] [ n ] + min ( min@@ Cost ( cost , m - 1 , n - 1 ) , min@@ Cost ( cost , m - 1 , n ) , min@@ Cost ( cost , m , n - 1 ) ) ; } public static void main ( String args [ ] ) { int cost [ ] [ ] = { { 1 , 2 , 3 } , { 4 , 8 , 2 } , { 1 , 5 , 3 } } ; System . out . print ( min@@ Cost ( cost , 2 , 2 ) ) ; } }
Min Cost Path | DP 1844 | import java . util . * ; class Minimum@@ Cost@@ Path { private static int min@@ Cost ( int cost [ ] [ ] , int m , int n ) { int i , j ; int tc [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ; for ( i = 1 ; i <= m ; i ++ ) tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ; for ( j = 1 ; j <= n ; j ++ ) tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; for ( i = 1 ; i <= m ; i ++ ) for ( j = 1 ; j <= n ; j ++ ) tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ i - 1 ] [ j ] , tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; return tc [ m ] [ n ] ; } private static int min ( int x , int y , int z ) { if ( x < y ) return ( x < z ) ? x : z ; else return ( y < z ) ? y : z ; } public static void main ( String args [ ] ) { int cost [ ] [ ] = { { 1 , 2 , 3 } , { 4 , 8 , 2 } , { 1 , 5 , 3 } } ; System . out . println ( min@@ Cost ( cost , 2 , 2 ) ) ; } }
Matrix Chain Multiplic@@ ation | DP 1853 | class Matrix@@ Chain@@ Multiplic@@ ation { static int Matrix@@ Chain@@ Order ( int p [ ] , int n ) { int m [ ] [ ] = new int [ n ] [ n ] ; int i , j , k , L , q ; for ( i = 1 ; i < n ; i ++ ) m [ i ] [ i ] = 0 ; for ( L = 2 ; L < n ; L ++ ) { for ( i = 1 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; if ( j == n ) continue ; m [ i ] [ j ] = Integer . MAX_VALUE ; for ( k = i ; k <= j - 1 ; k ++ ) { q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( q < m [ i ] [ j ] ) m [ i ] [ j ] = q ; } } } return m [ 1 ] [ n - 1 ] ; } public static void main ( String args [ ] ) { int arr [ ] = new int [ ] { 1 , 2 , 3 , 4 } ; int size = arr . length ; System . out . println ( " Minimum ▁ number ▁ of ▁ multiplic@@ ations ▁ is ▁ " + Matrix@@ Chain@@ Order ( arr , size ) ) ; } }
0 1861 | class K@@ nap@@ s@@ ack { static int max ( int a , int b ) { return ( a > b ) ? a : b ; } static int kn@@ ap@@ S@@ ack ( int W , int wt [ ] , int val [ ] , int n ) { if ( n == 0 W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return kn@@ ap@@ S@@ ack ( W , wt , val , n - 1 ) ; else return max ( val [ n - 1 ] + kn@@ ap@@ S@@ ack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , kn@@ ap@@ S@@ ack ( W , wt , val , n - 1 ) ) ; } public static void main ( String args [ ] ) { int val [ ] = new int [ ] { 60 , 100 , 120 } ; int wt [ ] = new int [ ] { 10 , 20 , 30 } ; int W = 50 ; int n = val . length ; System . out . println ( kn@@ ap@@ S@@ ack ( W , wt , val , n ) ) ; } }
0 1862 | class K@@ nap@@ s@@ ack { static int max ( int a , int b ) { return ( a > b ) ? a : b ; } static int kn@@ ap@@ S@@ ack ( int W , int wt [ ] , int val [ ] , int n ) { int i , w ; int K [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) { for ( w = 0 ; w <= W ; w ++ ) { if ( i == 0 w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } return K [ n ] [ W ] ; } public static void main ( String args [ ] ) { int val [ ] = new int [ ] { 60 , 100 , 120 } ; int wt [ ] = new int [ ] { 10 , 20 , 30 } ; int W = 50 ; int n = val . length ; System . out . println ( kn@@ ap@@ S@@ ack ( W , wt , val , n ) ) ; } }
Lon@@ gest Pal@@ ind@@ ro@@ mic Sub@@ sequence | DP 1867 | class GF@@ G { static int max ( int x , int y ) { return ( x > y ) ? x : y ; } static int l@@ ps ( char seq [ ] , int i , int j ) { if ( i == j ) { return 1 ; } if ( seq [ i ] == seq [ j ] && i + 1 == j ) { return 2 ; } if ( seq [ i ] == seq [ j ] ) { return l@@ ps ( seq , i + 1 , j - 1 ) + 2 ; } return max ( l@@ ps ( seq , i , j - 1 ) , l@@ ps ( seq , i + 1 , j ) ) ; } public static void main ( String [ ] args ) { String seq = " GE@@ EK@@ S@@ FOR@@ GE@@ E@@ KS " ; int n = seq . length ( ) ; System . out . printf ( " The ▁ length ▁ of ▁ the ▁ LP@@ S ▁ is ▁ % d " , l@@ ps ( seq . toCharArray ( ) , 0 , n - 1 ) ) ; } }
Cu@@ tting a Ro@@ d | DP 1870 | class Ro@@ d@@ Cu@@ tting { static int cut@@ Ro@@ d ( int price [ ] , int n ) { int val [ ] = new int [ n + 1 ] ; val [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int max_@@ val = Integer . MIN_VALUE ; for ( int j = 0 ; j < i ; j ++ ) max_@@ val = Math . max ( max_@@ val , price [ j ] + val [ i - j - 1 ] ) ; val [ i ] = max_@@ val ; } return val [ n ] ; } public static void main ( String args [ ] ) { int arr [ ] = new int [ ] { 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 } ; int size = arr . length ; System . out . println ( " Maximum ▁ Obtain@@ able ▁ Value ▁ is ▁ " + cut@@ Ro@@ d ( arr , size ) ) ; } }
Count number of ways to reach a given score in a game 1944 | import java . util . Arrays ; class GF@@ G { static int count ( int n ) { int table [ ] = new int [ n + 1 ] , i ; Arrays . fill ( table , 0 ) ; table [ 0 ] = 1 ; for ( i = 3 ; i <= n ; i ++ ) table [ i ] += table [ i - 3 ] ; for ( i = 5 ; i <= n ; i ++ ) table [ i ] += table [ i - 5 ] ; for ( i = 10 ; i <= n ; i ++ ) table [ i ] += table [ i - 10 ] ; return table [ n ] ; } public static void main ( String [ ] args ) { int n = 20 ; System . out . println ( " Count ▁ for ▁ " + n + " ▁ is ▁ " + count ( n ) ) ; n = 13 ; System . out . println ( " Count ▁ for ▁ " + n + " ▁ is ▁ " + count ( n ) ) ; } }
Nai@@ ve algorithm for Pattern Search@@ ing 1949 | public class Nai@@ ve@@ Search { public static void search ( String txt , String pat ) { int M = pat . length ( ) ; int N = txt . length ( ) ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt . charAt ( i + j ) != pat . charAt ( j ) ) break ; if ( j == M ) System . out . println ( " Pattern ▁ found ▁ at ▁ index ▁ " + i ) ; } } public static void main ( String [ ] args ) { String txt = " AAB@@ AAC@@ A@@ AD@@ AAB@@ AA@@ AB@@ AA " ; String pat = " AAB@@ A " ; search ( txt , pat ) ; } }
Rab@@ in 1954 | public class Main { public final static int d = 256 ; static void search ( String pat , String txt , int q ) { int M = pat . length ( ) ; int N = txt . length ( ) ; int i , j ; int p = 0 ; int t = 0 ; int h = 1 ; for ( i = 0 ; i < M - 1 ; i ++ ) h = ( h * d ) % q ; for ( i = 0 ; i < M ; i ++ ) { p = ( d * p + pat . charAt ( i ) ) % q ; t = ( d * t + txt . charAt ( i ) ) % q ; } for ( i = 0 ; i <= N - M ; i ++ ) { if ( p == t ) { for ( j = 0 ; j < M ; j ++ ) { if ( txt . charAt ( i + j ) != pat . charAt ( j ) ) break ; } if ( j == M ) System . out . println ( " Pattern ▁ found ▁ at ▁ index ▁ " + i ) ; } if ( i < N - M ) { t = ( d * ( t - txt . charAt ( i ) * h ) + txt . charAt ( i + M ) ) % q ; if ( t < 0 ) t = ( t + q ) ; } } } public static void main ( String [ ] args ) { String txt = " GE@@ E@@ KS ▁ FOR ▁ GE@@ E@@ KS " ; String pat = " GE@@ EK " ; int q = 101 ; search ( pat , txt , q ) ; } }
Write a program to calculate pow ( x , n ) 1976 | class GF@@ G { static int power ( int x , int y ) { if ( y == 0 ) return 1 ; else if ( y % 2 == 0 ) return power ( x , y / 2 ) * power ( x , y / 2 ) ; else return x * power ( x , y / 2 ) * power ( x , y / 2 ) ; } public static void main ( String [ ] args ) { int x = 2 ; int y = 3 ; System . out . printf ( " % d " , power ( x , y ) ) ; } }
Check whether a given point lies inside a triangle or not 1989 | import java . util . * ; class GF@@ G { static double area ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { return Math . abs ( ( x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ) / 2.0 ) ; } static boolean isIn@@ side ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x , int y ) { double A = area ( x1 , y1 , x2 , y2 , x3 , y3 ) ; double A1 = area ( x , y , x2 , y2 , x3 , y3 ) ; double A2 = area ( x1 , y1 , x , y , x3 , y3 ) ; double A3 = area ( x1 , y1 , x2 , y2 , x , y ) ; return ( A == A1 + A2 + A3 ) ; } public static void main ( String [ ] args ) { if ( isIn@@ side ( 0 , 0 , 20 , 0 , 10 , 30 , 10 , 15 ) ) System . out . println ( " Inside " ) ; else System . out . println ( " Not ▁ Inside " ) ; } }
Lu@@ ck@@ y Numbers 1994 | import java . io . * ; class GF@@ G { public static int counter = 2 ; static boolean is@@ Lu@@ ck@@ y ( int n ) { int next_@@ position = n ; if ( counter > n ) return true ; if ( n % counter == 0 ) return false ; next_@@ position -= next_@@ position / counter ; counter ++ ; return is@@ Lu@@ ck@@ y ( next_@@ position ) ; } public static void main ( String [ ] args ) { int x = 5 ; if ( is@@ Lu@@ ck@@ y ( x ) ) System . out . println ( x + " ▁ is ▁ a ▁ lu@@ ck@@ y ▁ no . " ) ; else System . out . println ( x + " ▁ is ▁ not ▁ a ▁ lu@@ ck@@ y ▁ no . " ) ; } }
Lex@@ ico@@ graphic rank of a string 2018 | import java . io . * ; import java . util . * ; class GF@@ G { static int fact ( int n ) { return ( n <= 1 ) ? 1 : n * fact ( n - 1 ) ; } static int find@@ Small@@ er@@ In@@ Right ( String str , int low , int high ) { int count@@ Right = 0 , i ; for ( i = low + 1 ; i <= high ; ++ i ) if ( str . charAt ( i ) < str . charAt ( low ) ) ++ count@@ Right ; return count@@ Right ; } static int find@@ Rank ( String str ) { int len = str . length ( ) ; int mul = fact ( len ) ; int rank = 1 ; int count@@ Right ; for ( int i = 0 ; i < len ; ++ i ) { mul /= len - i ; count@@ Right = find@@ Small@@ er@@ In@@ Right ( str , i , len - 1 ) ; rank += count@@ Right * mul ; } return rank ; } public static void main ( String [ ] args ) { String str = " string " ; System . out . println ( find@@ Rank ( str ) ) ; } }
Space and time efficient Bin@@ omial Coefficient 2022 | class Bin@@ omi@@ al@@ Coefficient { static int bin@@ omi@@ al@@ Coeff ( int n , int k ) { int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } public static void main ( String [ ] args ) { int n = 8 ; int k = 2 ; System . out . println ( " Value ▁ of ▁ C ( " + n + " , ▁ " + k + " ) ▁ " + " is " + " ▁ " + bin@@ omi@@ al@@ Coeff ( n , k ) ) ; } }
Pas@@ cal '@@ s Triangle 2025 | import java . io . * ; class GF@@ G { public static void print@@ Pas@@ cal ( int n ) { int [ ] [ ] arr = new int [ n ] [ n ] ; for ( int line = 0 ; line < n ; line ++ ) { for ( int i = 0 ; i <= line ; i ++ ) { if ( line == i i == 0 ) arr [ line ] [ i ] = 1 ; else arr [ line ] [ i ] = arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] ; System . out . print ( arr [ line ] [ i ] ) ; } System . out . println ( " " ) ; } } } public static void main ( String [ ] args ) { int n = 5 ; print@@ Pas@@ cal ( n ) ; }
E@@ fficient program to calculate e ^ x 2028 | import java . io . * ; class GF@@ G { static float exponential ( int n , float x ) { float sum = 1 ; for ( int i = n - 1 ; i > 0 ; -- i ) sum = 1 + x * sum / i ; return sum ; } public static void main ( String [ ] args ) { int n = 10 ; float x = 1 ; System . out . println ( " e ^ x ▁ = ▁ " + exponential ( n , x ) ) ; } }
E@@ fficient program to print all prime factors of a given number 2030 | import java . io . * ; import java . lang . Math ; class GF@@ G { public static void prime@@ Factors ( int n ) { while ( n % 2 == 0 ) { System . out . print ( 2 + " ▁ " ) ; n /= 2 ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { System . out . print ( i + " ▁ " ) ; n /= i ; } } if ( n > 2 ) System . out . print ( n ) ; } public static void main ( String [ ] args ) { int n = 3@@ 15 ; prime@@ Factors ( n ) ; } }
Print all possible combinations of r elements in a given array of size n 2032 | import java . io . * ; class Combination { static void print@@ Combination ( int arr [ ] , int n , int r ) { int data [ ] = new int [ r ] ; combin@@ ation@@ Util ( arr , n , r , 0 , data , 0 ) ; } static void combin@@ ation@@ Util ( int arr [ ] , int n , int r , int index , int data [ ] , int i ) { if ( index == r ) { for ( int j = 0 ; j < r ; j ++ ) System . out . print ( data [ j ] + " ▁ " ) ; System . out . println ( " " ) ; return ; } if ( i >= n ) return ; data [ index ] = arr [ i ] ; combin@@ ation@@ Util ( arr , n , r , index + 1 , data , i + 1 ) ; combin@@ ation@@ Util ( arr , n , r , index , data , i + 1 ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int r = 3 ; int n = arr . length ; print@@ Combination ( arr , n , r ) ; } }
Find the element that appears once 2065 | class GF@@ G { static int get@@ Single ( int arr [ ] , int n ) { int ones = 0 , tw@@ os = 0 ; int common_@@ bit@@ _mask ; for ( int i = 0 ; i < n ; i ++ ) { tw@@ os = tw@@ os | ( ones & arr [ i ] ) ; ones = ones ^ arr [ i ] ; common_@@ bit@@ _mask = ~ ( ones & tw@@ os ) ; ones &= common_@@ bit@@ _mask ; tw@@ os &= common_@@ bit@@ _mask ; } return ones ; } public static void main ( String args [ ] ) { int arr [ ] = { 3 , 3 , 2 , 3 } ; int n = arr . length ; System . out . println ( " The ▁ element ▁ with ▁ single ▁ occurrence ▁ is ▁ " + get@@ Single ( arr , n ) ) ; } }
Find the element that appears once 2066 | class GF@@ G { static final int INT_@@ SIZE = 32 ; static int get@@ Single ( int arr [ ] , int n ) { int result = 0 ; int x , sum ; for ( int i = 0 ; i < INT_@@ SIZE ; i ++ ) { sum = 0 ; x = ( 1 << i ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & x ) == 0 ) sum ++ ; } if ( ( sum % 3 ) != 0 ) result |= x ; } return result ; } public static void main ( String args [ ] ) { int arr [ ] = { 12 , 1 , 12 , 3 , 12 , 1 , 1 , 2 , 3 , 2 , 2 , 3 , 7 } ; int n = arr . length ; System . out . println ( " The ▁ element ▁ with ▁ single ▁ occurrence ▁ is ▁ " + get@@ Single ( arr , n ) ) ; } }
Count total set bits in all numbers from 1 to n 2073 | public class GF@@ G { static int count@@ Set@@ Bits ( int n ) { int i = 0 ; int ans = 0 ; while ( ( 1 << i ) <= n ) { boolean k = false ; int change = 1 << i ; for ( int j = 0 ; j <= n ; j ++ ) { if ( k == true ) ans += 1 ; else ans += 0 ; if ( change == 1 ) { k = ! k ; change = 1 << i ; } else { change -- ; } } i ++ ; } return ans ; } public static void main ( String [ ] args ) { int n = 17 ; System . out . println ( count@@ Set@@ Bits ( n ) ) ; } }
Add two numbers without using arithmetic operators 2079 | import java . io . * ; class GF@@ G { static int Add ( int x , int y ) { while ( y != 0 ) { int carry = x & y ; x = x ^ y ; y = carry << 1 ; } return x ; } public static void main ( String arg [ ] ) { System . out . println ( Add ( 15 , 32 ) ) ; } }
S@@ malle@@ st of three integers without comparison operators 2081 | class GF@@ G { static int smallest ( int x , int y , int z ) { int c = 0 ; while ( x != 0 && y != 0 && z != 0 ) { x -- ; y -- ; z -- ; c ++ ; } return c ; } public static void main ( String [ ] args ) { int x = 12 , y = 15 , z = 5 ; System . out . printf ( " Minimum ▁ of ▁ 3" + " ▁ numbers ▁ is ▁ % d " , smallest ( x , y , z ) ) ; } }
Add 1 to a given number 2090 | class GF@@ G { static int add@@ One ( int x ) { int m = 1 ; while ( ( int ) ( x & m ) >= 1 ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; } public static void main ( String [ ] args ) { System . out . println ( add@@ One ( 13 ) ) ; } }
Add 1 to a given number 2091 | class GF@@ G { static int add@@ One ( int x ) { return ( - ( ~ x ) ) ; } public static void main ( String [ ] args ) { System . out . printf ( " % d " , add@@ One ( 13 ) ) ; } }
Find whether a given number is a power of 4 or not 2096 | class GF@@ G { static int is@@ PowerOf@@ Four ( int n ) { if ( n == 0 ) return 0 ; while ( n != 1 ) { if ( n % 4 != 0 ) return 0 ; n = n / 4 ; } return 1 ; } public static void main ( String [ ] args ) { int test_@@ no = 64 ; if ( is@@ PowerOf@@ Four ( test_@@ no ) == 1 ) System . out . println ( test_@@ no + " ▁ is ▁ a ▁ power ▁ of ▁ 4" ) ; else System . out . println ( test_@@ no + " is ▁ not ▁ a ▁ power ▁ of ▁ 4" ) ; } }
Compute the minimum or maximum of two integers without branch@@ ing 2105 | import java . io . * ; class GF@@ G { public static int abs@@ bit@@ 32 ( int x , int y ) { int sub = x - y ; int mask = ( sub >> 31 ) ; return ( sub ^ mask ) - mask ; } public static int max ( int x , int y ) { int abs = abs@@ bit@@ 32 ( x , y ) ; return ( x + y + abs ) / 2 ; } public static int min ( int x , int y ) { int abs = abs@@ bit@@ 32 ( x , y ) ; return ( x + y - abs ) / 2 ; } public static void main ( String [ ] args ) { System . out . println ( max ( 2 , 3 ) ) ; System . out . println ( max ( 2 , - 3 ) ) ; System . out . println ( max ( - 2 , - 3 ) ) ; System . out . println ( min ( 2 , 3 ) ) ; System . out . println ( min ( 2 , - 3 ) ) ; System . out . println ( min ( - 2 , - 3 ) ) ; } }
Count set bits in an integer 2114 | import java . io . * ; class count@@ Set@@ Bits { static int count@@ Set@@ Bits ( int n ) { int count = 0 ; while ( n > 0 ) { count += n & 1 ; n >>= 1 ; } return count ; } public static void main ( String args [ ] ) { int i = 9 ; System . out . println ( count@@ Set@@ Bits ( i ) ) ; } }
Count set bits in an integer 2118 | class GF@@ G { static int [ ] Bits@@ Set@@ Table@@ 256 = new int [ 256 ] ; public static void initialize ( ) { Bits@@ Set@@ Table@@ 256 [ 0 ] = 0 ; for ( int i = 0 ; i < 256 ; i ++ ) { Bits@@ Set@@ Table@@ 256 [ i ] = ( i & 1 ) + Bits@@ Set@@ Table@@ 256 [ i / 2 ] ; } } public static int count@@ Set@@ Bits ( int n ) { return ( Bits@@ Set@@ Table@@ 256 [ n & 0xff ] + Bits@@ Set@@ Table@@ 256 [ ( n >> 8 ) & 0xff ] + Bits@@ Set@@ Table@@ 256 [ ( n >> 16 ) & 0xff ] + Bits@@ Set@@ Table@@ 256 [ n >> 24 ] ) ; } public static void main ( String [ ] args ) { initialize ( ) ; int n = 9 ; System . out . print ( count@@ Set@@ Bits ( n ) ) ; } }
S@@ malle@@ st power of 2 greater than or equal to n 2123 | import java . io . * ; class GF@@ G { static int next@@ PowerOf@@ 2 ( int n ) { int count = 0 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; } public static void main ( String args [ ] ) { int n = 0 ; System . out . println ( next@@ PowerOf@@ 2 ( n ) ) ; } }
S@@ malle@@ st power of 2 greater than or equal to n 2124 | import java . io . * ; class GF@@ G { static int next@@ PowerOf@@ 2 ( int n ) { int p = 1 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( p < n ) p <<= 1 ; return p ; } public static void main ( String args [ ] ) { int n = 5 ; System . out . println ( next@@ PowerOf@@ 2 ( n ) ) ; } }
Program to find parity 2127 | import java . util . * ; import java . lang . * ; import java . io . * ; import java . math . BigInteger ; class GF@@ G { static boolean get@@ Par@@ ity ( int n ) { boolean parity = false ; while ( n != 0 ) { parity = ! parity ; n = n & ( n - 1 ) ; } return parity ; } public static void main ( String [ ] args ) { int n = 12 ; System . out . println ( " Par@@ ity ▁ of ▁ no ▁ " + n + " ▁ = ▁ " + ( get@@ Par@@ ity ( n ) ? " odd " : " even " ) ) ; } }
Program to find whether a no is power of two 2132 | class Test { static boolean is@@ PowerOf@@ Two ( int x ) { return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ; } public static void main ( String [ ] args ) { System . out . println ( is@@ PowerOf@@ Two ( 31 ) ? " Yes " : " No " ) ; System . out . println ( is@@ PowerOf@@ Two ( 64 ) ? " Yes " : " No " ) ; } }
Position of right@@ most set bit 2137 | import java . io . * ; class GF@@ G { public static int La@@ st_@@ set_@@ bit ( int n ) { int p = 1 ; while ( n > 0 ) { if ( ( n & 1 ) > 0 ) { return p ; } p ++ ; n = n >> 1 ; } return - 1 ; } public static void main ( String [ ] args ) { int n = 18 ; int pos = La@@ st_@@ set_@@ bit ( n ) ; if ( pos != - 1 ) System . out . println ( pos ) ; else System . out . println ( "0" ) ; } }
Find position of the only set bit 2143 | class GF@@ G { static boolean is@@ PowerOf@@ Two ( int n ) { return ( n > 0 && ( ( n & ( n - 1 ) ) == 0 ) ) ? true : false ; } static int find@@ Position ( int n ) { if ( ! is@@ PowerOf@@ Two ( n ) ) return - 1 ; int i = 1 , pos = 1 ; while ( ( i & n ) == 0 ) { i = i << 1 ; ++ pos ; } return pos ; } public static void main ( String [ ] args ) { int n = 16 ; int pos = find@@ Position ( n ) ; if ( pos == - 1 ) System . out . println ( " n ▁ = ▁ " + n + " , ▁ Invalid ▁ number " ) ; else System . out . println ( " n ▁ = ▁ " + n + " , ▁ Position ▁ " + pos ) ; n = 12 ; pos = find@@ Position ( n ) ; if ( pos == - 1 ) System . out . println ( " n ▁ = ▁ " + n + " , ▁ Invalid ▁ number " ) ; else System . out . println ( " n ▁ = ▁ " + n + " , ▁ Position ▁ " + pos ) ; n = 128 ; pos = find@@ Position ( n ) ; if ( pos == - 1 ) System . out . println ( " n ▁ = ▁ " + n + " , ▁ Invalid ▁ number " ) ; else System . out . println ( " n ▁ = ▁ " + n + " , ▁ Position ▁ " + pos ) ; } }
How to swap two numbers without using a temporary variable ? 2147 | import java . io . * ; class GF@@ G { public static void main ( String [ ] args ) { int x = 10 ; int y = 5 ; x = x * y ; y = x / y ; x = x / y ; System . out . println ( " After ▁ swap@@ ing : " + " ▁ x ▁ = ▁ " + x + " , ▁ y ▁ = ▁ " + y ) ; } }
How to swap two numbers without using a temporary variable ? 2148 | import java . io . * ; public class GF@@ G { public static void main ( String a [ ] ) { int x = 10 ; int y = 5 ; x = x ^ y ; y = x ^ y ; x = x ^ y ; System . out . println ( " After ▁ swap : ▁ x ▁ = ▁ " + x + " , ▁ y ▁ = ▁ " + y ) ; } }
How to swap two numbers without using a temporary variable ? 2149 | class GF@@ G { static void swap ( int [ ] xp , int [ ] yp ) { xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; } public static void main ( String [ ] args ) { int [ ] x = { 10 } ; swap ( x , x ) ; System . out . println ( " After ▁ swap ( & x , ▁ & x ) : ▁ x ▁ = ▁ " + x [ 0 ] ) ; } }
How to swap two numbers without using a temporary variable ? 2151 | import java . io . * ; class GF@@ G { public static void swap ( int a , int b ) { a = ( a & b ) + ( a b ) ; b = a + ( ~ b ) + 1 ; a = a + ( ~ b ) + 1 ; System . out . print ( " After ▁ sw@@ apping : ▁ a ▁ = ▁ " + a + " , ▁ b ▁ = ▁ " + b ) ; } public static void main ( String [ ] args ) { int a = 5 , b = 10 ; swap ( a , b ) ; } }
Se@@ greg@@ ate 0 s and 1 s in an array 2168 | class Se@@ greg@@ ate { void se@@ greg@@ ate@@ 0@@ and@@ 1 ( int arr [ ] , int size ) { int left = 0 , right = size - 1 ; while ( left < right ) { while ( arr [ left ] == 0 && left < right ) left ++ ; while ( arr [ right ] == 1 && left < right ) right -- ; if ( left < right ) { arr [ left ] = 0 ; arr [ right ] = 1 ; left ++ ; right -- ; } } } public static void main ( String [ ] args ) { Se@@ greg@@ ate seg = new Se@@ greg@@ ate ( ) ; int arr [ ] = new int [ ] { 0 , 1 , 0 , 1 , 1 , 1 } ; int i , arr_@@ size = arr . length ; seg . se@@ greg@@ ate@@ 0@@ and@@ 1 ( arr , arr_@@ size ) ; System . out . print ( " Array ▁ after ▁ se@@ greg@@ ation ▁ is ▁ " ) ; for ( i = 0 ; i < 6 ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
Given an array arr [ ] , find the maximum j 2195 | class Find@@ Maximum { int max@@ Index@@ Diff ( int arr [ ] , int n ) { int max@@ Diff = - 1 ; int i , j ; for ( i = 0 ; i < n ; ++ i ) { for ( j = n - 1 ; j > i ; -- j ) { if ( arr [ j ] > arr [ i ] && max@@ Diff < ( j - i ) ) max@@ Diff = j - i ; } } return max@@ Diff ; } public static void main ( String [ ] args ) { Find@@ Maximum max = new Find@@ Maximum ( ) ; int arr [ ] = { 9 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 18 , 0 } ; int n = arr . length ; int max@@ Diff = max . max@@ Index@@ Diff ( arr , n ) ; System . out . println ( max@@ Diff ) ; } }
Given an array arr [ ] , find the maximum j 2196 | import java . util . * ; class GF@@ G { public static void main ( String [ ] args ) { int [ ] v = { 34 , 8 , 10 , 3 , 2 , 80 , 30 , 33 , 1 } ; int n = v . length ; int [ ] max@@ From@@ End = new int [ n + 1 ] ; Arrays . fill ( max@@ From@@ End , Integer . MIN_VALUE ) ; for ( int i = v . length - 1 ; i >= 0 ; i -- ) { max@@ From@@ End [ i ] = Math . max ( max@@ From@@ End [ i + 1 ] , v [ i ] ) ; } int result = 0 ; for ( int i = 0 ; i < v . length ; i ++ ) { int low = i + 1 , high = v . length - 1 , ans = i ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( v [ i ] <= max@@ From@@ End [ mid ] ) { ans = Math . max ( ans , mid ) ; low = mid + 1 ; } else { high = mid - 1 ; } } result = Math . max ( result , ans - i ) ; } System . out . print ( result + "@@ NEW_@@ LINE@@ "@@ )@@ ; } }
Find the maximum element in an array which is first increasing and then decre@@ asing 2199 | class Main { static int find@@ Maximum ( int arr [ ] , int low , int high ) { int max = arr [ low ] ; int i ; for ( i = low ; i <= high ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } return max ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 30 , 40 , 50 , 60 , 70 , 23 , 20 } ; int n = arr . length ; System . out . println ( " The ▁ maximum ▁ element ▁ is ▁ " + find@@ Maximum ( arr , 0 , n - 1 ) ) ; } }
Range Query on array whose each element is XOR of index value and previous element 2226 | import java . io . * ; class GF@@ G { static int fun ( int x ) { int y = ( x / 4 ) * 4 ; int ans = 0 ; for ( int i = y ; i <= x ; i ++ ) ans ^= i ; return ans ; } static int query ( int x ) { if ( x == 0 ) return 0 ; int k = ( x + 1 ) / 2 ; return ( ( x %= 2 ) != 0 ) ? 2 * fun ( k ) : ( ( fun ( k - 1 ) * 2 ) ^ ( k & 1 ) ) ; } static void all@@ Queries ( int q , int l [ ] , int r [ ] ) { for ( int i = 0 ; i < q ; i ++ ) System . out . println ( ( query ( r [ i ] ) ^ query ( l [ i ] - 1 ) ) ) ; } public static void main ( String [ ] args ) { int q = 3 ; int [ ] l = { 2 , 2 , 5 } ; int [ ] r = { 4 , 8 , 9 } ; all@@ Queries ( q , l , r ) ; } }
Probability of a random pair being the maximum weighted pair 2247 | import java . io . * ; class GF@@ G { static double probability ( int a [ ] , int b [ ] , int size1 , int size2 ) { int max@@ 1 = Integer . MIN_VALUE , count@@ 1 = 0 ; for ( int i = 0 ; i < size1 ; i ++ ) { if ( a [ i ] > max@@ 1 ) { max@@ 1 = a [ i ] ; count@@ 1 = 1 ; } else if ( a [ i ] == max@@ 1 ) { count@@ 1 ++ ; } } int max@@ 2 = Integer . MIN_VALUE , count2 = 0 ; for ( int i = 0 ; i < size2 ; i ++ ) { if ( b [ i ] > max@@ 2 ) { max@@ 2 = b [ i ] ; count2 = 1 ; } else if ( b [ i ] == max@@ 2 ) { count2 ++ ; } } return ( double ) ( count@@ 1 * count2 ) / ( size1 * size2 ) ; } public static void main ( String args [ ] ) { int a [ ] = { 1 , 2 , 3 } ; int b [ ] = { 1 , 3 , 3 } ; int size1 = a . length ; int size2 = b . length ; System . out . println ( probability ( a , b , size1 , size2 ) ) ; } }
Minimum adjacent sw@@ aps required to Sort Binary array 2259 | import java . io . * ; class GF@@ G { public static int min@@ sw@@ aps ( int arr [ ] , int n ) { int count = 0 ; int num_@@ un@@ place@@ d_@@ zeros = 0 ; for ( int index = n - 1 ; index >= 0 ; index -- ) { if ( arr [ index ] == 0 ) num_@@ un@@ place@@ d_@@ zeros += 1 ; else count += num_@@ un@@ place@@ d_@@ zeros ; } return count ; } public static void main ( String [ ] args ) { int [ ] arr = { 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 } ; System . out . println ( min@@ sw@@ aps ( arr , 9 ) ) ; } }
Mer@@ ging two un@@ sorted arrays in sorted order 2273 | import java . util . * ; class GF@@ G { public static void sorted@@ Merge ( int a [ ] , int b [ ] , int res [ ] , int n , int m ) { Arrays . sort ( a ) ; Arrays . sort ( b ) ; int i = 0 , j = 0 , k = 0 ; while ( i < n && j < m ) { if ( a [ i ] <= b [ j ] ) { res [ k ] = a [ i ] ; i += 1 ; k += 1 ; } else { res [ k ] = b [ j ] ; j += 1 ; k += 1 ; } } while ( i < n ) { res [ k ] = a [ i ] ; i += 1 ; k += 1 ; } while ( j < m ) { res [ k ] = b [ j ] ; j += 1 ; k += 1 ; } } public static void main ( String [ ] args ) { int a [ ] = { 10 , 5 , 15 } ; int b [ ] = { 20 , 3 , 2 , 12 } ; int n = a . length ; int m = b . length ; int res [ ] = new int [ n + m ] ; sorted@@ Merge ( a , b , res , n , m ) ; System . out . print ( " Sorted ▁ merged ▁ list ▁ : " ) ; for ( int i = 0 ; i < n + m ; i ++ ) System . out . print ( " ▁ " + res [ i ] ) ; } }
Find the element that appears once in an array where every other element appears twice 2286 | import java . io . * ; import java . util . Arrays ; class GF@@ G { static int single@@ element ( int arr [ ] , int n ) { int low = 0 , high = n - 2 ; int mid ; while ( low <= high ) { mid = ( low + high ) / 2 ; if ( arr [ mid ] == arr [ mid ^ 1 ] ) { low = mid + 1 ; } else { high = mid - 1 ; } } return arr [ low ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 5 , 4 , 5 , 3 , 4 } ; int size = 7 ; Arrays . sort ( arr ) ; System . out . println ( single@@ element ( arr , size ) ) ; } }
Find the Missing Number 2291 | import java . util . * ; import java . util . Arrays ; class GF@@ G { public static List < Integer > find@@ Dis@@ appe@@ ared@@ Numbers ( int [ ] nums ) { for ( int i = 0 ; i < nums . length ; i ++ ) { int index = Math . abs ( nums [ i ] ) ; if ( nums [ index - 1 ] > 0 ) { nums [ index - 1 ] *= - 1 ; } } List < Integer > res = new ArrayList < > ( ) ; for ( int i = 0 ; i < nums . length ; i ++ ) { if ( nums [ i ] > 0 ) { res . add ( i + 1 ) ; } } return res ; } public static void main ( String [ ] args ) { int [ ] a = { 1 , 2 , 4 , 5 , 6 } ; System . out . println ( find@@ Dis@@ appe@@ ared@@ Numbers ( a ) ) ; } }
Find the Missing Number 2292 | class GF@@ G { static int get@@ Missing@@ No ( int a [ ] , int n ) { int total = 1 ; for ( int i = 2 ; i <= ( n + 1 ) ; i ++ ) { total += i ; total -= a [ i - 2 ] ; } return total ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 5 } ; System . out . println ( get@@ Missing@@ No ( arr , arr . length ) ) ; } }
Find the Missing Number 2294 | class GF@@ G { static int get@@ Missing@@ No ( int a [ ] , int n ) { int n_@@ element@@ s_@@ sum = n * ( n + 1 ) / 2 ; int sum = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) sum += a [ i ] ; return n_@@ element@@ s_@@ sum - sum ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 4 , 5 , 6 } ; int n = a . length + 1 ; int miss = get@@ Missing@@ No ( a , n ) ; System . out . print ( miss ) ; } }
Find four elements that sum to a given value | Set 1 ( n ^ 3 solution ) 2311 | class Find@@ Four@@ Elements { void find@@ Four@@ Elements ( int A [ ] , int n , int X ) { for ( int i = 0 ; i < n - 3 ; i ++ ) { for ( int j = i + 1 ; j < n - 2 ; j ++ ) { for ( int k = j + 1 ; k < n - 1 ; k ++ ) { for ( int l = k + 1 ; l < n ; l ++ ) { if ( A [ i ] + A [ j ] + A [ k ] + A [ l ] == X ) System . out . print ( A [ i ] + " ▁ " + A [ j ] + " ▁ " + A [ k ] + " ▁ " + A [ l ] ) ; } } } } } public static void main ( String [ ] args ) { Find@@ Four@@ Elements find@@ four = new Find@@ Four@@ Elements ( ) ; int A [ ] = { 10 , 20 , 30 , 40 , 1 , 2 } ; int n = A . length ; int X = 91 ; find@@ four . find@@ Four@@ Elements ( A , n , X ) ; } }
Find element in a sorted array whose frequency is greater than or equal to n / 2. 2322 | public class Test { public static int find@@ Maj@@ ority ( int arr [ ] , int n ) { return arr [ n / 2 ] ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 2 , 3 } ; int n = arr . length ; System . out . println ( find@@ Maj@@ ority ( arr , n ) ) ; } }
Least frequ@@ ent element in an array 2349 | import java . io . * ; import java . util . * ; class GF@@ G { static int least@@ Frequ@@ ent ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int min_@@ count = n + 1 , res = - 1 ; int curr_@@ count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) curr_@@ count ++ ; else { if ( curr_@@ count < min_@@ count ) { min_@@ count = curr_@@ count ; res = arr [ i - 1 ] ; } curr_@@ count = 1 ; } } if ( curr_@@ count < min_@@ count ) { min_@@ count = curr_@@ count ; res = arr [ n - 1 ] ; } return res ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 3 , 2 , 1 , 2 , 2 , 3 , 1 } ; int n = arr . length ; System . out . print ( least@@ Frequ@@ ent ( arr , n ) ) ; } }
Find first k natural numbers missing in given array 2374 | import java . io . * ; import java . util . HashMap ; class GF@@ G { static void print@@ missing@@ k ( int arr [ ] , int n , int k ) { HashMap < Integer , Integer > d = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) d . put ( arr [ i ] , arr [ i ] ) ; int cnt = 1 ; int fl = 0 ; for ( int i = 0 ; i < ( n + k ) ; i ++ ) { if ( ! d . containsKey ( cnt ) ) { fl += 1 ; System . out . print ( cnt + " ▁ " ) ; if ( fl == k ) break ; } cnt += 1 ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 4 , 3 } ; int n = arr . length ; int k = 3 ; print@@ missing@@ k ( arr , n , k ) ; } }
Minimum product subset of an array 2381 | class GF@@ G { static int min@@ Product@@ Subset ( int a [ ] , int n ) { if ( n == 1 ) return a [ 0 ] ; int neg@@ max = Integer . MIN_VALUE ; int pos@@ min = Integer . MAX_VALUE ; int count_@@ neg = 0 , count_@@ zero = 0 ; int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { count_@@ zero ++ ; continue ; } if ( a [ i ] < 0 ) { count_@@ neg ++ ; neg@@ max = Math . max ( neg@@ max , a [ i ] ) ; } if ( a [ i ] > 0 && a [ i ] < pos@@ min ) pos@@ min = a [ i ] ; product *= a [ i ] ; } if ( count_@@ zero == n || ( count_@@ neg == 0 && count_@@ zero > 0 ) ) return 0 ; if ( count_@@ neg == 0 ) return pos@@ min ; if ( count_@@ neg % 2 == 0 && count_@@ neg != 0 ) { product = product / neg@@ max ; } return product ; } public static void main ( String [ ] args ) { int a [ ] = { - 1 , - 1 , - 2 , 4 , 3 } ; int n = 5 ; System . out . println ( min@@ Product@@ Subset ( a , n ) ) ; } }
Length of longest pal@@ ind@@ ro@@ me list in a linked list using O ( 1 ) extra space 2469 | class Gf@@ G { static class Node { int data ; Node next ; } static int count@@ Common ( Node a , Node b ) { int count = 0 ; for ( ; a != null && b != null ; a = a . next , b = b . next ) if ( a . data == b . data ) ++ count ; else break ; return count ; } static int max@@ Pal@@ ind@@ ro@@ me ( Node head ) { int result = 0 ; Node prev = null , curr = head ; while ( curr != null ) { Node next = curr . next ; curr . next = prev ; result = Math . max ( result , 2 * count@@ Common ( prev , next ) + 1 ) ; result = Math . max ( result , 2 * count@@ Common ( curr , next ) ) ; prev = curr ; curr = next ; } return result ; } static Node newNode ( int key ) { Node temp = new Node ( ) ; temp . data = key ; temp . next = null ; return temp ; } public static void main ( String [ ] args ) { Node head = newNode ( 2 ) ; head . next = newNode ( 4 ) ; head . next . next = newNode ( 3 ) ; head . next . next . next = newNode ( 4 ) ; head . next . next . next . next = newNode ( 2 ) ; head . next . next . next . next . next = newNode ( 15 ) ; System . out . println ( max@@ Pal@@ ind@@ ro@@ me ( head ) ) ; } }
Remove every k 2477 | class GF@@ G { static class Node { int data ; Node next ; } static Node free@@ List ( Node node ) { while ( node != null ) { Node next = node . next ; node = next ; } return node ; } static Node delete@@ K@@ th@@ Node ( Node head , int k ) { if ( head == null ) return null ; if ( k == 1 ) { head = free@@ List ( head ) ; return null ; } Node ptr = head , prev = null ; int count = 0 ; while ( ptr != null ) { count ++ ; if ( k == count ) { prev . next = ptr . next ; count = 0 ; } if ( count != 0 ) prev = ptr ; ptr = prev . next ; } return head ; } static void display@@ List ( Node head ) { Node temp = head ; while ( temp != null ) { System . out . print ( temp . data + " ▁ " ) ; temp = temp . next ; } } static Node newNode ( int x ) { Node temp = new Node ( ) ; temp . data = x ; temp . next = null ; return temp ; } public static void main ( String args [ ] ) { Node head = newNode ( 1 ) ; head . next = newNode ( 2 ) ; head . next . next = newNode ( 3 ) ; head . next . next . next = newNode ( 4 ) ; head . next . next . next . next = newNode ( 5 ) ; head . next . next . next . next . next = newNode ( 6 ) ; head . next . next . next . next . next . next = newNode ( 7 ) ; head . next . next . next . next . next . next . next = newNode ( 8 ) ; int k = 3 ; head = delete@@ K@@ th@@ Node ( head , k ) ; display@@ List ( head ) ; } }
Find the sum of last n nodes of the given Linked List 2480 | import java . util . * ; class GF@@ G { static class Node { int data ; Node next ; } ; static Node head ; static int n , sum ; static void push ( Node head_@@ ref , int new_data ) { Node new_node = new Node ( ) ; new_node . data = new_data ; new_node . next = head_@@ ref ; head_@@ ref = new_node ; head = head_@@ ref ; } static void sum@@ Of@@ Last@@ N_@@ Nodes ( Node head ) { if ( head == null ) return ; sum@@ Of@@ Last@@ N_@@ Nodes ( head . next ) ; if ( n > 0 ) { sum = sum + head . data ; -- n ; } } static int sum@@ Of@@ Last@@ N_@@ Nodes@@ Util ( Node head , int n ) { if ( n <= 0 ) return 0 ; sum = 0 ; sum@@ Of@@ Last@@ N_@@ Nodes ( head ) ; return sum ; } public static void main ( String [ ] args ) { head = null ; push ( head , 12 ) ; push ( head , 4 ) ; push ( head , 8 ) ; push ( head , 6 ) ; push ( head , 10 ) ; n = 2 ; System . out . print ( " Sum ▁ of ▁ last ▁ " + n + " ▁ nodes ▁ = ▁ " + sum@@ Of@@ Last@@ N_@@ Nodes@@ Util ( head , n ) ) ; } }
Check if a dou@@ bly linked list of characters is pal@@ ind@@ ro@@ me or not 2519 | class GF@@ G { static class Node { char data ; Node next ; Node prev ; } ; static Node push ( Node head_@@ ref , char new_data ) { Node new_node = new Node ( ) ; new_node . data = new_data ; new_node . next = head_@@ ref ; new_node . prev = null ; if ( head_@@ ref != null ) head_@@ ref . prev = new_node ; head_@@ ref = new_node ; return head_@@ ref ; } static boolean is@@ Pal@@ ind@@ ro@@ me ( Node left ) { if ( left == null ) return true ; Node right = left ; while ( right . next != null ) right = right . next ; while ( left != right ) { if ( left . data != right . data ) return false ; left = left . next ; right = right . prev ; } return true ; } public static void main ( String [ ] args ) { Node head = null ; head = push ( head , ' l ' ) ; head = push ( head , ' e ' ) ; head = push ( head , ' v ' ) ; head = push ( head , ' e ' ) ; head = push ( head , ' l ' ) ; if ( is@@ Pal@@ ind@@ ro@@ me ( head ) ) System . out . printf ( " It ▁ is ▁ Pal@@ ind@@ ro@@ me " ) ; else System . out . printf ( " Not ▁ Pal@@ ind@@ ro@@ me " ) ; } }
Print all leaf nodes of a Binary Tree from left to right 2524 | import java . util . * ; class GF@@ G { static class Node { public int data ; public Node left , right ; } ; static void print@@ Leaf@@ Nodes ( Node root ) { if ( root == null ) return ; if ( root . left == null && root . right == null ) { System . out . print ( root . data + " ▁ " ) ; return ; } if ( root . left != null ) print@@ Leaf@@ Nodes ( root . left ) ; if ( root . right != null ) print@@ Leaf@@ Nodes ( root . right ) ; } static Node newNode ( int data ) { Node temp = new Node ( ) ; temp . data = data ; temp . left = null ; temp . right = null ; return temp ; } public static void main ( String [ ] args ) { Node root = newNode ( 1 ) ; root . left = newNode ( 2 ) ; root . right = newNode ( 3 ) ; root . left . left = newNode ( 4 ) ; root . right . left = newNode ( 5 ) ; root . right . right = newNode ( 8 ) ; root . right . left . left = newNode ( 6 ) ; root . right . left . right = newNode ( 7 ) ; root . right . right . left = newNode ( 9 ) ; root . right . right . right = newNode ( 10 ) ; print@@ Leaf@@ Nodes ( root ) ; } }
Print all nodes at distance k from a given node 2527 | class Node { int data ; Node left , right ; Node ( int item ) { data = item ; left = right = null ; } } class Binary@@ Tree { Node root ; void print@@ k@@ distance@@ Node@@ Down ( Node node , int k ) { if ( node == null k < 0 ) return ; if ( k == 0 ) { System . out . print ( node . data ) ; System . out . println ( " " ) ; return ; } print@@ k@@ distance@@ Node@@ Down ( node . left , k - 1 ) ; print@@ k@@ distance@@ Node@@ Down ( node . right , k - 1 ) ; } int print@@ k@@ distance@@ Node ( Node node , Node target , int k ) { if ( node == null ) return - 1 ; if ( node == target ) { print@@ k@@ distance@@ Node@@ Down ( node , k ) ; return 0 ; } int dl = print@@ k@@ distance@@ Node ( node . left , target , k ) ; if ( dl != - 1 ) { if ( dl + 1 == k ) { System . out . print ( node . data ) ; System . out . println ( " " ) ; } else print@@ k@@ distance@@ Node@@ Down ( node . right , k - dl - 2 ) ; return 1 + dl ; } int dr = print@@ k@@ distance@@ Node ( node . right , target , k ) ; if ( dr != - 1 ) { if ( dr + 1 == k ) { System . out . print ( node . data ) ; System . out . println ( " " ) ; } else print@@ k@@ distance@@ Node@@ Down ( node . left , k - dr - 2 ) ; return 1 + dr ; } return - 1 ; } public static void main ( String args [ ] ) { Binary@@ Tree tree = new Binary@@ Tree ( ) ; tree . root = new Node ( 20 ) ; tree . root . left = new Node ( 8 ) ; tree . root . right = new Node ( 22 ) ; tree . root . left . left = new Node ( 4 ) ; tree . root . left . right = new Node ( 12 ) ; tree . root . left . right . left = new Node ( 10 ) ; tree . root . left . right . right = new Node ( 14 ) ; Node target = tree . root . left . right ; tree . print@@ k@@ distance@@ Node ( tree . root , target , 2 ) ; } }
Maxim@@ ize sum of diagonal of a matrix by rot@@ ating all rows or all columns 2558 | import java . util . * ; class GF@@ G { static int N = 3 ; static int find@@ Maximum@@ Diag@@ onal@@ Sum@@ O@@ Matrix@@ f ( int A [ ] [ ] ) { int max@@ Diag@@ onal@@ Sum = Integer . MIN_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { int curr = 0 ; for ( int j = 0 ; j < N ; j ++ ) { curr += A [ j ] [ ( i + j ) % N ] ; } max@@ Diag@@ onal@@ Sum = Math . max ( max@@ Diag@@ onal@@ Sum , curr ) ; } for ( int i = 0 ; i < N ; i ++ ) { int curr = 0 ; for ( int j = 0 ; j < N ; j ++ ) { curr += A [ ( i + j ) % N ] [ j ] ; } max@@ Diag@@ onal@@ Sum = Math . max ( max@@ Diag@@ onal@@ Sum , curr ) ; } return max@@ Diag@@ onal@@ Sum ; } public static void main ( String [ ] args ) { int [ ] [ ] mat = { { 1 , 1 , 2 } , { 2 , 1 , 2 } , { 1 , 2 , 2 } } ; System . out . println ( find@@ Maximum@@ Diag@@ onal@@ Sum@@ O@@ Matrix@@ f ( mat ) ) ; } }
Rotate all odd numbers right and all even numbers left in an Array of 1 to N 2573 | import java . io . * ; import java . util . * ; import java . lang . * ; class GF@@ G { static void left_@@ rotate ( int [ ] arr ) { int last = arr [ 1 ] ; for ( int i = 3 ; i < arr . length ; i = i + 2 ) { arr [ i - 2 ] = arr [ i ] ; } arr [ arr . length - 1 ] = last ; } static void right_@@ rotate ( int [ ] arr ) { int start = arr [ arr . length - 2 ] ; for ( int i = arr . length - 4 ; i >= 0 ; i = i - 2 ) { arr [ i + 2 ] = arr [ i ] ; } arr [ 0 ] = start ; } public static void rotate ( int arr [ ] ) { left_@@ rotate ( arr ) ; right_@@ rotate ( arr ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; rotate ( arr ) ; } }
Count of rot@@ ations required to generate a sorted array 2577 | public class GF@@ G { public static int count@@ Rotation ( int [ ] arr , int low , int high ) { if ( low > high ) { return 0 ; } int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid ] > arr [ mid + 1 ] ) { return mid + 1 ; } if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) { return mid ; } if ( arr [ mid ] > arr [ low ] ) { return count@@ Rotation ( arr , mid + 1 , high ) ; } if ( arr [ mid ] < arr [ high ] ) { return count@@ Rotation ( arr , low , mid - 1 ) ; } else { int right@@ Index = count@@ Rotation ( arr , mid + 1 , high ) ; int left@@ Index = count@@ Rotation ( arr , low , mid - 1 ) ; if ( right@@ Index == 0 ) { return left@@ Index ; } return right@@ Index ; } } public static void main ( String [ ] args ) { int [ ] ar@@ r1 = { 4 , 5 , 1 , 2 , 3 } ; System . out . println ( count@@ Rotation ( ar@@ r1 , 0 , ar@@ r1 . length - 1 ) ) ; } }
Find array sum using Bit@@ wise OR after splitting given array in two hal@@ ves after K circular shifts 2578 | import java . util . * ; class GF@@ G { static int MAX = 10000@@ 5 ; static int [ ] seg = new int [ 4 * MAX ] ; static void build ( int node , int l , int r , int a [ ] ) { if ( l == r ) seg [ node ] = a [ l ] ; else { int mid = ( l + r ) / 2 ; build ( 2 * node , l , mid , a ) ; build ( 2 * node + 1 , mid + 1 , r , a ) ; seg [ node ] = ( seg [ 2 * node ] seg [ 2 * node + 1 ] ) ; } } static int query ( int node , int l , int r , int start , int end , int a [ ] ) { if ( l > end r < start ) return 0 ; if ( start <= l && r <= end ) return seg [ node ] ; int mid = ( l + r ) / 2 ; return ( ( query ( 2 * node , l , mid , start , end , a ) ) | ( query ( 2 * node + 1 , mid + 1 , r , start , end , a ) ) ) ; } static void or@@ sum ( int a [ ] , int n , int q , int k [ ] ) { build ( 1 , 0 , n - 1 , a ) ; for ( int j = 0 ; j < q ; j ++ ) { int i = k [ j ] % ( n / 2 ) ; int sec = query ( 1 , 0 , n - 1 , n / 2 - i , n - i - 1 , a ) ; int first = ( query ( 1 , 0 , n - 1 , 0 , n / 2 - 1 - i , a ) | query ( 1 , 0 , n - 1 , n - i , n - 1 , a ) ) ; int temp = sec + first ; System . out . print ( temp + "@@ NEW_@@ LINE@@ "@@ )@@ ; } } public static void main ( String [ ] args ) { int a [ ] = { 7 , 44 , 19 , 86 , 65 , 39 , 75 , 101 } ; int n = a . length ; int q = 2 ; int k [ ] = { 4 , 2 } ; or@@ sum ( a , n , q , k ) ; } }
Maxim@@ ize count of corresponding same elements in given Arrays by Rotation 2579 | import java . util . * ; class GF@@ G { static void maximum@@ Equal ( int a [ ] , int b [ ] , int n ) { int store [ ] = new int [ ( int ) 1e@@ 5 ] ; for ( int i = 0 ; i < n ; i ++ ) { store [ b [ i ] ] = i + 1 ; } int ans [ ] = new int [ ( int ) 1e@@ 5 ] ; for ( int i = 0 ; i < n ; i ++ ) { int d = Math . abs ( store [ a [ i ] ] - ( i + 1 ) ) ; if ( store [ a [ i ] ] < i + 1 ) { d = n - d ; } ans [ d ] ++ ; } int final@@ ans = 0 ; for ( int i = 0 ; i < 1e@@ 5 ; i ++ ) final@@ ans = Math . max ( final@@ ans , ans [ i ] ) ; System . out . print ( final@@ ans + "@@ NEW_@@ LINE@@ "@@ )@@ ; } public static void main ( String [ ] args ) { int A [ ] = { 6 , 7 , 3 , 9 , 5 } ; int B [ ] = { 7 , 3 , 9 , 5 , 6 } ; int size = A . length ; maximum@@ Equal ( A , B , size ) ; } }
Count rot@@ ations which are di@@ visible by 10 2584 | class GF@@ G { static int count@@ Rotation ( int n ) { int count = 0 ; do { int digit = n % 10 ; if ( digit == 0 ) count ++ ; n = n / 10 ; } while ( n != 0 ) ; return count ; } public static void main ( String [ ] args ) { int n = 10@@ 203 ; System . out . println ( count@@ Rotation ( n ) ) ; } }
Check if it is possible to make array increasing or decre@@ asing by rot@@ ating the array 2586 | class GF@@ G { static boolean is@@ Possible ( int a [ ] , int n ) { if ( n <= 2 ) return true ; int flag = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( ! ( a [ i ] > a [ i + 1 ] && a [ i + 1 ] > a [ i + 2 ] ) ) { flag = 1 ; break ; } } if ( flag == 0 ) return true ; flag = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( ! ( a [ i ] < a [ i + 1 ] && a [ i + 1 ] < a [ i + 2 ] ) ) { flag = 1 ; break ; } } if ( flag == 0 ) return true ; int val1 = Integer . MAX_VALUE , mini = - 1 , val2 = Integer . MIN_VALUE , max@@ i = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] < val1 ) { mini = i ; val1 = a [ i ] ; } if ( a [ i ] > val2 ) { max@@ i = i ; val2 = a [ i ] ; } } flag = 1 ; for ( int i = 0 ; i < max@@ i ; i ++ ) { if ( a [ i ] > a [ i + 1 ] ) { flag = 0 ; break ; } } if ( flag == 1 && max@@ i + 1 == mini ) { flag = 1 ; for ( int i = mini ; i < n - 1 ; i ++ ) { if ( a [ i ] > a [ i + 1 ] ) { flag = 0 ; break ; } } if ( flag == 1 ) return true ; } flag = 1 ; for ( int i = 0 ; i < mini ; i ++ ) { if ( a [ i ] < a [ i + 1 ] ) { flag = 0 ; break ; } } if ( flag == 1 && max@@ i - 1 == mini ) { flag = 1 ; for ( int i = max@@ i ; i < n - 1 ; i ++ ) { if ( a [ i ] < a [ i + 1 ] ) { flag = 0 ; break ; } } if ( flag == 1 ) return true ; } return false ; } public static void main ( String args [ ] ) { int a [ ] = { 4 , 5 , 6 , 2 , 3 } ; int n = a . length ; if ( is@@ Possible ( a , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
Generate all rot@@ ations of a number 2594 | class GF@@ G { static int numberOf@@ Digits ( int n ) { int cnt = 0 ; while ( n > 0 ) { cnt ++ ; n /= 10 ; } return cnt ; } static void cal ( int num ) { int digits = numberOf@@ Digits ( num ) ; int pow@@ Te@@ n = ( int ) Math . pow ( 10 , digits - 1 ) ; for ( int i = 0 ; i < digits - 1 ; i ++ ) { int first@@ Digit = num / pow@@ Te@@ n ; int left = ( ( num * 10 ) + first@@ Digit ) - ( first@@ Digit * pow@@ Te@@ n * 10 ) ; System . out . print ( left + " ▁ " ) ; num = left ; } } public static void main ( String [ ] args ) { int num = 14@@ 45 ; cal ( num ) ; } }
Check whether all the rot@@ ations of a given number is greater than or equal to the given number or not 2596 | class GF@@ G { static void Check@@ K@@ Cycles ( int n , String s ) { boolean ff = true ; int x = 0 ; for ( int i = 1 ; i < n ; i ++ ) { x = ( s . substring ( i ) + s . substring ( 0 , i ) ) . length ( ) ; if ( x >= s . length ( ) ) { continue ; } ff = false ; break ; } if ( ff ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } public static void main ( String [ ] args ) { int n = 3 ; String s = "123" ; Check@@ K@@ Cycles ( n , s ) ; } }
Generating numbers that are divisor of their right 2600 | import java . util . * ; import java . io . * ; class GF@@ G { static void generate@@ Numbers ( int m ) { ArrayList < Integer > numbers = new ArrayList < > ( ) ; int k_@@ max , x ; for ( int y = 0 ; y < 10 ; y ++ ) { k_@@ max = ( int ) ( Math . pow ( 10 , m - 2 ) * ( 10 * y + 1 ) ) / ( int ) ( Math . pow ( 10 , m - 1 ) + y ) ; for ( int k = 1 ; k <= k_@@ max ; k ++ ) { x = ( int ) ( y * ( Math . pow ( 10 , m - 1 ) - k ) ) / ( 10 * k - 1 ) ; if ( ( int ) ( y * ( Math . pow ( 10 , m - 1 ) - k ) ) % ( 10 * k - 1 ) == 0 ) numbers . add ( 10 * x + y ) ; } } Collections . sort ( numbers ) ; for ( int i = 0 ; i < numbers . size ( ) ; i ++ ) System . out . println ( numbers . get ( i ) ) ; } public static void main ( String args [ ] ) { int m = 3 ; generate@@ Numbers ( m ) ; } }
Rotate a matrix by 90 degree in clockwise direction without using any extra space 2604 | import java . io . * ; class GF@@ G { static int N = 4 ; static void rotate@@ 90@@ Clock@@ wise ( int arr [ ] [ ] ) { for ( int j = 0 ; j < N ; j ++ ) { for ( int i = N - 1 ; i >= 0 ; i -- ) System . out . print ( arr [ i ] [ j ] + " ▁ " ) ; System . out . println ( ) ; } } public static void main ( String [ ] args ) { int arr [ ] [ ] = { { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } , { 9 , 10 , 11 , 12 } , { 13 , 14 , 15 , 16 } } ; rotate@@ 90@@ Clock@@ wise ( arr ) ; } }
Sort a Rot@@ ated Sorted Array 2616 | import java . util . * ; class GF@@ G { static int find@@ Start@@ Index@@ Of@@ Array ( int arr [ ] , int low , int high ) { if ( low > high ) { return - 1 ; } if ( low == high ) { return low ; } int mid = low + ( high - low ) / 2 ; if ( arr [ mid ] > arr [ mid + 1 ] ) { return mid + 1 ; } if ( arr [ mid - 1 ] > arr [ mid ] ) { return mid ; } if ( arr [ low ] > arr [ mid ] ) { return find@@ Start@@ Index@@ Of@@ Array ( arr , low , mid - 1 ) ; } else { return find@@ Start@@ Index@@ Of@@ Array ( arr , mid + 1 , high ) ; } } static void restore@@ Sorted@@ Array ( int arr [ ] , int n ) { if ( arr [ 0 ] < arr [ n - 1 ] ) { return ; } int start = find@@ Start@@ Index@@ Of@@ Array ( arr , 0 , n - 1 ) ; Arrays . sort ( arr , 0 , start ) ; Arrays . sort ( arr , start , n ) ; Arrays . sort ( arr ) ; } static void print@@ Array ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = arr . length ; restore@@ Sorted@@ Array ( arr , n ) ; print@@ Array ( arr , n ) ; } }
Types of Linked List 2641 | static class Node { int data ; Node next ; } ;
Remove all even parity nodes from a Dou@@ bly and Cir@@ cul@@ ar Sing@@ ly Linked List 2652 | class GF@@ G { static class Node { int data ; Node next ; } ; static Node push ( Node head_@@ ref , int data ) { Node ptr@@ 1 = new Node ( ) ; Node temp = head_@@ ref ; ptr@@ 1 . data = data ; ptr@@ 1 . next = head_@@ ref ; if ( head_@@ ref != null ) { while ( temp . next != head_@@ ref ) temp = temp . next ; temp . next = ptr@@ 1 ; } else ptr@@ 1 . next = ptr@@ 1 ; head_@@ ref = ptr@@ 1 ; return head_@@ ref ; } static void delete@@ Node ( Node head_@@ ref , Node del ) { if ( head_@@ ref == del ) head_@@ ref = del . next ; Node temp = head_@@ ref ; while ( temp . next != del ) { temp = temp . next ; } temp . next = del . next ; System . gc ( ) ; return ; } static boolean is@@ Even@@ Par@@ ity ( int x ) { int parity = 0 ; while ( x != 0 ) { if ( ( x & 1 ) != 0 ) parity ++ ; x = x >> 1 ; } if ( parity % 2 == 0 ) return true ; else return false ; } static void delete@@ Even@@ Par@@ ity@@ Nodes ( Node head ) { if ( head == null ) return ; if ( head == head . next ) { if ( is@@ Even@@ Par@@ ity ( head . data ) ) head = null ; return ; } Node ptr = head ; Node next ; do { next = ptr . next ; if ( is@@ Even@@ Par@@ ity ( ptr . data ) ) delete@@ Node ( head , ptr ) ; ptr = next ; } while ( ptr != head ) ; if ( head == head . next ) { if ( is@@ Even@@ Par@@ ity ( head . data ) ) head = null ; return ; } } static void print@@ List ( Node head ) { if ( head == null ) { System . out . print ( "@@ Empty List@@ NEW_@@ LINE@@ "@@ )@@ ; return ; } Node temp = head ; if ( head != null ) { do { System . out . printf ( " % d ▁ " , temp . data ) ; temp = temp . next ; } while ( temp != head ) ; } } public static void main ( String [ ] args ) { Node head = null ; head = push ( head , 21 ) ; head = push ( head , 13 ) ; head = push ( head , 6 ) ; head = push ( head , 34 ) ; head = push ( head , 9 ) ; head = push ( head , 11 ) ; delete@@ Even@@ Par@@ ity@@ Nodes ( head ) ; print@@ List ( head ) ; } }
Remove all the Even Digit Sum Nodes from a Cir@@ cul@@ ar Sing@@ ly Linked List 2653 | import java . util . * ; class GF@@ G { static class Node { int data ; Node next ; } ; static Node push ( Node head_@@ ref , int data ) { Node ptr@@ 1 = new Node ( ) ; Node temp = head_@@ ref ; ptr@@ 1 . data = data ; ptr@@ 1 . next = head_@@ ref ; if ( head_@@ ref != null ) { while ( temp . next != head_@@ ref ) temp = temp . next ; temp . next = ptr@@ 1 ; } else ptr@@ 1 . next = ptr@@ 1 ; head_@@ ref = ptr@@ 1 ; return head_@@ ref ; } static void delete@@ Node ( Node head_@@ ref , Node del ) { Node temp = head_@@ ref ; if ( head_@@ ref == del ) head_@@ ref = del . next ; while ( temp . next != del ) { temp = temp . next ; } temp . next = del . next ; del = null ; return ; } static int digit@@ Sum ( int num ) { int sum = 0 ; while ( num > 0 ) { sum += ( num % 10 ) ; num /= 10 ; } return sum ; } static void delete@@ Even@@ Digit@@ Sum@@ Nodes ( Node head ) { Node ptr = head ; Node next ; do { if ( ! ( digit@@ Sum ( ptr . data ) % 2 == 1 ) ) delete@@ Node ( head , ptr ) ; next = ptr . next ; ptr = next ; } while ( ptr != head ) ; } static void print@@ List ( Node head ) { Node temp = head ; if ( head != null ) { do { System . out . printf ( " % d ▁ " , temp . data ) ; temp = temp . next ; } while ( temp != head ) ; } } public static void main ( String [ ] args ) { Node head = null ; head = push ( head , 21 ) ; head = push ( head , 13 ) ; head = push ( head , 6 ) ; head = push ( head , 34 ) ; head = push ( head , 11 ) ; head = push ( head , 9 ) ; delete@@ Even@@ Digit@@ Sum@@ Nodes ( head ) ; print@@ List ( head ) ; } }
Search an Element in Dou@@ bly Cir@@ cul@@ ar Linked List 2673 | class GF@@ G { static class Node { int data ; Node next ; Node prev ; } ; static Node insert@@ Node ( Node start , int value ) { if ( start == null ) { Node new_node = new Node ( ) ; new_node . data = value ; new_node . next = new_node . prev = new_node ; start = new_node ; return new_node ; } Node last = ( start ) . prev ; Node new_node = new Node ( ) ; new_node . data = value ; new_node . next = start ; ( start ) . prev = new_node ; new_node . prev = last ; last . next = new_node ; return start ; } static void display@@ List ( Node start ) { Node temp = start ; while ( temp . next != start ) { System . out . printf ( " % d ▁ " , temp . data ) ; temp = temp . next ; } System . out . printf ( " % d ▁ " , temp . data ) ; } static int search@@ List ( Node start , int search ) { Node temp = start ; int count = 0 , flag = 0 , value ; if ( temp == null ) return - 1 ; else { while ( temp . next != start ) { count ++ ; if ( temp . data == search ) { flag = 1 ; count -- ; break ; } temp = temp . next ; } if ( temp . data == search ) { count ++ ; flag = 1 ; } if ( flag == 1 ) System . out . println ( " " + search ▁ + " found at location "@@ + count@@ )@@ ; else System . out . println ( " " + search ▁ + " not found "@@ )@@ ; } return - 1 ; } public static void main ( String args [ ] ) { Node start = null ; start = insert@@ Node ( start , 4 ) ; start = insert@@ Node ( start , 5 ) ; start = insert@@ Node ( start , 7 ) ; start = insert@@ Node ( start , 8 ) ; start = insert@@ Node ( start , 6 ) ; System . out . printf ( " Created ▁ circular ▁ dou@@ bly ▁ linked ▁ list ▁ is : ▁ " ) ; display@@ List ( start ) ; search@@ List ( start , 5 ) ; } }
Count of all prime weight nodes between given nodes in the given Tree 2682 | import java . util . * ; class GF@@ G { static final int MAX = 1000 ; static int [ ] weight = new int [ MAX ] ; static int [ ] level = new int [ MAX ] ; static int [ ] par = new int [ MAX ] ; static boolean [ ] prime = new boolean [ MAX + 1 ] ; static Vector < Integer > [ ] graph = new Vector [ MAX ] ; static void Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( ) { for ( int i = 0 ; i < prime . length ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= MAX ; i += p ) prime [ i ] = false ; } } } static void dfs ( int node , int parent , int h ) { par [ node ] = parent ; level [ node ] = h ; for ( int child : graph [ node ] ) { if ( child == parent ) continue ; dfs ( child , node , h + 1 ) ; } } static int find@@ Prime@@ On@@ Path ( int u , int v ) { int count = 0 ; if ( level [ u ] > level [ v ] ) { int temp = v ; v = u ; u = temp ; } int d = level [ v ] - level [ u ] ; while ( d -- > 0 ) { if ( prime [ weight [ v ] ] ) count ++ ; v = par [ v ] ; } if ( v == u ) { if ( prime [ weight [ v ] ] ) count ++ ; return count ; } while ( v != u ) { if ( prime [ weight [ v ] ] ) count ++ ; if ( prime [ weight [ u ] ] ) count ++ ; u = par [ u ] ; v = par [ v ] ; } if ( prime [ weight [ v ] ] ) count ++ ; return count ; } public static void main ( String [ ] args ) { for ( int i = 0 ; i < graph . length ; i ++ ) graph [ i ] = new Vector < Integer > ( ) ; Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( ) ; weight [ 1 ] = 5 ; weight [ 2 ] = 10 ; weight [ 3 ] = 11 ; weight [ 4 ] = 8 ; weight [ 5 ] = 6 ; graph [ 1 ] . add ( 2 ) ; graph [ 2 ] . add ( 3 ) ; graph [ 2 ] . add ( 4 ) ; graph [ 1 ] . add ( 5 ) ; dfs ( 1 , - 1 , 0 ) ; int u = 3 , v = 5 ; System . out . print ( find@@ Prime@@ On@@ Path ( u , v ) ) ; } }
Minimum and maximum node that lies in the path connecting two nodes in a Binary Tree 2689 | import java . util . * ; class GF@@ G { static class Node { Node left ; Node right ; int data ; } ; static Node newNode ( int key ) { Node node = new Node ( ) ; node . left = node . right = null ; node . data = key ; return node ; } static Vector < Integer > path ; static boolean Find@@ Path ( Node root , int key ) { if ( root == null ) return false ; path . add ( root . data ) ; if ( root . data == key ) return true ; if ( Find@@ Path ( root . left , key ) || Find@@ Path ( root . right , key ) ) return true ; path . remove ( path . size ( ) - 1 ) ; return false ; } static int min@@ Max@@ Node@@ In@@ Path ( Node root , int a , int b ) { path = new Vector < Integer > ( ) ; boolean flag = true ; Vector < Integer > Path@@ 2 = new Vector < Integer > ( ) , Path@@ 1 = new Vector < Integer > ( ) ; int min@@ 1 = Integer . MAX_VALUE ; int max@@ 1 = Integer . MIN_VALUE ; int min@@ 2 = Integer . MAX_VALUE ; int max@@ 2 = Integer . MIN_VALUE ; int i = 0 ; int j = 0 ; flag = Find@@ Path ( root , a ) ; Path@@ 1 = path ; path = new Vector < Integer > ( ) ; flag &= Find@@ Path ( root , b ) ; Path@@ 2 = path ; if ( flag ) { for ( i = 0 ; i < Path@@ 1 . size ( ) && i < Path@@ 2 . size ( ) ; i ++ ) if ( Path@@ 1 . get ( i ) != Path@@ 2 . get ( i ) ) break ; i -- ; j = i ; for ( ; i < Path@@ 1 . size ( ) ; i ++ ) { if ( min@@ 1 > Path@@ 1 . get ( i ) ) min@@ 1 = Path@@ 1 . get ( i ) ; if ( max@@ 1 < Path@@ 1 . get ( i ) ) max@@ 1 = Path@@ 1 . get ( i ) ; } for ( ; j < Path@@ 2 . size ( ) ; j ++ ) { if ( min@@ 2 > Path@@ 2 . get ( j ) ) min@@ 2 = Path@@ 2 . get ( j ) ; if ( max@@ 2 < Path@@ 2 . get ( j ) ) max@@ 2 = Path@@ 2 . get ( j ) ; } System . out . println ( " Min ▁ = ▁ " + Math . min ( min@@ 1 , min@@ 2 ) ) ; System . out . println ( " Max ▁ = ▁ " + Math . max ( max@@ 1 , max@@ 2 ) ) ; } else System . out . println ( "@@ Min = -1 Max = - 1 "@@ )@@ ; return 0 ; } public static void main ( String args [ ] ) { Node root = newNode ( 20 ) ; root . left = newNode ( 8 ) ; root . right = newNode ( 22 ) ; root . left . left = newNode ( 5 ) ; root . left . right = newNode ( 3 ) ; root . right . left = newNode ( 4 ) ; root . right . right = newNode ( 25 ) ; root . left . right . left = newNode ( 10 ) ; root . left . right . right = newNode ( 14 ) ; int a = 5 ; int b = 14 ; min@@ Max@@ Node@@ In@@ Path ( root , a , b ) ; } }
L@@ CA for general or n 2698 | import java . util . * ; class GF@@ G { static final int MAX@@ N = 10000@@ 1 ; static Vector < Integer > [ ] tree = new Vector [ MAX@@ N ] ; static int [ ] [ ] path = new int [ 3 ] [ MAX@@ N ] ; static boolean flag ; static void dfs ( int cur , int prev , int path@@ Number , int ptr , int node ) { for ( int i = 0 ; i < tree [ cur ] . size ( ) ; i ++ ) { if ( tree [ cur ] . get ( i ) != prev && ! flag ) { path [ path@@ Number ] [ ptr ] = tree [ cur ] . get ( i ) ; if ( tree [ cur ] . get ( i ) == node ) { flag = true ; path [ path@@ Number ] [ ptr + 1 ] = - 1 ; return ; } dfs ( tree [ cur ] . get ( i ) , cur , path@@ Number , ptr + 1 , node ) ; } } } static int L@@ CA ( int a , int b ) { if ( a == b ) return a ; path [ 1 ] [ 0 ] = path [ 2 ] [ 0 ] = 1 ; flag = false ; dfs ( 1 , 0 , 1 , 1 , a ) ; flag = false ; dfs ( 1 , 0 , 2 , 1 , b ) ; int i = 0 ; while ( i < MAX@@ N && path [ 1 ] [ i ] == path [ 2 ] [ i ] ) i ++ ; return path [ 1 ] [ i - 1 ] ; } static void addEdge ( int a , int b ) { tree [ a ] . add ( b ) ; tree [ b ] . add ( a ) ; } public static void main ( String [ ] args ) { for ( int i = 0 ; i < MAX@@ N ; i ++ ) tree [ i ] = new Vector < Integer > ( ) ; addEdge ( 1 , 2 ) ; addEdge ( 1 , 3 ) ; addEdge ( 2 , 4 ) ; addEdge ( 2 , 5 ) ; addEdge ( 2 , 6 ) ; addEdge ( 3 , 7 ) ; addEdge ( 3 , 8 ) ; System . out . print ( " L@@ CA ( 4 , ▁ 7 ) ▁ = ▁ " + L@@ CA ( 4 , 7 ) + "@@ NEW_@@ LINE@@ "@@ )@@ ; System . out . print ( " L@@ CA ( 4 , ▁ 6 ) ▁ = ▁ " + L@@ CA ( 4 , 6 ) + "@@ NEW_@@ LINE@@ "@@ )@@ ; } }
Check if a large number is di@@ visible by a number which is a power of 2 2719 | class GF@@ G { static boolean check@@ If@@ Di@@ visible ( String str , long num ) { long power@@ Of@@ 2 = ( int ) ( Math . log ( num ) / Math . log ( 2 ) ) ; if ( str . length ( ) < power@@ Of@@ 2 ) return false ; if ( power@@ Of@@ 2 == 0 ) return true ; long i , number = 0 ; int len = str . length ( ) ; for ( i = len - power@@ Of@@ 2 ; i < len ; i ++ ) { number += ( str . charAt ( ( int ) i ) - '0' ) * Math . pow ( 10 , power@@ Of@@ 2 - 1 ) ; power@@ Of@@ 2 -- ; } if ( number % num != 0 ) return false ; else return true ; } public static void main ( String [ ] args ) { String str = "@@ 213@@ 467@@ 75@@ 65@@ 64" ; long num = 4 ; if ( check@@ If@@ Di@@ visible ( str , num ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
Maximum length of sub@@ array such that all elements are equal in the sub@@ array 2731 | import java . util . * ; class GF@@ G { static int lon@@ gest_@@ sub@@ array ( int arr [ ] , int d ) { int i = 0 , j = 1 , e = 0 ; for ( i = 0 ; i < d - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { j = j + 1 ; } else { j = 1 ; } if ( e < j ) { e = j ; } } return e ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int N = arr . length ; System . out . print ( lon@@ gest_@@ sub@@ array ( arr , N ) ) ; } }
Nodes with prime degree in an un@@ directed Graph 2762 | import java . util . * ; class GF@@ G { static int n = 100@@ 05 ; static boolean [ ] Prime = new boolean [ n + 1 ] ; static void Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( ) { int i , j ; Prime [ 0 ] = Prime [ 1 ] = false ; for ( i = 2 ; i * i <= 100@@ 05 ; i ++ ) { if ( Prime [ i ] ) { for ( j = 2 * i ; j < 100@@ 05 ; j += i ) { Prime [ j ] = false ; } } } } static void prime@@ Degree@@ Nodes ( int N , int M , int edges [ ] [ ] ) { Vector < Integer > [ ] Ad@@ j = new Vector [ N + 1 ] ; for ( int i = 0 ; i < Ad@@ j . length ; i ++ ) Ad@@ j [ i ] = new Vector < Integer > ( ) ; for ( int i = 0 ; i < M ; i ++ ) { int x = edges [ i ] [ 0 ] ; int y = edges [ i ] [ 1 ] ; Ad@@ j [ x ] . add ( y ) ; Ad@@ j [ y ] . add ( x ) ; } Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( ) ; for ( int i = 1 ; i <= N ; i ++ ) { int x = Ad@@ j [ i ] . size ( ) ; if ( Prime [ x ] ) System . out . print ( i + " ▁ " ) ; } } public static void main ( String [ ] args ) { int N = 4 , M = 6 ; int edges [ ] [ ] = { { 1 , 2 } , { 1 , 3 } , { 1 , 4 } , { 2 , 3 } , { 2 , 4 } , { 3 , 4 } } ; Arrays . fill ( Prime , true ) ; prime@@ Degree@@ Nodes ( N , M , edges ) ; } }
Number of ways to color N 2765 | import java . util . * ; class GF@@ G { static int mod = 100000000@@ 7 ; static int count@@ W@@ ays ( int colored [ ] , int count , int n ) { if ( count == n ) { return 1 ; } int answer = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { if ( colored [ i ] == 0 ) { if ( colored [ i - 1 ] == 1 colored [ i + 1 ] == 1 ) { colored [ i ] = 1 ; answer = ( answer + count@@ W@@ ays ( colored , count + 1 , n ) ) % mod ; colored [ i ] = 0 ; } } } return answer ; } static int way@@ sTo@@ Color ( int arr [ ] , int n , int k ) { int colored [ ] = new int [ n + 2 ] ; for ( int i = 0 ; i < k ; i ++ ) { colored [ arr [ i ] ] = 1 ; } return count@@ W@@ ays ( colored , k , n ) ; } public static void main ( String [ ] args ) { int N = 6 ; int K = 3 ; int arr [ ] = { 1 , 2 , 6 } ; System . out . print ( way@@ sTo@@ Color ( arr , N , K ) ) ; } }
Check if a Sequence is a concatenation of two permutations 2779 | import java . util . * ; class GF@@ G { static boolean check@@ Permutation ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; int [ ] prefix = new int [ n + 1 ] ; Arrays . fill ( prefix , 0 ) ; prefix [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix [ i ] = prefix [ i - 1 ] + arr [ i ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int l@@ sum = prefix [ i ] ; int r@@ sum = sum - prefix [ i ] ; int l_@@ len = i + 1 , r_@@ len = n - i - 1 ; if ( ( ( 2 * l@@ sum ) == ( l_@@ len * ( l_@@ len + 1 ) ) ) && ( ( 2 * r@@ sum ) == ( r_@@ len * ( r_@@ len + 1 ) ) ) ) return true ; } return false ; } public static void main ( String args [ ] ) { int [ ] arr = { 1 , 2 , 5 , 3 , 4 , 1 , 2 } ; int n = arr . length ; if ( check@@ Permutation ( arr , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
Find Next number having distinct digits from the given number N 2781 | class GF@@ G { static void find@@ Next@@ Number ( int n ) { int h [ ] = new int [ 10 ] ; int i = 0 , ms@@ b = n , rem = 0 ; int next_@@ num = - 1 , count = 0 ; while ( ms@@ b > 9 ) { rem = ms@@ b % 10 ; h [ rem ] = 1 ; ms@@ b /= 10 ; count ++ ; } h [ ms@@ b ] = 1 ; count ++ ; for ( i = ms@@ b + 1 ; i < 10 ; i ++ ) { if ( h [ i ] == 0 ) { next_@@ num = i ; break ; } } if ( next_@@ num == - 1 ) { for ( i = 1 ; i < ms@@ b ; i ++ ) { if ( h [ i ] == 0 ) { next_@@ num = i ; count ++ ; break ; } } } if ( next_@@ num > 0 ) { for ( i = 0 ; i < 10 ; i ++ ) { if ( h [ i ] == 0 ) { ms@@ b = i ; break ; } } for ( i = 1 ; i < count ; i ++ ) { next_@@ num = ( ( next_@@ num * 10 ) + ms@@ b ) ; } if ( next_@@ num > n ) System . out . print ( next_@@ num + "@@ NEW_@@ LINE@@ "@@ )@@ ; else System . out . print ( "@@ Not Possible NEW_@@ LINE@@ "@@ )@@ ; } else { System . out . print ( "@@ Not Possible NEW_@@ LINE@@ "@@ )@@ ; } } public static void main ( String [ ] args ) { int n = 2019 ; find@@ Next@@ Number ( n ) ; } }
Find a N 2782 | class GF@@ G { static void find@@ The@@ Number ( int n ) { if ( n == 1 ) { System . out . print ( " Imp@@ ossible " + "@@ NEW_@@ LINE@@ "@@ )@@ ; return ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { System . out . print ( "5" ) ; } System . out . print ( "4" ) ; } public static void main ( String [ ] args ) { int n = 12 ; find@@ The@@ Number ( n ) ; } }
Queries to check whether bitwise AND of a sub@@ array is even or odd 2784 | class GF@@ G { static final int MAX@@ N = 10000@@ 05 ; static int even [ ] = new int [ MAX@@ N ] ; static int odd [ ] = new int [ MAX@@ N ] ; static void pre@@ compute ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) odd [ i ] = 1 ; if ( arr [ i ] % 2 == 0 ) even [ i ] = 1 ; } for ( int i = 1 ; i < n ; i ++ ) { even [ i ] = even [ i ] + even [ i - 1 ] ; odd [ i ] = odd [ i ] + odd [ i - 1 ] ; } } static boolean is@@ Odd ( int L , int R ) { int cnt = odd [ R ] ; if ( L > 0 ) cnt -= odd [ L - 1 ] ; if ( cnt == R - L + 1 ) return true ; return false ; } static void perform@@ Queries ( int a [ ] , int n , int q [ ] [ ] , int m ) { pre@@ compute ( a , n ) ; for ( int i = 0 ; i < m ; i ++ ) { int L = q [ i ] [ 0 ] , R = q [ i ] [ 1 ] ; if ( is@@ Odd ( L , R ) ) System . out . println ( " Odd " ) ; else System . out . println ( " Even " ) ; } } public static void main ( String args [ ] ) { int [ ] a = { 2 , 1 , 5 , 7 , 6 , 8 , 9 } ; int n = a . length ; int q [ ] [ ] = { { 0 , 2 } , { 1 , 2 } , { 2 , 3 } , { 3 , 6 } } ; int m = q . length ; perform@@ Queries ( a , n , q , m ) ; } }
Op@@ ti@@ mal Strategy for a Game | Special G@@ old Coin 2797 | import java . util . * ; class GF@@ G { static String get@@ Win@@ ner ( String str , int len ) { int total = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str . charAt ( i ) == ' S ' ) { total ++ ; } } if ( ( total % 2 ) == 1 ) return " First " ; return " Second " ; } public static void main ( String [ ] args ) { String str = " GS@@ SS " ; int len = str . length ( ) ; System . out . println ( get@@ Win@@ ner ( str , len ) ) ; } }
Re@@ arrange array elements such that Bit@@ wise AND of first N 2799 | import java . util . * ; class GF@@ G { static void print@@ Arr ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } static void find@@ Arrange@@ ment ( int arr [ ] , int n ) { if ( n < 2 ) { System . out . print ( " - 1" ) ; return ; } int min@@ Val = Arrays . stream ( arr ) . min ( ) . getAs@@ Int ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == min@@ Val ) { swap ( arr , i , n - 1 ) ; break ; } } int and@@ Val = arr [ 0 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { and@@ Val &= arr [ i ] ; } if ( and@@ Val == arr [ n - 1 ] ) print@@ Arr ( arr , n ) ; else System . out . print ( " - 1" ) ; } static int [ ] swap ( int [ ] arr , int i , int j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; return arr ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 3 , 3 } ; int n = arr . length ; find@@ Arrange@@ ment ( arr , n ) ; } }
Maximum prime moves to convert X to Y 2800 | class GF@@ G { static int max@@ Operations ( int X , int Y ) { if ( X > Y ) return - 1 ; int diff = Y - X ; if ( diff == 1 ) return - 1 ; if ( diff % 2 == 0 ) return ( diff / 2 ) ; return ( 1 + ( ( diff - 3 ) / 2 ) ) ; } public static void main ( String [ ] args ) { int X = 5 , Y = 16 ; System . out . println ( max@@ Operations ( X , Y ) ) ; } }
Random list of M non 2810 | class GF@@ G { static void print@@ Arr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } static void random@@ List ( int m , int n ) { int arr [ ] = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ ( int ) ( Math . random ( ) * m ) ] ++ ; } print@@ Arr ( arr , m ) ; } public static void main ( String args [ ] ) { int m = 4 , n = 8 ; random@@ List ( m , n ) ; } }
Find maximum value of the last element after redu@@ cing the array with given operations 2829 | import java . io . * ; class GF@@ G { static int find_@@ maximum@@ _value ( int a [ ] , int n ) { int sum = 0 ; int minimum = Integer . MAX_VALUE ; int pos = 0 , neg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { minimum = Math . min ( minimum , Math . abs ( a [ i ] ) ) ; sum += Math . abs ( a [ i ] ) ; if ( a [ i ] >= 0 ) pos += 1 ; else neg += 1 ; } if ( pos > 0 && neg > 0 ) return sum ; return ( sum - 2 * minimum ) ; } public static void main ( String [ ] args ) { int [ ] a = { 5 , 4 , 6 , 2 } ; int n = a . length ; System . out . println ( find_@@ maximum@@ _value ( a , n ) ) ; } }
Find smallest number K such that K % p = 0 and q % K = 0 2841 | import java . io . * ; class GF@@ G { static int getMin@@ Val ( int p , int q ) { if ( q % p == 0 ) return p ; return - 1 ; } public static void main ( String [ ] args ) { int p = 24 , q = 48 ; System . out . println ( getMin@@ Val ( p , q ) ) ; } }
Lex@@ ico@@ graphic@@ ally smallest string with given string as prefix 2883 | import java . util . Arrays ; class GF@@ G { static boolean is_@@ prefix ( String temp , String str ) { if ( temp . length ( ) < str . length ( ) ) return false ; else { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) != temp . charAt ( i ) ) return false ; } return true ; } } static String lex@@ ico@@ graphic@@ ally@@ String ( String [ ] input , int n , String str ) { Arrays . sort ( input ) ; for ( int i = 0 ; i < n ; i ++ ) { String temp = input [ i ] ; if ( is_@@ prefix ( temp , str ) ) { return temp ; } } return " - 1" ; } public static void main ( String args [ ] ) { String [ ] arr = { " apple " , " appe " , " ap@@ l " , " a@@ ap@@ l " , " app@@ ax " } ; String S = " app " ; int N = 5 ; System . out . println ( lex@@ ico@@ graphic@@ ally@@ String ( arr , N , S ) ) ; } }
Minim@@ ize the sum of pair which upon removing divi@@ des the Array into 3 sub@@ arrays 2884 | class GF@@ G { static int min@@ Sum@@ Pair ( int arr [ ] , int N ) { if ( N < 5 ) { return - 1 ; } int [ ] prefix@@ Min = new int [ N ] ; prefix@@ Min [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < N - 1 ; i ++ ) { prefix@@ Min [ i ] = Math . min ( arr [ i ] , prefix@@ Min [ i - 1 ] ) ; } int ans = Integer . MAX_VALUE ; for ( int i = 3 ; i < N - 1 ; i ++ ) { ans = Math . min ( ans , arr [ i ] + prefix@@ Min [ i - 2 ] ) ; } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 2 , 4 , 6 , 3 , 7 } ; int N = arr . length ; System . out . print ( min@@ Sum@@ Pair ( arr , N ) + "@@ NEW_@@ LINE@@ "@@ )@@ ; } }
Count of different numbers di@@ visible by 3 that can be obtained by changing at most one digit 2887 | import java . io . * ; import java . util . * ; class GF@@ G { public static void find@@ Count ( String number ) { int sum = 0 ; for ( int i = 0 ; i < number . length ( ) ; ++ i ) { sum += number . charAt ( i ) - 48 ; } int count = 0 ; for ( int i = 0 ; i < number . length ( ) ; ++ i ) { int remaining_@@ sum = sum - ( number . charAt ( i ) - 48 ) ; for ( int j = 0 ; j <= 9 ; ++ j ) { if ( ( remaining_@@ sum + j ) % 3 == 0 && j != number . charAt ( i ) - 48 ) { ++ count ; } } } System . out . println ( count ) ; } public static void main ( String [ ] args ) { String number = "@@ 23@@ 5" ; find@@ Count ( number ) ; } }
Maxim@@ ize the smallest array element by increment@@ ing all elements in a K 2894 | class GF@@ G { static long n , m , k , l , r , i ; static boolean check ( long v , long [ ] a ) { long te@@ c = 0 , ans = 0 ; long [ ] b = new long [ ( int ) ( n + k + 1 ) ] ; for ( int i = 0 ; i < n ; i ++ ) { te@@ c -= b [ i ] ; if ( a [ i ] + te@@ c < v ) { long mov = v - a [ i ] - te@@ c ; ans = ans + mov ; te@@ c += mov ; b [ i + ( int ) k ] = mov ; } } return ans <= m ; } static long Find@@ Lar@@ gest ( long [ ] a ) { l = 1 ; r = ( long ) Math . pow ( 10 , 10 ) ; while ( r - l > 0 ) { long tm = ( l + r + 1 ) / 2 ; if ( check ( tm , a ) ) l = tm ; else r = tm - 1 ; } return l ; } public static void main ( String [ ] args ) { long [ ] a = { 2 , 2 , 2 , 2 , 1 , 1 } ; m = 2 ; k = 3 ; n = a . length ; System . out . println ( Find@@ Lar@@ gest ( a ) ) ; } }
Maxim@@ ize boxes required to keep at least one black and one white sh@@ ir@@ t 2912 | import java . util . * ; class GF@@ G { static void number@@ of@@ Boxes ( int W , int B , int O ) { int low = 0 , high = Math . min ( W , B ) ; int ans = 0 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( ( ( W >= mid ) && ( B >= mid ) ) && ( ( W - mid ) + ( B - mid ) + O ) >= mid ) { ans = mid ; low = mid + 1 ; } else high = mid - 1 ; } System . out . println ( ans ) ; } public static void main ( String args [ ] ) { int W = 3 , B = 3 , O = 1 ; number@@ of@@ Boxes ( W , B , O ) ; } }
Find all possible pairs with given Bit@@ wise OR and Bit@@ wise XOR values 2942 | import java . util . * ; class GF@@ G { static void find@@ Pairs ( int A , int B ) { for ( int i = 1 ; i <= B ; i ++ ) { int y = A ^ i ; if ( y > 0 && ( i y ) == B ) { System . out . println ( i + " ▁ " + y ) ; } } } public static void main ( String [ ] args ) { int A = 8 , B = 10 ; find@@ Pairs ( A , B ) ; } }
Find Unique ID and Domain Name of a Web@@ site from a string 2946 | import java . util . * ; class GF@@ G { static boolean is@@ char ( char x ) { if ( ( x >= ' A ' && x <= ' Z ' ) || ( x >= ' a ' && x <= ' z ' ) ) { return true ; } return false ; } static boolean is@@ num ( char x ) { if ( x >= '0' && x <= '9' ) return true ; return false ; } static void find@@ Id@@ and@@ Domain ( String S , int N ) { String ID = " " , Domain = " " ; Vector < String > words = new Vector < String > ( ) ; String curr = " " ; for ( int i = 0 ; i < N ; i ++ ) { if ( S . charAt ( i ) == ' ▁ ' ) { words . add ( curr ) ; curr = " " ; } else { if ( S . charAt ( i ) == ' . ' ) { if ( i + 1 == N || ( i + 1 < N && S . charAt ( i + 1 ) == ' ▁ ' ) ) continue ; } curr += S . charAt ( i ) ; } } if ( curr . length ( ) > 0 ) words . add ( curr ) ; for ( String ss : words ) { if ( ss . length ( ) == 10 ) { boolean flag = false ; for ( int j = 0 ; j <= 9 ; j ++ ) { if ( j >= 5 && j < 9 ) { if ( is@@ num ( ss . charAt ( j ) ) == false ) flag = true ; } else { if ( is@@ char ( ss . charAt ( j ) ) == false ) flag = true ; } } if ( ! flag ) { ID = ss ; } } if ( ss . length ( ) > 2 && ss . substring ( 0 , 3 ) . equals ( " www " ) && ss . substring ( ss . length ( ) - 3 ) . equals ( " com " ) ) { Domain = ss . substring ( 4 , ss . length ( ) ) ; } } System . out . print ( " ID ▁ = ▁ " + ID + "@@ NEW_@@ LINE@@ "@@ )@@ ; System . out . print ( " Domain ▁ = ▁ " + Domain ) ; } public static void main ( String [ ] args ) { String S = " We ▁ th@@ ank ▁ ABC@@ DE@@ 1234@@ F ▁ for ▁ visi@@ ting ▁ " + " us ▁ and ▁ bu@@ ying ▁ products ▁ item ▁ AM@@ Z@@ rr @ ! k . ▁ " + " For ▁ more ▁ offers , ▁ visit ▁ us ▁ at ▁ www . amazon . com " ; int N = S . length ( ) ; find@@ Id@@ and@@ Domain ( S , N ) ; } }
Count trip@@ lets from a sorted array having difference between adjacent elements equal to D 2958 | import java . util . * ; class GF@@ G { static int count@@ Trip@@ lets ( int D , int [ ] arr ) { HashMap < Integer , Integer > freq = new HashMap < Integer , Integer > ( ) ; int ans = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( freq . containsKey ( arr [ i ] - D ) && freq . containsKey ( arr [ i ] - 2 * D ) ) { ans += freq . get ( arr [ i ] - D ) * freq . get ( arr [ i ] - 2 * D ) ; } if ( freq . containsKey ( arr [ i ] ) ) { freq . put ( arr [ i ] , freq . get ( arr [ i ] ) + 1 ) ; } else { freq . put ( arr [ i ] , 1 ) ; } } return ans ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 4 , 5 , 7 , 8 , 10 } ; int D = 1 ; System . out . print ( count@@ Trip@@ lets ( D , arr ) ) ; } }
Size of smallest square that contains N non 2978 | class GF@@ G { static boolean bound ( int w , int h , int N , int x ) { int val = ( x / w ) * ( x / h ) ; if ( val >= N ) return true ; else return false ; } static int Find@@ Square ( int N , int W , int H ) { int i = 1 ; int j = W * H * N ; while ( i < j ) { int mid = i + ( j - i ) / 2 ; if ( bound ( W , H , N , mid ) ) j = mid ; else i = mid + 1 ; } return j ; } public static void main ( String [ ] args ) { int W = 2 ; int H = 3 ; int N = 10 ; System . out . print ( Find@@ Square ( N , W , H ) ) ; } }
Check if a number can be represented as a sum of a Prime Number and a Perf@@ ect Square 2992 | import java . util . * ; class GF@@ G { static void Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( boolean prime [ ] , int n ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) { prime [ i ] = false ; } } } } static void sum@@ Of@@ Prime@@ Square ( int n ) { boolean flag = false ; boolean [ ] prime = new boolean [ n + 1 ] ; for ( int i = 0 ; i < prime . length ; i ++ ) prime [ i ] = true ; Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( prime , n ) ; for ( int i = 0 ; i <= n ; i ++ ) { if ( ! prime [ i ] ) continue ; int dif = n - i ; if ( Math . ceil ( ( double ) Math . sqrt ( dif ) ) == Math . floor ( ( double ) Math . sqrt ( dif ) ) ) { flag = true ; break ; } } if ( flag ) { System . out . print ( " Yes " ) ; } else System . out . print ( " No " ) ; } public static void main ( String [ ] args ) { int N = 27 ; sum@@ Of@@ Prime@@ Square ( N ) ; } }
Check if any sub@@ array of length M repeats at least K times consec@@ uti@@ vely or not 2995 | import java . io . * ; import java . lang . * ; import java . util . * ; class GF@@ G { static boolean check ( int arr [ ] , int M , int K , int ind ) { for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 1 ; j < K ; j ++ ) { if ( arr [ ind + i ] != arr [ ind + i + j * M ] ) { return false ; } } } return true ; } static boolean Sub@@ array@@ Repeat@@ s@@ K@@ or@@ More ( int arr [ ] , int N , int M , int K ) { for ( int ind = 0 ; ind <= N - M * K ; ind ++ ) { if ( check ( arr , M , K , ind ) ) { return true ; } } return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 1 , 2 , 1 , 1 , 1 , 3 } ; int M = 2 , K = 2 ; int N = arr . length ; if ( Sub@@ array@@ Repeat@@ s@@ K@@ or@@ More ( arr , N , M , K ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
S@@ malle@@ st value of N such that the sum of all natural numbers from K to N is at least X 2998 | import java . io . * ; import java . lang . * ; import java . util . * ; class GF@@ G { static void minimum@@ Number ( int K , int X ) { if ( K > X ) { System . out . println ( " - 1" ) ; return ; } int ans = 0 ; int sum = 0 ; for ( int i = K ; i <= X ; i ++ ) { sum += i ; if ( sum >= X ) { ans = i ; break ; } } System . out . println ( ans ) ; } public static void main ( String [ ] args ) { int K = 5 , X = 13 ; minimum@@ Number ( K , X ) ; } }
Find the peak index of a given array 3010 | import java . io . * ; import java . util . * ; class GF@@ G { public static int peak@@ Index ( int [ ] arr ) { int N = arr . length ; if ( arr . length < 3 ) return - 1 ; int i = 0 ; while ( i + 1 < N ) { if ( arr [ i + 1 ] < arr [ i ] arr [ i ] == arr [ i + 1 ] ) break ; i ++ ; } if ( i == 0 i == N - 1 ) return - 1 ; int ans = i ; while ( i < N - 1 ) { if ( arr [ i ] < arr [ i + 1 ] arr [ i ] == arr [ i + 1 ] ) break ; i ++ ; } if ( i == N - 1 ) return ans ; return - 1 ; } public static void main ( String [ ] args ) { int [ ] arr = { 0 , 1 , 0 } ; System . out . println ( peak@@ Index ( arr ) ) ; } }
Count pairs ( i , j ) from an array such that | arr [ i ] | and | arr [ j ] | both lies between | arr [ i ] 3018 | import java . util . Arrays ; class GF@@ G { static void find@@ Pairs ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) arr [ i ] = Math . abs ( arr [ i ] ) ; Arrays . sort ( arr ) ; int left = 0 ; int ans = 0 ; for ( int right = 0 ; right < N ; right ++ ) { while ( 2 * arr [ left ] < arr [ right ] ) left ++ ; ans += ( right - left ) ; } System . out . print ( ans ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 5 , 7 } ; int N = arr . length ; find@@ Pairs ( arr , N ) ; } }
Number of sub@@ arrays having even product 3038 | import java . io . * ; class GF@@ G { static void even@@ product ( int arr [ ] , int length ) { int count = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { int product = 1 ; for ( int j = i ; j < arr . length ; j ++ ) { product *= arr [ j ] ; if ( product % 2 == 0 ) ++ count ; } } System . out . println ( count ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 7 , 5 , 4 , 9 } ; int length = arr . length - 1 ; even@@ product ( arr , length ) ; } }
Count ways to partition a Binary String such that each substring contains exactly two 0 s 3132 | import java . util . * ; class GF@@ G { static int total@@ W@@ ays ( int n , String str ) { ArrayList < Integer > Idx@@ Of@@ 0@@ s = new ArrayList < Integer > ( ) ; int cnt@@ W@@ ays = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == '0' ) { Idx@@ Of@@ 0@@ s . add ( i ) ; } } int M = Idx@@ Of@@ 0@@ s . size ( ) ; if ( ( M == 0 ) || ( ( M % 2 ) != 0 ) ) { return 0 ; } for ( int i = 2 ; i < M ; i += 2 ) { cnt@@ W@@ ays = cnt@@ W@@ ays * ( Idx@@ Of@@ 0@@ s . get ( i ) - Idx@@ Of@@ 0@@ s . get ( i - 1 ) ) ; } return cnt@@ W@@ ays ; } public static void main ( String [ ] args ) { String str = "00@@ 100" ; int n = str . length ( ) ; System . out . print ( total@@ W@@ ays ( n , str ) ) ; } }
Count sub@@ arrays consisting of first K natural numbers in descending order 3140 | import java . util . * ; class GF@@ G { static int Count@@ Sub@@ array ( int arr [ ] , int n , int k ) { int temp = k , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == temp ) { if ( temp == 1 ) { count ++ ; temp = k ; } else temp -- ; } else { temp = k ; if ( arr [ i ] == k ) i -- ; } } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 7 , 9 , 3 , 2 , 1 , 8 , 3 , 2 , 1 } ; int N = arr . length ; int K = 3 ; System . out . println ( Count@@ Sub@@ array ( arr , N , K ) ) ; } }
Count di@@ visors which generates same Quo@@ ti@@ ent and Remain@@ der 3171 | class GF@@ G { static void count@@ Di@@ visors ( int n ) { int count = 0 ; int j = 0 ; int divisor [ ] = new int [ n ] ; for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { divisor [ j ] = i ; j += 1 ; } else { divisor [ j ] = i ; divisor [ j + 1 ] = n / i ; j += 2 ; } } } divisor [ j ] = n ; for ( int i = 0 ; i <= j ; i ++ ) { int x = divisor [ i ] ; x -= 1 ; if ( ( n / x ) == ( n % x ) ) count ++ ; } System . out . print ( count ) ; } public static void main ( String [ ] args ) { int N = 10000000 ; count@@ Di@@ visors ( N ) ; } }
Lon@@ gest increasing sub@@ sequence consisting of elements from indices di@@ visible by previously selected indices 3208 | import java . util . * ; class GF@@ G { static int find@@ MaxLength ( int N , int [ ] arr ) { int [ ] dp = new int [ N + 1 ] ; Arrays . fill ( dp , 1 ) ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 2 * i ; j <= N ; j += i ) { if ( arr [ i - 1 ] < arr [ j - 1 ] ) { dp [ j ] = Math . max ( dp [ j ] , dp [ i ] + 1 ) ; } } } return Arrays . stream ( dp ) . max ( ) . getAs@@ Int ( ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ; int N = arr . length ; System . out . print ( find@@ MaxLength ( N , arr ) ) ; } }
Find an integral solution of the non 3267 | import java . util . * ; class GF@@ G { static int power ( int x , int N ) { int res = 1 ; while ( N > 0 ) { if ( ( N & 1 ) != 0 ) { res = ( res * x ) ; } x = ( x * x ) ; N = N >> 1 ; } return res ; } static void find@@ Val@@ X_@@ Y ( int N ) { if ( N <= 1 ) { System . out . println ( - 1 ) ; return ; } int x@@ Max ; x@@ Max = ( int ) Math . log ( N ) ; int y@@ Max ; y@@ Max = ( int ) ( Math . log ( N ) / Math . log ( 5.0 ) ) ; for ( int i = 1 ; i <= x@@ Max ; i ++ ) { for ( int j = 1 ; j <= y@@ Max ; j ++ ) { int a = power ( 2 , i ) ; int b = power ( 5 , j ) ; if ( a + b == N ) { System . out . print ( i + " ▁ " + j ) ; return ; } } } System . out . println ( " - 1" ) ; } public static void main ( String args [ ] ) { int N = 129 ; find@@ Val@@ X_@@ Y ( N ) ; } }
Queries to flip characters of a binary string in given range 3277 | import java . util . * ; class GF@@ G { static String toggle@@ Query ( char [ ] str , int Q [ ] [ ] , int M ) { int N = str . length ; int prefix@@ Cnt [ ] = new int [ N + 1 ] ; for ( int i = 0 ; i < M ; i ++ ) { prefix@@ Cnt [ Q [ i ] [ 0 ] ] += 1 ; prefix@@ Cnt [ Q [ i ] [ 1 ] + 1 ] -= 1 ; } for ( int i = 1 ; i <= N ; i ++ ) { prefix@@ Cnt [ i ] += prefix@@ Cnt [ i - 1 ] ; } for ( int i = 0 ; i < N ; i ++ ) { if ( prefix@@ Cnt [ i ] % 2 == 1 ) { str [ i ] = ( char ) ( '1' - str [ i ] + '0' ) ; } } return String . valueOf ( str ) ; } public static void main ( String [ ] args ) { String str = "@@ 101@@ 01@@ 0" ; int Q [ ] [ ] = { { 0 , 1 } , { 2 , 5 } , { 2 , 3 } , { 1 , 4 } , { 0 , 5 } } ; int M = Q . length ; System . out . print ( toggle@@ Query ( str . toCharArray ( ) , Q , M ) ) ; } }
Length of longest sub@@ array with increasing contiguous elements 3295 | import java . util . * ; class GF@@ G { public static int max@@ i@@ Con@@ sec@@ uti@@ ve@@ Sub@@ array ( int arr [ ] , int N ) { int max@@ i = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { int cnt = 1 , j ; for ( j = i ; j < N - 1 ; j ++ ) { if ( arr [ j + 1 ] == arr [ j ] + 1 ) { cnt ++ ; } else { break ; } } max@@ i = Math . max ( max@@ i , cnt ) ; i = j ; } return max@@ i ; } public static void main ( String args [ ] ) { int N = 11 ; int arr [ ] = { 1 , 3 , 4 , 2 , 3 , 4 , 2 , 3 , 5 , 6 , 7 } ; System . out . println ( max@@ i@@ Con@@ sec@@ uti@@ ve@@ Sub@@ array ( arr , N ) ) ; } }
Maximum number of elements that can be removed such that ME@@ X of the given array remains unchanged 3303 | import java . io . * ; import java . util . * ; class GF@@ G { static void count@@ Remo@@ v@@ able@@ Elem ( int [ ] arr , int N ) { int [ ] hash = new int [ N + 1 ] ; Arrays . fill ( hash , 0 ) ; int me@@ x = N + 1 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] <= N ) hash [ arr [ i ] ] = 1 ; } for ( int i = 1 ; i <= N ; i ++ ) { if ( hash [ i ] == 0 ) { me@@ x = i ; break ; } } System . out . println ( N - ( me@@ x - 1 ) ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 2 , 3 , 5 , 1 , 6 } ; int N = arr . length ; count@@ Remo@@ v@@ able@@ Elem ( arr , N ) ; } }
Print all positions of a given string having count of smaller characters equal on both sides 3304 | import java . util . * ; class GF@@ G { static void print@@ Indexes ( char [ ] str ) { int N = str . length ; int [ ] cnt@@ Freq = new int [ 256 ] ; for ( int i = 0 ; i < N ; i ++ ) { cnt@@ Freq [ str [ i ] ] ++ ; } int [ ] cnt@@ Left@@ Freq = new int [ 256 ] ; for ( int i = 0 ; i < N ; i ++ ) { int cnt@@ Left = 0 ; int cnt@@ Right = 0 ; for ( int j = str [ i ] - 1 ; j >= 0 ; j -- ) { cnt@@ Left += cnt@@ Left@@ Freq [ j ] ; cnt@@ Right += cnt@@ Freq [ j ] - cnt@@ Left@@ Freq [ j ] ; } cnt@@ Left@@ Freq [ str [ i ] ] ++ ; if ( cnt@@ Left == cnt@@ Right && cnt@@ Left != 0 ) { System . out . print ( i + " ▁ " ) ; } } } public static void main ( String [ ] args ) { String str = " a@@ ab@@ ac@@ d@@ ab@@ bb " ; print@@ Indexes ( str . toCharArray ( ) ) ; } }
Check if a string is concatenation of another given string 3343 | import java . util . * ; class GF@@ G { static boolean check@@ Concat ( String str1 , String str2 ) { int N = str1 . length ( ) ; int M = str2 . length ( ) ; if ( N % M != 0 ) { return false ; } for ( int i = 0 ; i < N ; i ++ ) { if ( str1 . charAt ( i ) != str2 . charAt ( i % M ) ) { return false ; } } return true ; } public static void main ( String [ ] args ) { String str1 = " abc@@ abc@@ abc " ; String str2 = " abc " ; if ( check@@ Concat ( str1 , str2 ) ) { System . out . print ( " Yes " ) ; } else { System . out . print ( " No " ) ; } } }
Count positions in Binary Matrix having equal count of set bits in corresponding row and column 3357 | import java . util . * ; import java . lang . * ; class GF@@ G { static int count@@ Position ( int [ ] [ ] mat ) { int n = mat . length ; int m = mat [ 0 ] . length ; int [ ] row = new int [ n ] ; int [ ] col = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) { col [ j ] ++ ; row [ i ] ++ ; } } } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( row [ i ] == col [ j ] ) { count ++ ; } } } return count ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 0 , 1 } , { 1 , 1 } } ; System . out . println ( count@@ Position ( mat ) ) ; } }
Pair having all other given pairs ly@@ ing between its minimum and maximum 3358 | import java . util . * ; class GF@@ G { static void position ( int arr [ ] [ ] , int N ) { int pos = - 1 ; int count ; for ( int i = 0 ; i < N ; i ++ ) { count = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ i ] [ 0 ] <= arr [ j ] [ 0 ] && arr [ i ] [ 1 ] >= arr [ j ] [ 1 ] ) { count ++ ; } } if ( count == N ) { pos = i ; } } if ( pos == - 1 ) { System . out . print ( pos ) ; } else { System . out . print ( pos + 1 ) ; } } public static void main ( String [ ] args ) { int arr [ ] [ ] = { { 3 , 3 } , { 1 , 3 } , { 2 , 2 } , { 2 , 3 } , { 1 , 2 } } ; int N = arr . length ; position ( arr , N ) ; } }
Node whose removal minim@@ izes the maximum size forest from an N 3384 | import java . util . * ; class GF@@ G { static int mini = 105 , ans , n ; static Vector < Integer > [ ] g = new Vector [ 100 ] ; static int [ ] size = new int [ 100 ] ; static void create_@@ graph ( ) { g [ 1 ] . add ( 2 ) ; g [ 2 ] . add ( 1 ) ; g [ 1 ] . add ( 3 ) ; g [ 3 ] . add ( 1 ) ; g [ 1 ] . add ( 4 ) ; g [ 4 ] . add ( 1 ) ; g [ 2 ] . add ( 5 ) ; g [ 5 ] . add ( 2 ) ; g [ 2 ] . add ( 6 ) ; g [ 6 ] . add ( 2 ) ; } static void dfs ( int node , int parent ) { size [ node ] = 1 ; int mx = 0 ; for ( int y : g [ node ] ) { if ( y == parent ) continue ; dfs ( y , node ) ; size [ node ] += size [ y ] ; mx = Math . max ( mx , size [ y ] ) ; } mx = Math . max ( mx , n - size [ node ] ) ; if ( mx < mini ) { mini = mx ; ans = node ; } } public static void main ( String [ ] args ) { n = 6 ; for ( int i = 0 ; i < g . length ; i ++ ) g [ i ] = new Vector < Integer > ( ) ; create_@@ graph ( ) ; dfs ( 1 , - 1 ) ; System . out . print ( ans + "@@ NEW_@@ LINE@@ "@@ )@@ ; } }
Check if array can be sorted by sw@@ apping pairs having GC@@ D equal to the smallest element in the array 3423 | import java . util . * ; class GF@@ G { static void is@@ Possible ( int arr [ ] , int N ) { int mn = Integer . MAX_VALUE ; int [ ] B = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { mn = Math . min ( mn , arr [ i ] ) ; B [ i ] = arr [ i ] ; } Arrays . sort ( arr ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] != B [ i ] ) { if ( B [ i ] % mn != 0 ) { System . out . print ( " No " ) ; return ; } } } System . out . print ( " Yes " ) ; return ; } public static void main ( String [ ] args ) { int N = 6 ; int arr [ ] = { 4 , 3 , 6 , 6 , 2 , 9 } ; is@@ Possible ( arr , N ) ; } }
Check if all array elements are present in a given stack or not 3429 | import java . util . * ; class GF@@ G { static boolean check@@ Arr@@ In@@ Stack ( Stack < Integer > s , int arr [ ] , int n ) { HashMap < Integer , Integer > freq = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( freq . containsKey ( arr [ i ] ) ) freq . put ( arr [ i ] , freq . get ( arr [ i ] ) + 1 ) ; else freq . put ( arr [ i ] , 1 ) ; while ( ! s . isEmpty ( ) ) { int pop@@ ped@@ E@@ le = s . peek ( ) ; s . pop ( ) ; if ( freq . containsKey ( pop@@ ped@@ E@@ le ) ) freq . put ( pop@@ ped@@ E@@ le , freq . get ( pop@@ ped@@ E@@ le ) - 1 ) ; } if ( freq . size ( ) == 0 ) return false ; return true ; } public static void main ( String [ ] args ) { Stack < Integer > s = new Stack < Integer > ( ) ; s . add ( 10 ) ; s . add ( 20 ) ; s . add ( 30 ) ; s . add ( 40 ) ; s . add ( 50 ) ; int arr [ ] = { 20 , 30 } ; int n = arr . length ; if ( check@@ Arr@@ In@@ Stack ( s , arr , n ) ) System . out . print ( "@@ Y@@ ES@@ NEW_@@ LINE@@ "@@ )@@ ; else System . out . print ( "@@ NO@@ NEW_@@ LINE@@ "@@ )@@ ; } }
Minimum size substring to be removed to make a given string pal@@ ind@@ ro@@ mic 3448 | import java . util . * ; class GF@@ G { static String pal@@ ind@@ ro@@ me@@ Prefix ( String S ) { int n = S . length ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { String curr = S . substring ( 0 , i + 1 ) ; int l = 0 , r = curr . length ( ) - 1 ; boolean is_p@@ al@@ ind@@ ro@@ me = true ; while ( l < r ) { if ( curr . charAt ( l ) != curr . charAt ( r ) ) { is_p@@ al@@ ind@@ ro@@ me = false ; break ; } l ++ ; r -- ; } if ( is_p@@ al@@ ind@@ ro@@ me ) return curr ; } return " " ; } static String max@@ Pal@@ ind@@ ro@@ me ( String S ) { int n = S . length ( ) ; if ( n <= 1 ) { return S ; } String pre = " " , su@@ ff = " " ; int i = 0 , j = n - 1 ; while ( S . charAt ( i ) == S . charAt ( j ) && i < j ) { i ++ ; j -- ; } i -- ; j ++ ; pre = S . substring ( 0 , i + 1 ) ; su@@ ff = S . substring ( j ) ; if ( j - i == 1 ) { return pre + su@@ ff ; } if ( j - i == 2 ) { String mid_@@ char = S . substring ( i + 1 , i + 2 ) ; return pre + mid_@@ char + su@@ ff ; } String re@@ m_@@ str = S . substring ( i + 1 , j ) ; String pre_@@ of_@@ re@@ m_@@ str = pal@@ ind@@ ro@@ me@@ Prefix ( re@@ m_@@ str ) ; re@@ m_@@ str = reverse ( re@@ m_@@ str ) ; String su@@ ff_@@ of_@@ re@@ m_@@ str = pal@@ ind@@ ro@@ me@@ Prefix ( re@@ m_@@ str ) ; if ( pre_@@ of_@@ re@@ m_@@ str . length ( ) >= su@@ ff_@@ of_@@ re@@ m_@@ str . length ( ) ) { return pre + pre_@@ of_@@ re@@ m_@@ str + su@@ ff ; } else { return pre + su@@ ff_@@ of_@@ re@@ m_@@ str + su@@ ff ; } } static String reverse ( String input ) { char [ ] a = input . toCharArray ( ) ; int l , r = a . length - 1 ; for ( l = 0 ; l < r ; l ++ , r -- ) { char temp = a [ l ] ; a [ l ] = a [ r ] ; a [ r ] = temp ; } return String . valueOf ( a ) ; } public static void main ( String [ ] args ) { String S = " ge@@ ek@@ s@@ for@@ s@@ kee@@ g " ; System . out . print ( max@@ Pal@@ ind@@ ro@@ me ( S ) ) ; } }
Sum of all distances between occurrences of same characters in a given string 3496 | import java . util . * ; class GF@@ G { static int find@@ Sum ( String s ) { int sum = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { for ( int j = i + 1 ; j < s . length ( ) ; j ++ ) { if ( s . charAt ( i ) == s . charAt ( j ) ) { sum += ( j - i ) ; } } } return sum ; } public static void main ( String [ ] args ) { String s = " tt@@ t " ; System . out . print ( find@@ Sum ( s ) + "@@ NEW_@@ LINE@@ "@@ )@@ ; } }
Minim@@ ize count of fli@@ ps required such that no substring of 0 s have length exce@@ eding K 3534 | class GF@@ G { static int min@@ _f@@ li@@ ps ( String str , int k ) { if ( str . length ( ) == 0 ) return 0 ; int ans = 0 ; int cn@@ t_@@ zeros = 0 ; for ( char ch : str . toCharArray ( ) ) { if ( ch == '0' ) { ++ cn@@ t_@@ zeros ; } else { cn@@ t_@@ zeros = 0 ; } if ( cn@@ t_@@ zeros == k ) { ++ ans ; cn@@ t_@@ zeros = 0 ; } } return ans ; } public static void main ( String [ ] args ) { String str = "11@@ 1000000@@ 11" ; int k = 3 ; System . out . print ( min@@ _f@@ li@@ ps ( str , k ) ) ; } }
Count of N digit Numbers having no pair of equal consecutive Digits 3597 | import java . util . * ; class GF@@ G { public static void count ( int N ) { if ( N == 1 ) { System . out . println ( 10 ) ; return ; } int dp [ ] [ ] = new int [ N ] [ 10 ] ; for ( int i = 1 ; i < 10 ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) { int temp = 0 ; for ( int j = 0 ; j < 10 ; j ++ ) temp += dp [ i - 1 ] [ j ] ; for ( int j = 0 ; j < 10 ; j ++ ) dp [ i ] [ j ] = temp - dp [ i - 1 ] [ j ] ; } int ans = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) ans += dp [ N - 1 ] [ i ] ; System . out . println ( ans ) ; } public static void main ( String [ ] args ) { int N = 2 ; count ( N ) ; } }
Queries to find the count of connected Non 3604 | import java . util . * ; class GF@@ G { static int ctr = 0 ; static int find ( int [ ] parent , int x ) { if ( parent [ x ] == x ) return x ; parent [ x ] = find ( parent , parent [ x ] ) ; return parent [ x ] ; } static void set@@ Union ( int [ ] parent , int [ ] rank , int x , int y ) { int parent@@ x = find ( parent , x ) ; int paren@@ ty = find ( parent , y ) ; if ( paren@@ ty == parent@@ x ) return ; ctr -- ; if ( rank [ parent@@ x ] < rank [ paren@@ ty ] ) { parent [ parent@@ x ] = paren@@ ty ; } else if ( rank [ parent@@ x ] > rank [ paren@@ ty ] ) { parent [ paren@@ ty ] = parent@@ x ; } else { parent [ parent@@ x ] = paren@@ ty ; rank [ paren@@ ty ] ++ ; } } static int [ ] solve ( int n , int m , int [ ] [ ] query ) { int [ ] result = new int [ query . length ] ; int [ ] parent = new int [ n * m ] ; for ( int i = 0 ; i < n * m ; i ++ ) parent [ i ] = i ; int [ ] rank = new int [ n * m ] ; Arrays . fill ( rank , 1 ) ; boolean [ ] grid = new boolean [ n * m ] ; for ( int i = 0 ; i < query . length ; i ++ ) { int x = query [ i ] [ 0 ] ; int y = query [ i ] [ 1 ] ; if ( grid [ m * x + y ] == true ) { result [ i ] = ctr ; continue ; } grid [ m * x + y ] = true ; ctr ++ ; if ( x > 0 && grid [ m * ( x - 1 ) + y ] == true ) set@@ Union ( parent , rank , m * x + y , m * ( x - 1 ) + y ) ; if ( y > 0 && grid [ m * ( x ) + y - 1 ] == true ) set@@ Union ( parent , rank , m * x + y , m * ( x ) + y - 1 ) ; if ( x < n - 1 && grid [ m * ( x + 1 ) + y ] == true ) set@@ Union ( parent , rank , m * x + y , m * ( x + 1 ) + y ) ; if ( y < m - 1 && grid [ m * ( x ) + y + 1 ] == true ) set@@ Union ( parent , rank , m * x + y , m * ( x ) + y + 1 ) ; result [ i ] = ctr ; } return result ; } public static void main ( String [ ] args ) { int N = 3 , M = 3 , K = 4 ; int [ ] [ ] query = { { 0 , 0 } , { 1 , 1 } , { 1 , 0 } , { 1 , 2 } } ; int [ ] result = solve ( N , M , query ) ; for ( int i = 0 ; i < K ; i ++ ) System . out . print ( result [ i ] + " ▁ " ) ; } }
Minimum number of leaves required to be removed from a Tree to satisfy the given condition 3628 | import java . util . * ; class GF@@ G { static int cnt = 0 ; static void dfs ( int [ ] val , int [ ] cost , Vector < Integer > [ ] tr , int u , int s ) { s = s + cost [ u ] ; if ( s < 0 ) s = 0 ; if ( s > val [ u ] ) return ; cnt ++ ; for ( int i = 0 ; i < tr [ u ] . size ( ) ; i ++ ) { dfs ( val , cost , tr , tr [ u ] . get ( i ) , s ) ; } } public static void main ( String [ ] args ) { int n = 9 ; int val [ ] = { 88 , 22 , 83 , 14 , 95 , 91 , 98 , 53 , 11 } ; int cost [ ] = { - 1 , 24 , - 8 , 67 , 64 , 65 , 12 , - 80 , 8 } ; @ SuppressWarnings ( " unchecked " ) Vector < Integer > [ ] tr = new Vector [ n + 1 ] ; for ( int i = 0 ; i < tr . length ; i ++ ) tr [ i ] = new Vector < Integer > ( ) ; tr [ 0 ] . add ( 3 ) ; tr [ 0 ] . add ( 4 ) ; tr [ 4 ] . add ( 6 ) ; tr [ 6 ] . add ( 2 ) ; tr [ 2 ] . add ( 1 ) ; tr [ 2 ] . add ( 8 ) ; tr [ 8 ] . add ( 5 ) ; tr [ 5 ] . add ( 7 ) ; dfs ( val , cost , tr , 0 , 0 ) ; System . out . print ( n - cnt ) ; } }
Find Second largest element in an array | Set 2 3665 | import java . util . * ; class GF@@ G { static int [ ] find@@ Lar@@ gest ( int beg , int end , int [ ] arr , int n ) { if ( beg == end ) { int [ ] compared = new int [ n ] ; compared [ 0 ] = 1 ; compared [ 1 ] = arr [ beg ] ; return compared ; } int [ ] compare@@ d1 = find@@ Lar@@ gest ( beg , ( beg + end ) / 2 , arr , n ) ; int [ ] compare@@ d2 = find@@ Lar@@ gest ( ( beg + end ) / 2 + 1 , end , arr , n ) ; if ( compare@@ d1 [ 1 ] > compare@@ d2 [ 1 ] ) { int k = compare@@ d1 [ 0 ] + 1 ; compare@@ d1 [ 0 ] = k ; compare@@ d1 [ k ] = compare@@ d2 [ 1 ] ; return compare@@ d1 ; } else { int k = compare@@ d2 [ 0 ] + 1 ; compare@@ d2 [ 0 ] = k ; compare@@ d2 [ k ] = compare@@ d1 [ 1 ] ; return compare@@ d2 ; } } static void find@@ Second@@ Lar@@ gest ( int end , int [ ] arr ) { int [ ] compare@@ d1 = find@@ Lar@@ gest ( 0 , end - 1 , arr , end ) ; int [ ] compare@@ d2 = find@@ Lar@@ gest ( 2 , compare@@ d1 [ 0 ] + 2 , compare@@ d1 , compare@@ d1 [ 0 ] ) ; System . out . print ( compare@@ d2 [ 1 ] ) ; } public static void main ( String [ ] args ) { int N = 10 ; int [ ] arr = { 20 , 199@@ 0 , 12 , 11@@ 10 , 1 , 59 , 12 , 15 , 120 , 11@@ 10 } ; find@@ Second@@ Lar@@ gest ( N , arr ) ; } }
Count of Reverse Bit@@ on@@ ic Sub@@ strings in a given String 3666 | class GF@@ G { public static int Count@@ sub@@ String ( char [ ] str , int n ) { int c = 0 ; for ( int len = 1 ; len <= n ; len ++ ) { for ( int i = 0 ; i <= n - len ; i ++ ) { int j = i + len - 1 ; char temp = str [ i ] , f = 0 ; if ( j == i ) { c ++ ; continue ; } int k = i + 1 ; while ( temp > str [ k ] && k <= j ) { temp = str [ k ] ; k ++ ; } if ( k > j ) { c ++ ; f = 2 ; } while ( k <= j && temp < str [ k ] && f != 2 ) { temp = str [ k ] ; k ++ ; } if ( k > j && f != 2 ) { c ++ ; f = 0 ; } } } return c ; } public static void main ( String [ ] args ) { char str [ ] = { ' b ' , ' a ' , ' d ' , ' e ' } ; System . out . println ( Count@@ sub@@ String ( str , str . length ) ) ; } }
Construct a sequence from given frequencies of N consecutive integers with unit adjacent difference 3702 | import java . util . * ; class GF@@ G { static Vector < Integer > generate@@ Sequence ( int [ ] freq , int n ) { HashMap < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ; int total = 0 ; for ( int i = 0 ; i < n ; i ++ ) { m . put ( i , freq [ i ] ) ; total += freq [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( m . containsKey ( i ) ) { Vector < Integer > sequence = new Vector < Integer > ( ) ; @ SuppressWarnings ( " unchecked " ) HashMap < Integer , Integer > m@@ copy = ( HashMap < Integer , Integer > ) m . clone ( ) ; if ( m@@ copy . containsKey ( i ) && m@@ copy . get ( i ) > 0 ) m@@ copy . put ( i , m@@ copy . get ( i ) - 1 ) ; sequence . add ( i ) ; int last = i ; for ( int i1 = 0 ; i1 < total - 1 ; i1 ++ ) { if ( m@@ copy . containsKey ( last - 1 ) && m@@ copy . get ( last - 1 ) > 0 ) { m@@ copy . put ( last - 1 , m@@ copy . get ( last - 1 ) - 1 ) ; sequence . add ( last - 1 ) ; last -- ; } else if ( m@@ copy . containsKey ( last + 1 ) ) { m@@ copy . put ( last + 1 , m@@ copy . get ( last + 1 ) - 1 ) ; sequence . add ( last + 1 ) ; last ++ ; } else break ; } if ( sequence . size ( ) == total ) { return sequence ; } } } Vector < Integer > empty = new Vector < Integer > ( ) ; return empty ; } static void Print@@ Sequence ( int freq [ ] , int n ) { Vector < Integer > sequence = generate@@ Sequence ( freq , n ) ; if ( sequence . size ( ) == 0 ) { System . out . print ( " - 1" ) ; } else { for ( int i = 0 ; i < sequence . size ( ) ; i ++ ) { System . out . print ( sequence . get ( i ) + " ▁ " ) ; } } } public static void main ( String [ ] args ) { int freq [ ] = { 2 , 2 , 2 , 3 , 1 } ; int N = 5 ; Print@@ Sequence ( freq , N ) ; } }
Change in Medi@@ an of given array after deleting given elements 3730 | import java . util . * ; class GF@@ G { public static void medi@@ an@@ Change ( List < Integer > ar@@ r1 , List < Integer > ar@@ r2 ) { int N = ar@@ r1 . size ( ) ; List < Integer > median = new ArrayList < > ( ) ; if ( ( N & 1 ) != 0 ) median . add ( ar@@ r1 . get ( N / 2 ) * 1 ) ; else median . add ( ( ar@@ r1 . get ( N / 2 ) + ar@@ r1 . get ( ( N - 1 ) / 2 ) ) / 2 ) ; for ( int x = 0 ; x < ar@@ r2 . size ( ) ; x ++ ) { int it = ar@@ r1 . indexOf ( ar@@ r2 . get ( x ) ) ; ar@@ r1 . remove ( it ) ; N -- ; if ( ( N & 1 ) != 0 ) { median . add ( ar@@ r1 . get ( N / 2 ) * 1 ) ; } else { median . add ( ( ar@@ r1 . get ( N / 2 ) + ar@@ r1 . get ( ( N - 1 ) / 2 ) ) / 2 ) ; } } for ( int i = 0 ; i < median . size ( ) - 1 ; i ++ ) { System . out . print ( median . get ( i + 1 ) - median . get ( i ) + " ▁ " ) ; } } public static void main ( String [ ] args ) { List < Integer > ar@@ r1 = new ArrayList < Integer > ( ) { { add ( 2 ) ; add ( 4 ) ; add ( 6 ) ; add ( 8 ) ; add ( 10 ) ; } } ; List < Integer > ar@@ r2 = new ArrayList < Integer > ( ) { { add ( 4 ) ; add ( 6 ) ; } } ; medi@@ an@@ Change ( ar@@ r1 , ar@@ r2 ) ; } }
Count of distinct power of prime factor of N 3737 | import java . util . * ; class GF@@ G { static int count@@ Fa@@ c ( int n ) { int m = n ; int count = 0 ; for ( int i = 2 ; ( i * i ) <= m ; ++ i ) { int total = 0 ; while ( n % i == 0 ) { n /= i ; ++ total ; } int temp = 0 ; for ( int j = 1 ; ( temp + j ) <= total ; ++ j ) { temp += j ; ++ count ; } } if ( n != 1 ) ++ count ; return count ; } public static void main ( String [ ] args ) { int N = 24 ; System . out . println ( count@@ Fa@@ c ( N ) ) ; } }
Find the missing number in unordered Arith@@ metic Prog@@ ression 3742 | import java . util . Arrays ; class GF@@ G { static int find@@ Missing ( int arr [ ] , int left , int right , int diff ) { if ( right <= left ) return 0 ; int mid = left + ( right - left ) / 2 ; if ( arr [ mid + 1 ] - arr [ mid ] != diff ) return ( arr [ mid ] + diff ) ; if ( mid > 0 && arr [ mid ] - arr [ mid - 1 ] != diff ) return ( arr [ mid - 1 ] + diff ) ; if ( arr [ mid ] == arr [ 0 ] + mid * diff ) return find@@ Missing ( arr , mid + 1 , right , diff ) ; return find@@ Missing ( arr , left , mid - 1 , diff ) ; } static int missing@@ Element ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int diff = ( arr [ n - 1 ] - arr [ 0 ] ) / n ; return find@@ Missing ( arr , 0 , n - 1 , diff ) ; } public static void main ( String [ ] args ) { int arr [ ] = new int [ ] { 2 , 8 , 6 , 10 } ; int n = arr . length ; System . out . println ( missing@@ Element ( arr , n ) ) ; } }
Minimum value of K such that sum of cub@@ es of first K natural number is greater than equal to N 3757 | class GF@@ G { static int nai@@ ve_@@ find_@@ x ( int N ) { int c = 0 , i ; for ( i = 1 ; i < N ; i ++ ) { c += i * i * i ; if ( c >= N ) break ; } return i ; } public static void main ( String [ ] args ) { int N = 100 ; System . out . println ( nai@@ ve_@@ find_@@ x ( N ) ) ; } }
XOR of pairwise sum of every unordered pairs in an array 3795 | class GF@@ G { static int xor@@ Of@@ Sum ( int a [ ] , int n ) { int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) answer ^= ( a [ i ] + a [ j ] ) ; } return answer ; } public static void main ( String [ ] args ) { int n = 3 ; int A [ ] = { 1 , 2 , 3 } ; System . out . print ( xor@@ Of@@ Sum ( A , n ) ) ; } }
Lar@@ gest and smallest Fi@@ bon@@ ac@@ ci numbers in an Array 3798 | import java . util . * ; class GF@@ G { static void create@@ Hash ( HashSet < Integer > hash , int max@@ Element ) { int prev = 0 , curr = 1 ; hash . add ( prev ) ; hash . add ( curr ) ; while ( curr <= max@@ Element ) { int temp = curr + prev ; hash . add ( temp ) ; prev = curr ; curr = temp ; } } static void fi@@ bon@@ ac@@ ci ( int arr [ ] , int n ) { int max_@@ val = Arrays . stream ( arr ) . max ( ) . getAs@@ Int ( ) ; HashSet < Integer > hash = new HashSet < Integer > ( ) ; create@@ Hash ( hash , max_@@ val ) ; int minimum = Integer . MAX_VALUE ; int maximum = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( hash . contains ( arr [ i ] ) ) { minimum = Math . min ( minimum , arr [ i ] ) ; maximum = Math . max ( maximum , arr [ i ] ) ; } } System . out . print ( minimum + " , ▁ " + maximum + "@@ NEW_@@ LINE@@ "@@ )@@ ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int n = arr . length ; fi@@ bon@@ ac@@ ci ( arr , n ) ; } }
Check if an Array is a permutation of numbers from 1 to N 3802 | import java . util . * ; class GF@@ G { static boolean permutation ( int [ ] arr , int n ) { Set < Integer > hash = new HashSet < Integer > ( ) ; int max@@ E@@ le = 0 ; for ( int i = 0 ; i < n ; i ++ ) { hash . add ( arr [ i ] ) ; max@@ E@@ le = Math . max ( max@@ E@@ le , arr [ i ] ) ; } if ( max@@ E@@ le != n ) return false ; if ( hash . size ( ) == n ) return true ; return false ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 5 , 3 , 2 } ; int n = arr . length ; if ( permutation ( arr , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
Minimum increments to convert to an array of consecutive integers 3868 | import java . util . Arrays ; class GF@@ G { static boolean check ( int m , int n , int arr [ ] ) { int [ ] desired = new int [ n ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { desired [ i ] = m ; m -- ; } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > desired [ i ] desired [ i ] < 1 ) { return false ; } } return true ; } static int min@@ Operations ( int arr [ ] , int n ) { int start = ( int ) arr [ n - 1 ] ; int end = Arrays . stream ( arr ) . max ( ) . getAs@@ Int ( ) + n ; int max_@@ arr = 0 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( check ( mid , n , arr ) ) { max_@@ arr = mid ; end = mid - 1 ; } else { start = mid + 1 ; } } int [ ] desired = new int [ n ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { desired [ i ] = max_@@ arr ; max_@@ arr -- ; } int operations = 0 ; for ( int i = 0 ; i < n ; i ++ ) { operations += ( desired [ i ] - arr [ i ] ) ; } return operations ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 4 , 5 , 5 , 7 } ; int n = arr . length ; System . out . println ( min@@ Operations ( arr , n ) ) ; } }
Cost to make a string Pan@@ agram | Set 2 3917 | public class GF@@ G { static int cost@@ To@@ Pan@@ agram ( String str , int cost [ ] ) { int i , n = str . length ( ) ; int occurrences [ ] = new int [ 26 ] ; for ( i = 0 ; i < n ; i ++ ) occurrences [ str . charAt ( i ) - ' a ' ] ++ ; int gain = 0 ; for ( i = 0 ; i < 26 ; i ++ ) { if ( occurrences [ i ] == 0 ) gain -= ( 2 * cost [ i ] ) ; else if ( occurrences [ i ] > 1 ) gain += ( cost [ i ] * ( occurrences [ i ] - 1 ) ) ; } if ( gain >= 0 ) return 0 ; return ( gain * - 1 ) ; } public static void main ( String [ ] args ) { int cost [ ] = { 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 } ; String str = " ge@@ ek@@ s@@ forge@@ e@@ ks " ; System . out . println ( cost@@ To@@ Pan@@ agram ( str , cost ) ) ; } }
Weigh@@ ted sum of the characters of a string in an array | Set 2 3918 | import java . util . HashMap ; import java . util . Map ; class Gf@@ G { static int str@@ Score ( String str [ ] , String s , int n ) { HashMap < String , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) m . put ( str [ i ] , i + 1 ) ; if ( ! m . containsKey ( s ) ) return 0 ; int score = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) score += s . charAt ( i ) - ' a ' + 1 ; score = score * m . get ( s ) ; return score ; } public static void main ( String [ ] args ) { String str [ ] = { " ge@@ ek@@ s@@ forge@@ e@@ ks " , " algorithms " , " stack " } ; String s = " algorithms " ; int n = str . length ; System . out . println ( str@@ Score ( str , s , n ) ) ; } }
Replace all occurrences of pi with 3.14 in a given string 3966 | class GF@@ G { public String replace@@ Pi ( String input ) { String output = " " ; int size = input . length ( ) ; for ( int i = 0 ; i < size ; ++ i ) { if ( i + 1 < size && input . charAt ( i ) == ' p ' && input . charAt ( i + 1 ) == ' i ' ) { output += "@@ 3.14@@ " ; i ++ ; } else { output += input . charAt ( i ) ; } } return output ; } public static void main ( String args [ ] ) { GF@@ G g = new GF@@ G ( ) ; String input = "2 ▁ * ▁ pi ▁ + ▁ 3 ▁ * ▁ pi ▁ = ▁ 5 ▁ * ▁ pi " ; System . out . println ( g . replace@@ Pi ( input ) ) ; } }
Number of elements that can be seen from right side 3968 | import java . util . * ; class Solution { static int numberOf@@ Elements ( int height [ ] , int n ) { int max_@@ so@@ _f@@ ar = 0 ; int co@@ un = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( height [ i ] > max_@@ so@@ _f@@ ar ) { max_@@ so@@ _f@@ ar = height [ i ] ; co@@ un ++ ; } } return co@@ un ; } public static void main ( String args [ ] ) { int n = 6 ; int height [ ] = { 4 , 8 , 2 , 0 , 0 , 5 } ; System . out . println ( numberOf@@ Elements ( height , n ) ) ; } }
Sum and Product of minimum and maximum element of an Array 3980 | import java . io . * ; class GF@@ G { static int get@@ Min ( int arr [ ] , int n ) { int res = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) res = Math . min ( res , arr [ i ] ) ; return res ; } static int getMax ( int arr [ ] , int n ) { int res = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) res = Math . max ( res , arr [ i ] ) ; return res ; } static int find@@ Sum ( int arr [ ] , int n ) { int min = get@@ Min ( arr , n ) ; int max = getMax ( arr , n ) ; return min + max ; } static int find@@ Product ( int arr [ ] , int n ) { int min = get@@ Min ( arr , n ) ; int max = getMax ( arr , n ) ; return min * max ; } public static void main ( String [ ] args ) { int arr [ ] = { 12 , 1234 , 45 , 67 , 1 } ; int n = arr . length ; System . out . println ( " Sum ▁ = ▁ " + find@@ Sum ( arr , n ) ) ; System . out . println ( " Product ▁ = ▁ " + find@@ Product ( arr , n ) ) ; } }
Sort the given string using character search 4061 | class GF@@ G { static String sort@@ String ( String str , int n ) { String new_@@ str = " " ; for ( int i = ' a ' ; i <= ' z ' ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( str . charAt ( j ) == i ) new_@@ str += str . charAt ( j ) ; return new_@@ str ; } public static void main ( String [ ] args ) { String str = " ge@@ ek@@ s@@ forge@@ e@@ ks " ; int n = str . length ( ) ; System . out . print ( sort@@ String ( str , n ) ) ; } }
Find the number of times every day occurs in a month 4070 | import java . util . * ; import java . lang . * ; public class Gf@@ G { public static void occurren@@ ce@@ Days ( int n , String first@@ day ) { String [ ] days = new String [ ] { " Monday " , " T@@ ue@@ sday " , " W@@ ed@@ ne@@ sday " , " Th@@ ur@@ sday " , " Fri@@ day " , " S@@ atur@@ day " , " Sunday " } ; int [ ] count = new int [ 7 ] ; for ( int i = 0 ; i < 7 ; i ++ ) count [ i ] = 4 ; int pos = 0 ; for ( int i = 0 ; i < 7 ; i ++ ) { if ( first@@ day == days [ i ] ) { pos = i ; break ; } } int inc = n - 28 ; for ( int i = pos ; i < pos + inc ; i ++ ) { if ( i > 6 ) count [ i % 7 ] = 5 ; else count [ i ] = 5 ; } for ( int i = 0 ; i < 7 ; i ++ ) { System . out . println ( days [ i ] + " ▁ " + count [ i ] ) ; } } public static void main ( String argc [ ] ) { int n = 31 ; String first@@ day = " T@@ ue@@ sday " ; occurren@@ ce@@ Days ( n , first@@ day ) ; } }
Random@@ ized Binary Search Algorithm 4107 | class GF@@ G { static int get@@ Random ( int x , int y ) { return ( int ) ( x + Math . random ( ) * 10 % ( y - x + 1 ) ) ; } static int random@@ ized@@ Binary@@ Search ( int arr [ ] , int l , int r , int x ) { while ( l <= r ) { int m = get@@ Random ( l , r ) ; if ( arr [ m ] == x ) return m ; if ( arr [ m ] < x ) l = m + 1 ; else r = m - 1 ; } return - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 4 , 10 , 40 } ; int n = arr . length ; int x = 10 ; int result = random@@ ized@@ Binary@@ Search ( arr , 0 , n - 1 , x ) ; if ( result == - 1 ) System . out . printf ( " Element ▁ is ▁ not ▁ present ▁ in ▁ array " ) ; else System . out . printf ( " Element ▁ is ▁ present ▁ at ▁ index ▁ % d " , result ) ; } }
Check if an array of pairs can be sorted by sw@@ apping pairs with different first elements 4137 | import java . io . * ; import java . lang . * ; import java . util . * ; public class GF@@ G { static boolean is@@ Sorted ( int [ ] [ ] arr , int N ) { for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] [ 0 ] > arr [ i - 1 ] [ 0 ] ) { return false ; } } return true ; } static String is@@ Possible@@ To@@ Sort ( int [ ] [ ] arr , int N ) { int group = arr [ 0 ] [ 1 ] ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] [ 1 ] != group ) { return " Yes " ; } } if ( is@@ Sorted ( arr , N ) ) { return " Yes " ; } else { return " No " ; } } public static void main ( String [ ] args ) { int arr [ ] [ ] = { { 34@@ 0000 , 2 } , { 45@@ 000 , 1 } , { 30000 , 2 } , { 50000 , 4 } } ; int N = arr . length ; System . out . print ( is@@ Possible@@ To@@ Sort ( arr , N ) ) ; } }
Length of longest strictly increasing subset with each pair of adjacent elements satis@@ fying the condition 2 * A [ i ] â ‰@@ ¥ A [ i + 1 ] 4150 | import java . io . * ; import java . lang . * ; import java . util . * ; class GF@@ G { static void max@@ Len@@ Subset ( int a [ ] , int n ) { Arrays . sort ( a ) ; int index = 0 , maxlen = - 1 ; int i = 0 ; while ( i < n ) { int j = i ; int len = 1 ; while ( j < n - 1 ) { if ( 2 * a [ j ] >= a [ j + 1 ] ) { len ++ ; } else break ; j ++ ; } if ( maxlen < len ) { maxlen = len ; index = i ; } j ++ ; i = j ; } i = index ; while ( maxlen > 0 ) { System . out . print ( a [ i ] + " ▁ " ) ; maxlen -- ; i ++ ; } } public static void main ( String [ ] args ) { int a [ ] = { 3 , 1 , 5 , 11 } ; int n = a . length ; max@@ Len@@ Subset ( a , n ) ; } }
Maximum sum of absolute differences between distinct pairs of a trip@@ let from an array 4171 | import java . util . * ; class GF@@ G { static void maximum@@ Sum ( int [ ] arr , int N ) { int sum ; Arrays . sort ( arr ) ; sum = ( arr [ N - 1 ] - arr [ 0 ] ) + ( arr [ N - 2 ] - arr [ 0 ] ) + ( arr [ N - 1 ] - arr [ N - 2 ] ) ; System . out . println ( sum ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 3 , 4 , 2 } ; int N = arr . length ; maximum@@ Sum ( arr , N ) ; } }
Make the array elements equal by performing given operations minimum number of times 4191 | import java . io . * ; class GF@@ G { static void min@@ Operation ( int a [ ] , int N ) { int tot@@ Ops = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { tot@@ Ops += Math . abs ( a [ i ] - a [ i + 1 ] ) ; } int max@@ Ops = Math . max ( Math . abs ( a [ 0 ] - a [ 1 ] ) , Math . abs ( a [ N - 1 ] - a [ N - 2 ] ) ) ; for ( int i = 1 ; i < N - 1 ; i ++ ) { max@@ Ops = Math . max ( max@@ Ops , Math . abs ( a [ i ] - a [ i - 1 ] ) + Math . abs ( a [ i ] - a [ i + 1 ] ) - Math . abs ( a [ i - 1 ] - a [ i + 1 ] ) ) ; } System . out . println ( tot@@ Ops - max@@ Ops ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , - 1 , 0 , 1 , 1 } ; int N = arr . length ; min@@ Operation ( arr , N ) ; } }
Minimum increments or decre@@ ments by D required to make all array elements equal 4215 | import java . util . * ; class GF@@ G { static void num@@ Operation ( int arr [ ] , int N , int D ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( ( arr [ i + 1 ] - arr [ i ] ) % D != 0 ) { System . out . println ( " - 1" ) ; return ; } } int count = 0 ; int mid = arr [ N / 2 ] ; for ( int i = 0 ; i < N ; i ++ ) { count += Math . abs ( mid - arr [ i ] ) / D ; } System . out . println ( count ) ; } public static void main ( String [ ] args ) { int N = 4 , D = 2 ; int arr [ ] = { 2 , 4 , 6 , 8 } ; num@@ Operation ( arr , N , D ) ; } }
Maxim@@ ize sum of second minimum@@ s of each K length partitions of the array 4216 | import java . util . * ; class GF@@ G { static void find@@ Sum ( int A [ ] , int N , int K ) { Arrays . sort ( A ) ; int sum = 0 ; for ( int i = N / K ; i < N ; i += K - 1 ) { sum += A [ i ] ; } System . out . print ( sum ) ; } public static void main ( String [ ] args ) { int K = 4 ; int A [ ] = { 2 , 3 , 1 , 4 , 7 , 5 , 6 , 1 } ; int N = A . length ; find@@ Sum ( A , N , K ) ; } }
Count pairs ( i , j ) from given array such that i K * arr [ j ] 4238 | class GF@@ G { static int merge ( int arr [ ] , int temp [ ] , int l , int m , int r , int K ) { int i = l ; int j = m + 1 ; int cnt = 0 ; for ( i = l ; i <= m ; i ++ ) { boolean found = false ; while ( j <= r ) { if ( arr [ i ] >= K * arr [ j ] ) { found = true ; } else break ; j ++ ; } if ( found == true ) { cnt += j - ( m + 1 ) ; j -- ; } } int k = l ; i = l ; j = m + 1 ; while ( i <= m && j <= r ) { if ( arr [ i ] <= arr [ j ] ) temp [ k ++ ] = arr [ i ++ ] ; else temp [ k ++ ] = arr [ j ++ ] ; } while ( i <= m ) temp [ k ++ ] = arr [ i ++ ] ; while ( j <= r ) temp [ k ++ ] = arr [ j ++ ] ; for ( i = l ; i <= r ; i ++ ) arr [ i ] = temp [ i ] ; return cnt ; } static int merge@@ Sort@@ Util ( int arr [ ] , int temp [ ] , int l , int r , int K ) { int cnt = 0 ; if ( l < r ) { int m = ( l + r ) / 2 ; cnt += merge@@ Sort@@ Util ( arr , temp , l , m , K ) ; cnt += merge@@ Sort@@ Util ( arr , temp , m + 1 , r , K ) ; cnt += merge ( arr , temp , l , m , r , K ) ; } return cnt ; } static void merge@@ Sort ( int arr [ ] , int N , int K ) { int temp [ ] = new int [ N ] ; System . out . print ( merge@@ Sort@@ Util ( arr , temp , 0 , N - 1 , K ) ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 6 , 2 , 5 } ; int N = arr . length ; int K = 2 ; merge@@ Sort ( arr , N , K ) ; } }
Selection Sort VS Bu@@ bble Sort 4241 | import java . io . * ; class GF@@ G { static void Bubble@@ _S@@ ort ( int [ ] arr , int n ) { boolean flag ; for ( int i = 1 ; i < n ; ++ i ) { flag = false ; for ( int j = 0 ; j <= ( n - i - 1 ) ; ++ j ) { if ( arr [ j ] > arr [ j + 1 ] ) { int temp = arr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; flag = true ; } } if ( flag == false ) break ; } } public static void main ( String [ ] args ) { int n = 5 ; int [ ] arr = { 2 , 0 , 1 , 4 , 3 } ; Bubble@@ _S@@ ort ( arr , n ) ; System . out . print ( " The ▁ Sorted ▁ Array ▁ by ▁ " + " using ▁ Bu@@ bble ▁ Sort ▁ is ▁ : ▁ " ) ; for ( int i = 0 ; i < n ; ++ i ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
Minim@@ ize consecutive remo@@ vals of elements of the same type to empty given array 4249 | import java . util . Arrays ; class GF@@ G { static void min@@ Remo@@ vals ( int [ ] A , int N ) { Arrays . sort ( A ) ; int mx = A [ N - 1 ] ; int sum = 1 ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; } if ( sum - mx >= mx ) { System . out . println ( 0 ) ; } else { System . out . println ( 2 * mx - sum ) ; } } public static void main ( String [ ] args ) { int [ ] A = { 3 , 3 , 2 } ; int N = A . length ; min@@ Remo@@ vals ( A , N ) ; } }
Area of the largest rectangle formed by lines parallel to X and Y axis from given set of points 4272 | import java . util . * ; class GF@@ G { static int max@@ Rectangle ( int [ ] [ ] sequence , int size ) { int [ ] X_@@ C@@ ord = new int [ size ] ; int [ ] Y_@@ C@@ ord = new int [ size ] ; for ( int i = 0 ; i < size ; i ++ ) { X_@@ C@@ ord [ i ] = sequence [ i ] [ 0 ] ; Y_@@ C@@ ord [ i ] = sequence [ i ] [ 1 ] ; } Arrays . sort ( X_@@ C@@ ord ) ; Arrays . sort ( Y_@@ C@@ ord ) ; int X_@@ Max = 0 , Y_@@ Max = 0 ; for ( int i = 0 ; i < size - 1 ; i ++ ) { X_@@ Max = Math . max ( X_@@ Max , X_@@ C@@ ord [ i + 1 ] - X_@@ C@@ ord [ i ] ) ; Y_@@ Max = Math . max ( Y_@@ Max , Y_@@ C@@ ord [ i + 1 ] - Y_@@ C@@ ord [ i ] ) ; } return X_@@ Max * Y_@@ Max ; } public static void main ( String [ ] args ) { int [ ] [ ] point = { { - 2 , 0 } , { 2 , 0 } , { 4 , 0 } , { 4 , 2 } } ; int n = point . length ; System . out . print ( max@@ Rectangle ( point , n ) ) ; } }
Re@@ arrange two given arrays such that sum of same indexed elements lies within given range 4275 | import java . io . * ; import java . util . * ; class GF@@ G { static void check@@ Arrange@@ ment ( Integer [ ] A1 , Integer [ ] A2 , int n , int k ) { Arrays . sort ( A1 ) ; Arrays . sort ( A2 , Collections . reverse@@ Order ( ) ) ; int flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( A1 [ i ] + A2 [ i ] > k ) || ( A1 [ i ] + A2 [ i ] < k / 2 ) ) { flag = 1 ; break ; } } if ( flag == 1 ) System . out . println ( " No " ) ; else System . out . println ( " Yes " ) ; } public static void main ( String [ ] args ) { Integer [ ] ar@@ r1 = { 1 , 3 , 4 , 5 } ; Integer [ ] ar@@ r2 = { 2 , 0 , 1 , 1 } ; int K = 6 ; int N = ar@@ r1 . length ; check@@ Arrange@@ ment ( ar@@ r1 , ar@@ r2 , N , K ) ; } }
Check if a decre@@ asing Array can be sorted using Triple cyclic shift 4358 | class GF@@ G { static void sort@@ array ( int arr [ ] , int N ) { if ( N == 3 ) System . out . println ( " NO " ) ; else if ( N % 4 == 0 N % 4 == 1 ) { System . out . println ( " YES " ) ; System . out . println ( N / 2 ) ; int k = 1 , l ; for ( l = 0 ; l < ( N / 4 ) ; l ++ ) { System . out . println ( k + " ▁ " + ( k + 1 ) + " ▁ " + N ) ; System . out . println ( k + 1 + " ▁ " + N + " ▁ " + ( N - 1 ) ) ; k = k + 2 ; N = N - 2 ; } } else System . out . println ( " NO " ) ; } public static void main ( String [ ] args ) { int N = 5 ; int arr [ ] = { 5 , 4 , 3 , 2 , 1 } ; sort@@ array ( arr , N ) ; } }
Minim@@ ize sum of smallest elements from K sub@@ sequences of length L 4369 | import java . util . Arrays ; class GF@@ G { static int find@@ Min@@ Sum ( int [ ] arr , int K , int L , int size ) { if ( K * L > size ) return - 1 ; int min@@ sum = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < K ; i ++ ) min@@ sum += arr [ i ] ; return min@@ sum ; } public static void main ( String args [ ] ) { int arr [ ] = { 2 , 15 , 5 , 1 , 35 , 16 , 67 , 10 } ; int K = 3 ; int L = 2 ; int length = arr . length ; System . out . print ( find@@ Min@@ Sum ( arr , K , L , length ) ) ; } }
K@@ th smallest or largest element in un@@ sorted Array | Set 4 4378 | import java . io . * ; class GF@@ G { static int find@@ K@@ th@@ S@@ malle@@ st ( int [ ] arr , int n , int k ) { int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } int [ ] counter = new int [ max + 1 ] ; int smallest = 0 ; for ( int i = 0 ; i < n ; i ++ ) { counter [ arr [ i ] ] ++ ; } for ( int num = 1 ; num <= max ; num ++ ) { if ( counter [ num ] > 0 ) { smallest += counter [ num ] ; } if ( smallest >= k ) { return num ; } } return - 1 ; } public static void main ( String [ ] args ) { int [ ] arr = { 7 , 1 , 4 , 4 , 20 , 15 , 8 } ; int N = arr . length ; int K = 5 ; System . out . print ( find@@ K@@ th@@ S@@ malle@@ st ( arr , N , K ) ) ; } }
Sort Matrix in altern@@ ating ascending and descending order row@@ wise 4392 | class GF@@ G { static int N = 4 ; static void func ( int a [ ] [ ] ) { int i , j , k ; for ( i = 0 ; i < N ; i ++ ) { if ( i % 2 == 0 ) { for ( j = 0 ; j < N ; j ++ ) { for ( k = j + 1 ; k < N ; ++ k ) { if ( a [ i ] [ j ] > a [ i ] [ k ] ) { int temp = a [ i ] [ j ] ; a [ i ] [ j ] = a [ i ] [ k ] ; a [ i ] [ k ] = temp ; } } } } else { for ( j = 0 ; j < N ; j ++ ) { for ( k = j + 1 ; k < N ; ++ k ) { if ( a [ i ] [ j ] < a [ i ] [ k ] ) { int temp = a [ i ] [ j ] ; a [ i ] [ j ] = a [ i ] [ k ] ; a [ i ] [ k ] = temp ; } } } } } for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) { System . out . print ( a [ i ] [ j ] + " ▁ " ) ; } System . out . print ( "@@ NEW_@@ LINE@@ "@@ )@@ ; } } public static void main ( String [ ] args ) { int a [ ] [ ] = { { 5 , 7 , 3 , 4 } , { 9 , 5 , 8 , 2 } , { 6 , 3 , 8 , 1 } , { 5 , 8 , 9 , 3 } } ; func ( a ) ; } }
Find weight of M@@ ST in a complete graph with edge 4412 | import java . util . * ; class GF@@ G { static HashMap < Integer , Integer > [ ] g = new HashMap [ 2@@ 0000@@ 5 ] ; static HashSet < Integer > s = new HashSet < > ( ) ; static HashSet < Integer > ns = new HashSet < > ( ) ; static void dfs ( int x ) { Vector < Integer > v = new Vector < > ( ) ; v . clear ( ) ; ns . clear ( ) ; for ( int it : s ) { if ( g [ x ] . get ( it ) != null ) { v . add ( it ) ; } else { ns . add ( it ) ; } } s = ns ; for ( int i : v ) { dfs ( i ) ; } } static void weight@@ Of@@ M@@ ST ( int N ) { int cnt = 0 ; for ( int i = 1 ; i <= N ; ++ i ) { s . add ( i ) ; } Vector < Integer > qt = new Vector < > ( ) ; for ( int t : s ) qt . add ( t ) ; while ( ! qt . isEmpty ( ) ) { ++ cnt ; int t = qt . get ( 0 ) ; qt . remove ( 0 ) ; dfs ( t ) ; } System . out . print ( cnt - 4 ) ; } public static void main ( String [ ] args ) { int N = 6 , M = 11 ; int edges [ ] [ ] = { { 1 , 3 } , { 1 , 4 } , { 1 , 5 } , { 1 , 6 } , { 2 , 3 } , { 2 , 4 } , { 2 , 5 } , { 2 , 6 } , { 3 , 4 } , { 3 , 5 } , { 3 , 6 } } ; for ( int i = 0 ; i < g . length ; i ++ ) g [ i ] = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < M ; ++ i ) { int u = edges [ i ] [ 0 ] ; int v = edges [ i ] [ 1 ] ; g [ u ] . put ( v , 1 ) ; g [ v ] . put ( u , 1 ) ; } weight@@ Of@@ M@@ ST ( N ) ; } }
Sort elements of an array in increasing order of absolute difference of adjacent elements 4414 | import java . util . * ; class GF@@ G { static void sort@@ Diff ( Vector < Integer > arr , int n ) { Collections . sort ( arr ) ; Vector < Integer > out = new Vector < Integer > ( ) ; while ( n > 0 ) { out . add ( arr . get ( n / 2 ) ) ; arr . remove ( n / 2 ) ; n = n - 1 ; } for ( int i : out ) System . out . print ( i + " ▁ " ) ; } public static void main ( String [ ] args ) { Integer [ ] a = { 8 , 1 , 2 , 3 , 0 } ; Vector < Integer > arr = new Vector < Integer > ( Arrays . asList ( a ) ) ; int n = 5 ; sort@@ Diff ( arr , n ) ; } }
Count of distinct possible pairs such that the element from A is greater than the element from B 4420 | import java . util . * ; class GF@@ G { static int count@@ Pairs ( int [ ] A , int [ ] B ) { int n = A . length ; int ans = 0 ; Arrays . sort ( A ) ; Arrays . sort ( B ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] > B [ ans ] ) { ans ++ ; } } return ans ; } public static void main ( String [ ] args ) { int [ ] A = { 30 , 28 , 45 , 22 } ; int [ ] B = { 35 , 25 , 22 , 48 } ; System . out . print ( count@@ Pairs ( A , B ) ) ; } }
Sort the Array by rever@@ sing the numbers in it 4450 | import java . util . * ; import java . lang . * ; import java . io . * ; class GF@@ G { static int rever@@ s@@ Digits ( int num ) { int rev_@@ num = 0 ; while ( num > 0 ) { rev_@@ num = rev_@@ num * 10 + num % 10 ; num = num / 10 ; } return rev_@@ num ; } static void sort@@ Arr ( int arr [ ] , int n ) { ArrayList < int [ ] > vp = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { vp . add ( new int [ ] { rever@@ s@@ Digits ( arr [ i ] ) , arr [ i ] } ) ; } Collections . sort ( vp , ( a , b ) -> a [ 0 ] - b [ 0 ] ) ; for ( int i = 0 ; i < vp . size ( ) ; i ++ ) System . out . print ( vp . get ( i ) [ 1 ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 12 , 10 , 102 , 31 , 15 } ; int n = arr . length ; sort@@ Arr ( arr , n ) ; } }
Ar@@ range numbers to form a valid sequence 4468 | import java . util . * ; class GF@@ G { static int [ ] org@@ az@@ ine@@ In@@ Order ( int [ ] vec , int [ ] op , int n ) { int [ ] result = new int [ n ] ; Arrays . sort ( vec ) ; int i = 0 , j = n - 1 , k = 0 ; while ( i <= j && k <= n - 2 ) { if ( op [ k ] == ' < ' ) { result [ k ] = vec [ i ++ ] ; } else { result [ k ] = vec [ j -- ] ; } k ++ ; } result [ n - 1 ] = vec [ i ] ; return result ; } public static void main ( String [ ] args ) { int [ ] vec = { 8 , 2 , 7 , 1 , 5 , 9 } ; int [ ] op = { ' > ' , ' > ' , ' < ' , ' > ' , ' < ' } ; int [ ] result = org@@ az@@ ine@@ In@@ Order ( vec , op , vec . length ) ; for ( int i = 0 ; i < result . length ; i ++ ) { System . out . print ( result [ i ] + " ▁ " ) ; } } }
Find Partition Line such that sum of values on left and right is equal 4488 | class GF@@ G { static int MAX = 1000 ; static boolean line@@ Exists ( int x [ ] , int y [ ] , int v [ ] , int n ) { int size = ( 2 * MAX ) + 1 ; long [ ] arr = new long [ size ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ x [ i ] + MAX ] += v [ i ] ; } for ( int i = 1 ; i < size ; i ++ ) arr [ i ] += arr [ i - 1 ] ; if ( arr [ size - 1 ] == 0 ) return true ; if ( arr [ size - 1 ] - arr [ 0 ] == 0 ) return true ; for ( int i = 1 ; i < size - 1 ; i ++ ) { if ( arr [ i - 1 ] == arr [ size - 1 ] - arr [ i - 1 ] ) return true ; if ( arr [ i - 1 ] == arr [ size - 1 ] - arr [ i ] ) return true ; if ( arr [ i ] == arr [ size - 1 ] - arr [ i ] ) return true ; } if ( arr [ size - 2 ] == 0 ) return true ; return false ; } public static void main ( String [ ] args ) { int x [ ] = { - 3 , 5 , 8 } ; int y [ ] = { 8 , 7 , 9 } ; int v [ ] = { 8 , 2 , 10 } ; int n = x . length ; if ( line@@ Exists ( x , y , v , n ) ) System . out . printf ( " Yes " ) ; else System . out . printf ( " No " ) ; } }
Maximum sum of minimum@@ s of pairs in an array 4490 | import java . util . Arrays ; class GF@@ G { static int max@@ Sum ( int a [ ] , int n ) { Arrays . sort ( a ) ; int sum = 0 ; for ( int i = 0 ; i < n - 1 ; i += 2 ) { sum += a [ i ] ; } return sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 2 , 1 , 4 , 5 } ; int n = arr . length ; System . out . println ( max@@ Sum ( arr , n ) ) ; } }
Minimum increment operations to make K elements equal 4499 | import java . util . Arrays ; class ge@@ ek@@ s@@ forge@@ e@@ ks { static int min@@ Operations ( int ar [ ] , int k ) { Arrays . sort ( ar ) ; int ops@@ Needed = 0 ; for ( int i = 0 ; i < k ; i ++ ) { ops@@ Needed += ar [ k - 1 ] - ar [ i ] ; } int ans = ops@@ Needed ; for ( int i = k ; i < ar . length ; i ++ ) { ops@@ Needed = ops@@ Needed - ( ar [ i - 1 ] - ar [ i - k ] ) ; ops@@ Needed += ( k - 1 ) * ( ar [ i ] - ar [ i - 1 ] ) ; ans = Math . min ( ans , ops@@ Needed ) ; } return ans ; } public static void main ( String [ ] args ) { int [ ] arr = { 3 , 1 , 9 , 100 } ; int n = arr . length ; int k = 3 ; System . out . printf ( " % d " , min@@ Operations ( arr , k ) ) ; } }
Un@@ bounded Fr@@ actional K@@ nap@@ s@@ ack 4524 | class GF@@ G { static float kn@@ ap@@ S@@ ack ( int W , float wt [ ] , float val [ ] , int n ) { float max@@ ratio = Integer . MIN_VALUE ; int max@@ index = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( val [ i ] / wt [ i ] ) > max@@ ratio ) { max@@ ratio = ( val [ i ] / wt [ i ] ) ; max@@ index = i ; } } return ( W * max@@ ratio ) ; } public static void main ( String [ ] args ) { float val [ ] = { 14 , 27 , 44 , 19 } ; float wt [ ] = { 6 , 7 , 9 , 8 } ; int n = val . length ; int W = 50 ; System . out . println ( kn@@ ap@@ S@@ ack ( W , wt , val , n ) ) ; } }
Merge two B@@ ST@@ s with constant extra space 4539 | import java . util . * ; class GF@@ G { static class Node { int data ; Node left ; Node right ; } ; static Node newNode ( int num ) { Node temp = new Node ( ) ; temp . data = num ; temp . left = temp . right = null ; return temp ; } static void in@@ order ( Node root ) { if ( root != null ) { in@@ order ( root . left ) ; System . out . print ( root . data + " ▁ " ) ; in@@ order ( root . right ) ; } } static void merge ( Node roo@@ t1 , Node root@@ 2 ) { if ( roo@@ t1 == null && root@@ 2 == null ) return ; if ( roo@@ t1 == null ) { in@@ order ( root@@ 2 ) ; return ; } if ( root@@ 2 == null ) { in@@ order ( roo@@ t1 ) ; return ; } Node temp1 = roo@@ t1 ; Node prev@@ 1 = null ; while ( temp1 . left != null ) { prev@@ 1 = temp1 ; temp1 = temp1 . left ; } Node temp2 = root@@ 2 ; Node pre@@ v2 = null ; while ( temp2 . left != null ) { pre@@ v2 = temp2 ; temp2 = temp2 . left ; } if ( temp1 . data <= temp2 . data ) { System . out . print ( temp1 . data + " ▁ " ) ; if ( prev@@ 1 == null ) { merge ( roo@@ t1 . right , root@@ 2 ) ; } else { prev@@ 1 . left = temp1 . right ; merge ( roo@@ t1 , root@@ 2 ) ; } } else { System . out . print ( temp2 . data + " ▁ " ) ; if ( pre@@ v2 == null ) { merge ( roo@@ t1 , root@@ 2 . right ) ; } else { pre@@ v2 . left = temp2 . right ; merge ( roo@@ t1 , root@@ 2 ) ; } } } public static void main ( String args [ ] ) { Node roo@@ t1 = null , root@@ 2 = null ; roo@@ t1 = newNode ( 3 ) ; roo@@ t1 . left = newNode ( 1 ) ; roo@@ t1 . right = newNode ( 5 ) ; root@@ 2 = newNode ( 4 ) ; root@@ 2 . left = newNode ( 2 ) ; root@@ 2 . right = newNode ( 6 ) ; merge ( roo@@ t1 , root@@ 2 ) ; } }
Count number of subsets whose median is also present in the same subset 4561 | import java . util . Arrays ; class GF@@ G { static long mod = 100000000@@ 7 ; static long [ ] [ ] arr = new long [ 1001 ] [ 1001 ] ; static void Pre@@ process ( ) { arr [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= 1000 ; ++ i ) { arr [ i ] [ 0 ] = 1 ; for ( int j = 1 ; j < i ; ++ j ) { arr [ i ] [ j ] = ( arr [ i - 1 ] [ j - 1 ] + arr [ i - 1 ] [ j ] ) % mod ; } arr [ i ] [ i ] = 1 ; } } static long pow@@ mod ( long a , long n ) { if ( n == 0 ) { return 1 ; } long pt = pow@@ mod ( a , n / 2 ) ; pt = ( pt * pt ) % mod ; if ( n % 2 == 1 ) { return ( pt * a ) % mod ; } else { return pt ; } } static long Count@@ Subset ( int [ ] val , int n ) { long ans = pow@@ mod ( 2 , n - 1 ) ; Arrays . sort ( val ) ; for ( int i = 0 ; i < n ; ++ i ) { int j = i + 1 ; while ( j < n && val [ j ] == val [ i ] ) { int r = n - 1 - j ; int l = i ; ans = ( ans + arr [ l + r ] [ l ] ) % mod ; j ++ ; } } return ans ; } public static void main ( String [ ] args ) { Pre@@ process ( ) ; int val [ ] = { 2 , 3 , 2 } ; int n = val . length ; System . out . println ( Count@@ Subset ( val , n ) ) ; } }
Re@@ order the position of the words in alphabe@@ tical order 4564 | import java . util . * ; class GF@@ G { static void re@@ Ar@@ range ( String words [ ] , int n ) { HashMap < String , Integer > freq = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { freq . put ( words [ i ] , ( i + 1 ) ) ; } Arrays . sort ( words ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( freq . get ( words [ i ] ) + " ▁ " ) ; } public static void main ( String [ ] args ) { String words [ ] = { " live " , " place " , " travel " , " word " , " sky " } ; int n = words . length ; re@@ Ar@@ range ( words , n ) ; } }
Delete odd and even numbers at alternate step such that sum of remaining elements is minim@@ ized 4570 | import java . util . * ; class GF@@ G { static int Minimize@@ left@@ Over@@ Sum ( int a [ ] , int n ) { Vector < Integer > v1 = new Vector < Integer > ( ) , v2 = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) v1 . add ( a [ i ] ) ; else v2 . add ( a [ i ] ) ; } if ( v1 . size ( ) > v2 . size ( ) ) { Collections . sort ( v1 ) ; Collections . sort ( v2 ) ; int x = v1 . size ( ) - v2 . size ( ) - 1 ; int sum = 0 ; int i = 0 ; while ( i < x ) { sum += v1 . get ( i ++ ) ; } return sum ; } else if ( v2 . size ( ) > v1 . size ( ) ) { Collections . sort ( v1 ) ; Collections . sort ( v2 ) ; int x = v2 . size ( ) - v1 . size ( ) - 1 ; int sum = 0 ; int i = 0 ; while ( i < x ) { sum += v2 . get ( i ++ ) ; } return sum ; } else return 0 ; } public static void main ( String [ ] args ) { int a [ ] = { 2 , 2 , 2 , 2 } ; int n = a . length ; System . out . println ( Minimize@@ left@@ Over@@ Sum ( a , n ) ) ; } }
Find A and B from list of di@@ visors 4588 | import java . util . * ; class Gf@@ G { static void print@@ Numbers ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int A = arr [ n - 1 ] , B = - 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( A % arr [ i ] != 0 ) { B = arr [ i ] ; break ; } if ( i - 1 >= 0 && arr [ i ] == arr [ i - 1 ] ) { B = arr [ i ] ; break ; } } System . out . print ( " A ▁ = ▁ " + A + " , ▁ B ▁ = ▁ " + B ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 4 , 8 , 16 , 1 , 2 , 4 } ; int n = arr . length ; print@@ Numbers ( arr , n ) ; } }
Find the modified array after performing k operations of given type 4589 | class GF@@ G { static void print@@ Array ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } static void remove@@ Min ( int arr [ ] , int n ) { int i , min@@ Val = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) min@@ Val = Math . min ( min@@ Val , arr [ i ] ) ; for ( i = 0 ; i < n ; i ++ ) arr [ i ] = arr [ i ] - min@@ Val ; } static void removeFrom@@ Max ( int arr [ ] , int n ) { int i , maxVal = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) maxVal = Math . max ( maxVal , arr [ i ] ) ; for ( i = 0 ; i < n ; i ++ ) arr [ i ] = maxVal - arr [ i ] ; } static void modify@@ Array ( int arr [ ] , int n , int k ) { if ( k % 2 == 0 ) remove@@ Min ( arr , n ) ; else removeFrom@@ Max ( arr , n ) ; print@@ Array ( arr , n ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 4 , 8 , 12 , 16 } ; int n = arr . length ; int k = 2 ; modify@@ Array ( arr , n , k ) ; } }
Product of non 4656 | import java . util . Arrays ; class GF@@ G { static int find@@ Product ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int prod = 1 * arr [ 0 ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) { prod = prod * arr [ i + 1 ] ; } } return prod ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 1 , 1 , 4 , 5 , 6 } ; int n = arr . length ; System . out . println ( find@@ Product ( arr , n ) ) ; } }
Sort 3 numbers 4687 | import java . io . * ; import java . util . * ; class GF@@ G { public static void main ( String [ ] args ) { int a [ ] = { 10 , 12 , 5 } ; Arrays . sort ( a ) ; for ( int i = 0 ; i < 3 ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; } }
Subtr@@ action in the Array 4720 | import java . util . * ; class GF@@ G { static void operations ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int i = 0 , sum = 0 ; while ( k -- > 0 ) { while ( i < n && arr [ i ] - sum == 0 ) i ++ ; if ( i < n && arr [ i ] - sum > 0 ) { System . out . print ( arr [ i ] - sum + " ▁ " ) ; sum = arr [ i ] ; } else System . out . println ( "0" ) ; } } public static void main ( String args [ ] ) { int k = 5 ; int arr [ ] = { 3 , 6 , 4 , 2 } ; int n = arr . length ; operations ( arr , n , k ) ; } }
Re@@ arrange an array to minimize sum of product of consecutive pair elements 4800 | import java . util . Arrays ; import java . util . Collections ; import java . util . Comparator ; import java . util . Vector ; class GF@@ G { static int min@@ Sum ( int arr [ ] , int n ) { Vector < Integer > even@@ Arr = new Vector < > ( ) ; Vector < Integer > odd@@ Arr = new Vector < > ( ) ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n / 2 ) { odd@@ Arr . add ( arr [ i ] ) ; } else { even@@ Arr . add ( arr [ i ] ) ; } } Comparator comparator = Collections . reverse@@ Order ( ) ; Collections . sort ( even@@ Arr , comparator ) ; int i = 0 , sum = 0 ; for ( int j = 0 ; j < even@@ Arr . size ( ) ; j ++ ) { arr [ i ++ ] = even@@ Arr . get ( j ) ; arr [ i ++ ] = odd@@ Arr . get ( j ) ; sum += even@@ Arr . get ( j ) * odd@@ Arr . get ( j ) ; } return sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 } ; int n = arr . length ; System . out . println ( " Minimum ▁ required ▁ sum ▁ = ▁ " + min@@ Sum ( arr , n ) ) ; System . out . println ( " Sorted ▁ array ▁ in ▁ required ▁ format ▁ : ▁ " ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } }
Sort even 4805 | import java . util . * ; class GF@@ G { static void bit@@ on@@ ic@@ Generator ( int arr [ ] , int n ) { Vector < Integer > even@@ Arr = new Vector < Integer > ( ) ; Vector < Integer > odd@@ Arr = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 != 1 ) { even@@ Arr . add ( arr [ i ] ) ; } else { odd@@ Arr . add ( arr [ i ] ) ; } } Collections . sort ( even@@ Arr ) ; Collections . sort ( odd@@ Arr , Collections . reverse@@ Order ( ) ) ; int i = 0 ; for ( int j = 0 ; j < even@@ Arr . size ( ) ; j ++ ) { arr [ i ++ ] = even@@ Arr . get ( j ) ; } for ( int j = 0 ; j < odd@@ Arr . size ( ) ; j ++ ) { arr [ i ++ ] = odd@@ Arr . get ( j ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 } ; int n = arr . length ; bit@@ on@@ ic@@ Generator ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } }
Sort an array according to count of set bits 4819 | import java . util . * ; class GF@@ G { static int count@@ Bits ( int a ) { int count = 0 ; while ( a > 0 ) { if ( ( a & 1 ) > 0 ) count += 1 ; a = a >> 1 ; } return count ; } static void sort@@ By@@ Set@@ BitCount ( int arr [ ] , int n ) { Vector < Integer > [ ] count = new Vector [ 32 ] ; for ( int i = 0 ; i < count . length ; i ++ ) count [ i ] = new Vector < Integer > ( ) ; int set@@ bit@@ count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { set@@ bit@@ count = count@@ Bits ( arr [ i ] ) ; count [ set@@ bit@@ count ] . add ( arr [ i ] ) ; } int j = 0 ; for ( int i = 31 ; i >= 0 ; i -- ) { Vector < Integer > v1 = count [ i ] ; for ( int p = 0 ; p < v1 . size ( ) ; p ++ ) arr [ j ++ ] = v1 . get ( p ) ; } } static void print@@ Arr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = arr . length ; sort@@ By@@ Set@@ BitCount ( arr , n ) ; print@@ Arr ( arr , n ) ; } }
Minimum sum of two numbers formed from digits of an array 4826 | import java . util . Arrays ; class GF@@ G { static int solve ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int a = 0 , b = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 != 0 ) a = a * 10 + arr [ i ] ; else b = b * 10 + arr [ i ] ; } return a + b ; } public static void main ( String [ ] args ) { int arr [ ] = { 6 , 8 , 4 , 5 , 2 , 3 } ; int n = arr . length ; System . out . print ( " Sum ▁ is ▁ " + solve ( arr , n ) ) ; } }
K 4882 | import java . util . * ; class GF@@ G { static long K@@ th@@ Solution ( long X , long K ) { long ans = 0 ; for ( int i = 0 ; i < 64 ; i ++ ) { if ( ( X & ( 1 << i ) ) == 0 ) { if ( ( K & 1 ) > 0 ) { ans |= ( 1 << i ) ; } K >>= 1 ; if ( K == 0 ) { break ; } } } return ans ; } public static void main ( String [ ] args ) { long X = 5 , K = 5 ; System . out . println ( K@@ th@@ Solution ( X , K ) ) ; } }
Find an an@@ agram of given String having different characters at corresponding indices 4892 | import java . io . * ; class GF@@ G { static void find@@ An@@ agram ( String s ) { String check = s ; int i = 0 , j = s . length ( ) - 1 ; while ( i < s . length ( ) && j >= 0 ) { if ( s . charAt ( i ) != s . charAt ( j ) && check . charAt ( i ) != s . charAt ( j ) && check . charAt ( j ) != s . charAt ( i ) ) { char temp = s . charAt ( i ) ; s = s . substring ( 0 , i ) + s . charAt ( j ) + s . substring ( i + 1 ) ; s = s . substring ( 0 , j ) + temp + s . substring ( j + 1 ) ; i ++ ; j = s . length ( ) - 1 ; } else { j -- ; } } if ( s . length ( ) % 2 != 0 ) { int mid = s . length ( ) / 2 ; if ( check . charAt ( mid ) == s . charAt ( mid ) ) { for ( i = 0 ; i < s . length ( ) ; i ++ ) { if ( check . charAt ( i ) != s . charAt ( mid ) && s . charAt ( i ) != s . charAt ( mid ) ) { char temp = s . charAt ( i ) ; s = s . substring ( 0 , i ) + s . charAt ( mid ) + s . substring ( i + 1 ) ; s = s . substring ( 0 , mid ) + temp + s . substring ( mid + 1 ) ; break ; } } } } boolean ok = true ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { if ( check . charAt ( i ) == s . charAt ( i ) ) { ok = false ; break ; } } if ( ok ) System . out . println ( s ) ; else System . out . println ( - 1 ) ; } public static void main ( String [ ] args ) { String S = " ge@@ ek " ; find@@ An@@ agram ( S ) ; } }
Minimum time required to print given string from a circular container based on given conditions 4895 | class GF@@ G { static void min@@ Time ( String word ) { int ans = 0 ; int curr = 0 ; for ( int i = 0 ; i < word . length ( ) ; i ++ ) { int k = ( int ) word . charAt ( i ) - 97 ; int a = Math . abs ( curr - k ) ; int b = 26 - Math . abs ( curr - k ) ; ans += Math . min ( a , b ) ; ans ++ ; curr = ( int ) word . charAt ( i ) - 97 ; } System . out . print ( ans ) ; } public static void main ( String [ ] args ) { String str = " z@@ j@@ pc " ; min@@ Time ( str ) ; } }
Generate an array of maximum sum such that each element exceeds all elements present either on its left or right 4913 | import java . io . * ; class GF@@ G { static void maximum@@ Sum@@ Array ( int arr [ ] , int N ) { int [ ] arr@@ A = new int [ ( N ) ] ; int [ ] ans = new int [ ( N ) ] ; int max@@ Sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) arr@@ A [ i ] = arr [ i ] ; for ( int i = 0 ; i < N ; i ++ ) { int [ ] arr@@ B = new int [ ( N ) ] ; int maximum = arr@@ A [ i ] ; arr@@ B [ i ] = maximum ; for ( int j = i - 1 ; j >= 0 ; j -- ) { arr@@ B [ j ] = Math . min ( maximum , arr@@ A [ j ] ) ; maximum = arr@@ B [ j ] ; } maximum = arr@@ A [ i ] ; for ( int j = i + 1 ; j < N ; j ++ ) { arr@@ B [ j ] = Math . min ( maximum , arr@@ A [ j ] ) ; maximum = arr@@ B [ j ] ; } int sum = 0 ; for ( int j = 0 ; j < N ; j ++ ) sum += arr@@ B [ j ] ; if ( sum > max@@ Sum ) { max@@ Sum = sum ; ans = arr@@ B ; } } for ( int val : ans ) { System . out . print ( val + " ▁ " ) ; } } public static void main ( String [ ] args ) { int A [ ] = { 10 , 6 , 8 } ; int N = A . length ; maximum@@ Sum@@ Array ( A , N ) ; } }
Lex@@ ico@@ graphic@@ ally largest string possible by repeatedly appending first character of two given strings 4921 | import java . io . * ; class GF@@ G { static String lar@@ gest@@ Merge ( String word@@ 1 , String word@@ 2 ) { String merge = " " ; while ( word@@ 1 . length ( ) != 0 || word@@ 2 . length ( ) != 0 ) { if ( word@@ 1 . compareTo ( word@@ 2 ) == 0 || ( word@@ 1 . compareTo ( word@@ 2 ) > 0 ) ) { merge = merge + word@@ 1 . charAt ( 0 ) ; word@@ 1 = word@@ 1 . substring ( 1 ) ; } else { merge = merge + word@@ 2 . charAt ( 0 ) ; word@@ 2 = word@@ 2 . substring ( 1 ) ; } } return merge ; } public static void main ( String [ ] args ) { String S1 = " xyz@@ xyz " ; String S2 = " xy@@ wz@@ xy@@ x " ; System . out . println ( lar@@ gest@@ Merge ( S1 , S2 ) ) ; } }
Count the combination of 4 s and / or 5 s required to make each Array element 0 4929 | import java . io . * ; import java . util . Arrays ; class GF@@ G { static void sum@@ Of@@ Combin@@ ation@@ Of@@ 4@@ OR@@ 5 ( int [ ] arr , int N ) { int [ ] ans = new int [ N ] ; Arrays . fill ( ans , - 1 ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] < 4 ) { continue ; } int sum = Integer . MAX_VALUE ; int cnt = 0 ; for ( int j = 0 ; j <= arr [ i ] ; j += 4 ) { if ( ( arr [ i ] - j ) % 5 == 0 ) { sum = Math . min ( sum , cnt + ( arr [ i ] - j ) / 5 ) ; } cnt ++ ; } if ( sum != Integer . MAX_VALUE ) ans [ i ] = sum ; } for ( int num : ans ) System . out . printf ( num + " ▁ " ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 7 , 15 , 17 , 22 } ; int N = arr . length ; sum@@ Of@@ Combin@@ ation@@ Of@@ 4@@ OR@@ 5 ( arr , N ) ; } }
Lex@@ ico@@ graphic@@ ally largest string possible by at most K replacements 4966 | class GF@@ G { static String lar@@ gest@@ String ( String s , int k ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) != ' z ' && k > 0 ) { s = s . replace ( s . charAt ( i ) , ' z ' ) ; k -- ; } } return s ; } public static void main ( String args [ ] ) { String s = " db@@ za " ; int k = 1 ; System . out . println ( lar@@ gest@@ String ( s , k ) ) ; } }
Count characters of a string which when removed individ@@ ually makes the string equal to another string 4969 | class GF@@ G { static void Remove@@ One@@ Char ( String A , String B , int N , int M ) { int X = 0 ; int Y = N - 1 ; for ( int i = 0 ; i < M ; i ++ ) { if ( A . charAt ( X ) != B . charAt ( i ) ) break ; X ++ ; } for ( int i = M - 1 ; i >= 0 ; i -- ) { if ( A . charAt ( Y ) != B . charAt ( i ) ) break ; Y -- ; } if ( N - M == 1 && Y < X ) { System . out . println ( X - Y + 1 ) ; for ( int i = Y ; i <= X ; i ++ ) System . out . print ( i + 1 + " ▁ " ) ; System . out . println ( ) ; } else System . out . println ( - 1 ) ; } static public void main ( String [ ] args ) { String A = " ab@@ aa@@ c " ; String B = " ab@@ ac " ; int N = A . length ( ) ; int M = B . length ( ) ; Remove@@ One@@ Char ( A , B , N , M ) ; } }
Count of pairs of integers up to X and Y that generates equal Quo@@ ti@@ ent and Remain@@ der 4974 | import java . io . * ; class GF@@ G { static void count@@ Of@@ Pairs ( int x , int y ) { int count = 0 ; for ( int k = 1 ; k * k <= x ; ++ k ) { count += Math . max ( 0 , Math . min ( y , x / k - 1 ) - k ) ; } System . out . print ( count ) ; } public static void main ( String [ ] args ) { int x = 4 ; int y = 5 ; count@@ Of@@ Pairs ( x , y ) ; } }
Find the date after next half year from a given date 4981 | class GF@@ G { public static void getDate ( int d , String m ) { int [ ] days = { 31 , 29 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 } ; String [ ] month = { " January " , " February " , " March " , " April " , " May " , " June " , " July " , " August " , " Sep@@ tember " , " Octo@@ ber " , " No@@ vember " , " December " } ; int cnt = 183 ; int cur_@@ month = 0 ; for ( int i = 0 ; i < 12 ; i ++ ) if ( m == month [ i ] ) cur_@@ month = i ; int cur_@@ date = d ; while ( true ) { while ( cnt > 0 && cur_@@ date <= days [ cur_@@ month ] ) { cnt -= 1 ; cur_@@ date += 1 ; } if ( cnt == 0 ) break ; cur_@@ month = ( cur_@@ month + 1 ) % 12 ; cur_@@ date = 1 ; } System . out . println ( cur_@@ date + " ▁ " + month [ cur_@@ month ] ) ; } public static void main ( String args [ ] ) { int D = 15 ; String M = " January " ; getDate ( D , M ) ; } }
Find the last element after repeatedly removing every second element from either end altern@@ ately 5011 | import java . lang . * ; class GF@@ G { public static void print@@ Last@@ Element ( int arr [ ] , int N ) { boolean left@@ Turn = true ; int remain@@ Elements = N ; int step = 1 ; int head = 1 ; while ( remain@@ Elements > 1 ) { if ( left@@ Turn ) { head = head + step ; } else { if ( remain@@ Elements % 2 == 1 ) head = head + step ; } remain@@ Elements = remain@@ Elements / 2 ; step = step * 2 ; left@@ Turn = ! left@@ Turn ; } System . out . print ( arr [ head - 1 ] ) ; } public static void main ( String args [ ] ) { int [ ] arr = { 2 , 3 , 5 , 6 } ; int N = arr . length ; print@@ Last@@ Element ( arr , N ) ; } }
Check if a string can be split into 3 sub@@ strings such that one of them is a substring of the other two 5018 | import java . io . * ; import java . lang . * ; import java . util . * ; class GF@@ G { static String freq@@ Check ( String S , int N ) { int hash [ ] = new int [ 26 ] ; for ( int i = 0 ; i < N ; i ++ ) { hash [ S . charAt ( i ) - ' a ' ] ++ ; } for ( int i = 0 ; i < 26 ; i ++ ) { if ( hash [ i ] > 2 ) { return " Yes " ; } } return " No " ; } public static void main ( String [ ] args ) { String S = " ge@@ ek@@ seek@@ forge@@ e@@ ks " ; int N = S . length ( ) ; System . out . println ( freq@@ Check ( S , N ) ) ; } }
Minimum number of steps required to place all 1 s at a single index 5032 | import java . util . * ; import java . lang . * ; class GF@@ G { static void min@@ steps ( int [ ] A ) { int n = A . length ; int [ ] left = new int [ n ] ; Arrays . fill ( left , 0 ) ; int [ ] right = new int [ n ] ; Arrays . fill ( right , 0 ) ; int [ ] res = new int [ n ] ; Arrays . fill ( res , 0 ) ; int count = A [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { left [ i ] = left [ i - 1 ] + count ; count += A [ i ] ; } count = A [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { right [ i ] = right [ i + 1 ] + count ; count += A [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { res [ i ] = left [ i ] + right [ i ] ; System . out . print ( res [ i ] + " ▁ " ) ; } System . out . println ( ) ; } public static void main ( String [ ] args ) { int [ ] A = { 1 , 0 , 1 , 0 } ; min@@ steps ( A ) ; } }
Minim@@ ize fli@@ ps on K 5033 | class GF@@ G { static void minimum@@ Operations ( int [ ] A , int K ) { int [ ] is@@ flipped = new int [ A . length + 1 ] ; int ans = 0 ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( i > 0 ) { is@@ flipped [ i ] += is@@ flipped [ i - 1 ] ; is@@ flipped [ i ] %= 2 ; } if ( A [ i ] == 0 && is@@ flipped [ i ] == 0 ) { if ( ( A . length - i + 1 ) <= K ) { System . out . println ( - 1 ) ; return ; } ans ++ ; is@@ flipped [ i ] ++ ; is@@ flipped [ i + K ] -- ; } else if ( A [ i ] == 1 && is@@ flipped [ i ] != 0 ) { if ( ( A . length - i + 1 ) <= K ) { System . out . println ( - 1 ) ; return ; } ans ++ ; is@@ flipped [ i ] ++ ; is@@ flipped [ i + K ] -- ; } } System . out . println ( ans ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 0 , 1 , 0 } ; int K = 1 ; minimum@@ Operations ( arr , K ) ; } }
Reduce all array elements to zero by performing given operations thri@@ ce 5054 | import java . util . * ; class GF@@ G { static void Convert@@ Array ( int arr [ ] , int N ) { if ( N == 1 ) { System . out . println ( " Operation ▁ 1 ▁ : ▁ " + 1 + " ▁ " + 1 ) ; System . out . println ( " Added ▁ elements : ▁ " + - 1 * arr [ 0 ] ) ; System . out . println ( ) ; System . out . println ( " Operation ▁ 2 ▁ : ▁ " + 1 + " ▁ " + 1 ) ; System . out . println ( " Added ▁ elements : ▁ " + 1 * arr [ 0 ] ) ; System . out . println ( ) ; System . out . println ( " Operation ▁ 3 ▁ : ▁ " + 1 + " ▁ " + 1 ) ; System . out . println ( " Added ▁ elements : ▁ " + - 1 * arr [ 0 ] ) ; } else { System . out . println ( " Operation ▁ 1 ▁ : ▁ " + 1 + " ▁ " + N ) ; System . out . print ( " Added ▁ elements : ▁ " ) ; for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( - 1 * arr [ i ] * N + " ▁ " ) ; } System . out . println ( ) ; System . out . println ( ) ; System . out . println ( " Operation ▁ 2 ▁ : ▁ " + 1 + " ▁ " + ( N - 1 ) ) ; System . out . print ( " Added ▁ elements : ▁ " ) ; for ( int i = 0 ; i < N - 1 ; i ++ ) { System . out . print ( arr [ i ] * ( N - 1 ) + " ▁ " ) ; } System . out . println ( ) ; System . out . println ( ) ; System . out . println ( " Operation ▁ 3 ▁ : ▁ " + N + " ▁ " + N ) ; System . out . print ( " Added ▁ elements : ▁ " ) ; System . out . println ( arr [ N - 1 ] * ( N - 1 ) ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 2 , 4 } ; int N = arr . length ; Convert@@ Array ( arr , N ) ; } }
Count pairs from an array with even product of count of distinct prime factors 5055 | import java . util . * ; class GF@@ G { static int MAX = 1000000 ; static void count@@ Of@@ Prime@@ factors ( int [ ] Count@@ Distin@@ ct ) { boolean [ ] prime = new boolean [ MAX + 1 ] ; for ( int i = 0 ; i <= MAX ; i ++ ) { Count@@ Distin@@ ct [ i ] = 0 ; prime [ i ] = true ; } for ( int i = 2 ; i <= MAX ; i ++ ) { if ( prime [ i ] == true ) { Count@@ Distin@@ ct [ i ] = 1 ; for ( int j = i * 2 ; j <= MAX ; j += i ) { Count@@ Distin@@ ct [ j ] ++ ; prime [ j ] = false ; } } } } static int Count@@ Even@@ Pair ( int A [ ] , int B [ ] , int N , int M ) { int [ ] count@@ Distin@@ ct = new int [ ( MAX + 1 ) ] ; count@@ Of@@ Prime@@ factors ( count@@ Distin@@ ct ) ; int even@@ Count = 0 ; int odd@@ Count = 0 ; int even@@ Pairs = 0 ; for ( int i = 0 ; i < M ; i ++ ) { if ( count@@ Distin@@ ct [ B [ i ] ] == 0 ) continue ; if ( ( count@@ Distin@@ ct [ B [ i ] ] & 1 ) != 0 ) { odd@@ Count ++ ; } else { even@@ Count ++ ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( count@@ Distin@@ ct [ A [ i ] ] == 0 ) continue ; if ( ( count@@ Distin@@ ct [ A [ i ] ] & 1 ) != 0 ) { even@@ Pairs += ( even@@ Count ) ; } else { even@@ Pairs += even@@ Count + odd@@ Count ; } } return even@@ Pairs ; } public static void main ( String [ ] args ) { int A [ ] = { 1 , 2 , 3 } ; int B [ ] = { 4 , 5 , 6 } ; int N = A . length ; int M = B . length ; System . out . println ( Count@@ Even@@ Pair ( A , B , N , M ) ) ; } }
Minimum array elements required to be subtrac@@ ted from either end to reduce K to 0 5057 | import java . util . * ; class GF@@ G { static int lon@@ gest@@ Sub@@ array ( int [ ] arr , int N , int K ) { HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ; int sum = 0 , maxLen = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; if ( sum == K ) maxLen = i + 1 ; if ( ! um . containsKey ( sum ) ) um . put ( sum , i ) ; if ( um . containsKey ( sum - K ) ) { if ( maxLen < ( i - um . get ( sum - K ) ) ) maxLen = i - um . get ( sum - K ) ; } } return maxLen ; } static void min@@ Required@@ Operation ( int [ ] arr , int N , int K ) { int Total@@ Sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) Total@@ Sum += arr [ i ] ; int maxLen = lon@@ gest@@ Sub@@ array ( arr , N , Total@@ Sum - K ) ; if ( maxLen == - 1 ) { System . out . println ( - 1 ) ; } else System . out . println ( N - maxLen ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 3 , 1 , 1 , 2 } ; int K = 4 ; int N = arr . length ; min@@ Required@@ Operation ( arr , N , K ) ; } }
Count even and odd Bit@@ wise X@@ OR@@ s of consecutive numbers in a range [ L , R ] starting from L 5066 | import java . io . * ; import java . util . * ; class GF@@ G { static void count@@ Even@@ Odd ( int L , int R ) { int range = R - L + 1 ; int even = ( range / 4 ) * 2 ; if ( ( L & 1 ) != 0 && ( range % 4 == 3 ) ) { even ++ ; } else if ( ( L & 1 ) == 0 && ( range % 4 != 0 ) ) { even ++ ; } System . out . print ( " Even ▁ = ▁ " + even + " , ▁ Odd ▁ = ▁ " + ( range - even ) ) ; } public static void main ( String [ ] args ) { int L = 2 , R = 7 ; count@@ Even@@ Odd ( L , R ) ; } }
Count maximum number of consu@@ mable candi@@ es 5075 | public class GF@@ G { static int maximum@@ C@@ and@@ y ( int [ ] candi@@ es , int [ ] safety , int N , int M ) { int total = 0 ; int ans = Integer . MAX_VALUE ; boolean all_@@ safe = true ; for ( int i = 0 ; i < N ; i ++ ) { if ( candi@@ es [ i ] + M > safety [ i ] ) { all_@@ safe = false ; ans = Math . min ( ans , safety [ i ] ) ; } else { ans = Math . min ( ans , candi@@ es [ i ] + M ) ; } total += candi@@ es [ i ] ; } if ( all_@@ safe ) return total ; else return ans ; } public static void main ( String [ ] args ) { int A [ ] = { 4 , 5 , 2 , 3 } ; int B [ ] = { 8 , 13 , 6 , 4 } ; int M = 5 ; int N = A . length ; System . out . println ( maximum@@ C@@ and@@ y ( A , B , N , M ) ) ; } }
Generate an N 5081 | import java . io . * ; import java . util . * ; class GF@@ G { static void construct_@@ Array ( int N , int K ) { for ( int i = 1 ; i <= N ; i ++ ) { System . out . print ( K * i + " ▁ " ) ; } } public static void main ( String [ ] args ) { int N = 3 , K = 3 ; construct_@@ Array ( N , K ) ; } }
Generate an N 5083 | import java . io . * ; class GF@@ G { static void Print ( int N ) { if ( ( N / 2 ) % 2 == 1 || ( N % 2 == 1 ) ) { System . out . print ( - 1 ) ; return ; } int Cur@@ Even = 2 , Cur@@ Odd = 1 ; int Sum@@ Odd = 0 , Sum@@ Even = 0 ; for ( int i = 0 ; i < ( N / 2 ) ; i ++ ) { System . out . print ( Cur@@ Even + " ▁ " ) ; Sum@@ Even += Cur@@ Even ; Cur@@ Even += 2 ; } for ( int i = 0 ; i < N / 2 - 1 ; i ++ ) { System . out . print ( Cur@@ Odd + " ▁ " ) ; Sum@@ Odd += Cur@@ Odd ; Cur@@ Odd += 2 ; } Cur@@ Odd = Sum@@ Even - Sum@@ Odd ; System . out . println ( Cur@@ Odd ) ; } public static void main ( String [ ] args ) { int N = 12 ; Print ( N ) ; } }
Minimum prefix increments required to make all elements of an array multip@@ les of another array 5088 | import java . util . * ; class GF@@ G { static int Minimum@@ Moves ( int A [ ] , int B [ ] , int N ) { int total@@ Operations = 0 ; int carry = 0 ; int K = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { int nearest@@ Multiple = ( int ) ( Math . ceil ( ( double ) ( A [ i ] + carry ) / ( double ) ( B [ i ] ) ) * B [ i ] ) ; K = nearest@@ Multiple - ( A [ i ] + carry ) ; total@@ Operations += K ; carry += K ; } return total@@ Operations ; } public static void main ( String [ ] args ) { int A [ ] = { 3 , 4 , 5 , 2 , 5 , 5 , 9 } ; int B [ ] = { 1 , 1 , 9 , 6 , 3 , 8 , 7 } ; int N = A . length ; System . out . print ( Minimum@@ Moves ( A , B , N ) + "@@ NEW_@@ LINE@@ "@@ )@@ ; } }
Minim@@ ize deviation of an array by given operations 5091 | import java . io . * ; import java . util . * ; class GF@@ G { static void minimum@@ Deviation ( int A [ ] , int N ) { TreeSet < Integer > s = new TreeSet < Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) s . add ( A [ i ] ) ; else s . add ( 2 * A [ i ] ) ; } int diff = s . last ( ) - s . first ( ) ; while ( ( s . last ( ) % 2 == 0 ) ) { int max@@ El = s . last ( ) ; s . remove ( max@@ El ) ; s . add ( max@@ El / 2 ) ; diff = Math . min ( diff , s . last ( ) - s . first ( ) ) ; } System . out . print ( diff ) ; } public static void main ( String [ ] args ) { int A [ ] = { 4 , 1 , 5 , 20 , 3 } ; int N = A . length ; minimum@@ Deviation ( A , N ) ; } }
Find the player with least 0 s after empty@@ ing a Binary String by removing non 5096 | class GF@@ G { public static void Find@@ win@@ ner@@ Of@@ Game ( String S ) { int cnt@@ Zero = 0 ; int cnt@@ Con@@ One = 0 ; int nim@@ Sum = 0 ; int N = S . length ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( S . charAt ( i ) == '1' ) { cnt@@ Con@@ One += 1 ; } else { nim@@ Sum ^= cnt@@ Con@@ One ; cnt@@ Con@@ One = 0 ; cnt@@ Zero ++ ; } } nim@@ Sum ^= cnt@@ Con@@ One ; if ( cnt@@ Zero % 2 == 0 ) { System . out . print ( " Ti@@ e " ) ; } else if ( nim@@ Sum != 0 ) { System . out . print ( " player ▁ 1" ) ; } else { System . out . print ( " player ▁ 2" ) ; } } public static void main ( String [ ] args ) { String S = "01@@ 100@@ 11" ; Find@@ win@@ ner@@ Of@@ Game ( S ) ; } }
Minim@@ ize array elements required to be incremented or decre@@ mented to convert given array into a Fi@@ bon@@ ac@@ ci Series 5118 | import java . util . * ; class GF@@ G { static int min@@ Moves ( int [ ] arr ) { int N = arr . length ; if ( N <= 2 ) return 0 ; int ans = Integer . MAX_VALUE ; for ( int i = - 1 ; i <= 1 ; i ++ ) { for ( int j = - 1 ; j <= 1 ; j ++ ) { int num1 = arr [ 0 ] + i ; int num2 = arr [ 1 ] + j ; int flag = 1 ; int moves = Math . abs ( i ) + Math . abs ( j ) ; for ( int idx = 2 ; idx < N ; idx ++ ) { int num = num1 + num2 ; if ( Math . abs ( arr [ idx ] - num ) > 1 ) flag = 0 ; else moves += Math . abs ( arr [ idx ] - num ) ; num1 = num2 ; num2 = num ; } if ( flag > 0 ) ans = Math . min ( ans , moves ) ; } } if ( ans == Integer . MAX_VALUE ) return - 1 ; return ans ; } public static void main ( String [ ] args ) { int [ ] arr = { 4 , 8 , 9 , 17 , 27 } ; System . out . print ( min@@ Moves ( arr ) ) ; } }
Maximum possible sum of K even multip@@ les of 5 in a given range 5140 | import java . util . * ; class GF@@ G { static void max@@ k@@ sum ( int L , int R , int K ) { int N = ( R / 10 - L / 10 ) + 1 ; if ( K > N ) { System . out . print ( " - 1" ) ; return ; } R = R / 10 ; int X = R - K ; int sum = 10 * ( ( R * ( R + 1 ) ) / 2 - ( X * ( X + 1 ) ) / 2 ) ; System . out . print ( sum ) ; } public static void main ( String [ ] args ) { int L = 16 , R = 60 , K = 4 ; max@@ k@@ sum ( L , R , K ) ; } }
Maxim@@ ize length of longest non 5192 | import java . util . * ; class GF@@ G { static int find@@ Lon@@ gest@@ Non@@ Decre@@ asing ( int A [ ] , int N ) { int res = 0 ; int start = 0 ; int end = N - 1 ; int prev = - 1 ; while ( start <= end ) { if ( A [ start ] <= A [ end ] ) { if ( prev == - 1 ) { prev = A [ start ] ; res ++ ; start ++ ; } else { if ( A [ start ] >= prev ) { res ++ ; prev = A [ start ] ; start ++ ; } else if ( A [ end ] >= prev ) { res ++ ; prev = A [ end ] ; end -- ; } else { break ; } } } else { if ( prev == - 1 ) { prev = A [ end ] ; res ++ ; end -- ; } else { if ( A [ end ] >= prev ) { res ++ ; prev = A [ end ] ; end -- ; } else if ( A [ start ] >= prev ) { res ++ ; prev = A [ start ] ; start ++ ; } else { break ; } } } } return res ; } public static void main ( String [ ] args ) { int A [ ] = { 1 , 1 , 3 , 5 , 4 , 3 , 6 , 2 , 1 } ; int N = A . length ; System . out . print ( find@@ Lon@@ gest@@ Non@@ Decre@@ asing ( A , N ) ) ; } }
Non 5196 | import java . util . * ; import java . lang . * ; class GF@@ G { static void find@@ Pairs ( int N ) { for ( int i = 0 ; i <= N ; i ++ ) { System . out . print ( " ( " + i + " , ▁ " + ( N - i ) + " ) , ▁ " ) ; } } public static void main ( String [ ] args ) { int N = 5 ; find@@ Pairs ( N ) ; } }
Minim@@ ize adding odd and subtrac@@ ting even numbers to make all array elements equal to K 5216 | class GF@@ G { public static int Min@@ Operation ( int arr [ ] , int N , int K ) { int cnt@@ Op@@ e = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( K > arr [ i ] ) { if ( ( K - arr [ i ] ) % 2 == 0 ) { cnt@@ Op@@ e += 2 ; } else { cnt@@ Op@@ e += 1 ; } } else if ( K < arr [ i ] ) { if ( ( K - arr [ i ] ) % 2 == 0 ) { cnt@@ Op@@ e += 1 ; } else { cnt@@ Op@@ e += 2 ; } } } return cnt@@ Op@@ e ; } public static void main ( String [ ] args ) { int arr [ ] = { 8 , 7 , 2 , 1 , 3 } ; int K = 5 ; int N = arr . length ; System . out . println ( Min@@ Operation ( arr , N , K ) ) ; } }
Neare@@ st smaller number to N having multiplic@@ ative inverse under modulo N equal to that number 5222 | import java . io . * ; class GF@@ G { static int cl@@ st@@ Num ( int N ) { return ( N - 1 ) ; } public static void main ( String [ ] args ) { int N = 11 ; System . out . println ( cl@@ st@@ Num ( N ) ) ; } }
Mean of array generated by products of all pairs of the given array 5228 | import java . util . * ; class GF@@ G { static double pair@@ Product@@ Mean ( int arr [ ] , int N ) { Vector < Integer > pair@@ Array = new Vector < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { int pair@@ Product = arr [ i ] * arr [ j ] ; pair@@ Array . add ( pair@@ Product ) ; } } int length = pair@@ Array . size ( ) ; float sum = 0 ; for ( int i = 0 ; i < length ; i ++ ) sum += pair@@ Array . get ( i ) ; float mean ; if ( length != 0 ) mean = sum / length ; else mean = 0 ; return mean ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 4 , 8 } ; int N = arr . length ; System . out . format ( " % .2f " , pair@@ Product@@ Mean ( arr , N ) ) ; } }
Minim@@ ize positive product of two given numbers by at most N decre@@ ments 5238 | import java . io . * ; class GF@@ G { static int min@@ Prod ( int X , int Y , int N ) { if ( X <= Y ) { if ( N < X ) return ( X - N ) * Y ; else { return Math . max ( Y - ( N - X + 1 ) , 1 ) ; } } if ( Y >= N ) return ( Y - N ) * X ; return Math . max ( X - ( N - Y + 1 ) , 1 ) ; } public static void main ( String [ ] args ) { int X = 47 , Y = 42 , N = 167 ; System . out . println ( min@@ Prod ( X , Y , N ) ) ; } }
Check if any permutation of array contains sum of every adjacent pair not di@@ visible by 3 5268 | class GF@@ G { static void factor@@ sOf@@ 3 ( int arr [ ] , int N ) { int a = 0 , b = 0 , c = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 3 == 0 ) a ++ ; else if ( arr [ i ] % 3 == 1 ) b ++ ; else if ( arr [ i ] % 3 == 2 ) c ++ ; } if ( a >= 1 && a <= b + c + 1 ) System . out . print ( " Yes " + "@@ NEW_@@ LINE@@ "@@ )@@ ; else if ( a == 0 && b == 0 && c > 0 ) System . out . print ( " Yes " + "@@ NEW_@@ LINE@@ "@@ )@@ ; else if ( a == 0 && c == 0 && b > 0 ) System . out . print ( " Yes " + "@@ NEW_@@ LINE@@ "@@ )@@ ; else System . out . print ( " No " + "@@ NEW_@@ LINE@@ "@@ )@@ ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 3 } ; int N = arr . length ; factor@@ sOf@@ 3 ( arr , N ) ; } }
Maxim@@ ize count of empty water bott@@ les from N filled bott@@ les 5272 | import java . util . * ; class GF@@ G { static int max@@ Bo@@ tt@@ les ( int n , int e ) { int s = 0 , b = 0 ; int a = n ; while ( a != 0 ) { s = s + a ; a = ( a + b ) / e ; b = n - ( a * e ) ; n = a + b ; } return s ; } public static void main ( String [ ] args ) { int n = 9 , e = 3 ; int s = max@@ Bo@@ tt@@ les ( n , e ) ; System . out . print ( s + "@@ NEW_@@ LINE@@ "@@ )@@ ; } }
Count all N digit numbers whose digits are multiple of X 5273 | class GF@@ G { static int power ( int x , int n ) { int temp ; if ( n == 0 ) return 1 ; temp = power ( x , n / 2 ) ; if ( n % 2 == 0 ) return temp * temp ; else return x * temp * temp ; } static int count_@@ Tot@@ al_@@ Numbers ( int n , int x ) { int total , multip@@ les = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { if ( i % x == 0 ) multip@@ les ++ ; } if ( n == 1 ) return multip@@ les ; total = ( multip@@ les - 1 ) * power ( multip@@ les , n - 1 ) ; return total ; } public static void main ( String [ ] args ) { int N = 1 , X = 3 ; System . out . printf ( " % d ▁ " , count_@@ Tot@@ al_@@ Numbers ( N , X ) ) ; } }
Minim@@ ize array length by repeatedly replacing pairs of un@@ equal adjacent array elements by their sum 5282 | class GF@@ G { static int minLength ( int A [ ] , int N ) { int elem = A [ 0 ] , count = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( A [ i ] == elem ) { count ++ ; } else { break ; } } if ( count == N ) return N ; else return 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 1 , 3 , 1 } ; int N = arr . length ; System . out . print ( minLength ( arr , N ) + "@@ NEW_@@ LINE@@ "@@ )@@ ; } }
Split array into minimum number of sub@@ arrays having GC@@ D of its first and last element exce@@ eding 1 5287 | import java . util . * ; class GF@@ G { static int min@@ Sub@@ arrays ( int arr [ ] , int n ) { int right = n - 1 ; int left = 0 ; int sub@@ arrays = 0 ; while ( right >= 0 ) { for ( left = 0 ; left <= right ; left += 1 ) { if ( __@@ gcd ( arr [ left ] , arr [ right ] ) > 1 ) { sub@@ arrays += 1 ; right = left - 1 ; break ; } if ( left == right && __@@ gcd ( arr [ left ] , arr [ right ] ) == 1 ) { return 0 ; } } } return sub@@ arrays ; } static int __@@ gcd ( int a , int b ) { return b == 0 ? a : __@@ gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { int N = 6 ; int arr [ ] = { 2 , 3 , 4 , 4 , 4 , 3 } ; System . out . print ( min@@ Sub@@ arrays ( arr , N ) ) ; } }
Find all missing numbers from a given sorted array 5298 | import java . util . * ; class GF@@ G { static void print@@ Missing@@ Elements ( int arr [ ] , int N ) { int diff = arr [ 0 ] - 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] - i != diff ) { while ( diff < arr [ i ] - i ) { System . out . print ( ( i + diff ) + " ▁ " ) ; diff ++ ; } } } } public static void main ( String [ ] args ) { int arr [ ] = { 6 , 7 , 10 , 11 , 13 } ; int N = arr . length ; print@@ Missing@@ Elements ( arr , N ) ; } }
Find all missing numbers from a given sorted array 5299 | import java . util . * ; class GF@@ G { static void print@@ Missing@@ Elements ( int arr [ ] , int N ) { int [ ] b = new int [ arr [ N - 1 ] + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { b [ arr [ i ] ] = 1 ; } for ( int i = arr [ 0 ] ; i <= arr [ N - 1 ] ; i ++ ) { if ( b [ i ] == 0 ) { System . out . print ( i + " ▁ " ) ; } } } public static void main ( String [ ] args ) { int arr [ ] = { 6 , 7 , 10 , 11 , 13 } ; int N = arr . length ; print@@ Missing@@ Elements ( arr , N ) ; } }
Possible number of Trees having N vertex 5306 | import java . util . * ; class GF@@ G { static int mod = ( int ) 1e@@ 9 + 7 ; static int power ( int x , int y ) { if ( y == 0 ) return 1 ; int p = power ( x , y / 2 ) % mod ; p = ( p * p ) % mod ; if ( ( y & 1 ) != 0 ) p = ( x * p ) % mod ; return p ; } static int NumberOf@@ Trees ( int arr [ ] , int N ) { int max@@ Element = Arrays . stream ( arr ) . max ( ) . getAs@@ Int ( ) ; int [ ] level = new int [ max@@ Element + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { level [ arr [ i ] ] ++ ; } if ( arr [ 0 ] != 0 level [ 0 ] != 1 ) { return 0 ; } int ans = 1 ; for ( int i = 0 ; i < max@@ Element ; i ++ ) { ans = ( ans * power ( level [ i ] , level [ i + 1 ] ) ) % mod ; } return ans ; } public static void main ( String [ ] args ) { int N = 7 ; int arr [ ] = { 0 , 3 , 2 , 1 , 2 , 2 , 1 } ; System . out . print ( NumberOf@@ Trees ( arr , N ) ) ; } }
Count of carry operations on adding two Binary numbers 5309 | class GF@@ G { static int carry@@ Count ( int num1 , int num2 ) { int count = 0 ; while ( num2 != 0 ) { int carry = num1 & num2 ; num1 = num1 ^ num2 ; num2 = carry << 1 ; count += Integer . bit@@ Count ( num2 ) ; } return count ; } public static void main ( String [ ] args ) { int A = 15 , B = 10 ; System . out . print ( carry@@ Count ( A , B ) ) ; } }
Lead a life problem 5312 | import java . util . * ; class GF@@ G { static void calculate@@ Pro@@ fit ( int n , int [ ] ear@@ nings , int [ ] cost , int e ) { int pro@@ fit = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int ear@@ ning_@@ per_@@ day = 0 ; int dail@@ y_@@ sp@@ ent_@@ food = 0 ; if ( i == ( n - 1 ) ) { ear@@ ning_@@ per_@@ day = ear@@ nings [ i ] * e ; pro@@ fit = pro@@ fit + ear@@ ning_@@ per_@@ day ; break ; } if ( cost [ i ] < ear@@ nings [ i ] ) { ear@@ ning_@@ per_@@ day = ear@@ nings [ i ] * e ; dail@@ y_@@ sp@@ ent_@@ food = cost [ i ] * e ; pro@@ fit = pro@@ fit + ear@@ ning_@@ per_@@ day - dail@@ y_@@ sp@@ ent_@@ food ; } } System . out . print ( pro@@ fit + "@@ NEW_@@ LINE@@ "@@ )@@ ; } public static void main ( String [ ] args ) { int n = 4 ; int ear@@ nings [ ] = { 1 , 8 , 6 , 7 } ; int cost [ ] = { 1 , 3 , 4 , 1 } ; int e = 5 ; calculate@@ Pro@@ fit ( n , ear@@ nings , cost , e ) ; } }
Split N into two integers whose addition to A and B makes them equal 5336 | import java . util . * ; class GF@@ G { static void find@@ Pair ( int A , int B , int N ) { int X , Y ; X = N - B + A ; if ( X % 2 != 0 ) { System . out . print ( " - 1" ) ; } else { X = X / 2 ; Y = N - X ; System . out . print ( X + " ▁ " + Y ) ; } } public static void main ( String [ ] args ) { int A = 1 ; int B = 3 ; int N = 4 ; find@@ Pair ( A , B , N ) ; } }
Find the amplitude and number of w@@ aves for the given array 5339 | import java . util . * ; class GF@@ G { static boolean check ( int a [ ] , int n ) { int ma = a [ 1 ] - a [ 0 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( ( a [ i ] > a [ i - 1 ] && a [ i + 1 ] < a [ i ] ) || ( a [ i ] < a [ i - 1 ] && a [ i + 1 ] > a [ i ] ) ) ma = Math . max ( ma , Math . abs ( a [ i ] - a [ i + 1 ] ) ) ; else return false ; } System . out . print ( " Ampli@@ tude ▁ = ▁ " + ma ) ; System . out . println ( ) ; return true ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 1 , 5 , 0 , 7 , - 6 } ; int n = a . length ; int wave = ( n - 1 ) / 2 ; if ( check ( a , n ) ) System . out . print ( " W@@ aves ▁ = ▁ " + wave ) ; else System . out . print ( " - 1" ) ; } }
Generate a Binary String without any consecutive 0 ' s ▁ and ▁ at ▁ most ▁ K ▁ consecutive ▁ 1' s 5384 | class GF@@ G { static String Construct@@ Binary@@ String ( int N , int M , int K ) { if ( M < ( N - 1 ) || M > K * ( N + 1 ) ) return " - 1" ; String ans = " " ; int l = Math . min ( K , M / ( N - 1 ) ) ; int temp = N ; while ( temp != 0 ) { temp -- ; ans += '0' ; if ( temp == 0 ) break ; for ( int i = 0 ; i < l ; i ++ ) { ans += '1' ; } } M -= ( N - 1 ) * l ; if ( M == 0 ) return ans ; l = Math . min ( M , K ) ; for ( int i = 0 ; i < l ; i ++ ) ans += '1' ; M -= l ; while ( M > 0 ) { ans = '1' + ans ; M -- ; } return ans ; } public static void main ( String [ ] args ) { int N = 5 , M = 9 , K = 2 ; System . out . println ( Construct@@ Binary@@ String ( N , M , K ) ) ; } }
Perf@@ ect Square factors of a Number 5393 | import java . util . * ; class GF@@ G { static int noOf@@ Factors ( int N ) { if ( N == 1 ) return 1 ; int count = 0 ; int ans = 1 ; while ( N % 2 == 0 ) { count ++ ; N = N / 2 ; } ans *= ( count / 2 + 1 ) ; for ( int i = 3 ; i * i <= N ; i = i + 2 ) { count = 0 ; while ( N % i == 0 ) { count ++ ; N = N / i ; } ans *= ( count / 2 + 1 ) ; } return ans ; } public static void main ( String [ ] args ) { int N = 100 ; System . out . print ( noOf@@ Factors ( N ) ) ; } }
Path traver@@ sed using exactly M coins in K jumps 5481 | import java . io . * ; class GF@@ G { static void print_@@ path ( int N , int jump , int coin ) { if ( jump > coin || jump * ( N - 1 ) < coin ) { System . out . println ( " - 1" ) ; } else { int pos = 1 ; while ( jump > 0 ) { int tmp = Math . min ( N - 1 , coin - ( jump - 1 ) ) ; if ( pos + tmp <= N ) { pos += tmp ; } else { pos -= tmp ; } System . out . print ( pos + " ▁ " ) ; ; coin -= tmp ; jump -= 1 ; } } } public static void main ( String [ ] args ) { int N = 5 , K = 4 , M = 12 ; print_@@ path ( N , K , M ) ; } }
Minimum fli@@ ps required to generate continuous sub@@ strings of 0 â €@@ ™ s and 1 â €@@ ™ s 5491 | import java . io . * ; class GF@@ G { static int min@@ Changes ( String str , int N ) { int res ; int count@@ 0 = 0 , count@@ 1 = 0 ; for ( char x : str . toCharArray ( ) ) { if ( x == '0' ) count@@ 0 ++ ; } res = count@@ 0 ; for ( char x : str . toCharArray ( ) ) { if ( x == '0' ) count@@ 0 -- ; if ( x == '1' ) count@@ 1 ++ ; res = Math . min ( res , count@@ 1 + count@@ 0 ) ; } return res ; } public static void main ( String [ ] args ) { int N = 9 ; String str = "@@ 0001@@ 0100@@ 1" ; System . out . println ( min@@ Changes ( str , N ) ) ; } }
Count number of triangles possible for the given sides range 5493 | import java . util . Scanner ; import java . util . Arrays ; class GF@@ G { public static int count_@@ triangles ( int a , int b , int c , int d ) { int ans = 0 ; for ( int x = a ; x <= b ; ++ x ) { int num_@@ greater_@@ th@@ an_@@ d = Math . max ( d , c + x ) - Math . max ( d , b + x - 1 ) ; ans += num_@@ greater_@@ th@@ an_@@ d * ( d - c + 1 ) ; int r = Math . min ( Math . max ( c , c + x ) , d ) - c ; int l = Math . min ( Math . max ( c , b + x - 1 ) , d ) - c ; int x1 = ( r * ( r + 1 ) ) / 2 ; int x2 = ( l * ( l + 1 ) ) / 2 ; ans += x1 - x2 ; } return ans ; } public static void main ( String args [ ] ) { int a = 2 , b = 3 , c = 4 , d = 5 ; System . out . println ( count_@@ triangles ( a , b , c , d ) ) ; } }
Split a number as sum of K numbers which are not di@@ visible by K 5500 | class GF@@ G { static void print@@ K@@ Parts ( int N , int K ) { if ( N % K == 0 ) { for ( int i = 1 ; i < K ; i ++ ) System . out . print ( "1 , ▁ " ) ; System . out . print ( N - ( K - 1 ) + "@@ NEW_@@ LINE@@ "@@ )@@ ; } else { if ( K == 2 ) { System . out . print ( " Not ▁ Possible " + "@@ NEW_@@ LINE@@ "@@ )@@ ; return ; } for ( int i = 1 ; i < K - 1 ; i ++ ) System . out . print ( 1 + " , ▁ " ) ; System . out . print ( 2 + " , ▁ " + ( N - K ) + "@@ NEW_@@ LINE@@ "@@ )@@ ; } } public static void main ( String [ ] args ) { int N = 18 , K = 5 ; print@@ K@@ Parts ( N , K ) ; } }
Find the maximum sum ( a + b ) for a given input integer N satis@@ fying the given condition 5538 | import java . util . * ; class GF@@ G { static int get@@ Largest@@ Sum ( int N ) { int max_@@ sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = i + 1 ; j <= N ; j ++ ) { if ( i * j % ( i + j ) == 0 ) max_@@ sum = Math . max ( max_@@ sum , i + j ) ; } } return max_@@ sum ; } public static void main ( String [ ] args ) { int N = 25 ; int max_@@ sum = get@@ Largest@@ Sum ( N ) ; System . out . print ( max_@@ sum ) ; } }
Number of indices pair such that element pair sum from first Array is greater than second Array 5558 | import java . util . * ; class GF@@ G { static long get@@ Pairs ( Vector < Integer > A , Vector < Integer > B , int n ) { int [ ] D = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { D [ i ] = A . get ( i ) - B . get ( i ) ; } Arrays . sort ( D ) ; long total = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( D [ i ] > 0 ) { total += n - i - 1 ; } else { int k = upper_bound ( D , 0 , D . length , - D [ i ] ) ; total += n - k ; } } return total ; } static int upper_bound ( int [ ] a , int low , int high , int element ) { while ( low < high ) { int middle = low + ( high - low ) / 2 ; if ( a [ middle ] > element ) high = middle ; else low = middle + 1 ; } return low ; } public static void main ( String [ ] args ) { int n = 5 ; Vector < Integer > A = new Vector < Integer > ( ) ; Vector < Integer > B = new Vector < Integer > ( ) ; A . add ( 4 ) ; A . add ( 8 ) ; A . add ( 2 ) ; A . add ( 6 ) ; A . add ( 2 ) ; B . add ( 4 ) ; B . add ( 5 ) ; B . add ( 4 ) ; B . add ( 1 ) ; B . add ( 3 ) ; System . out . print ( get@@ Pairs ( A , B , n ) ) ; } }
Minimum number of Fac@@ tori@@ als whose sum is equal to N 5562 | import java . util . * ; class GF@@ G { static int [ ] fact = new int [ 14 ] ; static int size = 1 ; static void pre@@ Compute ( int N ) { fact [ 0 ] = 1 ; for ( int i = 1 ; fact [ i - 1 ] <= N ; i ++ ) { fact [ i ] = ( fact [ i - 1 ] * i ) ; size ++ ; } } static void find@@ Min ( int N ) { pre@@ Compute ( N ) ; int original@@ N = N ; Vector < Integer > ans = new Vector < Integer > ( ) ; for ( int i = size - 1 ; i >= 0 ; i -- ) { while ( N >= fact [ i ] ) { N -= fact [ i ] ; ans . add ( fact [ i ] ) ; } } System . out . print ( ans . size ( ) + "@@ NEW_@@ LINE@@ "@@ )@@ ; for ( int i = 0 ; i < ans . size ( ) ; i ++ ) System . out . print ( ans . get ( i ) + " ▁ " ) ; } public static void main ( String [ ] args ) { int n = 27 ; find@@ Min ( n ) ; } }
Count of sub@@ arrays with sum at least K 5591 | class GF@@ G { static int k_@@ sum ( int a [ ] , int n , int k ) { int r = 0 , sum = 0 ; int ans = 0 ; for ( int l = 0 ; l < n ; l ++ ) { while ( sum < k ) { if ( r == n ) break ; else { sum += a [ r ] ; r ++ ; } } if ( sum < k ) break ; ans += n - r + 1 ; sum -= a [ l ] ; } return ans ; } public static void main ( String [ ] args ) { int a [ ] = { 6 , 1 , 2 , 7 } , k = 10 ; int n = a . length ; System . out . println ( k_@@ sum ( a , n , k ) ) ; } }
Maximum Sum of Products of two arrays by to@@ g@@ gl@@ ing adjacent bits 5597 | class GF@@ G { static int max@@ Sum ( int ar@@ r1 [ ] , int ar@@ r2 [ ] , int n ) { int initial@@ Par@@ ity = 0 , final@@ Par@@ ity = 0 ; int sum = 0 , min@@ Positive = Integer . MAX_VALUE , max@@ Negative = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { initial@@ Par@@ ity += ar@@ r2 [ i ] ; if ( ar@@ r1 [ i ] >= 0 ) { final@@ Par@@ ity += 1 ; sum += ar@@ r1 [ i ] ; min@@ Positive = Math . min ( min@@ Positive , ar@@ r1 [ i ] ) ; } else { max@@ Negative = Math . max ( max@@ Negative , ar@@ r1 [ i ] ) ; } } if ( initial@@ Par@@ ity % 2 == final@@ Par@@ ity % 2 ) { return sum ; } else { if ( min@@ Positive + max@@ Negative >= 0 ) { return sum + max@@ Negative ; } else { return sum - min@@ Positive ; } } } public static void main ( String [ ] args ) { int ar@@ r1 [ ] = { 2 , - 4 , 5 , 3 } ; int ar@@ r2 [ ] = { 0 , 1 , 0 , 1 } ; int n = ar@@ r1 . length ; System . out . println ( max@@ Sum ( ar@@ r1 , ar@@ r2 , n ) ) ; } }
Find the minimum capacity of the train required to hold the pass@@ eng@@ ers 5605 | import java . util . * ; class GF@@ G { static int min@@ Capacity ( int enter [ ] , int exit [ ] , int n ) { int min@@ Cap = 0 ; int curr@@ Cap = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr@@ Cap = curr@@ Cap + enter [ i ] - exit [ i ] ; min@@ Cap = Math . max ( min@@ Cap , curr@@ Cap ) ; } return min@@ Cap ; } public static void main ( String [ ] args ) { int enter [ ] = { 3 , 5 , 2 , 0 } ; int exit [ ] = { 0 , 2 , 4 , 4 } ; int n = enter . length ; System . out . println ( min@@ Capacity ( enter , exit , n ) ) ; } }
Minimum element left from the array after performing given operations 5610 | import java . util . * ; class GF@@ G { static int get@@ Min ( int arr [ ] , int n ) { int min@@ Val = Arrays . stream ( arr ) . min ( ) . getAs@@ Int ( ) ; return min@@ Val ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 3 , 1 , 6 , 9 } ; int n = arr . length ; System . out . println ( get@@ Min ( arr , n ) ) ; } }
Length of longest sub 5625 | import java . io . * ; class GF@@ G { static int lon@@ gest@@ Sub@@ array ( int arr [ ] , int n ) { int max@@ Mean = 0 ; for ( int i = 1 ; i < n ; i ++ ) max@@ Mean = Math . max ( max@@ Mean , ( arr [ i ] + arr [ i - 1 ] ) / 2 ) ; int ans = 0 ; int sub@@ array@@ Length = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= max@@ Mean ) ans = Math . max ( ans , ++ sub@@ array@@ Length ) ; else sub@@ array@@ Length = 0 ; return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 3 , 3 , 2 , 1 , 4 } ; int n = arr . length ; System . out . println ( lon@@ gest@@ Sub@@ array ( arr , n ) ) ; } }
Convert given integer X to the form 2 ^ N 5627 | import java . io . * ; class GF@@ G { static int MAX = 24 ; static int count@@ Op ( int x ) { int arr [ ] = new int [ MAX ] ; arr [ 0 ] = 1 ; for ( int i = 1 ; i < MAX ; i ++ ) arr [ i ] = arr [ i - 1 ] * 2 ; int temp = x ; boolean flag = true ; int ans = 0 ; int operations = 0 ; boolean flag@@ 2 = false ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( arr [ i ] - 1 == x ) flag@@ 2 = true ; if ( arr [ i ] > x ) { ans = i ; break ; } } if ( flag@@ 2 ) return 0 ; while ( flag ) { if ( arr [ ans ] < x ) ans ++ ; operations ++ ; for ( int i = 0 ; i < MAX ; i ++ ) { int take = x ^ ( arr [ i ] - 1 ) ; if ( take <= arr [ ans ] - 1 ) { if ( take > temp ) temp = take ; } } if ( temp == arr [ ans ] - 1 ) { flag = false ; break ; } temp ++ ; operations ++ ; x = temp ; if ( x == arr [ ans ] - 1 ) flag = false ; } return operations ; } public static void main ( String [ ] args ) { int x = 39 ; System . out . println ( count@@ Op ( x ) ) ; } }
Maximum money that can be with@@ drawn in two steps 5639 | import java . util . * ; class GF@@ G { static int max@@ Coins ( int X , int Y ) { if ( X < Y ) { swap ( X , Y ) ; } int coins = X ; X -- ; coins += Math . max ( X , Y ) ; return coins ; } static void swap ( int X , int Y ) { int temp = X ; X = Y ; Y = temp ; } public static void main ( String [ ] args ) { int X = 7 , Y = 5 ; System . out . println ( max@@ Coins ( X , Y ) ) ; } }
Replace all elements by difference of sums of positive and negative numbers after that element 5664 | class GF@@ G { static void print@@ Array ( int N , int [ ] arr ) { for ( int i = 0 ; i < N ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; System . out . println ( ) ; } static void repl@@ aced@@ Array ( int N , int [ ] arr ) { int pos_@@ sum , neg_@@ sum , i , j , diff ; for ( i = 0 ; i < N ; i ++ ) { pos_@@ sum = 0 ; neg_@@ sum = 0 ; for ( j = i + 1 ; j < N ; j ++ ) { if ( arr [ j ] > 0 ) pos_@@ sum += arr [ j ] ; else neg_@@ sum += arr [ j ] ; } diff = Math . abs ( pos_@@ sum ) - Math . abs ( neg_@@ sum ) ; arr [ i ] = Math . abs ( diff ) ; } } public static void main ( String args [ ] ) { int N = 5 ; int [ ] arr = { 1 , - 1 , 2 , 3 , - 2 } ; repl@@ aced@@ Array ( N , arr ) ; print@@ Array ( N , arr ) ; N = 6 ; int [ ] ar@@ r1 = { - 3 , - 4 , - 2 , 5 , 1 , - 2 } ; repl@@ aced@@ Array ( N , ar@@ r1 ) ; print@@ Array ( N , ar@@ r1 ) ; } }
Find the Side of the smallest Square that can contain given 4 Big Squ@@ ares 5688 | import java . util . Arrays ; class GF@@ G { static long max ( long a , long b ) { if ( a > b ) return a ; else return b ; } static long smalle@@ st@@ Side ( long a [ ] ) { Arrays . sort ( a ) ; long side@@ 1 , side@@ 2 , side@@ 3 , side@@ 4 , side@@ 11 , side@@ 12 , side@@ Of@@ Square ; side@@ 1 = a [ 0 ] + a [ 3 ] ; side@@ 2 = a [ 1 ] + a [ 2 ] ; side@@ 3 = a [ 0 ] + a [ 1 ] ; side@@ 4 = a [ 2 ] + a [ 3 ] ; side@@ 11 = max ( side@@ 1 , side@@ 2 ) ; side@@ 12 = max ( side@@ 3 , side@@ 4 ) ; side@@ Of@@ Square = max ( side@@ 11 , side@@ 12 ) ; return side@@ Of@@ Square ; } public static void main ( String [ ] args ) { long side [ ] = new long [ 4 ] ; System . out . println ( " Test ▁ Case ▁ 1" ) ; side [ 0 ] = 2 ; side [ 1 ] = 2 ; side [ 2 ] = 2 ; side [ 3 ] = 2 ; System . out . println ( smalle@@ st@@ Side ( side ) ) ; System . out . println ( " Test Case 2 "@@ )@@ ; side [ 0 ] = 100000000@@ 000000@@ L ; side [ 1 ] = 12345@@ 0000000000@@ L ; side [ 2 ] = 987@@ 65@@ 0000000000@@ L ; side [ 3 ] = 987@@ 65432@@ 1000000@@ L ; System . out . println ( smalle@@ st@@ Side ( side ) ) ; } }
Maximum sum of all elements of array after performing given operations 5699 | import java . io . * ; class GF@@ G { static int max@@ Sub@@ Array@@ Sum ( int a [ ] , int size ) { int max_@@ so@@ _f@@ ar = Integer . MIN_VALUE , max_@@ ending_@@ here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_@@ ending_@@ here = max_@@ ending_@@ here + a [ i ] ; if ( max_@@ so@@ _f@@ ar < max_@@ ending_@@ here ) max_@@ so@@ _f@@ ar = max_@@ ending_@@ here ; if ( max_@@ ending_@@ here < 0 ) max_@@ ending_@@ here = 0 ; } return max_@@ so@@ _f@@ ar ; } static int max@@ Sum ( int a [ ] , int n ) { int S = 0 ; int S1 = max@@ Sub@@ Array@@ Sum ( a , n ) ; for ( int i = 0 ; i < n ; i ++ ) S += a [ i ] ; return ( 2 * S1 - S ) ; } public static void main ( String [ ] args ) { int a [ ] = { - 35 , 32 , - 24 , 0 , 27 , - 10 , 0 , - 19 } ; int n = a . length ; System . out . println ( max@@ Sum ( a , n ) ) ; } }
Maximum score after fli@@ pping a Binary Matrix at@@ most K times 5722 | import java . util . * ; class GF@@ G { static int n = 3 ; static int m = 4 ; static int max@@ Matrix@@ Score ( int A [ ] [ ] , int K ) { HashMap < Integer , Integer > update = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( A [ i ] [ 0 ] == 0 ) { int ans = 0 ; for ( int j = 1 ; j < m ; ++ j ) ans = ( int ) ( ans + A [ i ] [ j ] * Math . pow ( 2 , m - j - 1 ) ) ; update . put ( ans , i ) ; } } for ( Map . Entry < Integer , Integer > it : update . entrySet ( ) ) if ( K > 0 ) { int idx = it . getValue ( ) ; for ( int j = 0 ; j < m ; ++ j ) A [ idx ] [ j ] = ( A [ idx ] [ j ] + 1 ) % 2 ; K -- ; } int ans = 0 ; for ( int j = 0 ; j < m ; ++ j ) { int zero = 0 , one = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( A [ i ] [ j ] == 0 ) zero ++ ; else one ++ ; } if ( K > 0 && zero > one ) { ans += zero * Math . pow ( 2 , m - j - 1 ) ; K -- ; } else ans += one * Math . pow ( 2 , m - j - 1 ) ; } return ans ; } public static void main ( String [ ] args ) { int A [ ] [ ] = { { 0 , 0 , 1 , 1 } , { 1 , 0 , 1 , 0 } , { 1 , 1 , 0 , 0 } } ; int K = 2 ; System . out . print ( max@@ Matrix@@ Score ( A , K ) ) ; } }
Re@@ arrange an array to maxim@@ ize sum of Bit@@ wise AND of same 5929 | import java . io . * ; import java . lang . * ; import java . util . * ; public class GF@@ G { static int maxim@@ ize@@ And ( int i , int mask , int A [ ] , int B [ ] , int N , int [ ] [ ] dp ) { if ( i == N ) return 0 ; if ( dp [ i ] [ mask ] != - 1 ) return dp [ i ] [ mask ] ; for ( int j = 0 ; j < N ; ++ j ) { if ( ( mask & ( 1 << j ) ) == 0 ) { dp [ i ] [ mask ] = Math . max ( dp [ i ] [ mask ] , ( A [ i ] & B [ j ] ) + maxim@@ ize@@ And ( i + 1 , mask | ( 1 << j ) , A , B , N , dp ) ) ; } } return dp [ i ] [ mask ] ; } static int maxim@@ ize@@ And@@ Util ( int A [ ] , int B [ ] , int N ) { int dp [ ] [ ] = new int [ N ] [ ( 1 << N ) + 1 ] ; for ( int dd [ ] : dp ) Arrays . fill ( dd , - 1 ) ; return maxim@@ ize@@ And ( 0 , 0 , A , B , N , dp ) ; } public static void main ( String [ ] args ) { int A [ ] = { 3 , 5 , 7 , 11 } ; int B [ ] = { 2 , 6 , 10 , 12 } ; int N = A . length ; System . out . print ( maxim@@ ize@@ And@@ Util ( A , B , N ) ) ; } }
Length of longest increasing sub@@ sequence in a string 5958 | import java . util . * ; class GF@@ G { static int mn = - 214748364@@ 8 ; static int li@@ s@@ O@@ tim@@ ised ( String s ) { int [ ] dp = new int [ 30 ] ; Arrays . fill ( dp , 0 ) ; int N = s . length ( ) ; int lis = mn ; for ( int i = 0 ; i < N ; i ++ ) { int val = ( int ) s . charAt ( i ) - 97 ; int curr = 0 ; for ( int j = 0 ; j < val ; j ++ ) { curr = Math . max ( curr , dp [ j ] ) ; } curr ++ ; lis = Math . max ( lis , curr ) ; dp [ val ] = Math . max ( dp [ val ] , curr ) ; } return lis ; } public static void main ( String [ ] args ) { String s = " f@@ dry@@ uti@@ ag@@ h@@ f@@ se " ; System . out . print ( li@@ s@@ O@@ tim@@ ised ( s ) ) ; } }
Sum of length of two smallest subsets possible from a given array with sum at least K 5959 | import java . io . * ; import java . lang . * ; import java . util . * ; class GF@@ G { static int MAX = ( int ) ( 1e@@ 9 ) ; static int Minimum@@ Length ( int A [ ] , int N , int K ) { Arrays . sort ( A ) ; int suffix [ ] = new int [ N + 1 ] ; for ( int i = N - 1 ; i >= 0 ; i -- ) suffix [ i ] = suffix [ i + 1 ] + A [ i ] ; int dp [ ] [ ] = new int [ N + 1 ] [ K + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) for ( int j = 0 ; j <= K ; j ++ ) dp [ i ] [ j ] = MAX ; dp [ N ] [ 0 ] = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = K ; j >= 0 ; j -- ) { if ( j <= A [ i ] ) { dp [ i ] [ j ] = A [ i ] ; continue ; } if ( dp [ i + 1 ] [ j - A [ i ] ] == MAX ) dp [ i ] [ j ] = MAX ; else dp [ i ] [ j ] = Math . min ( dp [ i + 1 ] [ j ] , dp [ i + 1 ] [ j - A [ i ] ] + A [ i ] ) ; } } for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( suffix [ i ] - dp [ i ] [ K ] >= K ) { return N - i ; } } return - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 7 , 4 , 5 , 6 , 8 } ; int K = 13 ; int N = arr . length ; System . out . println ( Minimum@@ Length ( arr , N , K ) ) ; } }
Probability that the sum of all numbers obtained on throwing a di@@ ce N times lies between two given integers 5989 | class GF@@ G { static float [ ] [ ] dp = new float [ 105 ] [ 6@@ 05 ] ; static float find ( int N , int sum ) { if ( N < 0 sum < 0 ) return 0 ; if ( dp [ N ] [ sum ] > 0 ) return dp [ N ] [ sum ] ; if ( sum > 6 * N sum < N ) return 0 ; if ( N == 1 ) { if ( sum >= 1 && sum <= 6 ) return ( float ) ( 1.0 / 6 ) ; else return 0 ; } for ( int i = 1 ; i <= 6 ; i ++ ) dp [ N ] [ sum ] = dp [ N ] [ sum ] + find ( N - 1 , sum - i ) / 6 ; return dp [ N ] [ sum ] ; } public static void main ( String [ ] args ) { int N = 4 , a = 13 , b = 17 ; float probability = 0.0f ; for ( int sum = a ; sum <= b ; sum ++ ) probability = probability + find ( N , sum ) ; System . out . printf ( " % .@@ 6f " , probability ) ; } }
Medi@@ an of Bit@@ wise XOR of all sub@@ matrices starting from the top left corner 5998 | import java . util . * ; class GF@@ G { static double find@@ Med@@ XOR ( int mat [ ] [ ] , int N , int M ) { int dp [ ] [ ] = new int [ N ] [ M ] ; int med [ ] = new int [ N * M ] ; dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] ; med [ 0 ] = dp [ 0 ] [ 0 ] ; int len = 1 ; for ( int i = 1 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ^ mat [ i ] [ 0 ] ; med [ len ++ ] = dp [ i ] [ 0 ] ; } for ( int i = 1 ; i < M ; i ++ ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] ^ mat [ 0 ] [ i ] ; med [ len ++ ] = dp [ 0 ] [ i ] ; } for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 1 ; j < M ; j ++ ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ^ dp [ i ] [ j - 1 ] ^ dp [ i - 1 ] [ j - 1 ] ^ mat [ i ] [ j ] ; med [ len ++ ] = dp [ i ] [ j ] ; } } Arrays . sort ( med ) ; if ( len % 2 == 0 ) { return ( med [ ( len / 2 ) ] + med [ ( len / 2 ) - 1 ] ) / 2.0 ; } return med [ len / 2 ] ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 2 } , { 2 , 3 } } ; int N = mat . length ; int M = 2 ; System . out . println ( find@@ Med@@ XOR ( mat , N , M ) ) ; } }
Check if an array can be split into 3 sub@@ sequences of equal sum or not 6083 | import java . util . * ; class GF@@ G { static HashMap < String , Integer > dp = new HashMap < String , Integer > ( ) ; static int check@@ Equal@@ Sum@@ Util ( int arr [ ] , int N , int sm@@ 1 , int sm@@ 2 , int sm@@ 3 , int j ) { String s = String . valueOf ( sm@@ 1 ) + " _ " + String . valueOf ( sm@@ 2 ) + String . valueOf ( j ) ; if ( j == N ) { if ( sm@@ 1 == sm@@ 2 && sm@@ 2 == sm@@ 3 ) return 1 ; else return 0 ; } if ( dp . containsKey ( s ) ) return dp . get ( s ) ; else { int l = check@@ Equal@@ Sum@@ Util ( arr , N , sm@@ 1 + arr [ j ] , sm@@ 2 , sm@@ 3 , j + 1 ) ; int m = check@@ Equal@@ Sum@@ Util ( arr , N , sm@@ 1 , sm@@ 2 + arr [ j ] , sm@@ 3 , j + 1 ) ; int r = check@@ Equal@@ Sum@@ Util ( arr , N , sm@@ 1 , sm@@ 2 , sm@@ 3 + arr [ j ] , j + 1 ) ; dp . put ( s , Math . max ( Math . max ( l , m ) , r ) ) ; return dp . get ( s ) ; } } static void check@@ Equal@@ Sum ( int arr [ ] , int N ) { int sum@@ 1 , sum@@ 2 , sum@@ 3 ; sum@@ 1 = sum@@ 2 = sum@@ 3 = 0 ; if ( check@@ Equal@@ Sum@@ Util ( arr , N , sum@@ 1 , sum@@ 2 , sum@@ 3 , 0 ) == 1 ) { System . out . print ( " Yes " ) ; } else { System . out . print ( " No " ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 17 , 34 , 59 , 23 , 17 , 67 , 57 , 2 , 18 , 59 , 1 } ; int N = arr . length ; check@@ Equal@@ Sum ( arr , N ) ; } }
Binary Matrix after fli@@ pping sub@@ matrices in given range for Q queries 6084 | import java . util . * ; import java . lang . * ; class GF@@ G { static void manipulation ( int [ ] [ ] matrix , int [ ] q ) { int x1 = q [ 0 ] , y1 = q [ 1 ] , x2 = q [ 2 ] , y2 = q [ 3 ] ; for ( int i = x1 - 1 ; i < x2 ; i ++ ) { for ( int j = y1 - 1 ; j < y2 ; j ++ ) { if ( matrix [ i ] [ j ] == 1 ) matrix [ i ] [ j ] = 0 ; else matrix [ i ] [ j ] = 1 ; } } } static void queri@@ es_@@ fx@@ n ( int [ ] [ ] matrix , int [ ] [ ] queries ) { for ( int [ ] q : queries ) manipulation ( matrix , q ) ; } public static void main ( String [ ] args ) { int [ ] [ ] matrix = { { 0 , 1 , 0 } , { 1 , 1 , 0 } } ; int [ ] [ ] queries = { { 1 , 1 , 2 , 3 } , { 1 , 1 , 1 , 1 } , { 1 , 2 , 2 , 3 } } ; queri@@ es_@@ fx@@ n ( matrix , queries ) ; System . out . print ( " [ " ) ; for ( int i = 0 ; i < matrix . length ; i ++ ) { System . out . print ( " [ " ) ; for ( int j = 0 ; j < matrix [ i ] . length ; j ++ ) System . out . print ( matrix [ i ] [ j ] + " ▁ " ) ; if ( i == matrix . length - 1 ) System . out . print ( " ] " ) ; else System . out . print ( " ] , ▁ " ) ; } System . out . print ( " ] " ) ; } }
Count of ways in which N can be represented as sum of Fi@@ bon@@ ac@@ ci numbers without repeti@@ tion 6096 | import java . util . * ; class GF@@ G { static long [ ] fi@@ b = new long [ 101 ] ; static long [ ] d@@ p1 = new long [ 101 ] ; static long [ ] d@@ p2 = new long [ 101 ] ; static long [ ] v = new long [ 101 ] ; static void fi@@ bon@@ ac@@ ci ( ) { fi@@ b [ 1 ] = 1 ; fi@@ b [ 2 ] = 2 ; for ( int i = 3 ; i <= 87 ; i ++ ) { fi@@ b [ i ] = fi@@ b [ i - 1 ] + fi@@ b [ i - 2 ] ; } } static long find ( int num ) { int cnt = 0 ; for ( int i = 87 ; i > 0 ; i -- ) { if ( num >= fi@@ b [ i ] ) { v [ cnt ++ ] = i ; num -= fi@@ b [ i ] ; } } for ( int i = 0 ; i < cnt / 2 ; i ++ ) { long t = v [ i ] ; v [ i ] = v [ cnt - i - 1 ] ; v [ cnt - i - 1 ] = t ; } d@@ p1 [ 0 ] = 1 ; d@@ p2 [ 0 ] = ( v [ 0 ] - 1 ) / 2 ; for ( int i = 1 ; i < cnt ; i ++ ) { d@@ p1 [ i ] = d@@ p1 [ i - 1 ] + d@@ p2 [ i - 1 ] ; d@@ p2 [ i ] = ( ( v [ i ] - v [ i - 1 ] ) / 2 ) * d@@ p2 [ i - 1 ] + ( ( v [ i ] - v [ i - 1 ] - 1 ) / 2 ) * d@@ p1 [ i - 1 ] ; } return ( d@@ p1 [ cnt - 1 ] + d@@ p2 [ cnt - 1 ] ) ; } public static void main ( String [ ] args ) { fi@@ bon@@ ac@@ ci ( ) ; int num = 13 ; System . out . print ( find ( num ) ) ; } }
Count of N 6100 | class GF@@ G { public static void count@@ Num@@ s ( int N ) { int l = ( int ) Math . pow ( 10 , N - 1 ) , r = ( int ) Math . pow ( 10 , N ) - 1 ; int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { int xor = 0 , temp = i ; while ( temp > 0 ) { xor = xor ^ ( temp % 10 ) ; temp /= 10 ; } if ( xor <= 9 ) count ++ ; } System . out . println ( count ) ; } public static void main ( String [ ] args ) { int N = 2 ; count@@ Num@@ s ( N ) ; } }
Count of all sub@@ sequences having adjacent elements with different parity 6130 | import java . util . * ; class GF@@ G { public static long getCount ( int n , int k ) { if ( n == 1 ) return 10 ; long dp [ ] [ ] = new long [ n + 1 ] [ 11 ] ; for ( int i = 1 ; i <= 9 ; i ++ ) dp [ 1 ] [ i ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { int l = Math . max ( 0 , j - k ) ; int r = Math . min ( 9 , j + k ) ; dp [ i ] [ l ] += dp [ i - 1 ] [ j ] ; dp [ i ] [ r + 1 ] -= dp [ i - 1 ] [ j ] ; } for ( int j = 1 ; j <= 9 ; j ++ ) dp [ i ] [ j ] += dp [ i ] [ j - 1 ] ; } long count = 0 ; for ( int i = 0 ; i <= 9 ; i ++ ) count += dp [ n ] [ i ] ; return count ; } public static void main ( String [ ] args ) { int n = 2 , k = 1 ; System . out . println ( getCount ( n , k ) ) ; } }
Find if there is a path between two vertices in a directed graph | Set 2 6131 | import java . util . * ; class GF@@ G { static final int X = 6 ; static final int Z = 2 ; static boolean exist@@ Path ( int V , int edges [ ] [ ] , int u , int v ) { boolean [ ] [ ] mat = new boolean [ V ] [ V ] ; for ( int i = 0 ; i < X ; i ++ ) mat [ edges [ i ] [ 0 ] ] [ edges [ i ] [ 1 ] ] = true ; for ( int k = 0 ; k < V ; k ++ ) { for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { mat [ i ] [ j ] = mat [ i ] [ j ] || mat [ i ] [ k ] && mat [ k ] [ j ] ; } } } if ( u >= V v >= V ) { return false ; } if ( mat [ u ] [ v ] ) return true ; return false ; } public static void main ( String [ ] args ) { int V = 4 ; int edges [ ] [ ] = { { 0 , 2 } , { 0 , 1 } , { 1 , 2 } , { 2 , 3 } , { 2 , 0 } , { 3 , 3 } } ; int u = 1 , v = 3 ; if ( exist@@ Path ( V , edges , u , v ) ) System . out . print ( "@@ Yes@@ NEW_@@ LINE@@ "@@ )@@ ; else System . out . print ( "@@ No@@ NEW_@@ LINE@@ "@@ )@@ ; } }
Maxim@@ ize the numbers of splits in an Array having sum di@@ visible by 3 6132 | import java . util . * ; class GF@@ G { static int calculate_@@ maximum@@ _@@ splits ( int arr [ ] , int N ) { int pre [ ] = { 0 , - 1 , - 1 } ; int [ ] dp = new int [ N ] ; Arrays . fill ( dp , 0 ) ; int C = 0 ; for ( int i = 0 ; i < N ; i ++ ) { C = C + arr [ i ] ; C = C % 3 ; if ( pre [ C ] == - 1 ) { if ( 1 <= i ) dp [ i ] = dp [ i - 1 ] ; } else { dp [ i ] = Math . max ( dp [ i - 1 ] , dp [ pre [ C ] ] + 1 ) ; } pre [ C ] = i ; } return dp [ N - 1 ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 36 , 1 , 9 , 2 , 0 , 1 , 8 , 1 } ; int N = arr . length ; System . out . println ( calculate_@@ maximum@@ _@@ splits ( arr , N ) ) ; } }
S@@ malle@@ st index in given range of indices which is not equal to X 6138 | class GF@@ G { static void pre@@ compute ( int next@@ pos [ ] , int arr [ ] , int N ) { next@@ pos [ N - 1 ] = N ; for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] == arr [ i + 1 ] ) next@@ pos [ i ] = next@@ pos [ i + 1 ] ; else next@@ pos [ i ] = i + 1 ; } } static void find@@ Index ( int query [ ] [ ] , int arr [ ] , int N , int Q ) { int [ ] next@@ pos = new int [ N ] ; pre@@ compute ( next@@ pos , arr , N ) ; for ( int i = 0 ; i < Q ; i ++ ) { int l , r , x ; l = query [ i ] [ 0 ] ; r = query [ i ] [ 1 ] ; x = query [ i ] [ 2 ] ; int ans = - 1 ; if ( arr [ l ] != x ) ans = l ; else { int d = next@@ pos [ l ] ; if ( d <= r ) ans = d ; } System . out . print ( ans + "@@ NEW_@@ LINE@@ "@@ )@@ ; } } public static void main ( String [ ] args ) { int N , Q ; N = 6 ; Q = 3 ; int arr [ ] = { 1 , 2 , 1 , 1 , 3 , 5 } ; int query [ ] [ ] = { { 0 , 3 , 1 } , { 1 , 5 , 2 } , { 2 , 3 , 1 } } ; find@@ Index ( query , arr , N , Q ) ; } }
Check if one string can be converted to other using given operation 6176 | import java . util . * ; class GF@@ G { static void two@@ Strings@@ Equality ( String s , String t ) { int n = s . length ( ) ; int [ ] [ ] dp = new int [ n ] [ n + 1 ] ; if ( s . charAt ( n - 1 ) == t . charAt ( 0 ) ) dp [ n - 1 ] [ 1 ] = 1 ; if ( s . charAt ( n - 1 ) == t . charAt ( n - 1 ) ) dp [ n - 1 ] [ 0 ] = 1 ; for ( int i = n - 1 ; i > 0 ; i -- ) { for ( int j = 0 ; j <= n - i ; j ++ ) { if ( dp [ i ] [ j ] > 0 ) { if ( s . charAt ( i - 1 ) == t . charAt ( j ) ) dp [ i - 1 ] [ j + 1 ] = 1 ; if ( s . charAt ( i - 1 ) == t . charAt ( i + j - 1 ) ) dp [ i - 1 ] [ j ] = 1 ; } } } boolean ans = false ; for ( int i = 0 ; i <= n ; i ++ ) { if ( dp [ 0 ] [ i ] == 1 ) { ans = true ; break ; } } if ( ans == true ) System . out . print ( " Yes " + "@@ NEW_@@ LINE@@ "@@ )@@ ; else System . out . print ( " No " + "@@ NEW_@@ LINE@@ "@@ )@@ ; } public static void main ( String [ ] args ) { String S = " ab@@ ab " ; String T = " b@@ aa@@ b " ; two@@ Strings@@ Equality ( S , T ) ; } }
Check if a matrix contains a square sub@@ matrix with 0 as boundary element 6182 | import java . io . * ; import java . util . * ; class GF@@ G { static int square@@ Of@@ Zero@@ es ( int [ ] [ ] matrix ) { int last@@ Idx = matrix . length - 1 ; Map < String , Boolean > cache = new HashMap < String , Boolean > ( ) ; return ( has@@ Square@@ Of@@ Zero@@ es ( matrix , 0 , 0 , last@@ Idx , last@@ Idx , cache ) ) ? 1 : 0 ; } static boolean has@@ Square@@ Of@@ Zero@@ es ( int [ ] [ ] matrix , int r1 , int c1 , int r2 , int c2 , Map < String , Boolean > cache ) { if ( r1 >= r2 c1 >= c2 ) return false ; String key = r1 + " - " + c1 + " - " + r2 + " - " + c2 ; if ( cache . containsKey ( key ) ) return cache . get ( key ) ; cache . put ( key , is@@ Square@@ Of@@ Zero@@ es ( matrix , r1 , c1 , r2 , c2 ) || has@@ Square@@ Of@@ Zero@@ es ( matrix , r1 + 1 , c1 + 1 , r2 - 1 , c2 - 1 , cache ) || has@@ Square@@ Of@@ Zero@@ es ( matrix , r1 , c1 + 1 , r2 - 1 , c2 , cache ) || has@@ Square@@ Of@@ Zero@@ es ( matrix , r1 + 1 , c1 , r2 , c2 - 1 , cache ) || has@@ Square@@ Of@@ Zero@@ es ( matrix , r1 + 1 , c1 + 1 , r2 , c2 , cache ) || has@@ Square@@ Of@@ Zero@@ es ( matrix , r1 , c1 , r2 - 1 , c2 - 1 , cache ) ) ; return cache . get ( key ) ; } static boolean is@@ Square@@ Of@@ Zero@@ es ( int [ ] [ ] matrix , int r1 , int c1 , int r2 , int c2 ) { for ( int row = r1 ; row < r2 + 1 ; row ++ ) { if ( matrix [ row ] [ c1 ] != 0 matrix [ row ] [ c2 ] != 0 ) return false ; } for ( int col = c1 ; col < c2 + 1 ; col ++ ) { if ( matrix [ r1 ] [ col ] != 0 matrix [ r2 ] [ col ] != 0 ) return false ; } return true ; } public static void main ( String [ ] args ) { int [ ] [ ] matrix = { { 1 , 1 , 1 , 0 , 1 , 0 } , { 0 , 0 , 0 , 0 , 0 , 1 } , { 0 , 1 , 1 , 1 , 0 , 1 } , { 0 , 0 , 0 , 1 , 0 , 1 } , { 0 , 1 , 1 , 1 , 0 , 1 } , { 0 , 0 , 0 , 0 , 0 , 1 } } ; int ans ; ans = square@@ Of@@ Zero@@ es ( matrix ) ; if ( ans == 1 ) { System . out . println ( " True " ) ; } else { System . out . println ( " False " ) ; } } }
Check if a substring can be Pal@@ ind@@ ro@@ mic by replacing K characters for Q queries 6220 | class GF@@ G { static void can@@ Make@@ P@@ ali@@ Queries ( String str , int [ ] [ ] Q ) { int n = str . length ( ) ; int [ ] [ ] dp = new int [ 26 ] [ n ] ; for ( int i = 0 ; i < 26 ; i ++ ) { char current@@ Char = ( char ) ( i + ' a ' ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( j == 0 ) { dp [ i ] [ j ] = ( str . charAt ( j ) == current@@ Char ) ? 1 : 0 ; } else { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + ( ( str . charAt ( j ) == current@@ Char ) ? 1 : 0 ) ; } } } for ( int [ ] query : Q ) { int left = query [ 0 ] ; int right = query [ 1 ] ; int k = query [ 2 ] ; int un@@ Matched@@ Count = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { int occurrence = dp [ i ] [ right ] - dp [ i ] [ left ] + ( str . charAt ( left ) == ( i + ' a ' ) ? 1 : 0 ) ; if ( occurrence % 2 == 1 ) un@@ Matched@@ Count ++ ; } int ans = un@@ Matched@@ Count / 2 ; if ( ans <= k ) { System . out . print ( "@@ Y@@ ES@@ NEW_@@ LINE@@ "@@ )@@ ; } else { System . out . print ( "@@ NO@@ NEW_@@ LINE@@ "@@ )@@ ; } } } public static void main ( String [ ] args ) { String str = " Ge@@ ek@@ s@@ for@@ Ge@@ e@@ ks " ; int [ ] [ ] Q = { { 1 , 5 , 3 } , { 5 , 7 , 0 } , { 8 , 11 , 3 } , { 3 , 10 , 5 } , { 0 , 9 , 5 } } ; can@@ Make@@ P@@ ali@@ Queries ( str , Q ) ; } }
Maximum sum such that exactly half of the elements are selected and no two adjacent 6243 | class GF@@ G { static int Maximum@@ Sum ( int a [ ] , int n ) { int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < n + 1 ; j ++ ) dp [ i ] [ j ] = Integer . MIN_VALUE ; } for ( int i = 0 ; i < n + 1 ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { int val = Integer . MIN_VALUE ; if ( ( i - 2 >= 0 && dp [ i - 2 ] [ j - 1 ] != Integer . MIN_VALUE ) i - 2 < 0 ) { val = a [ i - 1 ] + ( i - 2 >= 0 ? dp [ i - 2 ] [ j - 1 ] : 0 ) ; } if ( i - 1 >= j ) { val = Math . max ( val , dp [ i - 1 ] [ j ] ) ; } dp [ i ] [ j ] = val ; } } return dp [ n ] [ n / 2 ] ; } public static void main ( String [ ] args ) { int A [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int N = A . length ; System . out . print ( Maximum@@ Sum ( A , N ) ) ; } }
Count the number of ways to divide N in k groups increment@@ ally 6279 | import java . util . * ; class GF@@ G { static int [ ] [ ] [ ] dp = new int [ 500 ] [ 500 ] [ 500 ] ; static int calculate ( int pos , int prev , int left , int k ) { if ( pos == k ) { if ( left == 0 ) return 1 ; else return 0 ; } if ( left == 0 ) return 0 ; if ( dp [ pos ] [ prev ] [ left ] != - 1 ) return dp [ pos ] [ prev ] [ left ] ; int answer = 0 ; for ( int i = prev ; i <= left ; i ++ ) { answer += calculate ( pos + 1 , i , left - i , k ) ; } return dp [ pos ] [ prev ] [ left ] = answer ; } static int count@@ Way@@ sto@@ Divide ( int n , int k ) { for ( int i = 0 ; i < 500 ; i ++ ) { for ( int j = 0 ; j < 500 ; j ++ ) { for ( int l = 0 ; l < 500 ; l ++ ) dp [ i ] [ j ] [ l ] = - 1 ; } } return calculate ( 0 , 1 , n , k ) ; } public static void main ( String [ ] args ) { int N = 8 ; int K = 4 ; System . out . print ( count@@ Way@@ sto@@ Divide ( N , K ) ) ; } }
Maximum number of multip@@ les in an array before any element 6301 | import java . util . * ; class GF@@ G { static int MAX = 100000 ; static int [ ] di@@ visors = new int [ MAX ] ; static void generate@@ Di@@ visors ( int n ) { for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { di@@ visors [ i ] ++ ; } else { di@@ visors [ i ] ++ ; di@@ visors [ n / i ] ++ ; } } } } static int find@@ Max@@ Multip@@ les ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans = Math . max ( di@@ visors [ arr [ i ] ] , ans ) ; generate@@ Di@@ visors ( arr [ i ] ) ; } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 8 , 1 , 28 , 4 , 2 , 6 , 7 } ; int n = arr . length ; System . out . print ( find@@ Max@@ Multip@@ les ( arr , n ) ) ; } }
Egg@@ s dro@@ pping pu@@ zzle | Set 2 6305 | class GF@@ G { static int egg@@ Drop ( int n , int k ) { int dp [ ] [ ] = new int [ k + 1 ] [ n + 1 ] ; int x = 0 ; while ( dp [ x ] [ n ] < k ) { x ++ ; for ( int i = 1 ; i <= n ; i ++ ) dp [ x ] [ i ] = dp [ x - 1 ] [ i - 1 ] + dp [ x - 1 ] [ i ] + 1 ; } return x ; } public static void main ( String args [ ] ) { int n = 2 , k = 36 ; System . out . println ( egg@@ Drop ( n , k ) ) ; } }
Number of square matrices with all 1 s 6312 | class GF@@ G { final static int n = 3 ; final static int m = 3 ; static int count@@ Square@@ Matrices ( int a [ ] [ ] , int N , int M ) { int count = 0 ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 1 ; j < M ; j ++ ) { if ( a [ i ] [ j ] == 0 ) continue ; a [ i ] [ j ] = Math . min ( Math . min ( a [ i - 1 ] [ j ] , a [ i ] [ j - 1 ] ) , a [ i - 1 ] [ j - 1 ] ) + 1 ; } } for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) count += a [ i ] [ j ] ; return count ; } public static void main ( String [ ] args ) { int arr [ ] [ ] = { { 1 , 0 , 1 } , { 1 , 1 , 0 } , { 1 , 1 , 0 } } ; System . out . println ( count@@ Square@@ Matrices ( arr , n , m ) ) ; } }
K@@ nap@@ s@@ ack with large Weights 6330 | class GF@@ G { static final int V@@ _S@@ UM_@@ MAX = 1000 ; static final int N_@@ MAX = 100 ; static final int W_@@ MAX = 10000000 ; static int dp [ ] [ ] = new int [ V@@ _S@@ UM_@@ MAX + 1 ] [ N_@@ MAX ] ; static boolean v [ ] [ ] = new boolean [ V@@ _S@@ UM_@@ MAX + 1 ] [ N_@@ MAX ] ; static int solve@@ D@@ p ( int r , int i , int w [ ] , int val [ ] , int n ) { if ( r <= 0 ) return 0 ; if ( i == n ) return W_@@ MAX ; if ( v [ r ] [ i ] ) return dp [ r ] [ i ] ; v [ r ] [ i ] = true ; dp [ r ] [ i ] = Math . min ( solve@@ D@@ p ( r , i + 1 , w , val , n ) , w [ i ] + solve@@ D@@ p ( r - val [ i ] , i + 1 , w , val , n ) ) ; return dp [ r ] [ i ] ; } static int max@@ Weight ( int w [ ] , int val [ ] , int n , int c ) { for ( int i = V@@ _S@@ UM_@@ MAX ; i >= 0 ; i -- ) { if ( solve@@ D@@ p ( i , 0 , w , val , n ) <= c ) { return i ; } } return 0 ; } public static void main ( String [ ] args ) { int w [ ] = { 3 , 4 , 5 } ; int val [ ] = { 30 , 50 , 60 } ; int n = w . length ; int C = 8 ; System . out . println ( max@@ Weight ( w , val , n , C ) ) ; } }
Number of subsets with a given AND value 6362 | class GF@@ G { static int max@@ N = 20 ; static int max@@ M = 64 ; static int [ ] [ ] d@@ p1 = new int [ max@@ N ] [ max@@ M ] ; static boolean [ ] [ ] v1 = new boolean [ max@@ N ] [ max@@ M ] ; static int find@@ Cnt ( int [ ] arr , int i , int curr , int n , int m ) { if ( i == n ) { return ( curr == m ? 1 : 0 ) ; } if ( v1 [ i ] [ curr ] ) return d@@ p1 [ i ] [ curr ] ; v1 [ i ] [ curr ] = true ; d@@ p1 [ i ] [ curr ] = find@@ Cnt ( arr , i + 1 , curr , n , m ) + find@@ Cnt ( arr , i + 1 , ( curr & arr [ i ] ) , n , m ) ; return d@@ p1 [ i ] [ curr ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 0 , 0 , 0 } ; int n = arr . length ; int m = 0 ; System . out . println ( find@@ Cnt ( arr , 0 , ( ( 1 << 6 ) - 1 ) , n , m ) ) ; } }
Number of ways to get a given sum with n number of m 6407 | class GF@@ G { static int mod = 100000000@@ 7 ; static int [ ] [ ] dp = new int [ 55 ] [ 55 ] ; static int N@@ oo@@ f@@ W@@ ays ( int face , int throw@@ s@@ Val , int sum ) { if ( sum == 0 && throw@@ s@@ Val == 0 ) { return 1 ; } if ( sum < 0 throw@@ s@@ Val == 0 ) { return 0 ; } if ( dp [ throw@@ s@@ Val ] [ sum ] != - 1 ) { return dp [ throw@@ s@@ Val ] [ sum ] ; } int ans = 0 ; for ( int i = 1 ; i <= face ; i ++ ) { ans += N@@ oo@@ f@@ W@@ ays ( face , throw@@ s@@ Val - 1 , sum - i ) ; } return dp [ throw@@ s@@ Val ] [ sum ] = ans ; } public static void main ( String [ ] args ) { int faces = 6 , throw@@ s@@ Val = 3 , sum = 12 ; for ( int i = 0 ; i < 55 ; i ++ ) { for ( int j = 0 ; j < 55 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } System . out . println ( N@@ oo@@ f@@ W@@ ays ( faces , throw@@ s@@ Val , sum ) ) ; } }
Queries for bitwise AND in the given matrix 6436 | class GF@@ G { final static int bits@@ count = 32 ; final static int n = 3 ; static int prefix_@@ count [ ] [ ] [ ] = new int [ bits@@ count ] [ n ] [ n ] ; static void find@@ Prefix@@ Count ( int arr [ ] [ ] ) { for ( int i = 0 ; i < bits@@ count ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { prefix_@@ count [ i ] [ j ] [ 0 ] = ( ( arr [ j ] [ 0 ] >> i ) & 1 ) ; for ( int k = 1 ; k < n ; k ++ ) { prefix_@@ count [ i ] [ j ] [ k ] = ( ( arr [ j ] [ k ] >> i ) & 1 ) ; prefix_@@ count [ i ] [ j ] [ k ] += prefix_@@ count [ i ] [ j ] [ k - 1 ] ; } } } for ( int i = 0 ; i < bits@@ count ; i ++ ) for ( int j = 1 ; j < n ; j ++ ) for ( int k = 0 ; k < n ; k ++ ) prefix_@@ count [ i ] [ j ] [ k ] += prefix_@@ count [ i ] [ j - 1 ] [ k ] ; } static int range@@ And ( int x1 , int y1 , int x2 , int y2 ) { int ans = 0 ; for ( int i = 0 ; i < bits@@ count ; i ++ ) { int p ; if ( x1 == 0 && y1 == 0 ) p = prefix_@@ count [ i ] [ x2 ] [ y2 ] ; else if ( x1 == 0 ) p = prefix_@@ count [ i ] [ x2 ] [ y2 ] - prefix_@@ count [ i ] [ x2 ] [ y1 - 1 ] ; else if ( y1 == 0 ) p = prefix_@@ count [ i ] [ x2 ] [ y2 ] - prefix_@@ count [ i ] [ x1 - 1 ] [ y2 ] ; else p = prefix_@@ count [ i ] [ x2 ] [ y2 ] - prefix_@@ count [ i ] [ x1 - 1 ] [ y2 ] - prefix_@@ count [ i ] [ x2 ] [ y1 - 1 ] + prefix_@@ count [ i ] [ x1 - 1 ] [ y1 - 1 ] ; if ( p == ( x2 - x1 + 1 ) * ( y2 - y1 + 1 ) ) ans = ( ans | ( 1 << i ) ) ; } return ans ; } public static void main ( String [ ] args ) { int arr [ ] [ ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; find@@ Prefix@@ Count ( arr ) ; int queries [ ] [ ] = { { 1 , 1 , 1 , 1 } , { 1 , 2 , 2 , 2 } } ; int q = queries . length ; for ( int i = 0 ; i < q ; i ++ ) System . out . println ( range@@ And ( queries [ i ] [ 0 ] , queries [ i ] [ 1 ] , queries [ i ] [ 2 ] , queries [ i ] [ 3 ] ) ) ; } }
Find the number of binary strings of length N with at least 3 consecutive 1 s 6458 | import java . util . * ; class GF@@ G { static int n ; static int solve ( int i , int x , int dp [ ] [ ] ) { if ( i < 0 ) { return x == 3 ? 1 : 0 ; } if ( dp [ i ] [ x ] != - 1 ) { return dp [ i ] [ x ] ; } dp [ i ] [ x ] = solve ( i - 1 , 0 , dp ) ; dp [ i ] [ x ] += solve ( i - 1 , x + 1 , dp ) ; return dp [ i ] [ x ] ; } public static void main ( String [ ] args ) { n = 4 ; int dp [ ] [ ] = new int [ n ] [ 4 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] [ 3 ] = ( 1 << ( i + 1 ) ) ; } System . out . print ( solve ( n - 1 , 0 , dp ) ) ; } }
Lon@@ gest sub@@ array having maximum sum 6571 | import java . util . * ; class GF@@ G { static int max@@ Sub@@ Array@@ Sum ( int arr [ ] , int size ) { int max_@@ so@@ _f@@ ar = arr [ 0 ] ; int curr_@@ max = arr [ 0 ] ; for ( int i = 1 ; i < size ; i ++ ) { curr_@@ max = Math . max ( arr [ i ] , curr_@@ max + arr [ i ] ) ; max_@@ so@@ _f@@ ar = Math . max ( max_@@ so@@ _f@@ ar , curr_@@ max ) ; } return max_@@ so@@ _f@@ ar ; } static int len@@ Of@@ Long@@ Sub@@ arr@@ With@@ Given@@ Sum ( int arr [ ] , int n , int k ) { HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ; int sum = 0 , maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum == k ) maxLen = i + 1 ; if ( um . containsKey ( sum ) ) um . put ( sum , i ) ; if ( um . containsKey ( sum - k ) ) { if ( maxLen < ( i - um . get ( sum - k ) ) ) maxLen = i - um . get ( sum - k ) ; } } return maxLen ; } static int len@@ Long@@ Sub@@ arr@@ With@@ Max@@ Sum ( int arr [ ] , int n ) { int max@@ Sum = max@@ Sub@@ Array@@ Sum ( arr , n ) ; return len@@ Of@@ Long@@ Sub@@ arr@@ With@@ Given@@ Sum ( arr , n , max@@ Sum ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 5 , - 2 , - 1 , 3 , - 4 } ; int n = arr . length ; System . out . println ( " Length ▁ of ▁ longest ▁ sub@@ array ▁ " + " having ▁ maximum ▁ sum ▁ = ▁ " + len@@ Long@@ Sub@@ arr@@ With@@ Max@@ Sum ( arr , n ) ) ; } }
Partition@@ ing into two contiguous element sub@@ arrays with equal sums 6628 | import java . util . * ; class GF@@ G { static class data { int element ; int position ; } ; static data find@@ Min@@ Element ( int arr [ ] , int n ) { data result = new data ( ) ; int [ ] prefix@@ Sum = new int [ n ] ; int [ ] suffix@@ Sum = new int [ n ] ; prefix@@ Sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { prefix@@ Sum [ i ] = prefix@@ Sum [ i - 1 ] + arr [ i ] ; } suffix@@ Sum [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { suffix@@ Sum [ i ] = suffix@@ Sum [ i + 1 ] + arr [ i ] ; } int min = suffix@@ Sum [ 0 ] ; int pos = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( Math . abs ( suffix@@ Sum [ i + 1 ] - prefix@@ Sum [ i ] ) < min ) { min = Math . abs ( suffix@@ Sum [ i + 1 ] - prefix@@ Sum [ i ] ) ; if ( suffix@@ Sum [ i + 1 ] < prefix@@ Sum [ i ] ) pos = i + 1 ; else pos = i ; } } result . element = min ; result . position = pos ; return result ; } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 1 , 2 , 3 , 4 } ; int n = arr . length ; data values ; values = find@@ Min@@ Element ( arr , n ) ; System . out . println ( " Minimum ▁ element ▁ : ▁ " + values . element + " Position : " + values@@ .@@ position@@ )@@ ; } }
Minimum remo@@ vals from array to make max 6662 | import java . util . * ; class GF@@ G { static int find@@ Ind ( int key , int i , int n , int k , int arr [ ] ) { int start , end , mid , ind = - 1 ; start = i + 1 ; end = n - 1 ; while ( start < end ) { mid = start + ( end - start ) / 2 ; if ( arr [ mid ] - key <= k ) { ind = mid ; start = mid + 1 ; } else { end = mid ; } } return ind ; } static int remo@@ vals ( int arr [ ] , int n , int k ) { int i , j , ans = n - 1 ; Arrays . sort ( arr ) ; for ( i = 0 ; i < n ; i ++ ) { j = find@@ Ind ( arr [ i ] , i , n , k , arr ) ; if ( j != - 1 ) { ans = Math . min ( ans , n - ( j - i + 1 ) ) ; } } return ans ; } public static void main ( String args [ ] ) { int a [ ] = { 1 , 3 , 4 , 9 , 10 , 11 , 12 , 17 , 20 } ; int n = a . length ; int k = 4 ; System . out . println ( remo@@ vals ( a , n , k ) ) ; } }
Length of Lon@@ gest Bal@@ anced Sub@@ sequence 6736 | import java . io . * ; class GF@@ G { static int maxLength ( String s , int n ) { int invalid@@ Open@@ Br@@ aces = 0 ; int invalid@@ Close@@ Br@@ aces = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' ( ' ) { invalid@@ Open@@ Br@@ aces ++ ; } else { if ( invalid@@ Open@@ Br@@ aces == 0 ) { invalid@@ Close@@ Br@@ aces ++ ; } else { invalid@@ Open@@ Br@@ aces -- ; } } } return ( n - ( invalid@@ Open@@ Br@@ aces + invalid@@ Close@@ Br@@ aces ) ) ; } public static void main ( String [ ] args ) { String s = " ( ) ( ( ( ( ( ( ) " ; int n = s . length ( ) ; System . out . println ( maxLength ( s , n ) ) ; } }
Lon@@ gest Common Sub@@ sequence with at most k changes allowed 6746 | class GF@@ G { static int MAX = 10 ; static int l@@ cs ( int [ ] [ ] [ ] dp , int [ ] ar@@ r1 , int n , int [ ] ar@@ r2 , int m , int k ) { if ( k < 0 ) return - 10000000 ; if ( n < 0 m < 0 ) return 0 ; int ans = dp [ n ] [ m ] [ k ] ; if ( ans != - 1 ) return ans ; try { ans = Math . max ( l@@ cs ( dp , ar@@ r1 , n - 1 , ar@@ r2 , m , k ) , l@@ cs ( dp , ar@@ r1 , n , ar@@ r2 , m - 1 , k ) ) ; if ( ar@@ r1 [ n - 1 ] == ar@@ r2 [ m - 1 ] ) ans = Math . max ( ans , 1 + l@@ cs ( dp , ar@@ r1 , n - 1 , ar@@ r2 , m - 1 , k ) ) ; ans = Math . max ( ans , 1 + l@@ cs ( dp , ar@@ r1 , n - 1 , ar@@ r2 , m - 1 , k - 1 ) ) ; } catch ( Exception e ) { } return ans ; } public static void main ( String [ ] args ) { int k = 1 ; int [ ] ar@@ r1 = { 1 , 2 , 3 , 4 , 5 } ; int [ ] ar@@ r2 = { 5 , 3 , 1 , 4 , 2 } ; int n = ar@@ r1 . length ; int m = ar@@ r2 . length ; int [ ] [ ] [ ] dp = new int [ MAX ] [ MAX ] [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) for ( int j = 0 ; j < MAX ; j ++ ) for ( int l = 0 ; l < MAX ; l ++ ) dp [ i ] [ j ] [ l ] = - 1 ; System . out . println ( l@@ cs ( dp , ar@@ r1 , n , ar@@ r2 , m , k ) ) ; } }
Maximum length sub@@ sequence with difference between adjacent elements as either 0 or 1 6761 | import java . util . * ; class GF@@ G { public static int max@@ Len@@ Sub ( int arr [ ] , int n ) { int m@@ ls [ ] = new int [ n ] , max = 0 ; for ( int i = 0 ; i < n ; i ++ ) m@@ ls [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( Math . abs ( arr [ i ] - arr [ j ] ) <= 1 && m@@ ls [ i ] < m@@ ls [ j ] + 1 ) m@@ ls [ i ] = m@@ ls [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( max < m@@ ls [ i ] ) max = m@@ ls [ i ] ; return max ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 5 , 6 , 3 , 7 , 6 , 5 , 8 } ; int n = arr . length ; System . out . println ( " Maximum ▁ length ▁ sub@@ sequence ▁ = ▁ " + max@@ Len@@ Sub ( arr , n ) ) ; } }
n 6774 | class GF@@ G { static final int max = 100000 ; static int base@@ conversion ( int arr [ ] , int num , int base ) { int i = 0 , rem , j ; if ( num == 0 ) { return 0 ; } while ( num > 0 ) { rem = num % base ; arr [ i ++ ] = rem ; num /= base ; } return i ; } public static void main ( String [ ] args ) { int arr [ ] = new int [ max ] ; int n = 10 ; int size = base@@ conversion ( arr , n - 1 , 6 ) ; if ( size == 0 ) System . out . print ( size ) ; for ( int i = size - 1 ; i >= 0 ; i -- ) { System . out . print ( arr [ i ] ) ; } } }
Count of arrays in which all adjacent elements are such that one of them divide the another 6826 | import java . util . * ; class GF@@ G { static int MAX = 1000 ; static int nu@@ mo@@ f@@ Array ( int n , int m ) { int [ ] [ ] dp = new int [ MAX ] [ MAX ] ; Vector < Integer > [ ] di = new Vector [ MAX ] ; Vector < Integer > [ ] mu = new Vector [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( int i = 0 ; i < MAX ; i ++ ) { di [ i ] = new Vector < > ( ) ; mu [ i ] = new Vector < > ( ) ; } for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 2 * i ; j <= m ; j += i ) { di [ j ] . add ( i ) ; mu [ i ] . add ( j ) ; } di [ i ] . add ( i ) ; } for ( int i = 1 ; i <= m ; i ++ ) dp [ 1 ] [ i ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { dp [ i ] [ j ] = 0 ; for ( Integer x : di [ j ] ) dp [ i ] [ j ] += dp [ i - 1 ] [ x ] ; for ( Integer x : mu [ j ] ) dp [ i ] [ j ] += dp [ i - 1 ] [ x ] ; } } int ans = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { ans += dp [ n ] [ i ] ; di [ i ] . clear ( ) ; mu [ i ] . clear ( ) ; } return ans ; } public static void main ( String [ ] args ) { int n = 3 , m = 3 ; System . out . println ( nu@@ mo@@ f@@ Array ( n , m ) ) ; } }
Fin@@ ding the maximum square sub 6849 | class GF@@ G { static int Row = 6 , Col = 6 ; static int lar@@ gest@@ K@@ Sub@@ matrix ( int [ ] [ ] a ) { int [ ] [ ] dp = new int [ Row ] [ Col ] ; int result = 0 ; for ( int i = 0 ; i < Row ; i ++ ) { for ( int j = 0 ; j < Col ; j ++ ) { if ( i == 0 j == 0 ) dp [ i ] [ j ] = 1 ; else { if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] && a [ i ] [ j ] == a [ i ] [ j - 1 ] && a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) { dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] > dp [ i ] [ j - 1 ] && dp [ i - 1 ] [ j ] > dp [ i - 1 ] [ j - 1 ] + 1 ) ? dp [ i - 1 ] [ j ] : ( dp [ i ] [ j - 1 ] > dp [ i - 1 ] [ j ] && dp [ i ] [ j - 1 ] > dp [ i - 1 ] [ j - 1 ] + 1 ) ? dp [ i ] [ j - 1 ] : dp [ i - 1 ] [ j - 1 ] + 1 ; } else dp [ i ] [ j ] = 1 ; } result = result > dp [ i ] [ j ] ? result : dp [ i ] [ j ] ; } } return result ; } public static void main ( String [ ] args ) { int [ ] [ ] a = { { 2 , 2 , 3 , 3 , 4 , 4 } , { 5 , 5 , 7 , 7 , 7 , 4 } , { 1 , 2 , 7 , 7 , 7 , 4 } , { 4 , 4 , 7 , 7 , 7 , 4 } , { 5 , 5 , 5 , 1 , 2 , 7 } , { 8 , 7 , 9 , 4 , 4 , 4 } } ; System . out . println ( lar@@ gest@@ K@@ Sub@@ matrix ( a ) ) ; } }
Number of sub@@ sequences in a string di@@ visible by n 6850 | class GF@@ G { static int count@@ Di@@ visible@@ Sub@@ seq ( String str , int n ) { int len = str . length ( ) ; int dp [ ] [ ] = new int [ len ] [ n ] ; dp [ 0 ] [ ( str . charAt ( 0 ) - '0' ) % n ] ++ ; for ( int i = 1 ; i < len ; i ++ ) { dp [ i ] [ ( str . charAt ( i ) - '0' ) % n ] ++ ; for ( int j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ; dp [ i ] [ ( j * 10 + ( str . charAt ( i ) - '0' ) ) % n ] += dp [ i - 1 ] [ j ] ; } } return dp [ len - 1 ] [ 0 ] ; } public static void main ( String [ ] args ) { String str = "12@@ 34" ; int n = 4 ; System . out . print ( count@@ Di@@ visible@@ Sub@@ seq ( str , n ) ) ; } }
Printing Lon@@ gest Common Sub@@ sequence | Set 2 ( Printing All ) 6941 | import java . util . * ; class GF@@ G { static int N = 100 ; static int [ ] [ ] L = new int [ N ] [ N ] ; static Set < String > find@@ L@@ CS ( String X , String Y , int m , int n ) { Set < String > s = new HashSet < > ( ) ; if ( m == 0 n == 0 ) { s . add ( " " ) ; return s ; } if ( X . charAt ( m - 1 ) == Y . charAt ( n - 1 ) ) { Set < String > tmp = find@@ L@@ CS ( X , Y , m - 1 , n - 1 ) ; for ( String str : tmp ) s . add ( str + X . charAt ( m - 1 ) ) ; } else { if ( L [ m - 1 ] [ n ] >= L [ m ] [ n - 1 ] ) s = find@@ L@@ CS ( X , Y , m - 1 , n ) ; if ( L [ m ] [ n - 1 ] >= L [ m - 1 ] [ n ] ) { Set < String > tmp = find@@ L@@ CS ( X , Y , m , n - 1 ) ; s . addAll ( tmp ) ; } } return s ; } static int L@@ CS ( String X , String Y , int m , int n ) { for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = Math . max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } return L [ m ] [ n ] ; } public static void main ( String [ ] args ) { String X = " AG@@ TG@@ AT@@ G " ; String Y = " GT@@ TAG " ; int m = X . length ( ) ; int n = Y . length ( ) ; System . out . println ( " L@@ CS ▁ length ▁ is ▁ " + L@@ CS ( X , Y , m , n ) ) ; Set < String > s = find@@ L@@ CS ( X , Y , m , n ) ; for ( String str : s ) System . out . println ( str ) ; } }
Number of non 6943 | import java . io . * ; class GF@@ G { static int count@@ Integr@@ al@@ Solutions ( int n ) { return ( ( n + 1 ) * ( n + 2 ) ) / 2 ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( count@@ Integr@@ al@@ Solutions ( n ) ) ; } }
Partition problem | DP 7040 | import java . io . * ; class Partition { static boolean isSub@@ set@@ Sum ( int arr [ ] , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 && sum != 0 ) return false ; if ( arr [ n - 1 ] > sum ) return isSub@@ set@@ Sum ( arr , n - 1 , sum ) ; return isSub@@ set@@ Sum ( arr , n - 1 , sum ) || isSub@@ set@@ Sum ( arr , n - 1 , sum - arr [ n - 1 ] ) ; } static boolean find@@ Partition ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; return isSub@@ set@@ Sum ( arr , n , sum / 2 ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 1 , 5 , 9 , 12 } ; int n = arr . length ; if ( find@@ Partition ( arr , n ) == true ) System . out . println ( " Can ▁ be ▁ divided ▁ into ▁ two ▁ " + " subsets ▁ of ▁ equal ▁ sum " ) ; else System . out . println ( " Can ▁ not ▁ be ▁ divided ▁ into ▁ " + " two ▁ subsets ▁ of ▁ equal ▁ sum " ) ; } }
Maximum amount of money that can be collected by a player in a game of coins 7123 | import java . util . * ; class GF@@ G { static void find ( int N , int [ ] [ ] Arr ) { int amount = 0 ; ArrayList < Integer > mid_@@ odd = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { int si@@ z = Arr [ i ] . length ; for ( int j = 0 ; j < si@@ z / 2 ; j ++ ) amount = amount + Arr [ i ] [ j ] ; if ( si@@ z % 2 == 1 ) mid_@@ odd . add ( Arr [ i ] [ si@@ z / 2 ] ) ; } Collections . sort ( mid_@@ odd ) ; for ( int i = 0 ; i < mid_@@ odd . size ( ) ; i ++ ) { if ( i % 2 == 0 ) amount = amount + mid_@@ odd . get ( i ) ; } System . out . println ( amount ) ; } public static void main ( String [ ] args ) { int N = 2 ; int [ ] [ ] Arr = { { 5 , 2 , 3 , 4 } , { 1 , 6 } } ; find ( N , Arr ) ; } }
Print matrix elements from top 7137 | import java . util . * ; class GF@@ G { static void print@@ Diag@@ onal@@ Traversal ( int [ ] [ ] nums ) { int max_size = nums [ 0 ] . length ; ArrayList < ArrayList < Integer > > v = new ArrayList < ArrayList < Integer > > ( ) ; for ( int i = 0 ; i < 2 * max_size - 1 ; i ++ ) { v . add ( new ArrayList < Integer > ( ) ) ; } for ( int i = 0 ; i < nums [ 0 ] . length ; i ++ ) { for ( int j = 0 ; j < nums [ 0 ] . length ; j ++ ) { v . get ( i + j ) . add ( nums [ i ] [ j ] ) ; } } for ( int i = 0 ; i < v . size ( ) ; i ++ ) { for ( int j = v . get ( i ) . size ( ) - 1 ; j >= 0 ; j -- ) { System . out . print ( v . get ( i ) . get ( j ) + " ▁ " ) ; } } } public static void main ( String [ ] args ) { int [ ] [ ] arr = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; print@@ Diag@@ onal@@ Traversal ( arr ) ; } }
Sum of all odd length sub@@ arrays 7148 | import java . io . * ; import java . util . Arrays ; class GF@@ G { static int O@@ dd@@ Length@@ Sum ( int [ ] arr ) { int sum = 0 ; int l = arr . length ; for ( int i = 0 ; i < l ; i ++ ) { for ( int j = i ; j < l ; j += 2 ) { for ( int k = i ; k <= j ; k ++ ) { sum += arr [ k ] ; } } } return sum ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 5 , 3 , 1 , 2 } ; System . out . print ( O@@ dd@@ Length@@ Sum ( arr ) ) ; } }
Re@@ present K as sum of N 7177 | import java . util . * ; class GF@@ G { public static long [ ] N_@@ bon@@ ac@@ ci = new long [ 100 ] ; @ SuppressWarnings ( " unchecked " ) public static void N_@@ bon@@ ac@@ ci_@@ nums ( int n , int k ) { N_@@ bon@@ ac@@ ci [ 0 ] = 1 ; for ( int i = 1 ; i <= 50 ; ++ i ) { for ( int j = i - 1 ; j >= i - k && j >= 0 ; -- j ) N_@@ bon@@ ac@@ ci [ i ] += N_@@ bon@@ ac@@ ci [ j ] ; } Vector ans = new Vector ( ) ; for ( int i = 50 ; i >= 0 ; -- i ) if ( n - N_@@ bon@@ ac@@ ci [ i ] >= 0 ) { ans . add ( N_@@ bon@@ ac@@ ci [ i ] ) ; n -= N_@@ bon@@ ac@@ ci [ i ] ; } if ( ans . size ( ) == 1 ) ans . add ( 0 ) ; System . out . println ( ans . size ( ) ) ; for ( int i = 0 ; i < ans . size ( ) ; ++ i ) System . out . print ( ans . get ( i ) + " , ▁ " ) ; } public static void main ( String args [ ] ) { int n = 21 , k = 5 ; N_@@ bon@@ ac@@ ci_@@ nums ( n , k ) ; } }
Bit@@ on@@ ic string 7181 | import java . util . * ; class GF@@ G { static int check@@ Bit@@ on@@ ic ( char [ ] s ) { int i , j ; for ( i = 1 ; i < s . length ; i ++ ) { if ( s [ i ] > s [ i - 1 ] ) continue ; if ( s [ i ] <= s [ i - 1 ] ) break ; } if ( i == s . length - 1 ) return 1 ; for ( j = i + 1 ; j < s . length ; j ++ ) { if ( s [ j ] < s [ j - 1 ] ) continue ; if ( s [ j ] >= s [ j - 1 ] ) break ; } i = j ; if ( i != s . length ) return 0 ; return 1 ; } public static void main ( String [ ] args ) { String s = " abc@@ df@@ g@@ cb@@ a " ; System . out . print ( ( check@@ Bit@@ on@@ ic ( s . toCharArray ( ) ) == 1 ) ? " YES " : " NO " ) ; } }
Generate a unique Array of length N with sum of all sub@@ arrays di@@ visible by N 7184 | class GF@@ G { static void make@@ Array ( int a [ ] , int n ) { for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( i * n + " ▁ " ) ; } public static void main ( String [ ] args ) { int N = 6 ; int arr [ ] = new int [ N ] ; make@@ Array ( arr , N ) ; } }
Check whether the string can be printed using same row of q@@ wer@@ ty keyp@@ ad 7214 | import java . util . * ; class GF@@ G { static int check@@ Q@@ wer@@ ty@@ Row ( char x ) { Character [ ] first_@@ row1 = { '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '0' , ' - ' , ' = ' } ; Set < Character > first_@@ row = new HashSet < > ( Arrays . asList ( first_@@ row1 ) ) ; Character [ ] second_@@ row1 = { ' Q ' , ' W ' , ' E ' , ' R ' , ' T ' , ' Y ' , ' U ' , ' I ' , ' O ' , ' P ' , ' [ ' , ' ] ' , ' q ' , ' w ' , ' e ' , ' r ' , ' t ' , ' y ' , ' u ' , ' i ' , ' o ' , ' p ' } ; Set < Character > second_@@ row = new HashSet < > ( Arrays . asList ( second_@@ row1 ) ) ; Character [ ] third_@@ row1 = { ' A ' , ' S ' , ' D ' , ' F ' , ' G ' , ' H ' , ' J ' , ' K ' , ' L ' , ' ; ' , ' : ' , ' a ' , ' s ' , ' d ' , ' f ' , ' g ' , ' h ' , ' j ' , ' k ' , ' l ' } ; Set < Character > third_@@ row = new HashSet < > ( Arrays . asList ( third_@@ row1 ) ) ; Character [ ] four@@ th_@@ row1 = { ' Z ' , ' X ' , ' C ' , ' V ' , ' B ' , ' N ' , ' M ' , ' , ' , ' . ' , ' / ' , ' z ' , ' x ' , ' c ' , ' v ' , ' b ' , ' n ' , ' m ' } ; Set < Character > four@@ th_@@ row = new HashSet < > ( Arrays . asList ( four@@ th_@@ row1 ) ) ; if ( first_@@ row . contains ( x ) ) { return 1 ; } else if ( second_@@ row . contains ( x ) ) { return 2 ; } else if ( third_@@ row . contains ( x ) ) { return 3 ; } else if ( four@@ th_@@ row . contains ( x ) ) { return 4 ; } return 0 ; } static boolean check@@ Validity ( String str ) { char x = str . charAt ( 0 ) ; int row = check@@ Q@@ wer@@ ty@@ Row ( x ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { x = str . charAt ( i ) ; if ( row != check@@ Q@@ wer@@ ty@@ Row ( x ) ) { return false ; } } return true ; } public static void main ( String [ ] args ) { String str = " Ge@@ ek@@ s@@ for@@ Ge@@ e@@ ks " ; if ( check@@ Validity ( str ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
Last digit of sum of numbers in the given range in the Fi@@ bon@@ ac@@ ci series 7217 | import java . util . * ; class GF@@ G { static int fi@@ b ( long n ) { int f0 = 0 ; int f1 = 1 ; if ( n == 0 ) return 0 ; if ( n == 1 ) return 1 ; else { int rem = ( int ) ( n % 60 ) ; if ( rem == 0 ) return 0 ; for ( int i = 2 ; i < rem + 3 ; i ++ ) { int f = ( f0 + f1 ) % 60 ; f0 = f1 ; f1 = f ; } int s = f1 - 1 ; return s ; } } public static void main ( String args [ ] ) { int m = 100@@ 87@@ 88@@ 7 ; long n = 29@@ 83@@ 09@@ 78@@ 99@@ L ; int Final = ( int ) Math . abs ( fi@@ b ( n ) - fi@@ b ( m - 1 ) ) ; System . out . println ( Final % 10 ) ; } }
Print Triangle separated pattern 7234 | class GF@@ G { static int print@@ Pattern ( int i , int j , int n ) { if ( j >= n ) { return 0 ; } if ( i >= n ) { return 1 ; } if ( j == i j == n - 1 - i ) { if ( i == n - 1 - j ) { System . out . print ( " / " ) ; } else { System . out . print ( " \ \@@ " ) ; } } else { System . out . print ( " * " ) ; } if ( print@@ Pattern ( i , j + 1 , n ) == 1 ) { return 1 ; } System . out . println ( ) ; return print@@ Pattern ( i + 1 , 0 , n ) ; } public static void main ( String [ ] args ) { int N = 9 ; print@@ Pattern ( 0 , 0 , N ) ; } }
Reverse the sub@@ strings of the given String according to the given Array of indices 7249 | class GF@@ G { static String s ; static void reverse@@ Str ( int l , int h ) { int n = h - l ; for ( int i = 0 ; i < n / 2 ; i ++ ) { s = swap ( i + l , n - i - 1 + l ) ; } } static void reverse@@ String ( int A [ ] , int n ) { reverse@@ Str ( 0 , A [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) reverse@@ Str ( A [ i - 1 ] , A [ i ] ) ; reverse@@ Str ( A [ n - 1 ] , s . length ( ) ) ; } static String swap ( int i , int j ) { char ch [ ] = s . toCharArray ( ) ; char temp = ch [ i ] ; ch [ i ] = ch [ j ] ; ch [ j ] = temp ; return String . valueOf ( ch ) ; } public static void main ( String [ ] args ) { s = " abcdef@@ gh " ; int A [ ] = { 2 , 4 , 6 } ; int n = A . length ; reverse@@ String ( A , n ) ; System . out . print ( s ) ; } }
Find the element in the matrix generated by given rules 7263 | import java . io . * ; import java . util . * ; class GF@@ G { static int getElement ( int N , int r , int c ) { if ( r > c ) return 0 ; if ( r == 1 ) { return c ; } int a = ( r + 1 ) * ( int ) ( Math . pow ( 2 , ( r - 2 ) ) ) ; int d = ( int ) ( Math . pow ( 2 , ( r - 1 ) ) ) ; c = c - r ; int element = a + d * c ; return element ; } public static void main ( String [ ] args ) { int N = 4 , R = 3 , C = 4 ; System . out . println ( getElement ( N , R , C ) ) ; } }
Check if a string can be formed from another string using given constraints 7298 | import java . util . * ; class GF@@ G { static boolean check ( String S1 , String S2 ) { int n1 = S1 . length ( ) ; int n2 = S2 . length ( ) ; HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( mp . containsKey ( ( int ) S1 . charAt ( i ) ) ) { mp . put ( ( int ) S1 . charAt ( i ) , mp . get ( ( int ) S1 . charAt ( i ) ) + 1 ) ; } else { mp . put ( ( int ) S1 . charAt ( i ) , 1 ) ; } } for ( int i = 0 ; i < n2 ; i ++ ) { if ( mp . containsKey ( ( int ) S2 . charAt ( i ) ) ) { mp . put ( ( int ) S2 . charAt ( i ) , mp . get ( ( int ) S2 . charAt ( i ) ) - 1 ) ; } else if ( mp . containsKey ( S2 . charAt ( i ) - 1 ) && mp . containsKey ( S2 . charAt ( i ) - 2 ) ) { mp . put ( ( S2 . charAt ( i ) - 1 ) , mp . get ( S2 . charAt ( i ) - 1 ) - 1 ) ; mp . put ( ( S2 . charAt ( i ) - 2 ) , mp . get ( S2 . charAt ( i ) - 2 ) - 1 ) ; } else { return false ; } } return true ; } public static void main ( String [ ] args ) { String S1 = " abb@@ at " ; String S2 = " cat " ; if ( check ( S1 , S2 ) ) System . out . print ( " YES " ) ; else System . out . print ( " NO " ) ; } }
Count of pal@@ ind@@ ro@@ mic strings of size upto N consisting of first K alphab@@ ets occur@@ ring at most twice 7354 | import java . io . * ; class GF@@ G { static int length@@ NP@@ al@@ ind@@ ro@@ me ( int N , int K ) { int half = N / 2 ; if ( N % 2 == 1 ) { half += 1 ; } int ans = 1 ; for ( int i = 1 ; i <= half ; i ++ ) { ans *= K ; K -- ; } return ans ; } static int pal@@ ind@@ ro@@ mic@@ Strings ( int N , int K ) { if ( N == 1 ) { return K ; } if ( N == 2 ) { return 2 * K ; } int ans = 0 ; ans += ( 2 * K ) ; for ( int i = 3 ; i <= N ; i ++ ) { ans += length@@ NP@@ al@@ ind@@ ro@@ me ( i , K ) ; } return ans ; } public static void main ( String [ ] args ) { int N = 4 , K = 3 ; System . out . println ( pal@@ ind@@ ro@@ mic@@ Strings ( N , K ) ) ; } }
Minimum number of characters required to be added to a String such that all lowercase alphab@@ ets occurs as a sub@@ sequence in increasing order 7356 | import java . io . * ; class GF@@ G { static int L@@ CS ( String S , int N , String T , int M , int dp [ ] [ ] ) { if ( N == 0 M == 0 ) return 0 ; if ( dp [ N ] [ M ] != 0 ) return dp [ N ] [ M ] ; if ( S . charAt ( N - 1 ) == T . charAt ( M - 1 ) ) { return dp [ N ] [ M ] = 1 + L@@ CS ( S , N - 1 , T , M - 1 , dp ) ; } return dp [ N ] [ M ] = Math . max ( L@@ CS ( S , N - 1 , T , M , dp ) , L@@ CS ( S , N , T , M - 1 , dp ) ) ; } static int minimum@@ Character ( String S ) { String T = " abcdefghijklmnopqrstuvwx@@ yz " ; int N = S . length ( ) , M = T . length ( ) ; int dp [ ] [ ] = new int [ N + 1 ] [ M + 1 ] ; return ( 26 - L@@ CS ( S , N , T , M , dp ) ) ; } public static void main ( String [ ] args ) { String S = " abc@@ d@@ adc " ; System . out . println ( minimum@@ Character ( S ) ) ; } }
Find smallest number formed by inserting given digit 7378 | import java . io . * ; import java . lang . * ; import java . util . * ; public class GF@@ G { static String Min@@ Value ( String number , int x ) { int length = number . length ( ) ; int position = length + 1 ; if ( number . charAt ( 0 ) == ' - ' ) { for ( int i = number . length ( ) - 1 ; i >= 1 ; -- i ) { if ( ( number . charAt ( i ) - 48 ) < x ) { position = i ; } } } else { for ( int i = number . length ( ) - 1 ; i >= 0 ; -- i ) { if ( ( number . charAt ( i ) - 48 ) > x ) { position = i ; } } } number = number . substring ( 0 , position ) + x + number . substring ( position , number . length ( ) ) ; return number . toString ( ) ; } public static void main ( String [ ] args ) { String number = "@@ 89@@ " ; int x = 1 ; System . out . print ( Min@@ Value ( number , x ) ) ; } }
Maximum count of “ 01@@ 0. . ” sub@@ sequences that can be removed from given Binary String 7385 | import java . io . * ; class GF@@ G { public static void count@@ Operations ( String S ) { int n = S . length ( ) ; int ans = 0 ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( S . charAt ( i ) == '0' ) { cnt ++ ; } else { if ( cnt > 0 ) { cnt -- ; ans ++ ; } } } System . out . println ( ans ) ; } public static void main ( String [ ] args ) { String S = "11@@ 00@@ 1101@@ 0" ; count@@ Operations ( S ) ; } }
Check if a permutation of S2 can be obtained by adding or removing characters from S1 7393 | public class GF@@ G { private static boolean is@@ Prime ( int n ) { if ( n <= 1 ) return false ; else if ( n == 2 ) return true ; else if ( n % 2 == 0 ) return false ; for ( int i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { if ( n % i == 0 ) return false ; } return true ; } private static void check@@ Permutation ( String s1 , String s2 ) { int freq [ ] = new int [ 26 ] ; for ( char ch : s1 . toCharArray ( ) ) { freq [ ch - ' a ' ] -- ; } for ( char ch : s2 . toCharArray ( ) ) { freq [ ch - ' a ' ] ++ ; } boolean is@@ All@@ Changes@@ Prime = true ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] == 0 ) { continue ; } else if ( ! is@@ Prime ( Math . abs ( freq [ i ] ) ) ) { is@@ All@@ Changes@@ Prime = false ; break ; } } if ( is@@ All@@ Changes@@ Prime ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } public static void main ( String [ ] args ) { String S1 = " ge@@ k@@ for@@ g@@ k " ; String S2 = " ge@@ ek@@ s@@ forge@@ e@@ ks " ; check@@ Permutation ( S1 , S2 ) ; } }
Minimum number of replacement done of substring "@@ 01" with "11@@ 0" to remove it completely 7397 | import java . io . * ; class GF@@ G { public static void minimum@@ Operations ( String S , int N ) { int ans = 0 ; int cnt@@ One = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( S . charAt ( i ) == '0' ) { ans += cnt@@ One ; cnt@@ One *= 2 ; } else cnt@@ One ++ ; } System . out . println ( ans ) ; } public static void main ( String [ ] args ) { String S = "00@@ 1" ; int N = S . length ( ) ; minimum@@ Operations ( S , N ) ; } }
Count strings having sum of ASCII values of characters equal to a Prime or Arm@@ strong Number 7420 | import java . io . * ; class GF@@ G { static boolean is@@ Prime ( int num ) { boolean flag = false ; if ( num > 1 ) { for ( int i = 2 ; i < num ; i ++ ) { if ( ( num % i ) == 0 ) { flag = true ; break ; } } } if ( flag ) return false ; else return true ; } static int order ( int x ) { int n = 0 ; while ( x != 0 ) { n = n + 1 ; x = x / 10 ; } return n ; } static boolean is@@ Arm@@ strong ( int x ) { int n = order ( x ) ; int temp = x ; int sum@@ 1 = 0 ; while ( temp != 0 ) { int r = temp % 10 ; sum@@ 1 = sum@@ 1 + ( int ) ( Math . pow ( r , n ) ) ; temp = temp / 10 ; } return ( sum@@ 1 == x ) ; } static int count_@@ arm@@ strong ( String [ ] li ) { int c = 0 ; for ( String ele : li ) { int val = 0 ; for ( char che : ele . toCharArray ( ) ) val += che ; if ( is@@ Arm@@ strong ( val ) ) c += 1 ; } return c ; } static int count_@@ prime ( String [ ] li ) { int c = 0 ; for ( String ele : li ) { int val = 0 ; for ( char che : ele . toCharArray ( ) ) val += che ; if ( is@@ Prime ( val ) ) c += 1 ; } return c ; } public static void main ( String [ ] args ) { String [ ] arr = { " ge@@ ek@@ s@@ forge@@ e@@ ks " , " a " , " computer " , " sci@@ ence " , " portal " , " for " , " ge@@ e@@ ks " } ; System . out . println ( " Number ▁ of ▁ Arm@@ strong ▁ Strings ▁ are : ▁ " + count_@@ arm@@ strong ( arr ) ) ; System . out . println ( " Number ▁ of ▁ Prime ▁ Strings ▁ are : ▁ " + count_@@ prime ( arr ) ) ; } }
Count points which are re@@ visited while following the path specified by a given string 7471 | import java . io . * ; import java . lang . * ; import java . util . * ; class GF@@ G { static int count ( String S , int X , int Y ) { int N = S . length ( ) ; int temp_@@ x = 0 , temp_@@ y = 0 ; int count = 0 ; HashSet < String > s = new HashSet < > ( ) ; s . add ( ( X + " # " + Y ) ) ; for ( int i = 0 ; i < N ; i ++ ) { temp_@@ x = X ; temp_@@ y = Y ; if ( S . charAt ( i ) == ' U ' ) { X ++ ; } else if ( S . charAt ( i ) == ' D ' ) { X -- ; } else if ( S . charAt ( i ) == ' R ' ) { Y ++ ; } else { Y -- ; } if ( s . contains ( ( temp_@@ x + X ) + " # " + ( temp_@@ y + Y ) ) ) { count ++ ; } else { s . add ( ( temp_@@ x + X ) + " # " + ( temp_@@ y + Y ) ) ; } } return count ; } public static void main ( String [ ] args ) { String S = " R@@ DD@@ UD@@ L " ; int X = 0 , Y = 0 ; System . out . print ( count ( S , X , Y ) ) ; } }
Minim@@ ize cost to re@@ arrange sub@@ strings to convert a string to a Bal@@ anced Bracket Sequence 7514 | class GF@@ G { static void count@@ Min@@ Moves ( String str ) { int n = str . length ( ) ; int a [ ] = new int [ n ] ; int j , ans = 0 , i , sum = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == ' ) ' ) { a [ i ] += sum - 1 ; } else { a [ i ] += sum + 1 ; } sum = a [ i ] ; } if ( sum == 0 ) { i = 1 ; while ( i < n ) { j = i - 1 ; while ( i < n && a [ i ] != 0 ) i ++ ; if ( i < n && a [ i - 1 ] < 0 ) { ans += i - j ; if ( j == 0 ) ans ++ ; } i ++ ; } System . out . println ( ans ) ; } else System . out . println ( " - 1" ) ; } public static void main ( String [ ] args ) { String str = " ) ( ( ) " ; count@@ Min@@ Moves ( str ) ; } }
Minim@@ ize a binary string by repeatedly removing even length sub@@ strings of same characters 7540 | import java . util . * ; class GF@@ G { static void Print@@ Stack ( Stack < Character > s ) { if ( s . isEmpty ( ) ) return ; char x = s . peek ( ) ; s . pop ( ) ; Print@@ Stack ( s ) ; System . out . print ( x ) ; s . add ( x ) ; } static void min@@ String ( String s ) { Stack < Character > Stack = new Stack < Character > ( ) ; Stack . add ( s . charAt ( 0 ) ) ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( Stack . isEmpty ( ) ) { Stack . add ( s . charAt ( i ) ) ; } else { if ( Stack . peek ( ) == s . charAt ( i ) ) { Stack . pop ( ) ; } else { Stack . push ( s . charAt ( i ) ) ; } } } Print@@ Stack ( Stack ) ; } public static void main ( String [ ] args ) { String str = "@@ 101@@ 00@@ 1" ; min@@ String ( str ) ; } }
Remove all duplicate adjacent characters from a string using Stack 7572 | import java . util . * ; class GF@@ G { static String Short@@ en@@ String ( String str1 ) { Stack < Character > st = new Stack < Character > ( ) ; int i = 0 ; while ( i < str1 . length ( ) ) { if ( st . isEmpty ( ) || str1 . charAt ( i ) != st . peek ( ) ) { st . add ( str1 . charAt ( i ) ) ; i ++ ; } else { st . pop ( ) ; i ++ ; } } if ( st . isEmpty ( ) ) { return ( " Empty ▁ String " ) ; } else { String short_@@ String = " " ; while ( ! st . isEmpty ( ) ) { short_@@ String = st . peek ( ) + short_@@ String ; st . pop ( ) ; } return ( short_@@ String ) ; } } public static void main ( String [ ] args ) { String str1 = " az@@ zx@@ zy " ; System . out . print ( Short@@ en@@ String ( str1 ) ) ; } }
Reverse words in a given string | Set 2 7579 | import java . util . * ; class GF@@ G { static void print@@ Rev ( String str ) { Stack < String > st = new Stack < String > ( ) ; String [ ] ss = str . split ( " ▁ " ) ; for ( String temp : ss ) { st . add ( temp ) ; } while ( ! st . isEmpty ( ) ) { System . out . print ( st . peek ( ) + " ▁ " ) ; st . pop ( ) ; } } public static void main ( String [ ] args ) { String str ; str = " ge@@ e@@ ks ▁ qui@@ z ▁ practice ▁ code " ; print@@ Rev ( str ) ; } }
Maximum number of set bits count in a K 7641 | import java . util . * ; class GF@@ G { static int max@@ Set@@ BitCount ( String s , int k ) { int maxCount = 0 , n = s . length ( ) ; int count = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( s . charAt ( i ) == '1' ) count ++ ; } maxCount = count ; for ( int i = k ; i < n ; i ++ ) { if ( s . charAt ( i - k ) == '1' ) count -- ; if ( s . charAt ( i ) == '1' ) count ++ ; maxCount = Math . max ( maxCount , count ) ; } return maxCount ; } public static void main ( String [ ] args ) { String s = "100@@ 11@@ 101@@ 0" ; int k = 3 ; System . out . println ( max@@ Set@@ BitCount ( s , k ) ) ; } }
Check if there exists a permutation of given string which doesn '@@ t contain any monoton@@ ous substring 7665 | import java . io . * ; import java . util . * ; class GF@@ G { static boolean check ( String s ) { boolean ok = true ; for ( int i = 0 ; i + 1 < s . length ( ) ; ++ i ) ok &= ( Math . abs ( s . charAt ( i ) - s . charAt ( i + 1 ) ) != 1 ) ; return ok ; } static String monoton@@ ous@@ String ( String s ) { String odd = " " , even = " " ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { if ( s . charAt ( i ) % 2 == 0 ) odd += s . charAt ( i ) ; else even += s . charAt ( i ) ; } char odd@@ Array [ ] = odd . toCharArray ( ) ; Arrays . sort ( odd@@ Array ) ; odd = new String ( odd@@ Array ) ; char even@@ Array [ ] = even . toCharArray ( ) ; Arrays . sort ( even@@ Array ) ; even = new String ( even@@ Array ) ; if ( check ( odd + even ) ) return " Yes " ; else if ( check ( even + odd ) ) return " Yes " ; return " No " ; } public static void main ( String [ ] args ) { String str = " abcd " ; String ans ; ans = monoton@@ ous@@ String ( str ) ; System . out . println ( ans ) ; } }
Make the string lex@@ ico@@ graphic@@ ally smallest and non pal@@ ind@@ ro@@ mic by replacing exactly one character 7678 | import java . util . * ; class GF@@ G { static String find@@ Str ( String S ) { StringBuilder sb = new StringBuilder ( S ) ; int n = sb . length ( ) ; for ( int i = 0 ; i < n / 2 ; ++ i ) { if ( sb . charAt ( i ) != ' a ' ) { sb . set@@ Char@@ At ( i , ' a ' ) ; return sb . toString ( ) ; } } sb . set@@ Char@@ At ( n - 1 , ' b ' ) ; return n < 2 ? " ▁ - 1 ▁ " : sb . toString ( ) ; } public static void main ( String [ ] args ) { String str = " a " ; System . out . println ( find@@ Str ( str ) ) ; String str1 = " ab@@ cc@@ ba " ; System . out . println ( find@@ Str ( str1 ) ) ; } }
Transform string str1 into str2 by taking characters from string str@@ 3 7680 | import java . util . * ; class GF@@ G { static void convert@@ String ( String str1 , String str2 , String str@@ 3 ) { HashMap < Character , Integer > freq = new HashMap < > ( ) ; for ( int i = 0 ; i < str@@ 3 . length ( ) ; i ++ ) { if ( freq . containsKey ( str@@ 3 . charAt ( i ) ) ) freq . put ( str@@ 3 . charAt ( i ) , freq . get ( str@@ 3 . charAt ( i ) ) + 1 ) ; else freq . put ( str@@ 3 . charAt ( i ) , 1 ) ; } int ptr@@ 1 = 0 ; int ptr2 = 0 ; boolean flag = true ; while ( ptr@@ 1 < str1 . length ( ) && ptr2 < str2 . length ( ) ) { if ( str1 . charAt ( ptr@@ 1 ) == str2 . charAt ( ptr2 ) ) { ptr@@ 1 ++ ; ptr2 ++ ; } else { if ( freq . containsKey ( str@@ 3 . charAt ( ptr2 ) ) ) if ( freq . get ( str@@ 3 . charAt ( ptr2 ) ) > 0 ) { freq . put ( str@@ 3 . charAt ( ptr2 ) , freq . get ( str@@ 3 . charAt ( ptr2 ) ) - 1 ) ; ptr2 ++ ; } else { flag = false ; break ; } } } if ( flag && ptr@@ 1 == str1 . length ( ) && ptr2 == str2 . length ( ) ) { System . out . print ( " YES " + "@@ NEW_@@ LINE@@ "@@ )@@ ; } else { System . out . print ( " NO " + "@@ NEW_@@ LINE@@ "@@ )@@ ; } } public static void main ( String [ ] args ) { String str1 = " ab@@ yz@@ fe " ; String str2 = " abcde@@ yz@@ f " ; String str@@ 3 = " pop@@ ode " ; convert@@ String ( str1 , str2 , str@@ 3 ) ; } }
Count the number of strings in an array whose distinct characters are less than equal to M 7694 | import java . util . * ; class GF@@ G { public static void distinct ( String [ ] S , int M ) { int count = 0 ; for ( int i = 0 ; i < S . length ; i ++ ) { Set < Character > set = new HashSet < > ( ) ; for ( int j = 0 ; j < S [ i ] . length ( ) ; j ++ ) { if ( ! set . contains ( S [ i ] . charAt ( j ) ) ) set . add ( S [ i ] . charAt ( j ) ) ; } int c = set . size ( ) ; if ( c <= M ) count += 1 ; } System . out . println ( count ) ; } public static void main ( String [ ] args ) { String S [ ] = { " HER@@ BI@@ VO@@ RES " , " A@@ ER@@ OP@@ LAN@@ E " , " GE@@ EK@@ S@@ FOR@@ GE@@ E@@ KS " } ; int M = 7 ; distinct ( S , M ) ; } }
Construct a string of length L such that each substring of length X has exactly Y distinct letters 7699 | public class GF@@ G { static void string ( int l , int x , int y ) { int p = 97 ; for ( int j = 0 ; j < l ; j ++ ) { char ans = ( char ) ( p + ( j % y ) ) ; System . out . print ( ans ) ; } } public static void main ( String [ ] args ) { int l = 6 ; int x = 5 ; int y = 3 ; string ( l , x , y ) ; } }
Periodic Binary String With Minimum Period and a Given Binary String as Sub@@ sequence . 7712 | class GF@@ G { static void find@@ Periodic@@ String ( String S ) { int l = 2 * S . length ( ) ; int count = 0 ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) { if ( S . charAt ( i ) == '1' ) count ++ ; } if ( count == S . length ( ) count == 0 ) System . out . println ( S ) ; else { char arr [ ] = new char [ l ] ; for ( int i = 0 ; i < l ; i += 2 ) { arr [ i ] = '1' ; arr [ i + 1 ] = '0' ; } for ( int i = 0 ; i < l ; i ++ ) System . out . print ( arr [ i ] ) ; System . out . println ( ) ; } } public static void main ( String [ ] args ) { String S = "@@ 1111@@ 00@@ 1" ; find@@ Periodic@@ String ( S ) ; } }
Count the minimum number of groups formed in a string 7718 | class GF@@ G { static void group_@@ formed ( String S ) { int count = 1 ; for ( int i = 0 ; i < S . length ( ) - 1 ; i ++ ) { if ( S . charAt ( i ) != S . charAt ( i + 1 ) ) count += 1 ; } System . out . println ( count ) ; } public static void main ( String [ ] args ) { String S = " TT@@ WWW " ; group_@@ formed ( S ) ; } }
String obtained by rever@@ sing and comp@@ lement@@ ing a Binary string K times 7728 | class GF@@ G { static String Reverse@@ Comp@@ lement ( char [ ] s , int n , int k ) { int rev = ( k + 1 ) / 2 ; int complement = k - rev ; if ( rev % 2 == 1 ) s = reverse ( s ) ; if ( complement % 2 == 1 ) { for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '0' ) s [ i ] = '1' ; else s [ i ] = '0' ; } } return String . valueOf ( s ) ; } static char [ ] reverse ( char a [ ] ) { int i , n = a . length ; char t ; for ( i = 0 ; i < n / 2 ; i ++ ) { t = a [ i ] ; a [ i ] = a [ n - i - 1 ] ; a [ n - i - 1 ] = t ; } return a ; } public static void main ( String [ ] args ) { String str = "100@@ 11" ; int k = 5 ; int n = str . length ( ) ; System . out . print ( Reverse@@ Comp@@ lement ( str . toCharArray ( ) , n , k ) ) ; } }
Check if any permutation of string is a K times repeated string 7731 | class GF@@ G { static boolean repe@@ ating@@ String ( String s , int n , int k ) { if ( n % k != 0 ) { return false ; } int [ ] frequency = new int [ 123 ] ; for ( int i = 0 ; i < 123 ; i ++ ) { frequency [ i ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { frequency [ s . charAt ( i ) ] ++ ; } int repeat = n / k ; for ( int i = 0 ; i < 123 ; i ++ ) { if ( frequency [ i ] % repeat != 0 ) { return false ; } } return true ; } public static void main ( String [ ] args ) { String s = " abc@@ d@@ cb@@ a " ; int n = s . length ( ) ; int k = 3 ; if ( repe@@ ating@@ String ( s , n , k ) ) { System . out . print ( " Yes " + "@@ NEW_@@ LINE@@ "@@ )@@ ; } else { System . out . print ( " No " + "@@ NEW_@@ LINE@@ "@@ )@@ ; } } }
Program to print the given digit in words 7768 | class GF@@ G { static void print@@ Value ( char digit ) { switch ( digit ) { case '0' : System . out . print ( " Zero ▁ " ) ; break ; case '1' : System . out . print ( " One ▁ " ) ; break ; case '2' : System . out . print ( " Two ▁ " ) ; break ; case '3' : System . out . print ( " Three ▁ " ) ; break ; case '4' : System . out . print ( " Four ▁ " ) ; break ; case '5' : System . out . print ( " Fi@@ ve ▁ " ) ; break ; case '6' : System . out . print ( " Si@@ x ▁ " ) ; break ; case '7' : System . out . print ( " Se@@ ven ▁ " ) ; break ; case '8' : System . out . print ( " E@@ ight ▁ " ) ; break ; case '9' : System . out . print ( " N@@ ine ▁ " ) ; break ; } } static void print@@ Word ( String N ) { int i , length = N . length ( ) ; for ( i = 0 ; i < length ; i ++ ) { print@@ Value ( N . charAt ( i ) ) ; } } public static void main ( String [ ] args ) { String N = "123" ; print@@ Word ( N ) ; } }
Jar@@ o and Jar@@ o 7774 | class GF@@ G { static double jar@@ o_@@ distance ( String s1 , String s2 ) { if ( s1 == s2 ) return 1.0 ; int len1 = s1 . length ( ) , len2 = s2 . length ( ) ; int max_@@ dist = ( int ) ( Math . floor ( Math . max ( len1 , len2 ) / 2 ) - 1 ) ; int match = 0 ; int hash@@ _s@@ 1 [ ] = new int [ s1 . length ( ) ] ; int hash@@ _s@@ 2 [ ] = new int [ s2 . length ( ) ] ; for ( int i = 0 ; i < len1 ; i ++ ) { for ( int j = Math . max ( 0 , i - max_@@ dist ) ; j < Math . min ( len2 , i + max_@@ dist + 1 ) ; j ++ ) if ( s1 . charAt ( i ) == s2 . charAt ( j ) && hash@@ _s@@ 2 [ j ] == 0 ) { hash@@ _s@@ 1 [ i ] = 1 ; hash@@ _s@@ 2 [ j ] = 1 ; match ++ ; break ; } } if ( match == 0 ) return 0.0 ; double t = 0 ; int point = 0 ; for ( int i = 0 ; i < len1 ; i ++ ) if ( hash@@ _s@@ 1 [ i ] == 1 ) { while ( hash@@ _s@@ 2 [ point ] == 0 ) point ++ ; if ( s1 . charAt ( i ) != s2 . charAt ( point ++ ) ) t ++ ; } t /= 2 ; return ( ( ( double ) match ) / ( ( double ) len1 ) + ( ( double ) match ) / ( ( double ) len2 ) + ( ( double ) match - t ) / ( ( double ) match ) ) / 3.0 ; } public static void main ( String [ ] args ) { String s1 = " CR@@ ATE " , s2 = " TRACE " ; System . out . print ( jar@@ o_@@ distance ( s1 , s2 ) + "@@ NEW_@@ LINE@@ "@@ )@@ ; } }
Minimum sw@@ aps required to make a binary string di@@ visible by 2 ^ k 7787 | class GF@@ G { static int find@@ Min@@ Sw@@ aps ( String s , int k ) { int ans = 0 ; int c_@@ one = 0 , c_@@ zero = 0 ; for ( int i = s . length ( ) - 1 ; i >= 0 ; i -- ) { if ( s . charAt ( i ) == '1' ) c_@@ one ++ ; if ( s . charAt ( i ) == '0' ) { c_@@ zero ++ ; ans += c_@@ one ; } if ( c_@@ zero == k ) break ; } if ( c_@@ zero < k ) return - 1 ; return ans ; } public static void main ( String [ ] args ) { String s = "100@@ 11@@ 1" ; int k = 2 ; System . out . println ( find@@ Min@@ Sw@@ aps ( s , k ) ) ; } }
Remove vo@@ w@@ els from a string stored in a Binary Tree 7789 | import java . util . * ; class GF@@ G { static class Node { char data ; Node left , right ; Node ( char _val ) { data = _val ; left = right = null ; } } ; static Node add@@ in@@ BT ( Node root , char data ) { if ( root == null ) { root = new Node ( data ) ; } else { Queue < Node > Q = new LinkedList < Node > ( ) ; Q . add ( root ) ; while ( ! Q . isEmpty ( ) ) { Node temp = Q . peek ( ) ; Q . remove ( ) ; if ( temp . left == null ) { temp . left = new Node ( data ) ; break ; } else Q . add ( temp . left ) ; if ( temp . right == null ) { temp . right = new Node ( data ) ; break ; } else Q . add ( temp . right ) ; } } return root ; } static void print ( Node root ) { Queue < Node > Q = new LinkedList < Node > ( ) ; Q . add ( root ) ; while ( Q . size ( ) > 0 ) { Node temp = Q . peek ( ) ; Q . remove ( ) ; System . out . print ( temp . data ) ; if ( temp . left != null ) Q . add ( temp . left ) ; if ( temp . right != null ) Q . add ( temp . right ) ; } } static boolean check@@ vo@@ wel ( char ch ) { ch = Character . toLowerCase ( ch ) ; if ( ch == ' a ' ch == ' e ' ch == ' i ' ch == ' o ' ch == ' u ' ) { return true ; } else { return false ; } } static Node remove@@ vo@@ w@@ els ( Node root ) { Queue < Node > Q = new LinkedList < Node > ( ) ; Q . add ( root ) ; Node roo@@ t1 = null ; while ( ! Q . isEmpty ( ) ) { Node temp = Q . peek ( ) ; Q . remove ( ) ; if ( ! check@@ vo@@ wel ( temp . data ) ) { roo@@ t1 = add@@ in@@ BT ( roo@@ t1 , temp . data ) ; } if ( temp . left != null ) { Q . add ( temp . left ) ; } if ( temp . right != null ) { Q . add ( temp . right ) ; } } return roo@@ t1 ; } public static void main ( String [ ] args ) { String s = " ge@@ e@@ ks " ; Node root = null ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { root = add@@ in@@ BT ( root , s . charAt ( i ) ) ; } root = remove@@ vo@@ w@@ els ( root ) ; print ( root ) ; } }
Queries to find the count of vo@@ w@@ els in the sub@@ strings of the given string 7809 | class GF@@ G { static final int N = 2 ; static Boolean is@@ Vo@@ wel ( char ch ) { return ( ch == ' a ' ch == ' e ' ch == ' i ' ch == ' o ' ch == ' u ' ) ; } static void perform@@ Queries ( String str , int len , int queries [ ] [ ] , int q ) { int [ ] pre = new int [ len ] ; if ( is@@ Vo@@ wel ( str . charAt ( 0 ) ) ) pre [ 0 ] = 1 ; else pre [ 0 ] = 0 ; for ( int i = 1 ; i < len ; i ++ ) { if ( is@@ Vo@@ wel ( str . charAt ( i ) ) ) pre [ i ] = 1 + pre [ i - 1 ] ; else pre [ i ] = pre [ i - 1 ] ; } for ( int i = 0 ; i < q ; i ++ ) { if ( queries [ i ] [ 0 ] == 0 ) { System . out . println ( pre [ queries [ i ] [ 1 ] ] ) ; } else { System . out . println ( ( pre [ queries [ i ] [ 1 ] ] - pre [ queries [ i ] [ 0 ] - 1 ] ) ) ; } } } public static void main ( String [ ] args ) { String str = " ge@@ ek@@ s@@ forge@@ e@@ ks " ; int len = str . length ( ) ; int queries [ ] [ ] = { { 1 , 3 } , { 2 , 4 } , { 1 , 9 } } ; int q = queries . length ; perform@@ Queries ( str , len , queries , q ) ; } }
Number of ways to split a binary number such that every part is di@@ visible by 2 7813 | class GF@@ G { static int max@@ N = 20 ; static int max@@ M = 64 ; static int cnt@@ Splits ( String s ) { if ( s . charAt ( s . length ( ) - 1 ) == '1' ) return 0 ; int c_@@ zero = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) c_@@ zero += ( s . charAt ( i ) == '0' ) ? 1 : 0 ; return ( int ) Math . pow ( 2 , c_@@ zero - 1 ) ; } public static void main ( String [ ] args ) { String s = "100@@ 10" ; System . out . println ( cnt@@ Splits ( s ) ) ; } }
Find the occurrence of the given binary pattern in the binary representation of the array elements 7837 | import java . util . * ; class GF@@ G { static String dec@@ To@@ Binary ( int n ) { int [ ] binary@@ Num = new int [ 32 ] ; int i = 0 ; while ( n > 0 ) { binary@@ Num [ i ] = n % 2 ; n = n / 2 ; i ++ ; } String binary = " " ; for ( int j = i - 1 ; j >= 0 ; j -- ) { binary += String . valueOf ( binary@@ Num [ j ] ) ; } return binary ; } static int count@@ Freq ( String pat , String txt ) { int M = pat . length ( ) ; int N = txt . length ( ) ; int res = 0 ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) { if ( txt . charAt ( i + j ) != pat . charAt ( j ) ) { break ; } } if ( j == M ) { res ++ ; j = 0 ; } } return res ; } static void find@@ Occurren@@ ce ( int arr [ ] , int n , String pattern ) { for ( int i = 0 ; i < n ; i ++ ) { String binary = dec@@ To@@ Binary ( arr [ i ] ) ; System . out . print ( count@@ Freq ( pattern , binary ) + " ▁ " ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 106 , 7 , 8 } ; String pattern = "10" ; int n = arr . length ; find@@ Occurren@@ ce ( arr , n , pattern ) ; } }
Find the winner of the game 7844 | import java . util . Arrays ; class GF@@ G { static void find_@@ winner ( String str , int n ) { String str1 = " " , str2 = " " ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { str1 += str . charAt ( i ) ; } else { str2 += str . charAt ( i ) ; } } char a [ ] = str1 . toCharArray ( ) ; Arrays . sort ( a ) ; char b [ ] = str2 . toCharArray ( ) ; Arrays . sort ( b ) ; str1 = new String ( a ) ; str2 = new String ( b ) ; if ( str1 . compareTo ( str2 ) < 0 ) System . out . print ( " A " ) ; else if ( str1 . compareTo ( str2 ) > 0 ) System . out . print ( " B " ) ; else System . out . print ( " Ti@@ e " ) ; } public static void main ( String [ ] args ) { String str = " ge@@ ek@@ s@@ forge@@ e@@ ks " ; int n = str . length ( ) ; find_@@ winner ( str , n ) ; } }
Program to duplicate Vo@@ w@@ els in String 7855 | import java . util . * ; class GF@@ G { static boolean is@@ Vo@@ wel ( char ch ) { ch = Character . toUpperCase ( ch ) ; return ( ch == ' A ' ch == ' E ' ch == ' I ' ch == ' O ' ch == ' U ' ) ; } static String duplicate@@ Vo@@ w@@ els ( String str ) { int t = str . length ( ) ; String res = " " ; for ( int i = 0 ; i < t ; i ++ ) { if ( is@@ Vo@@ wel ( str . charAt ( i ) ) ) res += str . charAt ( i ) ; res += str . charAt ( i ) ; } return res ; } public static void main ( String [ ] args ) { String str = " hello@@ world " ; System . out . println ( " Original ▁ String : ▁ " + str ) ; String res = duplicate@@ Vo@@ w@@ els ( str ) ; System . out . println ( " String ▁ with ▁ Vo@@ w@@ els ▁ duplicated : ▁ " + res ) ; } }
Recursive program to replace all occurrences of pi with 3.14 in a given string 7867 | class GF@@ G { public static String replace@@ Pi ( String s ) { if ( s . length ( ) == 0 || s . length ( ) == 1 ) return s ; if ( s . charAt ( 0 ) == ' p ' && s . charAt ( 1 ) == ' i ' ) { String small@@ Output = replace@@ Pi ( s . substring ( 2 ) ) ; return "@@ 3.14@@ " + small@@ Output ; } else { String small@@ Output = replace@@ Pi ( s . substring ( 1 ) ) ; return s . charAt ( 0 ) + small@@ Output ; } } public static void main ( String [ ] args ) { String s = " pi@@ pp@@ pi@@ i@@ ip@@ i " ; String result = replace@@ Pi ( s ) ; System . out . println ( result ) ; } }
Lon@@ gest sub@@ sequence with at least one character appearing in every string 7873 | class GF@@ G { static int MAX = 26 ; static int lar@@ gest@@ Sub@@ Seq ( String arr [ ] , int n ) { int [ ] count = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { String str = arr [ i ] ; boolean [ ] hash = new boolean [ MAX ] ; for ( int j = 0 ; j < str . length ( ) ; j ++ ) { hash [ str . charAt ( j ) - ' a ' ] = true ; } for ( int j = 0 ; j < MAX ; j ++ ) { if ( hash [ j ] ) count [ j ] ++ ; } } int max = - 1 ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( max < count [ i ] ) max = count [ i ] ; } return max ; } public static void main ( String [ ] args ) { String arr [ ] = { " ab " , " bc " , " de " } ; int n = arr . length ; System . out . println ( lar@@ gest@@ Sub@@ Seq ( arr , n ) ) ; } }
Distin@@ ct strings such that they contains given strings as sub 7879 | import java . util . HashSet ; class GF@@ G { static HashSet < String > string@@ Set = new HashSet < > ( ) ; public static void find_@@ permutation ( String str1 , String str2 , int len1 , int len2 , int i , int j , String res ) { if ( res . length ( ) == len1 + len2 ) { string@@ Set . add ( res ) ; return ; } if ( i < len1 ) find_@@ permutation ( str1 , str2 , len1 , len2 , i + 1 , j , res + str1 . charAt ( i ) ) ; if ( j < len2 ) find_@@ permutation ( str1 , str2 , len1 , len2 , i , j + 1 , res + str2 . charAt ( j ) ) ; } public static void print_@@ set ( ) { for ( String s : string@@ Set ) System . out . println ( s ) ; } public static void main ( String [ ] args ) { String str1 = " aa " , str2 = " ab " ; int len1 = str1 . length ( ) ; int len2 = str2 . length ( ) ; find_@@ permutation ( str1 , str2 , len1 , len2 , 0 , 0 , " " ) ; print_@@ set ( ) ; } }
Count of non 7882 | class GF@@ G { static int count@@ Sub@@ Str ( char [ ] s , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 2 { if ( s [ i ] == '0' && s [ i + 1 ] == '1' && s [ i + 2 ] == '0' ) { count ++ ; i += 3 ; } else if ( s [ i ] == '1' && s [ i + 1 ] == '0' && s [ i + 2 ] == '1' ) { count ++ ; i += 3 ; } else { i ++ ; } } return count ; } public static void main ( String [ ] args ) { char [ ] s = "@@ 101@@ 0101@@ 01@@ 01" . toCharArray ( ) ; int n = s . length ; System . out . println ( count@@ Sub@@ Str ( s , n ) ) ; } }
Find distinct characters in distinct sub@@ strings of a string 7883 | import java . util . HashSet ; class ge@@ e@@ ks { public static int count@@ Total@@ Distin@@ ct ( String str ) { int cnt = 0 ; HashSet < String > items = new HashSet < > ( ) ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { String temp = " " ; HashSet < Character > ans = new HashSet < > ( ) ; for ( int j = i ; j < str . length ( ) ; ++ j ) { temp = temp + str . charAt ( j ) ; ans . add ( str . charAt ( j ) ) ; if ( ! items . contains ( temp ) ) { items . add ( temp ) ; cnt += ans . size ( ) ; } } } return cnt ; } public static void main ( String [ ] args ) { String str = " AB@@ CA " ; System . out . println ( count@@ Total@@ Distin@@ ct ( str ) ) ; } }
Reverse the Words of a String using Stack 7894 | import java . util . Arrays ; import java . util . Stack ; class GF@@ G { static void reverse ( String k ) { Stack < String > s = new Stack < > ( ) ; String [ ] token = k . split ( " ▁ " ) ; for ( int i = 0 ; i < token . length ; i ++ ) { s . push ( token [ i ] ) ; } while ( ! s . empty ( ) ) { System . out . print ( s . peek ( ) + " ▁ " ) ; s . pop ( ) ; } } public static void main ( String [ ] args ) { String k = " ge@@ e@@ ks ▁ for ▁ ge@@ e@@ ks " ; reverse ( k ) ; } }
Count of three non 7900 | class GF@@ G { static boolean is@@ Pal@@ in ( int i , int j , int k , int l , int p , int q , String s ) { int start = i , end = q ; while ( start < end ) { if ( s . charAt ( start ) != s . charAt ( end ) ) { return false ; } start ++ ; if ( start == j + 1 ) { start = k ; } end -- ; if ( end == p - 1 ) { end = l ; } } return true ; } static int count@@ Sub@@ Str ( String s ) { int count = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i ; j < n - 2 ; j ++ ) { for ( int k = j + 1 ; k < n - 1 ; k ++ ) { for ( int l = k ; l < n - 1 ; l ++ ) { for ( int p = l + 1 ; p < n ; p ++ ) { for ( int q = p ; q < n ; q ++ ) { if ( is@@ Pal@@ in ( i , j , k , l , p , q , s ) ) { count ++ ; } } } } } } } return count ; } public static void main ( String [ ] args ) { String s = " abc@@ a " ; System . out . println ( count@@ Sub@@ Str ( s ) ) ; } }
Find the last non repe@@ ating character in string 7909 | public class GF@@ G { static final int MAX = 256 ; static String last@@ Non@@ Repe@@ ating ( String str , int n ) { int freq [ ] = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ str . charAt ( i ) ] ++ ; for ( int i = n - 1 ; i >= 0 ; i -- ) { char ch = str . charAt ( i ) ; if ( freq [ ch ] == 1 ) return ( " " + ch ) ; } return " - 1" ; } public static void main ( String [ ] args ) { String str = " Ge@@ ek@@ sFor@@ Ge@@ e@@ ks " ; int n = str . length ( ) ; System . out . println ( last@@ Non@@ Repe@@ ating ( str , n ) ) ; } }
Maximum length pal@@ ind@@ ro@@ me that can be created with characters in range L and R 7926 | class GF@@ G { static int N = 4 ; static int perform@@ Queries ( int l , int r , int prefix [ ] [ ] ) { l -- ; r -- ; boolean flag = false ; int count = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { int cnt = prefix [ r ] [ i ] ; if ( l > 0 ) cnt -= prefix [ l - 1 ] [ i ] ; if ( cnt % 2 == 1 ) { flag = true ; count += cnt - 1 ; } else count += cnt ; } if ( flag ) count += 1 ; return count ; } static void pre@@ Calculate ( String s , int prefix [ ] [ ] ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { prefix [ i ] [ s . charAt ( i ) - ' a ' ] ++ ; } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) prefix [ i ] [ j ] += prefix [ i - 1 ] [ j ] ; } } public static void main ( String args [ ] ) { String s = " am@@ im " ; int prefix [ ] [ ] = new int [ N ] [ 26 ] ; pre@@ Calculate ( s , prefix ) ; int queries [ ] [ ] = { { 1 , 4 } , { 3 , 4 } } ; int q = queries . length ; for ( int i = 0 ; i < q ; i ++ ) { System . out . println ( perform@@ Queries ( queries [ i ] [ 0 ] , queries [ i ] [ 1 ] , prefix ) ) ; } } }
Cap@@ it@@ alize the first and last character of each word in a string 7942 | class GF@@ G { static String First@@ And@@ Last ( String str ) { char [ ] ch = str . toCharArray ( ) ; for ( int i = 0 ; i < ch . length ; i ++ ) { int k = i ; while ( i < ch . length && ch [ i ] != ' ▁ ' ) i ++ ; ch [ k ] = ( char ) ( ch [ k ] >= ' a ' && ch [ k ] <= ' z ' ? ( ( int ) ch [ k ] - 32 ) : ( int ) ch [ k ] ) ; ch [ i - 1 ] = ( char ) ( ch [ i - 1 ] >= ' a ' && ch [ i - 1 ] <= ' z ' ? ( ( int ) ch [ i - 1 ] - 32 ) : ( int ) ch [ i - 1 ] ) ; } return new String ( ch ) ; } public static void main ( String args [ ] ) { String str = " Ge@@ e@@ ks ▁ for ▁ Ge@@ e@@ ks " ; System . out . println ( str ) ; System . out . println ( First@@ And@@ Last ( str ) ) ; } }
Find the longest sub 7945 | class GF@@ G { static int [ ] compute_@@ l@@ ps ( String s ) { int n = s . length ( ) ; int [ ] l@@ ps = new int [ n ] ; int len = 0 ; l@@ ps [ 0 ] = 0 ; int i = 1 ; while ( i < n ) { if ( s . charAt ( i ) == s . charAt ( len ) ) { len ++ ; l@@ ps [ i ] = len ; i ++ ; } else { if ( len != 0 ) len = l@@ ps [ len - 1 ] ; else { l@@ ps [ i ] = 0 ; i ++ ; } } } return l@@ ps ; } static void Lon@@ gest@@ substring ( String s ) { int [ ] l@@ ps = compute_@@ l@@ ps ( s ) ; int n = s . length ( ) ; if ( l@@ ps [ n - 1 ] == 0 ) { System . out . println ( - 1 ) ; return ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( l@@ ps [ i ] == l@@ ps [ n - 1 ] ) { System . out . println ( s . substring ( 0 , l@@ ps [ i ] ) ) ; return ; } } if ( l@@ ps [ l@@ ps [ n - 1 ] - 1 ] == 0 ) System . out . println ( - 1 ) ; else System . out . println ( s . substring ( 0 , l@@ ps [ l@@ ps [ n - 1 ] - 1 ] ) ) ; } public static void main ( String [ ] args ) { String s = " fix@@ prefix@@ suffix " ; Lon@@ gest@@ substring ( s ) ; } }
Find the first maximum length even word from a string 7967 | class GF@@ G { static String find@@ Max@@ Len@@ Even ( String str ) { int n = str . length ( ) ; int i = 0 ; int curr@@ len = 0 ; int maxlen = 0 ; int st = - 1 ; while ( i < n ) { if ( str . charAt ( i ) == ' ▁ ' ) { if ( curr@@ len % 2 == 0 ) { if ( maxlen < curr@@ len ) { maxlen = curr@@ len ; st = i - curr@@ len ; } } curr@@ len = 0 ; } else { curr@@ len ++ ; } i ++ ; } if ( curr@@ len % 2 == 0 ) { if ( maxlen < curr@@ len ) { maxlen = curr@@ len ; st = i - curr@@ len ; } } if ( st == - 1 ) return " - 1" ; return str . substring ( st , st + maxlen ) ; } public static void main ( String args [ ] ) { String str = " this ▁ is ▁ a ▁ test ▁ string " ; System . out . println ( find@@ Max@@ Len@@ Even ( str ) ) ; } }
Minimum length substring with exactly K distinct characters 7968 | class GF@@ G { static String find@@ Min@@ Len@@ Str ( String str , int k ) { int n = str . length ( ) ; int st = 0 ; int end = 0 ; int cnt [ ] = new int [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) cnt [ i ] = 0 ; int dist@@ E@@ le = 0 ; int curr@@ len ; int min@@ len = n ; int start@@ Ind = - 1 ; while ( end < n ) { cnt [ str . charAt ( end ) - ' a ' ] ++ ; if ( cnt [ str . charAt ( end ) - ' a ' ] == 1 ) dist@@ E@@ le ++ ; if ( dist@@ E@@ le > k ) { while ( st < end && dist@@ E@@ le > k ) { if ( cnt [ str . charAt ( st ) - ' a ' ] == 1 ) dist@@ E@@ le -- ; cnt [ str . charAt ( st ) - ' a ' ] -- ; st ++ ; } } if ( dist@@ E@@ le == k ) { while ( st < end && cnt [ str . charAt ( st ) - ' a ' ] > 1 ) { cnt [ str . charAt ( st ) - ' a ' ] -- ; st ++ ; } curr@@ len = end - st + 1 ; if ( curr@@ len < min@@ len ) { min@@ len = curr@@ len ; start@@ Ind = st ; } } end ++ ; } return str . substring ( start@@ Ind , start@@ Ind + min@@ len ) ; } public static void main ( String args [ ] ) { String str = " ef@@ ec@@ fe@@ fd " ; int k = 4 ; System . out . println ( find@@ Min@@ Len@@ Str ( str , k ) ) ; } }
Character pairs from two strings with even sum 7977 | class Gf@@ G { static int total@@ Pairs ( String s1 , String s2 ) { int a1 = 0 , b1 = 0 ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { if ( ( int ) s1 . charAt ( i ) % 2 != 0 ) a1 ++ ; else b1 ++ ; } int a2 = 0 , b2 = 0 ; for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { if ( ( int ) s2 . charAt ( i ) % 2 != 0 ) a2 ++ ; else b2 ++ ; } return ( ( a1 * a2 ) + ( b1 * b2 ) ) ; } public static void main ( String [ ] args ) { String s1 = " ge@@ e@@ ks " , s2 = " for " ; System . out . println ( total@@ Pairs ( s1 , s2 ) ) ; } }
Find the minimum number of preprocess moves required to make two strings equal 7980 | import java . util . * ; class GF@@ G { static int Pre@@ process ( String A , String B ) { int n = A . length ( ) ; int ans = 0 ; for ( int i = 0 ; i < n / 2 ; i ++ ) { HashMap < Character , Integer > mp = new HashMap < > ( ) ; if ( mp . containsKey ( A . charAt ( i ) ) ) mp . put ( A . charAt ( i ) , mp . get ( A . charAt ( i ) ) + 1 ) ; else mp . put ( A . charAt ( i ) , 1 ) ; if ( mp . containsKey ( A . charAt ( n - i - 1 ) ) ) mp . put ( A . charAt ( n - i - 1 ) , mp . get ( A . charAt ( n - i - 1 ) ) + 1 ) ; else mp . put ( A . charAt ( n - i - 1 ) , 1 ) ; if ( mp . containsKey ( B . charAt ( i ) ) ) mp . put ( B . charAt ( i ) , mp . get ( B . charAt ( i ) ) + 1 ) ; else mp . put ( B . charAt ( i ) , 1 ) ; if ( mp . containsKey ( B . charAt ( n - i - 1 ) ) ) mp . put ( B . charAt ( n - i - 1 ) , mp . get ( B . charAt ( n - i - 1 ) ) + 1 ) ; else mp . put ( B . charAt ( n - i - 1 ) , 1 ) ; int sz = mp . size ( ) ; if ( sz == 4 ) ans += 2 ; else if ( sz == 3 ) ans += 1 + ( A . charAt ( i ) == A . charAt ( n - i - 1 ) ? 1 : 0 ) ; else if ( sz == 2 ) ans += mp . get ( A . charAt ( i ) ) != 2 ? 1 : 0 ; } if ( n % 2 == 1 && A . charAt ( n / 2 ) != B . charAt ( n / 2 ) ) ans ++ ; return ans ; } public static void main ( String [ ] args ) { String A = " ab@@ ac@@ aba " , B = " bac@@ ab@@ aa " ; System . out . println ( Pre@@ process ( A , B ) ) ; } }
Sub@@ string Reverse Pattern 8033 | class GF@@ G { static void print@@ Pattern ( char [ ] s , int n ) { System . out . println ( s ) ; int i = 0 , j = n - 1 ; while ( i < j ) { char c = s [ i ] ; s [ i ] = s [ j ] ; s [ j ] = c ; i ++ ; j -- ; } i = 0 ; j = n - 1 ; while ( j - i > 1 ) { s [ i ] = s [ j ] = ' * ' ; System . out . println ( s ) ; i ++ ; j -- ; } } public static void main ( String [ ] args ) { char [ ] s = " ge@@ e@@ ks " . toCharArray ( ) ; int n = s . length ; print@@ Pattern ( s , n ) ; } }
Find Bit whose minimum sequence fli@@ ps makes all bits same 8054 | class Gf@@ G { static char bit@@ ToBe@@ Fli@@ pped ( String s ) { char last = s . charAt ( s . length ( ) - 1 ) ; char first = s . charAt ( 0 ) ; if ( last == first ) { if ( last == '0' ) { return '1' ; } else { return '0' ; } } else if ( last != first ) { return last ; } return last ; } public static void main ( String [ ] args ) { String s = "11@@ 0101@@ 100@@ 0" ; System . out . println ( bit@@ ToBe@@ Fli@@ pped ( s ) ) ; } }
Program to check if all characters have even frequency 8116 | class GF@@ G { static boolean check ( String s ) { int [ ] freq = new int [ 26 ] ; int n = s . length ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { freq [ ( s . charAt ( i ) ) - 97 ] += 1 ; } for ( int i = 0 ; i < freq . length ; i ++ ) { if ( freq [ i ] % 2 == 1 ) { return false ; } } return true ; } public static void main ( String [ ] args ) { String s = " ab@@ acc@@ aba " ; if ( check ( s ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
Remove even frequency characters from the string 8128 | import java . util . * ; class GF@@ G { static void solve ( String s ) { HashMap < Character , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( m . containsKey ( s . charAt ( i ) ) ) m . put ( s . charAt ( i ) , m . get ( s . charAt ( i ) ) + 1 ) ; else m . put ( s . charAt ( i ) , 1 ) ; } String new_@@ string = " " ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( m . get ( s . charAt ( i ) ) % 2 == 0 ) continue ; new_@@ string = new_@@ string + s . charAt ( i ) ; } System . out . println ( new_@@ string ) ; } public static void main ( String [ ] args ) { String s = " a@@ ab@@ bb@@ d@@ dee@@ ec@@ c " ; solve ( s ) ; } }
Minim@@ ize the length of string by removing occurrence of only one character 8151 | import java . io . * ; class GF@@ G { static int minimum@@ Length ( String s ) { int max@@ O@@ cc = 0 , n = s . length ( ) ; int arr [ ] = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ s . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( arr [ i ] > max@@ O@@ cc ) max@@ O@@ cc = arr [ i ] ; return ( n - max@@ O@@ cc ) ; } public static void main ( String [ ] args ) { String str = " af@@ d@@ de@@ w@@ q@@ d " ; System . out . println ( minimum@@ Length ( str ) ) ; } }
Minimum operation require to make first and last character same 8156 | import java . util . * ; class GF@@ G { static final int MAX = Integer . MAX_VALUE ; static int min@@ Operation ( String s , int i , int j , int count ) { if ( ( i >= s . length ( ) && j < 0 ) || ( i == j ) ) return MAX ; if ( s . charAt ( i ) == s . charAt ( j ) ) return count ; if ( i >= s . length ( ) ) return min@@ Operation ( s , i , j - 1 , count + 1 ) ; else if ( j < 0 ) return min@@ Operation ( s , i + 1 , j , count + 1 ) ; else return Math . min ( min@@ Operation ( s , i , j - 1 , count + 1 ) , min@@ Operation ( s , i + 1 , j , count + 1 ) ) ; } public static void main ( String [ ] args ) { String s = " bac@@ def@@ gh@@ ip@@ alo@@ p " ; int ans = min@@ Operation ( s , 0 , s . length ( ) - 1 , 0 ) ; if ( ans == MAX ) System . out . println ( - 1 ) ; else System . out . println ( ans ) ; } }
Lon@@ gest common an@@ agram sub@@ sequence from N strings 8176 | class GF@@ G { final int MAX_@@ CHAR = 26 ; static void frequency ( int fr@@ e [ ] [ ] , String s [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { String str = s [ i ] ; for ( int j = 0 ; j < str . length ( ) ; j ++ ) fr@@ e [ i ] [ str . charAt ( j ) - ' a ' ] ++ ; } } static void Lon@@ gest@@ Sequence ( int fr@@ e [ ] [ ] , int n ) { for ( int i = 24 ; i >= 0 ; i -- ) { int mi = fr@@ e [ 0 ] [ i ] ; for ( int j = 1 ; j < n ; j ++ ) mi = Math . min ( fr@@ e [ j ] [ i ] , mi ) ; while ( mi -- != 0 ) System . out . print ( ( char ) ( ' a ' + i ) ) ; } } public static void main ( String args [ ] ) { String s [ ] = { " lo@@ o " , " lo@@ l " , " o@@ live " } ; int n = s . length ; int fr@@ e [ ] [ ] = new int [ n ] [ 26 ] ; frequency ( fr@@ e , s , n ) ; Lon@@ gest@@ Sequence ( fr@@ e , n ) ; } }
Minimum bit changes in Binary Cir@@ cul@@ ar array to reach a index 8221 | class GF@@ G { static void minimum@@ Flip ( String s , int x , int y ) { s = s + s ; boolean is@@ Op@@ posi@@ te = false ; if ( x > y ) { swap ( x , y ) ; is@@ Op@@ posi@@ te = true ; } int val@@ Clock@@ wise = 0 ; char cur = s . charAt ( x ) ; for ( int i = x ; i <= y ; i ++ ) { if ( s . charAt ( i ) != cur ) { cur = s . charAt ( i ) ; val@@ Clock@@ wise ++ ; } } int val@@ An@@ tic@@ lock@@ wise = 0 ; cur = s . charAt ( y ) ; x += s . length ( ) ; for ( int i = y ; i < x ; i ++ ) { if ( s . charAt ( i ) != cur ) { cur = s . charAt ( i ) ; val@@ An@@ tic@@ lock@@ wise ++ ; } } if ( val@@ Clock@@ wise <= val@@ An@@ tic@@ lock@@ wise ) { if ( ! is@@ Op@@ posi@@ te ) { System . out . println ( " Clock@@ wise ▁ " + val@@ Clock@@ wise ) ; } else { System . out . println ( " An@@ ti - clockwise ▁ " + val@@ An@@ tic@@ lock@@ wise ) ; } } else if ( ! is@@ Op@@ posi@@ te ) { System . out . println ( " An@@ ti - clockwise ▁ " + val@@ An@@ tic@@ lock@@ wise ) ; } else { System . out . println ( " Clock@@ wise ▁ " + val@@ Clock@@ wise ) ; } } static void swap ( int a , int b ) { int c = a ; a = b ; b = c ; } public static void main ( String [ ] args ) { int x = 0 , y = 8 ; String s = "@@ 0001@@ 10" ; minimum@@ Flip ( s , x , y ) ; } }
Lex@@ ico@@ graphical Maximum substring of string 8240 | import java . io . * ; import java . util . * ; class GF@@ G { static String Lex@@ ico@@ graphic@@ al@@ Max@@ String ( String str ) { char max@@ char = ' a ' ; ArrayList < Integer > index = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) >= max@@ char ) { max@@ char = str . charAt ( i ) ; index . add ( i ) ; } } String max@@ string = " " ; for ( int i = 0 ; i < index . size ( ) ; i ++ ) { if ( str . substring ( index . get ( i ) , str . length ( ) ) . compareTo ( max@@ string ) > 0 ) { max@@ string = str . substring ( index . get ( i ) , str . length ( ) ) ; } } return max@@ string ; } public static void main ( String [ ] args ) { String str = " ac@@ bac@@ bc " ; System . out . println ( Lex@@ ico@@ graphic@@ al@@ Max@@ String ( str ) ) ; } }
Reverse each word in a linked list node 8276 | class GF@@ G { static class Node { String c ; Node next ; } ; static Node newNode ( String c ) { Node temp = new Node ( ) ; temp . c = c ; temp . next = null ; return temp ; } ; static String reverse_@@ word ( String str ) { String s = " " ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) s = str . charAt ( i ) + s ; return s ; } static Node reverse ( Node head ) { Node ptr = head ; while ( ptr != null ) { ptr . c = reverse_@@ word ( ptr . c ) ; ptr = ptr . next ; } return head ; } static void print@@ List ( Node head ) { while ( head != null ) { System . out . print ( head . c + " ▁ " ) ; head = head . next ; } } public static void main ( String args [ ] ) { Node head = newNode ( " Ge@@ ek@@ s@@ forge@@ e@@ ks " ) ; head . next = newNode ( " a " ) ; head . next . next = newNode ( " computer " ) ; head . next . next . next = newNode ( " sci@@ ence " ) ; head . next . next . next . next = newNode ( " portal " ) ; head . next . next . next . next . next = newNode ( " for " ) ; head . next . next . next . next . next . next = newNode ( " ge@@ e@@ ks " ) ; System . out . print ( "@@ List before reverse@@ : NEW_@@ LINE@@ "@@ )@@ ; print@@ List ( head ) ; head = reverse ( head ) ; System . out . print ( " List after reverse : "@@ )@@ ; print@@ List ( head ) ; } }
Find i '@@ th Index character in a binary string obtained after n iterations 8289 | import java . io . * ; import java . util . Arrays ; class GF@@ G { static String s = " " ; static String Reverse@@ String ( String s ) { char [ ] arr = s . toCharArray ( ) ; for ( int i = 0 ; i < arr . length / 2 ; i ++ ) { char temp = arr [ i ] ; arr [ i ] = arr [ arr . length - i - 1 ] ; arr [ arr . length - i - 1 ] = temp ; } return new String ( arr ) ; } static void binary_@@ conversion ( int m ) { while ( m != 0 ) { int tmp = m % 2 ; s += Integer . toString ( tmp ) ; m = ( int ) ( m / 2 ) ; } s = Reverse@@ String ( s ) ; } static int find_@@ character ( int n , int m , int i ) { binary_@@ conversion ( m ) ; String s1 = " " ; for ( int x = 0 ; x < n ; x ++ ) { for ( int y = 0 ; y < s . length ( ) ; y ++ ) { if ( s . charAt ( y ) == '1' ) s1 += "10" ; else s1 += "@@ 01" ; } s = s1 ; s1 = " " ; } return s . charAt ( i ) - '0' ; } public static void main ( String args [ ] ) { int m = 5 , n = 2 , i = 8 ; System . out . print ( find_@@ character ( n , m , i ) ) ; } }
Sum of all sub@@ sequences of a number 8301 | import java . io . * ; class GF@@ G { static int find@@ Sub@@ Sequence ( String s , int num ) { int res = 0 ; int i = 0 ; while ( num > 0 ) { if ( ( num & 1 ) == 1 ) res += s . charAt ( i ) - '0' ; i ++ ; num = num >> 1 ; } return res ; } static int combined@@ Sum ( String s ) { int n = s . length ( ) ; int c_@@ sum = 0 ; int range = ( 1 << n ) - 1 ; for ( int i = 0 ; i <= range ; i ++ ) c_@@ sum += find@@ Sub@@ Sequence ( s , i ) ; return c_@@ sum ; } public static void main ( String [ ] args ) { String s = "123" ; System . out . println ( combined@@ Sum ( s ) ) ; } }
Create a new string by altern@@ ately combining the characters of two hal@@ ves of the string in reverse 8323 | import java . io . * ; class GF@@ G { public static void solve ( String s ) { int l = s . length ( ) ; int x = l / 2 ; int y = l ; String p = " " ; while ( x > 0 && y > l / 2 ) { char ch = s . charAt ( x - 1 ) ; p += ch ; x -- ; ch = s . charAt ( y - 1 ) ; p += ch ; y -- ; } if ( y > l / 2 ) { char ch = s . charAt ( x - 1 ) ; p += ch ; y -- ; } System . out . println ( p ) ; } public static void main ( String args [ ] ) { String s = " sun@@ sh@@ ine " ; solve ( s ) ; } }
Convert string X to an an@@ agram of string Y with minimum replacements 8334 | class GF@@ G { static final int MAX = 26 ; static void print@@ An@@ agram@@ And@@ Changes ( char [ ] X , char [ ] Y ) { int coun@@ tx [ ] = new int [ MAX ] , coun@@ ty [ ] = new int [ MAX ] , ctr@@ x [ ] = new int [ MAX ] , c@@ try [ ] = new int [ MAX ] ; int change = 0 ; int l = X . length ; for ( int i = 0 ; i < l ; i ++ ) { coun@@ tx [ X [ i ] - ' A ' ] ++ ; coun@@ ty [ Y [ i ] - ' A ' ] ++ ; } for ( int i = 0 ; i < MAX ; i ++ ) { if ( coun@@ tx [ i ] > coun@@ ty [ i ] ) { ctr@@ x [ i ] += ( coun@@ tx [ i ] - coun@@ ty [ i ] ) ; } else if ( coun@@ tx [ i ] < coun@@ ty [ i ] ) { c@@ try [ i ] += ( coun@@ ty [ i ] - coun@@ tx [ i ] ) ; } change += Math . abs ( coun@@ ty [ i ] - coun@@ tx [ i ] ) ; } for ( int i = 0 ; i < l ; i ++ ) { if ( ctr@@ x [ X [ i ] - ' A ' ] == 0 ) { continue ; } int j ; for ( j = 0 ; j < MAX ; j ++ ) { if ( ( c@@ try [ j ] ) > 0 ) { break ; } } if ( coun@@ tx [ X [ i ] - ' A ' ] == ctr@@ x [ X [ i ] - ' A ' ] X [ i ] - ' A ' > j ) { coun@@ tx [ X [ i ] - ' A ' ] -- ; ctr@@ x [ X [ i ] - ' A ' ] -- ; c@@ try [ j ] -- ; X [ i ] = ( char ) ( ' A ' + j ) ; } else { coun@@ tx [ X [ i ] - ' A ' ] -- ; } } System . out . println ( " An@@ agram ▁ : ▁ " + String . valueOf ( X ) ) ; System . out . println ( " Number ▁ of ▁ changes ▁ made ▁ : ▁ " + change / 2 ) ; } public static void main ( String [ ] args ) { String x = " CDB@@ ABC " , y = " AD@@ C@@ AB@@ D " ; print@@ An@@ agram@@ And@@ Changes ( x . toCharArray ( ) , y . toCharArray ( ) ) ; } }
Count occurrences of a word in string 8374 | import java . io . * ; class GF@@ G { static int count@@ Occurren@@ ces ( String str , String word ) { String a [ ] = str . split ( " ▁ " ) ; int count = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { if ( word . equals ( a [ i ] ) ) count ++ ; } return count ; } public static void main ( String args [ ] ) { String str = " Ge@@ ek@@ s@@ for@@ Ge@@ e@@ ks ▁ A ▁ computer ▁ sci@@ ence ▁ portal ▁ for ▁ ge@@ e@@ ks ▁ " ; String word = " portal " ; System . out . println ( count@@ Occurren@@ ces ( str , word ) ) ; } }
Split the string into sub@@ strings using delimiter 8379 | import java . util . * ; class GF@@ G { static Vector < String > split@@ Strings ( String str , char dl ) { String word = " " ; int num = 0 ; str = str + dl ; int l = str . length ( ) ; Vector < String > sub@@ str@@ _list = new Vector < String > ( ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( str . charAt ( i ) != dl ) { word = word + str . charAt ( i ) ; } else { if ( ( int ) word . length ( ) != 0 ) { sub@@ str@@ _list . add ( word ) ; } word = " " ; } } return sub@@ str@@ _list ; } public static void main ( String [ ] args ) { String str = " ge@@ e@@ ks ; for ; ge@@ e@@ ks " ; char dl = ' ; ' ; Vector < String > res = split@@ Strings ( str , dl ) ; for ( String x : res ) { System . out . println ( x ) ; } } }
Lon@@ gest sub@@ sequence of the form 0 * 1 * 0 * in a binary string 8398 | class GF@@ G { public static int lon@@ gest@@ Sub@@ seq ( String s ) { int n = s . length ( ) ; int [ ] pre_@@ count_@@ 0 = new int [ n + 2 ] ; int [ ] pre_@@ count_@@ 1 = new int [ n + 1 ] ; int [ ] post_@@ count_@@ 0 = new int [ n + 2 ] ; pre_@@ count_@@ 0 [ 0 ] = 0 ; post_@@ count_@@ 0 [ n + 1 ] = 0 ; pre_@@ count_@@ 1 [ 0 ] = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { pre_@@ count_@@ 0 [ j ] = pre_@@ count_@@ 0 [ j - 1 ] ; pre_@@ count_@@ 1 [ j ] = pre_@@ count_@@ 1 [ j - 1 ] ; post_@@ count_@@ 0 [ n - j + 1 ] = post_@@ count_@@ 0 [ n - j + 2 ] ; if ( s . charAt ( j - 1 ) == '0' ) pre_@@ count_@@ 0 [ j ] ++ ; else pre_@@ count_@@ 1 [ j ] ++ ; if ( s . charAt ( n - j ) == '0' ) post_@@ count_@@ 0 [ n - j + 1 ] ++ ; } if ( pre_@@ count_@@ 0 [ n ] == n pre_@@ count_@@ 0 [ n ] == 0 ) return n ; int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= n ; j ++ ) ans = Math . max ( pre_@@ count_@@ 0 [ i - 1 ] + pre_@@ count_@@ 1 [ j ] - pre_@@ count_@@ 1 [ i - 1 ] + post_@@ count_@@ 0 [ j + 1 ] , ans ) ; return ans ; } public static void main ( String [ ] args ) { String s = "@@ 0000@@ 11@@ 10000@@ 0" ; System . out . println ( lon@@ gest@@ Sub@@ seq ( s ) ) ; } }
Distin@@ ct permutations of the string | Set 2 8401 | public class GF@@ G { static boolean should@@ Swap ( char str [ ] , int start , int curr ) { for ( int i = start ; i < curr ; i ++ ) { if ( str [ i ] == str [ curr ] ) { return false ; } } return true ; } static void find@@ Per@@ mutations ( char str [ ] , int index , int n ) { if ( index >= n ) { System . out . println ( str ) ; return ; } for ( int i = index ; i < n ; i ++ ) { boolean check = should@@ Swap ( str , index , i ) ; if ( check ) { swap ( str , index , i ) ; find@@ Per@@ mutations ( str , index + 1 , n ) ; swap ( str , index , i ) ; } } } static void swap ( char [ ] str , int i , int j ) { char c = str [ i ] ; str [ i ] = str [ j ] ; str [ j ] = c ; } public static void main ( String [ ] args ) { char str [ ] = { ' A ' , ' B ' , ' C ' , ' A ' } ; int n = str . length ; find@@ Per@@ mutations ( str , 0 , n ) ; } }
Maximum number of characters between any two same character in a string 8408 | import java . io . * ; public class GF@@ G { static int MAX_@@ CHAR = 256 ; static int maximum@@ Chars ( String str ) { int n = str . length ( ) ; int res = - 1 ; int [ ] first@@ Ind = new int [ MAX_@@ CHAR ] ; for ( int i = 0 ; i < MAX_@@ CHAR ; i ++ ) first@@ Ind [ i ] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int first_@@ ind = first@@ Ind [ str . charAt ( i ) ] ; if ( first_@@ ind == - 1 ) first@@ Ind [ str . charAt ( i ) ] = i ; else res = Math . max ( res , Math . abs ( i - first_@@ ind - 1 ) ) ; } return res ; } static public void main ( String [ ] args ) { String str = " ab@@ ba " ; System . out . println ( maximum@@ Chars ( str ) ) ; } }
Length of the longest substring with equal 1 s and 0 s 8414 | import java . io . * ; import java . util . * ; class GF@@ G { public static boolean isValid ( String p ) { int n = p . length ( ) ; int c1 = 0 , c0 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( p . charAt ( i ) == '0' ) { c0 ++ ; } if ( p . charAt ( i ) == '1' ) { c1 ++ ; } } if ( c0 == c1 ) { return true ; } else { return false ; } } public static int lon@@ gest@@ Sub ( String s ) { int max_len = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( isValid ( s . substring ( i , j + 1 ) ) && max_len < j - i + 1 ) { max_len = j - i + 1 ; } } } return max_len ; } public static void main ( String [ ] args ) { String s = "@@ 101@@ 00@@ 100@@ 0" ; System . out . println ( lon@@ gest@@ Sub ( s ) ) ; } }
Generate two output strings depending upon occurrence of character in input string . 8428 | class GF@@ G { final static int MAX_@@ CHAR = 256 ; static void print@@ Du@@ o ( String str ) { int count@@ Char [ ] = new int [ MAX_@@ CHAR ] ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { count@@ Char [ str . charAt ( i ) - ' a ' ] ++ ; } String str1 = " " , str2 = " " ; for ( int i = 0 ; i < MAX_@@ CHAR ; i ++ ) { if ( count@@ Char [ i ] > 1 ) { str2 = str2 + ( char ) ( i + ' a ' ) ; } else if ( count@@ Char [ i ] == 1 ) { str1 = str1 + ( char ) ( i + ' a ' ) ; } } System . out . print ( " String ▁ with ▁ characters ▁ occur@@ ring ▁ " + "@@ on@@ ce@@ :@@ NEW_@@ LINE@@ "@@ )@@ ; System . out . print ( str1 + "@@ NEW_@@ LINE@@ "@@ )@@ ; System . out . print ( " String ▁ with ▁ characters ▁ occur@@ ring ▁ " + "@@ multiple time@@ s@@ :@@ NEW_@@ LINE@@ "@@ )@@ ; System . out . print ( str2 + "@@ NEW_@@ LINE@@ "@@ )@@ ; System . out . print ( " " ) ; } public static void main ( String [ ] args ) { String str = " lo@@ v@@ eto@@ code " ; print@@ Du@@ o ( str ) ; } }
Find repeated character present first in a string 8445 | import java . io . * ; import java . util . * ; class GF@@ G { static int find@@ Repeat@@ First@@ N2 ( String s ) { int p = - 1 , i , j ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { for ( j = i + 1 ; j < s . length ( ) ; j ++ ) { if ( s . charAt ( i ) == s . charAt ( j ) ) { p = i ; break ; } } if ( p != - 1 ) break ; } return p ; } static public void main ( String [ ] args ) { String str = " ge@@ ek@@ s@@ forge@@ e@@ ks " ; int pos = find@@ Repeat@@ First@@ N2 ( str ) ; if ( pos == - 1 ) System . out . println ( " Not ▁ found " ) ; else System . out . println ( str . charAt ( pos ) ) ; } }
Given two strings check which string makes a pal@@ ind@@ ro@@ me first 8473 | public class Fir@@ st_@@ Pal@@ in { static final int MAX_@@ CHAR = 26 ; static char string@@ Pal@@ ind@@ ro@@ me ( String A , String B ) { int [ ] count@@ A = new int [ MAX_@@ CHAR ] ; int [ ] count@@ B = new int [ MAX_@@ CHAR ] ; int l1 = A . length ( ) ; int l2 = B . length ( ) ; for ( int i = 0 ; i < l1 ; i ++ ) count@@ A [ A . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < l2 ; i ++ ) count@@ B [ B . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( ( count@@ A [ i ] > 1 && count@@ B [ i ] == 0 ) ) return ' A ' ; return ' B ' ; } public static void main ( String args [ ] ) { String a = " abcde@@ a " ; String b = " bc@@ de@@ sg " ; System . out . println ( string@@ Pal@@ ind@@ ro@@ me ( a , b ) ) ; } }
Maximum length substring having all same characters after k changes 8500 | public class GF@@ G { static int find@@ Len ( String A , int n , int k , char ch ) { int maxlen = 1 ; int cnt = 0 ; int l = 0 , r = 0 ; while ( r < n ) { if ( A . charAt ( r ) != ch ) ++ cnt ; while ( cnt > k ) { if ( A . charAt ( l ) != ch ) -- cnt ; ++ l ; } maxlen = Math . max ( maxlen , r - l + 1 ) ; ++ r ; } return maxlen ; } static int answer ( String A , int n , int k ) { int maxlen = 1 ; for ( int i = 0 ; i < 26 ; ++ i ) { maxlen = Math . max ( maxlen , find@@ Len ( A , n , k , ( char ) ( i + ' A ' ) ) ) ; maxlen = Math . max ( maxlen , find@@ Len ( A , n , k , ( char ) ( i + ' a ' ) ) ) ; } return maxlen ; } public static void main ( String [ ] args ) { int n = 5 , k = 2 ; String A = " AB@@ AB@@ A " ; System . out . println ( " Maximum ▁ length ▁ = ▁ " + answer ( A , n , k ) ) ; n = 6 ; k = 4 ; String B = " HH@@ HH@@ HH " ; System . out . println ( " Maximum ▁ length ▁ = ▁ " + answer ( B , n , k ) ) ; } }
Maximum and minimum sums from two numbers with digit replacements 8626 | class GF@@ G { static int replace@@ Di@@ g ( int x , int from , int to ) { int result = 0 ; int multiply = 1 ; while ( x > 0 ) { int remin@@ der = x % 10 ; if ( remin@@ der == from ) result = result + to * multiply ; else result = result + remin@@ der * multiply ; multiply *= 10 ; x = x / 10 ; } return result ; } static void calculate@@ MinMax@@ Sum ( int x1 , int x2 ) { int min@@ Sum = replace@@ Di@@ g ( x1 , 6 , 5 ) + replace@@ Di@@ g ( x2 , 6 , 5 ) ; int max@@ Sum = replace@@ Di@@ g ( x1 , 5 , 6 ) + replace@@ Di@@ g ( x2 , 5 , 6 ) ; System . out . print ( " Minimum ▁ sum ▁ = ▁ " + min@@ Sum ) ; System . out . print ( " Maximum sum = " + max@@ Sum@@ )@@ ; } public static void main ( String [ ] args ) { int x1 = 5@@ 46@@ 6 , x2 = 455@@ 5 ; calculate@@ MinMax@@ Sum ( x1 , x2 ) ; } }
E@@ fficient method for 2 '@@ s complement of a binary string 8634 | class Test { static String find@@ Tw@@ os@@ complement ( StringBuffer str ) { int n = str . length ( ) ; int i ; for ( i = n - 1 ; i >= 0 ; i -- ) if ( str . charAt ( i ) == '1' ) break ; if ( i == - 1 ) return "1" + str ; for ( int k = i - 1 ; k >= 0 ; k -- ) { if ( str . charAt ( k ) == '1' ) str . replace ( k , k + 1 , "0" ) ; else str . replace ( k , k + 1 , "1" ) ; } return str . toString ( ) ; } public static void main ( String [ ] args ) { StringBuffer str = new StringBuffer ( "@@ 0000@@ 01@@ 01" ) ; System . out . println ( find@@ Tw@@ os@@ complement ( str ) ) ; } }
Sum of all subsets whose sum is a Perf@@ ect Number from a given array 8822 | import java . util . * ; class GF@@ G { static int is@@ Perf@@ ect ( int x ) { int sum_@@ div = 1 ; for ( int i = 2 ; i <= x / 2 ; ++ i ) { if ( x % i == 0 ) { sum_@@ div += i ; } } if ( sum_@@ div == x ) { return 1 ; } else return 0 ; } static void sub@@ set@@ Sum ( int arr [ ] , int n ) { long total = 1 << n ; for ( long i = 0 ; i < total ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( ( i & ( 1 << j ) ) != 0 ) sum += arr [ j ] ; if ( is@@ Perf@@ ect ( sum ) != 0 ) { System . out . print ( sum + " ▁ " ) ; } } } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 4 , 6 } ; int N = arr . length ; sub@@ set@@ Sum ( arr , N ) ; } }
Generate all N digit numbers having absolute difference as K between adjacent digits 8832 | import java . util . * ; class GF@@ G { static void check@@ Until ( int num , int K , int N , Vector < Integer > ans ) { if ( N == 1 ) { ans . add ( num ) ; return ; } if ( ( num % 10 + K ) <= 9 ) check@@ Until ( 10 * num + ( num % 10 + K ) , K , N - 1 , ans ) ; if ( K > 0 ) { if ( ( num % 10 - K ) >= 0 ) check@@ Until ( 10 * num + num % 10 - K , K , N - 1 , ans ) ; } } static void check ( int K , int N , Vector < Integer > ans ) { for ( int i = 1 ; i <= 9 ; i ++ ) { check@@ Until ( i , K , N , ans ) ; } } static void print ( Vector < Integer > ans ) { for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { System . out . print ( ans . get ( i ) + " , ▁ " ) ; } } public static void main ( String [ ] args ) { int N = 4 , K = 8 ; Vector < Integer > ans = new Vector < Integer > ( ) ; ; check ( K , N , ans ) ; print ( ans ) ; } }
Rat in a Ma@@ ze with multiple steps or jump allowed 8863 | class GF@@ G { static int N = 4 ; static void print@@ Solution ( int sol [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { System . out . printf ( " ▁ % d ▁ " , sol [ i ] [ j ] ) ; } System . out . printf ( "@@ NEW_@@ LINE@@ "@@ )@@ ; } } static boolean is@@ Safe ( int ma@@ ze [ ] [ ] , int x , int y ) { if ( x >= 0 && x < N && y >= 0 && y < N && ma@@ ze [ x ] [ y ] != 0 ) { return true ; } return false ; } static boolean solve@@ Ma@@ ze ( int ma@@ ze [ ] [ ] ) { int sol [ ] [ ] = { { 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 } } ; if ( solve@@ Ma@@ ze@@ Util ( ma@@ ze , 0 , 0 , sol ) == false ) { System . out . printf ( " Solution ▁ doesn ' t ▁ exist " ) ; return false ; } print@@ Solution ( sol ) ; return true ; } static boolean solve@@ Ma@@ ze@@ Util ( int ma@@ ze [ ] [ ] , int x , int y , int sol [ ] [ ] ) { if ( x == N - 1 && y == N - 1 ) { sol [ x ] [ y ] = 1 ; return true ; } if ( is@@ Safe ( ma@@ ze , x , y ) == true ) { sol [ x ] [ y ] = 1 ; for ( int i = 1 ; i <= ma@@ ze [ x ] [ y ] && i < N ; i ++ ) { if ( solve@@ Ma@@ ze@@ Util ( ma@@ ze , x + i , y , sol ) == true ) { return true ; } if ( solve@@ Ma@@ ze@@ Util ( ma@@ ze , x , y + i , sol ) == true ) { return true ; } } sol [ x ] [ y ] = 0 ; return false ; } return false ; } public static void main ( String [ ] args ) { int ma@@ ze [ ] [ ] = { { 2 , 1 , 0 , 0 } , { 3 , 0 , 0 , 1 } , { 0 , 1 , 0 , 1 } , { 0 , 0 , 0 , 1 } } ; solve@@ Ma@@ ze ( ma@@ ze ) ; } }
Expected number of moves to reach the end of a board | Matrix Expon@@ enti@@ ation 8921 | class GF@@ G { static final int maxSize = 50 ; static double [ ] [ ] matrix_@@ product ( double [ ] [ ] a , double [ ] [ ] b ) { double [ ] [ ] c = new double [ 7 ] [ 7 ] ; for ( int i = 0 ; i < 7 ; i ++ ) for ( int j = 0 ; j < 7 ; j ++ ) for ( int k = 0 ; k < 7 ; k ++ ) c [ i ] [ j ] += a [ i ] [ k ] * b [ k ] [ j ] ; return c ; } static double [ ] [ ] mul_@@ exp@@ o ( double [ ] [ ] mul , int p ) { double [ ] [ ] s = { { 1 , 0 , 0 , 0 , 0 , 0 , 0 } , { 0 , 1 , 0 , 0 , 0 , 0 , 0 } , { 0 , 0 , 1 , 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 1 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 , 1 , 0 , 0 } , { 0 , 0 , 0 , 0 , 0 , 1 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 1 } } ; while ( p != 1 ) { if ( p % 2 == 1 ) s = matrix_@@ product ( s , mul ) ; mul = matrix_@@ product ( mul , mul ) ; p /= 2 ; } return matrix_@@ product ( mul , s ) ; } static double expected@@ Steps ( int x ) { if ( x == 0 ) return 0 ; if ( x <= 6 ) return 6 ; double [ ] [ ] mul = { { ( double ) 7 / 6 , 1 , 0 , 0 , 0 , 0 , 0 } , { 0 , 0 , 1 , 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 1 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 , 1 , 0 , 0 } , { 0 , 0 , 0 , 0 , 0 , 1 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 1 } , { ( double ) - 1 / 6 , 0 , 0 , 0 , 0 , 0 , 0 } } ; mul = mul_@@ exp@@ o ( mul , x - 6 ) ; return ( mul [ 0 ] [ 0 ] + mul [ 1 ] [ 0 ] + mul [ 2 ] [ 0 ] + mul [ 3 ] [ 0 ] + mul [ 4 ] [ 0 ] + mul [ 5 ] [ 0 ] ) * 6 ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . printf ( " % .@@ 5f " , expected@@ Steps ( n - 1 ) ) ; } }
Find 2 ^ ( 2 ^ A ) % B 8938 | class GF@@ G { static long F ( long A , long B ) { if ( A == 1 ) return ( 4 % B ) ; else { long temp = F ( A - 1 , B ) ; return ( temp * temp ) % B ; } } public static void main ( String args [ ] ) { long A = 25 , B = 50 ; System . out . println ( F ( A , B ) ) ; } }
Find bit@@ on@@ ic point in given bit@@ on@@ ic sequence 8966 | import java . io . * ; class GF@@ G { static int binary@@ Search ( int arr [ ] , int left , int right ) { if ( left <= right ) { int mid = ( left + right ) / 2 ; if ( arr [ mid - 1 ] < arr [ mid ] && arr [ mid ] > arr [ mid + 1 ] ) return mid ; if ( arr [ mid ] < arr [ mid + 1 ] ) return binary@@ Search ( arr , mid + 1 , right ) ; else return binary@@ Search ( arr , left , mid - 1 ) ; } return - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 6 , 7 , 8 , 11 , 9 , 5 , 2 , 1 } ; int n = arr . length ; int index = binary@@ Search ( arr , 1 , n - 2 ) ; if ( index != - 1 ) System . out . println ( arr [ index ] ) ; } }
Check if it is possible to reach the point ( X , Y ) using distances given in an array 8986 | import java . io . * ; class GF@@ G { static int is@@ Possible@@ To@@ Re@@ ach ( int [ ] A , int N , int X , int Y ) { double distance = Math . sqrt ( ( X * X + Y * Y ) ) ; double mx = 0 ; for ( int i = 0 ; i < N ; i ++ ) { mx += ( A [ i ] ) ; } if ( mx < distance ) { System . out . print ( " NO " ) ; return 0 ; } if ( ( mx - distance ) < 0.000001 ) { System . out . print ( " YES " ) ; return 0 ; } for ( int i = 0 ; i < N ; i ++ ) { if ( distance + mx < 2 * A [ i ] ) { System . out . print ( " No " ) ; return 0 ; } } System . out . print ( " Yes " ) ; return 0 ; } public static void main ( String [ ] args ) { int [ ] A = { 2 , 5 } ; int X = 5 , Y = 4 ; int N = A . length ; is@@ Possible@@ To@@ Re@@ ach ( A , N , X , Y ) ; } }
Find the angle between tang@@ ents drawn from a given external point to a Circle 9005 | import java . io . * ; import java . lang . * ; import java . util . * ; class GF@@ G { static double point_@@ distance ( int x1 , int y1 , int x2 , int y2 ) { int p = ( x2 - x1 ) ; int q = ( y2 - y1 ) ; double distance = Math . sqrt ( p * p + q * q ) ; return distance ; } static void tang@@ ent@@ Angle ( int x1 , int y1 , int x2 , int y2 , double radius ) { double distance = point_@@ distance ( x1 , y1 , x2 , y2 ) ; if ( radius / distance > 1 radius / distance < - 1 ) { System . out . println ( - 1 ) ; } double result = 2 * Math . asin ( radius / distance ) * 180 / 3.14@@ 15 ; System . out . println ( String . format ( " % .@@ 4f " , result ) + " ▁ degrees " ) ; } public static void main ( String [ ] args ) { int radius = 4 ; int x1 = 7 , y1 = 12 ; int x2 = 3 , y2 = 4 ; tang@@ ent@@ Angle ( x1 , y1 , x2 , y2 , radius ) ; } }
Find the area of rho@@ m@@ bus from given Angle and Side length 9061 | class GF@@ G { static final double RADI@@ AN = 0.01@@ 745@@ 329@@ 252 ; static double Area@@ _@@ of_@@ R@@ ho@@ m@@ bus ( int a , int theta ) { double area = ( a * a ) * Math . sin ( ( RADI@@ AN * theta ) ) ; return area ; } public static void main ( String [ ] args ) { int a = 4 ; int theta = 60 ; double ans = Area@@ _@@ of_@@ R@@ ho@@ m@@ bus ( a , theta ) ; System . out . printf ( " % .2f " , ans ) ; } }
Length of diagonal of a paralle@@ log@@ ram using adjacent sides and angle between them 9063 | class GF@@ G { static double Length@@ _@@ Diagonal ( int a , int b , double theta ) { double diagonal = Math . sqrt ( ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ) - 2 * a * b * Math . cos ( theta * ( Math . PI / 180 ) ) ) ; return diagonal ; } public static void main ( String [ ] args ) { int a = 3 ; int b = 5 ; double theta = 45 ; double ans = Length@@ _@@ Diagonal ( a , b , theta ) ; System . out . printf ( " % .2f " , ans ) ; } }
Maximum number of tiles required to cover the floor of given size using 2 x1 size tiles 9064 | import java . util . * ; class GF@@ G { static void maximum@@ Tiles ( int n , int m ) { System . out . println ( ( m * n ) / 2 ) ; } public static void main ( String [ ] args ) { int M = 3 ; int N = 4 ; maximum@@ Tiles ( N , M ) ; } }
Minimum Sum of Eu@@ clidean Di@@ stances to all given Points 9067 | class GF@@ G { static double find ( double x , double y , int [ ] [ ] p ) { double mind = 0 ; for ( int i = 0 ; i < p . length ; i ++ ) { double a = p [ i ] [ 0 ] , b = p [ i ] [ 1 ] ; mind += Math . sqrt ( ( x - a ) * ( x - a ) + ( y - b ) * ( y - b ) ) ; } return mind ; } static double getMin@@ Dist@@ Sum ( int [ ] [ ] p ) { double x = 0 , y = 0 ; for ( int i = 0 ; i < p . length ; i ++ ) { x += p [ i ] [ 0 ] ; y += p [ i ] [ 1 ] ; } x = x / p . length ; y = y / p . length ; double mind = find ( x , y , p ) ; return mind ; } public static void main ( String [ ] args ) { int [ ] [ ] vec = { { 0 , 1 } , { 1 , 0 } , { 1 , 2 } , { 2 , 1 } } ; double d = getMin@@ Dist@@ Sum ( vec ) ; System . out . print ( d + "@@ NEW_@@ LINE@@ "@@ )@@ ; } }
Number of quad@@ ri@@ later@@ al formed with N distinct points on circum@@ ference of Circle 9087 | class GF@@ G { static int n@@ Cr ( int n , int r ) { return ( fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ) ; } static int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i < n + 1 ; i ++ ) res = res * i ; return res ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( n@@ Cr ( n , 4 ) ) ; } }
Minimum area of square holding two identical rectangles 9090 | import java . io . * ; class GF@@ G { static int area@@ Square ( int L , int B ) { int large = Math . max ( L , B ) ; int small = Math . min ( L , B ) ; if ( large >= 2 * small ) { return large * large ; } else { return ( 2 * small ) * ( 2 * small ) ; } } public static void main ( String [ ] args ) { int L = 7 ; int B = 4 ; System . out . println ( area@@ Square ( L , B ) ) ; } }
Find if the gl@@ ass will be empty or not when the rate of dr@@ in@@ king is given 9141 | class GF@@ G { static double pie = 3.1415@@ 9265@@ 35@@ 89@@ 7 ; static double find@@ solution ( double d , double h , double m , double n ) { double k = ( 4 * m ) / ( pie * d * d ) ; if ( n > k ) return - 1 ; double ans = ( h / ( k - n ) ) ; return ans ; } public static void main ( String [ ] args ) { double d = 1 , h = 1 , m = 1 , n = 1 ; System . out . printf ( " % .@@ 5f " , find@@ solution ( d , h , m , n ) ) ; } }
Angle sub@@ ten@@ ded by an arc at the centre of a circle 9146 | import java . io . * ; class GF@@ G { static int angle ( int n ) { return 2 * n ; } public static void main ( String [ ] args ) { int n = 30 ; System . out . println ( angle ( n ) ) ; } }
Check whether Quad@@ ri@@ later@@ al is valid or not if angles are given 9158 | class GF@@ G { public static int Valid ( int a , int b , int c , int d ) { if ( a + b + c + d == 360 ) return 1 ; return 0 ; } public static void main ( String [ ] args ) { int a = 80 , b = 70 , c = 100 , d = 110 ; if ( Valid ( a , b , c , d ) == 1 ) System . out . println ( " Valid ▁ quad@@ ri@@ later@@ al " ) ; else System . out . println ( " Invalid ▁ quad@@ ri@@ later@@ al " ) ; } }
Length of the chord the circle if length of the another chord which is equ@@ ally in@@ clin@@ ed through the diameter is given 9182 | import java . io . * ; class GF@@ G { static void l@@ eng@@ chord ( int z ) { System . out . println ( " The ▁ length ▁ is ▁ " + z ) ; } public static void main ( String [ ] args ) { int z = 48 ; l@@ eng@@ chord ( z ) ; } }
Count pairs from an array having equal sum and quotient 10017 | import java . util . * ; class GF@@ G { static int count@@ Pairs ( int a [ ] , int n ) { int count = 0 ; HashMap < Double , Integer > mp = new HashMap < Double , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { double y = a [ i ] ; if ( y != 0 && y != 1 ) { double x = ( ( y * 1.0 ) / ( 1 - y ) ) * y ; if ( mp . containsKey ( x ) ) count += mp . get ( x ) ; } if ( mp . containsKey ( y ) ) { mp . put ( y , mp . get ( y ) + 1 ) ; } else { mp . put ( y , 1 ) ; } } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { - 4 , - 3 , 0 , 2 , 1 } ; int N = arr . length ; System . out . print ( count@@ Pairs ( arr , N ) ) ; } }
Queries to count numbers from a range which does not contain digit K in their decimal or octal representation 10019 | import java . util . * ; public class GF@@ G { static boolean contains ( int num , int K , int Base ) { boolean is@@ There = false ; while ( num > 0 ) { int remainder = num % Base ; if ( remainder == K ) { is@@ There = true ; } num /= Base ; } return is@@ There ; } static void count ( int n , int k , Vector < Vector < Integer > > v ) { int [ ] pref = new int [ 10000@@ 05 ] ; for ( int i = 1 ; i < 1e6 + 5 ; i ++ ) { boolean present = contains ( i , k , 10 ) || contains ( i , k , 8 ) ; if ( present ) { pref [ i ] += pref [ i - 1 ] + 1 ; } } System . out . print ( ( v . get ( 0 ) . get ( 1 ) - v . get ( 0 ) . get ( 0 ) + 1 - ( pref [ v . get ( 0 ) . get ( 1 ) ] - pref [ v . get ( 0 ) . get ( 0 ) - 1 ] ) ) + " ▁ " ) ; System . out . print ( ( v . get ( 1 ) . get ( 1 ) - v . get ( 1 ) . get ( 0 ) - ( pref [ v . get ( 1 ) . get ( 1 ) ] - pref [ v . get ( 1 ) . get ( 0 ) - 1 ] ) ) + " ▁ " ) ; } public static void main ( String [ ] args ) { int K = 7 ; Vector < Vector < Integer > > Q = new Vector < Vector < Integer > > ( ) ; Q . add ( new Vector < Integer > ( ) ) ; Q . get ( 0 ) . add ( 2 ) ; Q . get ( 0 ) . add ( 5 ) ; Q . add ( new Vector < Integer > ( ) ) ; Q . get ( 1 ) . add ( 1 ) ; Q . get ( 1 ) . add ( 15 ) ; int N = Q . size ( ) ; count ( N , K , Q ) ; } }
Count P@@ ron@@ ic numbers from a given range 10045 | import java . util . * ; class GF@@ G { static int pr@@ on@@ ic ( int num ) { int N = ( int ) Math . sqrt ( num ) ; if ( N * ( N + 1 ) <= num ) { return N ; } return N - 1 ; } static int count@@ P@@ ron@@ ic ( int A , int B ) { return pr@@ on@@ ic ( B ) - pr@@ on@@ ic ( A - 1 ) ; } public static void main ( String [ ] args ) { int A = 3 ; int B = 20 ; System . out . print ( count@@ P@@ ron@@ ic ( A , B ) ) ; } }
Minim@@ ize sw@@ aps required to place largest and smallest array elements at first and last array indices 10067 | import java . util . * ; class GF@@ G { static int minimum@@ Moves ( int [ ] a , int n ) { int min_@@ element = Integer . MAX_VALUE ; int max_@@ element = Integer . MIN_VALUE ; int min_@@ ind = - 1 ; int max_@@ ind = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] <= min_@@ element ) { min_@@ element = a [ i ] ; min_@@ ind = i ; } if ( a [ i ] > max_@@ element ) { max_@@ element = a [ i ] ; max_@@ ind = i ; } } if ( max_@@ ind == min_@@ ind ) { return 0 ; } else if ( max_@@ ind > min_@@ ind ) { return max_@@ ind + ( n - min_@@ ind - 2 ) ; } else { return max_@@ ind + n - min_@@ ind - 1 ; } } public static void main ( String [ ] args ) { int arr [ ] = { 35 , 46 , 17 , 23 } ; int N = arr . length ; System . out . print ( minimum@@ Moves ( arr , N ) + "@@ NEW_@@ LINE@@ "@@ )@@ ; } }
Find the index of the smallest element to be removed to make sum of array di@@ visible by K 10069 | import java . util . * ; class GF@@ G { static int find@@ Index ( int arr [ ] , int n , int K ) { int sum = 0 ; int res = - 1 ; int mini = ( int ) 1e@@ 9 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { int temp = sum - arr [ i ] ; if ( temp % K == 0 ) { if ( res == - 1 mini > arr [ i ] ) { res = i + 1 ; mini = arr [ i ] ; } } } return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 14 , 7 , 8 , 2 , 4 } ; int K = 7 ; int N = arr . length ; System . out . print ( find@@ Index ( arr , N , K ) ) ; } }
Count odd and even Bin@@ omial Coefficients of N 10123 | import java . util . * ; class GF@@ G { static int count@@ Set@@ Bits ( int N ) { int count = 0 ; while ( N != 0 ) { N = N & ( N - 1 ) ; count ++ ; } return count ; } public static void main ( String [ ] args ) { int N = 4 ; int bits = count@@ Set@@ Bits ( N ) ; System . out . println ( " Odd ▁ " + " : ▁ " + ( int ) ( Math . pow ( 2 , bits ) ) ) ; System . out . println ( " Even ▁ " + " : ▁ " + ( N + 1 - ( int ) ( Math . pow ( 2 , bits ) ) ) ) ; } }
Program to calculate Variance of first N Natur@@ al Numbers 10127 | class GF@@ G { static double find_@@ Variance ( int n ) { long numerator = n * n - 1 ; double ans = ( numerator * 1.0 ) / 12 ; return ans ; } public static void main ( String [ ] args ) { int N = 5 ; System . out . println ( find_@@ Variance ( N ) ) ; } }
Difference between sum of odd and even frequ@@ ent elements in an Array 10129 | import java . util . * ; import java . io . * ; import java . math . * ; class GF@@ G { static int find@@ Sum ( int arr [ ] , int N ) { Map < Integer , Integer > map = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( ! map . containsKey ( arr [ i ] ) ) map . put ( arr [ i ] , 1 ) ; else map . replace ( arr [ i ] , map . get ( arr [ i ] ) + 1 ) ; } int sum_@@ odd = 0 , sum_@@ even = 0 ; Set < Map . Entry < Integer , Integer > > h@@ map = map . entrySet ( ) ; for ( Map . Entry < Integer , Integer > data : h@@ map ) { int key = data . getKey ( ) ; int val = data . getValue ( ) ; if ( val % 2 != 0 ) sum_@@ odd += ( key ) * ( val ) ; if ( val % 2 == 0 ) sum_@@ even += ( key ) * ( val ) ; } int diff = sum_@@ even - sum_@@ odd ; return diff ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 5 , 5 , 2 , 4 , 3 , 3 } ; int N = arr . length ; System . out . println ( find@@ Sum ( arr , N ) ) ; } }
Sum of the first N terms of XOR Fi@@ bon@@ ac@@ ci series 10133 | import java . util . * ; class GF@@ G { static void find@@ Sum ( int a , int b , int n ) { if ( n == 1 ) { System . out . println ( a ) ; return ; } int s = a + b ; for ( int i = 0 ; i < n - 2 ; i ++ ) { int x = a ^ b ; s += x ; a = b ; b = x ; } System . out . println ( s ) ; } public static void main ( String [ ] args ) { int a = 2 , b = 5 , N = 8 ; find@@ Sum ( a , b , N ) ; } }
Minimum value to be added to maxim@@ ize Bit@@ wise XOR of the given array 10138 | import java . util . * ; import java . io . * ; import java . lang . * ; class GF@@ G { static int ones@@ Comp@@ lement ( int n , int max@@ Element ) { int bits = ( int ) Math . floor ( ( Math . log ( max@@ Element ) / Math . log ( 2 ) ) ) + 1 ; return ( ( 1 << bits ) - 1 ) ^ n ; } static int find@@ Number ( int arr [ ] , int n ) { int res = 0 ; int max@@ Element = 0 ; for ( int i = 0 ; i < n ; i ++ ) { res = res ^ arr [ i ] ; if ( max@@ Element < arr [ i ] ) max@@ Element = arr [ i ] ; } res = ones@@ Comp@@ lement ( res , max@@ Element ) ; return ( res ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int N = arr . length ; System . out . print ( find@@ Number ( arr , N ) ) ; } }
Lar@@ gest divisor of a number not di@@ visible by another given number 10155 | import java . util . * ; class GF@@ G { static void find@@ The@@ Gre@@ atest@@ X ( int P , int Q ) { HashMap < Integer , Integer > di@@ visi@@ ors = new HashMap < > ( ) ; for ( int i = 2 ; i * i <= Q ; i ++ ) { while ( Q % i == 0 && Q > 1 ) { Q /= i ; if ( di@@ visi@@ ors . containsKey ( i ) ) { di@@ visi@@ ors . put ( i , di@@ visi@@ ors . get ( i ) + 1 ) ; } else { di@@ visi@@ ors . put ( i , 1 ) ; } } } if ( Q > 1 ) if ( di@@ visi@@ ors . containsKey ( Q ) ) { di@@ visi@@ ors . put ( Q , di@@ visi@@ ors . get ( Q ) + 1 ) ; } else { di@@ visi@@ ors . put ( Q , 1 ) ; } int ans = 0 ; for ( Map . Entry < Integer , Integer > i : di@@ visi@@ ors . entrySet ( ) ) { int frequency = i . getValue ( ) ; int temp = P ; int cur = 0 ; while ( temp % i . getKey ( ) == 0 ) { temp /= i . getKey ( ) ; cur ++ ; } if ( cur < frequency ) { ans = P ; break ; } temp = P ; for ( int j = cur ; j >= frequency ; j -- ) { temp /= i . getKey ( ) ; } ans = Math . max ( temp , ans ) ; } System . out . print ( ans ) ; } public static void main ( String [ ] args ) { int P = 10 , Q = 4 ; find@@ The@@ Gre@@ atest@@ X ( P , Q ) ; } }
Count set bits in Bit@@ wise XOR of all adjacent elements upto N 10165 | import java . io . * ; import java . util . * ; class GF@@ G { static int count@@ X@@ OR@@ Set@@ Bits@@ Ad@@ j@@ Elem@@ Range@@ 1_@@ N ( int N ) { int total_@@ set_@@ bits = 0 ; int bit_@@ Position = 1 ; while ( N != 0 ) { total_@@ set_@@ bits += ( ( N + 1 ) / 2 * bit_@@ Position ) ; N -= ( N + 1 ) / 2 ; bit_@@ Position ++ ; } return total_@@ set_@@ bits ; } public static void main ( String [ ] args ) { int N = 4 ; System . out . println ( count@@ X@@ OR@@ Set@@ Bits@@ Ad@@ j@@ Elem@@ Range@@ 1_@@ N ( N ) ) ; } }
Maxim@@ ize Bit@@ wise AND of first element with complement of remaining elements for any permutation of given Array 10212 | import java . util . * ; class GF@@ G { static final int size_@@ int = 32 ; static int function@@ Max ( int arr [ ] , int n ) { Vector < Integer > [ ] set@@ Bit = new Vector [ 32 + 1 ] ; for ( int i = 0 ; i < set@@ Bit . length ; i ++ ) set@@ Bit [ i ] = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < size_@@ int ; j ++ ) { if ( ( arr [ i ] & ( 1 << j ) ) > 0 ) set@@ Bit [ j ] . add ( i ) ; } } for ( int i = size_@@ int ; i >= 0 ; i -- ) { if ( set@@ Bit [ i ] . size ( ) == 1 ) { swap ( arr , 0 , set@@ Bit [ i ] . get ( 0 ) ) ; break ; } } int max@@ And = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { max@@ And = max@@ And & ( ~ arr [ i ] ) ; } return max@@ And ; } static int [ ] swap ( int [ ] arr , int i , int j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; return arr ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 4 , 8 , 16 } ; int n = arr . length ; System . out . print ( function@@ Max ( arr , n ) ) ; } }
Highe@@ st power of 2 that divi@@ des the LC@@ M of first N Natur@@ al numbers . 10219 | class GF@@ G { static int highest@@ Power ( int n ) { return ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ; } public static void main ( String [ ] args ) { int n = 15 ; System . out . println ( highest@@ Power ( n ) ) ; } }
Check whether a number can be represented as difference of two consecutive cub@@ es 10230 | import java . util . * ; class GF@@ G { static void print ( int N ) { for ( int i = 0 ; i < 100000 ; i ++ ) { if ( Math . pow ( i + 1 , 3 ) - Math . pow ( i , 3 ) == N ) { int j = i + 1 ; System . out . println ( i + " ▁ " + j ) ; return ; } } } static boolean is@@ Per@@ fec@@ t@@ Square ( double x ) { double sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; } static boolean diff@@ Cube ( int N ) { return is@@ Per@@ fec@@ t@@ Square ( 12 * N - 3 ) ; } public static void main ( String [ ] args ) { int N = 19 ; if ( diff@@ Cube ( N ) ) { System . out . println ( " Yes " ) ; print ( N ) ; } else { System . out . println ( " No " ) ; } } }
Is it possible to reach N and M from 1 and 0 respectively as per given condition 10249 | class GF@@ G { static boolean is_@@ possible ( int x , int y ) { if ( x < 2 && y != 0 ) return false ; y = y - x + 1 ; if ( y % 2 == 0 && y >= 0 ) return true ; else return false ; } public static void main ( String [ ] args ) { int x = 5 , y = 2 ; if ( is_@@ possible ( x , y ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
Construct a Maximum Binary Tree from two given Binary Trees 10253 | class Node { int data ; Node left , right ; public Node ( int data , Node left , Node right ) { this . data = data ; this . left = left ; this . right = right ; } static Node newNode ( int data ) { return new Node ( data , null , null ) ; } static void in@@ order ( Node node ) { if ( node == null ) return ; in@@ order ( node . left ) ; System . out . printf ( " % d ▁ " , node . data ) ; in@@ order ( node . right ) ; } static Node Maximum@@ Binary@@ Tree ( Node t1 , Node t2 ) { if ( t1 == null ) return t2 ; if ( t2 == null ) return t1 ; t1 . data = Math . max ( t1 . data , t2 . data ) ; t1 . left = Maximum@@ Binary@@ Tree ( t1 . left , t2 . left ) ; t1 . right = Maximum@@ Binary@@ Tree ( t1 . right , t2 . right ) ; return t1 ; } public static void main ( String [ ] args ) { Node roo@@ t1 = newNode ( 3 ) ; roo@@ t1 . left = newNode ( 2 ) ; roo@@ t1 . right = newNode ( 6 ) ; roo@@ t1 . left . left = newNode ( 20 ) ; Node root@@ 2 = newNode ( 5 ) ; root@@ 2 . left = newNode ( 1 ) ; root@@ 2 . right = newNode ( 8 ) ; root@@ 2 . left . right = newNode ( 2 ) ; root@@ 2 . right . right = newNode ( 8 ) ; Node root@@ 3 = Maximum@@ Binary@@ Tree ( roo@@ t1 , root@@ 2 ) ; in@@ order ( root@@ 3 ) ; } }
Fast Expon@@ ention using Bit Manip@@ ulation 10267 | class GF@@ G { static int power@@ Optim@@ ised ( int a , int n ) { int ans = 1 ; while ( n > 0 ) { int last_@@ bit = ( n & 1 ) ; if ( last_@@ bit > 0 ) { ans = ans * a ; } a = a * a ; n = n >> 1 ; } return ans ; } public static void main ( String [ ] args ) { int a = 3 , n = 5 ; System . out . print ( power@@ Optim@@ ised ( a , n ) ) ; } }
Maxim@@ ize count of distinct elements possible in an Array from the given operation 10285 | import java . util . * ; class GF@@ G { static int gcd ( int x , int y ) { if ( x == 0 ) return y ; return gcd ( y % x , x ) ; } static int find@@ Distin@@ ct ( int arr [ ] , int n ) { int maximum = Arrays . stream ( arr ) . max ( ) . getAs@@ Int ( ) ; if ( n == 1 ) return 1 ; if ( n == 2 ) { return ( maximum / gcd ( arr [ 0 ] , arr [ 1 ] ) ) ; } int k = gcd ( arr [ 0 ] , arr [ 1 ] ) ; for ( int i = 2 ; i < n ; i ++ ) { k = gcd ( k , arr [ i ] ) ; } return ( maximum / k ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 5 } ; int n = arr . length ; System . out . println ( find@@ Distin@@ ct ( arr , n ) ) ; } }
Check whether count of odd and even factors of a number are equal 10303 | class GF@@ G { static void is@@ Equal@@ Factors ( int N ) { int ev@@ _count = 0 , o@@ d_@@ count = 0 ; for ( int i = 1 ; i <= Math . sqrt ( N ) + 1 ; i ++ ) { if ( N % i == 0 ) { if ( i == N / i ) { if ( i % 2 == 0 ) ev@@ _count += 1 ; else o@@ d_@@ count += 1 ; } else { if ( i % 2 == 0 ) ev@@ _count += 1 ; else o@@ d_@@ count += 1 ; if ( ( N / i ) % 2 == 0 ) ev@@ _count += 1 ; else o@@ d_@@ count += 1 ; } } } if ( ev@@ _count == o@@ d_@@ count ) System . out . print ( " YES " + "@@ NEW_@@ LINE@@ "@@ )@@ ; else System . out . print ( " NO " + "@@ NEW_@@ LINE@@ "@@ )@@ ; } public static void main ( String [ ] args ) { int N = 10 ; is@@ Equal@@ Factors ( N ) ; } }
Maximum OR value of a pair in an Array | Set 2 10320 | import java . util . Arrays ; class GF@@ G { static int max@@ OR ( int [ ] arr , int n ) { int max_value = Arrays . stream ( arr ) . max ( ) . getAs@@ Int ( ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans = Math . max ( ans , ( max_value arr [ i ] ) ) ; } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = new int [ ] { 3 , 6 , 8 , 16 } ; int n = 4 ; System . out . print ( max@@ OR ( arr , n ) ) ; } }
Primitive Ab@@ und@@ ant Number 10372 | class GF@@ G { static int getS@@ um ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) sum = sum + i ; else { sum = sum + i ; sum = sum + ( n / i ) ; } } } return sum ; } static boolean check@@ Ab@@ und@@ ant ( int n ) { return ( getS@@ um ( n ) - n > n ) ; } static boolean is@@ De@@ fici@@ ent ( int n ) { return ( getS@@ um ( n ) < ( 2 * n ) ) ; } static boolean check@@ Primitive@@ Ab@@ und@@ ant ( int num ) { if ( ! check@@ Ab@@ und@@ ant ( num ) ) { return false ; } for ( int i = 2 ; i <= Math . sqrt ( num ) ; i ++ ) { if ( num % i == 0 && i != num ) { if ( i * i == num ) { if ( ! is@@ De@@ fici@@ ent ( i ) ) { return false ; } } else if ( ! is@@ De@@ fici@@ ent ( i ) || ! is@@ De@@ fici@@ ent ( num / i ) ) { return false ; } } } return true ; } public static void main ( String [ ] args ) { int n = 20 ; if ( check@@ Primitive@@ Ab@@ und@@ ant ( n ) ) { System . out . print ( " Yes " ) ; } else { System . out . print ( " No " ) ; } } }
Can@@ ada Numbers 10375 | import java . io . * ; class GF@@ G { static int div@@ Sum ( int num ) { int result = 0 ; for ( int i = 1 ; i <= Math . sqrt ( num ) ; i ++ ) { if ( num % i == 0 ) { if ( i == ( num / i ) ) result += i ; else result += ( i + num / i ) ; } } return ( result - 1 - num ) ; } static int getS@@ um ( int n ) { int sum = 0 ; while ( n != 0 ) { int r = n % 10 ; sum = sum + r * r ; n = n / 10 ; } return sum ; } static boolean is@@ Can@@ ada ( int n ) { return div@@ Sum ( n ) == getS@@ um ( n ) ; } public static void main ( String [ ] args ) { int n = 125 ; if ( is@@ Can@@ ada ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
Count of elements not di@@ visible by any other elements of Array 10399 | import java . util . * ; class GF@@ G { static int count@@ E@@ le ( int a [ ] , int n ) { int len = 0 ; HashMap < Integer , Integer > h@@ map = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { len = Math . max ( len , a [ i ] ) ; if ( h@@ map . containsKey ( a [ i ] ) ) { h@@ map . put ( a [ i ] , h@@ map . get ( a [ i ] ) + 1 ) ; } else { h@@ map . put ( a [ i ] , 1 ) ; } } boolean [ ] v = new boolean [ len + 1 ] ; for ( int i = 0 ; i <= len ; i ++ ) { v [ i ] = true ; } for ( int i = 0 ; i < n ; i ++ ) { if ( v [ a [ i ] ] == false ) continue ; for ( int j = 2 * a [ i ] ; j <= len ; j += a [ i ] ) { v [ j ] = false ; } } int count = 0 ; for ( int i = 1 ; i <= len ; i ++ ) { if ( v [ i ] == true && h@@ map . containsKey ( i ) && h@@ map . get ( i ) == 1 && h@@ map . get ( i ) == 1 ) { count += 1 ; } } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 86 , 45 , 18 , 4 , 8 , 28 , 19 , 33 , 2 } ; int n = arr . length ; System . out . print ( count@@ E@@ le ( arr , n ) ) ; } }
Maxim@@ ize sum of absolute difference between adjacent elements in Array with sum K 10406 | import java . util . * ; class GF@@ G { static int max@@ Adjac@@ ent@@ Difference ( int N , int K ) { if ( N == 1 ) { return 0 ; } if ( N == 2 ) { return K ; } return 2 * K ; } public static void main ( String [ ] args ) { int N = 6 ; int K = 11 ; System . out . print ( max@@ Adjac@@ ent@@ Difference ( N , K ) ) ; } }
Check if row 10413 | import java . util . * ; class GF@@ G { static boolean is@@ Pal ( int a [ ] [ ] , int n , int m ) { for ( int i = 0 ; i < n / 2 ; i ++ ) { for ( int j = 0 ; j < m - 1 ; j ++ ) { if ( a [ i ] [ j ] != a [ n - 1 - i ] [ m - 1 - j ] ) return false ; } } return true ; } public static void main ( String [ ] args ) { int n = 3 , m = 3 ; int a [ ] [ ] = { { 1 , 2 , 3 } , { 4 , 5 , 4 } , { 3 , 2 , 1 } } ; if ( is@@ Pal ( a , n , m ) ) { System . out . print ( " YES " + "@@ NEW_@@ LINE@@ "@@ )@@ ; } else { System . out . print ( " NO " + "@@ NEW_@@ LINE@@ "@@ )@@ ; } } }
Un@@ touch@@ able Number 10440 | class GF@@ G { static int div@@ Sum ( int num ) { int result = 0 ; for ( int i = 2 ; i <= Math . sqrt ( num ) ; i ++ ) { if ( num % i == 0 ) { if ( i == ( num / i ) ) result += i ; else result += ( i + num / i ) ; } } return ( result + 1 ) ; } static boolean isUn@@ touch@@ able ( int n ) { for ( int i = 1 ; i <= 2 * n ; i ++ ) { if ( div@@ Sum ( i ) == n ) return false ; } return true ; } public static void main ( String [ ] args ) { int n = 52 ; if ( isUn@@ touch@@ able ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
120 10477 | class GF@@ G { static int gon@@ Num@@ 120 ( int n ) { return ( 118 * n * n - 116 * n ) / 2 ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . print ( gon@@ Num@@ 120 ( n ) ) ; } }
Construct an Array such that cube sum of all element is a perfect square 10546 | import java . util . * ; class GF@@ G { static void construct@@ Array ( int N ) { int arr [ ] = new int [ N ] ; for ( int i = 1 ; i <= N ; i ++ ) { arr [ i - 1 ] = i ; } for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( arr [ i ] + " , ▁ " ) ; } } public static void main ( String [ ] args ) { int N = 6 ; construct@@ Array ( N ) ; } }
Pair of integers having difference of their fi@@ fth power as X 10563 | class GF@@ G { static void find@@ Pair ( int x ) { int lim = 120 ; for ( int i = - lim ; i <= lim ; i ++ ) { for ( int j = - lim ; j <= lim ; j ++ ) { if ( Math . pow ( i , 5 ) - Math . pow ( j , 5 ) == x ) { System . out . print ( i + " ▁ " + j + "@@ NEW_@@ LINE@@ "@@ )@@ ; return ; } } } System . out . print ( " - 1" ) ; } public static void main ( String [ ] args ) { int X = 33 ; find@@ Pair ( X ) ; } }
Check if a number is Full Fi@@ bon@@ ac@@ ci or not 10578 | import java . util . * ; class GF@@ G { static boolean is@@ Per@@ fec@@ t@@ Square ( int x ) { int s = ( int ) Math . sqrt ( x ) ; return ( s * s == x ) ; } static boolean is@@ Fi@@ bon@@ ac@@ ci ( int n ) { return is@@ Per@@ fec@@ t@@ Square ( 5 * n * n + 4 ) || is@@ Per@@ fec@@ t@@ Square ( 5 * n * n - 4 ) ; } static boolean check@@ Digits ( int n ) { while ( n != 0 ) { int dig = n % 10 ; if ( dig == 4 && dig == 6 && dig == 7 && dig == 9 ) return false ; n /= 10 ; } return true ; } static boolean is@@ Full@@ fi@@ bon@@ ac@@ ci ( int n ) { return ( check@@ Digits ( n ) && is@@ Fi@@ bon@@ ac@@ ci ( n ) ) ; } public static void main ( String [ ] args ) { int n = 13 ; if ( is@@ Full@@ fi@@ bon@@ ac@@ ci ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
Length of the longest altern@@ ating even odd sub@@ array 10601 | import java . util . * ; class GF@@ G { static int lon@@ gest@@ Even@@ O@@ dd@@ Sub@@ array ( int a [ ] , int n ) { int longest = 1 ; int cnt = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ( a [ i ] + a [ i + 1 ] ) % 2 == 1 ) { cnt ++ ; } else { longest = Math . max ( longest , cnt ) ; cnt = 1 ; } } if ( longest == 1 ) return 0 ; return Math . max ( cnt , longest ) ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 3 , 4 , 5 , 7 , 8 } ; int n = a . length ; System . out . println ( lon@@ gest@@ Even@@ O@@ dd@@ Sub@@ array ( a , n ) ) ; } }
S@@ malle@@ st number to make Array sum at most K by divid@@ ing each element 10669 | import java . util . * ; class GF@@ G { static int find@@ Min@@ Di@@ visor ( int arr [ ] , int n , int limit ) { int low = 0 , high = 1000000000 ; while ( low < high ) { int mid = ( low + high ) / 2 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += Math . ceil ( ( double ) arr [ i ] / ( double ) mid ) ; } if ( sum <= limit ) high = mid ; else low = mid + 1 ; } return low ; } public static void main ( String args [ ] ) { int arr [ ] = { 2 , 3 , 4 , 9 } ; int N = arr . length ; int K = 6 ; System . out . println ( find@@ Min@@ Di@@ visor ( arr , N , K ) ) ; } }
Find the maximum sum pair in an Array with even parity 10679 | import java . util . * ; class GF@@ G { static int sz = ( int ) 1e@@ 3 ; static boolean is@@ Even@@ Par@@ ity ( int x ) { int parity = 0 ; while ( x != 0 ) { if ( x % 2 == 1 ) parity ++ ; x = x >> 1 ; } if ( parity % 2 == 0 ) return true ; else return false ; } static void print@@ Array ( int arr [ ] , int len ) { for ( int i = 0 ; i < len ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } static void find@@ Pair@@ Even@@ Par@@ ity ( int arr [ ] , int len ) { int first@@ Maximum = Integer . MIN_VALUE ; int second@@ Maximum = Integer . MIN_VALUE ; for ( int i = 0 ; i < len ; i ++ ) { if ( is@@ Even@@ Par@@ ity ( arr [ i ] ) ) { if ( arr [ i ] >= first@@ Maximum ) { second@@ Maximum = first@@ Maximum ; first@@ Maximum = arr [ i ] ; } else if ( arr [ i ] >= second@@ Maximum ) { second@@ Maximum = arr [ i ] ; } } } System . out . print ( first@@ Maximum + " ▁ " + second@@ Maximum ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 18 , 15 , 8 , 9 , 14 } ; int len = arr . length ; find@@ Pair@@ Even@@ Par@@ ity ( arr , len ) ; } }
Program to check if N is a Hexag@@ onal Number or not 10680 | import java . util . * ; class GF@@ G { static boolean is@@ Hexag@@ onal ( int N ) { float val = 8 * N + 1 ; float x = 1 + ( float ) Math . sqrt ( val ) ; float n = ( x ) / 4 ; if ( ( n - ( int ) n ) == 0 ) return true ; else return false ; } public static void main ( String [ ] args ) { int N = 14 ; if ( is@@ Hexag@@ onal ( N ) == true ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
Count all sub@@ arrays whose sum can be split as difference of squares of two Inte@@ gers 10685 | import java . io . * ; import java . lang . * ; import java . util . * ; class GF@@ G { static int Solve ( int arr [ ] , int n ) { int temp = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { temp = 0 ; for ( int j = i ; j < n ; j ++ ) { temp += arr [ j ] ; if ( ( temp + 2 ) % 4 != 0 ) count ++ ; } } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; int N = arr . length ; System . out . println ( Solve ( arr , N ) ) ; } }
Check whether a number can be represented by the product of two squares 10688 | class GF@@ G { static boolean prod@@ Square ( int n ) { for ( long i = 2 ; i * i <= n ; i ++ ) for ( long j = 2 ; j <= n ; j ++ ) if ( i * i * j * j == n ) return true ; return false ; } public static void main ( String [ ] args ) { int n = 25 ; if ( prod@@ Square ( n ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
Find N distinct integers with zero sum 10701 | class GF@@ G { static void find@@ Numbers ( int N ) { for ( int i = 1 ; i <= N / 2 ; i ++ ) { System . out . print ( i + " , ▁ " + - i + " , ▁ " ) ; } if ( N % 2 == 1 ) System . out . print ( 0 ) ; } public static void main ( String [ ] args ) { int N = 10 ; find@@ Numbers ( N ) ; } }
Count the numbers which can convert N to 1 using given operation 10707 | import java . util . * ; class GF@@ G { static int count@@ Values ( int N ) { Vector < Integer > div = new Vector < > ( ) ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { div . add ( i ) ; if ( N != i * i ) { div . add ( N / i ) ; } } } int answer = 0 ; for ( int i = 1 ; i * i <= N - 1 ; i ++ ) { if ( ( N - 1 ) % i == 0 ) { if ( i * i == N - 1 ) answer ++ ; else answer += 2 ; } } for ( int d : div ) { int K = N ; while ( K % d == 0 ) K /= d ; if ( ( K - 1 ) % d == 0 ) answer ++ ; } return answer ; } public static void main ( String [ ] args ) { int N = 6 ; System . out . print ( count@@ Values ( N ) ) ; } }
Divide array in two maximum equal length arrays of similar and dis@@ similar elements 10753 | import java . io . * ; import java . lang . * ; import java . util . * ; class GF@@ G { static void Solve ( int arr [ ] , int size , int n ) { int [ ] v = new int [ n + 1 ] ; for ( int i = 0 ; i < size ; i ++ ) v [ arr [ i ] ] ++ ; int max@@ 1 = - 1 , mx = - 1 ; for ( int i = 0 ; i < v . length ; i ++ ) { if ( v [ i ] > mx ) { mx = v [ i ] ; max@@ 1 = i ; } } int cnt = 0 ; for ( int i : v ) { if ( i == 0 ) ++ cnt ; } int diff@@ 1 = n + 1 - cnt ; int max_size = Math . max ( Math . min ( v [ max@@ 1 ] - 1 , diff@@ 1 ) , Math . min ( v [ max@@ 1 ] , diff@@ 1 - 1 ) ) ; System . out . println ( " Maximum ▁ size ▁ is : ▁ " + max_size ) ; System . out . println ( " First ▁ Array ▁ is " ) ; for ( int i = 0 ; i < max_size ; i ++ ) { System . out . print ( max@@ 1 + " ▁ " ) ; v [ max@@ 1 ] -= 1 ; } System . out . println ( ) ; System . out . println ( " The ▁ Second ▁ Array ▁ Is ▁ : " ) ; for ( int i = 0 ; i < ( n + 1 ) ; i ++ ) { if ( v [ i ] > 0 ) { System . out . print ( i + " ▁ " ) ; max_size -- ; } if ( max_size < 1 ) break ; } System . out . println ( ) ; } public static void main ( String [ ] args ) { int n = 7 ; int arr [ ] = new int [ ] { 1 , 2 , 1 , 5 , 1 , 6 , 7 , 2 } ; int size = arr . length ; Solve ( arr , size , n ) ; } }
Unique element in an array where all elements occur K times except one | Set 2 10755 | import java . util . Arrays ; class Main { public static int find@@ unique ( int a [ ] , int k ) { int res = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { int p = 0 ; for ( int j = 0 ; j < a . length ; j ++ ) { p += ( Math . abs ( a [ j ] ) & ( 1 << i ) ) != 0 ? 1 : 0 ; } p %= k ; res += Math . pow ( 2 , i ) * p ; } int c = 0 ; for ( int x = 0 ; x < a . length ; x ++ ) if ( a [ x ] == res ) { c = 1 ; break ; } return c == 1 ? res : - res ; } public static void main ( String [ ] args ) { int a [ ] = { 12 , 12 , 2 , 2 , 3 } ; int k = 2 ; System . out . println ( find@@ unique ( a , k ) ) ; } }
Minimum volume of con@@ e that can be circum@@ scri@@ bed about a sphere of radius R 10771 | import java . util . * ; class GF@@ G { static double Volum@@ e_@@ of_@@ con@@ e ( double R ) { double V = ( double ) ( ( 1 / 3.0 ) * ( 3.14 ) * ( 2 * ( R * R ) ) * ( 4 * R ) ) ; return V ; } public static void main ( String [ ] args ) { double R = 10.0 ; System . out . print ( Volum@@ e_@@ of_@@ con@@ e ( R ) ) ; } }
Program to find Surface Area and Volume of Oct@@ ag@@ onal Pri@@ sm 10776 | public class GF@@ G { static void find_@@ volume ( double area , double h ) { double Volume = ( area * h ) ; System . out . println ( " Volume : ▁ " + Volume ) ; } static void find_@@ Sur@@ face_@@ area ( double area , double a , double h ) { double Sur@@ face_@@ area = ( 2 * area ) + ( 8 * a * h ) ; System . out . println ( " Surface ▁ area : ▁ " + Sur@@ face_@@ area ) ; } public static void main ( String [ ] args ) { double h = 1 ; double a = 6 ; double d = 2 ; double area = 2 * a * d ; find_@@ Sur@@ face_@@ area ( area , a , h ) ; find_@@ volume ( area , h ) ; } }
Elements of Array which can be expressed as power of some integer to given exponent K 10784 | class GF@@ G { static double n@@ th@@ Root ( long A , long N ) { double x@@ Pre = 7 ; double eps = 1e-3 ; double del@@ X = Integer . MAX_VALUE ; double x@@ K = 0 ; while ( del@@ X > eps ) { x@@ K = ( ( N - 1.0 ) * x@@ Pre + ( double ) A / Math . pow ( x@@ Pre , N - 1 ) ) / ( double ) N ; del@@ X = Math . abs ( x@@ K - x@@ Pre ) ; x@@ Pre = x@@ K ; } return x@@ K ; } static boolean check ( long no , int k ) { double k@@ th_@@ root = n@@ th@@ Root ( no , k ) ; long num = ( long ) k@@ th_@@ root ; if ( Math . abs ( num - k@@ th_@@ root ) < 1e-4 ) return true ; return false ; } static void print@@ Exp@@ o ( long arr [ ] , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { if ( check ( arr [ i ] , k ) ) System . out . print ( arr [ i ] + " ▁ " ) ; } } public static void main ( String [ ] args ) { int K = 6 ; long arr [ ] = { 46@@ 65@@ 6 , 64 , 256 , 7@@ 29 , 16 , 1000 } ; int n = arr . length ; print@@ Exp@@ o ( arr , n , K ) ; } }
Count of sub@@ sequences whose product is a difference of square of two integers 10786 | class GF@@ G { static int Cnt@@ cont@@ Sub@@ s ( int a [ ] , int n ) { int c = 0 , d = 0 , i , sum = 1 , j ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 != 0 a [ i ] % 4 == 0 ) d ++ ; sum = a [ i ] ; for ( j = i + 1 ; j < n ; j ++ ) { sum = sum * a [ j ] ; if ( sum % 2 != 0 sum % 4 == 0 ) c ++ ; } sum = 1 ; } return c + d ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 4 , 2 , 9 , 8 } ; int n = arr . length ; System . out . print ( Cnt@@ cont@@ Sub@@ s ( arr , n ) ) ; } }
Sum of all Perf@@ ect numbers ly@@ ing in the range [ L , R ] 10793 | class GF@@ G { static int pref [ ] = new int [ 10000 ] ; static int is@@ Perf@@ ect ( int n ) { int sum = 1 ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i * i != n ) sum = sum + i + n / i ; else sum = sum + i ; } } if ( sum == n && n != 1 ) return n ; return 0 ; } static void pre@@ computation ( ) { for ( int i = 1 ; i < 10000 ; ++ i ) { pref [ i ] = pref [ i - 1 ] + is@@ Perf@@ ect ( i ) ; } } public static void main ( String [ ] args ) { int L = 6 , R = 28 ; pre@@ computation ( ) ; System . out . println ( pref [ R ] - pref [ L - 1 ] ) ; } }
Count of numbers upto M with GC@@ D equals to K when paired with M 10797 | import java . util . * ; class GF@@ G { static int Euler@@ To@@ ti@@ ent@@ Function ( int limit ) { int copy = limit ; Vector < Integer > primes = new Vector < Integer > ( ) ; for ( int i = 2 ; i * i <= limit ; i ++ ) { if ( limit % i == 0 ) { while ( limit % i == 0 ) { limit /= i ; } primes . add ( i ) ; } } if ( limit >= 2 ) { primes . add ( limit ) ; } int ans = copy ; for ( int it : primes ) { ans = ( ans / it ) * ( it - 1 ) ; } return ans ; } static void Count@@ GC@@ D ( int m , int k ) { if ( m % k != 0 ) { System . out . print ( 0 + "@@ NEW_@@ LINE@@ "@@ )@@ ; return ; } if ( m == k ) { System . out . print ( 2 + "@@ NEW_@@ LINE@@ "@@ )@@ ; return ; } int limit = m / k ; int ans = Euler@@ To@@ ti@@ ent@@ Function ( limit ) ; System . out . print ( ans + "@@ NEW_@@ LINE@@ "@@ )@@ ; } public static void main ( String [ ] args ) { int M = 9 ; int K = 1 ; Count@@ GC@@ D ( M , K ) ; } }
Sum of numbers in the K@@ th level of a Fi@@ bon@@ ac@@ ci triangle 10800 | import java . util . * ; class GF@@ G { static int fi@@ b ( int n ) { double phi = ( 1 + Math . sqrt ( 5 ) ) / 2 ; return ( int ) Math . round ( Math . pow ( phi , n ) / Math . sqrt ( 5 ) ) ; } static int calculate@@ Sum ( int l , int r ) { int sum = fi@@ b ( r + 2 ) - fi@@ b ( l + 1 ) ; return sum ; } static int sum@@ Fi@@ bon@@ ac@@ ci ( int k ) { int l = ( k * ( k - 1 ) ) / 2 ; int r = l + k ; int sum = calculate@@ Sum ( l , r - 1 ) ; return sum ; } public static void main ( String args [ ] ) { int k = 3 ; System . out . println ( sum@@ Fi@@ bon@@ ac@@ ci ( k ) ) ; } }
Print the sequence of size N in which every term is sum of previous K terms 10802 | class Sum { void sum@@ Of@@ Prev@@ K ( int N , int K ) { int arr [ ] = new int [ N ] ; arr [ 0 ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) { int j = i - 1 , count = 0 , sum = 0 ; while ( j >= 0 && count < K ) { sum += arr [ j ] ; j -- ; count ++ ; } arr [ i ] = sum ; } for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } public static void main ( String args [ ] ) { Sum s = new Sum ( ) ; int N = 10 , K = 4 ; s . sum@@ Of@@ Prev@@ K ( N , K ) ; } }
Find the real and imaginary part of a Complex number 10810 | class GF@@ G { static void find@@ Real@@ And@@ Ima@@ g ( String s ) { int l = s . length ( ) ; int i ; if ( s . indexOf ( ' + ' ) != - 1 ) { i = s . indexOf ( ' + ' ) ; } else { i = s . indexOf ( ' - ' ) ; } String real = s . substring ( 0 , i ) ; String imaginary = s . substring ( i + 1 , l - 1 ) ; System . out . println ( " Real ▁ part : ▁ " + real ) ; System . out . println ( " Ima@@ gin@@ ary ▁ part : ▁ " + imaginary ) ; } public static void main ( String [ ] args ) { String s = "3 + 4i " ; find@@ Real@@ And@@ Ima@@ g ( s ) ; } }
Count pairs in array such that one element is reverse of another 10823 | class Ge@@ e@@ ks { static int reverse ( int num ) { int rev_@@ num = 0 ; while ( num > 0 ) { rev_@@ num = rev_@@ num * 10 + num % 10 ; num = num / 10 ; } return rev_@@ num ; } static int count@@ Reverse ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( reverse ( arr [ i ] ) == arr [ j ] ) { res ++ ; } return res ; } public static void main ( String [ ] args ) { int a [ ] = { 16 , 61 , 12 , 21 , 25 } ; int n = a . length ; System . out . print ( count@@ Reverse ( a , n ) ) ; } }
Find the Sum of the series 1 / 2 10836 | class GF@@ G { static void print@@ Series@@ Sum ( int N ) { double sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 1 ) { sum += ( double ) i / ( i + 1 ) ; } else { sum -= ( double ) i / ( i + 1 ) ; } } System . out . print ( sum + "@@ NEW_@@ LINE@@ "@@ )@@ ; } public static void main ( String [ ] args ) { int N = 10 ; print@@ Series@@ Sum ( N ) ; } }
Program to add two integers of given base 10840 | class GF@@ G { static String sum@@ Base@@ B ( String a , String b , int base ) { int len@@ _a , len_@@ b ; len@@ _a = a . length ( ) ; len_@@ b = b . length ( ) ; String sum , s ; s = " " ; sum = " " ; int diff ; diff = Math . abs ( len@@ _a - len_@@ b ) ; for ( int i = 1 ; i <= diff ; i ++ ) s += "0" ; if ( len@@ _a < len_@@ b ) a = s + a ; else b = s + b ; int curr , carry = 0 ; for ( int i = Math . max ( len@@ _a , len_@@ b ) - 1 ; i > - 1 ; i -- ) { curr = carry + ( a . charAt ( i ) - '0' ) + ( b . charAt ( i ) - '0' ) ; carry = curr / base ; curr = curr % base ; sum = ( char ) ( curr + '0' ) + sum ; } if ( carry > 0 ) sum = ( char ) ( carry + '0' ) + sum ; return sum ; } public static void main ( String [ ] args ) { String a , b , sum ; int base ; a = "123" ; b = "@@ 234@@ " ; base = 6 ; sum = sum@@ Base@@ B ( a , b , base ) ; System . out . println ( sum ) ; } }
Count of Fi@@ bon@@ ac@@ ci di@@ visors of a given number 10858 | import java . util . * ; class GF@@ G { static void create@@ Hash ( HashSet < Integer > hash , int max@@ Element ) { int prev = 0 , curr = 1 ; hash . add ( prev ) ; hash . add ( curr ) ; while ( curr <= max@@ Element ) { int temp = curr + prev ; hash . add ( temp ) ; prev = curr ; curr = temp ; } } static int count@@ Fi@@ bon@@ ac@@ ci@@ Di@@ visors ( int n ) { HashSet < Integer > hash = new HashSet < Integer > ( ) ; create@@ Hash ( hash , n ) ; int cnt = 0 ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( ( n / i == i ) && ( hash . contains ( n / i ) ) ) cnt ++ ; else { if ( hash . contains ( n / i ) ) cnt ++ ; if ( hash . contains ( n / ( n / i ) ) ) cnt ++ ; } } } return cnt ; } public static void main ( String [ ] args ) { int n = 12 ; System . out . print ( count@@ Fi@@ bon@@ ac@@ ci@@ Di@@ visors ( n ) ) ; } }
Check if number formed by joining two Numbers is Perf@@ ect Cube 10874 | class GF@@ G { static boolean is@@ Per@@ fec@@ t@@ Cube ( int x ) { long cr = Math . round ( Math . c@@ br@@ t ( x ) ) ; return ( cr * cr * cr == x ) ; } static void check@@ Cube ( int a , int b ) { String s1 = Integer . toString ( a ) ; String s2 = Integer . toString ( b ) ; int c = Integer . parseInt ( s1 + s2 ) ; if ( is@@ Per@@ fec@@ t@@ Cube ( c ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } public static void main ( String [ ] args ) { int a = 6 ; int b = 4 ; check@@ Cube ( a , b ) ; } }
Find the next Non 10879 | import java . util . * ; class GF@@ G { static boolean is@@ Per@@ fec@@ t@@ Square ( int x ) { int s = ( int ) Math . sqrt ( x ) ; return ( s * s == x ) ; } static boolean is@@ Fi@@ bon@@ ac@@ ci ( int N ) { return is@@ Per@@ fec@@ t@@ Square ( 5 * N * N + 4 ) || is@@ Per@@ fec@@ t@@ Square ( 5 * N * N - 4 ) ; } static int next@@ Non@@ Fi@@ bon@@ ac@@ ci ( int N ) { if ( N <= 3 ) return 4 ; if ( is@@ Fi@@ bon@@ ac@@ ci ( N + 1 ) ) return N + 2 ; else return N + 1 ; } public static void main ( String [ ] args ) { int N = 3 ; System . out . print ( next@@ Non@@ Fi@@ bon@@ ac@@ ci ( N ) + "@@ NEW_@@ LINE@@ "@@ )@@ ; N = 5 ; System . out . print ( next@@ Non@@ Fi@@ bon@@ ac@@ ci ( N ) + "@@ NEW_@@ LINE@@ "@@ )@@ ; N = 7 ; System . out . print ( next@@ Non@@ Fi@@ bon@@ ac@@ ci ( N ) + "@@ NEW_@@ LINE@@ "@@ )@@ ; } }
Count of prime digits of a Number which divi@@ des the number 10882 | class GF@@ G { static int count@@ Digit ( int n ) { boolean prime [ ] = new boolean [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) prime [ i ] = false ; prime [ 2 ] = prime [ 3 ] = true ; prime [ 5 ] = prime [ 7 ] = true ; int temp = n , count = 0 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 && prime [ d ] == true ) count ++ ; } return count ; } public static void main ( String [ ] args ) { int n = 10@@ 32 ; System . out . println ( count@@ Digit ( n ) ) ; } }
Print a pair of numbers with the given Sum and Product 10887 | import java . util . * ; class GF@@ G { static void find@@ Roots ( int b , int c ) { int a = 1 ; int d = b * b - 4 * a * c ; double sq@@ rt_@@ val = Math . sqrt ( Math . abs ( d ) ) ; if ( d > 0 ) { double x = - b + sq@@ rt_@@ val ; double y = - b - sq@@ rt_@@ val ; int roo@@ t1 = ( int ) ( x ) / ( 2 * a ) ; int root@@ 2 = ( int ) ( y ) / ( 2 * a ) ; if ( roo@@ t1 + root@@ 2 == - 1 * b && roo@@ t1 * root@@ 2 == c ) System . out . print ( roo@@ t1 + " , ▁ " + root@@ 2 ) ; else System . out . print ( - 1 ) ; } else if ( d == 0 ) { int root = - b / ( 2 * a ) ; if ( root + root == - 1 * b && root * root == c ) System . out . print ( root + " , ▁ " + root ) ; else System . out . print ( - 1 ) ; } else { System . out . print ( - 1 ) ; } System . out . println ( ) ; } public static void main ( String [ ] args ) { int S = 5 , P = 6 ; find@@ Roots ( - S , P ) ; S = 5 ; P = 9 ; find@@ Roots ( - S , P ) ; } }
Print N numbers such that their product is a Perf@@ ect Cube 10888 | import java . util . * ; class GF@@ G { static void find@@ Numbers ( int N ) { int i = 1 ; while ( i <= N ) { System . out . print ( ( i * i * i ) + " ▁ " ) ; i ++ ; } } public static void main ( String [ ] args ) { int N = 4 ; find@@ Numbers ( N ) ; } }
Check if N can be expressed as product of 3 distinct numbers 10898 | import java . util . * ; class GF@@ G { static void get@@ numbers ( int n ) { Vector < Integer > divisor = new Vector < Integer > ( ) ; for ( int i = 2 ; i * i <= n ; i ++ ) { while ( n % i == 0 ) { divisor . add ( i ) ; n /= i ; } } if ( n != 1 ) { divisor . add ( n ) ; } int a , b , c , size ; a = b = c = 1 ; size = divisor . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { if ( a == 1 ) { a = a * divisor . get ( i ) ; } else if ( b == 1 b == a ) { b = b * divisor . get ( i ) ; } else { c = c * divisor . get ( i ) ; } } if ( a == 1 b == 1 c == 1 a == b b == c a == c ) { System . out . print ( " - 1" + "@@ NEW_@@ LINE@@ "@@ )@@ ; } else { System . out . print ( a + " ▁ " + b + " ▁ " + c + "@@ NEW_@@ LINE@@ "@@ )@@ ; } } public static void main ( String [ ] args ) { int n = 64 ; get@@ numbers ( n ) ; } }
Check if all Prime factors of number N are unique or not 10899 | import java . util . * ; class GF@@ G { static Vector < Integer > prime@@ Factors ( int n ) { int i , j ; Vector < Integer > Prime = new Vector < Integer > ( ) ; if ( n % 2 == 0 ) { Prime . add ( 2 ) ; } while ( n % 2 == 0 ) { n = n / 2 ; } for ( i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { Prime . add ( i ) ; } while ( n % i == 0 ) { n = n / i ; } } if ( n > 2 ) { Prime . add ( n ) ; } return Prime ; } static void check@@ Distinct@@ Prime ( int n ) { Vector < Integer > Prime = prime@@ Factors ( n ) ; int product = 1 ; for ( int i : Prime ) { product *= i ; } if ( product == n ) System . out . print ( " YES " ) ; else System . out . print ( " NO " ) ; } public static void main ( String [ ] args ) { int N = 30 ; check@@ Distinct@@ Prime ( N ) ; } }
Calculate sum of all integers from 1 to N , excluding perfect power of 2 10927 | import java . lang . Math ; class GF@@ G { public static void find@@ Sum ( int N ) { int sum = ( N ) * ( N + 1 ) / 2 ; int r = ( int ) ( Math . log ( N ) / Math . log ( 2 ) ) + 1 ; int exp@@ Sum = ( int ) ( Math . pow ( 2 , r ) ) - 1 ; System . out . println ( sum - exp@@ Sum ) ; } public static void main ( String [ ] args ) { int N = 2 ; find@@ Sum ( N ) ; } }
Area of plot remaining at the end 9194 | class GF@@ G { static int remaining@@ Area ( int N , int M , int K ) { while ( K -- > 0 && N > 0 && M > 0 ) { if ( N > M ) N = N - M ; else M = M - N ; } if ( N > 0 && M > 0 ) return N * M ; else return 0 ; } public static void main ( String [ ] args ) { int N = 5 , M = 3 , K = 2 ; System . out . println ( remaining@@ Area ( N , M , K ) ) ; } }
Check if it is possible to create a polygon with given n sides 9208 | class GF@@ G { static boolean is@@ Possible ( int a [ ] , int n ) { int sum = 0 , max@@ S = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; max@@ S = Math . max ( a [ i ] , max@@ S ) ; } if ( ( sum - max@@ S ) > max@@ S ) return true ; return false ; } public static void main ( String [ ] args ) { int a [ ] = { 2 , 3 , 4 } ; int n = a . length ; if ( is@@ Possible ( a , n ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
Find the coordinates of the fourth vertex of a rectangle with given 3 vertices 9220 | import java . util . HashMap ; import java . util . Map ; class Gf@@ G { static Pair < Integer , Integer > find@@ Four@@ th@@ Vertex ( int n , int m , String s [ ] ) { HashMap < Integer , Integer > row = new HashMap < > ( ) ; HashMap < Integer , Integer > col = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( s [ i ] . charAt ( j ) == ' * ' ) { if ( row . containsKey ( i ) ) { row . put ( i , row . get ( i ) + 1 ) ; } else { row . put ( i , 1 ) ; } if ( col . containsKey ( j ) ) { col . put ( j , col . get ( j ) + 1 ) ; } else { col . put ( j , 1 ) ; } } } } int x = 0 , y = 0 ; for ( Map . Entry < Integer , Integer > entry : row . entrySet ( ) ) { if ( entry . getValue ( ) == 1 ) x = entry . getKey ( ) ; } for ( Map . Entry < Integer , Integer > entry : col . entrySet ( ) ) { if ( entry . getValue ( ) == 1 ) y = entry . getKey ( ) ; } Pair < Integer , Integer > ans = new Pair < > ( x + 1 , y + 1 ) ; return ans ; } public static void main ( String [ ] args ) { String s [ ] = { " * . * " , " * . . " , " . . . " } ; int n = s . length ; int m = s [ 0 ] . length ( ) ; Pair < Integer , Integer > rs = find@@ Four@@ th@@ Vertex ( n , m , s ) ; System . out . println ( rs . first + " ▁ " + rs . second ) ; } } class Pair < A , B > { A first ; B second ; public Pair ( A first , B second ) { this . first = first ; this . second = second ; } }
Lar@@ gest right circular con@@ e that can be in@@ scri@@ bed within a sphere which is in@@ scri@@ bed within a cube 9224 | import java . io . * ; class GF@@ G { static float con@@ e ( float a ) { if ( a < 0 ) return - 1 ; float r = ( float ) ( a * Math . sqrt ( 2 ) ) / 3 ; float h = ( 2 * a ) / 3 ; float V = ( float ) ( 3.14 * Math . pow ( r , 2 ) * h ) ; return V ; } public static void main ( String [ ] args ) { float a = 5 ; System . out . println ( con@@ e ( a ) ) ; } }
Lar@@ gest Square that can be in@@ scri@@ bed within a hex@@ ag@@ on 9251 | class Solution { static float square@@ Area ( float a ) { if ( a < 0 ) return - 1 ; float area = ( float ) ( Math . pow ( 1.@@ 268 , 2 ) * Math . pow ( a , 2 ) ) ; return area ; } public static void main ( String args [ ] ) { float a = 6 ; System . out . println ( square@@ Area ( a ) ) ; } }
Length of ro@@ pe tied around three equal circ@@ les touch@@ ing each other 9260 | import java . lang . * ; class GF@@ G { static double PI = 3.14@@ 159@@ 265 ; public static double length_@@ ro@@ pe ( double r ) { return ( ( 2 * PI * r ) + 6 * r ) ; } public static void main ( String [ ] args ) { double r = 7 ; System . out . println ( length_@@ ro@@ pe ( r ) ) ; } }
Volume of big@@ gest sphere within a right circular cylinder 9266 | import java . io . * ; class GF@@ G { static float sp@@ h ( float r , float h ) { if ( r < 0 && h < 0 ) return - 1 ; float R = r ; return R ; } public static void main ( String [ ] args ) { float r = 4 , h = 8 ; System . out . println ( sp@@ h ( r , h ) ) ; } }
Minimum Cu@@ ts can be made in the Ch@@ ess@@ board such that it is not divided into 2 parts 9276 | class GF@@ G { static int numberOf@@ Cu@@ ts ( int M , int N ) { int result = 0 ; result = ( M - 1 ) * ( N - 1 ) ; return result ; } public static void main ( String args [ ] ) { int M = 4 , N = 4 ; int Cu@@ ts = numberOf@@ Cu@@ ts ( M , N ) ; System . out . println ( " Maximum ▁ cuts ▁ = ▁ " + Cu@@ ts ) ; } }
Equation of par@@ ab@@ ola from its focus and direc@@ tri@@ x 9285 | import java . util . * ; class solution { static void equ@@ ation_@@ par@@ ab@@ ola ( float x1 , float y1 , float a , float b , float c ) { float t = a * a + b * b ; float a1 = t - ( a * a ) ; float b1 = t - ( b * b ) ; float c1 = ( - 2 * t * x1 ) - ( 2 * c * a ) ; float d1 = ( - 2 * t * y1 ) - ( 2 * c * b ) ; float e1 = - 2 * a * b ; float f1 = ( - c * c ) + ( t * x1 * x1 ) + ( t * y1 * y1 ) ; System . out . println ( " equation ▁ of ▁ par@@ ab@@ ola ▁ is ▁ " + a1 + " ▁ x ^ 2 ▁ + ▁ " + b1 + " ▁ y ^ 2 ▁ + ▁ " + c1 + " ▁ x ▁ + ▁ " + d1 + " ▁ y ▁ + ▁ " + e1 + " ▁ xy ▁ + ▁ " + f1 + " ▁ = ▁ 0 . " ) ; } public static void main ( String arr [ ] ) { float x1 = 0 ; float y1 = 0 ; float a = 3 ; float b = - 4 ; float c = 2 ; equ@@ ation_@@ par@@ ab@@ ola ( x1 , y1 , a , b , c ) ; } }
Program to find the Area and Per@@ imeter of a Se@@ mic@@ ir@@ cle 9291 | import java . io . * ; class GF@@ G { static float area ( float r ) { return ( float ) ( ( 0.5 ) * ( 3.14 ) * ( r * r ) ) ; } static float per@@ imeter ( float r ) { return ( float ) ( ( 3.14 ) * ( r ) ) ; } public static void main ( String [ ] args ) { float r = 10 ; System . out . println ( " The ▁ Area ▁ of ▁ Se@@ mic@@ ir@@ cle : ▁ " + area ( r ) ) ; System . out . println ( " The ▁ Per@@ imeter ▁ of ▁ Se@@ mic@@ ir@@ cle : " + + per@@ imeter ( r ) ) ; } }
Check if it is possible to move from ( 0 , 0 ) to ( x , y ) in N steps 9306 | import java . io . * ; public class GF@@ G { static boolean Arri@@ ve ( int a , int b , int n ) { if ( n >= Math . abs ( a ) + Math . abs ( b ) && ( n - ( Math . abs ( a ) + Math . abs ( b ) ) ) % 2 == 0 ) return true ; return false ; } int main ( ) { return 0 ; } public static void main ( String [ ] args ) { int a = 5 , b = 5 , n = 11 ; if ( Arri@@ ve ( a , b , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
Area of largest triangle that can be in@@ scri@@ bed within a rectangle 9317 | import java . util . * ; class GF@@ G { static float triangle@@ area ( float l , float b ) { if ( l < 0 b < 0 ) return - 1 ; float area = ( l * b ) / 2 ; return area ; } public static void main ( String args [ ] ) { float l = 5 , b = 4 ; System . out . println ( triangle@@ area ( l , b ) ) ; } }
Area of a largest square fit in a right angle triangle 9335 | public class GF@@ G { static float square@@ Area ( float l , float b , float h ) { if ( l < 0 b < 0 h < 0 ) return - 1 ; float a = ( l * b ) / ( l + b ) ; return a * a ; } public static void main ( String [ ] args ) { float l = 5 , b = 12 , h = 13 ; System . out . println ( square@@ Area ( l , b , h ) ) ; } }
Inter@@ sec@@ ting rectangle when bottom 9357 | class GF@@ G { static void Find@@ Points ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x4 , int y@@ 4 ) { int x5 = Math . max ( x1 , x3 ) ; int y@@ 5 = Math . max ( y1 , y3 ) ; int x@@ 6 = Math . min ( x2 , x4 ) ; int y@@ 6 = Math . min ( y2 , y@@ 4 ) ; if ( x5 > x@@ 6 y@@ 5 > y@@ 6 ) { System . out . println ( " No ▁ intersection " ) ; return ; } System . out . print ( " ( " + x5 + " , ▁ " + y@@ 5 + " ) ▁ " ) ; System . out . print ( " ( " + x@@ 6 + " , ▁ " + y@@ 6 + " ) ▁ " ) ; int x@@ 7 = x5 ; int y@@ 7 = y@@ 6 ; System . out . print ( " ( " + x@@ 7 + " , ▁ " + y@@ 7 + " ) ▁ " ) ; int x@@ 8 = x@@ 6 ; int y@@ 8 = y@@ 5 ; System . out . print ( " ( " + x@@ 8 + " , ▁ " + y@@ 8 + " ) ▁ " ) ; } public static void main ( String args [ ] ) { int x1 = 0 , y1 = 0 , x2 = 10 , y2 = 8 ; int x3 = 2 , y3 = 3 , x4 = 7 , y@@ 4 = 9 ; Find@@ Points ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y@@ 4 ) ; } }
Program to find equation of a plane passing through 3 points 9364 | import java . io . * ; class GF@@ G { static void equ@@ ation_@@ plane ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 , float x3 , float y3 , float z3 ) { float a1 = x2 - x1 ; float b1 = y2 - y1 ; float c1 = z2 - z1 ; float a2 = x3 - x1 ; float b2 = y3 - y1 ; float c2 = z3 - z1 ; float a = b1 * c2 - b2 * c1 ; float b = a2 * c1 - a1 * c2 ; float c = a1 * b2 - b1 * a2 ; float d = ( - a * x1 - b * y1 - c * z1 ) ; System . out . println ( " equation ▁ of ▁ plane ▁ is ▁ " + a + " ▁ x ▁ + ▁ " + b + " ▁ y ▁ + ▁ " + c + " ▁ z ▁ + ▁ " + d + " ▁ = ▁ 0 . " ) ; } public static void main ( String [ ] args ) { float x1 = - 1 ; float y1 = 2 ; float z1 = 1 ; float x2 = 0 ; float y2 = - 3 ; float z2 = 2 ; float x3 = 1 ; float y3 = 1 ; float z3 = - 4 ; equ@@ ation_@@ plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) ; } }
Program to determine the oct@@ ant of the ax@@ ial plane 9368 | import java . util . * ; class solution { static void oct@@ ant ( float x , float y , float z ) { if ( x >= 0 && y >= 0 && z >= 0 ) System . out . println ( " Point ▁ lies ▁ in ▁ 1st ▁ oct@@ ant " ) ; else if ( x < 0 && y >= 0 && z >= 0 ) System . out . println ( " Point ▁ lies ▁ in ▁ 2nd ▁ oct@@ ant " ) ; else if ( x < 0 && y < 0 && z >= 0 ) System . out . println ( " Point ▁ lies ▁ in ▁ 3rd ▁ oct@@ ant " ) ; else if ( x >= 0 && y < 0 && z >= 0 ) System . out . println ( " Point ▁ lies ▁ in ▁ 4@@ th ▁ oct@@ ant " ) ; else if ( x >= 0 && y >= 0 && z < 0 ) System . out . println ( " Point ▁ lies ▁ in ▁ 5@@ th ▁ oct@@ ant " ) ; else if ( x < 0 && y >= 0 && z < 0 ) System . out . println ( " Point ▁ lies ▁ in ▁ 6@@ th ▁ oct@@ ant " ) ; else if ( x < 0 && y < 0 && z < 0 ) System . out . println ( " Point ▁ lies ▁ in ▁ 7@@ th ▁ oct@@ ant " ) ; else if ( x >= 0 && y < 0 && z < 0 ) System . out . println ( " Point ▁ lies ▁ in ▁ 8@@ th ▁ oct@@ ant " ) ; } public static void main ( String args [ ] ) { float x = 2 , y = 3 , z = 4 ; oct@@ ant ( x , y , z ) ; x = - 4 ; y = 2 ; z = - 8 ; oct@@ ant ( x , y , z ) ; x = - 6 ; y = - 2 ; z = 8 ; oct@@ ant ( x , y , z ) ; } }
Pent@@ ag@@ onal Pyram@@ id@@ al Number 9380 | import java . io . * ; class GF@@ G { static int pent@@ ag@@ on_@@ pyram@@ id@@ al ( int n ) { return n * n * ( n + 1 ) / 2 ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( pent@@ ag@@ on_@@ pyram@@ id@@ al ( n ) ) ; } }
Find the other end point of a line with given one end and mid 9407 | class GF@@ G { static void other@@ EndPoint ( int x1 , int y1 , int m1 , int m2 ) { float x2 = ( float ) ( 2 * m1 - x1 ) ; float y2 = ( float ) ( 2 * m2 - y1 ) ; System . out . println ( " x2 ▁ = ▁ " + x2 + " , ▁ " + " y2 ▁ = ▁ " + y2 ) ; } public static void main ( String args [ ] ) { int x1 = - 4 , y1 = - 1 , m1 = 3 , m2 = 5 ; other@@ EndPoint ( x1 , y1 , m1 , m2 ) ; } }
Count of acute , ob@@ t@@ use and right triangles with given sides 9510 | import java . util . * ; class GF@@ G { static void find@@ Triangle ( int a [ ] , int n ) { int b [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) b [ i ] = a [ i ] * a [ i ] ; Arrays . sort ( a ) ; Arrays . sort ( b ) ; int x = 0 , y = 0 , z = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int p = i + 1 ; int q = i + 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { while ( p < n - 1 && b [ i ] + b [ j ] >= b [ p + 1 ] ) p ++ ; q = Math . max ( q , p ) ; while ( q < n - 1 && a [ i ] + a [ j ] > a [ q + 1 ] ) q ++ ; if ( b [ i ] + b [ j ] == b [ p ] ) { x += Math . max ( p - j - 1 , 0 ) ; y ++ ; z += q - p ; } else { x += Math . max ( p - j , 0 ) ; z += q - p ; } } } System . out . println ( " Ac@@ u@@ te ▁ Triangle : ▁ " + x ) ; System . out . println ( " Right ▁ Triangle : ▁ " + y ) ; System . out . println ( " Ob@@ t@@ use ▁ Triangle : ▁ " + z ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 9 , 10 , 12 , 15 } ; int n = arr . length ; find@@ Triangle ( arr , n ) ; } }
Area of a polygon with given n ordered vertices 9521 | import java . io . * ; class GF@@ G { public static double polygon@@ Area ( double X [ ] , double Y [ ] , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; j = i ; } return Math . abs ( area / 2.0 ) ; } public static void main ( String [ ] args ) { double X [ ] = { 0 , 2 , 4 } ; double Y [ ] = { 1 , 3 , 7 } ; int n = 3 ; System . out . println ( polygon@@ Area ( X , Y , n ) ) ; } }
Program to find area of a triangle 9528 | import java . io . * ; import java . math . * ; class GF@@ G { static double polygon@@ Area ( double X [ ] , double Y [ ] , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; j = i ; } return Math . abs ( area / 2.0 ) ; } public static void main ( String [ ] args ) { double X [ ] = { 0 , 2 , 4 } ; double Y [ ] = { 1 , 3 , 7 } ; int n = X . length ; System . out . println ( polygon@@ Area ( X , Y , n ) ) ; } }
Lar@@ gest integer upto N having gre@@ atest prime factor greater than its square root 9543 | public class GF@@ G { final static int max@@ n = 10000@@ 1 ; static int gp@@ f [ ] = new int [ max@@ n ] ; static void modified@@ Si@@ eve ( ) { for ( int i = 0 ; i < max@@ n ; i ++ ) gp@@ f [ i ] = 0 ; gp@@ f [ 0 ] = 0 ; gp@@ f [ 1 ] = 1 ; for ( int i = 2 ; i < max@@ n ; i ++ ) { if ( gp@@ f [ i ] > 0 ) continue ; for ( int j = i ; j < max@@ n ; j += i ) { gp@@ f [ j ] = Math . max ( i , gp@@ f [ j ] ) ; } } } static int gre@@ atest@@ Valid@@ Int ( int N ) { modified@@ Si@@ eve ( ) ; for ( int i = N ; i > 0 ; i -- ) { if ( gp@@ f [ i ] > Math . sqrt ( i ) ) { return i ; } } return - 1 ; } public static void main ( String [ ] args ) { int N = 25 ; System . out . println ( gre@@ atest@@ Valid@@ Int ( N ) ) ; } }
Find sub@@ factorial of a number 9547 | import java . util . * ; class GF@@ G { static double sub@@ factorial ( int N ) { double res = 0 , fact = 1 ; int count = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { fact = fact * i ; if ( count % 2 == 0 ) res = res - ( 1 / fact ) ; else res = res + ( 1 / fact ) ; count ++ ; } return fact * ( 1 + res ) ; } public static void main ( String [ ] args ) { int N = 4 ; System . out . println ( ( int ) ( sub@@ factorial ( N ) ) ) ; } }
Count of pair of integers ( x , y ) such that difference between square of x and y is a perfect square 9549 | import java . util . * ; class GF@@ G { static int count@@ Pairs ( int N ) { int res = 0 ; for ( int q = 1 ; q * q <= N ; q ++ ) { int max@@ P = Math . min ( 2 * N - q , N / q ) ; if ( max@@ P < q ) continue ; int cnt = max@@ P - q + 1 ; res += ( cnt / 2 + ( cnt & 1 ) ) ; } return res ; } public static void main ( String [ ] args ) { int N = 3 ; System . out . print ( count@@ Pairs ( N ) ) ; } }
Find the last positive element remaining after repeated subtr@@ actions of smallest positive element from all Array elements 9573 | import java . util . * ; class GF@@ G { static int last@@ Positive@@ Element ( int [ ] arr ) { int N = arr . length ; if ( N == 1 ) return arr [ 0 ] ; int gre@@ atest = - 1 , second@@ Gre@@ atest = - 1 ; for ( int x : arr ) { if ( x >= gre@@ atest ) { second@@ Gre@@ atest = gre@@ atest ; gre@@ atest = x ; } else if ( x >= second@@ Gre@@ atest ) { second@@ Gre@@ atest = x ; } } return gre@@ atest - second@@ Gre@@ atest ; } public static void main ( String [ ] args ) { int [ ] arr = { 3 , 5 , 4 , 7 } ; System . out . print ( last@@ Positive@@ Element ( arr ) ) ; } }
Sum of all subsets of a given size ( = K ) 9609 | import java . io . * ; class GF@@ G { static void find@@ Sum@@ Of@@ All@@ Sub@@ sets ( int [ ] arr , int n , int k ) { int factor@@ i@@ al_@@ N = 1 , factor@@ i@@ al_@@ d = 1 , factor@@ i@@ al_@@ D = 1 ; for ( int i = 1 ; i <= n - 1 ; i ++ ) factor@@ i@@ al_@@ N *= i ; for ( int i = 1 ; i <= k - 1 ; i ++ ) factor@@ i@@ al_@@ d *= i ; for ( int i = 1 ; i <= n - k ; i ++ ) factor@@ i@@ al_@@ D *= i ; int freq = factor@@ i@@ al_@@ N / ( factor@@ i@@ al_@@ d * factor@@ i@@ al_@@ D ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; sum = sum * freq ; System . out . println ( " Sum ▁ of ▁ all ▁ subsets ▁ of ▁ size ▁ = ▁ " + k + " ▁ is ▁ = > ▁ " + sum ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 4 , 5 } ; int n = 4 , k = 2 ; find@@ Sum@@ Of@@ All@@ Sub@@ sets ( arr , n , k ) ; } }
Maxim@@ ize XOR by selecting 3 numbers in range [ 0 , A ] , [ 0 , B ] , and [ 0 , C ] respectively 9612 | import java . util . * ; class GF@@ G { static int maximum@@ Trip@@ let@@ XOR ( int A , int B , int C ) { int ans = 0 ; for ( int i = 30 ; i >= 0 ; i -- ) { int cur = 1 << i ; if ( A >= cur ) { ans += cur ; A -= cur ; } else if ( B >= cur ) { ans += cur ; B -= cur ; } else if ( C >= cur ) { ans += cur ; C -= cur ; } } return ans ; } public static void main ( String [ ] args ) { int A = 6 ; int B = 2 ; int C = 10 ; System . out . print ( maximum@@ Trip@@ let@@ XOR ( A , B , C ) ) ; } }
Lon@@ gest remaining array of distinct elements possible after repeated removal of maximum and minimum elements of trip@@ lets 9626 | import java . io . * ; import java . util . * ; class GF@@ G { static int max@@ Unique@@ Elements ( int [ ] Arr , int N ) { HashMap < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( mp . containsKey ( Arr [ i ] ) ) { mp . put ( Arr [ i ] , mp . get ( Arr [ i ] ) + 1 ) ; } else { mp . put ( Arr [ i ] , 1 ) ; } } int cnt = 0 ; for ( Map . Entry < Integer , Integer > entry : mp . entrySet ( ) ) { if ( ( entry . getValue ( ) ) % 2 == 0 ) { cnt ++ ; } } int ans = mp . size ( ) ; if ( cnt % 2 == 1 ) { ans -- ; } return ans ; } public static void main ( String [ ] args ) { int N = 5 ; int A [ ] = { 1 , 2 , 1 , 3 , 7 } ; System . out . println ( max@@ Unique@@ Elements ( A , N ) ) ; } }
Count cells in a grid from which maximum number of cells can be reached by K vertical or horizontal jumps 9640 | import java . io . * ; class GF@@ G { static int m = 100000000@@ 7 ; static int power ( int x , int y ) { int res = 1 ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % m ; y = y >> 1 ; x = ( x * x ) % m ; } return res ; } static int count@@ N@@ Digit@@ Number ( int N ) { int ne = N / 2 + N % 2 ; int no = ( int ) Math . floor ( N / 2 ) ; return power ( 4 , ne ) * power ( 5 , no ) ; } public static void main ( String [ ] args ) { int N = 5 ; System . out . println ( count@@ N@@ Digit@@ Number ( N ) % m ) ; } }
Count of pairs in range [ P , Q ] with numbers as multiple of R and their product lie in range [ P * Q / 4 , P * Q ] 9706 | import java . awt . * ; import java . util . * ; class GF@@ G { static class pair < T , V > { T first ; V second ; } static void find@@ Pairs ( int p , int q , int r ) { ArrayList < Integer > v = new ArrayList < > ( ) ; for ( int i = p ; i <= q ; i ++ ) { if ( i % r == 0 ) { v . add ( i ) ; } } ArrayList < pair < Integer , Integer > > ans = new ArrayList < > ( ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { for ( int j = i + 1 ; j < v . size ( ) ; j ++ ) { if ( v . get ( i ) * v . get ( j ) >= p * q / 4 && v . get ( i ) * v . get ( j ) <= p * q ) { pair < Integer , Integer > x = new pair < > ( ) ; x . first = v . get ( i ) ; x . second = v . get ( j ) ; ans . add ( x ) ; } } } if ( ans . size ( ) == 0 ) { System . out . println ( - 1 ) ; } else { for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { System . out . println ( ans . get ( i ) . first + " ▁ " + ans . get ( i ) . second ) ; } } } public static void main ( String [ ] args ) { int p = 14 , q = 30 , r = 5 ; find@@ Pairs ( p , q , r ) ; } }
Maxim@@ ize product of sub@@ array sum with its maximum element 9718 | import java . io . * ; class GF@@ G { static int K@@ ad@@ ane ( int arr [ ] , int n ) { int lar@@ gest@@ Sum = 0 , curr@@ Max = 0 ; int curr@@ Sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr@@ Sum += arr [ i ] ; curr@@ Max = Math . max ( curr@@ Max , arr [ i ] ) ; lar@@ gest@@ Sum = Math . max ( lar@@ gest@@ Sum , curr@@ Max * curr@@ Sum ) ; if ( curr@@ Sum < 0 ) { curr@@ Max = 0 ; curr@@ Sum = 0 ; } } return lar@@ gest@@ Sum ; } static int maximum@@ Weight ( int arr [ ] , int n ) { int lar@@ gest@@ Sum = K@@ ad@@ ane ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = - arr [ i ] ; } lar@@ gest@@ Sum = Math . max ( lar@@ gest@@ Sum , K@@ ad@@ ane ( arr , n ) ) ; return lar@@ gest@@ Sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , - 3 , 8 , - 2 , 5 } ; int N = arr . length ; System . out . println ( maximum@@ Weight ( arr , N ) ) ; } }
Maximum number of multiplication by 3 or division by 2 operations possible on an array 9729 | public class GF@@ G { static int maximum@@ Tur@@ ns ( int arr [ ] , int N ) { int Count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { while ( arr [ i ] % 2 == 0 ) { Count ++ ; arr [ i ] = arr [ i ] / 2 ; } } return Count ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 2 , 4 } ; int M = 3 , K = 2 ; int N = arr . length ; System . out . println ( maximum@@ Tur@@ ns ( arr , N ) ) ; } }
Dist@@ ribute the white and black objects into maximum groups under certain constraints 9731 | import java . io . * ; class GF@@ G { public static void is@@ Possible ( int W , int B , int D ) { if ( W > B ) { int temp = W ; W = B ; B = temp ; } if ( B > W * ( D + 1 ) ) System . out . println ( " NO " ) ; else System . out . println ( " YES " ) ; } public static void main ( String [ ] args ) { int W = 2 ; int B = 5 ; int D = 2 ; is@@ Possible ( W , B , D ) ; } }
Find the maximum GC@@ D possible for some pair in a given range [ L , R ] 9734 | import java . io . * ; class GF@@ G { public static int GC@@ D ( int a , int b ) { if ( b == 0 ) return a ; return GC@@ D ( b , a % b ) ; } public static int max@@ G@@ CD@@ InRange ( int L , int R ) { int ans = 1 ; for ( int Z = R ; Z >= 1 ; Z -- ) { if ( ( R / Z ) - ( L - 1 ) / Z > 1 ) { ans = Z ; break ; } } return ans ; } public static void main ( String [ ] args ) { int L = 102 ; int R = 139 ; System . out . println ( max@@ G@@ CD@@ InRange ( L , R ) ) ; }
Find Prime number just less than and just greater each element of given Array 9738 | import java . io . * ; class GF@@ G { static boolean is@@ Prime ( int X ) { for ( int i = 2 ; i * i <= X ; i ++ ) if ( X % i == 0 ) return false ; return true ; } static void print@@ Pri@@ mes ( int A [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = A [ i ] - 1 ; ; j -- ) { if ( is@@ Prime ( j ) ) { System . out . print ( j + " ▁ " ) ; break ; } } for ( int j = A [ i ] + 1 ; ; j ++ ) { if ( is@@ Prime ( j ) ) { System . out . print ( j + " ▁ " ) ; break ; } } System . out . println ( ) ; } } public static void main ( String [ ] args ) { int A [ ] = { 17 , 28 } ; int N = A . length ; print@@ Pri@@ mes ( A , N ) ; } }
S@@ malle@@ st number required to be added to M to make it di@@ visible by N 9791 | class GF@@ G { public static int find@@ Num ( int N , int K ) { int rem = ( N + K ) % K ; if ( rem == 0 ) return N ; else return N + K - rem ; } public static int find@@ S@@ malle@@ st ( int M , int N ) { int x = find@@ Num ( M , N ) ; return x - M ; } public static void main ( String args [ ] ) { int M = 100 , N = 28 ; System . out . println ( find@@ S@@ malle@@ st ( M , N ) ) ; } }
Minimum time required to schedule K processes 9812 | import java . util . * ; import java . lang . * ; class GF@@ G { static int min@@ Time ( int [ ] A , int n , int K ) { int max_@@ ability = A [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { max_@@ ability = Math . max ( max_@@ ability , A [ i ] ) ; } int tmp [ ] = new int [ max_@@ ability + 1 ] ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { tmp [ A [ i ] ] ++ ; } for ( int i = max_@@ ability ; i >= 0 ; i -- ) { if ( tmp [ i ] != 0 ) { if ( tmp [ i ] * i < K ) { K -= ( i * tmp [ i ] ) ; tmp [ i / 2 ] += tmp [ i ] ; count += tmp [ i ] ; if ( K <= 0 ) { return count ; } } else { if ( K % i != 0 ) { count += ( K / i ) + 1 ; } else { count += ( K / i ) ; } return count ; } } } return - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 1 , 7 , 2 , 4 } ; int N = arr . length ; int K = 15 ; System . out . println ( min@@ Time ( arr , N , K ) ) ; } }
Minimum operations required to make all elements in an array of first N odd numbers equal 9825 | class GF@@ G { public static int min@@ Operations ( int N ) { int [ ] arr = new int [ N ] ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] = ( 2 * i ) + 1 ; sum = sum + arr [ i ] ; } int mid = 0 ; if ( N % 2 == 0 ) { mid = sum / N ; } else { mid = arr [ N / 2 ] ; } int ans = 0 ; for ( int i = 0 ; i < N / 2 ; i ++ ) { ans += mid - arr [ i ] ; } return ans ; } public static void main ( String [ ] args ) { int N = 6 ; System . out . println ( min@@ Operations ( N ) ) ; } }
Queries to update array by adding or multiply@@ ing array elements and print the element present at specified index 9847 | import java . io . * ; import java . lang . * ; import java . util . * ; public class GF@@ G { static void Query ( int arr [ ] , int N , int Q [ ] [ ] ) { int mul = 1 ; int add = 0 ; for ( int i = 0 ; i < Q . length ; i ++ ) { if ( Q [ i ] [ 0 ] == 0 ) { add = add + Q [ i ] [ 1 ] ; } else if ( Q [ i ] [ 0 ] == 1 ) { mul = mul * Q [ i ] [ 1 ] ; add = add * Q [ i ] [ 1 ] ; } else { int ans = arr [ Q [ i ] [ 1 ] ] * mul + add ; System . out . print ( ans + " ▁ " ) ; } } } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 1 , 23 , 45 , 100 } ; int N = arr . length ; int Q [ ] [ ] = { { 1 , 2 } , { 0 , 10 } , { 2 , 3 } , { 1 , 5 } , { 2 , 4 } } ; Query ( arr , N , Q ) ; } }
Maximum sum of pairs that are at least K distance ap@@ art in an array 9850 | import java . io . * ; import java . lang . * ; import java . util . * ; public class GF@@ G { static int getMax@@ Pair@@ Sum ( int [ ] arr , int N , int K ) { int [ ] pre@@ Max = new int [ N ] ; pre@@ Max [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { pre@@ Max [ i ] = Math . max ( pre@@ Max [ i - 1 ] , arr [ i ] ) ; } int res = Integer . MIN_VALUE ; for ( int i = K ; i < N ; i ++ ) { res = Math . max ( res , arr [ i ] + pre@@ Max [ i - K ] ) ; } return res ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 4 , 8 , 6 , 3 } ; int K = 3 ; int N = arr . length ; System . out . print ( getMax@@ Pair@@ Sum ( arr , N , K ) ) ; } }
Count pairs from an array having GC@@ D equal to the minimum element in the pair 9853 | import java . io . * ; import java . util . * ; class GF@@ G { static int Count@@ Pairs ( int arr [ ] , int N ) { int res = 0 ; Map < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { Integer c = mp . get ( arr [ i ] ) ; mp . put ( arr [ i ] , ( c == null ) ? 1 : c + 1 ) ; } Iterator < Map . Entry < Integer , Integer > > itr = mp . entrySet ( ) . iterator ( ) ; while ( itr . hasNext ( ) ) { Map . Entry < Integer , Integer > entry = itr . next ( ) ; int x = ( int ) entry . getKey ( ) ; int y = ( int ) entry . getValue ( ) ; if ( x == 1 ) { res += N - 1 ; continue ; } res += ( y * ( y - 1 ) ) / 2 ; for ( int j = 2 ; j <= Math . sqrt ( x ) ; j ++ ) { if ( x % j == 0 ) { res += mp . get ( j ) ; if ( j != x / j ) res += mp . get ( ( int ) x / j ) ; } } } return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 1 , 2 } ; int N = arr . length ; System . out . println ( Count@@ Pairs ( arr , N ) ) ; } }
Minim@@ ize sum of an array having Bit@@ wise AND of all its pairs present in a given matrix 9876 | import java . io . * ; import java . lang . * ; import java . util . * ; class GF@@ G { static int find@@ Min@@ Sum ( int mat [ ] [ ] , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int res = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( i != j ) { res |= mat [ i ] [ j ] ; } } sum += res ; } return sum ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { - 1 , 2 , 3 } , { 9 , - 1 , 7 } , { 4 , 5 , - 1 } } ; int N = mat . length ; System . out . println ( find@@ Min@@ Sum ( mat , N ) ) ; } }
Minim@@ ize maximum difference between adjacent elements possible by removing a single array element 9880 | import java . util . * ; class GF@@ G { static int max@@ Adjac@@ ent@@ Difference ( ArrayList < Integer > A ) { int diff = 0 ; for ( int i = 1 ; i < ( int ) A . size ( ) ; i ++ ) { diff = Math . max ( diff , A . get ( i ) - A . get ( i - 1 ) ) ; } return diff ; } static int Minimum@@ Value ( int arr [ ] , int N ) { int Min@@ Value = Integer . MAX_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { ArrayList < Integer > new_@@ arr = new ArrayList < > ( ) ; for ( int j = 0 ; j < N ; j ++ ) { if ( i == j ) continue ; new_@@ arr . add ( arr [ j ] ) ; } Min@@ Value = Math . min ( Min@@ Value , max@@ Adjac@@ ent@@ Difference ( new_@@ arr ) ) ; } return Min@@ Value ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 7 , 8 } ; int N = arr . length ; System . out . print ( Minimum@@ Value ( arr , N ) ) ; } }
Number of Anti@@ symmetric Relations on a set of N elements 9884 | import java . util . * ; class GF@@ G { static int mod = 100000000@@ 7 ; static int power ( int x , int y ) { int res = 1 ; x = x % mod ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % mod ; y = y >> 1 ; x = ( x * x ) % mod ; } return res ; } static int anti@@ symmetri@@ c@@ Relation ( int N ) { return ( power ( 2 , N ) * power ( 3 , ( N * N - N ) / 2 ) ) % mod ; } public static void main ( String [ ] args ) { int N = 2 ; System . out . print ( anti@@ symmetri@@ c@@ Relation ( N ) ) ; } }
Count pairs with odd Bit@@ wise XOR that can be removed and replaced by their Bit@@ wise OR 9893 | import java . io . * ; import java . lang . * ; import java . util . * ; class GF@@ G { static void count@@ Pairs ( int arr [ ] , int N ) { int even = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; } if ( N - even >= 1 ) { System . out . println ( even ) ; return ; } System . out . println ( 0 ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 4 , 7 , 2 } ; int N = arr . length ; count@@ Pairs ( arr , N ) ; } }
Permutation of first N natural numbers having given array as the prefix maximum array 9896 | import java . io . * ; import java . lang . * ; import java . util . * ; class GF@@ G { static boolean check@@ Permutation ( int ans [ ] , int a [ ] , int n ) { int Max = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { Max = Math . max ( Max , ans [ i ] ) ; if ( Max != a [ i ] ) return false ; } return true ; } static void find@@ Permutation ( int a [ ] , int n ) { int ans [ ] = new int [ n ] ; HashMap < Integer , Integer > um = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! um . containsKey ( a [ i ] ) ) { ans [ i ] = a [ i ] ; um . put ( a [ i ] , i ) ; } } ArrayList < Integer > v = new ArrayList < > ( ) ; int j = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ! um . containsKey ( i ) ) { v . add ( i ) ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( ans [ i ] == 0 ) { ans [ i ] = v . get ( j ) ; j ++ ; } } if ( check@@ Permutation ( ans , a , n ) ) { for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( ans [ i ] + " ▁ " ) ; } } else System . out . println ( " - 1" ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 4 , 5 , 5 } ; int N = arr . length ; find@@ Permutation ( arr , N ) ; } }
Find all pairs raised to power K differs by exactly N 9922 | import java . util . * ; class GF@@ G { static void Valid@@ Pairs ( int X , int K ) { int count = 0 ; for ( int A = - 1000 ; A <= 1000 ; A ++ ) { for ( int B = - 1000 ; B <= 1000 ; B ++ ) { if ( Math . pow ( A , K ) - Math . pow ( B , K ) == X ) { count ++ ; System . out . println ( A + " ▁ " + B ) ; } } } if ( count == 0 ) { System . out . println ( " - 1" ) ; } } public static void main ( String args [ ] ) { int X = 33 ; int K = 5 ; Valid@@ Pairs ( X , K ) ; } }
XOR of major diagonal elements of a 3D Matrix 9927 | import java . io . * ; import java . lang . * ; import java . util . * ; class GF@@ G { static void find@@ XOR ( int mat [ ] [ ] [ ] , int N ) { int XOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { XOR ^= mat [ i ] [ i ] [ i ] ; XOR ^= mat [ i ] [ i ] [ N - i - 1 ] ; } System . out . println ( XOR ) ; } public static void main ( String [ ] args ) { int mat [ ] [ ] [ ] = { { { 1 , 2 } , { 3 , 4 } } , { { 5 , 6 } , { 7 , 8 } } } ; int N = mat . length ; find@@ XOR ( mat , N ) ; } }
Find the player who wins the game of pl@@ acing alternate + and 9929 | import java . util . * ; class GF@@ G { static void check@@ Win@@ ner ( int arr [ ] , int N ) { int diff = 0 ; for ( int i = 0 ; i < N ; i ++ ) { diff -= arr [ i ] ; } if ( diff % 2 == 0 ) { System . out . println ( " A " ) ; } else { System . out . println ( " B " ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 } ; int N = arr . length ; check@@ Win@@ ner ( arr , N ) ; } }
Program to check if a number can be expressed as an even power of 2 or not 9942 | import java . io . * ; class GF@@ G { static boolean check@@ Even@@ Power ( long N ) { if ( ( N & ( N - 1 ) ) != 0 ) return false ; N = N & 0x5@@ 5555@@ 555 ; return ( N > 0 ) ; } public static void main ( String [ ] args ) { long N = 4 ; System . out . println ( check@@ Even@@ Power ( N ) ? 1 : 0 ) ; } }
Maximum sum of K 9954 | import java . util . * ; class GF@@ G { static int distinct ( int arr [ ] , int n ) { Set < Integer > set = new HashSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { set . add ( arr [ i ] ) ; } return set . size ( ) ; } static int max@@ Sub@@ Sum ( int arr [ ] , int n , int k , int total@@ Distin@@ ct ) { if ( k > n ) return 0 ; int max = 0 , sum = 0 ; for ( int i = 0 ; i < n - k + 1 ; i ++ ) { sum = 0 ; Set < Integer > set = new HashSet < > ( ) ; for ( int j = i ; j < i + k ; j ++ ) { sum += arr [ j ] ; set . add ( arr [ j ] ) ; } if ( set . size ( ) == total@@ Distin@@ ct ) max = Math . max ( sum , max ) ; } return max ; } public static void main ( String args [ ] ) { int arr [ ] = { 7 , 7 , 2 , 4 , 2 , 7 , 4 , 6 , 6 , 6 } ; int K = 6 ; int N = arr . length ; int total@@ Distin@@ ct = distinct ( arr , N ) ; System . out . println ( max@@ Sub@@ Sum ( arr , N , K , total@@ Distin@@ ct ) ) ; } }
Partition array into two sub@@ arrays with every element in the right sub@@ array strictly greater than every element in left sub@@ array 9963 | import java . util . * ; class GF@@ G { static void partition@@ Array ( int a [ ] , int n ) { int min [ ] = new int [ n ] ; int mini = Integer . MAX_VALUE ; for ( int i = n - 1 ; i >= 0 ; i -- ) { mini = Math . min ( mini , a [ i ] ) ; min [ i ] = mini ; } int max@@ i = Integer . MIN_VALUE ; int ind = - 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { max@@ i = Math . max ( max@@ i , a [ i ] ) ; if ( max@@ i < min [ i + 1 ] ) { ind = i ; break ; } } if ( ind != - 1 ) { for ( int i = 0 ; i <= ind ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; System . out . println ( ) ; for ( int i = ind + 1 ; i < n ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; } else System . out . println ( " Imp@@ ossible " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 3 , 2 , 7 , 9 } ; int N = arr . length ; partition@@ Array ( arr , N ) ; } }
Count ways to represent an integer as an exponent 9979 | import java . util . * ; class GF@@ G { static int gcd ( int a , int b ) { while ( b > 0 ) { int rem = a % b ; a = b ; b = rem ; } return a ; } static int count@@ NumberOf@@ W@@ ays ( int n ) { if ( n == 1 ) return - 1 ; int g = 0 ; int power = 0 ; while ( n % 2 == 0 ) { power ++ ; n /= 2 ; } g = gcd ( g , power ) ; for ( int i = 3 ; i <= ( int ) Math . sqrt ( n ) ; i += 2 ) { power = 0 ; while ( n % i == 0 ) { power ++ ; n /= i ; } g = gcd ( g , power ) ; } if ( n > 2 ) g = gcd ( g , 1 ) ; int ways = 1 ; power = 0 ; while ( g % 2 == 0 ) { g /= 2 ; power ++ ; } ways *= ( power + 1 ) ; for ( int i = 3 ; i <= ( int ) Math . sqrt ( g ) ; i += 2 ) { power = 0 ; while ( g % i == 0 ) { power ++ ; g /= i ; } ways *= ( power + 1 ) ; } if ( g > 2 ) ways *= 2 ; return ways ; } public static void main ( String [ ] args ) { int N = 64 ; System . out . print ( count@@ NumberOf@@ W@@ ays ( N ) ) ; } }
Count of Oct@@ al numbers upto N digits 10970 | public class GF@@ G { static int count ( int N ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += 7 * Math . pow ( 8 , i - 1 ) ; } return sum ; } public static void main ( String [ ] args ) { int N = 4 ; System . out . println ( count ( N ) ) ; } }
Maxim@@ ize value of ( a + b ) such that ( a * a 10978 | class GF@@ G { static int maxValue ( int n ) { return n ; } public static void main ( String [ ] args ) { int n = 1 ; System . out . print ( maxValue ( n ) ) ; } }
Length of S@@ malle@@ st sub@@ array in range 1 to N with sum greater than a given value 11007 | class GF@@ G { static int using@@ Binary@@ Search ( int start , int end , int N , int S ) { if ( start >= end ) return start ; int mid = start + ( end - start ) / 2 ; int total@@ Sum = ( N * ( N + 1 ) ) / 2 ; int mid@@ Sum = ( mid * ( mid + 1 ) ) / 2 ; if ( ( total@@ Sum - mid@@ Sum ) <= S ) { return using@@ Binary@@ Search ( start , mid , N , S ) ; } return using@@ Binary@@ Search ( mid + 1 , end , N , S ) ; } public static void main ( String [ ] args ) { int N , S ; N = 5 ; S = 11 ; System . out . println ( N - using@@ Binary@@ Search ( 1 , N , N , S ) + 1 ) ; } }
Check if Sum and XOR of all elements of array is equal 11013 | class GF@@ G { static void equal_@@ xor_@@ sum ( int arr [ ] , int n ) { int Sum = 0 ; int Xor = 0 ; for ( int i = 0 ; i < n ; i ++ ) { Sum = Sum + arr [ i ] ; Xor = Xor ^ arr [ i ] ; } if ( Sum == Xor ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 6 , 3 , 7 , 10 } ; int n = arr . length ; equal_@@ xor_@@ sum ( arr , n ) ; } }
Reduce a number to 1 by performing given operations | Set 2 11019 | class GF@@ G { static int set_@@ bits ( int n ) { int count = 0 ; while ( n > 0 ) { count += n % 2 ; n /= 2 ; } return count ; } static int min@@ Steps ( int n ) { int ans = 0 ; while ( n != 1 ) { if ( n % 2 == 0 ) n /= 2 ; else if ( n == 3 || set_@@ bits ( n - 1 ) < set_@@ bits ( n + 1 ) ) n -- ; else n ++ ; ans ++ ; } return ans ; } public static void main ( String [ ] args ) { int n = 15 ; System . out . print ( min@@ Steps ( n ) ) ; } }
Find two numbers with the given LC@@ M and minimum possible difference 11024 | class GF@@ G { static int l@@ cm ( int a , int b ) { return ( a / __@@ gcd ( a , b ) * b ) ; } static int __@@ gcd ( int a , int b ) { return b == 0 ? a : __@@ gcd ( b , a % b ) ; } static void find@@ Num@@ s ( int x ) { int ans = - 1 ; for ( int i = 1 ; i <= Math . sqrt ( x ) ; i ++ ) { if ( x % i == 0 && l@@ cm ( i , x / i ) == x ) { ans = i ; } } System . out . print ( ans + " ▁ " + ( x / ans ) ) ; } public static void main ( String [ ] args ) { int x = 12 ; find@@ Num@@ s ( x ) ; } }
Remove one element to get minimum OR value 11055 | class GF@@ G { static int min@@ OR ( int [ ] arr , int n ) { if ( n == 1 ) return 0 ; int [ ] pre = new int [ n ] ; int [ ] su@@ f = new int [ n ] ; pre [ 0 ] = arr [ 0 ] ; su@@ f [ n - 1 ] = arr [ n - 1 ] ; for ( int i = 1 ; i < n ; i ++ ) pre [ i ] = ( pre [ i - 1 ] arr [ i ] ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) su@@ f [ i ] = ( su@@ f [ i + 1 ] arr [ i ] ) ; int ans = Math . min ( pre [ n - 2 ] , su@@ f [ 1 ] ) ; for ( int i = 1 ; i < n - 1 ; i ++ ) ans = Math . min ( ans , ( pre [ i - 1 ] su@@ f [ i + 1 ] ) ) ; return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 } ; int n = arr . length ; System . out . print ( min@@ OR ( arr , n ) ) ; } }
Check if a number is Eu@@ ler P@@ se@@ ud@@ op@@ ri@@ me 11109 | class GF@@ G { static int find@@ Cnt ( int [ ] arr , int n , int k ) { int ret = 0 ; int i = 0 ; while ( i < n ) { int j = i + 1 ; while ( j < n && arr [ j ] >= arr [ j - 1 ] ) j ++ ; int x = Math . max ( 0 , j - i - k + 1 ) ; ret += ( x * ( x + 1 ) ) / 2 ; i = j ; } return ret ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 4 , 3 , 2 , 1 } ; int n = arr . length ; int k = 2 ; System . out . println ( find@@ Cnt ( arr , n , k ) ) ; } }
Number of K '@@ s such that the given array can be divided into two sets satis@@ fying the given conditions 11121 | import java . util . * ; class GF@@ G { static int two_@@ sets ( int a [ ] , int n ) { Arrays . sort ( a ) ; return a [ n / 2 ] - a [ ( n / 2 ) - 1 ] ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 4 , 4 , 6 , 7 , 9 } ; int n = a . length ; System . out . println ( two_@@ sets ( a , n ) ) ; } }
Find the K@@ th position element of the given sequence 11128 | class GF@@ G { static int k@@ th@@ Num ( int n , int k ) { int a = ( n + 1 ) / 2 ; if ( k > a ) return ( 2 * ( k - a ) ) ; return ( 2 * k - 1 ) ; } public static void main ( String [ ] args ) { int n = 7 , k = 7 ; System . out . println ( k@@ th@@ Num ( n , k ) ) ; } }
Number of colo@@ ured 0 '@@ s in an N 11139 | class GF@@ G { static int count ( int n ) { return n * ( 3 * n - 1 ) / 2 ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( count ( n ) ) ; } }
Find the deleted value from the array when average of original elements is given 11149 | class GF@@ G { static int find@@ Missing ( int arr [ ] , int n , int k , int avg ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int num = ( avg * ( n + k ) ) - sum ; int den = k ; if ( num % den != 0 ) return - 1 ; return ( int ) ( num / den ) ; } public static void main ( String [ ] args ) { int k = 3 , avg = 4 ; int arr [ ] = { 2 , 7 , 3 } ; int n = arr . length ; System . out . println ( find@@ Missing ( arr , n , k , avg ) ) ; } }
Sum of values of all possible non 11168 | class GF@@ G { static int sum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } sum = sum * ( int ) Math . pow ( 2 , n - 1 ) ; return sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 1 , 5 , 6 } ; int n = arr . length ; System . out . println ( sum ( arr , n ) ) ; } }
Minimum absolute difference between N and any power of 2 11173 | import java . util . * ; class GF@@ G { static int prev@@ Power@@ of@@ 2 ( int n ) { int p = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ; return ( int ) Math . pow ( 2 , p ) ; } static int next@@ PowerOf@@ 2 ( int n ) { int p = 1 ; if ( ( n == 0 ) && ! ( ( n & ( n - 1 ) ) == 0 ) ) return n ; while ( p < n ) p <<= 1 ; return p ; } static int min@@ Diff ( int n ) { int low = prev@@ Power@@ of@@ 2 ( n ) ; int high = next@@ PowerOf@@ 2 ( n ) ; return Math . min ( n - low , high - n ) ; } public static void main ( String [ ] args ) { int n = 6 ; System . out . println ( min@@ Diff ( n ) ) ; } }
Check whether N is a Factor@@ ion or not 11181 | class GF@@ G { static int MAX = 10 ; static boolean is@@ Factor@@ ion ( int n ) { int fact [ ] = new int [ MAX ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i < MAX ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ; int org = n ; int sum = 0 ; while ( n > 0 ) { int d = n % 10 ; sum += fact [ d ] ; n /= 10 ; } if ( sum == org ) return true ; return false ; } public static void main ( String [ ] args ) { int n = 405@@ 85 ; if ( is@@ Factor@@ ion ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
Color all boxes in line such that every M consecutive boxes are unique 11182 | class GF@@ G { static final int MOD = 100000000@@ 7 ; static int mod@@ Fact ( int n , int m ) { int result = 1 ; for ( int i = 1 ; i <= m ; i ++ ) result = ( result * i ) % MOD ; return result ; } public static void main ( String [ ] args ) { int n = 3 , m = 2 ; System . out . println ( mod@@ Fact ( n , m ) ) ; } }
Maximum count of common di@@ visors of A and B such that all are co 11185 | class GF@@ G { static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } static int max@@ Common@@ Factors ( int a , int b ) { int __@@ gcd = gcd ( a , b ) ; int ans = 1 ; for ( int i = 2 ; i * i <= __@@ gcd ; i ++ ) { if ( __@@ gcd % i == 0 ) { ans ++ ; while ( __@@ gcd % i == 0 ) __@@ gcd /= i ; } } if ( __@@ gcd != 1 ) ans ++ ; return ans ; } public static void main ( String [ ] args ) { int a = 12 , b = 18 ; System . out . println ( max@@ Common@@ Factors ( a , b ) ) ; } }
Count total unset bits in all the numbers from 1 to N 11216 | class GF@@ G { static int count@@ Un@@ set@@ Bits ( int n ) { int cnt = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int temp = i ; while ( temp > 0 ) { if ( temp % 2 == 0 ) { cnt = cnt + 1 ; } temp = temp / 2 ; } } return cnt ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( count@@ Un@@ set@@ Bits ( n ) ) ; } }
Check if the sum of digits of number is di@@ visible by all of its digits 11223 | class GF@@ G { static boolean is@@ Di@@ visible ( long n ) { long temp = n ; int sum = 0 ; while ( n != 0 ) { int digit = ( int ) n % 10 ; sum += digit ; n /= 10 ; } n = temp ; while ( n != 0 ) { int digit = ( int ) n % 10 ; if ( sum % digit != 0 ) return false ; n /= 10 ; } return true ; } public static void main ( String [ ] args ) { long n = 123 ; if ( is@@ Di@@ visible ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
Maximum items that can be bou@@ ght with the given type of coins 11227 | import java . io . * ; class GF@@ G { static int CO@@ ST = 3 ; static int max@@ Items ( int x , int y , int z ) { int type1 = x / CO@@ ST ; x %= CO@@ ST ; int type2 = y / CO@@ ST ; y %= CO@@ ST ; int type@@ 3 = z / CO@@ ST ; z %= CO@@ ST ; int type@@ 4 = Math . min ( x , Math . min ( y , z ) ) ; int max@@ Items = type1 + type2 + type@@ 3 + type@@ 4 ; return max@@ Items ; } public static void main ( String [ ] args ) { int x = 4 , y = 5 , z = 6 ; System . out . println ( max@@ Items ( x , y , z ) ) ; } }
Number of Sub@@ sequences with Even and Odd Sum | Set 2 11254 | import java . util . * ; class GF@@ G { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static pair count@@ Sum ( int arr [ ] , int n ) { int NumberOf@@ O@@ d@@ ds = 0 , NumberOf@@ Ev@@ ens = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 1 ) NumberOf@@ O@@ d@@ ds ++ ; NumberOf@@ Ev@@ ens = n - NumberOf@@ O@@ d@@ ds ; int NumberOf@@ O@@ dd@@ Sub@@ sequences = ( 1 << NumberOf@@ Ev@@ ens ) * ( 1 << ( NumberOf@@ O@@ d@@ ds - 1 ) ) ; int NumberOf@@ Even@@ Sub@@ sequences = ( 1 << n ) - 1 - NumberOf@@ O@@ dd@@ Sub@@ sequences ; return new pair ( NumberOf@@ Even@@ Sub@@ sequences , NumberOf@@ O@@ dd@@ Sub@@ sequences ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 2 , 3 } ; int n = arr . length ; pair ans = count@@ Sum ( arr , n ) ; System . out . print ( " Even@@ Sum ▁ = ▁ " + ans . first ) ; System . out . print ( " ▁ O@@ dd@@ Sum ▁ = ▁ " + ans . second ) ; } }
Find prime numbers in the first half and second half of an array 11319 | import java . util . * ; class GF@@ G { static boolean prime ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } static void pri@@ me_@@ range ( int start , int end , int [ ] a ) { for ( int i = start ; i < end ; i ++ ) { if ( prime ( a [ i ] ) ) System . out . print ( a [ i ] + " ▁ " ) ; } } static void Print ( int arr [ ] , int n ) { System . out . print ( " Prime ▁ numbers ▁ in ▁ the ▁ first ▁ half ▁ are ▁ " ) ; pri@@ me_@@ range ( 0 , n / 2 , arr ) ; System . out . println ( ) ; System . out . print ( " Prime ▁ numbers ▁ in ▁ the ▁ second ▁ half ▁ are ▁ " ) ; pri@@ me_@@ range ( n / 2 , n , arr ) ; System . out . println ( ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 5 , 10 , 15 , 17 , 21 , 23 } ; int n = arr . length ; Print ( arr , n ) ; } }
Removing a number from array without changing its arithmetic mean 11328 | import java . io . * ; class GF@@ G { static int Find@@ Element ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + a [ i ] ; if ( sum % n == 0 ) { int m = sum / n ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] == m ) return m ; } return - 1 ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = a . length ; System . out . print ( Find@@ Element ( a , n ) ) ; } }
Count of N digit numbers possible which satisfy the given conditions 11339 | import java . io . * ; class GF@@ G { static int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } static int Count_@@ number ( int N ) { return ( N * fact ( N ) ) ; } public static void main ( String [ ] args ) { int N = 2 ; System . out . print ( Count_@@ number ( N ) ) ; } }
Number of hours after which the second person moves ahead of the first person if they travel at a given speed 11349 | import java . io . * ; class GF@@ G { static int find@@ Hours ( int a , int b , int k ) { if ( a >= b ) return - 1 ; int time = k / ( b - a ) ; time = time + 1 ; return time ; } public static void main ( String [ ] args ) { int a = 4 , b = 5 , k = 1 ; System . out . println ( find@@ Hours ( a , b , k ) ) ; } }
Number of ways of distribu@@ ting N identical objects in R distinct groups with no groups empty 11352 | import java . io . * ; class GF@@ G { static int n@@ cr ( int n , int r ) { int ans = 1 ; for ( int i = 1 ; i <= r ; i += 1 ) { ans *= ( n - r + i ) ; ans /= i ; } return ans ; } static int NoOf@@ Distribu@@ tions ( int N , int R ) { return n@@ cr ( N - 1 , R - 1 ) ; } public static void main ( String [ ] args ) { int N = 4 ; int R = 3 ; System . out . println ( NoOf@@ Distribu@@ tions ( N , R ) ) ; } }
Find the minimum number of elements that should be removed to make an array good 11371 | import java . util . Collections ; import java . util . Vector ; class GF@@ G { static int Min@@ Remove ( int [ ] a , int n , int k ) { int [ ] cnt = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) cnt [ 0 ] ++ ; else if ( cnt [ a [ i ] - 1 ] > 0 ) { cnt [ a [ i ] - 1 ] -- ; cnt [ a [ i ] ] ++ ; } } return n - ( k * cnt [ k - 1 ] ) ; } public static void main ( String [ ] args ) { int a [ ] = { 0 , 1 , 2 , 3 , 4 , 0 , 1 , 0 , 1 , 2 , 3 , 4 } ; int k = 5 ; int n = a . length ; System . out . println ( Min@@ Remove ( a , n , k ) ) ; } }
Print Lower He@@ ss@@ en@@ berg matrix of order N 11383 | class GF@@ G { static void Lower@@ He@@ ss@@ en@@ ber@@ g@@ Matrix ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( j > i + 1 ) System . out . print ( '0' + " ▁ " ) ; else { System . out . printf ( " % .0f " , Math . random ( ) * 10 ) ; System . out . print ( " ▁ " ) ; } } System . out . println ( "@@ NEW_@@ LINE@@ "@@ )@@ ; } } public static void main ( String [ ] args ) { int n = 4 ; Lower@@ He@@ ss@@ en@@ ber@@ g@@ Matrix ( n ) ; } }
Count Distin@@ ct Rect@@ angles in N * N Ch@@ ess@@ board 11387 | class Rectangle { static int count ( int N ) { int a = 0 ; a = ( N * ( N + 1 ) ) / 2 ; return a ; } public static void main ( String args [ ] ) { int n = 4 ; System . out . print ( count ( n ) ) ; } }
Sum of all mer@@ sen@@ ne numbers present in an array 11389 | class GF@@ G { static boolean is@@ Mer@@ sen@@ ne ( int n ) { while ( n != 0 ) { int r = n % 2 ; if ( r == 0 ) return false ; n /= 2 ; } return true ; } static int sum@@ Of@@ Mer@@ sen@@ ne ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 && is@@ Mer@@ sen@@ ne ( arr [ i ] ) ) { sum += arr [ i ] ; } } return sum ; } public static void main ( String [ ] args ) { int [ ] arr = { 17 , 6 , 7 , 63 , 3 } ; int n = arr . length ; System . out . print ( sum@@ Of@@ Mer@@ sen@@ ne ( arr , n ) ) ; } }
Total number of days taken to complete the task if after certain days one person leaves 11404 | import java . io . * ; class GF@@ G { static int numberOf@@ Days ( int a , int b , int n ) { int Days = b * ( n + a ) / ( a + b ) ; return Days ; } public static void main ( String [ ] args ) { int a = 10 , b = 20 , n = 5 ; System . out . println ( numberOf@@ Days ( a , b , n ) ) ; } }
Maximum number of people that can be killed with strength P 11417 | class GF@@ G { static long square@@ Series ( long n ) { return ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; } static long max@@ People ( long n ) { long low = 0 ; long high = 1000000@@ L ; long ans = 0L ; while ( low <= high ) { long mid = low + ( ( high - low ) / 2 ) ; long value = square@@ Series ( mid ) ; if ( value <= n ) { ans = mid ; low = mid + 1 ; } else { high = mid - 1 ; } } return ans ; } public static void main ( String [ ] args ) { long p = 14 ; System . out . println ( max@@ People ( p ) ) ; } }
Check whether product of integers from a to b is positive , negative or zero 11425 | import java . io . * ; class GF@@ G { static void solve ( long a , long b ) { if ( a > 0 && b > 0 ) { System . out . println ( " Positive " ) ; } else if ( a <= 0 && b >= 0 ) { System . out . println ( " Zero " ) ; } else { long n = Math . abs ( a - b ) + 1 ; if ( n % 2 == 0 ) { System . out . println ( " Positive " ) ; } else { System . out . println ( " Negative " ) ; } } } public static void main ( String [ ] args ) { int a = - 10 , b = - 2 ; solve ( a , b ) ; } }
Find sum of factor@@ i@@ als in an array 11461 | class GF@@ G { static int factorial ( int n ) { int f = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { f *= i ; } return f ; } static int sum@@ Fac@@ tori@@ al ( int [ ] arr , int n ) { int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s += factorial ( arr [ i ] ) ; } return s ; } public static void main ( String [ ] args ) { int [ ] arr = { 7 , 3 , 5 , 4 , 8 } ; int n = arr . length ; System . out . println ( sum@@ Fac@@ tori@@ al ( arr , n ) ) ; } }
Check if given two straight lines are identical or not 11475 | class GF@@ G { static void id@@ str@@ t ( double a1 , double b1 , double c1 , double a2 , double b2 , double c2 ) { if ( ( a1 / a2 == b1 / b2 ) && ( a1 / a2 == c1 / c2 ) && ( b1 / b2 == c1 / c2 ) ) System . out . println ( " The ▁ given ▁ straight " + " ▁ lines ▁ are ▁ identical " ) ; else System . out . println ( " The ▁ given ▁ straight " + " ▁ lines ▁ are ▁ not ▁ identical " ) ; } public static void main ( String [ ] args ) { double a1 = - 2 , b1 = 4 , c1 = 3 , a2 = - 6 , b2 = 12 , c2 = 9 ; id@@ str@@ t ( a1 , b1 , c1 , a2 , b2 , c2 ) ; } }
S@@ malle@@ st N digit number which is a multiple of 5 11488 | class GF@@ G { static int smalle@@ st@@ Multiple ( int n ) { if ( n == 1 ) return 5 ; return ( int ) ( Math . pow ( 10 , n - 1 ) ) ; } public static void main ( String args [ ] ) { int n = 4 ; System . out . println ( smalle@@ st@@ Multiple ( n ) ) ; } }
Number of ways of choo@@ sing K equal sub@@ strings of any length for every query 11515 | import java . util . HashMap ; class GF@@ G { static int maxlen = 100 ; public static void generate@@ Sub@@ Strings ( String s , HashMap < String , Integer > mp@@ p ) { int l = s . length ( ) ; for ( int i = 0 ; i < l ; i ++ ) { String temp = " " ; for ( int j = i ; j < l ; j ++ ) { temp += s . charAt ( j ) ; if ( mp@@ p . containsKey ( temp ) ) { int x = mp@@ p . get ( temp ) ; mp@@ p . put ( temp , ++ x ) ; } else mp@@ p . put ( temp , 1 ) ; } } } public static void bin@@ omi@@ al@@ Coeff ( int [ ] [ ] C ) { int i , j ; for ( i = 1 ; i < 100 ; i ++ ) { for ( j = 0 ; j < 100 ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } } public static int answer@@ Query ( HashMap < String , Integer > mp@@ p , int [ ] [ ] C , int k ) { int ans = 0 ; for ( HashMap . Entry < String , Integer > entry : mp@@ p . entrySet ( ) ) { if ( entry . getValue ( ) >= k ) ans += C [ entry . getValue ( ) ] [ k ] ; } return ans ; } public static void main ( String [ ] args ) { String s = " a@@ ab@@ aa@@ b " ; HashMap < String , Integer > mp@@ p = new HashMap < > ( ) ; generate@@ Sub@@ Strings ( s , mp@@ p ) ; int [ ] [ ] C = new int [ maxlen ] [ maxlen ] ; bin@@ omi@@ al@@ Coeff ( C ) ; int [ ] queries = { 2 , 3 , 4 } ; int q = queries . length ; for ( int i = 0 ; i < q ; i ++ ) System . out . println ( answer@@ Query ( mp@@ p , C , queries [ i ] ) ) ; } }
XOR of all the elements in the given range [ L , R ] 11530 | class GF@@ G { static long compute@@ XOR ( int n ) { int x = n & 3 ; switch ( x ) { case 0 : return n ; case 1 : return 1 ; case 2 : return n + 1 ; case 3 : return 0 ; } return 0 ; } public static void main ( String args [ ] ) { int l = 1 , r = 4 ; System . out . println ( compute@@ XOR ( r ) ^ compute@@ XOR ( l - 1 ) ) ; } }
Sum of Fi@@ bon@@ ac@@ ci Numbers in a range 11545 | import java . lang . Math ; class GF@@ G { static int fi@@ b ( int n ) { double phi = ( 1 + Math . sqrt ( 5 ) ) / 2 ; return ( int ) Math . round ( Math . pow ( phi , n ) / Math . sqrt ( 5 ) ) ; } static int calculate@@ Sum ( int l , int r ) { int sum = 0 ; for ( int i = l ; i <= r ; i ++ ) sum += fi@@ b ( i ) ; return sum ; } public static void main ( String [ ] args ) { int l = 4 , r = 8 ; System . out . println ( calculate@@ Sum ( l , r ) ) ; } }
Count of all N digit numbers such that num + Rev ( num ) = 10 ^ N 11584 | class GF@@ G { static int count@@ Numbers ( int n ) { if ( n % 2 == 1 ) return 0 ; return ( 9 * ( int ) Math . pow ( 10 , n / 2 - 1 ) ) ; } public static void main ( String args [ ] ) { int n = 2 ; System . out . print ( count@@ Numbers ( n ) ) ; } }
Probability of A win@@ ning the match when individual probabilities of hit@@ ting the target given 11615 | class GF@@ G { static double get@@ Probability ( int a , int b , int c , int d ) { double p = ( double ) a / ( double ) b ; double q = ( double ) c / ( double ) d ; double ans = p * ( 1 / ( 1 - ( 1 - q ) * ( 1 - p ) ) ) ; return ans ; } public static void main ( String [ ] args ) { int a = 1 , b = 2 , c = 10 , d = 11 ; System . out . printf ( " % .@@ 5f " , get@@ Probability ( a , b , c , d ) ) ; } }
Sum of minimum element of all sub 11630 | class Gf@@ G { static int find@@ Min@@ Sum ( int arr [ ] , int n ) { int oc@@ c = n - 1 , sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] * ( int ) Math . pow ( 2 , oc@@ c ) ; oc@@ c -- ; } return sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 4 , 5 } ; int n = arr . length ; System . out . println ( find@@ Min@@ Sum ( arr , n ) ) ; } }
Sum of all Sub@@ matrices of a Given Matrix 11652 | class GF@@ G { static final int n = 3 ; static int matrix@@ Sum ( int arr [ ] [ ] ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int top_@@ left = ( i + 1 ) * ( j + 1 ) ; int bottom_@@ right = ( n - i ) * ( n - j ) ; sum += ( top_@@ left * bottom_@@ right * arr [ i ] [ j ] ) ; } } return sum ; } public static void main ( String [ ] args ) { int arr [ ] [ ] = { { 1 , 1 , 1 } , { 1 , 1 , 1 } , { 1 , 1 , 1 } } ; System . out . println ( matrix@@ Sum ( arr ) ) ; } }
Count primes that can be expressed as sum of two consecutive primes and 1 11664 | import java . util . * ; class Gf@@ G { static int N = 10000@@ 5 ; static boolean i@@ spri@@ me [ ] = new boolean [ N ] ; static boolean can [ ] = new boolean [ N ] ; static ArrayList < Integer > Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( ) { for ( int a = 0 ; a < i@@ spri@@ me . length ; a ++ ) { i@@ spri@@ me [ a ] = true ; } for ( int p = 2 ; p * p < N ; p ++ ) { if ( i@@ spri@@ me [ p ] == true ) { for ( int i = p * p ; i < N ; i += p ) i@@ spri@@ me [ i ] = false ; } } ArrayList < Integer > primes = new ArrayList < Integer > ( ) ; for ( int i = 2 ; i < N ; i ++ ) if ( i@@ spri@@ me [ i ] ) primes . add ( i ) ; return primes ; } static int Pri@@ me_@@ Numbers ( int n ) { ArrayList < Integer > primes = Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( ) ; for ( int i = 0 ; i < ( int ) ( primes . size ( ) ) - 1 ; i ++ ) if ( primes . get ( i ) + primes . get ( i + 1 ) + 1 < N ) can [ primes . get ( i ) + primes . get ( i + 1 ) + 1 ] = true ; int ans = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( can [ i ] && i@@ spri@@ me [ i ] == true ) { ans ++ ; } } return ans ; } public static void main ( String [ ] args ) { int n = 50 ; System . out . println ( Pri@@ me_@@ Numbers ( n ) ) ; } }
Mid@@ point ellipse drawing algorithm 11721 | import java . util . * ; import java . text . DecimalFormat ; class GF@@ G { static void mid@@ p@@ te@@ llip@@ se ( float rx , float ry , float xc , float yc ) { float dx , dy , d1 , d2 , x , y ; x = 0 ; y = ry ; d1 = ( ry * ry ) - ( rx * rx * ry ) + ( 0.25f * rx * rx ) ; dx = 2 * ry * ry * x ; dy = 2 * rx * rx * y ; DecimalFormat df = new DecimalFormat ( " # , # # # , # #@@ 0.0000@@ 0" ) ; while ( dx < dy ) { System . out . println ( df . format ( ( x + xc ) ) + " , ▁ " + df . format ( ( y + yc ) ) ) ; System . out . println ( df . format ( ( - x + xc ) ) + " , ▁ " + df . format ( ( y + yc ) ) ) ; System . out . println ( df . format ( ( x + xc ) ) + " , ▁ " + df . format ( ( - y + yc ) ) ) ; System . out . println ( df . format ( ( - x + xc ) ) + " , ▁ " + df . format ( ( - y + yc ) ) ) ; if ( d1 < 0 ) { x ++ ; dx = dx + ( 2 * ry * ry ) ; d1 = d1 + dx + ( ry * ry ) ; } else { x ++ ; y -- ; dx = dx + ( 2 * ry * ry ) ; dy = dy - ( 2 * rx * rx ) ; d1 = d1 + dx - dy + ( ry * ry ) ; } } d2 = ( ( ry * ry ) * ( ( x + 0.5f ) * ( x + 0.5f ) ) ) + ( ( rx * rx ) * ( ( y - 1 ) * ( y - 1 ) ) ) - ( rx * rx * ry * ry ) ; while ( y >= 0 ) { System . out . println ( df . format ( ( x + xc ) ) + " , ▁ " + df . format ( ( y + yc ) ) ) ; System . out . println ( df . format ( ( - x + xc ) ) + " , ▁ " + df . format ( ( y + yc ) ) ) ; System . out . println ( df . format ( ( x + xc ) ) + " , ▁ " + df . format ( ( - y + yc ) ) ) ; System . out . println ( df . format ( ( - x + xc ) ) + " , ▁ " + df . format ( ( - y + yc ) ) ) ; if ( d2 > 0 ) { y -- ; dy = dy - ( 2 * rx * rx ) ; d2 = d2 + ( rx * rx ) - dy ; } else { y -- ; x ++ ; dx = dx + ( 2 * ry * ry ) ; dy = dy - ( 2 * rx * rx ) ; d2 = d2 + dx - dy + ( rx * rx ) ; } } } public static void main ( String args [ ] ) { mid@@ p@@ te@@ llip@@ se ( 10 , 15 , 50 , 50 ) ; } }
Find the final X and Y when they are Alter@@ ing under given condition 11727 | import java . io . * ; class GF@@ G { static void alter ( long x , long y ) { while ( true ) { if ( x == 0 y == 0 ) break ; if ( x >= 2 * y ) x = x % ( 2 * y ) ; else if ( y >= 2 * x ) y = y % ( 2 * x ) ; else break ; } System . out . println ( " X ▁ = ▁ " + x + " , ▁ " + " Y ▁ = ▁ " + y ) ; } public static void main ( String [ ] args ) { long x = 12 , y = 5 ; alter ( x , y ) ; } }
Per@@ mutations of string such that no two vo@@ w@@ els are adjacent 11781 | class GF@@ G { static int factorial ( int n ) { int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) fact = fact * i ; return fact ; } static int n@@ cr ( int n , int r ) { return factorial ( n ) / ( factorial ( r ) * factorial ( n - r ) ) ; } static int count@@ W@@ ays ( String str ) { int freq [ ] = new int [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { freq [ i ] = 0 ; } int n@@ vo@@ w@@ els = 0 , n@@ con@@ son@@ ants = 0 ; int v@@ places , c@@ ways , v@@ ways ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) ++ freq [ str . charAt ( i ) - ' a ' ] ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( i == 0 i == 4 i == 8 i == 14 i == 20 ) n@@ vo@@ w@@ els += freq [ i ] ; else n@@ con@@ son@@ ants += freq [ i ] ; } v@@ places = n@@ con@@ son@@ ants + 1 ; c@@ ways = factorial ( n@@ con@@ son@@ ants ) ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( i != 0 && i != 4 && i != 8 && i != 14 && i != 20 && freq [ i ] > 1 ) { c@@ ways = c@@ ways / factorial ( freq [ i ] ) ; } } v@@ ways = n@@ cr ( v@@ places , n@@ vo@@ w@@ els ) * factorial ( n@@ vo@@ w@@ els ) ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( i == 0 i == 4 i == 8 i == 14 i == 20 && freq [ i ] > 1 ) { v@@ ways = v@@ ways / factorial ( freq [ i ] ) ; } } return c@@ ways * v@@ ways ; } public static void main ( String [ ] args ) { String str = " permutation " ; System . out . println ( count@@ W@@ ays ( str ) ) ; } }
Sum of elements in an array having prime frequency 11866 | import java . util . * ; class GF@@ G { static void Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( boolean prime [ ] , int p_@@ size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_@@ size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_@@ size ; i += p ) prime [ i ] = false ; } } } static int sum@@ Of@@ Elements ( int arr [ ] , int n ) { boolean prime [ ] = new boolean [ n + 1 ] ; Arrays . fill ( prime , true ) ; Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( prime , n + 1 ) ; int i , j ; HashMap < Integer , Integer > m = new HashMap < > ( ) ; for ( i = 0 ; i < n ; i ++ ) { if ( m . containsKey ( arr [ i ] ) ) m . put ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ; else m . put ( arr [ i ] , 1 ) ; } int sum = 0 ; for ( Map . Entry < Integer , Integer > entry : m . entrySet ( ) ) { int key = entry . getKey ( ) ; int value = entry . getValue ( ) ; if ( prime [ value ] ) { sum += ( key ) ; } } return sum ; } public static void main ( String args [ ] ) { int arr [ ] = { 5 , 4 , 6 , 5 , 4 , 6 } ; int n = arr . length ; System . out . println ( sum@@ Of@@ Elements ( arr , n ) ) ; } }
Count pairs from two arrays whose modulo operation yields K 11902 | import java . util . * ; class GF@@ G { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static int total@@ Pairs ( int [ ] ar@@ r1 , int [ ] ar@@ r2 , int K , int n , int m ) { HashSet < pair > s = new HashSet < pair > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( ar@@ r1 [ i ] > ar@@ r2 [ j ] ) { if ( ar@@ r1 [ i ] % ar@@ r2 [ j ] == K ) s . add ( new pair ( ar@@ r1 [ i ] , ar@@ r2 [ j ] ) ) ; } else { if ( ar@@ r2 [ j ] % ar@@ r1 [ i ] == K ) s . add ( new pair ( ar@@ r2 [ j ] , ar@@ r1 [ i ] ) ) ; } } } return s . size ( ) ; } public static void main ( String [ ] args ) { int [ ] ar@@ r1 = { 8 , 3 , 7 , 50 } ; int [ ] ar@@ r2 = { 5 , 1 , 10 , 4 } ; int K = 3 ; int n = ar@@ r1 . length ; int m = ar@@ r2 . length ; System . out . println ( total@@ Pairs ( ar@@ r1 , ar@@ r2 , K , n , m ) ) ; } }
S@@ malle@@ st prime number missing in an array 11915 | import java . util . * ; class GF@@ G { static Vector < Integer > find@@ Prime ( int MAX ) { boolean pm [ ] = new boolean [ MAX + 1 ] ; for ( int i = 0 ; i < pm . length ; i ++ ) pm [ i ] = true ; pm [ 0 ] = pm [ 1 ] = false ; for ( int i = 2 ; i <= MAX ; i ++ ) if ( pm [ i ] ) for ( int j = 2 * i ; j <= MAX ; j += i ) pm [ j ] = false ; Vector < Integer > prime = new Vector < Integer > ( ) ; for ( int i = 0 ; i <= MAX ; i ++ ) if ( pm [ i ] ) prime . add ( i ) ; return prime ; } static int max_@@ element ( int arr [ ] ) { int max = arr [ 0 ] ; for ( int i = 0 ; i < arr . length ; i ++ ) max = Math . max ( max , arr [ i ] ) ; return max ; } static int find@@ S@@ malle@@ st ( int arr [ ] , int n ) { int MAX = max_@@ element ( arr ) ; Vector < Integer > prime = find@@ Prime ( MAX ) ; Set < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) s . add ( arr [ i ] ) ; long ans = - 1 ; for ( int i = 0 ; i < prime . size ( ) ; i ++ ) { if ( ! s . contains ( prime . get ( i ) ) ) { ans = ( prime . get ( i ) ) ; break ; } } return ( int ) ans ; } public static void main ( String args [ ] ) { int arr [ ] = { 3 , 0 , 1 , 2 , 7 } ; int n = arr . length ; if ( find@@ S@@ malle@@ st ( arr , n ) == - 1 ) System . out . print ( " No ▁ prime ▁ number ▁ missing " ) ; else System . out . print ( find@@ S@@ malle@@ st ( arr , n ) ) ; } }
Program to find the pro@@ fit or loss when CP of N items is equal to SP of M items 11922 | public class GF@@ G { static void pro@@ fit@@ Loss ( int N , int M ) { if ( N == M ) System . out . print ( " No ▁ Pro@@ fit ▁ nor ▁ Loss " ) ; else { float result = 0 ; result = ( float ) ( Math . abs ( N - M ) ) / M ; if ( N - M < 0 ) System . out . print ( " Loss ▁ = ▁ - " + result * 100 + " % " ) ; else System . out . print ( " Pro@@ fit ▁ = ▁ " + result * 100 + " % " ) ; } } public static void main ( String [ ] args ) { int N = 8 , M = 9 ; pro@@ fit@@ Loss ( N , M ) ; } }
Check whether sum of digits at odd places of a number is di@@ visible by K 11968 | import java . util . * ; class solution { static boolean Sum@@ Di@@ visible ( int n , int k ) { int sum = 0 , position = 1 ; while ( n > 0 ) { if ( position % 2 == 1 ) sum += n % 10 ; n = n / 10 ; position ++ ; } if ( sum % k == 0 ) return true ; return false ; } public static void main ( String arr [ ] ) { int n = 59@@ 24@@ 52 ; int k = 3 ; if ( Sum@@ Di@@ visible ( n , k ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
Check whether sum of digits at odd places of a number is di@@ visible by K 11969 | import java . io . * ; class GF@@ G { static boolean sum@@ Di@@ visible ( int n , int k ) { int sum = 0 ; String num = Integer . toString ( n ) ; int i ; for ( i = 0 ; i < num . length ( ) ; i ++ ) { if ( i % 2 != 0 ) { sum = sum + ( num . charAt ( i ) - '0' ) ; } } if ( sum % k == 0 ) { return true ; } else { return false ; } } public static void main ( String [ ] args ) { int n = 59@@ 24@@ 52 ; int k = 3 ; if ( sum@@ Di@@ visible ( n , k ) ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
Maximum count of equal numbers in an array after performing given operations 12011 | public class GF@@ G { static int Equal@@ Numbers ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; if ( sum % n != 0 ) return n - 1 ; return n ; } public static void main ( String args [ ] ) { int a [ ] = { 1 , 4 , 1 } ; int n = a . length ; System . out . println ( Equal@@ Numbers ( a , n ) ) ; } }
Print values of ' a ' in equation ( a + b ) <= n and a + b is di@@ visible by x 12038 | import java . io . * ; class GF@@ G { static void Possible@@ Values ( int b , int x , int n ) { int least@@ di@@ visible = ( b / x + 1 ) * x ; int flag = 1 ; while ( least@@ di@@ visible <= n ) { if ( least@@ di@@ visible - b >= 1 ) { System . out . print ( least@@ di@@ visible - b + " ▁ " ) ; least@@ di@@ visible += x ; flag = 0 ; } else break ; } if ( flag > 0 ) System . out . println ( - 1 ) ; } public static void main ( String [ ] args ) { int b = 10 , x = 6 , n = 40 ; Possible@@ Values ( b , x , n ) ; } }
Check whether the given number is Eu@@ cli@@ d Number or not 12077 | import java . util . * ; class GF@@ G { static int MAX = 10000 ; static HashSet < Integer > s = new HashSet < Integer > ( ) ; static void Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( ) { boolean [ ] prime = new boolean [ MAX ] ; Arrays . fill ( prime , true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } int product = 1 ; for ( int p = 2 ; p < MAX ; p ++ ) { if ( prime [ p ] ) { product = product * p ; s . add ( product + 1 ) ; } } } static boolean is@@ Eu@@ cli@@ d ( int n ) { if ( s . contains ( n ) ) return true ; else return false ; } public static void main ( String [ ] args ) { Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( ) ; int n = 31 ; if ( is@@ Eu@@ cli@@ d ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; n = 42 ; if ( is@@ Eu@@ cli@@ d ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
Number of solutions for x < y , where a <= x <= b and c <= y <= d and x , y are integers 12087 | import java . io . * ; class GF@@ G { static int NumberOf@@ Solutions ( int a , int b , int c , int d ) { int ans = 0 ; for ( int i = a ; i <= b ; i ++ ) if ( d >= Math . max ( c , i + 1 ) ) ans += d - Math . max ( c , i + 1 ) + 1 ; return ans ; } public static void main ( String [ ] args ) { int a = 2 , b = 3 , c = 3 , d = 4 ; System . out . println ( NumberOf@@ Solutions ( a , b , c , d ) ) ; } }
Program to find N@@ th term of series 4 , 14 , 28 , 46 , 68 , 94 , 124 , 158 , ... . . 12144 | import java . util . * ; class solution { static int n@@ th@@ Term ( int n ) { return 2 * ( int ) Math . pow ( n , 2 ) + 4 * n - 2 ; } public static void main ( String arr [ ] ) { int N = 4 ; System . out . println ( n@@ th@@ Term ( N ) ) ; } }
Sum of Area of all possible square inside a rectangle 12244 | class GF@@ G { static int calculate@@ Area@@ Sum ( int l , int b ) { int size = 1 ; int maxSize = Math . min ( l , b ) ; int total@@ Area = 0 ; for ( int i = 1 ; i <= maxSize ; i ++ ) { int total@@ Squ@@ ares = ( l - size + 1 ) * ( b - size + 1 ) ; int area = total@@ Squ@@ ares * size * size ; total@@ Area += area ; size ++ ; } return total@@ Area ; } public static void main ( String [ ] args ) { int l = 4 , b = 3 ; System . out . println ( calculate@@ Area@@ Sum ( l , b ) ) ; } }
Check if Decimal representation of an Oct@@ al number is di@@ visible by 7 12264 | import java . util . * ; import java . lang . * ; import java . io . * ; class GF@@ G { static int check ( int n ) { int sum = 0 ; while ( n != 0 ) { sum += n % 10 ; n = n / 10 ; } if ( sum % 7 == 0 ) return 1 ; else return 0 ; } public static void main ( String args [ ] ) { int n = 25 ; String s = ( check ( n ) == 1 ) ? " YES " : " NO " ; System . out . println ( s ) ; } }
Egg@@ s dro@@ pping pu@@ zzle ( Bin@@ omial Coefficient and Binary Search Solution ) 12287 | class Ge@@ e@@ ks { static int bin@@ omi@@ al@@ Coeff ( int x , int n , int k ) { int sum = 0 , term = 1 ; for ( int i = 1 ; i <= n && sum < k ; ++ i ) { term *= x - i + 1 ; term /= i ; sum += term ; } return sum ; } static int min@@ Tri@@ als ( int n , int k ) { int low = 1 , high = k ; while ( low < high ) { int mid = ( low + high ) / 2 ; if ( bin@@ omi@@ al@@ Coeff ( mid , n , k ) < k ) low = mid + 1 ; else high = mid ; } return low ; } public static void main ( String args [ ] ) { System . out . println ( min@@ Tri@@ als ( 2 , 10 ) ) ; } }
Find next pal@@ ind@@ ro@@ me prime 12288 | import java . lang . * ; class Ge@@ e@@ ks { static boolean is@@ Prime ( int num ) { if ( num < 2 num % 2 == 0 ) return num == 2 ; for ( int i = 3 ; i * i <= num ; i += 2 ) if ( num % i == 0 ) return false ; return true ; } static int prime@@ Pal@@ ind@@ ro@@ me ( int N ) { if ( 8 <= N && N <= 11 ) return 11 ; for ( int x = 1 ; x < 100000 ; ++ x ) { String s = Integer . toString ( x ) ; StringBuffer buffer = new StringBuffer ( s ) ; buffer . reverse ( ) ; int y = Integer . parseInt ( s + buffer . substring ( 1 ) . toString ( ) ) ; if ( y >= N && is@@ Prime ( y ) == true ) return y ; } return - 1 ; } public static void main ( String args [ ] ) { System . out . print ( prime@@ Pal@@ ind@@ ro@@ me ( 112 ) ) ; } }
Hyper@@ factorial of a number 12294 | import java . io . * ; class GF@@ G { static int boost_@@ hyper@@ factorial ( int num ) { int val = 1 ; for ( int i = 1 ; i <= num ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { val *= i ; } } return val ; } public static void main ( String [ ] args ) { int num = 5 ; System . out . println ( boost_@@ hyper@@ factorial ( num ) ) ; } }
Number of sub arrays with odd sum 12308 | import java . io . * ; class GF@@ G { static int count@@ O@@ dd@@ Sum ( int ar [ ] , int n ) { int temp [ ] = { 1 , 0 } ; int result = 0 , val = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { val = ( ( val + ar [ i ] ) % 2 + 2 ) % 2 ; temp [ val ] ++ ; } result = temp [ 0 ] * temp [ 1 ] ; return ( result ) ; } public static void main ( String [ ] args ) { int ar [ ] = { 5 , 4 , 4 , 5 , 1 , 3 } ; int n = ar . length ; System . out . println ( " The ▁ Number ▁ of ▁ Sub@@ arrays " + " ▁ with ▁ odd ▁ sum ▁ is ▁ " + count@@ O@@ dd@@ Sum ( ar , n ) ) ; } }
C@@ entered Hex@@ a@@ dec@@ ag@@ onal Number 12359 | import java . io . * ; class GF@@ G { static int center_@@ hexa@@ dec@@ ag@@ on@@ al_@@ num ( int n ) { return 8 * n * n - 8 * n + 1 ; } public static void main ( String args [ ] ) { int n = 2 ; System . out . print ( n + " th ▁ centered ▁ " + " hexa@@ dec@@ ag@@ onal ▁ number : ▁ " ) ; System . out . println ( center_@@ hexa@@ dec@@ ag@@ on@@ al_@@ num ( n ) ) ; n = 12 ; System . out . print ( n + " th ▁ centered ▁ " + " hexa@@ dec@@ ag@@ onal ▁ number : ▁ " ) ; System . out . println ( center_@@ hexa@@ dec@@ ag@@ on@@ al_@@ num ( n ) ) ; } }
Program to compare m ^ n and n ^ m 12364 | import java . io . * ; class GF@@ G { static void check ( long m , long n ) { double RHS = m * ( double ) Math . log ( n ) ; double LHS = n * ( double ) Math . log ( m ) ; if ( LHS > RHS ) System . out . print ( " m ^ n ▁ > ▁ n ^ m " ) ; else if ( LHS < RHS ) System . out . print ( " m ^ n ▁ < ▁ n ^ m " ) ; else System . out . print ( " m ^ n ▁ = ▁ n ^ m " ) ; } static public void main ( String [ ] args ) { long m = 987@@ 65432@@ 1 , n = 12345@@ 69@@ 87 ; check ( m , n ) ; } }
Sum of series 1 * 1 * 2 ! + 2 * 2 * 3 ! + …@@ … . . + n * n * ( n + 1 ) ! 12394 | import java . io . * ; class GF@@ G { static int factorial ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } static int calculate@@ Series ( int n ) { return 2 + ( n * n + n - 2 ) * factorial ( n + 1 ) ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( calculate@@ Series ( n ) ) ; } }
Sum of square 12408 | class GF@@ G { static int find@@ Sum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( ( i * ( i + 1 ) * ( 2 * i + 1 ) ) / 6 ) ; return sum ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( find@@ Sum ( n ) ) ; } }
Con@@ ne@@ ll Sequence 12476 | import java . util . * ; class GF@@ G { static Vector < Long > gen ( long n , Vector < Long > r ) { long a = r . get ( r . size ( ) - 1 ) ; a ++ ; for ( int i = 1 ; i <= n ; a += 2 , i ++ ) { r . add ( a ) ; } return r ; } static Vector < Long > con@@ ell ( long n ) { Vector < Long > res = new Vector < Long > ( ) ; long k = 1 ; res . add ( 0L ) ; while ( true ) { res = gen ( k , res ) ; k ++ ; int j = res . size ( ) - 1 ; while ( j != n && j + k > n ) { k -- ; } if ( j >= n ) { break ; } } res . remove ( 0 ) ; return res ; } public static void main ( String [ ] args ) { long n = 10 ; System . out . println ( " The ▁ first ▁ " + n + " ▁ terms ▁ are " ) ; Vector < Long > res = con@@ ell ( n ) ; for ( int i = 0 ; i < res . size ( ) ; i ++ ) { System . out . print ( res . get ( i ) + " ▁ " ) ; } System . out . println ( ) ; } }
Ni@@ com@@ ach@@ u '@@ s The@@ o@@ rem 12507 | import java . io . * ; class GF@@ G { static void Ni@@ com@@ achu@@ The@@ or@@ um_@@ sum ( int n ) { int sum = 0 ; for ( int k = 1 ; k <= n ; k ++ ) sum += k * k * k ; int tri@@ No = n * ( n + 1 ) / 2 ; if ( sum == tri@@ No * tri@@ No ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } public static void main ( String [ ] args ) { int n = 5 ; Ni@@ com@@ achu@@ The@@ or@@ um_@@ sum ( n ) ; } }
LC@@ M of factorial and its neighbors 12517 | import java . io . * ; class GF@@ G { static int factorial ( int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; } static int LC@@ MO@@ f@@ Neigh@@ bour@@ Fact ( int n ) { return factorial ( n + 1 ) ; } public static void main ( String args [ ] ) { int N = 5 ; System . out . println ( LC@@ MO@@ f@@ Neigh@@ bour@@ Fact ( N ) ) ; } }
Check if a number is sand@@ wi@@ ch@@ ed between primes 12585 | import java . io . * ; class GF@@ G { static boolean is@@ Prime ( int n ) { if ( n == 0 n == 1 ) return false ; int root = ( int ) Math . sqrt ( n ) ; for ( int i = 2 ; i <= root ; i ++ ) if ( n % i == 0 ) return false ; return true ; } static boolean is@@ Sand@@ wit@@ ch@@ ed ( int n ) { return ( is@@ Prime ( n - 1 ) && is@@ Prime ( n + 1 ) ) ; } public static void main ( String [ ] args ) { int n = 64@@ 2 ; System . out . print ( n + " ▁ : ▁ " ) ; if ( is@@ Sand@@ wit@@ ch@@ ed ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; n = 9 ; System . out . print ( n + " ▁ : ▁ " ) ; if ( is@@ Sand@@ wit@@ ch@@ ed ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
Square Free Number 12592 | class GF@@ G { static boolean is@@ Square@@ Free ( int n ) { if ( n % 2 == 0 ) n = n / 2 ; if ( n % 2 == 0 ) return false ; for ( int i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { n = n / i ; if ( n % i == 0 ) return false ; } } return true ; } public static void main ( String [ ] args ) { int n = 10 ; if ( is@@ Square@@ Free ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
Find sum of odd factors of a number 12683 | import java . io . * ; import java . math . * ; class GF@@ G { static int su@@ mo@@ fo@@ dd@@ Factors ( int n ) { int res = 1 ; while ( n % 2 == 0 ) n = n / 2 ; for ( int i = 3 ; i <= Math . sqrt ( n ) ; i ++ ) { int count = 0 , curr_@@ sum = 1 ; int curr_@@ term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; curr_@@ term *= i ; curr_@@ sum += curr_@@ term ; } res *= curr_@@ sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; } public static void main ( String args [ ] ) throws IOException { int n = 30 ; System . out . println ( su@@ mo@@ fo@@ dd@@ Factors ( n ) ) ; } }
Find sum of odd factors of a number 12684 | class GF@@ G { static int count@@ Solutions ( int n , int val ) { int total = 0 ; if ( n == 1 && val >= 0 ) return 1 ; for ( int i = 0 ; i <= val ; i ++ ) { total += count@@ Solutions ( n - 1 , val - i ) ; } return total ; } public static void main ( String [ ] args ) { int n = 5 ; int val = 20 ; System . out . print ( count@@ Solutions ( n , val ) ) ; } }
N@@ arc@@ is@@ sist@@ ic number 12778 | import java . io . * ; import static java . lang . Math . * ; class n@@ arc@@ is@@ sist@@ ic { int count@@ Digit ( int n ) { if ( n == 0 ) return 0 ; return 1 + count@@ Digit ( n / 10 ) ; } boolean check ( int n ) { int l = count@@ Digit ( n ) ; int dup = n ; int sum = 0 ; while ( dup > 0 ) { sum += pow ( dup % 10 , l ) ; dup /= 10 ; } return ( n == sum ) ; } public static void main ( String args [ ] ) { n@@ arc@@ is@@ sist@@ ic obj = new n@@ arc@@ is@@ sist@@ ic ( ) ; int n = 16@@ 34 ; if ( obj . check ( n ) ) System . out . println ( " yes " ) ; else System . out . println ( " no " ) ; } }
Lar@@ gest number by which given 3 numbers should be divided such that they leaves same remainder 12819 | class GF@@ G { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int same@@ Remain@@ der ( int a , int b , int c ) { int a1 = ( b - a ) , b1 = ( c - b ) , c1 = ( c - a ) ; return gcd ( a1 , gcd ( b1 , c1 ) ) ; } public static void main ( String [ ] args ) { int a = 62 , b = 132 , c = 237 ; System . out . println ( same@@ Remain@@ der ( a , b , c ) ) ; } }
Lar@@ gest number less than N whose each digit is prime number 12913 | import java . io . * ; class GF@@ G { static char [ ] Prime@@ Digit@@ Number ( char N [ ] , int size ) { char [ ] ans = new char [ size ] ; int ns = 0 ; int small = 0 ; int i ; int p [ ] = { 0 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 0 } ; int prev@@ prime [ ] = { 0 , 0 , 0 , 2 , 3 , 3 , 5 , 5 , 7 , 7 } ; if ( size == 1 ) { ans [ 0 ] = ( char ) ( prev@@ prime [ N [ 0 ] - '0' ] + '0' ) ; ans [ 1 ] = ' \0' ; return ans ; } if ( N [ 0 ] == '1' ) { for ( i = 0 ; i < size - 1 ; i ++ ) ans [ i ] = '7' ; ans [ size - 1 ] = ' \0' ; return ans ; } for ( i = 0 ; i < size && small == 0 ; i ++ ) { if ( p [ N [ i ] - '0' ] == 1 ) { ans [ ns ++ ] = N [ i ] ; } else { if ( p [ N [ i ] - '0' ] == 0 && prev@@ prime [ N [ i ] - '0' ] != 0 ) { ans [ ns ++ ] = ( char ) ( prev@@ prime [ N [ i ] - '0' ] + '0' ) ; small = 1 ; } else if ( p [ N [ i ] - '0' ] == 0 && prev@@ prime [ N [ i ] - '0' ] == 0 ) { int j = i ; while ( j > 0 && p [ N [ j ] - '0' ] == 0 && prev@@ prime [ N [ j ] - '0' ] == 0 ) { ans [ j ] = N [ j ] = '7' ; N [ j - 1 ] = ( char ) ( prev@@ prime [ N [ j - 1 ] - '0' ] + '0' ) ; ans [ j - 1 ] = N [ j - 1 ] ; small = 1 ; j -- ; } i = ns ; } } } if ( small == 0 ) { if ( prev@@ prime [ N [ size - 1 ] - '0' ] + '0' != '0' ) ans [ size - 1 ] = ( char ) ( prev@@ prime [ N [ size - 1 ] - '0' ] + '0' ) ; else { int j = size - 1 ; while ( j > 0 && prev@@ prime [ N [ j ] - '0' ] == 0 ) { ans [ j ] = N [ j ] = '7' ; N [ j - 1 ] = ( char ) ( prev@@ prime [ N [ j - 1 ] - '0' ] + '0' ) ; ans [ j - 1 ] = N [ j - 1 ] ; small = 1 ; j -- ; } } } for ( ; ns < size ; ns ++ ) ans [ ns ] = '7' ; ans [ ns ] = ' \0' ; int k = 0 ; while ( ans [ k ] == '0' ) k ++ ; return ans ; } public static void main ( String [ ] args ) { char [ ] N = "100@@ 0" . toCharArray ( ) ; int size = N . length ; System . out . println ( Prime@@ Digit@@ Number ( N , size ) ) ; } }
Check if a number is power of k using base changing method 12932 | class GF@@ G { static boolean is@@ PowerOf@@ K ( int n , int k ) { boolean one@@ Seen = false ; while ( n > 0 ) { int digit = n % k ; if ( digit > 1 ) return false ; if ( digit == 1 ) { if ( one@@ Seen ) return false ; one@@ Seen = true ; } n /= k ; } return true ; } public static void main ( String [ ] args ) { int n = 64 , k = 4 ; if ( is@@ PowerOf@@ K ( n , k ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
Maximum sum of Bit@@ wise XOR of elements with their respective positions in a permutation of size N 10051 | import java . util . * ; class GF@@ G { static int calc@@ Sc@@ r ( ArrayList < Integer > arr ) { int ans = 0 ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) ans += ( i ^ arr . get ( i ) ) ; return ans ; } static int getMax ( ArrayList < Integer > arr , int ans , ArrayList < Boolean > chosen , int N ) { if ( arr . size ( ) == N ) { ans = Math . max ( ans , calc@@ Sc@@ r ( arr ) ) ; return ans ; } for ( int i = 0 ; i < N ; i ++ ) { if ( chosen . get ( i ) ) continue ; chosen . set ( i , true ) ; arr . add ( i ) ; ans = getMax ( arr , ans , chosen , N ) ; chosen . set ( i , false ) ; arr . remove ( arr . size ( ) - 1 ) ; } return ans ; } public static void main ( String [ ] args ) { int N = 2 ; ArrayList < Integer > arr = new ArrayList < Integer > ( ) ; int ans = - 1 ; ArrayList < Boolean > chosen = new ArrayList < Boolean > ( Collections . n@@ Copies ( N , false ) ) ; ans = getMax ( arr , ans , chosen , N ) ; System . out . print ( ans + "@@ NEW_@@ LINE@@ "@@ )@@ ; } }
K di@@ stant prime pairs in a given range 10186 | import java . util . * ; class solution { static void find@@ Prime@@ No@@ s ( int L , int R , Map < Integer , Integer > M , int K ) { for ( int i = L ; i <= R ; i ++ ) { if ( M . get ( i ) != null ) M . put ( i , M . get ( i ) + 1 ) ; else M . put ( i , 1 ) ; } if ( M . get ( 1 ) != null ) { M . remove ( 1 ) ; } for ( int i = 2 ; i <= Math . sqrt ( R ) ; i ++ ) { int multiple = 2 ; while ( ( i * multiple ) <= R ) { if ( M . get ( i * multiple ) != null ) { M . remove ( i * multiple ) ; } multiple ++ ; } } for ( Map . Entry < Integer , Integer > entry : M . entrySet ( ) ) { if ( M . get ( entry . getKey ( ) + K ) != null ) { System . out . print ( " ( " + entry . getKey ( ) + " , ▁ " + ( entry . getKey ( ) + K ) + " ) ▁ " ) ; } } } static void get@@ Prime@@ Pairs ( int L , int R , int K ) { Map < Integer , Integer > M = new HashMap < Integer , Integer > ( ) ; find@@ Prime@@ No@@ s ( L , R , M , K ) ; } public static void main ( String args [ ] ) { int L = 1 , R = 19 ; int K = 6 ; get@@ Prime@@ Pairs ( L , R , K ) ; } }
655@@ 37 10473 | class GF@@ G { static int gon@@ Num@@ 655@@ 37 ( int n ) { return ( 65535 * n * n - 655@@ 33 * n ) / 2 ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . print ( gon@@ Num@@ 655@@ 37 ( n ) ) ; } }
Count pairs in an array such that the absolute difference between them is Ã@@ ƒ@@ Æ ’ Ã † â €@@ ™ Ã@@ ƒ@@ â € Ã ¢ â ‚@@ ¬ â „@@ ¢ Ã@@ ƒ@@ Æ ’ Ã ¢ â ‚@@ ¬ Ã@@ ƒ ¢ Ã ¢ â € š ¬ Ã ¢ â € ž ¢ Ã@@ ƒ@@ Æ ’ Ã † â €@@ ™ Ã@@ ƒ ¢ Ã ¢ â € š ¬ Ã@@ ƒ@@ Æ ’@@ ¢ Ã@@ ƒ ¢ Ã ¢ â ‚@@ ¬ Å ¡@@ ¬ Ã@@ ƒ ¢ Ã ¢ â ‚@@ ¬ Å ¾@@ ¢ Ã@@ ƒ@@ Æ ’ Ã † â €@@ ™ Ã@@ ƒ@@ â € Ã ¢ â ‚@@ ¬ â „@@ ¢ Ã@@ ƒ@@ Æ ’@@ ¢ Ã@@ ƒ ¢ Ã ¢ â ‚@@ ¬ Å ¡@@ ¬ Ã@@ ƒ@@ Æ ’ Ã † â €@@ ™@@ ¢ Ã@@ ƒ@@ Æ ’@@ ¢ Ã@@ ƒ ¢ Ã ¢ â € š ¬ Ã …@@ ¡@@ ¬ Ã@@ ƒ@@ Æ ’@@ ¢ Ã@@ ƒ ¢ Ã ¢ â € š ¬ Ã …@@ ¾@@ ¢@@ ¢ Ã@@ ƒ@@ Æ ’ Ã † â €@@ ™ Ã@@ ƒ@@ â € Ã ¢ â ‚@@ ¬ â „@@ ¢ Ã@@ ƒ@@ Æ ’ Ã ¢ â ‚@@ ¬ Ã@@ ƒ ¢ Ã ¢ â € š ¬ Ã ¢ â € ž ¢ Ã@@ ƒ@@ Æ ’ Ã † â €@@ ™ Ã@@ ƒ ¢ Ã ¢ â € š ¬ Ã@@ ƒ@@ Æ ’@@ ¢ Ã@@ ƒ ¢ Ã ¢ â ‚@@ ¬ Å ¡@@ ¬ Ã@@ ƒ ¢ Ã ¢ â ‚@@ ¬ Å ¾@@ ¢@@ ¢ Ã@@ ƒ@@ Æ ’ Ã † â €@@ ™ Ã@@ ƒ@@ â € Ã ¢ â ‚@@ ¬ â „@@ ¢ Ã@@ ƒ@@ Æ ’ Ã ¢ â ‚@@ ¬ Ã@@ ƒ ¢ Ã ¢ â € š ¬ Ã ¢ â € ž ¢@@ ¢ Ã@@ ƒ@@ Æ ’ Ã † â €@@ ™ Ã@@ ƒ@@ â € Ã ¢ â ‚@@ ¬ â „@@ ¢@@ ¢ Ã@@ ƒ@@ Æ ’ Ã † â €@@ ™@@ ¢ Ã@@ ƒ@@ Æ ’@@ ¢ Ã@@ ƒ ¢ Ã ¢ â ‚@@ ¬ Å ¡@@ ¬ Ã@@ ƒ@@ â €@@ ¦@@ ¡@@ ¬ Ã@@ ƒ@@ Æ ’ Ã † â €@@ ™ Ã@@ ƒ ¢ Ã ¢ â € š ¬@@ ¦@@ ¡@@ ¬@@ °@@ ¥ K 11337 | import java . util . * ; class solution { static int count ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int cnt = 0 ; int i = 0 , j = 1 ; while ( i < n && j < n ) { j = ( j <= i ) ? ( i + 1 ) : j ; while ( j < n && ( arr [ j ] - arr [ i ] ) < k ) j ++ ; cnt += ( n - j ) ; i ++ ; } return cnt ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = arr . length ; int k = 2 ; System . out . println ( count ( arr , n , k ) ) ; } }
Find integers that divi@@ des maximum number of elements of the array 11690 | import java . util . * ; class GF@@ G { static void maximum@@ Factor ( int [ ] arr ) { int [ ] rank = new int [ Arrays . stream ( arr ) . max ( ) . getAs@@ Int ( ) + 1 ] ; int [ ] factors = new int [ Arrays . stream ( arr ) . max ( ) . getAs@@ Int ( ) + 1 ] ; int g = 0 ; for ( int i = 2 ; i <= Arrays . stream ( arr ) . max ( ) . getAs@@ Int ( ) ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < arr . length ; j ++ ) if ( arr [ j ] % i == 0 ) count += 1 ; rank [ g ] = count ; factors [ g ] = i ; g ++ ; } int m = Arrays . stream ( rank ) . max ( ) . getAs@@ Int ( ) ; for ( int i = 0 ; i < rank . length ; i ++ ) { if ( rank [ i ] == m ) System . out . print ( factors [ i ] + " ▁ " ) ; } } public static void main ( String [ ] args ) { int [ ] arr = { 120 , 15 , 24 , 63 , 18 } ; maximum@@ Factor ( arr ) ; } }
Sum of the multip@@ les of two numbers below N 11823 | import java . io . * ; class GF@@ G { static int find@@ Sum ( int n , int a , int b ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( i % a == 0 i % b == 0 ) sum += i ; return sum ; } public static void main ( String [ ] args ) { int n = 10 , a = 3 , b = 5 ; System . out . println ( find@@ Sum ( n , a , b ) ) ; } }
Medi@@ an 11831 | import java . util . * ; class GF@@ G { public static double find@@ Medi@@ an ( int a [ ] , int n ) { Arrays . sort ( a ) ; if ( n % 2 != 0 ) return ( double ) a [ n / 2 ] ; return ( double ) ( a [ ( n - 1 ) / 2 ] + a [ n / 2 ] ) / 2.0 ; } public static void main ( String args [ ] ) { int a [ ] = { 1 , 3 , 4 , 2 , 7 , 5 , 8 , 6 } ; int n = a . length ; System . out . println ( " Medi@@ an ▁ = ▁ " + find@@ Medi@@ an ( a , n ) ) ; } }
Program for C@@ entered I@@ co@@ sa@@ hedr@@ al Number 12405 | import java . io . * ; class GF@@ G { static int cen@@ tered@@ I@@ co@@ sa@@ hedral@@ Num ( int n ) { return ( 2 * n + 1 ) * ( 5 * n * n + 5 * n + 3 ) / 3 ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( cen@@ tered@@ I@@ co@@ sa@@ hedral@@ Num ( n ) ) ; n = 12 ; System . out . println ( cen@@ tered@@ I@@ co@@ sa@@ hedral@@ Num ( n ) ) ; } }
Do@@ dec@@ ag@@ onal number 12417 | import java . util . * ; class GF@@ G { static int Do@@ dec@@ ag@@ on@@ al_@@ number ( int n ) { return 5 * n * n - 4 * n ; } public static void main ( String [ ] args ) { int n = 7 ; System . out . println ( Do@@ dec@@ ag@@ on@@ al_@@ number ( n ) ) ; n = 12 ; System . out . println ( Do@@ dec@@ ag@@ on@@ al_@@ number ( n ) ) ; } }
Average of even numbers till a given even number 12639 | import java . io . * ; class GF@@ G { static int average@@ Even ( int n ) { if ( n % 2 != 0 ) { System . out . println ( " Invalid ▁ Input " ) ; return - 1 ; } return ( n + 2 ) / 2 ; } public static void main ( String args [ ] ) { int n = 16 ; System . out . println ( average@@ Even ( n ) ) ; } }
Find Harmon@@ ic mean using Arith@@ metic mean and Geo@@ metric mean 12817 | import java . io . * ; class Ge@@ ek@@ s@@ for@@ Ge@@ e@@ ks { static double compute ( int a , int b ) { double AM , GM , H@@ M ; AM = ( a + b ) / 2 ; GM = Math . sqrt ( a * b ) ; H@@ M = ( GM * GM ) / AM ; return H@@ M ; } public static void main ( String args [ ] ) { int a = 5 , b = 15 ; double H@@ M = compute ( a , b ) ; String str = " " ; str = str + H@@ M ; System . out . print ( " Harmon@@ ic ▁ Mean ▁ between ▁ " + a + " ▁ and ▁ " + b + " ▁ is ▁ " + str . substring ( 0 , 5 ) ) ; } }
A product array pu@@ zzle | Set 2 ( O ( 1 ) Space ) 13033 | public class Array_@@ pu@@ zz@@ le_@@ 2 { static final double EPS = 1e-@@ 9 ; static void product@@ Pu@@ zzle ( int a [ ] , int n ) { double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += Math . log10 ( a [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( ( int ) ( EPS + Math . pow ( 10.@@ 00 , sum - Math . log10 ( a [ i ] ) ) ) + " ▁ " ) ; } public static void main ( String args [ ] ) { int a [ ] = { 10 , 3 , 5 , 6 , 2 } ; int n = a . length ; System . out . println ( " The ▁ product ▁ array ▁ is : ▁ " ) ; product@@ Pu@@ zzle ( a , n ) ; } }
P@@ ell Number 13054 | class P@@ ell@@ Number { public static int p@@ ell ( int n ) { if ( n <= 2 ) return n ; return 2 * p@@ ell ( n - 1 ) + p@@ ell ( n - 2 ) ; } public static void main ( String args [ ] ) { int n = 4 ; System . out . println ( p@@ ell ( n ) ) ; } }
Find minimum value to assign all array elements so that array product becomes greater 13116 | import java . util . Arrays ; class GF@@ G1 { static long find@@ Min@@ Value ( long arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { val += ( double ) ( Math . log ( ( double ) ( arr [ i ] ) ) ) ; } long left = arr [ 0 ] , right = arr [ n - 1 ] ; long ans = 0 ; while ( left <= right ) { long mid = ( left + right ) / 2 ; double temp = ( double ) n * ( double ) ( Math . log ( ( double ) ( mid ) ) ) ; if ( val < temp ) { ans = mid ; right = mid - 1 ; } else { left = mid + 1 ; } } return ans ; } public static void main ( String [ ] args ) { long arr [ ] = { 4 , 2 , 1 , 10 , 6 } ; int n = arr . length ; System . out . println ( find@@ Min@@ Value ( arr , n ) ) ; } }
Find other two sides of a right angle triangle 13135 | class GF@@ G { static void print@@ Other@@ Si@@ des ( int n ) { if ( n % 2 != 0 ) { if ( n == 1 ) System . out . println ( " - 1" ) ; else { int b = ( n * n - 1 ) / 2 ; int c = ( n * n + 1 ) / 2 ; System . out . println ( " b ▁ = ▁ " + b + " , ▁ c ▁ = ▁ " + c ) ; } } else { if ( n == 2 ) System . out . println ( " - 1" ) ; else { int b = n * n / 4 - 1 ; int c = n * n / 4 + 1 ; System . out . println ( " b ▁ = ▁ " + b + " , ▁ c ▁ = ▁ " + c ) ; } } } public static void main ( String [ ] args ) { int a = 3 ; print@@ Other@@ Si@@ des ( a ) ; } }
Sum of di@@ visors of factorial of a number 13140 | import java . io . * ; import java . util . * ; public class Division { static int fact ( int n ) { if ( n == 0 ) return 1 ; return n * fact ( n - 1 ) ; } static int div ( int x ) { int ans = 0 ; for ( int i = 1 ; i <= x ; i ++ ) if ( x % i == 0 ) ans += i ; return ans ; } static int sum@@ Fact@@ Div ( int n ) { return div ( fact ( n ) ) ; } public static void main ( String args [ ] ) { int n = 4 ; System . out . println ( sum@@ Fact@@ Div ( n ) ) ; } }
Sum of di@@ visors of factorial of a number 13141 | import java . util . * ; class GF@@ G { static ArrayList < Integer > all@@ Pri@@ mes = new ArrayList < Integer > ( ) ; static void si@@ eve ( int n ) { boolean [ ] prime = new boolean [ n + 1 ] ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == false ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = true ; } } for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] == false ) all@@ Pri@@ mes . add ( p ) ; } static int factor@@ ial@@ Di@@ visors ( int n ) { int result = 1 ; for ( int i = 0 ; i < all@@ Pri@@ mes . size ( ) ; i ++ ) { int p = all@@ Pri@@ mes . get ( i ) ; int exp = 0 ; while ( p <= n ) { exp = exp + ( n / p ) ; p = p * all@@ Pri@@ mes . get ( i ) ; } result = result * ( ( int ) Math . pow ( all@@ Pri@@ mes . get ( i ) , exp + 1 ) - 1 ) / ( all@@ Pri@@ mes . get ( i ) - 1 ) ; } return result ; } public static void main ( String [ ] args ) { System . out . println ( factor@@ ial@@ Di@@ visors ( 4 ) ) ; } }
Pan@@ digital number in a given base 13179 | import java . util . * ; class GF@@ G { static boolean check@@ Pan@@ digital ( int b , String n ) { if ( n . length ( ) < b ) return false ; boolean hash [ ] = new boolean [ b ] ; Arrays . fill ( hash , false ) ; for ( int i = 0 ; i < n . length ( ) ; i ++ ) { if ( n . charAt ( i ) >= '0' && n . charAt ( i ) <= '9' ) hash [ n . charAt ( i ) - '0' ] = true ; else if ( n . charAt ( i ) - ' A ' <= b - 11 ) hash [ n . charAt ( i ) - ' A ' + 10 ] = true ; } for ( int i = 0 ; i < b ; i ++ ) if ( hash [ i ] == false ) return false ; return true ; } public static void main ( String [ ] args ) { int b = 13 ; String n = "12@@ 98@@ 45@@ 03@@ 76@@ ABC " ; if ( check@@ Pan@@ digital ( b , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
Number of occurrences of 2 as a digit in numbers from 0 to n 13188 | class GF@@ G { static int numberOf@@ 2@@ sin@@ Range ( int n ) { String s = " " ; for ( int i = 0 ; i < n + 1 ; i ++ ) s += String . valueOf ( i ) ; int count = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '2' ) { count ++ ; } } return count ; } public static void main ( String [ ] args ) { int n = 30 ; System . out . println ( numberOf@@ 2@@ sin@@ Range ( n ) ) ; } }
Find ways an Integer can be expressed as sum of n 13222 | class GF@@ G { static int power ( int num , int n ) { if ( n == 0 ) return 1 ; else if ( n % 2 == 0 ) return power ( num , n / 2 ) * power ( num , n / 2 ) ; else return num * power ( num , n / 2 ) * power ( num , n / 2 ) ; } static int check@@ Recursive ( int x , int n , int curr_@@ num , int curr_@@ sum ) { int results = 0 ; int p = power ( curr_@@ num , n ) ; while ( p + curr_@@ sum < x ) { results += check@@ Recursive ( x , n , curr_@@ num + 1 , p + curr_@@ sum ) ; curr_@@ num ++ ; p = power ( curr_@@ num , n ) ; } if ( p + curr_@@ sum == x ) results ++ ; return results ; } public static void main ( String [ ] args ) { int x = 10 , n = 2 ; System . out . println ( check@@ Recursive ( x , n , 1 , 0 ) ) ; } }
Number The@@ ory | Gener@@ ators of finite cyclic group under addition 13225 | class GF@@ G { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static void print@@ Gener@@ ators ( int n ) { System . out . println ( "1 ▁ " ) ; for ( int i = 2 ; i < n ; i ++ ) if ( gcd ( i , n ) == 1 ) System . out . println ( i + " ▁ " ) ; } public static void main ( String args [ ] ) { int n = 10 ; print@@ Gener@@ ators ( n ) ; } }
Find sum of di@@ visors of all the di@@ visors of a natural number 13275 | import java . util . HashMap ; class GF@@ G { public static int sum@@ Di@@ visor@@ sOf@@ Di@@ visors ( int n ) { HashMap < Integer , Integer > mp = new HashMap < > ( ) ; for ( int j = 2 ; j <= Math . sqrt ( n ) ; j ++ ) { int count = 0 ; while ( n % j == 0 ) { n /= j ; count ++ ; } if ( count != 0 ) mp . put ( j , count ) ; } if ( n != 1 ) mp . put ( n , 1 ) ; int ans = 1 ; for ( HashMap . Entry < Integer , Integer > entry : mp . entrySet ( ) ) { int pw = 1 ; int sum = 0 ; for ( int i = entry . getValue ( ) + 1 ; i >= 1 ; i -- ) { sum += ( i * pw ) ; pw = entry . getKey ( ) ; } ans *= sum ; } return ans ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( sum@@ Di@@ visor@@ sOf@@ Di@@ visors ( n ) ) ; } }
Find sum of modulo K of first N natural number 13297 | import java . io . * ; class GF@@ G { static int find@@ Sum ( int N , int K ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) ans += ( i % K ) ; return ans ; } static public void main ( String [ ] args ) { int N = 10 , K = 2 ; System . out . println ( find@@ Sum ( N , K ) ) ; } }
Find Square Root under Modul@@ o p | Set 2 ( Sh@@ an@@ ks T@@ on@@ ell@@ i algorithm ) 13415 | class GF@@ G { static int z = 0 ; static int pow@@ 1 ( int base@@ 1 , int exponent , int modulus ) { int result = 1 ; base@@ 1 = base@@ 1 % modulus ; while ( exponent > 0 ) { if ( exponent % 2 == 1 ) result = ( result * base@@ 1 ) % modulus ; exponent = exponent >> 1 ; base@@ 1 = ( base@@ 1 * base@@ 1 ) % modulus ; } return result ; } static int gcd ( int a , int b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; } static int order ( int p , int b ) { if ( gcd ( p , b ) != 1 ) { System . out . println ( " p ▁ and ▁ b ▁ are " + " not ▁ co - prime . " ) ; return - 1 ; } int k = 3 ; while ( true ) { if ( pow@@ 1 ( b , k , p ) == 1 ) return k ; k ++ ; } } static int conver@@ tx@@ 2e ( int x ) { z = 0 ; while ( x % 2 == 0 ) { x /= 2 ; z ++ ; } return x ; } static int ST@@ on@@ ell@@ i ( int n , int p ) { if ( gcd ( n , p ) != 1 ) { System . out . println ( " a ▁ and ▁ p ▁ are ▁ not ▁ co@@ prime " ) ; return - 1 ; } if ( pow@@ 1 ( n , ( p - 1 ) / 2 , p ) == ( p - 1 ) ) { System . out . println ( " no ▁ sqrt ▁ possible " ) ; return - 1 ; } int s , e ; s = conver@@ tx@@ 2e ( p - 1 ) ; e = z ; int q ; for ( q = 2 ; ; q ++ ) { if ( pow@@ 1 ( q , ( p - 1 ) / 2 , p ) == ( p - 1 ) ) break ; } int x = pow@@ 1 ( n , ( s + 1 ) / 2 , p ) ; int b = pow@@ 1 ( n , s , p ) ; int g = pow@@ 1 ( q , s , p ) ; int r = e ; while ( true ) { int m ; for ( m = 0 ; m < r ; m ++ ) { if ( order ( p , b ) == - 1 ) return - 1 ; if ( order ( p , b ) == Math . pow ( 2 , m ) ) break ; } if ( m == 0 ) return x ; x = ( x * pow@@ 1 ( g , ( int ) Math . pow ( 2 , r - m - 1 ) , p ) ) % p ; g = pow@@ 1 ( g , ( int ) Math . pow ( 2 , r - m ) , p ) ; b = ( b * g ) % p ; if ( b == 1 ) return x ; r = m ; } } public static void main ( String [ ] args ) { int n = 2 ; int p = 113 ; int x = ST@@ on@@ ell@@ i ( n , p ) ; if ( x == - 1 ) System . out . println ( " Mod@@ ular ▁ square " + "@@ root is not exist@@ NEW_@@ LINE@@ "@@ )@@ ; else System . out . println ( " Mod@@ ular ▁ square ▁ root ▁ of ▁ " + n + " ▁ and ▁ " + p + " ▁ is ▁ " + x + "@@ NEW_@@ LINE@@ "@@ )@@ ; } }
Program to find the Roots of Quadrati@@ c equation 13418 | import java . io . * ; import static java . lang . Math . * ; class Quadrati@@ c { static void find@@ Roots ( int a , int b , int c ) { if ( a == 0 ) { System . out . println ( " Invalid " ) ; return ; } int d = b * b - 4 * a * c ; double sq@@ rt_@@ val = sqrt ( abs ( d ) ) ; if ( d > 0 ) { System . out . println ( "@@ Roots are real and different NEW_@@ LINE@@ "@@ )@@ ; System . out . println ( ( double ) ( - b + sq@@ rt_@@ val ) / ( 2 * a ) + "@@ NEW_@@ LINE@@ " + ( double ) ( - b - sq@@ rt_@@ val ) / ( 2 * a ) ) ; } else if ( d == 0 ) { System . out . println ( "@@ Roots are real and same NEW_@@ LINE@@ "@@ )@@ ; System . out . println ( - ( double ) b / ( 2 * a ) + "@@ NEW_@@ LINE@@ " + - ( double ) b / ( 2 * a ) ) ; } { System . out . println ( "@@ Roots are complex NEW_@@ LINE@@ "@@ )@@ ; System . out . println ( - ( double ) b / ( 2 * a ) + " ▁ + ▁ i " + sq@@ rt_@@ val + "@@ NEW_@@ LINE@@ " + - ( double ) b / ( 2 * a ) + " ▁ - ▁ i " + sq@@ rt_@@ val ) ; } } public static void main ( String args [ ] ) { int a = 1 , b = - 7 , c = 12 ; find@@ Roots ( a , b , c ) ; } }
Find all di@@ visors of a natural number | Set 2 13429 | import java . util . Vector ; class Test { static void print@@ Di@@ visors ( int n ) { Vector < Integer > v = new Vector < > ( ) ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) System . out . printf ( " % d ▁ " , i ) ; else { System . out . printf ( " % d ▁ " , i ) ; v . add ( n / i ) ; } } } for ( int i = v . size ( ) - 1 ; i >= 0 ; i -- ) System . out . printf ( " % d ▁ " , v . get ( i ) ) ; } public static void main ( String args [ ] ) { System . out . println ( " The ▁ di@@ visors ▁ of ▁ 100 ▁ are : ▁ " ) ; print@@ Di@@ visors ( 100 ) ; } }
Find all factors of a natural number | Set 1 13431 | class Test { static void print@@ Di@@ visors ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) if ( n % i == 0 ) System . out . print ( i + " ▁ " ) ; } public static void main ( String args [ ] ) { System . out . println ( " The ▁ di@@ visors ▁ of ▁ 100 ▁ are : ▁ " ) ; print@@ Di@@ visors ( 100 ) ; ; } }
Find all factors of a natural number | Set 1 13432 | class Test { static void print@@ Di@@ visors ( int n ) { for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) System . out . print ( " ▁ " + i ) ; System . out . print ( i + " ▁ " + n / i + " ▁ " ) ; } } } public static void main ( String args [ ] ) { System . out . println ( " The ▁ di@@ visors ▁ of ▁ 100 ▁ are : ▁ " ) ; print@@ Di@@ visors ( 100 ) ; ; } }
Sol@@ ving f ( n ) = ( 1 ) + ( 2 * 3 ) + ( 4 * 5 * 6 ) . . . n using Recur@@ sion 13443 | class GF@@ G { static int series@@ Sum ( int calculated , int current , int N ) { int i , cur = 1 ; if ( current == N + 1 ) return 0 ; for ( i = calculated ; i < calculated + current ; i ++ ) cur *= i ; return cur + series@@ Sum ( i , current + 1 , N ) ; } public static void main ( String [ ] args ) { int N = 5 ; System . out . println ( series@@ Sum ( 1 , 1 , N ) ) ; } }
Compute n@@ Cr % p | Set 2 ( Lu@@ cas The@@ o@@ rem ) 13471 | class GF@@ G { static int n@@ Cr@@ Mod@@ pD@@ P ( int n , int r , int p ) { int [ ] C = new int [ r + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . min ( i , r ) ; j > 0 ; j -- ) C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p ; } return C [ r ] ; } static int n@@ Cr@@ Mod@@ p@@ Lu@@ cas ( int n , int r , int p ) { if ( r == 0 ) return 1 ; int ni = n % p ; int ri = r % p ; } public static void main ( String [ ] args ) { int n = 1000 , r = 900 , p = 13 ; System . out . println ( " Value ▁ of ▁ n@@ Cr ▁ % ▁ p ▁ is ▁ " + n@@ Cr@@ Mod@@ p@@ Lu@@ cas ( n , r , p ) ) ; } }
Mod@@ ular multiplic@@ ative inverse 13511 | class GF@@ G { static int mod@@ Inverse ( int a , int m ) { int m0 = m ; int y = 0 , x = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { int q = a / m ; int t = m ; m = a % m ; a = t ; t = y ; y = x - q * y ; x = t ; } if ( x < 0 ) x += m0 ; return x ; } public static void main ( String args [ ] ) { int a = 3 , m = 11 ; System . out . println ( " Mod@@ ular ▁ multiplic@@ ative ▁ " + " inverse ▁ is ▁ " + mod@@ Inverse ( a , m ) ) ; } }
Eu@@ ler '@@ s To@@ ti@@ ent Function 13513 | import java . io . * ; class GF@@ G { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int phi ( int n ) { int result = 1 ; for ( int i = 2 ; i < n ; i ++ ) if ( gcd ( i , n ) == 1 ) result ++ ; return result ; } public static void main ( String [ ] args ) { int n ; for ( n = 1 ; n <= 10 ; n ++ ) System . out . println ( " phi ( " + n + " ) ▁ = ▁ " + phi ( n ) ) ; } }
Program to print first n Fi@@ bon@@ ac@@ ci Numbers | Set 1 13539 | class Test { static void print@@ Fi@@ bon@@ ac@@ ci@@ Numbers ( int n ) { int f1 = 0 , f2 = 1 , i ; if ( n < 1 ) return ; System . out . print ( f1 + " ▁ " ) ; for ( i = 1 ; i < n ; i ++ ) { System . out . print ( f2 + " ▁ " ) ; int next = f1 + f2 ; f1 = f2 ; f2 = next ; } } public static void main ( String [ ] args ) { print@@ Fi@@ bon@@ ac@@ ci@@ Numbers ( 7 ) ; } }
Program to find LC@@ M of two numbers 13544 | class Test { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int l@@ cm ( int a , int b ) { return ( a / gcd ( a , b ) ) * b ; } public static void main ( String [ ] args ) { int a = 15 , b = 20 ; System . out . println ( " LC@@ M ▁ of ▁ " + a + " ▁ and ▁ " + b + " ▁ is ▁ " + l@@ cm ( a , b ) ) ; } }
Check if a number is multiple of 5 without using / and % operators 13565 | class GF@@ G { static int MAX = 11 ; static boolean is@@ Multiple@@ of@@ 5 ( int n ) { char str [ ] = new char [ MAX ] ; int len = str . length ; if ( str [ len - 1 ] == '5' str [ len - 1 ] == '0' ) return true ; return false ; } public static void main ( String [ ] args ) { int n = 19 ; if ( is@@ Multiple@@ of@@ 5 ( n ) == true ) System . out . println ( n + " ▁ is ▁ multiple ▁ " + " of ▁ 5" ) ; else System . out . println ( n + " ▁ is ▁ not ▁ a ▁ " + " multiple ▁ of ▁ 5" ) ; } }
Write a program to reverse digits of a number 13575 | class GF@@ G { static int rev_@@ num = 0 ; static int base_@@ pos = 1 ; static int rever@@ s@@ Digits ( int num ) { if ( num > 0 ) { rever@@ s@@ Digits ( num / 10 ) ; rev_@@ num += ( num % 10 ) * base_@@ pos ; base_@@ pos *= 10 ; } return rev_@@ num ; } public static void main ( String [ ] args ) { int num = 45@@ 62 ; System . out . println ( rever@@ s@@ Digits ( num ) ) ; } }
Modify a matrix by converting each element to XOR of its digits 13586 | import java . io . * ; class GF@@ G { static int M = 3 ; static int N = 3 ; static int find@@ XOR ( int X ) { int ans = 0 ; while ( X != 0 ) { ans ^= ( X % 10 ) ; X /= 10 ; } return ans ; } static void print@@ X@@ OR@@ matrix ( int arr [ ] [ ] ) { for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { System . out . print ( arr [ i ] [ j ] + " ▁ " ) ; } System . out . println ( ) ; } } static void convert@@ XOR ( int arr [ ] [ ] ) { for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int X = arr [ i ] [ j ] ; int temp = find@@ XOR ( X ) ; arr [ i ] [ j ] = temp ; } } print@@ X@@ OR@@ matrix ( arr ) ; } public static void main ( String [ ] args ) { int arr [ ] [ ] = { { 27 , 173 , 5 } , { 21 , 6 , 6@@ 24 } , { 5 , 321 , 49 } } ; convert@@ XOR ( arr ) ; } }
All about Bit Manip@@ ulation 13589 | static int set@@ Bit ( int num , int i ) { return num | ( 1 << i ) ; }
Sum of Bit@@ wise OR of every array element paired with all other array elements 13598 | import java . util . * ; class GF@@ G { static void print@@ OR@@ Sum@@ forEach@@ Element ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int req_@@ sum = 0 ; for ( int j = 0 ; j < N ; j ++ ) { req_@@ sum += ( arr [ i ] arr [ j ] ) ; } System . out . print ( req_@@ sum + " ▁ " ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int N = arr . length ; print@@ OR@@ Sum@@ forEach@@ Element ( arr , N ) ; } }
Lar@@ gest number in the Array having frequency same as value 13630 | class GF@@ G { static int find@@ Largest@@ Number ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] &= 0xFFFF ; if ( arr [ i ] <= n ) { arr [ i ] += 0x10000 ; } } for ( int i = n - 1 ; i > 0 ; -- i ) { if ( ( arr [ i ] >> 16 ) == i ) return i + 1 ; } return - 1 ; } public static void main ( String [ ] args ) { int [ ] arr = { 3 , 2 , 5 , 5 , 2 , 4 , 5 } ; int n = arr . length ; System . out . print ( find@@ Largest@@ Number ( arr , n ) + "@@ NEW_@@ LINE@@ "@@ )@@ ; } }
Find a number such that maximum in array is minimum possible after XOR 13633 | import java . util . * ; class GF@@ G { static int Recursive@@ Function ( ArrayList < Integer > ref , int bit ) { if ( ref . size ( ) == 0 bit < 0 ) return 0 ; ArrayList < Integer > curr_@@ on = new ArrayList < > ( ) ; ArrayList < Integer > curr_@@ off = new ArrayList < > ( ) ; for ( int i = 0 ; i < ref . size ( ) ; i ++ ) { if ( ( ( ref . get ( i ) >> bit ) & 1 ) == 0 ) curr_@@ off . add ( ref . get ( i ) ) ; else curr_@@ on . add ( ref . get ( i ) ) ; } if ( curr_@@ off . size ( ) == 0 ) return Recursive@@ Function ( curr_@@ on , bit - 1 ) ; if ( curr_@@ on . size ( ) == 0 ) return Recursive@@ Function ( curr_@@ off , bit - 1 ) ; return Math . min ( Recursive@@ Function ( curr_@@ off , bit - 1 ) , Recursive@@ Function ( curr_@@ on , bit - 1 ) ) + ( 1 << bit ) ; } static void Print@@ Minimum ( int a [ ] , int n ) { ArrayList < Integer > v = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) v . add ( a [ i ] ) ; System . out . println ( Recursive@@ Function ( v , 30 ) ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 2 , 1 } ; int size = arr . length ; Print@@ Minimum ( arr , size ) ; } }
XOR of all Prime numbers in an Array at positions di@@ visible by K 13643 | class GF@@ G { static int MAX = 10000@@ 05 ; static boolean prime [ ] = new boolean [ MAX ] ; static void Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( boolean [ ] prime ) { prime [ 1 ] = false ; prime [ 0 ] = false ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } } static void pri@@ me_@@ xor ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < MAX ; i ++ ) prime [ i ] = true ; Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( prime ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { if ( ( i + 1 ) % k == 0 ) { ans ^= arr [ i ] ; } } } System . out . println ( ans ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 5 , 7 , 11 , 8 } ; int n = arr . length ; int K = 2 ; pri@@ me_@@ xor ( arr , n , K ) ; } }
Count of numbers which can be made power of 2 by given operation 13712 | import java . util . * ; class GF@@ G { static boolean is@@ PowerOf@@ Two ( int x ) { if ( x == 0 ) return false ; if ( ( x & ( x - 1 ) ) == 0 ) return true ; else return false ; } static int count@@ Num ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( is@@ PowerOf@@ Two ( a [ i ] ) || is@@ PowerOf@@ Two ( a [ i ] + 1 ) ) count ++ ; } return count ; } public static void main ( String args [ ] ) { int arr [ ] = { 5 , 6 , 9 , 3 , 1 } ; int n = arr . length ; System . out . println ( count@@ Num ( arr , n ) ) ; } }
XOR of all elements of array with set bits equal to K 13727 | import java . util . * ; class GF@@ G { static int xor@@ Given@@ Set@@ Bits ( int arr [ ] , int n , int k ) { Vector < Integer > v = new Vector < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( Integer . bit@@ Count ( arr [ i ] ) == k ) { v . add ( arr [ i ] ) ; } } int result = v . get ( 0 ) ; for ( int i = 1 ; i < v . size ( ) ; i ++ ) { result = result ^ v . get ( i ) ; } return result ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 13 , 1 , 19 , 7 } ; int n = arr . length ; int k = 3 ; System . out . println ( xor@@ Given@@ Set@@ Bits ( arr , n , k ) ) ; } }
Number of leading zeros in binary representation of a given number 13735 | import java . io . * ; class GF@@ G { static int count@@ Zeros ( int x ) { int y ; int n = 32 ; y = x >> 16 ; if ( y != 0 ) { n = n - 16 ; x = y ; } y = x >> 8 ; if ( y != 0 ) { n = n - 8 ; x = y ; } y = x >> 4 ; if ( y != 0 ) { n = n - 4 ; x = y ; } y = x >> 2 ; if ( y != 0 ) { n = n - 2 ; x = y ; } y = x >> 1 ; if ( y != 0 ) return n - 2 ; return n - x ; } public static void main ( String [ ] args ) { int x = 101 ; System . out . println ( count@@ Zeros ( x ) ) ; } }
Count pairs with Bit@@ wise OR as Even number 13776 | import java . io . * ; class GF@@ G { static int find@@ Even@@ Pair ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( ( ! ( ( A [ i ] & 1 ) > 0 ) ) ) count ++ ; return count * ( count - 1 ) / 2 ; } public static void main ( String [ ] args ) { int A [ ] = { 5 , 6 , 2 , 8 } ; int N = A . length ; System . out . println ( find@@ Even@@ Pair ( A , N ) ) ; } }
Le@@ f@@ to@@ ver element after performing alternate Bit@@ wise OR and Bit@@ wise XOR operations on adjacent pairs 13826 | import java . util . * ; class GF@@ G { static int N = 1000 ; static int last@@ Element ( int a [ ] , int n ) { int steps = 1 ; Vector < Integer > [ ] v = new Vector [ N ] ; for ( int i = 0 ; i < N ; i ++ ) v [ i ] = new Vector < Integer > ( ) ; if ( n == 1 ) return a [ 0 ] ; for ( int i = 0 ; i < n ; i += 2 ) v [ steps ] . add ( a [ i ] a [ i + 1 ] ) ; while ( v [ steps ] . size ( ) > 1 ) { steps += 1 ; for ( int i = 0 ; i < v [ steps - 1 ] . size ( ) ; i += 2 ) { if ( steps % 2 == 1 ) v [ steps ] . add ( v [ steps - 1 ] . get ( i ) | v [ steps - 1 ] . get ( i + 1 ) ) ; v [ steps ] . add ( v [ steps - 1 ] . get ( i ) ^ v [ steps - 1 ] . get ( i + 1 ) ) ; } } return v [ steps ] . get ( 0 ) ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 4 , 5 , 6 } ; int n = a . length ; int index = 0 ; int value = 2 ; a [ 0 ] = 2 ; System . out . println ( last@@ Element ( a , n ) ) ; index = 3 ; value = 5 ; a [ index ] = value ; System . out . println ( last@@ Element ( a , n ) ) ; } }
XN@@ OR of two numbers 13858 | import java . util . * ; import java . lang . * ; public class Gf@@ G { public static int x@@ nor ( int a , int b ) { if ( a < b ) { int t = a ; a = b ; b = t ; } if ( a == 0 && b == 0 ) return 1 ; int a_@@ rem = 0 ; int b_@@ rem = 0 ; int count = 0 ; int x@@ nor@@ num = 0 ; while ( true ) { a_@@ rem = a & 1 ; b_@@ rem = b & 1 ; if ( a_@@ rem == b_@@ rem ) x@@ nor@@ num |= ( 1 << count ) ; count ++ ; a = a >> 1 ; b = b >> 1 ; if ( a < 1 ) break ; } return x@@ nor@@ num ; } public static void main ( String argc [ ] ) { int a = 10 , b = 50 ; System . out . println ( x@@ nor ( a , b ) ) ; } }
Quo@@ ti@@ ent and remainder divid@@ ing by 2 ^ k ( a power of 2 ) 13870 | import java . io . * ; public class GF@@ G { static void divide ( int n , int m ) { System . out . println ( " Remain@@ der ▁ = ▁ " + ( ( n ) & ( m - 1 ) ) ) ; System . out . println ( " Quo@@ ti@@ ent ▁ = ▁ " + ( n >> ( int ) ( Math . log ( m ) / Math . log ( 2 ) ) ) ) ; } static public void main ( String [ ] args ) { int n = 43 , m = 8 ; divide ( n , m ) ; } }
Check if one of the numbers is one '@@ s complement of the other 13885 | import java . util . * ; import java . lang . * ; public class Gf@@ G { public static boolean are@@ All@@ Bits@@ Set ( long n ) { if ( n == 0 ) return false ; if ( ( ( n + 1 ) & n ) == 0 ) return true ; return false ; } public static boolean is@@ One@@ s@@ Comp@@ lement@@ Of@@ Other ( long a , long b ) { return are@@ All@@ Bits@@ Set ( a ^ b ) ; } public static void main ( String argc [ ] ) { long a = 10 , b = 5 ; if ( is@@ One@@ s@@ Comp@@ lement@@ Of@@ Other ( a , b ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
Count total bits in a number 13895 | import java . io . * ; class GF@@ G { static int count@@ Bits ( int number ) { return ( int ) ( Math . log ( number ) / Math . log ( 2 ) + 1 ) ; } public static void main ( String [ ] args ) { int num = 65 ; System . out . println ( count@@ Bits ( num ) ) ; } }
Extract ' k ' bits from a given position in a number . 13915 | class GF@@ G { static int bit@@ Extr@@ acted ( int number , int k , int p ) { return ( ( ( 1 << k ) - 1 ) & ( number >> ( p - 1 ) ) ) ; } public static void main ( String [ ] args ) { int number = 171 , k = 5 , p = 2 ; System . out . println ( " The ▁ extracted ▁ number ▁ is ▁ " + bit@@ Extr@@ acted ( number , k , p ) ) ; } }
W@@ ays to represent a number as a sum of 1 ' s ▁ and ▁ 2' s 13965 | class GF@@ G { static void multiply ( int F [ ] [ ] , int M [ ] [ ] ) { int x = F [ 0 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 0 ] ; int y = F [ 0 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 1 ] ; int z = F [ 1 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 0 ] ; int w = F [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] ; F [ 0 ] [ 0 ] = x ; F [ 0 ] [ 1 ] = y ; F [ 1 ] [ 0 ] = z ; F [ 1 ] [ 1 ] = w ; } static void power ( int F [ ] [ ] , int n ) { if ( n == 0 n == 1 ) { return ; } int M [ ] [ ] = { { 1 , 1 } , { 1 , 0 } } ; power ( F , n / 2 ) ; multiply ( F , F ) ; if ( n % 2 != 0 ) { multiply ( F , M ) ; } } static int count@@ W@@ ays ( int n ) { int F [ ] [ ] = { { 1 , 1 } , { 1 , 0 } } ; if ( n == 0 ) { return 0 ; } power ( F , n ) ; return F [ 0 ] [ 0 ] ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( count@@ W@@ ays ( n ) ) ; } }
XOR counts of 0 s and 1 s in binary representation 13976 | class GF@@ G { static int count@@ XOR ( int n ) { int count@@ 0 = 0 , count@@ 1 = 0 ; while ( n != 0 ) { if ( n % 2 == 0 ) count@@ 0 ++ ; else count@@ 1 ++ ; n /= 2 ; } return ( count@@ 0 ^ count@@ 1 ) ; } public static void main ( String [ ] args ) { int n = 31 ; System . out . println ( count@@ XOR ( n ) ) ; } }
Equal Sum and XOR 13985 | import java . util . * ; class GF@@ G { public static int count@@ Values ( int n ) { int count@@ V = 0 ; for ( int i = 0 ; i <= n ; i ++ ) if ( ( n + i ) == ( n ^ i ) ) count@@ V ++ ; return count@@ V ; } public static void main ( String [ ] args ) { int n = 12 ; System . out . println ( count@@ Values ( n ) ) ; } }
Calculate 7 n / 8 without using division and multiplication operators 14020 | import java . io . * ; class GF@@ G { static int multiply@@ By@@ Se@@ ven@@ By@@ E@@ ight ( int n ) { return ( n - ( n >> 3 ) ) ; } public static void main ( String args [ ] ) { int n = 9 ; System . out . println ( multiply@@ By@@ Se@@ ven@@ By@@ E@@ ight ( n ) ) ; } }
Maximum length pal@@ ind@@ ro@@ mic substring for every index such that it starts and ends at that index 3051 | class GF@@ G { public static void print@@ Lon@@ gest@@ Pal@@ ind@@ ro@@ me ( String S , int N ) { int pal@@ Length [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { int maxlength = 1 ; for ( int j = 0 ; j < i ; j ++ ) { if ( S . charAt ( j ) == S . charAt ( i ) ) { if ( is@@ Pal@@ ind@@ ro@@ me ( S , j , i ) ) { maxlength = i - j + 1 ; break ; } } } for ( int j = N - 1 ; j > i ; j -- ) { if ( S . charAt ( j ) == S . charAt ( i ) ) { if ( is@@ Pal@@ ind@@ ro@@ me ( S , i , j ) ) { maxlength = Math . max ( j - i + 1 , maxlength ) ; break ; } } } pal@@ Length [ i ] = maxlength ; } for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( pal@@ Length [ i ] + " ▁ " ) ; } } public static boolean is@@ Pal@@ ind@@ ro@@ me ( String S , int i , int j ) { while ( i < j ) { if ( S . charAt ( i ) != S . charAt ( j ) ) return false ; i ++ ; j -- ; } return true ; } public static void main ( String [ ] args ) { String S = " bab@@ aba " ; int N = S . length ( ) ; print@@ Lon@@ gest@@ Pal@@ ind@@ ro@@ me ( S , N ) ; } }
Check if array can be sorted with one swap 3944 | import java . util . Arrays ; class GF@@ G { static boolean check@@ Sorted ( int n , int arr [ ] ) { int [ ] b = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) b [ i ] = arr [ i ] ; Arrays . sort ( b , 0 , n ) ; int ct = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != b [ i ] ) ct ++ ; if ( ct == 0 ct == 2 ) return true ; else return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 3 , 4 , 2 } ; int n = arr . length ; if ( check@@ Sorted ( n , arr ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
Making elements distinct in a sorted array by minimum increments 4066 | import java . io . * ; class GF@@ G { static int min@@ Sum ( int arr [ ] , int n ) { int sum = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) { int j = i ; while ( j < n && arr [ j ] <= arr [ j - 1 ] ) { arr [ j ] = arr [ j ] + 1 ; j ++ ; } } sum = sum + arr [ i ] ; } return sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 2 , 3 , 5 , 6 } ; int n = arr . length ; System . out . println ( min@@ Sum ( arr , n ) ) ; } }
Making elements distinct in a sorted array by minimum increments 4067 | import java . io . * ; class GF@@ G { static int min@@ Sum ( int arr [ ] , int n ) { int sum = arr [ 0 ] , prev = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] <= prev ) { prev = prev + 1 ; sum = sum + prev ; } else { sum = sum + arr [ i ] ; prev = arr [ i ] ; } } return sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 2 , 3 , 5 , 6 } ; int n = arr . length ; System . out . println ( min@@ Sum ( arr , n ) ) ; } }
Count of distinct permutation of a String obtained by sw@@ apping only un@@ equal characters 4916 | import java . util . HashMap ; class GF@@ G { static int valid@@ Per@@ mutations ( String str ) { HashMap < Character , Integer > m = new HashMap < Character , Integer > ( ) ; int count = str . length ( ) , ans = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { m . put ( str . charAt ( i ) , m . getOr@@ Default ( str . charAt ( i ) , 0 ) + 1 ) ; } for ( int i = 0 ; i < str . length ( ) ; i ++ ) { ans += count - m . get ( str . charAt ( i ) ) ; m . put ( str . charAt ( i ) , m . get ( str . charAt ( i ) ) - 1 ) ; count -- ; } return ans + 1 ; } public static void main ( String [ ] args ) { String str = " sst@@ t " ; System . out . println ( valid@@ Per@@ mutations ( str ) ) ; } }
Sorting array with reverse around middle 5766 | import java . util . * ; class GF@@ G { static boolean if@@ Possible ( int arr [ ] , int n ) { int copy [ ] = Arrays . copyOf ( arr , arr . length ) ; Arrays . sort ( copy ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! ( arr [ i ] == copy [ i ] ) && ! ( arr [ n - 1 - i ] == copy [ i ] ) ) return false ; } return true ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 7 , 6 , 4 , 5 , 3 , 2 , 8 } ; int n = arr . length ; if ( if@@ Possible ( arr , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
Count of numbers between range having only non 6490 | import java . util . * ; class GF@@ G { static int M = 20 ; static int dp [ ] [ ] [ ] [ ] = new int [ M ] [ 165 ] [ M ] [ 2 ] ; static int n , m ; static int count ( int pos , int sum , int rem , int ti@@ ght , int non@@ z , Vector < Integer > num ) { if ( pos == num . size ( ) ) { if ( rem == 0 && sum == n ) return 1 ; return 0 ; } if ( dp [ pos ] [ sum ] [ rem ] [ ti@@ ght ] != - 1 ) return dp [ pos ] [ sum ] [ rem ] [ ti@@ ght ] ; int ans = 0 ; int limit = ( ti@@ ght != 0 ? 9 : num . get ( pos ) ) ; for ( int d = 0 ; d <= limit ; d ++ ) { if ( d == 0 && non@@ z != 0 ) continue ; int curr@@ Sum = sum + d ; int curr@@ Rem = ( rem * 10 + d ) % m ; int curr@@ F = ( ti@@ ght != 0 || ( d < num . get ( pos ) ) ) ? 1 : 0 ; ans += count ( pos + 1 , curr@@ Sum , curr@@ Rem , curr@@ F , ( non@@ z != 0 d != 0 ) ? 1 : 0 , num ) ; } return dp [ pos ] [ sum ] [ rem ] [ ti@@ ght ] = ans ; } static int solve ( int x ) { Vector < Integer > num = new Vector < Integer > ( ) ; while ( x != 0 ) { num . add ( x % 10 ) ; x /= 10 ; } Collections . reverse ( num ) ; for ( int i = 0 ; i < M ; i ++ ) for ( int j = 0 ; j < 165 ; j ++ ) for ( int k = 0 ; k < M ; k ++ ) for ( int l = 0 ; l < 2 ; l ++ ) dp [ i ] [ j ] [ k ] [ l ] = - 1 ; return count ( 0 , 0 , 0 , 0 , 0 , num ) ; } public static void main ( String args [ ] ) { int L = 1 , R = 100 ; n = 8 ; m = 2 ; System . out . print ( solve ( R ) - solve ( L ) ) ; } }
Maximum sub@@ array sum in O ( n ) using prefix sum 6682 | class GF@@ G { static int maximum@@ Sum@@ Sub@@ array ( int arr [ ] , int n ) { int min_@@ prefix_@@ sum = 0 ; int res = Integer . MIN_VALUE ; int prefix_@@ sum [ ] = new int [ n ] ; prefix_@@ sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix_@@ sum [ i ] = prefix_@@ sum [ i - 1 ] + arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { res = Math . max ( res , prefix_@@ sum [ i ] - min_@@ prefix_@@ sum ) ; min_@@ prefix_@@ sum = Math . min ( min_@@ prefix_@@ sum , prefix_@@ sum [ i ] ) ; } return res ; } public static void main ( String [ ] args ) { int ar@@ r1 [ ] = { - 2 , - 3 , 4 , - 1 , - 2 , 1 , 5 , - 3 } ; int n1 = ar@@ r1 . length ; System . out . println ( maximum@@ Sum@@ Sub@@ array ( ar@@ r1 , n1 ) ) ; int ar@@ r2 [ ] = { 4 , - 8 , 9 , - 4 , 1 , - 8 , - 1 , 6 } ; int n2 = ar@@ r2 . length ; System . out . println ( maximum@@ Sum@@ Sub@@ array ( ar@@ r2 , n2 ) ) ; } }
Counts paths from a point to reach Origin 6792 | import java . io . * ; class GF@@ G { static int count@@ Paths ( int n , int m ) { int dp [ ] [ ] = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; return dp [ n ] [ m ] ; } public static void main ( String [ ] args ) { int n = 3 , m = 2 ; System . out . println ( " ▁ Number ▁ of ▁ Paths ▁ " + count@@ Paths ( n , m ) ) ; } }
How to solve a Dynamic Programming Problem ? 6837 | public static int [ ] dp = new int [ MAX@@ N ] ; static int solve ( int n ) { if ( n < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( dp [ n ] != - 1 ) return dp [ n ] ; return dp [ n ] = solve ( n - 1 ) + solve ( n - 3 ) + solve ( n - 5 ) ; }
Printing Shor@@ test Common Super@@ sequence 6940 | class GF@@ G { static String print@@ Shor@@ test@@ Super@@ Seq ( String X , String Y ) { int m = X . length ( ) ; int n = Y . length ( ) ; int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) { dp [ i ] [ j ] = j ; } else if ( j == 0 ) { dp [ i ] [ j ] = i ; } else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) { dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; } else { dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } } String str = " " ; int i = m , j = n ; while ( i > 0 && j > 0 ) { if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) { str += ( X . charAt ( i - 1 ) ) ; i -- ; j -- ; } else if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j - 1 ] ) { str += ( Y . charAt ( j - 1 ) ) ; j -- ; } else { str += ( X . charAt ( i - 1 ) ) ; i -- ; } } while ( i > 0 ) { str += ( X . charAt ( i - 1 ) ) ; i -- ; } while ( j > 0 ) { str += ( Y . charAt ( j - 1 ) ) ; j -- ; } str = reverse ( str ) ; return str ; } static String reverse ( String input ) { char [ ] temp@@ array = input . toCharArray ( ) ; int left , right = 0 ; right = temp@@ array . length - 1 ; for ( left = 0 ; left < right ; left ++ , right -- ) { char temp = temp@@ array [ left ] ; temp@@ array [ left ] = temp@@ array [ right ] ; temp@@ array [ right ] = temp ; } return String . valueOf ( temp@@ array ) ; } public static void main ( String [ ] args ) { String X = " AGG@@ TAB " ; String Y = " GX@@ TX@@ AY@@ B " ; System . out . println ( print@@ Shor@@ test@@ Super@@ Seq ( X , Y ) ) ; } }
Printing Shor@@ test Common Super@@ sequence 7070 | class Matrix@@ Chain@@ Multiplic@@ ation { static int Matrix@@ Chain@@ Order ( int p [ ] , int n ) { int m [ ] [ ] = new int [ n ] [ n ] ; int i , j , k , L , q ; for ( i = 1 ; i < n ; i ++ ) m [ i ] [ i ] = 0 ; for ( L = 2 ; L < n ; L ++ ) { for ( i = 1 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; if ( j == n ) continue ; m [ i ] [ j ] = Integer . MAX_VALUE ; for ( k = i ; k <= j - 1 ; k ++ ) { q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( q < m [ i ] [ j ] ) m [ i ] [ j ] = q ; } } } return m [ 1 ] [ n - 1 ] ; } public static void main ( String args [ ] ) { int arr [ ] = new int [ ] { 1 , 2 , 3 , 4 } ; int size = arr . length ; System . out . println ( " Minimum ▁ number ▁ of ▁ multiplic@@ ations ▁ is ▁ " + Matrix@@ Chain@@ Order ( arr , size ) ) ; } }
Coin Change | DP 7071 | import java . util . * ; class GF@@ G { static int count ( int S [ ] , int m , int n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 0 ; if ( m <= 0 && n >= 1 ) return 0 ; return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 3 } ; int m = arr . length ; System . out . println ( count ( arr , m , 4 ) ) ; } }
Find the count of sub@@ strings in alphabe@@ tic order 8070 | import java . util . * ; class Solution { static int find@@ Sub@@ string@@ Count ( String str ) { int result = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( str . charAt ( i ) + 1 == str . charAt ( i + 1 ) ) { result ++ ; while ( str . charAt ( i ) + 1 == str . charAt ( i + 1 ) ) { i ++ ; } } } return result ; } public static void main ( String args [ ] ) { String str = " alphabet " ; System . out . println ( find@@ Sub@@ string@@ Count ( str ) ) ; } }
Round the given number to nearest multiple of 10 8348 | import java . util . * ; class GF@@ G { static int round ( int n ) { int a = ( n / 10 ) * 10 ; int b = a + 10 ; return ( n - a > b - n ) ? b : a ; } public static void main ( String [ ] args ) { int n = 47@@ 22 ; System . out . println ( round ( n ) ) ; } }
Encrypt string with product of number of vo@@ w@@ els and con@@ son@@ ants in substring of size k 8366 | class GF@@ G { static boolean is@@ Vo@@ wel ( char c ) { return ( c == ' a ' c == ' e ' c == ' i ' c == ' o ' c == ' u ' ) ; } static String encrypt@@ String ( String s , int n , int k ) { int count@@ Vo@@ w@@ els = 0 ; int count@@ Con@@ son@@ ants = 0 ; String ans = " " ; for ( int l = 0 ; l <= n - k ; l ++ ) { count@@ Vo@@ w@@ els = 0 ; count@@ Con@@ son@@ ants = 0 ; for ( int r = l ; r <= l + k - 1 ; r ++ ) { if ( is@@ Vo@@ wel ( s . charAt ( r ) ) == true ) { count@@ Vo@@ w@@ els ++ ; } else { count@@ Con@@ son@@ ants ++ ; } } ans += String . valueOf ( count@@ Vo@@ w@@ els * count@@ Con@@ son@@ ants ) ; } return ans ; } static public void main ( String [ ] args ) { String s = " hello " ; int n = s . length ( ) ; int k = 2 ; System . out . println ( encrypt@@ String ( s , n , k ) ) ; } }
Ham@@ ming Distance between two strings 8624 | class GF@@ G { static int ham@@ ming@@ Dist ( String str1 , String str2 ) { int i = 0 , count = 0 ; while ( i < str1 . length ( ) ) { if ( str1 . charAt ( i ) != str2 . charAt ( i ) ) count ++ ; i ++ ; } return count ; } public static void main ( String [ ] args ) { String str1 = " ge@@ ek@@ spr@@ acti@@ ce " ; String str2 = " ner@@ d@@ spr@@ acti@@ se " ; System . out . println ( ham@@ ming@@ Dist ( str1 , str2 ) ) ; } }
Program to find volume and surface area of pent@@ ag@@ onal pri@@ sm 9311 | import java . util . * ; class solution { static float surface@@ Area ( float a , float b , float h ) { return 5 * a * b + 5 * b * h ; } static float volume ( float b , float h ) { return ( 5 * b * h ) / 2 ; } public static void main ( String arr [ ] ) { float a = 5 ; float b = 3 ; float h = 7 ; System . out . println ( " surface ▁ area = ▁ " + surface@@ Area ( a , b , h ) + " , ▁ " ) ; System . out . println ( " volume = ▁ " + volume ( b , h ) ) ; } }
Maxim@@ ize 3 rd element sum in quad@@ rup@@ let sets formed from given Array 2746 | import java . util . * ; class GF@@ G { static int form@@ Quad@@ rup@@ lets ( Integer arr [ ] , int n ) { int ans = 0 , pairs = 0 ; pairs = n / 4 ; Arrays . sort ( arr , Collections . reverse@@ Order ( ) ) ; for ( int i = 0 ; i < n - pairs ; i += 3 ) { ans += arr [ i + 2 ] ; } return ans ; } public static void main ( String [ ] args ) { Integer arr [ ] = { 2 , 1 , 7 , 5 , 5 , 4 , 1 , 1 , 3 , 3 , 2 , 2 } ; int n = arr . length ; System . out . print ( form@@ Quad@@ rup@@ lets ( arr , n ) + "@@ NEW_@@ LINE@@ "@@ )@@ ; } }
Maxim@@ ize X such that sum of numbers in range [ 1 , X ] is at most K 2915 | import java . util . * ; class GF@@ G { static int Count ( int N , int K ) { if ( K == 0 ) return 0 ; int res = 0 ; int low = 1 , high = N ; while ( low <= high ) { int mid = ( low + high ) / 2 ; int sum = ( mid * mid + mid ) / 2 ; if ( sum <= K ) { res = Math . max ( res , mid ) ; low = mid + 1 ; } else { high = mid - 1 ; } } return res ; } public static void main ( String [ ] args ) { int N = 6 , K = 14 ; System . out . println ( Count ( N , K ) ) ; } }
Maximum elements that can be removed from front of two arrays such that their sum is at most K 2947 | import java . io . * ; import java . util . * ; class GF@@ G { static void max@@ Items ( int n , int m , int a [ ] , int b [ ] , int K ) { int count = 0 ; int A [ ] = new int [ n + 1 ] ; int B [ ] = new int [ m + 1 ] ; A [ 0 ] = 0 ; B [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { A [ i ] = a [ i - 1 ] + A [ i - 1 ] ; } for ( int i = 1 ; i <= m ; i ++ ) { B [ i ] = b [ i - 1 ] + B [ i - 1 ] ; } for ( int i = 0 ; i <= n ; i ++ ) { if ( A [ i ] > K ) break ; int rem = K - A [ i ] ; int j = 0 ; int lo = 0 , hi = m ; while ( lo <= hi ) { int mid = ( lo + hi ) / 2 ; if ( B [ mid ] <= rem ) { j = mid ; lo = mid + 1 ; } else { hi = mid - 1 ; } } count = Math . max ( j + i , count ) ; } System . out . print ( count ) ; } public static void main ( String [ ] args ) { int n = 4 , m = 5 , K = 7 ; int A [ ] = { 2 , 4 , 7 , 3 } ; int B [ ] = { 1 , 9 , 3 , 4 , 5 } ; max@@ Items ( n , m , A , B , K ) ; } }
Number which is co 2965 | import java . io . * ; import java . lang . * ; import java . util . * ; class GF@@ G { static boolean is@@ Prime ( int N ) { if ( N == 1 ) return false ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) return false ; } return true ; } static int find@@ Co@@ Prime ( int L , int R ) { int co@@ Prime ; for ( int i = R + 1 ; ; i ++ ) { if ( is@@ Prime ( i ) ) { co@@ Prime = i ; break ; } } return co@@ Prime ; } public static void main ( String [ ] args ) { int L = 16 , R = 17 ; System . out . println ( find@@ Co@@ Prime ( L , R ) ) ; } }
Frequency of lex@@ ico@@ graphic@@ ally K@@ th smallest character in the a string 3062 | import java . io . * ; import java . util . * ; class GF@@ G { public static void K@@ th@@ Character ( String S , int N , int K ) { char str@@ array [ ] = S . toCharArray ( ) ; Arrays . sort ( str@@ array ) ; char ch = str@@ array [ K - 1 ] ; int count = 0 ; for ( char c : str@@ array ) { if ( c == ch ) count ++ ; } System . out . println ( count ) ; } public static void main ( String [ ] args ) { String S = " ge@@ ek@@ s@@ forge@@ e@@ ks " ; int N = S . length ( ) ; int K = 3 ; K@@ th@@ Character ( S , N , K ) ; } }
Lon@@ gest substring with no pair of adjacent characters are adjacent English alphab@@ ets 3063 | import java . io . * ; class GF@@ G { static void find@@ Sub@@ string ( String S ) { String T = " " ; String ans = " " ; int l = 0 ; T += S . charAt ( 0 ) ; for ( int i = 1 ; i < S . length ( ) ; i ++ ) { if ( Math . abs ( S . charAt ( i ) - S . charAt ( i - 1 ) ) == 1 ) { l = T . length ( ) ; if ( l > ans . length ( ) ) { ans = T ; } T = " " ; T += S . charAt ( i ) ; } else { T += S . charAt ( i ) ; } } l = T . length ( ) ; if ( l > ans . length ( ) ) { ans = T ; } System . out . println ( ans ) ; } public static void main ( String [ ] args ) { String S = " a@@ ab@@ d@@ ml " ; find@@ Sub@@ string ( S ) ; } }
Count array elements whose all distinct digits appear in K 3113 | import java . io . * ; import java . util . * ; class GF@@ G { static int noOf@@ Valid@@ K@@ bers ( int K , int arr [ ] ) { HashSet < Integer > set = new HashSet < > ( ) ; while ( K != 0 ) { set . add ( K % 10 ) ; K = K / 10 ; } int count = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { int no = arr [ i ] ; boolean flag = true ; while ( no != 0 ) { int digit = no % 10 ; if ( ! set . contains ( digit ) ) { flag = false ; break ; } no = no / 10 ; } if ( flag == true ) { count ++ ; } } return count ; } public static void main ( String [ ] args ) { int K = 12 ; int arr [ ] = { 1 , 12 , 12@@ 22 , 13 , 2 } ; System . out . println ( noOf@@ Valid@@ K@@ bers ( K , arr ) ) ; } }
S@@ malle@@ st divisor of N closest to X 3129 | import java . util . * ; class GF@@ G { static final int MAX = 10000 ; static Vector < Integer > [ ] di@@ visors = new Vector [ MAX + 1 ] ; static void compute@@ Di@@ visors ( ) { for ( int i = 1 ; i <= MAX ; i ++ ) { for ( int j = i ; j <= MAX ; j += i ) { di@@ visors [ j ] . add ( i ) ; } } } static int get@@ Close@@ st ( int val1 , int val2 , int target ) { if ( target - val1 >= val2 - target ) return val2 ; else return val1 ; } static int find@@ Close@@ st ( Vector < Integer > array , int n , int target ) { Integer [ ] arr = array . toArray ( new Integer [ array . size ( ) ] ) ; if ( target <= arr [ 0 ] ) return arr [ 0 ] ; if ( target >= arr [ n - 1 ] ) return arr [ n - 1 ] ; int i = 0 , j = n , mid = 0 ; while ( i < j ) { mid = ( i + j ) / 2 ; if ( arr [ mid ] == target ) return arr [ mid ] ; if ( target < arr [ mid ] ) { if ( mid > 0 && target > arr [ mid - 1 ] ) return get@@ Close@@ st ( arr [ mid - 1 ] , arr [ mid ] , target ) ; j = mid ; } else { if ( mid < n - 1 && target < arr [ mid + 1 ] ) return get@@ Close@@ st ( arr [ mid ] , arr [ mid + 1 ] , target ) ; i = mid + 1 ; } } return arr [ mid ] ; } static void print@@ Close@@ st ( int N , int X ) { compute@@ Di@@ visors ( ) ; int ans = find@@ Close@@ st ( di@@ visors [ N ] , di@@ visors [ N ] . size ( ) , X ) ; System . out . print ( ans ) ; } public static void main ( String [ ] args ) { int N = 16 , X = 5 ; for ( int i = 0 ; i < di@@ visors . length ; i ++ ) di@@ visors [ i ] = new Vector < Integer > ( ) ; print@@ Close@@ st ( N , X ) ; } }
Count maximum concatenation of pairs from given array that are di@@ visible by 3 3161 | public class GF@@ G { static int count@@ Div ( int [ ] arr ) { int rem@@ 0 = 0 ; int re@@ m1 = 0 ; int re@@ m2 = 0 ; for ( int i : arr ) { int digit@@ Sum = 0 ; digit@@ Sum += i ; if ( digit@@ Sum % 3 == 0 ) { rem@@ 0 += 1 ; } else if ( digit@@ Sum % 3 == 1 ) { re@@ m1 += 1 ; } else { re@@ m2 += 1 ; } } return ( rem@@ 0 / 2 + Math . min ( re@@ m1 , re@@ m2 ) ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 5 , 3 , 2 , 8 , 7 } ; System . out . println ( count@@ Div ( arr ) ) ; } }
Count array elements whose product of digits is a Composite Number 3245 | import java . io . * ; import java . util . * ; class GF@@ G { static int N = 10000@@ 5 ; static void Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( boolean prime [ ] , int p_@@ size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_@@ size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_@@ size ; i += p ) prime [ i ] = false ; } } } static int digit@@ Product ( int number ) { int res = 1 ; while ( number > 0 ) { res *= ( number % 10 ) ; number /= 10 ; } return res ; } static void Distinct@@ Composite@@ Digit@@ Product ( int arr [ ] , int n ) { TreeSet < Integer > output = new TreeSet < Integer > ( ) ; boolean prime [ ] = new boolean [ N + 1 ] ; Arrays . fill ( prime , true ) ; Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( prime , N ) ; for ( int i = 0 ; i < n ; i ++ ) { int ans = digit@@ Product ( arr [ i ] ) ; if ( ans <= 1 ) { continue ; } if ( ! prime [ ans ] ) { output . add ( ans ) ; } } System . out . print ( output . size ( ) ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 13 , 55 , 7 , 13 , 11 , 71 , 233 , 233 , 144 , 89 } ; int n = arr . length ; Distinct@@ Composite@@ Digit@@ Product ( arr , n ) ; } }
Count pairs from a given range whose sum is a Prime Number in that range 3246 | import java . io . * ; import java . util . * ; class GF@@ G { static ArrayList < Integer > simple@@ Si@@ eve ( int l@@ mt , ArrayList < Integer > prime ) { boolean [ ] Si@@ eve = new boolean [ l@@ mt + 1 ] ; Arrays . fill ( Si@@ eve , true ) ; Si@@ eve [ 0 ] = Si@@ eve [ 1 ] = false ; for ( int i = 2 ; i <= l@@ mt ; ++ i ) { if ( Si@@ eve [ i ] == true ) { prime . add ( i ) ; for ( int j = i * i ; j <= l@@ mt ; j += i ) { Si@@ eve [ j ] = false ; } } } return prime ; } static boolean [ ] Seg@@ mented@@ Si@@ eve@@ Fn ( int low , int high ) { int l@@ mt = ( int ) ( Math . sqrt ( high ) ) + 1 ; ArrayList < Integer > prime = new ArrayList < Integer > ( ) ; prime = simple@@ Si@@ eve ( l@@ mt , prime ) ; int n = high - low + 1 ; boolean [ ] seg@@ mented@@ Si@@ eve = new boolean [ n + 1 ] ; Arrays . fill ( seg@@ mented@@ Si@@ eve , true ) ; for ( int i = 0 ; i < prime . size ( ) ; i ++ ) { int low@@ Li@@ m = ( int ) ( low / prime . get ( i ) ) * prime . get ( i ) ; if ( low@@ Li@@ m < low ) { low@@ Li@@ m += prime . get ( i ) ; } for ( int j = low@@ Li@@ m ; j <= high ; j += prime . get ( i ) ) { if ( j != prime . get ( i ) ) { seg@@ mented@@ Si@@ eve [ j - low ] = false ; } } } return seg@@ mented@@ Si@@ eve ; } static int count@@ Pai@@ rs@@ W@@ ho@@ se@@ Sum@@ Prime@@ L_@@ R ( int L , int R ) { boolean [ ] seg@@ mented@@ Si@@ eve = Seg@@ mented@@ Si@@ eve@@ Fn ( L , R ) ; int cnt@@ Pairs = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( seg@@ mented@@ Si@@ eve [ i - L ] ) { cnt@@ Pairs += i / 2 ; } } return cnt@@ Pairs ; } public static void main ( String [ ] args ) { int L = 1 , R = 5 ; System . out . println ( count@@ Pai@@ rs@@ W@@ ho@@ se@@ Sum@@ Prime@@ L_@@ R ( L , R ) ) ; } }
Count quad@@ rup@@ les of given type from given array 3255 | import java . util . * ; class GF@@ G { static int count@@ Sub@@ sequ@@ ec@@ e ( int a [ ] , int n ) { int i , j , k , l ; int answer = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { for ( k = j + 1 ; k < n ; k ++ ) { for ( l = k + 1 ; l < n ; l ++ ) { if ( a [ j ] == a [ l ] && a [ i ] == a [ k ] ) { answer ++ ; } } } } } return answer ; } public static void main ( String [ ] args ) { int [ ] a = { 1 , 2 , 3 , 2 , 1 , 3 , 2 } ; System . out . print ( count@@ Sub@@ sequ@@ ec@@ e ( a , 7 ) ) ; } }
Minim@@ ize sum of prime numbers added to make an array non 3463 | import java . util . * ; class GF@@ G { static final int MAX = 10000000 ; static boolean [ ] is@@ Prime = new boolean [ MAX + 1 ] ; static Vector < Integer > primes = new Vector < Integer > ( ) ; static void Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( ) { Arrays . fill ( is@@ Prime , true ) ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( is@@ Prime [ p ] == true ) { for ( int i = p * p ; i <= MAX ; i += p ) is@@ Prime [ i ] = false ; } } for ( int p = 2 ; p <= MAX ; p ++ ) if ( is@@ Prime [ p ] ) primes . add ( p ) ; } static int pri@@ me_@@ search ( Vector < Integer > primes , int diff ) { int low = 0 ; int high = primes . size ( ) - 1 ; int res = - 1 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( primes . get ( mid ) == diff ) { return primes . get ( mid ) ; } else if ( primes . get ( mid ) < diff ) { low = mid + 1 ; } else { res = primes . get ( mid ) ; high = mid - 1 ; } } return res ; } static int min@@ Cost ( int arr [ ] , int n ) { Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( ) ; int res = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { int diff = arr [ i - 1 ] - arr [ i ] ; int closest_@@ prime = pri@@ me_@@ search ( primes , diff ) ; res += closest_@@ prime ; arr [ i ] += closest_@@ prime ; } } return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 1 , 5 , 4 , 3 } ; int n = 5 ; System . out . print ( min@@ Cost ( arr , n ) ) ; } }
S@@ malle@@ st character in a string having minimum sum of distances between consecutive repeti@@ tions 3491 | import java . util . * ; class GF@@ G { static char min@@ Dist@@ Char ( char [ ] s ) { int n = s . length ; int [ ] first = new int [ 26 ] ; int [ ] last = new int [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { first [ i ] = - 1 ; last [ i ] = - 1 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( first [ s [ i ] - ' a ' ] == - 1 ) { first [ s [ i ] - ' a ' ] = i ; } last [ s [ i ] - ' a ' ] = i ; } int min = Integer . MAX_VALUE ; char ans = '1' ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( last [ i ] == first [ i ] ) continue ; if ( min > last [ i ] - first [ i ] ) { min = last [ i ] - first [ i ] ; ans = ( char ) ( i + ' a ' ) ; } } return ans ; } public static void main ( String [ ] args ) { String str = " ge@@ ek@@ s@@ forge@@ e@@ ks " ; System . out . print ( min@@ Dist@@ Char ( str . toCharArray ( ) ) ) ; } }
Check if an array contains only one distinct element 3543 | import java . util . * ; public class Main { public static void unique@@ Element ( int arr [ ] ) { Set < Integer > set = new HashSet < > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { set . add ( arr [ i ] ) ; } if ( set . size ( ) == 1 ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 9 , 9 , 9 , 9 , 9 , 9 , 9 } ; unique@@ Element ( arr ) ; } }
Count of Root to Leaf Paths consisting of at most M consecutive Nodes having value K 3603 | import java . util . * ; class GF@@ G { @ SuppressWarnings ( " unchecked " ) static Vector < Integer > [ ] adj = new Vector [ 10000@@ 5 ] ; static int [ ] visited = new int [ 10000@@ 5 ] ; static int ans = 0 ; static void dfs ( int node , int count , int m , int arr [ ] , int k ) { visited [ node ] = 1 ; if ( arr [ node - 1 ] == k ) { count ++ ; } else { count = 0 ; } if ( count > m ) { return ; } if ( adj [ node ] . size ( ) == 1 && node != 1 ) { ans ++ ; } for ( int x : adj [ node ] ) { if ( visited [ x ] == 0 ) { dfs ( x , count , m , arr , k ) ; } } } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 1 , 3 , 2 , 1 , 2 , 1 } ; int N = 7 , K = 2 , M = 2 ; for ( int i = 0 ; i < adj . length ; i ++ ) adj [ i ] = new Vector < Integer > ( ) ; adj [ 1 ] . add ( 2 ) ; adj [ 2 ] . add ( 1 ) ; adj [ 1 ] . add ( 3 ) ; adj [ 3 ] . add ( 1 ) ; adj [ 2 ] . add ( 4 ) ; adj [ 4 ] . add ( 2 ) ; adj [ 2 ] . add ( 5 ) ; adj [ 5 ] . add ( 2 ) ; adj [ 3 ] . add ( 6 ) ; adj [ 6 ] . add ( 3 ) ; adj [ 3 ] . add ( 7 ) ; adj [ 7 ] . add ( 3 ) ; int counter = 0 ; dfs ( 1 , counter , M , arr , K ) ; System . out . print ( ans + "@@ NEW_@@ LINE@@ "@@ )@@ ; } }
Distance Tr@@ ave@@ led by Two Tra@@ ins together in the same Direction 3621 | import java . util . * ; import java . lang . * ; class GF@@ G { static int calc_@@ distance ( int A [ ] , int B [ ] , int n ) { int distance_@@ tr@@ ave@@ led_@@ A = 0 ; int distance_@@ tr@@ ave@@ led_@@ B = 0 ; int answer = 0 ; for ( int i = 0 ; i < 5 ; i ++ ) { distance_@@ tr@@ ave@@ led_@@ A += A [ i ] ; distance_@@ tr@@ ave@@ led_@@ B += B [ i ] ; if ( ( distance_@@ tr@@ ave@@ led_@@ A == distance_@@ tr@@ ave@@ led_@@ B ) && ( A [ i ] == B [ i ] ) ) { answer += A [ i ] ; } } return answer ; } public static void main ( String [ ] args ) { int A [ ] = { 1 , 2 , 3 , 2 , 4 } ; int B [ ] = { 2 , 1 , 3 , 1 , 4 } ; int N = A . length ; System . out . println ( calc_@@ distance ( A , B , N ) ) ; } }
Find a pair in Array with second largest product 3633 | class GF@@ G { static void max@@ Product ( int arr [ ] , int N ) { if ( N < 3 ) { return ; } int a = arr [ 0 ] , b = arr [ 1 ] ; int c = 0 , d = 0 ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N - 1 ; j ++ ) { if ( arr [ i ] * arr [ j ] > a * b ) { c = a ; d = b ; a = arr [ i ] ; b = arr [ j ] ; } if ( arr [ i ] * arr [ j ] < a * b && arr [ i ] * arr [ j ] > c * d ) c = arr [ i ] ; d = arr [ j ] ; } System . out . println ( c + " ▁ " + d ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 2 , 67 , 45 , 160 , 78 } ; int N = arr . length ; max@@ Product ( arr , N ) ; } }
Find largest factor of N such that N / F is less than K 3715 | import java . util . Arrays ; class GF@@ G { static void find@@ Max@@ Value ( int N , int K ) { int packages ; int max@@ i = 1 ; for ( int i = 1 ; i <= K ; i ++ ) { if ( N % i == 0 ) max@@ i = Math . max ( max@@ i , i ) ; } packages = N / max@@ i ; System . out . println ( packages ) ; } public static void main ( String [ ] args ) { int N = 8 , K = 7 ; find@@ Max@@ Value ( N , K ) ; } }
Maxim@@ ize number of groups formed with size not smaller than its largest element 3760 | import java . util . * ; class GF@@ G { static void make@@ Groups ( int a [ ] , int n ) { int [ ] v = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { v [ a [ i ] ] ++ ; } int no_@@ of_@@ groups = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { no_@@ of_@@ groups += v [ i ] / i ; v [ i ] = v [ i ] % i ; } int i = 1 ; int total = 0 ; for ( i = 1 ; i <= n ; i ++ ) { if ( v [ i ] != 0 ) { total = v [ i ] ; break ; } } i ++ ; while ( i <= n ) { if ( v [ i ] != 0 ) { total += v [ i ] ; if ( total >= i ) { int rem = total - i ; no_@@ of_@@ groups ++ ; total = rem ; } } i ++ ; } System . out . print ( no_@@ of_@@ groups + "@@ NEW_@@ LINE@@ "@@ )@@ ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 1 , 2 , 2 } ; int size = arr . length ; make@@ Groups ( arr , size ) ; } }
Maximum size of square such that all sub@@ matrices of that size have sum less than K 3797 | class GF@@ G { static final int N = 4 ; static final int M = 5 ; static void pre@@ Process ( int [ ] [ ] mat , int [ ] [ ] aux ) { for ( int i = 0 ; i < M ; i ++ ) aux [ 0 ] [ i ] = mat [ 0 ] [ i ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) aux [ i ] [ j ] = mat [ i ] [ j ] + aux [ i - 1 ] [ j ] ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 1 ; j < M ; j ++ ) aux [ i ] [ j ] += aux [ i ] [ j - 1 ] ; } static int sum@@ Query ( int [ ] [ ] aux , int t@@ li , int tl@@ j , int rb@@ i , int rb@@ j ) { int res = aux [ rb@@ i ] [ rb@@ j ] ; if ( t@@ li > 0 ) res = res - aux [ t@@ li - 1 ] [ rb@@ j ] ; if ( tl@@ j > 0 ) res = res - aux [ rb@@ i ] [ tl@@ j - 1 ] ; if ( t@@ li > 0 && tl@@ j > 0 ) res = res + aux [ t@@ li - 1 ] [ tl@@ j - 1 ] ; return res ; } static boolean check ( int mid , int [ ] [ ] aux , int K ) { boolean satis@@ fies = true ; for ( int x = 0 ; x < N ; x ++ ) { for ( int y = 0 ; y < M ; y ++ ) { if ( x + mid - 1 <= N - 1 && y + mid - 1 <= M - 1 ) { if ( sum@@ Query ( aux , x , y , x + mid - 1 , y + mid - 1 ) > K ) satis@@ fies = false ; } } } return ( satis@@ fies == true ) ; } static int maximum@@ Square@@ Size ( int [ ] [ ] mat , int K ) { int [ ] [ ] aux = new int [ N ] [ M ] ; pre@@ Process ( mat , aux ) ; int low = 1 , high = Math . min ( N , M ) ; int mid ; while ( high - low > 1 ) { mid = ( low + high ) / 2 ; if ( check ( mid , aux , K ) ) { low = mid ; } else high = mid ; } if ( check ( high , aux , K ) ) return high ; return low ; } public static void main ( String [ ] args ) { int K = 30 ; int [ ] [ ] mat = { { 1 , 2 , 3 , 4 , 6 } , { 5 , 3 , 8 , 1 , 2 } , { 4 , 6 , 7 , 5 , 5 } , { 2 , 4 , 8 , 9 , 4 } } ; System . out . print ( maximum@@ Square@@ Size ( mat , K ) ) ; } }
Lon@@ gest sub 3850 | class GF@@ G { static boolean is@@ alpha ( int input_@@ char ) { if ( ( input_@@ char >= 65 && input_@@ char <= 90 ) || ( input_@@ char >= 97 && input_@@ char <= 122 ) ) return true ; return false ; } static void find@@ Sub@@ Array ( int arr [ ] , int n ) { int sum = 0 ; int maxsize = - 1 , start@@ index = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( is@@ alpha ( arr [ i ] ) ) { arr [ i ] = 0 ; } else { arr [ i ] = 1 ; } } for ( int i = 0 ; i < n - 1 ; i ++ ) { sum = ( arr [ i ] == 0 ) ? - 1 : 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] == 0 ) sum += - 1 ; else sum += 1 ; if ( sum == 0 && maxsize < j - i + 1 ) { maxsize = j - i + 1 ; start@@ index = i ; } } } if ( maxsize == - 1 ) System . out . println ( maxsize ) ; else System . out . println ( start@@ index + " ▁ " + ( start@@ index + maxsize - 1 ) ) ; } public static void main ( String [ ] args ) { int arr [ ] = { ' A ' , ' B ' , ' X ' , 4 , 6 , ' X ' , ' a ' } ; int size = arr . length ; find@@ Sub@@ Array ( arr , size ) ; } }
Minimum steps required to reach the end of a matrix | Set 2 3875 | import java . util . * ; class GF@@ G { static int n = 3 ; static class Pair { int first , second ; Pair ( int a , int b ) { first = a ; second = b ; } } static int min@@ Steps ( int arr [ ] [ ] ) { boolean v [ ] [ ] = new boolean [ n ] [ n ] ; Queue < Pair > q = new LinkedList < Pair > ( ) ; q . add ( new Pair ( 0 , 0 ) ) ; int depth = 0 ; while ( q . size ( ) != 0 ) { int x = q . size ( ) ; while ( x -- > 0 ) { Pair y = q . peek ( ) ; int i = y . first , j = y . second ; q . remove ( ) ; if ( v [ i ] [ j ] ) continue ; if ( i == n - 1 && j == n - 1 ) return depth ; v [ i ] [ j ] = true ; if ( i + arr [ i ] [ j ] < n ) q . add ( new Pair ( i + arr [ i ] [ j ] , j ) ) ; if ( j + arr [ i ] [ j ] < n ) q . add ( new Pair ( i , j + arr [ i ] [ j ] ) ) ; } depth ++ ; } return - 1 ; } public static void main ( String args [ ] ) { int arr [ ] [ ] = { { 1 , 1 , 1 } , { 1 , 1 , 1 } , { 1 , 1 , 1 } } ; System . out . println ( min@@ Steps ( arr ) ) ; } }
Inte@@ gers from the range that are composed of a single distinct digit 3930 | import java . io . * ; class GF@@ G { static boolean check@@ Distin@@ ct ( int x ) { int last = x % 10 ; while ( x > 0 ) { if ( x % 10 != last ) return false ; x = x / 10 ; } return true ; } static int find@@ Count ( int L , int R ) { int count = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( check@@ Distin@@ ct ( i ) ) count += 1 ; } return count ; } public static void main ( String [ ] args ) { int L = 10 , R = 50 ; System . out . println ( find@@ Count ( L , R ) ) ; } }
Lower Insertion Point 3932 | public class AQ@@ ES { static int Lower@@ Insertion@@ Point ( int arr [ ] , int n , int X ) { if ( X < arr [ 0 ] ) return 0 ; else if ( X > arr [ n - 1 ] ) return n ; int lower@@ Pnt = 0 ; int i = 1 ; while ( i < n && arr [ i ] < X ) { lower@@ Pnt = i ; i = i * 2 ; } while ( lower@@ Pnt < n && arr [ lower@@ Pnt ] < X ) lower@@ Pnt ++ ; return lower@@ Pnt ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 4 , 4 , 5 , 6 , 7 , 9 } ; int n = arr . length ; int X = 4 ; System . out . println ( Lower@@ Insertion@@ Point ( arr , n , X ) ) ; } }
Check if a string contains a pal@@ ind@@ ro@@ mic sub 3961 | class GF@@ G { static boolean check ( String s ) { for ( int i = 0 ; i < s . length ( ) - 1 ; i ++ ) if ( s . charAt ( i ) == s . charAt ( i + 1 ) ) return true ; return false ; } public static void main ( String [ ] args ) { String s = " x@@ z@@ yy@@ z " ; if ( check ( s ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
Number of anomal@@ ies in an array 3973 | class GF@@ G { static int count@@ Ano@@ mal@@ ies ( int arr [ ] , int n , int k ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && Math . abs ( arr [ i ] - arr [ j ] ) <= k ) break ; if ( j == n ) res ++ ; } return res ; } public static void main ( String args [ ] ) { int arr [ ] = { 7 , 1 , 8 } , k = 5 ; int n = arr . length ; System . out . println ( count@@ Ano@@ mal@@ ies ( arr , n , k ) ) ; } }
Find pair with maximum difference in any column of a Matrix 3986 | public class G@@ OC@@ 1 { static int col@@ Max@@ Diff ( int mat [ ] [ ] ) { int max_@@ diff = Integer . MIN_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { int max_@@ val = mat [ 0 ] [ i ] , min_@@ val = mat [ 0 ] [ i ] ; for ( int j = 1 ; j < N ; j ++ ) { max_@@ val = Math . max ( max_@@ val , mat [ j ] [ i ] ) ; min_@@ val = Math . min ( min_@@ val , mat [ j ] [ i ] ) ; } max_@@ diff = Math . max ( max_@@ diff , max_@@ val - min_@@ val ) ; } return max_@@ diff ; } public static void main ( String args [ ] ) { int mat [ ] [ ] = { { 1 , 2 , 3 , 4 , 5 } , { 5 , 3 , 5 , 4 , 0 } , { 5 , 6 , 7 , 8 , 9 } , { 0 , 6 , 3 , 4 , 12 } , { 9 , 7 , 12 , 4 , 3 } , } ; System . out . println ( " Max ▁ difference ▁ : ▁ " + col@@ Max@@ Diff ( mat ) ) ; } }
Find the only missing number in a sorted array 4014 | class GF@@ G { static int find@@ missing ( int [ ] ar , int N ) { int l = 0 , r = N - 1 ; while ( l <= r ) { int mid = ( l + r ) / 2 ; if ( ar [ mid ] != mid + 1 && ar [ mid - 1 ] == mid ) return ( mid + 1 ) ; if ( ar [ mid ] != mid + 1 ) r = mid - 1 ; else l = mid + 1 ; } return - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 7 , 8 } ; int N = arr . length ; System . out . println ( find@@ missing ( arr , N ) ) ; } }
Lar@@ gest gap in an array 4033 | import java . io . * ; class GF@@ G { static int solve ( int [ ] a , int n ) { int max@@ 1 = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( Math . abs ( a [ i ] - a [ j ] ) > max@@ 1 ) { max@@ 1 = Math . abs ( a [ i ] - a [ j ] ) ; } } } return max@@ 1 ; } static public void main ( String [ ] args ) { int [ ] arr = { - 1 , 2 , 3 , - 4 , - 10 , 22 } ; int size = arr . length ; System . out . println ( " Lar@@ gest ▁ gap ▁ is ▁ : ▁ " + solve ( arr , size ) ) ; } }
Maximum product quad@@ r@@ uple ( sub 4037 | class GF@@ G { static int max@@ Product ( int arr [ ] , int n ) { if ( n < 4 ) { return - 1 ; } int max@@ A = Integer . MIN_VALUE , max@@ B = Integer . MIN_VALUE , max@@ C = Integer . MIN_VALUE , max@@ D = Integer . MIN_VALUE ; int min@@ A = Integer . MAX_VALUE , min@@ B = Integer . MAX_VALUE , min@@ C = Integer . MAX_VALUE , min@@ D = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max@@ A ) { max@@ D = max@@ C ; max@@ C = max@@ B ; max@@ B = max@@ A ; max@@ A = arr [ i ] ; } else if ( arr [ i ] > max@@ B ) { max@@ D = max@@ C ; max@@ C = max@@ B ; max@@ B = arr [ i ] ; } else if ( arr [ i ] > max@@ C ) { max@@ D = max@@ C ; max@@ C = arr [ i ] ; } else if ( arr [ i ] > max@@ D ) { max@@ D = arr [ i ] ; } if ( arr [ i ] < min@@ A ) { min@@ D = min@@ C ; min@@ C = min@@ B ; min@@ B = min@@ A ; min@@ A = arr [ i ] ; } else if ( arr [ i ] < min@@ B ) { min@@ D = min@@ C ; min@@ C = min@@ B ; min@@ B = arr [ i ] ; } else if ( arr [ i ] < min@@ C ) { min@@ D = min@@ C ; min@@ C = arr [ i ] ; } else if ( arr [ i ] < min@@ D ) { min@@ D = arr [ i ] ; } } int x = max@@ A * max@@ B * max@@ C * max@@ D ; int y = min@@ A * min@@ B * min@@ C * min@@ D ; int z = min@@ A * min@@ B * max@@ A * max@@ B ; return Math . max ( x , Math . max ( y , z ) ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , - 4 , 3 , - 6 , 7 , 0 } ; int n = arr . length ; int max = max@@ Product ( arr , n ) ; if ( max == - 1 ) System . out . println ( " No ▁ Quad@@ r@@ uple ▁ Exists " ) ; else System . out . println ( " Maximum ▁ product ▁ is ▁ " + max ) ; } }
Modify a given matrix by pl@@ acing sorted boundary elements in clockwise manner 4162 | import java . util . * ; class GF@@ G { static void print@@ Matrix ( ArrayList < ArrayList < Integer > > a ) { for ( int i = 0 ; i < a . size ( ) ; i ++ ) { for ( int j = 0 ; j < a . get ( i ) . size ( ) ; j ++ ) { System . out . print ( a . get ( i ) . get ( j ) + " ▁ " ) ; } System . out . println ( ) ; } } static void sort@@ Boundary@@ W@@ ise ( ArrayList < ArrayList < Integer > > a ) { int i , k = 0 , l = 0 ; int m = a . size ( ) , n = a . get ( 0 ) . size ( ) ; int n_@@ i , n_@@ k = 0 , n_@@ l = 0 , n_@@ m = m , n_@@ n = n ; while ( k < m && l < n ) { ArrayList < Integer > boundary = new ArrayList < Integer > ( ) ; for ( i = l ; i < n ; ++ i ) { boundary . add ( a . get ( k ) . get ( i ) ) ; } k ++ ; for ( i = k ; i < m ; ++ i ) { boundary . add ( a . get ( i ) . get ( n - 1 ) ) ; } n -- ; if ( k < m ) { for ( i = n - 1 ; i >= l ; -- i ) { boundary . add ( a . get ( m - 1 ) . get ( i ) ) ; } m -- ; } if ( l < n ) { for ( i = m - 1 ; i >= k ; -- i ) { boundary . add ( a . get ( i ) . get ( l ) ) ; } l ++ ; } Collections . sort ( boundary ) ; int ind = 0 ; for ( i = n_@@ l ; i < n_@@ n ; ++ i ) { a . get ( n_@@ k ) . set ( i , boundary . get ( ind ) ) ; ind ++ ; } n_@@ k += 1 ; for ( i = n_@@ k ; i < n_@@ m ; ++ i ) { a . get ( i ) . set ( n_@@ n - 1 , boundary . get ( ind ) ) ; ind ++ ; } n_@@ n -- ; if ( n_@@ k < n_@@ m ) { for ( i = n_@@ n - 1 ; i >= n_@@ l ; -- i ) { a . get ( n_@@ m - 1 ) . set ( i , boundary . get ( ind ) ) ; ind ++ ; } n_@@ m -- ; } if ( n_@@ l < n_@@ n ) { for ( i = n_@@ m - 1 ; i >= n_@@ k ; -- i ) { a . get ( i ) . set ( n_@@ l , boundary . get ( ind ) ) ; ind ++ ; } n_@@ l ++ ; } } print@@ Matrix ( a ) ; } public static void main ( String args [ ] ) { ArrayList < ArrayList < Integer > > matrix = new ArrayList < ArrayList < Integer > > ( ) ; ArrayList < Integer > list1 = new ArrayList < Integer > ( Arrays . asList ( 9 , 7 , 4 , 5 ) ) ; ArrayList < Integer > list2 = new ArrayList < Integer > ( Arrays . asList ( 1 , 6 , 2 , - 6 ) ) ; ArrayList < Integer > list@@ 3 = new ArrayList < Integer > ( Arrays . asList ( 12 , 20 , 2 , 0 ) ) ; ArrayList < Integer > list@@ 4 = new ArrayList < Integer > ( Arrays . asList ( - 5 , - 6 , 7 , - 2 ) ) ; matrix . add ( list1 ) ; matrix . add ( list2 ) ; matrix . add ( list@@ 3 ) ; matrix . add ( list@@ 4 ) ; sort@@ Boundary@@ W@@ ise ( matrix ) ; } }
Maximum score possible from an array with jumps of at most length K 4183 | import java . io . * ; import java . math . * ; import java . util . * ; public class GF@@ G { static int max@@ Score ( int i , int A [ ] , int K , int N , int dp [ ] ) { if ( i >= N - 1 ) return A [ N - 1 ] ; if ( dp [ i ] != - 1 ) return dp [ i ] ; int score = Integer . MIN_VALUE ; for ( int j = 1 ; j <= K ; j ++ ) { score = Math . max ( score , max@@ Score ( i + j , A , K , N , dp ) ) ; } return dp [ i ] = score + A [ i ] ; } static void get@@ Score ( int A [ ] , int N , int K ) { int dp [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) dp [ i ] = - 1 ; System . out . println ( max@@ Score ( 0 , A , K , N , dp ) ) ; } public static void main ( String args [ ] ) { int A [ ] = { 100 , - 30 , - 50 , - 15 , - 20 , - 30 } ; int K = 3 ; int N = A . length ; get@@ Score ( A , N , K ) ; } }
Check if an array can be sorted by sw@@ apping pairs from indices consisting of un@@ equal elements in another array 4185 | import java . io . * ; class GF@@ G { static boolean check@@ if@@ Sorted ( int A [ ] , int B [ ] , int N ) { boolean flag = false ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] > A [ i + 1 ] ) { flag = true ; break ; } } if ( ! flag ) { return true ; } int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( B [ i ] == 0 ) { count ++ ; break ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( B [ i ] == 1 ) { count ++ ; break ; } } if ( count == 2 ) { return true ; } return false ; } public static void main ( String [ ] args ) { int A [ ] = { 3 , 1 , 2 } ; int B [ ] = { 0 , 1 , 1 } ; int N = A . length ; boolean check = check@@ if@@ Sorted ( A , B , N ) ; if ( check ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
Sort an array by left shift@@ ing digits of array elements 4206 | import java . util . * ; class GF@@ G { static boolean is@@ Incre@@ asing ( int [ ] arr ) { for ( int i = 0 ; i < arr . length - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) return false ; } return true ; } static int [ ] sort@@ Arr ( int [ ] arr ) { int prev = - 1 ; for ( int i = 0 ; i < arr . length ; i ++ ) { int opt@@ E@@ le = arr [ i ] ; String str@@ E@@ le = String . valueOf ( arr [ i ] ) ; for ( int idx = 0 ; idx < str@@ E@@ le . length ( ) ; idx ++ ) { String str@@ E@@ le@@ 2 = str@@ E@@ le . substring ( idx ) + str@@ E@@ le . substring ( 0 , idx ) ; int temp = Integer . valueOf ( str@@ E@@ le@@ 2 ) ; if ( temp >= prev && temp < opt@@ E@@ le ) opt@@ E@@ le = temp ; } arr [ i ] = opt@@ E@@ le ; prev = arr [ i ] ; } if ( is@@ Incre@@ asing ( arr ) ) return arr ; else { return new int [ ] { - 1 } ; } } public static void main ( String [ ] args ) { int [ ] arr = { 511 , 321 , 323 , 4@@ 32 , 4@@ 33 } ; int [ ] res = sort@@ Arr ( arr ) ; for ( int i = 0 ; i < res . length ; i ++ ) System . out . print ( res [ i ] + " ▁ " ) ; } }
Minim@@ ize the sum of differences of consecutive elements after removing exactly K elements 4471 | class GF@@ G { final static int N = 100 ; final static int INF = 1000000 ; static int dp [ ] [ ] = new int [ N ] [ N ] ; static int vis [ ] [ ] = new int [ N ] [ N ] ; static int find@@ Sum ( int [ ] arr , int n , int k , int l , int r ) { if ( ( l ) + ( n - 1 - r ) == k ) return arr [ r ] - arr [ l ] ; if ( vis [ l ] [ r ] == 1 ) return dp [ l ] [ r ] ; vis [ l ] [ r ] = 1 ; dp [ l ] [ r ] = Math . min ( find@@ Sum ( arr , n , k , l , r - 1 ) , find@@ Sum ( arr , n , k , l + 1 , r ) ) ; return dp [ l ] [ r ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 100 , 120 , 140 } ; int k = 2 ; int n = arr . length ; System . out . println ( find@@ Sum ( arr , n , k , 0 , n - 1 ) ) ; } }
Case 4532 | import java . util . Collections ; import java . util . Vector ; class GF@@ G { public static String get@@ Sorted@@ String ( StringBuilder s , int n ) { Vector < Character > v1 = new Vector < > ( ) ; Vector < Character > v2 = new Vector < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) >= ' a ' && s . charAt ( i ) <= ' z ' ) v1 . add ( s . charAt ( i ) ) ; if ( s . charAt ( i ) >= ' A ' && s . charAt ( i ) <= ' z ' ) v2 . add ( s . charAt ( i ) ) ; } Collections . sort ( v1 ) ; Collections . sort ( v2 ) ; int i = 0 , j = 0 ; for ( int k = 0 ; k < n ; k ++ ) { if ( s . charAt ( k ) > = ' a ' && s . charAt ( k ) <= ' z ' ) { s . set@@ Char@@ At ( k , v1 . elementAt ( i ) ) ; ++ i ; } else if ( s . charAt ( k ) > = ' A ' && s . charAt ( k ) <= ' Z ' ) { s . set@@ Char@@ At ( k , v2 . elementAt ( j ) ) ; ++ j ; } } return s . toString ( ) ; } public static void main ( String [ ] args ) { StringBuilder s = new StringBuilder ( " g@@ E@@ ek@@ sf@@ Org@@ EE@@ k@@ S " ) ; int n = s . length ( ) ; System . out . println ( get@@ Sorted@@ String ( s , n ) ) ; } }
Remove elements to make array sorted 4543 | class GF@@ G { static void remove@@ Elements ( int [ ] arr , int n ) { int [ ] br@@ r = new int [ n ] ; int l = 1 ; br@@ r [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( br@@ r [ l - 1 ] <= arr [ i ] ) { br@@ r [ l ] = arr [ i ] ; l ++ ; } } for ( int i = 0 ; i < l ; i ++ ) System . out . print ( br@@ r [ i ] + " ▁ " ) ; } static public void main ( String [ ] args ) { int [ ] arr = { 10 , 12 , 9 , 10 , 2 , 13 , 14 } ; int n = arr . length ; remove@@ Elements ( arr , n ) ; } }
Find number from its di@@ visors 4554 | import java . util . * ; class GF@@ G { static int find@@ X ( int a [ ] , int n ) { Arrays . sort ( a ) ; int x = a [ 0 ] * a [ n - 1 ] ; Vector < Integer > vec = new Vector < Integer > ( ) ; for ( int i = 2 ; i * i <= x ; i ++ ) { if ( x % i == 0 ) { vec . add ( i ) ; if ( ( x / i ) != i ) vec . add ( x / i ) ; } } Collections . sort ( vec ) ; if ( vec . size ( ) != n ) return - 1 ; else { int i = 0 ; for ( int it : vec ) { if ( a [ i ++ ] != it ) return - 1 ; } } return x ; } public static void main ( String [ ] args ) { int a [ ] = { 2 , 5 , 4 , 10 } ; int n = a . length ; System . out . print ( find@@ X ( a , n ) ) ; } }
Product of all Sub@@ sequences of size K except the minimum and maximum Elements 4567 | import java . util . Arrays ; class GF@@ G { static int MOD = 100000000@@ 7 ; static int max = 101 ; static long C [ ] [ ] = new long [ max ] [ max ] ; static long power ( long x , long y ) { long res = 1 ; x = x % MOD ; while ( y > 0 ) { if ( y % 2 == 1 ) { res = ( res * x ) % MOD ; } y = y >> 1 ; x = ( x * x ) % MOD ; } return res % MOD ; } static void comb@@ i ( int n , int k ) { int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] % MOD + C [ i - 1 ] [ j ] % MOD ) % MOD ; } } } static long product ( long a [ ] , int n , int k ) { long ans = 1 ; Arrays . sort ( a ) ; long pow@@ a = C [ n - 1 ] [ k - 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { long pow@@ la = C [ i ] [ k - 1 ] ; long pow@@ fa = C [ n - i - 1 ] [ k - 1 ] ; long po@@ we = ( ( pow@@ a % MOD ) - ( pow@@ la + pow@@ fa ) % MOD + MOD ) % MOD ; long mul = power ( a [ i ] , po@@ we ) % MOD ; ans = ( ( ans % MOD ) * ( mul % MOD ) ) % MOD ; } return ans % MOD ; } public static void main ( String [ ] args ) { comb@@ i ( 100 , 100 ) ; long arr [ ] = { 1 , 2 , 3 , 4 } ; int n = arr . length ; int k = 3 ; long ans = product ( arr , n , k ) ; System . out . println ( ans ) ; } }
Equ@@ ally divide into two sets such that one set has maximum distinct elements 4678 | import java . util . * ; class GF@@ G { static int distribution ( int arr [ ] , int n ) { Set < Integer > resources = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) resources . add ( arr [ i ] ) ; return Math . min ( resources . size ( ) , n / 2 ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 2 , 1 , 3 , 4 } ; int n = arr . length ; System . out . print ( distribution ( arr , n ) + "@@ NEW_@@ LINE@@ "@@ )@@ ; } }
Sort string of characters using Stack 4692 | import java . io . * ; import java . util . * ; class GF@@ G { public static void print@@ Sorted ( String s , int l ) { Stack < Character > stack = new Stack < Character > ( ) ; Stack < Character > temp@@ stack = new Stack < Character > ( ) ; stack . push ( s . charAt ( 0 ) ) ; for ( int i = 1 ; i < l ; i ++ ) { int a = s . charAt ( i ) ; int b = ( int ) ( ( char ) stack . peek ( ) ) ; if ( ( a - b ) >= 1 || ( a == b ) ) { stack . push ( s . charAt ( i ) ) ; } else if ( ( b - a ) >= 1 ) { while ( ( b - a ) >= 1 ) { temp@@ stack . push ( stack . peek ( ) ) ; stack . pop ( ) ; if ( stack . size ( ) > 0 ) { b = ( int ) ( ( char ) stack . peek ( ) ) ; } else { break ; } } stack . push ( s . charAt ( i ) ) ; while ( temp@@ stack . size ( ) > 0 ) { stack . push ( temp@@ stack . peek ( ) ) ; temp@@ stack . pop ( ) ; } } } String answer = " " ; while ( stack . size ( ) > 0 ) { answer = stack . peek ( ) + answer ; stack . pop ( ) ; } System . out . println ( answer ) ; } public static void main ( String [ ] args ) { String s = " ge@@ ek@@ s@@ forge@@ e@@ ks " ; int l = s . length ( ) ; print@@ Sorted ( s , l ) ; } }
Maxim@@ ise the number of to@@ ys that can be purch@@ ased with amount K 4699 | import java . io . * ; import java . util . * ; class GF@@ G { static int maximum@@ _to@@ ys ( int cost [ ] , int N , int K ) { int count = 0 , sum = 0 ; Arrays . sort ( cost ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( sum + cost [ i ] <= K ) { sum = sum + cost [ i ] ; count ++ ; } } return count ; } public static void main ( String [ ] args ) { int K = 50 ; int cost [ ] = { 1 , 12 , 5 , 111 , 200 , 1000 , 10 , 9 , 12 , 15 } ; int N = cost . length ; System . out . print ( maximum@@ _to@@ ys ( cost , N , K ) ) ; } }
Check if given array is almost sorted ( elements are at 4745 | import java . util . * ; class GF@@ G { public static boolean al@@ most@@ Sort ( int A [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( A [ i ] > A [ i + 1 ] ) { int temp = A [ i ] ; A [ i ] = A [ i + 1 ] ; A [ i + 1 ] = temp ; i ++ ; } } for ( int i = 0 ; i < n - 1 ; i ++ ) if ( A [ i ] > A [ i + 1 ] ) return false ; return true ; } public static void main ( String [ ] args ) { int A [ ] = { 1 , 3 , 2 , 4 , 6 , 5 } ; int n = A . length ; if ( al@@ most@@ Sort ( A , n ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
Sort an array when two hal@@ ves are sorted 4802 | import java . io . * ; class GF@@ G { static void merge@@ Two@@ Half ( int [ ] A , int n ) { int i ; int [ ] temp = new int [ n ] ; for ( i = 0 ; i < n - 1 ; i ++ ) { if ( A [ i ] > A [ i + 1 ] ) { half_@@ i = i + 1 ; break ; } } if ( half_@@ i == 0 ) return ; i = 0 ; int j = half_@@ i ; int k = 0 ; while ( i < half_@@ i && j < n ) { if ( A [ i ] < A [ j ] ) temp [ k ++ ] = A [ i ++ ] ; else temp [ k ++ ] = A [ j ++ ] ; } while ( i < half_@@ i ) temp [ k ++ ] = A [ i ++ ] ; while ( j < n ) temp [ k ++ ] = A [ j ++ ] ; for ( i = 0 ; i < n ; i ++ ) A [ i ] = temp [ i ] ; } static public void main ( String [ ] args ) { int [ ] A = { 2 , 3 , 8 , - 1 , 7 , 10 } ; int n = A . length ; merge@@ Two@@ Half ( A , n ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( A [ i ] + " ▁ " ) ; } }
Maxim@@ ize number of circular build@@ ings that can be covered by L length wire 4960 | import java . io . * ; class GF@@ G { static final double Pi = 3.1415@@ 92 ; static int Max@@ Build@@ ings@@ Co@@ vered ( int arr [ ] , int N , int L ) { double curr_@@ sum = 0 ; int start = 0 , curr_@@ count = 0 , max_@@ count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { curr_@@ sum = curr_@@ sum + ( ( double ) arr [ i ] * Pi ) ; if ( i != 0 ) curr_@@ sum += 1 ; if ( curr_@@ sum <= L ) { curr_@@ count ++ ; } else if ( curr_@@ sum > L ) { curr_@@ sum = curr_@@ sum - ( ( double ) arr [ start ] * Pi ) ; curr_@@ sum -= 1 ; start ++ ; curr_@@ count -- ; } max_@@ count = Math . max ( curr_@@ count , max_@@ count ) ; } return max_@@ count ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 1 , 6 , 2 } ; int L = 24 ; int N = arr . length ; System . out . println ( Max@@ Build@@ ings@@ Co@@ vered ( arr , N , L ) ) ; } }
Check if a Binary String can be split into disjoint sub@@ sequences which are equal to "01@@ 0" 4967 | public class MyClass { static boolean is@@ Possible ( String s ) { int n = s . length ( ) ; int count_@@ 0 = 0 , count_@@ 1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '0' ) ++ count_@@ 0 ; else ++ count_@@ 1 ; if ( count_@@ 1 > count_@@ 0 ) return false ; } if ( count_@@ 0 != ( 2 * count_@@ 1 ) ) return false ; count_@@ 0 = 0 ; count_@@ 1 = 0 ; for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( s . charAt ( i ) == '0' ) ++ count_@@ 0 ; else ++ count_@@ 1 ; if ( count_@@ 1 > count_@@ 0 ) return false ; } return true ; } public static void main ( String args [ ] ) { String s = "01@@ 0100@@ " ; if ( is@@ Possible ( s ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
Maxim@@ ize array product by changing any array element arr [ i ] to ( 5128 | import java . util . * ; class GF@@ G { static int find@@ Max@@ Val@@ By@@ Re@@ arr@@ Arr ( int arr [ ] , int N ) { int res = 0 ; res = ( N * ( N + 1 ) ) / 2 ; return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 2 , 1 } ; int N = arr . length ; System . out . print ( find@@ Max@@ Val@@ By@@ Re@@ arr@@ Arr ( arr , N ) ) ; } }
Minimum characters to be replaced to make a string concatenation of a K 5229 | import java . io . * ; import java . util . * ; class GF@@ G { static float pair@@ Product@@ Mean ( int arr [ ] , int N ) { int suffix@@ Sum@@ Array [ ] = new int [ N ] ; suffix@@ Sum@@ Array [ N - 1 ] = arr [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { suffix@@ Sum@@ Array [ i ] = suffix@@ Sum@@ Array [ i + 1 ] + arr [ i ] ; } int length = ( N * ( N - 1 ) ) / 2 ; float res = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { res += arr [ i ] * suffix@@ Sum@@ Array [ i + 1 ] ; } float mean ; if ( length != 0 ) mean = res / length ; else mean = 0 ; return mean ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 4 , 8 } ; int N = arr . length ; System . out . format ( " % .2f " , pair@@ Product@@ Mean ( arr , N ) ) ; } }
Possible values of Q such that , for any value of R , their product is equal to X times their sum 5349 | import java . util . * ; class GF@@ G { static void values_@@ of_@@ Q ( int X ) { ArrayList < Integer > val_@@ Q = new ArrayList < Integer > ( ) ; for ( int i = 1 ; i <= X ; i ++ ) { if ( ( ( ( X + i ) * X ) ) % i == 0 ) { val_@@ Q . add ( X + i ) ; } } System . out . println ( val_@@ Q . size ( ) ) ; for ( int i = 0 ; i < val_@@ Q . size ( ) ; i ++ ) { System . out . print ( val_@@ Q . get ( i ) + " ▁ " ) ; } } public static void main ( String [ ] args ) { int X = 3 ; values_@@ of_@@ Q ( X ) ; } }
Sum of product of all integers upto N with their count of di@@ visors 5374 | class GF@@ G { static int sum@@ Of@@ Factors ( int N ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { int first = i ; int last = ( N / i ) * i ; int factors = ( last - first ) / i + 1 ; int total@@ Contribution = ( ( ( factors ) * ( factors + 1 ) ) / 2 ) * i ; ans += total@@ Contribution ; } return ans ; } public static void main ( String [ ] args ) { int N = 3 ; System . out . println ( sum@@ Of@@ Factors ( N ) ) ; } }
Maximum pro@@ fit such that total sto@@ len value is less than K to get bonus 5432 | import java . util . * ; class GF@@ G { static int max@@ Pro@@ fit ( int [ ] value , int N , int K ) { Arrays . sort ( value ) ; int maxval = value [ N - 1 ] ; int max@@ Pro@@ fit = 0 ; int curr_@@ val ; do { curr_@@ val = 0 ; for ( int i = 0 ; i < N ; i ++ ) { curr_@@ val += value [ i ] ; if ( curr_@@ val <= K ) { max@@ Pro@@ fit = Math . max ( curr_@@ val + maxval * ( i + 1 ) , max@@ Pro@@ fit ) ; } } } while ( next_@@ permutation ( value ) ) ; return max@@ Pro@@ fit ; } static boolean next_@@ permutation ( int [ ] p ) { for ( int a = p . length - 2 ; a >= 0 ; -- a ) if ( p [ a ] < p [ a + 1 ] ) for ( int b = p . length - 1 ; ; -- b ) if ( p [ b ] > p [ a ] ) { int t = p [ a ] ; p [ a ] = p [ b ] ; p [ b ] = t ; for ( ++ a , b = p . length - 1 ; a < b ; ++ a , -- b ) { t = p [ a ] ; p [ a ] = p [ b ] ; p [ b ] = t ; } return true ; } return false ; } public static void main ( String [ ] args ) { int N = 4 , K = 6 ; int [ ] values = { 5 , 2 , 7 , 3 } ; System . out . print ( max@@ Pro@@ fit ( values , N , K ) ) ; } }
Min operations to reduce N by multiply@@ ing by any number or taking square root 5435 | import java . lang . Math ; class GF@@ G { static void minValue ( int n ) { while ( ( int ) Math . sqrt ( n ) == Math . sqrt ( n ) && n > 1 ) { n = ( int ) ( Math . sqrt ( n ) ) ; } for ( int i = ( int ) ( Math . sqrt ( n ) ) ; i > 1 ; i -- ) { while ( n % ( i * i ) == 0 ) n /= i ; } System . out . println ( n ) ; } public static void main ( String args [ ] ) { int N = 20 ; minValue ( N ) ; } }
Final direction after visi@@ ting every cell of Matrix starting from ( 0 , 0 ) 5458 | class GF@@ G { static void find@@ Direction ( int n , int m ) { if ( n > m ) { if ( m % 2 == 0 ) System . out . print ( "@@ Up@@ NEW_@@ LINE@@ "@@ )@@ ; else System . out . print ( "@@ Down@@ NEW_@@ LINE@@ "@@ )@@ ; } else { if ( n % 2 == 0 ) System . out . print ( "@@ Left@@ NEW_@@ LINE@@ "@@ )@@ ; else System . out . print ( "@@ Right@@ NEW_@@ LINE@@ "@@ )@@ ; } } public static void main ( String [ ] args ) { int n = 3 , m = 3 ; find@@ Direction ( n , m ) ; } }
Find GC@@ D of each subtree of a given node in an N 5485 | import java . util . * ; class GF@@ G { static int N = ( int ) ( 1e@@ 5 + 5 ) ; static Vector < Integer > [ ] v = new Vector [ N ] ; static int [ ] val = new int [ N ] ; static int [ ] answer = new int [ N ] ; static int n ; static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } static void DFS ( int node , int parent ) { answer [ node ] = val [ node ] ; for ( int child : v [ node ] ) { if ( child == parent ) continue ; DFS ( child , node ) ; answer [ node ] = gcd ( answer [ node ] , answer [ child ] ) ; } } static void preprocess ( ) { DFS ( 1 , - 1 ) ; } static void find@@ GC@@ D ( int queries [ ] , int q ) { preprocess ( ) ; for ( int i = 0 ; i < q ; i ++ ) { int GC@@ D = answer [ queries [ i ] ] ; System . out . print ( " For ▁ subtree ▁ of ▁ " + queries [ i ] + " , ▁ GC@@ D ▁ = ▁ " + GC@@ D + "@@ NEW_@@ LINE@@ "@@ )@@ ; } } public static void main ( String [ ] args ) { n = 5 ; for ( int i = 0 ; i < v . length ; i ++ ) v [ i ] = new Vector < Integer > ( ) ; v [ 1 ] . add ( 2 ) ; v [ 2 ] . add ( 1 ) ; v [ 1 ] . add ( 3 ) ; v [ 3 ] . add ( 1 ) ; v [ 3 ] . add ( 4 ) ; v [ 4 ] . add ( 3 ) ; v [ 3 ] . add ( 5 ) ; v [ 5 ] . add ( 3 ) ; val [ 1 ] = 2 ; val [ 2 ] = 3 ; val [ 3 ] = 4 ; val [ 4 ] = 8 ; val [ 5 ] = 16 ; int queries [ ] = { 2 , 3 , 1 } ; int q = queries . length ; find@@ GC@@ D ( queries , q ) ; } }
Check if array can be converted into strictly decre@@ asing sequence 5503 | class GF@@ G { static boolean check ( int [ ] arr , int n ) { boolean flag = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < n - i ) { flag = false ; } } if ( flag ) { return true ; } else { return false ; } } public static void main ( String [ ] args ) { int ar@@ r1 [ ] = { 11 , 11 , 11 , 11 } ; int n1 = ar@@ r1 . length ; if ( check ( ar@@ r1 , n1 ) ) { System . out . print ( " Yes " + "@@ NEW_@@ LINE@@ "@@ )@@ ; } else { System . out . print ( " No " + "@@ NEW_@@ LINE@@ "@@ )@@ ; } } }
Check if array can be converted into strictly decre@@ asing sequence 5539 | class GF@@ G { static int get@@ Largest@@ Sum ( int N ) { int max_@@ sum = 0 ; for ( int i = 1 ; i * i <= N ; i ++ ) { for ( int j = i + 1 ; j * j <= N ; j ++ ) { int k = N / j ; int a = k * i ; int b = k * j ; if ( a <= N && b <= N && a * b % ( a + b ) == 0 ) max_@@ sum = Math . max ( max_@@ sum , a + b ) ; } } return max_@@ sum ; } public static void main ( String [ ] args ) { int N = 25 ; int max_@@ sum = get@@ Largest@@ Sum ( N ) ; System . out . print ( max_@@ sum + "@@ NEW_@@ LINE@@ "@@ )@@ ; } }
Count common elements in two arrays containing multip@@ les of N and M 5623 | import java . util . * ; import java . lang . * ; import java . io . * ; class GF@@ G { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int l@@ cm ( int n , int m ) { return ( n * m ) / gcd ( n , m ) ; } public static void main ( String [ ] args ) { int n = 2 , m = 3 , k = 5 ; System . out . print ( k / l@@ cm ( n , m ) ) ; } }
Check whether a sub@@ sequence exists with sum equal to k if arr [ i ] > 2 * arr [ i 5626 | import java . io . * ; class GF@@ G { static boolean CheckFor@@ Sequence ( int arr [ ] , int n , int k ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( k >= arr [ i ] ) k -= arr [ i ] ; } if ( k != 0 ) return false ; else return true ; } public static void main ( String [ ] args ) { int A [ ] = { 1 , 3 , 7 , 15 , 31 } ; int n = A . length ; System . out . println ( CheckFor@@ Sequence ( A , n , 18 ) ? " True " : " False " ) ; } }
Maximum possible sub 5630 | import java . io . * ; import java . util . * ; class GF@@ G { static int Sub@@ array@@ Sum ( int [ ] a , int n , int x ) { int ans = - 10000 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int cur@@ ans = 0 ; ArrayList < Integer > pq = new ArrayList < Integer > ( ) ; ArrayList < Integer > pq@@ 2 = new ArrayList < Integer > ( ) ; for ( int k = 0 ; k < n ; k ++ ) { if ( k >= i && k <= j ) { cur@@ ans += a [ k ] ; pq@@ 2 . add ( a [ k ] ) ; } else pq . add ( a [ k ] ) ; } Collections . sort ( pq ) ; Collections . reverse ( pq ) ; Collections . sort ( pq@@ 2 ) ; ans = Math . max ( ans , cur@@ ans ) ; for ( int k = 1 ; k <= x ; k ++ ) { if ( pq . size ( ) == 0 || pq@@ 2 . size ( ) == 0 || pq@@ 2 . get ( 0 ) >= pq . get ( 0 ) ) break ; cur@@ ans -= pq@@ 2 . get ( 0 ) ; pq@@ 2 . remove ( 0 ) ; cur@@ ans += pq . get ( 0 ) ; pq . remove ( 0 ) ; ans = Math . max ( ans , cur@@ ans ) ; } } } return ans ; } public static void main ( String [ ] args ) { int [ ] a = { 5 , - 1 , 2 , 3 , 4 , - 2 , 5 } ; int x = 2 ; int n = a . length ; System . out . println ( Sub@@ array@@ Sum ( a , n , x ) ) ; } }
Generate an array of size K which satis@@ fies the given conditions 5634 | class GF@@ G { static void generate@@ Array ( int n , int k ) { int [ ] array = new int [ k ] ; int remaining = n - ( k * ( k + 1 ) / 2 ) ; if ( remaining < 0 ) System . out . print ( " NO " ) ; int right_@@ most = remaining % k ; int high = ( int ) Math . ceil ( remaining / ( k * 1.0 ) ) ; int low = ( int ) Math . floor ( remaining / ( k * 1.0 ) ) ; for ( int i = k - right_@@ most ; i < k ; i ++ ) array [ i ] = high ; for ( int i = 0 ; i < ( k - right_@@ most ) ; i ++ ) array [ i ] = low ; for ( int i = 0 ; i < k ; i ++ ) array [ i ] += i + 1 ; if ( k - 1 != remaining k == 1 ) { for ( int u : array ) System . out . print ( u + " ▁ " ) ; } else if ( k == 2 k == 3 ) System . out . printf ( "@@ -@@ 1@@ NEW_@@ LINE@@ "@@ )@@ ; else { array [ 1 ] -= 1 ; array [ k - 1 ] += 1 ; for ( int u : array ) System . out . print ( u + " ▁ " ) ; } } public static void main ( String [ ] args ) { int n = 26 , k = 6 ; generate@@ Array ( n , k ) ; } }
Maximum count of sub 5684 | import java . util . * ; import java . lang . * ; import java . io . * ; class GF@@ G { static int max@@ Sub@@ Strings ( String s , int k ) { int max@@ Sub@@ Str = 0 , n = s . length ( ) ; for ( int c = 0 ; c < 26 ; c ++ ) { char ch = ( char ) ( ( int ) ' a ' + c ) ; int curr = 0 ; for ( int i = 0 ; i <= n - k ; i ++ ) { if ( s . charAt ( i ) != ch ) continue ; int cnt = 0 ; while ( i < n && s . charAt ( i ) == ch && cnt != k ) { i ++ ; cnt ++ ; } i -- ; if ( cnt == k ) curr ++ ; } max@@ Sub@@ Str = Math . max ( max@@ Sub@@ Str , curr ) ; } return max@@ Sub@@ Str ; } public static void main ( String [ ] args ) { String s = " aa@@ ac@@ a@@ ab@@ ba@@ a " ; int k = 2 ; System . out . println ( max@@ Sub@@ Strings ( s , k ) ) ; } }
Minimum cost to reach a point N from 0 with two different operations allowed 5718 | class GF@@ G { static int min@@ Cost ( int N , int P , int Q ) { int cost = 0 ; while ( N > 0 ) { if ( ( N & 1 ) > 0 ) { cost += P ; N -- ; } else { int temp = N / 2 ; if ( temp * P > Q ) cost += Q ; else cost += P * temp ; N /= 2 ; } } return cost ; } public static void main ( String [ ] args ) { int N = 9 , P = 5 , Q = 1 ; System . out . println ( min@@ Cost ( N , P , Q ) ) ; } }
Schedule jobs so that each server gets equal load 5774 | class GF@@ G { static int solve ( int a [ ] , int b [ ] , int n ) { int i ; int s = 0 ; for ( i = 0 ; i < n ; i ++ ) s += ( a [ i ] + b [ i ] ) ; if ( n == 1 ) return a [ 0 ] + b [ 0 ] ; if ( s % n != 0 ) return - 1 ; int x = s / n ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) return - 1 ; if ( i > 0 ) { a [ i ] += b [ i - 1 ] ; b [ i - 1 ] = 0 ; } if ( a [ i ] == x ) continue ; int y = a [ i ] + b [ i ] ; if ( i + 1 < n ) y += b [ i + 1 ] ; if ( y == x ) { a [ i ] = y ; b [ i ] = 0 ; continue ; } if ( a [ i ] + b [ i ] == x ) { a [ i ] += b [ i ] ; b [ i ] = 0 ; continue ; } if ( i + 1 < n && a [ i ] + b [ i + 1 ] == x ) { a [ i ] += b [ i + 1 ] ; b [ i + 1 ] = 0 ; continue ; } return - 1 ; } for ( i = 0 ; i < n ; i ++ ) if ( b [ i ] != 0 ) return - 1 ; return x ; } public static void main ( String [ ] args ) { int a [ ] = { 6 , 14 , 21 , 1 } ; int b [ ] = { 15 , 7 , 10 , 10 } ; int n = a . length ; System . out . println ( solve ( a , b , n ) ) ; } }
Check if it is possible to survi@@ ve on Is@@ land 5776 | import java . io . * ; class GF@@ G { static void survi@@ val ( int S , int N , int M ) { if ( ( ( N * 6 ) < ( M * 7 ) && S > 6 ) M > N ) System . out . println ( " No " ) ; else { int days = ( M * S ) / N ; if ( ( ( M * S ) % N ) != 0 ) days ++ ; System . out . println ( " Yes ▁ " + days ) ; } } public static void main ( String [ ] args ) { int S = 10 , N = 16 , M = 2 ; survi@@ val ( S , N , M ) ; } }
Lon@@ gest sub@@ array with all even or all odd elements 5870 | import java . io . * ; class GF@@ G { static int Lon@@ gest@@ O@@ dd@@ Even@@ Sub@@ array ( int A [ ] , int N ) { int dp [ ] = new int [ N ] ; dp [ 0 ] = 1 ; int ans = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( ( A [ i ] % 2 == 0 && A [ i - 1 ] % 2 == 0 ) || ( A [ i ] % 2 != 0 && A [ i - 1 ] % 2 != 0 ) ) { dp [ i ] = dp [ i - 1 ] + 1 ; } else dp [ i ] = 1 ; } for ( int i = 0 ; i < N ; i ++ ) ans = Math . max ( ans , dp [ i ] ) ; return ans ; } public static void main ( String [ ] args ) { int A [ ] = { 2 , 5 , 7 , 2 , 4 , 6 , 8 , 3 } ; int N = A . length ; System . out . println ( Lon@@ gest@@ O@@ dd@@ Even@@ Sub@@ array ( A , N ) ) ; } }
Split array into sub@@ arrays such that sum of difference between their maximum@@ s and minimum@@ s is maximum 5947 | import java . util . * ; public class Main { static int getValue ( int [ ] arr , int N ) { int dp [ ] = new int [ N ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i < N ; i ++ ) { int min = arr [ i ] ; int max = arr [ i ] ; for ( int j = i ; j >= 0 ; j -- ) { min = Math . min ( arr [ j ] , min ) ; max = Math . max ( arr [ j ] , max ) ; dp [ i ] = Math . max ( dp [ i ] , max - min + ( ( j >= 1 ) ? dp [ j - 1 ] : 0 ) ) ; } } return dp [ N - 1 ] ; } public static void main ( String args [ ] ) { int arr [ ] = { 8 , 1 , 7 , 9 , 2 } ; int N = arr . length ; System . out . println ( getValue ( arr , N ) ) ; } }
Min number of operations to reduce N to 0 by subtrac@@ ting any digits from N 6145 | import java . util . * ; class GF@@ G { static int reduce@@ Zero ( int N ) { int [ ] dp = new int [ N + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) dp [ i ] = ( int ) 1e@@ 9 ; dp [ 0 ] = 0 ; for ( int i = 0 ; i <= N ; i ++ ) { for ( char c : String . valueOf ( i ) . toCharArray ( ) ) { dp [ i ] = Math . min ( dp [ i ] , dp [ i - ( c - '0' ) ] + 1 ) ; } } return dp [ N ] ; } public static void main ( String [ ] args ) { int N = 25 ; System . out . print ( reduce@@ Zero ( N ) ) ; } }
Count of sub@@ sequences of length at@@ most K containing distinct prime elements 6187 | import java . util . * ; class GF@@ G { static boolean [ ] prime = new boolean [ 10000@@ 1 ] ; static void Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( ) { for ( int i = 0 ; i < prime . length ; i ++ ) prime [ i ] = true ; prime [ 0 ] = prime [ 1 ] = false ; for ( int p = 2 ; p * p < 100000 ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= 100000 ; i += p ) prime [ i ] = false ; } } } static int distin@@ ct@@ Prime@@ Sub@@ Seq ( int a [ ] , int n , int k ) { Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( ) ; Vector < Integer > primes = new Vector < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ a [ i ] ] ) primes . add ( a [ i ] ) ; } int l = primes . size ( ) ; Collections . sort ( primes ) ; Vector < Integer > b = new Vector < > ( ) ; Vector < Integer > dp = new Vector < > ( ) ; int sum = 0 ; for ( int i = 0 ; i < l ; ) { int count = 1 , x = a [ i ] ; i ++ ; while ( i < l && a [ i ] == x ) { count ++ ; i ++ ; } b . add ( count ) ; dp . add ( count ) ; sum += count ; } int of_@@ length = 2 ; int len = dp . size ( ) ; int ans = 0 ; while ( of_@@ length < k ) { int freq = 0 ; int prev = 0 ; for ( int i = 0 ; i < ( len - 1 ) ; i ++ ) { freq += dp . elementAt ( i ) ; int j = sum - freq ; int sub@@ seq = b . elementAt ( i ) * j ; ans += sub@@ seq ; dp . add ( i , sub@@ seq ) ; prev += dp . elementAt ( i ) ; } len -- ; sum = prev ; of_@@ length ++ ; } ans += ( l + 3 ) ; return ans ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 2 , 3 , 3 , 4 , 5 } ; int n = a . length ; int k = 3 ; System . out . print ( distin@@ ct@@ Prime@@ Sub@@ Seq ( a , n , k ) ) ; } }
Number of ways to split N as sum of K numbers from the given range 6207 | class GF@@ G { static int mod = 100000000@@ 7 ; static int [ ] [ ] dp = new int [ 1000 ] [ 1000 ] ; static int calculate ( int pos , int left , int k , int L , int R ) { if ( pos == k ) { if ( left == 0 ) return 1 ; else return 0 ; } if ( left == 0 ) return 0 ; if ( dp [ pos ] [ left ] != - 1 ) return dp [ pos ] [ left ] ; int answer = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( i > left ) break ; answer = ( answer + calculate ( pos + 1 , left - i , k , L , R ) ) % mod ; } return dp [ pos ] [ left ] = answer ; } static int count@@ Way@@ sto@@ Divide ( int n , int k , int L , int R ) { for ( int i = 0 ; i < 1000 ; i ++ ) { for ( int j = 0 ; j < 1000 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } return calculate ( 0 , n , k , L , R ) ; } public static void main ( String [ ] args ) { int N = 12 ; int K = 3 ; int L = 1 ; int R = 5 ; System . out . print ( count@@ Way@@ sto@@ Divide ( N , K , L , R ) ) ; } }
Lar@@ gest Square in a Binary Matrix with at most K 1 s for multiple Queries 6211 | import java . util . * ; class GF@@ G { static void lar@@ gest@@ Square ( int matrix [ ] [ ] , int R , int C , int q_@@ i [ ] , int q_@@ j [ ] , int K , int Q ) { int count@@ DP [ ] [ ] = new int [ R ] [ C ] ; for ( int i = 0 ; i < R ; i ++ ) for ( int j = 0 ; j < C ; j ++ ) count@@ DP [ i ] [ j ] = 0 ; count@@ DP [ 0 ] [ 0 ] = matrix [ 0 ] [ 0 ] ; for ( int i = 1 ; i < R ; i ++ ) count@@ DP [ i ] [ 0 ] = count@@ DP [ i - 1 ] [ 0 ] + matrix [ i ] [ 0 ] ; for ( int j = 1 ; j < C ; j ++ ) count@@ DP [ 0 ] [ j ] = count@@ DP [ 0 ] [ j - 1 ] + matrix [ 0 ] [ j ] ; for ( int i = 1 ; i < R ; i ++ ) for ( int j = 1 ; j < C ; j ++ ) count@@ DP [ i ] [ j ] = matrix [ i ] [ j ] + count@@ DP [ i - 1 ] [ j ] + count@@ DP [ i ] [ j - 1 ] - count@@ DP [ i - 1 ] [ j - 1 ] ; for ( int q = 0 ; q < Q ; q ++ ) { int i = q_@@ i [ q ] ; int j = q_@@ j [ q ] ; int min_@@ dist = Math . min ( Math . min ( i , j ) , Math . min ( R - i - 1 , C - j - 1 ) ) ; int ans = - 1 , l = 0 , u = min_@@ dist ; while ( l <= u ) { int mid = ( l + u ) / 2 ; int x1 = i - mid , x2 = i + mid ; int y1 = j - mid , y2 = j + mid ; int count = count@@ DP [ x2 ] [ y2 ] ; if ( x1 > 0 ) count -= count@@ DP [ x1 - 1 ] [ y2 ] ; if ( y1 > 0 ) count -= count@@ DP [ x2 ] [ y1 - 1 ] ; if ( x1 > 0 && y1 > 0 ) count += count@@ DP [ x1 - 1 ] [ y1 - 1 ] ; if ( count <= K ) { ans = 2 * mid + 1 ; l = mid + 1 ; } else u = mid - 1 ; } System . out . println ( ans ) ; } } public static void main ( String args [ ] ) { int matrix [ ] [ ] = { { 1 , 0 , 1 , 0 , 0 } , { 1 , 0 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 } , { 1 , 0 , 0 , 1 , 0 } } ; int K = 9 , Q = 1 ; int q_@@ i [ ] = { 1 } ; int q_@@ j [ ] = { 2 } ; lar@@ gest@@ Square ( matrix , 4 , 5 , q_@@ i , q_@@ j , K , Q ) ; } }
