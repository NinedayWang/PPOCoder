Find maximum of minimum for every window size in a given array 1057 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ Max@@ Of@@ Min ( int arr [ ] , int n ) { for ( int k = 1 ; k <= n ; k ++ ) { int max@@ Of@@ Min = INT_@@ MIN ; for ( int i = 0 ; i <= n - k ; i ++ ) { int min = arr [ i ] ; for ( int j = 1 ; j < k ; j ++ ) { if ( arr [ i + j ] < min ) min = arr [ i + j ] ; } if ( min > max@@ Of@@ Min ) max@@ Of@@ Min = min ; } cout << max@@ Of@@ Min << " ▁ " ; } } int main ( ) { int arr [ ] = { 10 , 20 , 30 , 50 , 10 , 70 , 30 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; print@@ Max@@ Of@@ Min ( arr , n ) ; return 0 ; }
Find maximum of minimum for every window size in a given array 1058 | #@@ include <@@ io@@ stream@@ > NEW_LINE #@@ include <@@ stack@@ > NEW_LINE using namespace std ; void print@@ Max@@ Of@@ Min ( int arr [ ] , int n ) { stack < int > s ; int left [ n + 1 ] ; int right [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { left [ i ] = -1 ; right [ i ] = n ; } for ( int i = 0 ; i < n ; i ++ ) { while ( ! s . empty ( ) && arr [ s . top ( ) ] >= arr [ i ] ) s . pop ( ) ; if ( ! s . empty ( ) ) left [ i ] = s . top ( ) ; s . push ( i ) ; } while ( ! s . empty ( ) ) s . pop ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { while ( ! s . empty ( ) && arr [ s . top ( ) ] >= arr [ i ] ) s . pop ( ) ; if ( ! s . empty ( ) ) right [ i ] = s . top ( ) ; s . push ( i ) ; } int ans [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) ans [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int len = right [ i ] - left [ i ] - 1 ; ans [ len ] = max ( ans [ len ] , arr [ i ] ) ; } for ( int i = n - 1 ; i >= 1 ; i -- ) ans [ i ] = max ( ans [ i ] , ans [ i + 1 ] ) ; for ( int i = 1 ; i <= n ; i ++ ) cout << ans [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 10 , 20 , 30 , 50 , 10 , 70 , 30 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; print@@ Max@@ Of@@ Min ( arr , n ) ; return 0 ; }
Sum of all elements between k1 ' th ▁ and ▁ k@@ 2' th smallest elements 1134 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int sum@@ Between@@ Two@@ K@@ th ( int arr [ ] , int n , int k1 , int k2 ) { sort ( arr , arr + n ) ; int result = 0 ; for ( int i = k1 ; i < k2 - 1 ; i ++ ) result += arr [ i ] ; return result ; } int main ( ) { int arr [ ] = { 20 , 8 , 22 , 4 , 12 , 10 , 14 } ; int k1 = 3 , k2 = 6 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << sum@@ Between@@ Two@@ K@@ th ( arr , n , k1 , k2 ) ; return 0 ; }
Check if removing an edge can divide a Binary Tree in two hal@@ ves 118 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; struct Node * newNode ( int x ) { struct Node * temp = new Node ; temp -> data = x ; temp -> left = temp -> right = NULL ; return temp ; } ; int count ( Node * root ) { if ( root == NULL ) return 0 ; return count ( root -> left ) + count ( root -> right ) + 1 ; } int check@@ Rec ( Node * root , int n , bool & res ) { if ( root == NULL ) return 0 ; int c = check@@ Rec ( root -> left , n , res ) + 1 + check@@ Rec ( root -> right , n , res ) ; if ( c == n - c ) res = true ; return c ; } bool check ( Node * root ) { int n = count ( root ) ; bool res = false ; check@@ Rec ( root , n , res ) ; return res ; } int main ( ) { struct Node * root = newNode ( 5 ) ; root -> left = newNode ( 1 ) ; root -> right = newNode ( 6 ) ; root -> left -> left = newNode ( 3 ) ; root -> right -> left = newNode ( 7 ) ; root -> right -> right = newNode ( 4 ) ; check ( root ) ? printf ( " YES " ) : printf ( " NO " ) ; return 0 ; }
Given an array of pairs , find all symmetric pairs in it 1225 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ Sym@@ Pairs ( int arr [ ] [ 2 ] , int row ) { unordered_map < int , int > h@@ M ; for ( int i = 0 ; i < row ; i ++ ) { int first = arr [ i ] [ 0 ] ; int sec = arr [ i ] [ 1 ] ; if ( h@@ M . find ( sec ) != h@@ M . end ( ) && h@@ M [ sec ] == first ) cout << " ( " << sec << " , ▁ " << first << " ) " << endl ; else h@@ M [ first ] = sec ; } } int main ( ) { int arr [ 5 ] [ 2 ] ; arr [ 0 ] [ 0 ] = 11 ; arr [ 0 ] [ 1 ] = 20 ; arr [ 1 ] [ 0 ] = 30 ; arr [ 1 ] [ 1 ] = 40 ; arr [ 2 ] [ 0 ] = 5 ; arr [ 2 ] [ 1 ] = 10 ; arr [ 3 ] [ 0 ] = 40 ; arr [ 3 ] [ 1 ] = 30 ; arr [ 4 ] [ 0 ] = 10 ; arr [ 4 ] [ 1 ] = 5 ; find@@ Sym@@ Pairs ( arr , 5 ) ; }
Count items common to both the lists but with different prices 1255 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; struct item { string name ; int price ; } ; int count@@ Items ( item list1 [ ] , int m , item list2 [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( ( list1 [ i ] . name . compare ( list2 [ j ] . name ) == 0 ) && ( list1 [ i ] . price != list2 [ j ] . price ) ) count ++ ; return count ; } int main ( ) { item list1 [ ] = { { " apple " , 60 } , { " brea@@ d " , 20 } , { " whe@@ at " , 50 } , { " o@@ il " , 30 } } ; item list2 [ ] = { { " mil@@ k " , 20 } , { " brea@@ d " , 15 } , { " whe@@ at " , 40 } , { " apple " , 60 } } ; int m = sizeof ( list1 ) / sizeof ( list1 [ 0 ] ) ; int n = sizeof ( list2 ) / sizeof ( list2 [ 0 ] ) ; cout << " Count ▁ = ▁ " << count@@ Items ( list1 , m , list2 , n ) ; return 0 ; }
Number of sub@@ arrays having sum exactly equal to k 1283 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Sub@@ array@@ Sum ( int arr [ ] , int n , int sum ) { unordered_map < int , int > prev@@ Sum ; int res = 0 ; int curr@@ sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr@@ sum += arr [ i ] ; if ( curr@@ sum == sum ) res ++ ; if ( prev@@ Sum . find ( curr@@ sum - sum ) != prev@@ Sum . end ( ) ) res += ( prev@@ Sum [ curr@@ sum - sum ] ) ; prev@@ Sum [ curr@@ sum ] ++ ; } return res ; } int main ( ) { int arr [ ] = { 10 , 2 , -2 , -@@ 20 , 10 } ; int sum = -@@ 10 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << find@@ Sub@@ array@@ Sum ( arr , n , sum ) ; return 0 ; }
Count of index pairs with equal elements in an array 1387 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Pairs ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] == arr [ j ] ) ans ++ ; return ans ; } int main ( ) { int arr [ ] = { 1 , 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << count@@ Pairs ( arr , n ) << endl ; return 0 ; }
Print all root to leaf paths with there relative positions 142 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define MAX_@@ PATH@@ _SIZE 1000 NEW_LINE struct Node { char data ; Node * left , * right ; } ; Node * newNode ( char data ) { struct Node * temp = new Node ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } struct PATH { int H@@ d ; char key ; } ; void print@@ Path ( vector < PATH > path , int size ) { int minimum_@@ H@@ d = INT_MAX ; PATH p ; for ( int it = 0 ; it < size ; it ++ ) { p = path [ it ] ; minimum_@@ H@@ d = min ( minimum_@@ H@@ d , p . H@@ d ) ; } for ( int it = 0 ; it < size ; it ++ ) { p = path [ it ] ; int noOf@@ Under@@ Scores = abs ( p . H@@ d - minimum_@@ H@@ d ) ; for ( int i = 0 ; i < noOf@@ Under@@ Scores ; i ++ ) cout << " _ ▁ " ; cout << p . key << endl ; } cout << " = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = " << endl ; } void print@@ All@@ Path@@ s@@ Util ( Node * root , vector < PATH > & All@@ Path , int HD , int order ) { if ( root == NULL ) return ; if ( root -> left == NULL && root -> right == NULL ) { All@@ Path [ order ] = ( PATH { HD , root -> data } ) ; print@@ Path ( All@@ Path , order + 1 ) ; return ; } All@@ Path [ order ] = ( PATH { HD , root -> data } ) ; print@@ All@@ Path@@ s@@ Util ( root -> left , All@@ Path , HD - 1 , order + 1 ) ; print@@ All@@ Path@@ s@@ Util ( root -> right , All@@ Path , HD + 1 , order + 1 ) ; } void print@@ All@@ Paths ( Node * root ) { if ( root == NULL ) return ; vector < PATH > All@@ paths ( MAX_@@ PATH@@ _SIZE ) ; print@@ All@@ Path@@ s@@ Util ( root , All@@ paths , 0 , 0 ) ; } int main ( ) { Node * root = newNode ( ' A ' ) ; root -> left = newNode ( ' B ' ) ; root -> right = newNode ( ' C ' ) ; root -> left -> left = newNode ( ' D ' ) ; root -> left -> right = newNode ( ' E ' ) ; root -> right -> left = newNode ( ' F ' ) ; root -> right -> right = newNode ( ' G ' ) ; print@@ All@@ Paths ( root ) ; return 0 ; }
Find the minimum element in a sorted and rotated array 1448 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Min ( int arr [ ] , int low , int high ) { while ( low < high ) { int mid = low + ( high - low ) / 2 ; if ( arr [ mid ] == arr [ high ] ) high -- ; else if ( arr [ mid ] > arr [ high ] ) low = mid + 1 ; else high = mid ; } return arr [ high ] ; } int main ( ) { int ar@@ r1 [ ] = { 5 , 6 , 1 , 2 , 3 , 4 } ; int n1 = sizeof ( ar@@ r1 ) / sizeof ( ar@@ r1 [ 0 ] ) ; cout << " The ▁ minimum ▁ element ▁ is ▁ " << find@@ Min ( ar@@ r1 , 0 , n1 - 1 ) << endl ; int ar@@ r2 [ ] = { 1 , 2 , 3 , 4 } ; int n2 = sizeof ( ar@@ r2 ) / sizeof ( ar@@ r2 [ 0 ] ) ; cout << " The ▁ minimum ▁ element ▁ is ▁ " << find@@ Min ( ar@@ r2 , 0 , n2 - 1 ) << endl ; int arr@@ 3 [ ] = { 1 } ; int n3 = sizeof ( arr@@ 3 ) / sizeof ( arr@@ 3 [ 0 ] ) ; cout << " The ▁ minimum ▁ element ▁ is ▁ " << find@@ Min ( arr@@ 3 , 0 , n3 - 1 ) << endl ; int arr@@ 4 [ ] = { 1 , 2 } ; int n@@ 4 = sizeof ( arr@@ 4 ) / sizeof ( arr@@ 4 [ 0 ] ) ; cout << " The ▁ minimum ▁ element ▁ is ▁ " << find@@ Min ( arr@@ 4 , 0 , n@@ 4 - 1 ) << endl ; int arr@@ 5 [ ] = { 2 , 1 } ; int n@@ 5 = sizeof ( arr@@ 5 ) / sizeof ( arr@@ 5 [ 0 ] ) ; cout << " The ▁ minimum ▁ element ▁ is ▁ " << find@@ Min ( arr@@ 5 , 0 , n@@ 5 - 1 ) << endl ; int arr@@ 6 [ ] = { 5 , 6 , 7 , 1 , 2 , 3 , 4 } ; int n@@ 6 = sizeof ( arr@@ 6 ) / sizeof ( arr@@ 6 [ 0 ] ) ; cout << " The ▁ minimum ▁ element ▁ is ▁ " << find@@ Min ( arr@@ 6 , 0 , n@@ 6 - 1 ) << endl ; int arr@@ 7 [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int n@@ 7 = sizeof ( arr@@ 7 ) / sizeof ( arr@@ 7 [ 0 ] ) ; cout << " The ▁ minimum ▁ element ▁ is ▁ " << find@@ Min ( arr@@ 7 , 0 , n@@ 7 - 1 ) << endl ; int arr@@ 8 [ ] = { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 1 } ; int n@@ 8 = sizeof ( arr@@ 8 ) / sizeof ( arr@@ 8 [ 0 ] ) ; cout << " The ▁ minimum ▁ element ▁ is ▁ " << find@@ Min ( arr@@ 8 , 0 , n@@ 8 - 1 ) << endl ; int arr@@ 9 [ ] = { 3 , 4 , 5 , 1 , 2 } ; int n@@ 9 = sizeof ( arr@@ 9 ) / sizeof ( arr@@ 9 [ 0 ] ) ; cout << " The ▁ minimum ▁ element ▁ is ▁ " << find@@ Min ( arr@@ 9 , 0 , n@@ 9 - 1 ) << endl ; return 0 ; }
Re@@ arrange positive and negative numbers using in@@ built sort function 1472 | #@@ include <@@ io@@ stream@@ > NEW_LINE void print@@ Array ( int array [ ] , int length ) { std :: cout << " [ " ; for ( int i = 0 ; i < length ; i ++ ) { std :: cout << array [ i ] ; if ( i < ( length - 1 ) ) std :: cout << " , ▁ " ; else std :: cout << " ] " << std :: endl ; } } void reverse ( int array [ ] , int start , int end ) { while ( start < end ) { int temp = array [ start ] ; array [ start ] = array [ end ] ; array [ end ] = temp ; start ++ ; end -- ; } } void re@@ arrange ( int array [ ] , int start , int end ) { if ( start == end ) return ; re@@ arrange ( array , ( start + 1 ) , end ) ; if ( array [ start ] >= 0 ) { reverse ( array , ( start + 1 ) , end ) ; reverse ( array , start , end ) ; } } int main ( ) { int array [ ] = { -@@ 12 , -@@ 11 , -@@ 13 , -@@ 5 , -@@ 6 , 7 , 5 , 3 , 6 } ; int length = ( sizeof ( array ) / sizeof ( array [ 0 ] ) ) ; int count@@ Negative = 0 ; for ( int i = 0 ; i < length ; i ++ ) { if ( array [ i ] < 0 ) count@@ Negative ++ ; } std :: cout << " array : ▁ " ; print@@ Array ( array , length ) ; re@@ arrange ( array , 0 , ( length - 1 ) ) ; reverse ( array , count@@ Negative , ( length - 1 ) ) ; std :: cout << " re@@ arrange@@ d ▁ array : ▁ " ; print@@ Array ( array , length ) ; return 0 ; }
Positive elements at even and negative at odd positions ( Relative order not maintained ) 1494 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void re@@ arrange ( int a [ ] , int size ) { int positive = 0 , negative = 1 ; while ( true ) { while ( positive < size && a [ positive ] >= 0 ) positive += 2 ; while ( negative < size && a [ negative ] <= 0 ) negative += 2 ; if ( positive < size && negative < size ) swap ( a [ positive ] , a [ negative ] ) ; else break ; } } int main ( ) { int arr [ ] = { 1 , -@@ 3 , 5 , 6 , -@@ 3 , 6 , 7 , -@@ 4 , 9 , 10 } ; int n = ( sizeof ( arr ) / sizeof ( arr [ 0 ] ) ) ; re@@ arrange ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
Find the largest three distinct elements in an array 1513 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ 3@@ largest ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int check = 0 , count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( count < 4 ) { if ( check != arr [ n - i ] ) { cout << arr [ n - i ] << " ▁ " ; check = arr [ n - i ] ; count ++ ; } } else break ; } } int main ( ) { int arr [ ] = { 12 , 45 , 1 , -1 , 45 , 54 , 23 , 5 , 0 , -@@ 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; find@@ 3@@ largest ( arr , n ) ; }
Find the smallest and second smallest elements in an array 1534 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ 2@@ S@@ malle@@ st ( int arr [ ] , int arr_@@ size ) { int i , first , second ; if ( arr_@@ size < 2 ) { cout << " ▁ Invalid ▁ Input ▁ " ; return ; } first = second = INT_MAX ; for ( i = 0 ; i < arr_@@ size ; i ++ ) { if ( arr [ i ] < first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] < second && arr [ i ] != first ) second = arr [ i ] ; } if ( second == INT_MAX ) cout << " There ▁ is ▁ no ▁ second ▁ smallest ▁ element STRNEWLINE " ; else cout << " The ▁ smallest ▁ element ▁ is ▁ " << first << " ▁ and ▁ second ▁ " " S@@ malle@@ st ▁ element ▁ is ▁ " << second << endl ; } int main ( ) { int arr [ ] = { 12 , 13 , 1 , 10 , 34 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; print@@ 2@@ S@@ malle@@ st ( arr , n ) ; return 0 ; }
Find the smallest missing number 1535 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ First@@ Missing ( int array [ ] , int start , int end ) { if ( start > end ) return end + 1 ; if ( start != array [ start ] ) return start ; int mid = ( start + end ) / 2 ; if ( array [ mid ] == mid ) return find@@ First@@ Missing ( array , mid + 1 , end ) ; return find@@ First@@ Missing ( array , start , mid ) ; } int main ( ) { int arr [ ] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " S@@ malle@@ st ▁ missing ▁ element ▁ is ▁ " << find@@ First@@ Missing ( arr , 0 , n - 1 ) << endl ; }
Range LC@@ M Queries 1552 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define MAX 1000 NEW_LINE int tree [ 4 * MAX ] ; int arr [ MAX ] ; int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } int l@@ cm ( int a , int b ) { return a * b / gcd ( a , b ) ; } void build ( int node , int start , int end ) { if ( start == end ) { tree [ node ] = arr [ start ] ; return ; } int mid = ( start + end ) / 2 ; build ( 2 * node , start , mid ) ; build ( 2 * node + 1 , mid + 1 , end ) ; int left_@@ l@@ cm = tree [ 2 * node ] ; int right_@@ l@@ cm = tree [ 2 * node + 1 ] ; tree [ node ] = l@@ cm ( left_@@ l@@ cm , right_@@ l@@ cm ) ; } int query ( int node , int start , int end , int l , int r ) { if ( end < l start > r ) return 1 ; if ( l <= start && r >= end ) return tree [ node ] ; int mid = ( start + end ) / 2 ; int left_@@ l@@ cm = query ( 2 * node , start , mid , l , r ) ; int right_@@ l@@ cm = query ( 2 * node + 1 , mid + 1 , end , l , r ) ; return l@@ cm ( left_@@ l@@ cm , right_@@ l@@ cm ) ; } int main ( ) { arr [ 0 ] = 5 ; arr [ 1 ] = 7 ; arr [ 2 ] = 5 ; arr [ 3 ] = 2 ; arr [ 4 ] = 10 ; arr [ 5 ] = 12 ; arr [ 6 ] = 11 ; arr [ 7 ] = 17 ; arr [ 8 ] = 14 ; arr [ 9 ] = 1 ; arr [ 10 ] = 44 ; build ( 1 , 0 , 10 ) ; cout << query ( 1 , 0 , 10 , 2 , 5 ) << endl ; cout << query ( 1 , 0 , 10 , 5 , 10 ) << endl ; cout << query ( 1 , 0 , 10 , 0 , 10 ) << endl ; return 0 ; }
Queries for counts of array elements with values in given range 1557 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int lower@@ Index ( int arr [ ] , int n , int x ) { int l = 0 , h = n - 1 ; while ( l <= h ) { int mid = ( l + h ) / 2 ; if ( arr [ mid ] >= x ) h = mid - 1 ; else l = mid + 1 ; } return l ; } int upper@@ Index ( int arr [ ] , int n , int y ) { int l = 0 , h = n - 1 ; while ( l <= h ) { int mid = ( l + h ) / 2 ; if ( arr [ mid ] <= y ) l = mid + 1 ; else h = mid - 1 ; } return h ; } int count@@ InRange ( int arr [ ] , int n , int x , int y ) { int count = 0 ; count = upper@@ Index ( arr , n , y ) - lower@@ Index ( arr , n , x ) + 1 ; return count ; } int main ( ) { int arr [ ] = { 1 , 4 , 4 , 9 , 10 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sort ( arr , arr + n ) ; int i = 1 , j = 4 ; cout << count@@ InRange ( arr , n , i , j ) << endl ; i = 9 , j = 12 ; cout << count@@ InRange ( arr , n , i , j ) << endl ; return 0 ; }
Array range queries over range queries 1562 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void type1 ( int arr [ ] , int start , int limit ) { for ( int i = start ; i <= limit ; i ++ ) arr [ i ] ++ ; } void type2 ( int arr [ ] , int query [ ] [ 3 ] , int start , int limit ) { for ( int i = start ; i <= limit ; i ++ ) { if ( query [ i ] [ 0 ] == 1 ) type1 ( arr , query [ i ] [ 1 ] , query [ i ] [ 2 ] ) ; else if ( query [ i ] [ 0 ] == 2 ) type2 ( arr , query , query [ i ] [ 1 ] , query [ i ] [ 2 ] ) ; } } int main ( ) { int n = 5 , m = 5 ; int arr [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) arr [ i ] = 0 ; int temp [ 15 ] = { 1 , 1 , 2 , 1 , 4 , 5 , 2 , 1 , 2 , 2 , 1 , 3 , 2 , 3 , 4 } ; int query [ 5 ] [ 3 ] ; int j = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { query [ i ] [ 0 ] = temp [ j ++ ] ; query [ i ] [ 1 ] = temp [ j ++ ] ; query [ i ] [ 2 ] = temp [ j ++ ] ; } for ( int i = 1 ; i <= m ; i ++ ) if ( query [ i ] [ 0 ] == 1 ) type1 ( arr , query [ i ] [ 1 ] , query [ i ] [ 2 ] ) ; else if ( query [ i ] [ 0 ] == 2 ) type2 ( arr , query , query [ i ] [ 1 ] , query [ i ] [ 2 ] ) ; for ( int i = 1 ; i <= n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
Sort an array in wave form 1608 | #@@ include <@@ io@@ stream@@ > NEW_LINE #@@ include <@@ algorithm@@ > NEW_LINE using namespace std ; void swap ( int * x , int * y ) { int temp = * x ; * x = * y ; * y = temp ; } void sort@@ In@@ Wave ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 1 ; i += 2 ) swap ( & arr [ i ] , & arr [ i + 1 ] ) ; } int main ( ) { int arr [ ] = { 10 , 90 , 49 , 2 , 1 , 5 , 23 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sort@@ In@@ Wave ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
Merge an array of size n into another array of size m + n 1610 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define NA -1 NEW_LINE void moveTo@@ End ( int m@@ Plus@@ N [ ] , int size ) { int j = size - 1 ; for ( int i = size - 1 ; i >= 0 ; i -- ) if ( m@@ Plus@@ N [ i ] != NA ) { m@@ Plus@@ N [ j ] = m@@ Plus@@ N [ i ] ; j -- ; } } int merge ( int m@@ Plus@@ N [ ] , int N [ ] , int m , int n ) { int i = n ; int j = 0 ; int k = 0 ; while ( k < ( m + n ) ) { if ( ( j == n ) || ( i < ( m + n ) && m@@ Plus@@ N [ i ] <= N [ j ] ) ) { m@@ Plus@@ N [ k ] = m@@ Plus@@ N [ i ] ; k ++ ; i ++ ; } else { m@@ Plus@@ N [ k ] = N [ j ] ; k ++ ; j ++ ; } } } void print@@ Array ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << endl ; } int main ( ) { int m@@ Plus@@ N [ ] = { 2 , 8 , NA , NA , NA , 13 , NA , 15 , 20 } ; int N [ ] = { 5 , 7 , 9 , 25 } ; int n = sizeof ( N ) / sizeof ( N [ 0 ] ) ; int m = sizeof ( m@@ Plus@@ N ) / sizeof ( m@@ Plus@@ N [ 0 ] ) - n ; moveTo@@ End ( m@@ Plus@@ N , m + n ) ; merge ( m@@ Plus@@ N , N , m , n ) ; print@@ Array ( m@@ Plus@@ N , m + n ) ; return 0 ; }
Count In@@ versions in an array | Set 1 ( Using Merge Sort ) 1614 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int getIn@@ v@@ Count ( int arr [ ] , int n ) { int inv_@@ count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) inv_@@ count ++ ; return inv_@@ count ; } int main ( ) { int arr [ ] = { 1 , 20 , 6 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " ▁ Number ▁ of ▁ in@@ versions ▁ are ▁ " << getIn@@ v@@ Count ( arr , n ) ; return 0 ; }
Two elements whose sum is closest to zero 1616 | # include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE # include <@@ std@@ lib@@ .@@ h@@ > NEW_LINE # include <@@ math@@ .@@ h@@ > NEW_LINE using namespace std ; void min@@ Abs@@ Sum@@ Pair ( int arr [ ] , int arr_@@ size ) { int inv_@@ count = 0 ; int l , r , min_@@ sum , sum , min_@@ l , min_@@ r ; if ( arr_@@ size < 2 ) { cout << " Invalid ▁ Input " ; return ; } min_@@ l = 0 ; min_@@ r = 1 ; min_@@ sum = arr [ 0 ] + arr [ 1 ] ; for ( l = 0 ; l < arr_@@ size - 1 ; l ++ ) { for ( r = l + 1 ; r < arr_@@ size ; r ++ ) { sum = arr [ l ] + arr [ r ] ; if ( abs ( min_@@ sum ) > abs ( sum ) ) { min_@@ sum = sum ; min_@@ l = l ; min_@@ r = r ; } } } cout << " The ▁ two ▁ elements ▁ whose ▁ sum ▁ is ▁ minimum ▁ are ▁ " << arr [ min_@@ l ] << " ▁ and ▁ " << arr [ min_@@ r ] ; } int main ( ) { int arr [ ] = { 1 , 60 , -@@ 10 , 70 , -@@ 80 , 85 } ; min@@ Abs@@ Sum@@ Pair ( arr , 6 ) ; return 0 ; }
Sort an array of 0 s , 1 s and 2 s 1634 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void sort@@ 012 ( int a [ ] , int arr_@@ size ) { int lo = 0 ; int hi = arr_@@ size - 1 ; int mid = 0 ; while ( mid <= hi ) { switch ( a [ mid ] ) { case 0 : swap ( a [ lo ++ ] , a [ mid ++ ] ) ; break ; case 1 : mid ++ ; break ; case 2 : swap ( a [ mid ] , a [ hi -- ] ) ; break ; } } } void print@@ Array ( int arr [ ] , int arr_@@ size ) { for ( int i = 0 ; i < arr_@@ size ; i ++ ) cout << arr [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 0 , 1 , 1 , 0 , 1 , 2 , 1 , 2 , 0 , 0 , 0 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sort@@ 012 ( arr , n ) ; cout << " array ▁ after ▁ se@@ greg@@ ation ▁ " ; print@@ Array ( arr , n ) ; return 0 ; }
Find the Minimum length Un@@ sorted Sub@@ array , sorting which makes the complete array sorted 1636 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ Un@@ sorted ( int arr [ ] , int n ) { int s = 0 , e = n - 1 , i , max , min ; for ( s = 0 ; s < n - 1 ; s ++ ) { if ( arr [ s ] > arr [ s + 1 ] ) break ; } if ( s == n - 1 ) { cout << " The ▁ complete ▁ array ▁ is ▁ sorted " ; return ; } for ( e = n - 1 ; e > 0 ; e -- ) { if ( arr [ e ] < arr [ e - 1 ] ) break ; } max = arr [ s ] ; min = arr [ s ] ; for ( i = s + 1 ; i <= e ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; if ( arr [ i ] < min ) min = arr [ i ] ; } for ( i = 0 ; i < s ; i ++ ) { if ( arr [ i ] > min ) { s = i ; break ; } } for ( i = n - 1 ; i >= e + 1 ; i -- ) { if ( arr [ i ] < max ) { e = i ; break ; } } cout << " The ▁ un@@ sorted ▁ sub@@ array ▁ which " << " ▁ makes ▁ the ▁ given ▁ array " << endl << " sorted ▁ lies ▁ between ▁ the ▁ inde@@ es ▁ " << s << " ▁ and ▁ " << e ; return ; } int main ( ) { int arr [ ] = { 10 , 12 , 20 , 30 , 25 , 40 , 32 , 31 , 35 , 50 , 60 } ; int arr_@@ size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; print@@ Un@@ sorted ( arr , arr_@@ size ) ; get@@ char ( ) ; return 0 ; }
Search , insert and delete in an un@@ sorted array 1656 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int findElement ( int arr [ ] , int n , int key ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == key ) return i ; return -1 ; } int main ( ) { int arr [ ] = { 12 , 34 , 10 , 6 , 40 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int key = 40 ; int position = findElement ( arr , n , key ) ; if ( position == - 1 ) cout << " Element ▁ not ▁ found " ; else cout << " Element ▁ Found ▁ at ▁ Position : ▁ " << position + 1 ; return 0 ; }
Search , insert and delete in a sorted array 1659 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int binary@@ Search ( int arr [ ] , int low , int high , int key ) { if ( high < low ) return -1 ; int mid = ( low + high ) / 2 ; if ( key == arr [ mid ] ) return mid ; if ( key > arr [ mid ] ) return binary@@ Search ( arr , ( mid + 1 ) , high , key ) ; return binary@@ Search ( arr , low , ( mid - 1 ) , key ) ; } int main ( ) { int arr [ ] = { 5 , 6 , 7 , 8 , 9 , 10 } ; int n , key ; n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; key = 10 ; cout << " Index : ▁ " << binary@@ Search ( arr , 0 , n - 1 , key ) << endl ; return 0 ; }
Equi@@ lib@@ ri@@ um index of an array 1683 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int equi@@ lib@@ ri@@ um ( int arr [ ] , int n ) { int sum = 0 ; int left@@ sum = 0 ; for ( int i = 0 ; i < n ; ++ i ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; ++ i ) { sum -= arr [ i ] ; if ( left@@ sum == sum ) return i ; left@@ sum += arr [ i ] ; } return -1 ; } int main ( ) { int arr [ ] = { -@@ 7 , 1 , 5 , 2 , -@@ 4 , 3 , 0 } ; int arr_@@ size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " First ▁ equi@@ lib@@ ri@@ um ▁ index ▁ is ▁ " << equi@@ lib@@ ri@@ um ( arr , arr_@@ size ) ; return 0 ; }
Ceil@@ ing in a sorted array 1688 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int ceil@@ Search ( int arr [ ] , int low , int high , int x ) { int mid ; if ( x <= arr [ low ] ) return low ; if ( x > arr [ high ] ) return -1 ; mid = ( low + high ) / 2 ; if ( arr [ mid ] == x ) return mid ; else if ( arr [ mid ] < x ) { if ( mid + 1 <= high && x <= arr [ mid + 1 ] ) return mid + 1 ; else return ceil@@ Search ( arr , mid + 1 , high , x ) ; } else { if ( mid - 1 >= low && x > arr [ mid - 1 ] ) return mid ; else return ceil@@ Search ( arr , low , mid - 1 , x ) ; } } int main ( ) { int arr [ ] = { 1 , 2 , 8 , 10 , 10 , 12 , 19 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 20 ; int index = ceil@@ Search ( arr , 0 , n - 1 , x ) ; if ( index == -1 ) cout << " Ceil@@ ing ▁ of ▁ " << x << " ▁ doesn ' t ▁ exist ▁ in ▁ array ▁ " ; else cout << " ceiling ▁ of ▁ " << x << " ▁ is ▁ " << arr [ index ] ; return 0 ; }
Sum of heights of all individual nodes in a binary tree 168 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE struct Node { int data ; struct Node * left ; struct Node * right ; } ; int getHeight ( struct Node * Node ) { if ( Node == NULL ) return 0 ; else { int l@@ Height = getHeight ( Node -> left ) ; int r@@ Height = getHeight ( Node -> right ) ; if ( l@@ Height > r@@ Height ) return ( l@@ Height + 1 ) ; else return ( r@@ Height + 1 ) ; } } struct Node * newNode ( int data ) { struct Node * Node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; Node -> data = data ; Node -> left = NULL ; Node -> right = NULL ; return ( Node ) ; } int getTotal@@ Height ( struct Node * root ) { if ( root == NULL ) return 0 ; return getTotal@@ Height ( root -> left ) + getHeight ( root ) + getTotal@@ Height ( root -> right ) ; } int main ( ) { struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; printf ( " Sum ▁ of ▁ heights ▁ of ▁ all ▁ Nodes ▁ = ▁ % d " , getTotal@@ Height ( root ) ) ; return 0 ; }
Maj@@ ority Element 1693 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int maj@@ ority@@ Element ( int * arr , int n ) { sort ( arr , arr + n ) ; int count = 1 , max_@@ ele = -1 , temp = arr [ 0 ] , ele , f = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( temp == arr [ i ] ) { count ++ ; } else { count = 1 ; temp = arr [ i ] ; } if ( max_@@ ele < count ) { max_@@ ele = count ; ele = arr [ i ] ; if ( max_@@ ele > ( n / 2 ) ) { f = 1 ; break ; } } } return ( f == 1 ? ele : -1 ) ; } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 1 , 3 , 5 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maj@@ ority@@ Element ( arr , n ) ; return 0 ; }
Check for Maj@@ ority Element in a sorted array 1694 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Maj@@ ority ( int arr [ ] , int n , int x ) { int i ; int last_@@ index = n % 2 ? ( n / 2 + 1 ) : ( n / 2 ) ; for ( i = 0 ; i < last_@@ index ; i ++ ) { if ( arr [ i ] == x && arr [ i + n / 2 ] == x ) return 1 ; } return 0 ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 4 , 4 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 4 ; if ( is@@ Maj@@ ority ( arr , n , x ) ) cout << x << " ▁ appears ▁ more ▁ than ▁ " << n / 2 << " ▁ times ▁ in ▁ arr [ ] " << endl ; else cout << x << " ▁ does ▁ not ▁ appear ▁ more ▁ than " << n / 2 << " ▁ times ▁ in ▁ arr [ ] " << endl ; return 0 ; }
Check for Maj@@ ority Element in a sorted array 169 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; struct Node { int data ; struct Node * left ; struct Node * right ; } ; struct Node * newNode ( int data ) { struct Node * Node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; Node -> data = data ; Node -> left = NULL ; Node -> right = NULL ; return ( Node ) ; } int getTotal@@ Height@@ Util ( struct Node * root , int & sum ) { if ( root == NULL ) return 0 ; int lh = getTotal@@ Height@@ Util ( root -> left , sum ) ; int rh = getTotal@@ Height@@ Util ( root -> right , sum ) ; int h = max ( lh , rh ) + 1 ; sum = sum + h ; return h ; } int getTotal@@ Height ( Node * root ) { int sum = 0 ; getTotal@@ Height@@ Util ( root , sum ) ; return sum ; } int main ( ) { struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; printf ( " Sum ▁ of ▁ heights ▁ of ▁ all ▁ Nodes ▁ = ▁ % d " , getTotal@@ Height ( root ) ) ; return 0 ; }
Ste@@ pping Numbers 364 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void b@@ fs ( int n , int m , int num ) { queue < int > q ; q . push ( num ) ; while ( ! q . empty ( ) ) { int step@@ Num = q . front ( ) ; q . pop ( ) ; if ( step@@ Num <= m && step@@ Num >= n ) cout << step@@ Num << " ▁ " ; if ( num == 0 step@@ Num > m ) continue ; int last@@ Digit = step@@ Num % 10 ; int step@@ Num@@ A = step@@ Num * 10 + ( last@@ Digit - 1 ) ; int step@@ Num@@ B = step@@ Num * 10 + ( last@@ Digit + 1 ) ; if ( last@@ Digit == 0 ) q . push ( step@@ Num@@ B ) ; else if ( last@@ Digit == 9 ) q . push ( step@@ Num@@ A ) ; else { q . push ( step@@ Num@@ A ) ; q . push ( step@@ Num@@ B ) ; } } } void display@@ Ste@@ pping@@ Numbers ( int n , int m ) { for ( int i = 0 ; i <= 9 ; i ++ ) b@@ fs ( n , m , i ) ; } int main ( ) { int n = 0 , m = 21 ; display@@ Ste@@ pping@@ Numbers ( n , m ) ; return 0 ; }
Level order traversal line by line | Set 3 ( Using One Queue ) 37 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; struct node { struct node * left ; int data ; struct node * right ; } ; void level@@ Order ( node * root ) { if ( root == NULL ) return ; queue < node * > q ; node * curr ; q . push ( root ) ; q . push ( NULL ) ; while ( q . size ( ) > 1 ) { curr = q . front ( ) ; q . pop ( ) ; if ( curr == NULL ) { q . push ( NULL ) ; cout << " STRNEWLINE " ; } else { if ( curr -> left ) q . push ( curr -> left ) ; if ( curr -> right ) q . push ( curr -> right ) ; cout << curr -> data << " ▁ " ; } } } node * newNode ( int data ) { node * temp = new node ; temp -> data = data ; temp -> left = NULL ; temp -> right = NULL ; return temp ; } int main ( ) { node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> right = newNode ( 6 ) ; level@@ Order ( root ) ; return 0 ; }
Word L@@ adder ( Length of shortest chain to reach a target word ) 447 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int shor@@ test@@ Chain@@ Len ( string start , string target , set < string > & D ) { if ( start == target ) return 0 ; if ( D . find ( target ) == D . end ( ) ) return 0 ; int level = 0 , word@@ length = start . size ( ) ; queue < string > Q ; Q . push ( start ) ; while ( ! Q . empty ( ) ) { ++ level ; int size@@ of@@ Q = Q . size ( ) ; for ( int i = 0 ; i < size@@ of@@ Q ; ++ i ) { string word = Q . front ( ) ; Q . pop ( ) ; for ( int pos = 0 ; pos < word@@ length ; ++ pos ) { char orig_@@ char = word [ pos ] ; for ( char c = ' a ' ; c <= ' z ' ; ++ c ) { word [ pos ] = c ; if ( word == target ) return level + 1 ; if ( D . find ( word ) == D . end ( ) ) continue ; D . erase ( word ) ; Q . push ( word ) ; } word [ pos ] = orig_@@ char ; } } } return 0 ; } int main ( ) { set < string > D ; D . insert ( " po@@ on " ) ; D . insert ( " p@@ lee " ) ; D . insert ( " same " ) ; D . insert ( " po@@ ie " ) ; D . insert ( " p@@ lie " ) ; D . insert ( " po@@ in " ) ; D . insert ( " ple@@ a " ) ; string start = " to@@ on " ; string target = " ple@@ a " ; cout << " Length ▁ of ▁ shortest ▁ chain ▁ is : ▁ " << shor@@ test@@ Chain@@ Len ( start , target , D ) ; return 0 ; }
Swap K@@ th node from beginning with K@@ th node from end in a Linked List 605 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; void push ( struct Node * * head_@@ ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = ( * head_@@ ref ) ; ( * head_@@ ref ) = new_node ; } void print@@ List ( struct Node * node ) { while ( node != NULL ) { cout << node -> data << " ▁ " ; node = node -> next ; } cout << endl ; } int count@@ Nodes ( struct Node * s ) { int count = 0 ; while ( s != NULL ) { count ++ ; s = s -> next ; } return count ; } void swap@@ K@@ th ( struct Node * * head_@@ ref , int k ) { int n = count@@ Nodes ( * head_@@ ref ) ; if ( n < k ) return ; if ( 2 * k - 1 == n ) return ; Node * x = * head_@@ ref ; Node * x_@@ prev = NULL ; for ( int i = 1 ; i < k ; i ++ ) { x_@@ prev = x ; x = x -> next ; } Node * y = * head_@@ ref ; Node * y_@@ prev = NULL ; for ( int i = 1 ; i < n - k + 1 ; i ++ ) { y_@@ prev = y ; y = y -> next ; } if ( x_@@ prev ) x_@@ prev -> next = y ; if ( y_@@ prev ) y_@@ prev -> next = x ; Node * temp = x -> next ; x -> next = y -> next ; y -> next = temp ; if ( k == 1 ) * head_@@ ref = y ; if ( k == n ) * head_@@ ref = x ; } int main ( ) { struct Node * head = NULL ; for ( int i = 8 ; i >= 1 ; i -- ) push ( & head , i ) ; cout << " Original ▁ Linked ▁ List : ▁ " ; print@@ List ( head ) ; for ( int k = 1 ; k < 9 ; k ++ ) { swap@@ K@@ th ( & head , k ) ; cout << " Modified List for k = " print@@ List ( head ) ; } return 0 ; }
Count trip@@ lets in a sorted dou@@ bly linked list whose sum is equal to a given value x 612 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; struct Node { int data ; struct Node * next , * prev ; } ; int count@@ Pairs ( struct Node * first , struct Node * second , int value ) { int count = 0 ; while ( first != NULL && second != NULL && first != second && second -> next != first ) { if ( ( first -> data + second -> data ) == value ) { count ++ ; first = first -> next ; second = second -> prev ; } else if ( ( first -> data + second -> data ) > value ) second = second -> prev ; else first = first -> next ; } return count ; } int count@@ Trip@@ lets ( struct Node * head , int x ) { if ( head == NULL ) return 0 ; struct Node * current , * first , * last ; int count = 0 ; last = head ; while ( last -> next != NULL ) last = last -> next ; for ( current = head ; current != NULL ; current = current -> next ) { first = current -> next ; count += count@@ Pairs ( first , last , x - current -> data ) ; } return count ; } void insert ( struct Node * * head , int data ) { struct Node * temp = new Node ( ) ; temp -> data = data ; temp -> next = temp -> prev = NULL ; if ( ( * head ) == NULL ) ( * head ) = temp ; else { temp -> next = * head ; ( * head ) -> prev = temp ; ( * head ) = temp ; } } int main ( ) { struct Node * head = NULL ; insert ( & head , 9 ) ; insert ( & head , 8 ) ; insert ( & head , 6 ) ; insert ( & head , 5 ) ; insert ( & head , 4 ) ; insert ( & head , 2 ) ; insert ( & head , 1 ) ; int x = 17 ; cout << " Count ▁ = ▁ " << count@@ Trip@@ lets ( head , x ) ; return 0 ; }
Ar@@ range con@@ son@@ ants and vo@@ w@@ els nodes in a linked list 647 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; struct Node { char data ; struct Node * next ; } ; Node * newNode ( char key ) { Node * temp = new Node ; temp -> data = key ; temp -> next = NULL ; return temp ; } void print@@ list ( Node * head ) { if ( ! head ) { cout << " Empty ▁ List STRNEWLINE " ; return ; } while ( head != NULL ) { cout << head -> data << " ▁ " ; if ( head -> next ) cout << " - > ▁ " ; head = head -> next ; } cout << endl ; } bool is@@ Vo@@ wel ( char x ) { return ( x == ' a ' x == ' e ' x == ' i ' x == ' o ' x == ' u ' ) ; } Node * arrange ( Node * head ) { Node * new@@ Head = head ; Node * latest@@ Vo@@ wel ; Node * curr = head ; if ( head == NULL ) return NULL ; if ( is@@ Vo@@ wel ( head -> data ) ) latest@@ Vo@@ wel = head ; else { while ( curr -> next != NULL && ! is@@ Vo@@ wel ( curr -> next -> data ) ) curr = curr -> next ; if ( curr -> next == NULL ) return head ; latest@@ Vo@@ wel = new@@ Head = curr -> next ; curr -> next = curr -> next -> next ; latest@@ Vo@@ wel -> next = head ; } while ( curr != NULL && curr -> next != NULL ) { if ( is@@ Vo@@ wel ( curr -> next -> data ) ) { if ( curr == latest@@ Vo@@ wel ) { latest@@ Vo@@ wel = curr = curr -> next ; } else { Node * temp = latest@@ Vo@@ wel -> next ; latest@@ Vo@@ wel -> next = curr -> next ; latest@@ Vo@@ wel = latest@@ Vo@@ wel -> next ; curr -> next = curr -> next -> next ; latest@@ Vo@@ wel -> next = temp ; } } else { curr = curr -> next ; } } return new@@ Head ; } int main ( ) { Node * head = newNode ( ' a ' ) ; head -> next = newNode ( ' b ' ) ; head -> next -> next = newNode ( ' c ' ) ; head -> next -> next -> next = newNode ( ' e ' ) ; head -> next -> next -> next -> next = newNode ( ' d ' ) ; head -> next -> next -> next -> next -> next = newNode ( ' o ' ) ; head -> next -> next -> next -> next -> next -> next = newNode ( ' x ' ) ; head -> next -> next -> next -> next -> next -> next -> next = newNode ( ' i ' ) ; printf ( " Linked ▁ list ▁ before ▁ : STRNEWLINE " ) ; print@@ list ( head ) ; head = arrange ( head ) ; printf ( " Linked ▁ list ▁ after ▁ : STRNEWLINE " ) ; print@@ list ( head ) ; return 0 ; }
Find k 688 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; Node ( int x ) { data = x ; left = right = NULL ; } } ; Node * insert ( Node * root , int x ) { if ( root == NULL ) return new Node ( x ) ; if ( x < root -> data ) root -> left = insert ( root -> left , x ) ; else if ( x > root -> data ) root -> right = insert ( root -> right , x ) ; return root ; } Node * k@@ th@@ S@@ malle@@ st ( Node * root , int & k ) { if ( root == NULL ) return NULL ; Node * left = k@@ th@@ S@@ malle@@ st ( root -> left , k ) ; if ( left != NULL ) return left ; k -- ; if ( k == 0 ) return root ; return k@@ th@@ S@@ malle@@ st ( root -> right , k ) ; } void print@@ K@@ th@@ S@@ malle@@ st ( Node * root , int k ) { int count = 0 ; Node * res = k@@ th@@ S@@ malle@@ st ( root , k ) ; if ( res == NULL ) cout << " There ▁ are ▁ less ▁ than ▁ k ▁ nodes ▁ in ▁ the ▁ B@@ ST " ; else cout << " K - th ▁ S@@ malle@@ st ▁ Element ▁ is ▁ " << res -> data ; } int main ( ) { Node * root = NULL ; int keys [ ] = { 20 , 8 , 22 , 4 , 12 , 10 , 14 } ; for ( int x : keys ) root = insert ( root , x ) ; int k = 3 ; print@@ K@@ th@@ S@@ malle@@ st ( root , k ) ; return 0 ; }
Shor@@ test distance between two nodes in B@@ ST 704 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; struct Node { struct Node * left , * right ; int key ; } ; struct Node * newNode ( int key ) { struct Node * ptr = new Node ; ptr -> key = key ; ptr -> left = ptr -> right = NULL ; return ptr ; } struct Node * insert ( struct Node * root , int key ) { if ( ! root ) root = newNode ( key ) ; else if ( root -> key > key ) root -> left = insert ( root -> left , key ) ; else if ( root -> key < key ) root -> right = insert ( root -> right , key ) ; return root ; } int distance@@ From@@ Root ( struct Node * root , int x ) { if ( root -> key == x ) return 0 ; else if ( root -> key > x ) return 1 + distance@@ From@@ Root ( root -> left , x ) ; return 1 + distance@@ From@@ Root ( root -> right , x ) ; } int distance@@ Between@@ 2 ( struct Node * root , int a , int b ) { if ( ! root ) return 0 ; if ( root -> key > a && root -> key > b ) return distance@@ Between@@ 2 ( root -> left , a , b ) ; if ( root -> key < a && root -> key < b ) return distance@@ Between@@ 2 ( root -> right , a , b ) ; if ( root -> key >= a && root -> key <= b ) return distance@@ From@@ Root ( root , a ) + distance@@ From@@ Root ( root , b ) ; } int find@@ Dist@@ Wrapper ( Node * root , int a , int b ) { if ( a > b ) swap ( a , b ) ; return distance@@ Between@@ 2 ( root , a , b ) ; } int main ( ) { struct Node * root = NULL ; root = insert ( root , 20 ) ; insert ( root , 10 ) ; insert ( root , 5 ) ; insert ( root , 15 ) ; insert ( root , 30 ) ; insert ( root , 25 ) ; insert ( root , 35 ) ; int a = 5 , b = 55 ; cout << find@@ Dist@@ Wrapper ( root , 5 , 35 ) ; return 0 ; }
Count B@@ ST sub@@ trees that lie in given range 711 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; struct node { int data ; struct node * left , * right ; } ; bool in@@ Range ( node * root , int low , int high ) { return root -> data >= low && root -> data <= high ; } bool get@@ Count@@ Util ( node * root , int low , int high , int * count ) { if ( root == NULL ) return true ; bool l = get@@ Count@@ Util ( root -> left , low , high , count ) ; bool r = get@@ Count@@ Util ( root -> right , low , high , count ) ; if ( l && r && in@@ Range ( root , low , high ) ) { ++ * count ; return true ; } return false ; } int getCount ( node * root , int low , int high ) { int count = 0 ; get@@ Count@@ Util ( root , low , high , & count ) ; return count ; } node * newNode ( int data ) { node * temp = new node ; temp -> data = data ; temp -> left = temp -> right = NULL ; return ( temp ) ; } int main ( ) { node * root = newNode ( 10 ) ; root -> left = newNode ( 5 ) ; root -> right = newNode ( 50 ) ; root -> left -> left = newNode ( 1 ) ; root -> right -> left = newNode ( 40 ) ; root -> right -> right = newNode ( 100 ) ; int l = 5 ; int h = 45 ; cout << " Count ▁ of ▁ sub@@ trees ▁ in ▁ [ " << l << " , ▁ " << h << " ] ▁ is ▁ " << getCount ( root , l , h ) ; return 0 ; }
Sorted order printing of a given array that represents a B@@ ST 747 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ Sorted ( int arr [ ] , int start , int end ) { if ( start > end ) return ; print@@ Sorted ( arr , start * 2 + 1 , end ) ; cout << arr [ start ] << " ▁ " ; print@@ Sorted ( arr , start * 2 + 2 , end ) ; } int main ( ) { int arr [ ] = { 4 , 2 , 5 , 1 , 3 } ; int arr_@@ size = sizeof ( arr ) / sizeof ( int ) ; print@@ Sorted ( arr , 0 , arr_@@ size - 1 ) ; get@@ char ( ) ; return 0 ; }
Minimum operations required to make each row and column of matrix equals 823 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Min@@ Op@@ ear@@ tion ( int matrix [ ] [ 2 ] , int n ) { int sum@@ Row [ n ] , sum@@ Col [ n ] ; memset ( sum@@ Row , 0 , sizeof ( sum@@ Row ) ) ; memset ( sum@@ Col , 0 , sizeof ( sum@@ Col ) ) ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { sum@@ Row [ i ] += matrix [ i ] [ j ] ; sum@@ Col [ j ] += matrix [ i ] [ j ] ; } int max@@ Sum = 0 ; for ( int i = 0 ; i < n ; ++ i ) { max@@ Sum = max ( max@@ Sum , sum@@ Row [ i ] ) ; max@@ Sum = max ( max@@ Sum , sum@@ Col [ i ] ) ; } int count = 0 ; for ( int i = 0 , j = 0 ; i < n && j < n ; ) { int diff = min ( max@@ Sum - sum@@ Row [ i ] , max@@ Sum - sum@@ Col [ j ] ) ; matrix [ i ] [ j ] += diff ; sum@@ Row [ i ] += diff ; sum@@ Col [ j ] += diff ; count += diff ; if ( sum@@ Row [ i ] == max@@ Sum ) ++ i ; if ( sum@@ Col [ j ] == max@@ Sum ) ++ j ; } return count ; } void print@@ Matrix ( int matrix [ ] [ 2 ] , int n ) { for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) cout << matrix [ i ] [ j ] << " ▁ " ; cout << " STRNEWLINE " ; } } int main ( ) { int matrix [ ] [ 2 ] = { { 1 , 2 } , { 3 , 4 } } ; cout << find@@ Min@@ Op@@ ear@@ tion ( matrix , 2 ) << " STRNEWLINE " ; print@@ Matrix ( matrix , 2 ) ; return 0 ; }
Search in a row wise and column wise sorted matrix 848 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int search ( int mat [ 4 ] [ 4 ] , int n , int x ) { if ( n == 0 ) return -1 ; int smallest = mat [ 0 ] [ 0 ] , largest = mat [ n - 1 ] [ n - 1 ] ; if ( x < smallest x > largest ) return -1 ; int i = 0 , j = n - 1 ; while ( i < n && j >= 0 ) { if ( mat [ i ] [ j ] == x ) { cout << " n ▁ Found ▁ at ▁ " << i << " , ▁ " << j ; return 1 ; } if ( mat [ i ] [ j ] > x ) j -- ; else i ++ ; } cout << " n ▁ Element ▁ not ▁ found " ; return 0 ; } int main ( ) { int mat [ 4 ] [ 4 ] = { { 10 , 20 , 30 , 40 } , { 15 , 25 , 35 , 45 } , { 27 , 29 , 37 , 48 } , { 32 , 33 , 39 , 50 } } ; search ( mat , 4 , 29 ) ; return 0 ; }
Check if sums of i 859 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; const int MAX = 100 ; bool are@@ Sum@@ Same ( int a [ ] [ MAX ] , int n , int m ) { int sum@@ 1 = 0 , sum@@ 2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum@@ 1 = 0 , sum@@ 2 = 0 ; for ( int j = 0 ; j < m ; j ++ ) { sum@@ 1 += a [ i ] [ j ] ; sum@@ 2 += a [ j ] [ i ] ; } if ( sum@@ 1 == sum@@ 2 ) return true ; } return false ; } int main ( ) { int n = 4 ; int m = 4 ; int M [ n ] [ MAX ] = { { 1 , 2 , 3 , 4 } , { 9 , 5 , 3 , 1 } , { 0 , 3 , 5 , 6 } , { 0 , 4 , 5 , 6 } } ; cout << are@@ Sum@@ Same ( M , n , m ) << " STRNEWLINE " ; return 0 ; }
Minimum operations required to set all elements of binary matrix 884 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE #@@ define N 5 NEW_LINE #@@ define M 5 NEW_LINE using namespace std ; int min@@ Operation ( bool arr [ N ] [ M ] ) { int ans = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = M - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] [ j ] == 0 ) { ans ++ ; for ( int k = 0 ; k <= i ; k ++ ) { for ( int h = 0 ; h <= j ; h ++ ) { if ( arr [ k ] [ h ] == 1 ) arr [ k ] [ h ] = 0 ; else arr [ k ] [ h ] = 1 ; } } } } } return ans ; } int main ( ) { bool mat [ N ] [ M ] = { 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 } ; cout << min@@ Operation ( mat ) << endl ; return 0 ; }
Sum of both diagon@@ als of a spir@@ al odd 896 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int spir@@ al@@ Di@@ a@@ Sum ( int n ) { if ( n == 1 ) return 1 ; return ( 4 * n * n - 6 * n + 6 + spir@@ al@@ Di@@ a@@ Sum ( n - 2 ) ) ; } int main ( ) { int n = 7 ; cout << spir@@ al@@ Di@@ a@@ Sum ( n ) ; return 0 ; }
Print matrix in diagonal pattern 901 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; const int MAX = 100 ; void print@@ Matrix@@ Diagonal ( int mat [ MAX ] [ MAX ] , int n ) { int i = 0 , j = 0 ; bool is@@ Up = true ; for ( int k = 0 ; k < n * n ; ) { if ( is@@ Up ) { for ( ; i >= 0 && j < n ; j ++ , i -- ) { cout << mat [ i ] [ j ] << " ▁ " ; k ++ ; } if ( i < 0 && j <= n - 1 ) i = 0 ; if ( j == n ) i = i + 2 , j -- ; } else { for ( ; j >= 0 && i < n ; i ++ , j -- ) { cout << mat [ i ] [ j ] << " ▁ " ; k ++ ; } if ( j < 0 && i <= n - 1 ) j = 0 ; if ( i == n ) j = j + 2 , i -- ; } is@@ Up = ! is@@ Up ; } } int main ( ) { int mat [ MAX ] [ MAX ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; int n = 3 ; print@@ Matrix@@ Diagonal ( mat , n ) ; return 0 ; }
Replace every matrix element with maximum of GC@@ D of row or column 907 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define R 3 NEW_LINE #@@ define C 4 NEW_LINE int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } void replace@@ matrix ( int mat [ R ] [ C ] , int n , int m ) { int rg@@ cd [ R ] = { 0 } , cg@@ cd [ C ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { rg@@ cd [ i ] = gcd ( rg@@ cd [ i ] , mat [ i ] [ j ] ) ; cg@@ cd [ j ] = gcd ( cg@@ cd [ j ] , mat [ i ] [ j ] ) ; } } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) mat [ i ] [ j ] = max ( rg@@ cd [ i ] , cg@@ cd [ j ] ) ; } int main ( ) { int m [ R ] [ C ] = { 1 , 2 , 3 , 3 , 4 , 5 , 6 , 6 , 7 , 8 , 9 , 9 , } ; replace@@ matrix ( m , R , C ) ; for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) cout << m [ i ] [ j ] << " ▁ " ; cout << endl ; } return 0 ; }
Count all sorted rows in a matrix 908 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE #@@ define MAX 100 NEW_LINE using namespace std ; int sorted@@ Count ( int mat [ ] [ MAX ] , int r , int c ) { int result = 0 ; for ( int i = 0 ; i < r ; i ++ ) { int j ; for ( j = 0 ; j < c - 1 ; j ++ ) if ( mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] ) break ; if ( j == c - 1 ) result ++ ; } for ( int i = 0 ; i < r ; i ++ ) { int j ; for ( j = c - 1 ; j > 0 ; j -- ) if ( mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] ) break ; if ( c > 1 && j == 0 ) result ++ ; } return result ; } int main ( ) { int m = 4 , n = 5 ; int mat [ ] [ MAX ] = { { 1 , 2 , 3 , 4 , 5 } , { 4 , 3 , 1 , 2 , 6 } , { 8 , 7 , 6 , 5 , 4 } , { 5 , 7 , 8 , 9 , 10 } } ; cout << sorted@@ Count ( mat , m , n ) ; return 0 ; }
Find a specific pair in Matrix 927 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define N 5 NEW_LINE int find@@ Max@@ Value ( int mat [ ] [ N ] ) { int maxValue = INT_@@ MIN ; int max@@ Arr [ N ] [ N ] ; max@@ Arr [ N - 1 ] [ N - 1 ] = mat [ N - 1 ] [ N - 1 ] ; int max@@ v = mat [ N - 1 ] [ N - 1 ] ; for ( int j = N - 2 ; j >= 0 ; j -- ) { if ( mat [ N - 1 ] [ j ] > max@@ v ) max@@ v = mat [ N - 1 ] [ j ] ; max@@ Arr [ N - 1 ] [ j ] = max@@ v ; } max@@ v = mat [ N - 1 ] [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( mat [ i ] [ N - 1 ] > max@@ v ) max@@ v = mat [ i ] [ N - 1 ] ; max@@ Arr [ i ] [ N - 1 ] = max@@ v ; } for ( int i = N - 2 ; i >= 0 ; i -- ) { for ( int j = N - 2 ; j >= 0 ; j -- ) { if ( max@@ Arr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] > maxValue ) maxValue = max@@ Arr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] ; max@@ Arr [ i ] [ j ] = max ( mat [ i ] [ j ] , max ( max@@ Arr [ i ] [ j + 1 ] , max@@ Arr [ i + 1 ] [ j ] ) ) ; } } return maxValue ; } int main ( ) { int mat [ N ] [ N ] = { { 1 , 2 , -1 , -@@ 4 , -@@ 20 } , { -@@ 8 , -@@ 3 , 4 , 2 , 1 } , { 3 , 8 , 6 , 1 , 3 } , { -@@ 4 , -1 , 1 , 7 , -@@ 6 } , { 0 , -@@ 4 , 10 , -@@ 5 , 1 } } ; cout << " Maximum ▁ Value ▁ is ▁ " << find@@ Max@@ Value ( mat ) ; return 0 ; }
Print unique rows in a given boolean matrix 933 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define ROW 4 NEW_LINE #@@ define COL 5 NEW_LINE void find@@ Unique@@ Rows ( int M [ ROW ] [ COL ] ) { for ( int i = 0 ; i < ROW ; i ++ ) { int flag = 0 ; for ( int j = 0 ; j < i ; j ++ ) { flag = 1 ; for ( int k = 0 ; k <= COL ; k ++ ) if ( M [ i ] [ k ] != M [ j ] [ k ] ) flag = 0 ; if ( flag == 1 ) break ; } if ( flag == 0 ) { for ( int j = 0 ; j < COL ; j ++ ) cout << M [ i ] [ j ] << " ▁ " ; cout << endl ; } } } int main ( ) { int M [ ROW ] [ COL ] = { { 0 , 1 , 0 , 0 , 1 } , { 1 , 0 , 1 , 1 , 0 } , { 0 , 1 , 0 , 0 , 1 } , { 1 , 0 , 1 , 0 , 0 } } ; find@@ Unique@@ Rows ( M ) ; return 0 ; }
Find sum of all elements in a matrix except the elements in row and / or column of given cell ? 943 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE #@@ define R 3 NEW_LINE #@@ define C 3 NEW_LINE using namespace std ; struct Cell { int r ; int c ; } ; void print@@ Sum@@ s ( int mat [ ] [ C ] , struct Cell arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 , r = arr [ i ] . r , c = arr [ i ] . c ; for ( int j = 0 ; j < R ; j ++ ) for ( int k = 0 ; k < C ; k ++ ) if ( j != r && k != c ) sum += mat [ j ] [ k ] ; cout << sum << endl ; } } int main ( ) { int mat [ ] [ C ] = { { 1 , 1 , 2 } , { 3 , 4 , 6 } , { 5 , 3 , 2 } } ; struct Cell arr [ ] = { { 0 , 0 } , { 1 , 1 } , { 0 , 1 } } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; print@@ Sum@@ s ( mat , arr , n ) ; return 0 ; }
Given an n x n square matrix , find sum of all sub 956 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; #@@ define n 5 NEW_LINE void print@@ Sum@@ Tri@@ ck@@ y ( int mat [ ] [ n ] , int k ) { if ( k > n ) return ; int strip@@ Sum [ n ] [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { int sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) sum += mat [ i ] [ j ] ; strip@@ Sum [ 0 ] [ j ] = sum ; for ( int i = 1 ; i < n - k + 1 ; i ++ ) { sum += ( mat [ i + k - 1 ] [ j ] - mat [ i - 1 ] [ j ] ) ; strip@@ Sum [ i ] [ j ] = sum ; } } for ( int i = 0 ; i < n - k + 1 ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < k ; j ++ ) sum += strip@@ Sum [ i ] [ j ] ; cout << sum << " ▁ " ; for ( int j = 1 ; j < n - k + 1 ; j ++ ) { sum += ( strip@@ Sum [ i ] [ j + k - 1 ] - strip@@ Sum [ i ] [ j - 1 ] ) ; cout << sum << " ▁ " ; } cout << endl ; } } int main ( ) { int mat [ n ] [ n ] = { { 1 , 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 , 4 } , { 5 , 5 , 5 , 5 , 5 } , } ; int k = 3 ; print@@ Sum@@ Tri@@ ck@@ y ( mat , k ) ; return 0 ; }
Number of paths with exactly k coins 966 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE #@@ define R 3 NEW_LINE #@@ define C 3 NEW_LINE #@@ define MAX_@@ K 1000 NEW_LINE using namespace std ; int dp [ R ] [ C ] [ MAX_@@ K ] ; int path@@ Count@@ DP@@ Rec@@ DP ( int mat [ ] [ C ] , int m , int n , int k ) { if ( m < 0 n < 0 ) return 0 ; if ( m == 0 && n == 0 ) return ( k == mat [ m ] [ n ] ) ; if ( dp [ m ] [ n ] [ k ] != -1 ) return dp [ m ] [ n ] [ k ] ; dp [ m ] [ n ] [ k ] = path@@ Count@@ DP@@ Rec@@ DP ( mat , m - 1 , n , k - mat [ m ] [ n ] ) + path@@ Count@@ DP@@ Rec@@ DP ( mat , m , n - 1 , k - mat [ m ] [ n ] ) ; return dp [ m ] [ n ] [ k ] ; } int path@@ Count@@ DP ( int mat [ ] [ C ] , int k ) { memset ( dp , -1 , sizeof dp ) ; return path@@ Count@@ DP@@ Rec@@ DP ( mat , R - 1 , C - 1 , k ) ; } int main ( ) { int k = 12 ; int mat [ R ] [ C ] = { { 1 , 2 , 3 } , { 4 , 6 , 5 } , { 3 , 2 , 1 } } ; cout << path@@ Count@@ DP ( mat , k ) ; return 0 ; }
Find length of the longest consecutive path from a given starting character 967 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE #@@ define R 3 NEW_LINE #@@ define C 3 NEW_LINE using namespace std ; int x [ ] = { 0 , 1 , 1 , -1 , 1 , 0 , -1 , -1 } ; int y [ ] = { 1 , 0 , 1 , 1 , -1 , -1 , 0 , -1 } ; int dp [ R ] [ C ] ; bool is@@ valid ( int i , int j ) { if ( i < 0 j < 0 i > = R j > = C ) return false ; return true ; } bool is@@ adjacent ( char prev , char curr ) { return ( ( curr - prev ) == 1 ) ; } int get@@ Len@@ Util ( char mat [ R ] [ C ] , int i , int j , char prev ) { if ( ! is@@ valid ( i , j ) || ! is@@ adjacent ( prev , mat [ i ] [ j ] ) ) return 0 ; if ( dp [ i ] [ j ] != -1 ) return dp [ i ] [ j ] ; int ans = 0 ; for ( int k = 0 ; k < 8 ; k ++ ) ans = max ( ans , 1 + get@@ Len@@ Util ( mat , i + x [ k ] , j + y [ k ] , mat [ i ] [ j ] ) ) ; return dp [ i ] [ j ] = ans ; } int get@@ Len ( char mat [ R ] [ C ] , char s ) { memset ( dp , -1 , sizeof dp ) ; int ans = 0 ; for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) { if ( mat [ i ] [ j ] == s ) { for ( int k = 0 ; k < 8 ; k ++ ) ans = max ( ans , 1 + get@@ Len@@ Util ( mat , i + x [ k ] , j + y [ k ] , s ) ) ; } } } return ans ; } int main ( ) { char mat [ R ] [ C ] = { { ' a ' , ' c ' , ' d ' } , { ' h ' , ' b ' , ' a ' } , { ' i ' , ' g ' , ' f ' } } ; cout << get@@ Len ( mat , ' a ' ) << endl ; cout << get@@ Len ( mat , ' e ' ) << endl ; cout << get@@ Len ( mat , ' b ' ) << endl ; cout << get@@ Len ( mat , ' f ' ) << endl ; return 0 ; }
Find the two repe@@ ating elements in a given array 1703 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ Repe@@ ating ( int arr [ ] , int size ) { int * count = new int [ sizeof ( int ) * ( size - 2 ) ] ; int i ; cout << " ▁ Repe@@ ating ▁ elements ▁ are ▁ " ; for ( i = 0 ; i < size ; i ++ ) { if ( count [ arr [ i ] ] == 1 ) cout << arr [ i ] << " ▁ " ; else count [ arr [ i ] ] ++ ; } } int main ( ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_@@ size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; print@@ Repe@@ ating ( arr , arr_@@ size ) ; return 0 ; }
Find the two repe@@ ating elements in a given array 1706 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ Repe@@ ating ( int arr [ ] , int size ) { int i ; cout << " The ▁ repe@@ ating ▁ elements ▁ are " ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ abs ( arr [ i ] ) ] > 0 ) arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ] ; else cout << " ▁ " << abs ( arr [ i ] ) << " ▁ " ; } } int main ( ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_@@ size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; print@@ Repe@@ ating ( arr , arr_@@ size ) ; return 0 ; }
Find a Fixed Point ( Value equal to index ) in a given array 1708 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int binary@@ Search ( int arr [ ] , int low , int high ) { if ( high >= low ) { int mid = ( low + high ) / 2 ; if ( mid == arr [ mid ] ) return mid ; if ( mid > arr [ mid ] ) return binary@@ Search ( arr , ( mid + 1 ) , high ) ; else return binary@@ Search ( arr , low , ( mid - 1 ) ) ; } return -1 ; } int main ( ) { int arr [ 10 ] = { -@@ 10 , -1 , 0 , 3 , 10 , 11 , 30 , 50 , 100 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Fixed ▁ Point ▁ is ▁ " << binary@@ Search ( arr , 0 , n - 1 ) ; return 0 ; }
Find sub@@ array with given sum | Set 1 ( Non@@ negative Numbers ) 1709 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int sub@@ Array@@ Sum ( int arr [ ] , int n , int sum ) { int curr_@@ sum , i , j ; for ( i = 0 ; i < n ; i ++ ) { curr_@@ sum = arr [ i ] ; for ( j = i + 1 ; j <= n ; j ++ ) { if ( curr_@@ sum == sum ) { cout << " Sum ▁ found ▁ between ▁ indexes ▁ " << i << " ▁ and ▁ " << j - 1 ; return 1 ; } if ( curr_@@ sum > sum j == n ) break ; curr_@@ sum = curr_@@ sum + arr [ j ] ; } } cout << " No ▁ sub@@ array ▁ found " ; return 0 ; } int main ( ) { int arr [ ] = { 15 , 2 , 4 , 8 , 9 , 5 , 10 , 23 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int sum = 23 ; sub@@ Array@@ Sum ( arr , n , sum ) ; return 0 ; }
Min Cost Path | DP 1843 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define R 3 NEW_LINE #@@ define C 3 NEW_LINE int min ( int x , int y , int z ) ; int min ( int x , int y , int z ) { if ( x < y ) return ( x < z ) ? x : z ; else return ( y < z ) ? y : z ; } int min@@ Cost ( int cost [ R ] [ C ] , int m , int n ) { if ( n < 0 m < 0 ) return INT_MAX ; else if ( m == 0 && n == 0 ) return cost [ m ] [ n ] ; else return cost [ m ] [ n ] + min ( min@@ Cost ( cost , m - 1 , n - 1 ) , min@@ Cost ( cost , m - 1 , n ) , min@@ Cost ( cost , m , n - 1 ) ) ; } int main ( ) { int cost [ R ] [ C ] = { { 1 , 2 , 3 } , { 4 , 8 , 2 } , { 1 , 5 , 3 } } ; cout << min@@ Cost ( cost , 2 , 2 ) << endl ; return 0 ; }
Min Cost Path | DP 1844 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE #@@ include <@@ limit@@ s.@@ h@@ > NEW_LINE #@@ define R 3 NEW_LINE #@@ define C 3 NEW_LINE using namespace std ; int min ( int x , int y , int z ) ; int min@@ Cost ( int cost [ R ] [ C ] , int m , int n ) { int i , j ; int tc [ R ] [ C ] ; tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ; for ( i = 1 ; i <= m ; i ++ ) tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ; for ( j = 1 ; j <= n ; j ++ ) tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; for ( i = 1 ; i <= m ; i ++ ) for ( j = 1 ; j <= n ; j ++ ) tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ i - 1 ] [ j ] , tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; return tc [ m ] [ n ] ; } int min ( int x , int y , int z ) { if ( x < y ) return ( x < z ) ? x : z ; else return ( y < z ) ? y : z ; } int main ( ) { int cost [ R ] [ C ] = { { 1 , 2 , 3 } , { 4 , 8 , 2 } , { 1 , 5 , 3 } } ; cout << " ▁ " << min@@ Cost ( cost , 2 , 2 ) ; return 0 ; }
Matrix Chain Multiplic@@ ation | DP 1853 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int Matrix@@ Chain@@ Order ( int p [ ] , int n ) { int m [ n ] [ n ] ; int i , j , k , L , q ; for ( i = 1 ; i < n ; i ++ ) m [ i ] [ i ] = 0 ; for ( L = 2 ; L < n ; L ++ ) { for ( i = 1 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; m [ i ] [ j ] = INT_MAX ; for ( k = i ; k <= j - 1 ; k ++ ) { q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( q < m [ i ] [ j ] ) m [ i ] [ j ] = q ; } } } return m [ 1 ] [ n - 1 ] ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Minimum ▁ number ▁ of ▁ multiplic@@ ations ▁ is ▁ " << Matrix@@ Chain@@ Order ( arr , size ) ; get@@ char ( ) ; return 0 ; }
0 1861 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max ( int a , int b ) { return ( a > b ) ? a : b ; } int kn@@ ap@@ S@@ ack ( int W , int wt [ ] , int val [ ] , int n ) { if ( n == 0 W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return kn@@ ap@@ S@@ ack ( W , wt , val , n - 1 ) ; else return max ( val [ n - 1 ] + kn@@ ap@@ S@@ ack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , kn@@ ap@@ S@@ ack ( W , wt , val , n - 1 ) ) ; } int main ( ) { int val [ ] = { 60 , 100 , 120 } ; int wt [ ] = { 10 , 20 , 30 } ; int W = 50 ; int n = sizeof ( val ) / sizeof ( val [ 0 ] ) ; cout << kn@@ ap@@ S@@ ack ( W , wt , val , n ) ; return 0 ; }
0 1862 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max ( int a , int b ) { return ( a > b ) ? a : b ; } int kn@@ ap@@ S@@ ack ( int W , int wt [ ] , int val [ ] , int n ) { int i , w ; int K [ n + 1 ] [ W + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) { for ( w = 0 ; w <= W ; w ++ ) { if ( i == 0 w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } return K [ n ] [ W ] ; } int main ( ) { int val [ ] = { 60 , 100 , 120 } ; int wt [ ] = { 10 , 20 , 30 } ; int W = 50 ; int n = sizeof ( val ) / sizeof ( val [ 0 ] ) ; cout << kn@@ ap@@ S@@ ack ( W , wt , val , n ) ; return 0 ; }
Lon@@ gest Pal@@ ind@@ ro@@ mic Sub@@ sequence | DP 1867 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max ( int x , int y ) { return ( x > y ) ? x : y ; } int l@@ ps ( char * seq , int i , int j ) { if ( i == j ) return 1 ; if ( seq [ i ] == seq [ j ] && i + 1 == j ) return 2 ; if ( seq [ i ] == seq [ j ] ) return l@@ ps ( seq , i + 1 , j - 1 ) + 2 ; return max ( l@@ ps ( seq , i , j - 1 ) , l@@ ps ( seq , i + 1 , j ) ) ; } int main ( ) { char seq [ ] = " GE@@ EK@@ S@@ FOR@@ GE@@ E@@ KS " ; int n = strlen ( seq ) ; cout << " The ▁ length ▁ of ▁ the ▁ LP@@ S ▁ is ▁ " << l@@ ps ( seq , 0 , n - 1 ) ; return 0 ; }
Cu@@ tting a Ro@@ d | DP 1870 | #@@ include <@@ st@@ dio@@ .@@ h@@ > NEW_LINE #@@ include <@@ limit@@ s.@@ h@@ > NEW_LINE int max ( int a , int b ) { return ( a > b ) ? a : b ; } int cut@@ Ro@@ d ( int price [ ] , int n ) { int val [ n + 1 ] ; val [ 0 ] = 0 ; int i , j ; for ( i = 1 ; i <= n ; i ++ ) { int max_@@ val = INT_@@ MIN ; for ( j = 0 ; j < i ; j ++ ) max_@@ val = max ( max_@@ val , price [ j ] + val [ i - j - 1 ] ) ; val [ i ] = max_@@ val ; } return val [ n ] ; } int main ( ) { int arr [ ] = { 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( " Maximum ▁ Obtain@@ able ▁ Value ▁ is ▁ % dn " , cut@@ Ro@@ d ( arr , size ) ) ; get@@ char ( ) ; return 0 ; }
Count number of ways to reach a given score in a game 1944 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int count ( int n ) { int table [ n + 1 ] , i ; for ( int j = 0 ; j < n + 1 ; j ++ ) table [ j ] = 0 ; table [ 0 ] = 1 ; for ( i = 3 ; i <= n ; i ++ ) table [ i ] += table [ i - 3 ] ; for ( i = 5 ; i <= n ; i ++ ) table [ i ] += table [ i - 5 ] ; for ( i = 10 ; i <= n ; i ++ ) table [ i ] += table [ i - 10 ] ; return table [ n ] ; } int main ( void ) { int n = 20 ; cout << " Count ▁ for ▁ " << n << " ▁ is ▁ " << count ( n ) << endl ; n = 13 ; cout << " Count ▁ for ▁ " << n << " ▁ is ▁ " << count ( n ) << endl ; return 0 ; }
Nai@@ ve algorithm for Pattern Search@@ ing 1949 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void search ( char * pat , char * txt ) { int M = strlen ( pat ) ; int N = strlen ( txt ) ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; if ( j == M ) cout << " Pattern ▁ found ▁ at ▁ index ▁ " << i << endl ; } } int main ( ) { char txt [ ] = " AAB@@ AAC@@ A@@ AD@@ AAB@@ AA@@ AB@@ AA " ; char pat [ ] = " AAB@@ A " ; search ( pat , txt ) ; return 0 ; }
Rab@@ in 1954 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define d 256 NEW_LINE void search ( char pat [ ] , char txt [ ] , int q ) { int M = strlen ( pat ) ; int N = strlen ( txt ) ; int i , j ; int p = 0 ; int t = 0 ; int h = 1 ; for ( i = 0 ; i < M - 1 ; i ++ ) h = ( h * d ) % q ; for ( i = 0 ; i < M ; i ++ ) { p = ( d * p + pat [ i ] ) % q ; t = ( d * t + txt [ i ] ) % q ; } for ( i = 0 ; i <= N - M ; i ++ ) { if ( p == t ) { for ( j = 0 ; j < M ; j ++ ) { if ( txt [ i + j ] != pat [ j ] ) break ; } if ( j == M ) cout << " Pattern ▁ found ▁ at ▁ index ▁ " << i << endl ; } if ( i < N - M ) { t = ( d * ( t - txt [ i ] * h ) + txt [ i + M ] ) % q ; if ( t < 0 ) t = ( t + q ) ; } } } int main ( ) { char txt [ ] = " GE@@ E@@ KS ▁ FOR ▁ GE@@ E@@ KS " ; char pat [ ] = " GE@@ EK " ; int q = 101 ; search ( pat , txt , q ) ; return 0 ; }
Write a program to calculate pow ( x , n ) 1976 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; class g@@ fg { public : int power ( int x , unsigned int y ) { if ( y == 0 ) return 1 ; else if ( y % 2 == 0 ) return power ( x , y / 2 ) * power ( x , y / 2 ) ; else return x * power ( x , y / 2 ) * power ( x , y / 2 ) ; } } ; int main ( ) { g@@ fg g ; int x = 2 ; unsigned int y = 3 ; cout << g . power ( x , y ) ; return 0 ; }
Check whether a given point lies inside a triangle or not 1989 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; float area ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { return abs ( ( x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ) / 2.0 ) ; } bool isIn@@ side ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x , int y ) { float A = area ( x1 , y1 , x2 , y2 , x3 , y3 ) ; float A1 = area ( x , y , x2 , y2 , x3 , y3 ) ; float A2 = area ( x1 , y1 , x , y , x3 , y3 ) ; float A3 = area ( x1 , y1 , x2 , y2 , x , y ) ; return ( A == A1 + A2 + A3 ) ; } int main ( ) { if ( isIn@@ side ( 0 , 0 , 20 , 0 , 10 , 30 , 10 , 15 ) ) printf ( " Inside " ) ; else printf ( " Not ▁ Inside " ) ; return 0 ; }
Lu@@ ck@@ y Numbers 1994 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define bool int NEW_LINE bool is@@ Lu@@ ck@@ y ( int n ) { static int counter = 2 ; int next_@@ position = n ; if ( counter > n ) return 1 ; if ( n % counter == 0 ) return 0 ; next_@@ position -= next_@@ position / counter ; counter ++ ; return is@@ Lu@@ ck@@ y ( next_@@ position ) ; } int main ( ) { int x = 5 ; if ( is@@ Lu@@ ck@@ y ( x ) ) cout << x << " ▁ is ▁ a ▁ lu@@ ck@@ y ▁ no . " ; else cout << x << " ▁ is ▁ not ▁ a ▁ lu@@ ck@@ y ▁ no . " ; }
Lex@@ ico@@ graphic rank of a string 2018 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE #@@ include <@@ string@@ .@@ h@@ > NEW_LINE using namespace std ; int fact ( int n ) { return ( n <= 1 ) ? 1 : n * fact ( n - 1 ) ; } int find@@ Small@@ er@@ In@@ Right ( char * str , int low , int high ) { int count@@ Right = 0 , i ; for ( i = low + 1 ; i <= high ; ++ i ) if ( str [ i ] < str [ low ] ) ++ count@@ Right ; return count@@ Right ; } int find@@ Rank ( char * str ) { int len = strlen ( str ) ; int mul = fact ( len ) ; int rank = 1 ; int count@@ Right ; int i ; for ( i = 0 ; i < len ; ++ i ) { mul /= len - i ; count@@ Right = find@@ Small@@ er@@ In@@ Right ( str , i , len - 1 ) ; rank += count@@ Right * mul ; } return rank ; } int main ( ) { char str [ ] = " string " ; cout << find@@ Rank ( str ) ; return 0 ; }
Space and time efficient Bin@@ omial Coefficient 2022 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int bin@@ omi@@ al@@ Coeff ( int n , int k ) { int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } int main ( ) { int n = 8 , k = 2 ; cout << " Value ▁ of ▁ C ( " << n << " , ▁ " << k << " ) ▁ is ▁ " << bin@@ omi@@ al@@ Coeff ( n , k ) ; return 0 ; }
Pas@@ cal '@@ s Triangle 2025 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ Pas@@ cal ( int n ) { int arr [ n ] [ n ] ; for ( int line = 0 ; line < n ; line ++ ) { for ( int i = 0 ; i <= line ; i ++ ) { if ( line == i i == 0 ) arr [ line ] [ i ] = 1 ; else arr [ line ] [ i ] = arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] ; cout << arr [ line ] [ i ] << " ▁ " ; } cout << " STRNEWLINE " ; } } int main ( ) { int n = 5 ; print@@ Pas@@ cal ( n ) ; return 0 ; }
E@@ fficient program to calculate e ^ x 2028 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; float exponential ( int n , float x ) { float sum = 1.0f ; for ( int i = n - 1 ; i > 0 ; -- i ) sum = 1 + x * sum / i ; return sum ; } int main ( ) { int n = 10 ; float x = 1.0f ; cout << " e ^ x ▁ = ▁ " << fixed << setprecision ( 5 ) << exponential ( n , x ) ; return 0 ; }
E@@ fficient program to print all prime factors of a given number 2030 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void prime@@ Factors ( int n ) { while ( n % 2 == 0 ) { cout << 2 << " ▁ " ; n = n / 2 ; } for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { cout << i << " ▁ " ; n = n / i ; } } if ( n > 2 ) cout << n << " ▁ " ; } int main ( ) { int n = 3@@ 15 ; prime@@ Factors ( n ) ; return 0 ; }
Print all possible combinations of r elements in a given array of size n 2032 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void combin@@ ation@@ Util ( int arr [ ] , int n , int r , int index , int data [ ] , int i ) ; void print@@ Combination ( int arr [ ] , int n , int r ) { int data [ r ] ; combin@@ ation@@ Util ( arr , n , r , 0 , data , 0 ) ; } void combin@@ ation@@ Util ( int arr [ ] , int n , int r , int index , int data [ ] , int i ) { if ( index == r ) { for ( int j = 0 ; j < r ; j ++ ) cout << data [ j ] << " ▁ " ; cout << endl ; return ; } if ( i >= n ) return ; data [ index ] = arr [ i ] ; combin@@ ation@@ Util ( arr , n , r , index + 1 , data , i + 1 ) ; combin@@ ation@@ Util ( arr , n , r , index , data , i + 1 ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int r = 3 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; print@@ Combination ( arr , n , r ) ; return 0 ; }
Find the element that appears once 2065 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int get@@ Single ( int arr [ ] , int n ) { int ones = 0 , tw@@ os = 0 ; int common_@@ bit@@ _mask ; for ( int i = 0 ; i < n ; i ++ ) { tw@@ os = tw@@ os | ( ones & arr [ i ] ) ; ones = ones ^ arr [ i ] ; common_@@ bit@@ _mask = ~ ( ones & tw@@ os ) ; ones &= common_@@ bit@@ _mask ; tw@@ os &= common_@@ bit@@ _mask ; } return ones ; } int main ( ) { int arr [ ] = { 3 , 3 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " The ▁ element ▁ with ▁ single ▁ occurrence ▁ is ▁ " << get@@ Single ( arr , n ) ; return 0 ; }
Find the element that appears once 2066 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define INT_@@ SIZE 32 NEW_LINE int get@@ Single ( int arr [ ] , int n ) { int result = 0 ; int x , sum ; for ( int i = 0 ; i < INT_@@ SIZE ; i ++ ) { sum = 0 ; x = ( 1 << i ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] & x ) sum ++ ; } if ( ( sum % 3 ) != 0 ) result |= x ; } return result ; } int main ( ) { int arr [ ] = { 12 , 1 , 12 , 3 , 12 , 1 , 1 , 2 , 3 , 2 , 2 , 3 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " The ▁ element ▁ with ▁ single ▁ occurrence ▁ is ▁ " << get@@ Single ( arr , n ) ; return 0 ; }
Count total set bits in all numbers from 1 to n 2073 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Set@@ Bits ( int n ) { int i = 0 ; int ans = 0 ; while ( ( 1 << i ) <= n ) { bool k = 0 ; int change = 1 << i ; for ( int j = 0 ; j <= n ; j ++ ) { ans += k ; if ( change == 1 ) { k = ! k ; change = 1 << i ; } else { change -- ; } } i ++ ; } return ans ; } int main ( ) { int n = 17 ; cout << count@@ Set@@ Bits ( n ) << endl ; return 0 ; }
Add two numbers without using arithmetic operators 2079 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int Add ( int x , int y ) { while ( y != 0 ) { int carry = x & y ; x = x ^ y ; y = carry << 1 ; } return x ; } int main ( ) { cout << Add ( 15 , 32 ) ; return 0 ; }
S@@ malle@@ st of three integers without comparison operators 2081 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int smallest ( int x , int y , int z ) { int c = 0 ; while ( x && y && z ) { x -- ; y -- ; z -- ; c ++ ; } return c ; } int main ( ) { int x = 12 , y = 15 , z = 5 ; cout << " Minimum ▁ of ▁ 3 ▁ numbers ▁ is ▁ " << smallest ( x , y , z ) ; return 0 ; }
Add 1 to a given number 2090 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int add@@ One ( int x ) { int m = 1 ; while ( x & m ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; } int main ( ) { cout << add@@ One ( 13 ) ; return 0 ; }
Add 1 to a given number 2091 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int add@@ One ( int x ) { return ( - ( ~ x ) ) ; } int main ( ) { cout << add@@ One ( 13 ) ; return 0 ; }
Find whether a given number is a power of 4 or not 2096 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; #@@ define bool int NEW_LINE class GF@@ G { public : bool is@@ PowerOf@@ Four ( int n ) { if ( n == 0 ) return 0 ; while ( n != 1 ) { if ( n % 4 != 0 ) return 0 ; n = n / 4 ; } return 1 ; } } ; int main ( ) { GF@@ G g ; int test_@@ no = 64 ; if ( g . is@@ PowerOf@@ Four ( test_@@ no ) ) cout << test_@@ no << " ▁ is ▁ a ▁ power ▁ of ▁ 4" ; else cout << test_@@ no << " is ▁ not ▁ a ▁ power ▁ of ▁ 4" ; get@@ char ( ) ; }
Compute the minimum or maximum of two integers without branch@@ ing 2105 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int abs@@ bit@@ 32 ( int x , int y ) { int sub = x - y ; int mask = ( sub >> 31 ) ; return ( sub ^ mask ) - mask ; } int max ( int x , int y ) { int abs = abs@@ bit@@ 32 ( x , y ) ; return ( x + y + abs ) / 2 ; } int min ( int x , int y ) { int abs = abs@@ bit@@ 32 ( x , y ) ; return ( x + y - abs ) / 2 ; } int main ( ) { cout << max ( 2 , 3 ) << endl ; cout << max ( 2 , -@@ 3 ) << endl ; cout << max ( -2 , -@@ 3 ) << endl ; cout << min ( 2 , 3 ) << endl ; cout << min ( 2 , -@@ 3 ) << endl ; cout << min ( -2 , -@@ 3 ) << endl ; return 0 ; }
Count set bits in an integer 2114 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; unsigned int count@@ Set@@ Bits ( unsigned int n ) { unsigned int count = 0 ; while ( n ) { count += n & 1 ; n >>= 1 ; } return count ; } int main ( ) { int i = 9 ; cout << count@@ Set@@ Bits ( i ) ; return 0 ; }
Count set bits in an integer 2118 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int Bits@@ Set@@ Table@@ 256 [ 256 ] ; void initialize ( ) { Bits@@ Set@@ Table@@ 256 [ 0 ] = 0 ; for ( int i = 0 ; i < 256 ; i ++ ) { Bits@@ Set@@ Table@@ 256 [ i ] = ( i & 1 ) + Bits@@ Set@@ Table@@ 256 [ i / 2 ] ; } } int count@@ Set@@ Bits ( int n ) { return ( Bits@@ Set@@ Table@@ 256 [ n & 0xff ] + Bits@@ Set@@ Table@@ 256 [ ( n >> 8 ) & 0xff ] + Bits@@ Set@@ Table@@ 256 [ ( n >> 16 ) & 0xff ] + Bits@@ Set@@ Table@@ 256 [ n >> 24 ] ) ; } int main ( ) { initialize ( ) ; int n = 9 ; cout << count@@ Set@@ Bits ( n ) ; }
S@@ malle@@ st power of 2 greater than or equal to n 2123 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; unsigned int next@@ PowerOf@@ 2 ( unsigned int n ) { unsigned count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; } int main ( ) { unsigned int n = 0 ; cout << next@@ PowerOf@@ 2 ( n ) ; return 0 ; }
S@@ malle@@ st power of 2 greater than or equal to n 2124 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; unsigned int next@@ PowerOf@@ 2 ( unsigned int n ) { unsigned int p = 1 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( p < n ) p <<= 1 ; return p ; } int main ( ) { unsigned int n = 5 ; cout << next@@ PowerOf@@ 2 ( n ) ; return 0 ; }
Program to find parity 2127 | # include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE # define bool int NEW_LINE using namespace std ; bool get@@ Par@@ ity ( unsigned int n ) { bool parity = 0 ; while ( n ) { parity = ! parity ; n = n & ( n - 1 ) ; } return parity ; } int main ( ) { unsigned int n = 7 ; cout << " Par@@ ity ▁ of ▁ no ▁ " << n << " ▁ = ▁ " << ( get@@ Par@@ ity ( n ) ? " odd " : " even " ) ; get@@ char ( ) ; return 0 ; }
Program to find whether a no is power of two 2132 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define bool int NEW_LINE bool is@@ PowerOf@@ Two ( int x ) { return x && ( ! ( x & ( x - 1 ) ) ) ; } int main ( ) { is@@ PowerOf@@ Two ( 31 ) ? cout << " Yes STRNEWLINE " : cout << " No STRNEWLINE " ; is@@ PowerOf@@ Two ( 64 ) ? cout << " Yes STRNEWLINE " : cout << " No STRNEWLINE " ; return 0 ; }
Position of right@@ most set bit 2137 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int Position@@ Right@@ most@@ Set@@ bit ( int n ) { int p = 1 ; while ( n > 0 ) { if ( n & 1 ) { return p ; } p ++ ; n = n >> 1 ; } return -1 ; } int main ( ) { int n = 18 ; int pos = Position@@ Right@@ most@@ Set@@ bit ( n ) ; if ( pos != -1 ) cout << pos ; else cout << 0 ; return 0 ; }
Find position of the only set bit 2143 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int is@@ PowerOf@@ Two ( unsigned n ) { return n && ( ! ( n & ( n - 1 ) ) ) ; } int find@@ Position ( unsigned n ) { if ( ! is@@ PowerOf@@ Two ( n ) ) return -1 ; unsigned i = 1 , pos = 1 ; while ( ! ( i & n ) ) { i = i << 1 ; ++ pos ; } return pos ; } int main ( void ) { int n = 16 ; int pos = find@@ Position ( n ) ; ( pos == -1 ) ? cout << " n ▁ = ▁ " << n << " , ▁ Invalid ▁ number " << endl : cout << " n ▁ = ▁ " << n << " , ▁ Position ▁ " << pos << endl ; n = 12 ; pos = find@@ Position ( n ) ; ( pos == -1 ) ? cout << " n ▁ = ▁ " << n << " , ▁ Invalid ▁ number " << endl : cout << " n ▁ = ▁ " << n << " , ▁ Position ▁ " << pos << endl ; n = 128 ; pos = find@@ Position ( n ) ; ( pos == -1 ) ? cout << " n ▁ = ▁ " << n << " , ▁ Invalid ▁ number " << endl : cout << " n ▁ = ▁ " << n << " , ▁ Position ▁ " << pos << endl ; return 0 ; }
How to swap two numbers without using a temporary variable ? 2147 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int main ( ) { int x = 10 , y = 5 ; x = x * y ; y = x / y ; x = x / y ; cout << " After ▁ Sw@@ apping : ▁ x ▁ = " << x << " , ▁ y = " << y ; }
How to swap two numbers without using a temporary variable ? 2148 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int main ( ) { int x = 10 , y = 5 ; x = x ^ y ; y = x ^ y ; x = x ^ y ; cout << " After ▁ Sw@@ apping : ▁ x ▁ = " << x << " , ▁ y = " << y ; return 0 ; }
How to swap two numbers without using a temporary variable ? 2149 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void swap ( int * xp , int * yp ) { * xp = * xp ^ * yp ; * yp = * xp ^ * yp ; * xp = * xp ^ * yp ; } int main ( ) { int x = 10 ; swap ( & x , & x ) ; cout << " After ▁ swap ( & x , ▁ & x ) : ▁ x ▁ = ▁ " << x ; return 0 ; }
How to swap two numbers without using a temporary variable ? 2151 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void swap ( int & a , int & b ) { a = ( a & b ) + ( a b ) ; b = a + ( ~ b ) + 1 ; a = a + ( ~ b ) + 1 ; cout << " After ▁ sw@@ apping : ▁ a ▁ = ▁ " << a << " , ▁ b ▁ = ▁ " << b ; } int main ( ) { int a = 5 , b = 10 ; swap ( a , b ) ; return 0 ; }
Se@@ greg@@ ate 0 s and 1 s in an array 2168 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void se@@ greg@@ ate@@ 0@@ and@@ 1 ( int arr [ ] , int size ) { int left = 0 , right = size - 1 ; while ( left < right ) { while ( arr [ left ] == 0 && left < right ) left ++ ; while ( arr [ right ] == 1 && left < right ) right -- ; if ( left < right ) { arr [ left ] = 0 ; arr [ right ] = 1 ; left ++ ; right -- ; } } } int main ( ) { int arr [ ] = { 0 , 1 , 0 , 1 , 1 , 1 } ; int i , arr_@@ size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; se@@ greg@@ ate@@ 0@@ and@@ 1 ( arr , arr_@@ size ) ; cout << " Array ▁ after ▁ se@@ greg@@ ation ▁ " ; for ( i = 0 ; i < 6 ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
Given an array arr [ ] , find the maximum j 2195 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max@@ Index@@ Diff ( int arr [ ] , int n ) { int max@@ Diff = -1 ; int i , j ; for ( i = 0 ; i < n ; ++ i ) { for ( j = n - 1 ; j > i ; -- j ) { if ( arr [ j ] > arr [ i ] && max@@ Diff < ( j - i ) ) max@@ Diff = j - i ; } } return max@@ Diff ; } int main ( ) { int arr [ ] = { 9 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 18 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int max@@ Diff = max@@ Index@@ Diff ( arr , n ) ; cout << " STRNEWLINE " << max@@ Diff ; return 0 ; }
Given an array arr [ ] , find the maximum j 2196 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int main ( ) { vector < long long int > v { 34 , 8 , 10 , 3 , 2 , 80 , 30 , 33 , 1 } ; int n = v . size ( ) ; vector < long long int > max@@ From@@ End ( n + 1 , INT_@@ MIN ) ; for ( int i = v . size ( ) - 1 ; i >= 0 ; i -- ) { max@@ From@@ End [ i ] = max ( max@@ From@@ End [ i + 1 ] , v [ i ] ) ; } int result = 0 ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { int low = i + 1 , high = v . size ( ) - 1 , ans = i ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( v [ i ] <= max@@ From@@ End [ mid ] ) { ans = max ( ans , mid ) ; low = mid + 1 ; } else { high = mid - 1 ; } } result = max ( result , ans - i ) ; } cout << result << endl ; }
Find the maximum element in an array which is first increasing and then decre@@ asing 2199 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Maximum ( int arr [ ] , int low , int high ) { int max = arr [ low ] ; int i ; for ( i = low + 1 ; i <= high ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; else break ; } return max ; } int main ( ) { int arr [ ] = { 1 , 30 , 40 , 50 , 60 , 70 , 23 , 20 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " The ▁ maximum ▁ element ▁ is ▁ " << find@@ Maximum ( arr , 0 , n - 1 ) ; return 0 ; }
Range Query on array whose each element is XOR of index value and previous element 2226 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int fun ( int x ) { int y = ( x / 4 ) * 4 ; int ans = 0 ; for ( int i = y ; i <= x ; i ++ ) ans ^= i ; return ans ; } int query ( int x ) { if ( x == 0 ) return 0 ; int k = ( x + 1 ) / 2 ; return ( x %= 2 ) ? 2 * fun ( k ) : ( ( fun ( k - 1 ) * 2 ) ^ ( k & 1 ) ) ; } void all@@ Queries ( int q , int l [ ] , int r [ ] ) { for ( int i = 0 ; i < q ; i ++ ) cout << ( query ( r [ i ] ) ^ query ( l [ i ] - 1 ) ) << endl ; } int main ( ) { int q = 3 ; int l [ ] = { 2 , 2 , 5 } ; int r [ ] = { 4 , 8 , 9 } ; all@@ Queries ( q , l , r ) ; return 0 ; }
Probability of a random pair being the maximum weighted pair 2247 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; double probability ( int a [ ] , int b [ ] , int size1 , int size2 ) { int max@@ 1 = INT_@@ MIN , count@@ 1 = 0 ; for ( int i = 0 ; i < size1 ; i ++ ) { if ( a [ i ] > max@@ 1 ) { max@@ 1 = a [ i ] ; count@@ 1 = 1 ; } else if ( a [ i ] == max@@ 1 ) { count@@ 1 ++ ; } } int max@@ 2 = INT_@@ MIN , count2 = 0 ; for ( int i = 0 ; i < size2 ; i ++ ) { if ( b [ i ] > max@@ 2 ) { max@@ 2 = b [ i ] ; count2 = 1 ; } else if ( b [ i ] == max@@ 2 ) { count2 ++ ; } } return ( double ) ( count@@ 1 * count2 ) / ( size1 * size2 ) ; } int main ( ) { int a [ ] = { 1 , 2 , 3 } ; int b [ ] = { 1 , 3 , 3 } ; int size1 = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int size2 = sizeof ( b ) / sizeof ( b [ 0 ] ) ; cout << probability ( a , b , size1 , size2 ) ; return 0 ; }
Minimum adjacent sw@@ aps required to Sort Binary array 2259 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int min@@ sw@@ aps ( int arr [ ] , int n ) { int count = 0 ; int num_@@ un@@ place@@ d_@@ zeros = 0 ; for ( int index = n - 1 ; index >= 0 ; index -- ) { if ( arr [ index ] == 0 ) num_@@ un@@ place@@ d_@@ zeros += 1 ; else count += num_@@ un@@ place@@ d_@@ zeros ; } return count ; } int main ( ) { int arr [ ] = { 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 } ; cout << min@@ sw@@ aps ( arr , 9 ) ; return 0 ; }
Mer@@ ging two un@@ sorted arrays in sorted order 2273 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void sorted@@ Merge ( int a [ ] , int b [ ] , int res [ ] , int n , int m ) { sort ( a , a + n ) ; sort ( b , b + m ) ; int i = 0 , j = 0 , k = 0 ; while ( i < n && j < m ) { if ( a [ i ] <= b [ j ] ) { res [ k ] = a [ i ] ; i += 1 ; k += 1 ; } else { res [ k ] = b [ j ] ; j += 1 ; k += 1 ; } } while ( i < n ) { res [ k ] = a [ i ] ; i += 1 ; k += 1 ; } while ( j < m ) { res [ k ] = b [ j ] ; j += 1 ; k += 1 ; } } int main ( ) { int a [ ] = { 10 , 5 , 15 } ; int b [ ] = { 20 , 3 , 2 , 12 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int m = sizeof ( b ) / sizeof ( b [ 0 ] ) ; int res [ n + m ] ; sorted@@ Merge ( a , b , res , n , m ) ; cout << " Sorted ▁ merge ▁ list ▁ : " ; for ( int i = 0 ; i < n + m ; i ++ ) cout << " ▁ " << res [ i ] ; cout << " n " ; return 0 ; }
Find the element that appears once in an array where every other element appears twice 2286 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int single@@ element ( int arr [ ] , int n ) { int low = 0 , high = n - 2 ; int mid ; while ( low <= high ) { mid = ( low + high ) / 2 ; if ( arr [ mid ] == arr [ mid ^ 1 ] ) { low = mid + 1 ; } else { high = mid - 1 ; } } return arr [ low ] ; } int main ( ) { int arr [ ] = { 2 , 3 , 5 , 4 , 5 , 3 , 4 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sort ( arr , arr + size ) ; cout << single@@ element ( arr , size ) ; return 0 ; }
Find the Missing Number 2291 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int get@@ Missing@@ No ( int a [ ] , int n ) { int total = ( n + 1 ) * ( n + 2 ) / 2 ; for ( int i = 0 ; i < n ; i ++ ) total -= a [ i ] ; return total ; } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int miss = get@@ Missing@@ No ( arr , n ) ; cout << miss ; }
Find the Missing Number 2292 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int get@@ Missing@@ No ( int a [ ] , int n ) { int i , total = 1 ; for ( i = 2 ; i <= ( n + 1 ) ; i ++ ) { total += i ; total -= a [ i - 2 ] ; } return total ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 5 } ; cout << get@@ Missing@@ No ( arr , sizeof ( arr ) / sizeof ( arr [ 0 ] ) ) ; return 0 ; }
Find the Missing Number 2294 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int get@@ Missing@@ No ( int a [ ] , int n ) { int n_@@ element@@ s_@@ sum = n * ( n + 1 ) / 2 ; int sum = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) sum += a [ i ] ; return n_@@ element@@ s_@@ sum - sum ; } int main ( ) { int a [ ] = { 1 , 2 , 4 , 5 , 6 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) + 1 ; int miss = get@@ Missing@@ No ( a , n ) ; cout << ( miss ) ; return 0 ; }
Find four elements that sum to a given value | Set 1 ( n ^ 3 solution ) 2311 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ Four@@ Elements ( int A [ ] , int n , int X ) { for ( int i = 0 ; i < n - 3 ; i ++ ) { for ( int j = i + 1 ; j < n - 2 ; j ++ ) { for ( int k = j + 1 ; k < n - 1 ; k ++ ) { for ( int l = k + 1 ; l < n ; l ++ ) if ( A [ i ] + A [ j ] + A [ k ] + A [ l ] == X ) cout << A [ i ] << " , ▁ " << A [ j ] << " , ▁ " << A [ k ] << " , ▁ " << A [ l ] ; } } } } int main ( ) { int A [ ] = { 10 , 20 , 30 , 40 , 1 , 2 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int X = 91 ; find@@ Four@@ Elements ( A , n , X ) ; return 0 ; }
Find element in a sorted array whose frequency is greater than or equal to n / 2. 2322 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int find@@ Maj@@ ority ( int arr [ ] , int n ) { return arr [ n / 2 ] ; } int main ( ) { int arr [ ] = { 1 , 2 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << find@@ Maj@@ ority ( arr , n ) ; return 0 ; }
Least frequ@@ ent element in an array 2349 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int least@@ Frequ@@ ent ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int min_@@ count = n + 1 , res = -1 , curr_@@ count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) curr_@@ count ++ ; else { if ( curr_@@ count < min_@@ count ) { min_@@ count = curr_@@ count ; res = arr [ i - 1 ] ; } curr_@@ count = 1 ; } } if ( curr_@@ count < min_@@ count ) { min_@@ count = curr_@@ count ; res = arr [ n - 1 ] ; } return res ; } int main ( ) { int arr [ ] = { 1 , 3 , 2 , 1 , 2 , 2 , 3 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << least@@ Frequ@@ ent ( arr , n ) ; return 0 ; }
Find first k natural numbers missing in given array 2374 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ missing@@ k ( int arr [ ] , int n , int k ) { map < int , int > d ; for ( int i = 0 ; i < n ; i ++ ) d [ arr [ i ] ] = arr [ i ] ; int cnt = 1 ; int fl = 0 ; for ( int i = 0 ; i < ( n + k ) ; i ++ ) { if ( d . find ( cnt ) == d . end ( ) ) { fl += 1 ; cout << cnt << " ▁ " ; if ( fl == k ) break ; } cnt += 1 ; } } int main ( ) { int arr [ ] = { 1 , 4 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; ; print@@ missing@@ k ( arr , n , k ) ; }
Minimum product subset of an array 2381 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int min@@ Product@@ Subset ( int a [ ] , int n ) { if ( n == 1 ) return a [ 0 ] ; int max_@@ neg = INT_@@ MIN ; int min_@@ pos = INT_MAX ; int count_@@ neg = 0 , count_@@ zero = 0 ; int prod = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { count_@@ zero ++ ; continue ; } if ( a [ i ] < 0 ) { count_@@ neg ++ ; max_@@ neg = max ( max_@@ neg , a [ i ] ) ; } if ( a [ i ] > 0 ) min_@@ pos = min ( min_@@ pos , a [ i ] ) ; prod = prod * a [ i ] ; } if ( count_@@ zero == n || ( count_@@ neg == 0 && count_@@ zero > 0 ) ) return 0 ; if ( count_@@ neg == 0 ) return min_@@ pos ; if ( ! ( count_@@ neg & 1 ) && count_@@ neg != 0 ) { prod = prod / max_@@ neg ; } return prod ; } int main ( ) { int a [ ] = { -1 , -1 , -2 , 4 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << min@@ Product@@ Subset ( a , n ) ; return 0 ; }
Length of longest pal@@ ind@@ ro@@ me list in a linked list using O ( 1 ) extra space 2469 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; int count@@ Common ( Node * a , Node * b ) { int count = 0 ; for ( ; a && b ; a = a -> next , b = b -> next ) if ( a -> data == b -> data ) ++ count ; else break ; return count ; } int max@@ Pal@@ ind@@ ro@@ me ( Node * head ) { int result = 0 ; Node * prev = NULL , * curr = head ; while ( curr ) { Node * next = curr -> next ; curr -> next = prev ; result = max ( result , 2 * count@@ Common ( prev , next ) + 1 ) ; result = max ( result , 2 * count@@ Common ( curr , next ) ) ; prev = curr ; curr = next ; } return result ; } Node * newNode ( int key ) { Node * temp = new Node ; temp -> data = key ; temp -> next = NULL ; return temp ; } int main ( ) { Node * head = newNode ( 2 ) ; head -> next = newNode ( 4 ) ; head -> next -> next = newNode ( 3 ) ; head -> next -> next -> next = newNode ( 4 ) ; head -> next -> next -> next -> next = newNode ( 2 ) ; head -> next -> next -> next -> next -> next = newNode ( 15 ) ; cout << max@@ Pal@@ ind@@ ro@@ me ( head ) << endl ; return 0 ; }
Remove every k 2477 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; void free@@ List ( Node * node ) { while ( node != NULL ) { Node * next = node -> next ; delete ( node ) ; node = next ; } } Node * delete@@ K@@ th@@ Node ( struct Node * head , int k ) { if ( head == NULL ) return NULL ; if ( k == 1 ) { free@@ List ( head ) ; return NULL ; } struct Node * ptr = head , * prev = NULL ; int count = 0 ; while ( ptr != NULL ) { count ++ ; if ( k == count ) { delete ( prev -> next ) ; prev -> next = ptr -> next ; count = 0 ; } if ( count != 0 ) prev = ptr ; ptr = prev -> next ; } return head ; } void display@@ List ( struct Node * head ) { struct Node * temp = head ; while ( temp != NULL ) { cout << temp -> data << " ▁ " ; temp = temp -> next ; } } struct Node * newNode ( int x ) { Node * temp = new Node ; temp -> data = x ; temp -> next = NULL ; return temp ; } int main ( ) { struct Node * head = newNode ( 1 ) ; head -> next = newNode ( 2 ) ; head -> next -> next = newNode ( 3 ) ; head -> next -> next -> next = newNode ( 4 ) ; head -> next -> next -> next -> next = newNode ( 5 ) ; head -> next -> next -> next -> next -> next = newNode ( 6 ) ; head -> next -> next -> next -> next -> next -> next = newNode ( 7 ) ; head -> next -> next -> next -> next -> next -> next -> next = newNode ( 8 ) ; int k = 3 ; head = delete@@ K@@ th@@ Node ( head , k ) ; display@@ List ( head ) ; return 0 ; }
Find the sum of last n nodes of the given Linked List 2480 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; void push ( struct Node * * head_@@ ref , int new_data ) { struct Node * new_node = new Node ; new_node -> data = new_data ; new_node -> next = ( * head_@@ ref ) ; ( * head_@@ ref ) = new_node ; } void sum@@ Of@@ Last@@ N_@@ Nodes ( struct Node * head , int * n , int * sum ) { if ( ! head ) return ; sum@@ Of@@ Last@@ N_@@ Nodes ( head -> next , n , sum ) ; if ( * n > 0 ) { * sum = * sum + head -> data ; -- * n ; } } int sum@@ Of@@ Last@@ N_@@ Nodes@@ Util ( struct Node * head , int n ) { if ( n <= 0 ) return 0 ; int sum = 0 ; sum@@ Of@@ Last@@ N_@@ Nodes ( head , & n , & sum ) ; return sum ; } int main ( ) { struct Node * head = NULL ; push ( & head , 12 ) ; push ( & head , 4 ) ; push ( & head , 8 ) ; push ( & head , 6 ) ; push ( & head , 10 ) ; int n = 2 ; cout << " Sum ▁ of ▁ last ▁ " << n << " ▁ nodes ▁ = ▁ " << sum@@ Of@@ Last@@ N_@@ Nodes@@ Util ( head , n ) ; return 0 ; }
Check if a dou@@ bly linked list of characters is pal@@ ind@@ ro@@ me or not 2519 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; struct Node { char data ; struct Node * next ; struct Node * prev ; } ; void push ( struct Node * * head_@@ ref , char new_data ) { struct Node * new_node = new Node ; new_node -> data = new_data ; new_node -> next = ( * head_@@ ref ) ; new_node -> prev = NULL ; if ( ( * head_@@ ref ) != NULL ) ( * head_@@ ref ) -> prev = new_node ; ( * head_@@ ref ) = new_node ; } bool is@@ Pal@@ ind@@ ro@@ me ( struct Node * left ) { if ( left == NULL ) return true ; struct Node * right = left ; while ( right -> next != NULL ) right = right -> next ; while ( left != right ) { if ( left -> data != right -> data ) return false ; left = left -> next ; right = right -> prev ; } return true ; } int main ( ) { struct Node * head = NULL ; push ( & head , ' l ' ) ; push ( & head , ' e ' ) ; push ( & head , ' v ' ) ; push ( & head , ' e ' ) ; push ( & head , ' l ' ) ; if ( is@@ Pal@@ ind@@ ro@@ me ( head ) ) printf ( " It ▁ is ▁ Pal@@ ind@@ ro@@ me " ) ; else printf ( " Not ▁ Pal@@ ind@@ ro@@ me " ) ; return 0 ; }
Print all leaf nodes of a Binary Tree from left to right 2524 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; void print@@ Leaf@@ Nodes ( Node * root ) { if ( ! root ) return ; if ( ! root -> left && ! root -> right ) { cout << root -> data << " ▁ " ; return ; } if ( root -> left ) print@@ Leaf@@ Nodes ( root -> left ) ; if ( root -> right ) print@@ Leaf@@ Nodes ( root -> right ) ; } Node * newNode ( int data ) { Node * temp = new Node ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } int main ( ) { Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> right -> left = newNode ( 5 ) ; root -> right -> right = newNode ( 8 ) ; root -> right -> left -> left = newNode ( 6 ) ; root -> right -> left -> right = newNode ( 7 ) ; root -> right -> right -> left = newNode ( 9 ) ; root -> right -> right -> right = newNode ( 10 ) ; print@@ Leaf@@ Nodes ( root ) ; return 0 ; }
Print all nodes at distance k from a given node 2527 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; struct node { int data ; struct node * left , * right ; } ; void print@@ k@@ distance@@ Node@@ Down ( node * root , int k ) { if ( root == NULL k < 0 ) return ; if ( k == 0 ) { cout << root -> data << endl ; return ; } print@@ k@@ distance@@ Node@@ Down ( root -> left , k - 1 ) ; print@@ k@@ distance@@ Node@@ Down ( root -> right , k - 1 ) ; } int print@@ k@@ distance@@ Node ( node * root , node * target , int k ) { if ( root == NULL ) return -1 ; if ( root == target ) { print@@ k@@ distance@@ Node@@ Down ( root , k ) ; return 0 ; } int dl = print@@ k@@ distance@@ Node ( root -> left , target , k ) ; if ( dl != -1 ) { if ( dl + 1 == k ) cout << root -> data << endl ; else print@@ k@@ distance@@ Node@@ Down ( root -> right , k - dl - 2 ) ; return 1 + dl ; } int dr = print@@ k@@ distance@@ Node ( root -> right , target , k ) ; if ( dr != -1 ) { if ( dr + 1 == k ) cout << root -> data << endl ; else print@@ k@@ distance@@ Node@@ Down ( root -> left , k - dr - 2 ) ; return 1 + dr ; } return -1 ; } node * newnode ( int data ) { node * temp = new node ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } int main ( ) { node * root = newnode ( 20 ) ; root -> left = newnode ( 8 ) ; root -> right = newnode ( 22 ) ; root -> left -> left = newnode ( 4 ) ; root -> left -> right = newnode ( 12 ) ; root -> left -> right -> left = newnode ( 10 ) ; root -> left -> right -> right = newnode ( 14 ) ; node * target = root -> left -> right ; print@@ k@@ distance@@ Node ( root , target , 2 ) ; return 0 ; }
Maxim@@ ize sum of diagonal of a matrix by rot@@ ating all rows or all columns 2558 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define N 3 NEW_LINE int find@@ Maximum@@ Diag@@ onal@@ Sum@@ O@@ Matrix@@ f ( int A [ ] [ N ] ) { int max@@ Diag@@ onal@@ Sum = INT_@@ MIN ; for ( int i = 0 ; i < N ; i ++ ) { int curr = 0 ; for ( int j = 0 ; j < N ; j ++ ) { curr += A [ j ] [ ( i + j ) % N ] ; } max@@ Diag@@ onal@@ Sum = max ( max@@ Diag@@ onal@@ Sum , curr ) ; } for ( int i = 0 ; i < N ; i ++ ) { int curr = 0 ; for ( int j = 0 ; j < N ; j ++ ) { curr += A [ ( i + j ) % N ] [ j ] ; } max@@ Diag@@ onal@@ Sum = max ( max@@ Diag@@ onal@@ Sum , curr ) ; } return max@@ Diag@@ onal@@ Sum ; } int main ( ) { int mat [ N ] [ N ] = { { 1 , 1 , 2 } , { 2 , 1 , 2 } , { 1 , 2 , 2 } } ; cout << find@@ Maximum@@ Diag@@ onal@@ Sum@@ O@@ Matrix@@ f ( mat ) ; return 0 ; }
Rotate all odd numbers right and all even numbers left in an Array of 1 to N 2573 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void left_@@ rotate ( int arr [ ] ) { int last = arr [ 1 ] ; for ( int i = 3 ; i < 6 ; i = i + 2 ) { arr [ i - 2 ] = arr [ i ] ; } arr [ 6 - 1 ] = last ; } void right_@@ rotate ( int arr [ ] ) { int start = arr [ 6 - 2 ] ; for ( int i = 6 - 4 ; i >= 0 ; i = i - 2 ) { arr [ i + 2 ] = arr [ i ] ; } arr [ 0 ] = start ; } void rotate ( int arr [ ] ) { left_@@ rotate ( arr ) ; right_@@ rotate ( arr ) ; for ( int i = 0 ; i < 6 ; i ++ ) { cout << ( arr [ i ] ) << " ▁ " ; } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; rotate ( arr ) ; }
Count of rot@@ ations required to generate a sorted array 2577 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Rotation ( int arr [ ] , int low , int high ) { if ( low > high ) { return 0 ; } int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid ] > arr [ mid + 1 ] ) { return mid + 1 ; } if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) { return mid ; } if ( arr [ mid ] > arr [ low ] ) { return count@@ Rotation ( arr , mid + 1 , high ) ; } if ( arr [ mid ] < arr [ high ] ) { return count@@ Rotation ( arr , low , mid - 1 ) ; } else { int right@@ Index = count@@ Rotation ( arr , mid + 1 , high ) ; int left@@ Index = count@@ Rotation ( arr , low , mid - 1 ) ; if ( right@@ Index == 0 ) { return left@@ Index ; } return right@@ Index ; } } int main ( ) { int ar@@ r1 [ ] = { 4 , 5 , 1 , 2 , 3 } ; int N = sizeof ( ar@@ r1 ) / sizeof ( ar@@ r1 [ 0 ] ) ; cout << count@@ Rotation ( ar@@ r1 , 0 , N - 1 ) ; return 0 ; }
Find array sum using Bit@@ wise OR after splitting given array in two hal@@ ves after K circular shifts 2578 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE const int MAX = 10000@@ 5 ; using namespace std ; int seg [ 4 * MAX ] ; void build ( int node , int l , int r , int a [ ] ) { if ( l == r ) seg [ node ] = a [ l ] ; else { int mid = ( l + r ) / 2 ; build ( 2 * node , l , mid , a ) ; build ( 2 * node + 1 , mid + 1 , r , a ) ; seg [ node ] = ( seg [ 2 * node ] seg [ 2 * node + 1 ] ) ; } } int query ( int node , int l , int r , int start , int end , int a [ ] ) { if ( l > end or r < start ) return 0 ; if ( start <= l and r <= end ) return seg [ node ] ; int mid = ( l + r ) / 2 ; return ( ( query ( 2 * node , l , mid , start , end , a ) ) | ( query ( 2 * node + 1 , mid + 1 , r , start , end , a ) ) ) ; } void or@@ sum ( int a [ ] , int n , int q , int k [ ] ) { build ( 1 , 0 , n - 1 , a ) ; for ( int j = 0 ; j < q ; j ++ ) { int i = k [ j ] % ( n / 2 ) ; int sec = query ( 1 , 0 , n - 1 , n / 2 - i , n - i - 1 , a ) ; int first = ( query ( 1 , 0 , n - 1 , 0 , n / 2 - 1 - i , a ) | query ( 1 , 0 , n - 1 , n - i , n - 1 , a ) ) ; int temp = sec + first ; cout << temp << endl ; } } int main ( ) { int a [ ] = { 7 , 44 , 19 , 86 , 65 , 39 , 75 , 101 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int q = 2 ; int k [ q ] = { 4 , 2 } ; or@@ sum ( a , n , q , k ) ; return 0 ; }
Maxim@@ ize count of corresponding same elements in given Arrays by Rotation 2579 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void maximum@@ Equal ( int a [ ] , int b [ ] , int n ) { vector < int > store ( 1e@@ 5 ) ; for ( int i = 0 ; i < n ; i ++ ) { store [ b [ i ] ] = i + 1 ; } vector < int > ans ( 1e@@ 5 ) ; for ( int i = 0 ; i < n ; i ++ ) { int d = abs ( store [ a [ i ] ] - ( i + 1 ) ) ; if ( store [ a [ i ] ] < i + 1 ) { d = n - d ; } ans [ d ] ++ ; } int final@@ ans = 0 ; for ( int i = 0 ; i < 1e@@ 5 ; i ++ ) final@@ ans = max ( final@@ ans , ans [ i ] ) ; cout << final@@ ans << " STRNEWLINE " ; } int main ( ) { int A [ ] = { 6 , 7 , 3 , 9 , 5 } ; int B [ ] = { 7 , 3 , 9 , 5 , 6 } ; int size = sizeof ( A ) / sizeof ( A [ 0 ] ) ; maximum@@ Equal ( A , B , size ) ; return 0 ; }
Count rot@@ ations which are di@@ visible by 10 2584 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Rotation ( int n ) { int count = 0 ; do { int digit = n % 10 ; if ( digit == 0 ) count ++ ; n = n / 10 ; } while ( n != 0 ) ; return count ; } int main ( ) { int n = 10@@ 203 ; cout << count@@ Rotation ( n ) ; }
Check if it is possible to make array increasing or decre@@ asing by rot@@ ating the array 2586 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Possible ( int a [ ] , int n ) { if ( n <= 2 ) return true ; int flag = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( ! ( a [ i ] > a [ i + 1 ] and a [ i + 1 ] > a [ i + 2 ] ) ) { flag = 1 ; break ; } } if ( flag == 0 ) return true ; flag = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( ! ( a [ i ] < a [ i + 1 ] and a [ i + 1 ] < a [ i + 2 ] ) ) { flag = 1 ; break ; } } if ( flag == 0 ) return true ; int val1 = INT_MAX , mini = -1 , val2 = INT_@@ MIN , max@@ i ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] < val1 ) { mini = i ; val1 = a [ i ] ; } if ( a [ i ] > val2 ) { max@@ i = i ; val2 = a [ i ] ; } } flag = 1 ; for ( int i = 0 ; i < max@@ i ; i ++ ) { if ( a [ i ] > a [ i + 1 ] ) { flag = 0 ; break ; } } if ( flag == 1 and max@@ i + 1 == mini ) { flag = 1 ; for ( int i = mini ; i < n - 1 ; i ++ ) { if ( a [ i ] > a [ i + 1 ] ) { flag = 0 ; break ; } } if ( flag == 1 ) return true ; } flag = 1 ; for ( int i = 0 ; i < mini ; i ++ ) { if ( a [ i ] < a [ i + 1 ] ) { flag = 0 ; break ; } } if ( flag == 1 and max@@ i - 1 == mini ) { flag = 1 ; for ( int i = max@@ i ; i < n - 1 ; i ++ ) { if ( a [ i ] < a [ i + 1 ] ) { flag = 0 ; break ; } } if ( flag == 1 ) return true ; } return false ; } int main ( ) { int a [ ] = { 4 , 5 , 6 , 2 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; if ( is@@ Possible ( a , n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
Generate all rot@@ ations of a number 2594 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int numberOf@@ Digits ( int n ) { int cnt = 0 ; while ( n > 0 ) { cnt ++ ; n /= 10 ; } return cnt ; } void cal ( int num ) { int digits = numberOf@@ Digits ( num ) ; int pow@@ Te@@ n = pow ( 10 , digits - 1 ) ; for ( int i = 0 ; i < digits - 1 ; i ++ ) { int first@@ Digit = num / pow@@ Te@@ n ; int left = ( ( num * 10 ) + first@@ Digit ) - ( first@@ Digit * pow@@ Te@@ n * 10 ) ; cout << left << " ▁ " ; num = left ; } } int main ( ) { int num = 14@@ 45 ; cal ( num ) ; return 0 ; }
Check whether all the rot@@ ations of a given number is greater than or equal to the given number or not 2596 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void Check@@ K@@ Cycles ( int n , string s ) { bool ff = true ; int x = 0 ; for ( int i = 1 ; i < n ; i ++ ) { x = ( s . substr ( i ) + s . substr ( 0 , i ) ) . length ( ) ; if ( x >= s . length ( ) ) { continue ; } ff = false ; break ; } if ( ff ) { cout << ( " Yes " ) ; } else { cout << ( " No " ) ; } } int main ( ) { int n = 3 ; string s = "123" ; Check@@ K@@ Cycles ( n , s ) ; return 0 ; }
Generating numbers that are divisor of their right 2600 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void generate@@ Numbers ( int m ) { vector < int > numbers ; int k_@@ max , x ; for ( int y = 0 ; y < 10 ; y ++ ) { k_@@ max = ( int ) ( pow ( 10 , m - 2 ) * ( 10 * y + 1 ) ) / ( int ) ( pow ( 10 , m - 1 ) + y ) ; for ( int k = 1 ; k <= k_@@ max ; k ++ ) { x = ( int ) ( y * ( pow ( 10 , m - 1 ) - k ) ) / ( 10 * k - 1 ) ; if ( ( int ) ( y * ( pow ( 10 , m - 1 ) - k ) ) % ( 10 * k - 1 ) == 0 ) numbers . push_back ( 10 * x + y ) ; } } sort ( numbers . begin ( ) , numbers . end ( ) ) ; for ( int i = 0 ; i < numbers . size ( ) ; i ++ ) cout << ( numbers [ i ] ) << endl ; } int main ( ) { int m = 3 ; generate@@ Numbers ( m ) ; }
Rotate a matrix by 90 degree in clockwise direction without using any extra space 2604 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define N 4 NEW_LINE void rotate@@ 90@@ Clock@@ wise ( int arr [ N ] [ N ] ) { for ( int j = 0 ; j < N ; j ++ ) { for ( int i = N - 1 ; i >= 0 ; i -- ) cout << arr [ i ] [ j ] << " ▁ " ; cout << ' ' ; } } int main ( ) { int arr [ N ] [ N ] = { { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } , { 9 , 10 , 11 , 12 } , { 13 , 14 , 15 , 16 } } ; rotate@@ 90@@ Clock@@ wise ( arr ) ; return 0 ; }
Sort a Rot@@ ated Sorted Array 2616 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Start@@ Index@@ Of@@ Array ( int arr [ ] , int low , int high ) { if ( low > high ) { return -1 ; } if ( low == high ) { return low ; } int mid = low + ( high - low ) / 2 ; if ( arr [ mid ] > arr [ mid + 1 ] ) return mid + 1 ; if ( arr [ mid - 1 ] > arr [ mid ] ) return mid ; if ( arr [ low ] > arr [ mid ] ) return find@@ Start@@ Index@@ Of@@ Array ( arr , low , mid - 1 ) ; else return find@@ Start@@ Index@@ Of@@ Array ( arr , mid + 1 , high ) ; } void restore@@ Sorted@@ Array ( int arr [ ] , int n ) { if ( arr [ 0 ] < arr [ n - 1 ] ) return ; int start = find@@ Start@@ Index@@ Of@@ Array ( arr , 0 , n - 1 ) ; reverse ( arr , arr + start ) ; reverse ( arr + start , arr + n ) ; reverse ( arr , arr + n ) ; } void print@@ Array ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) cout << arr [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; restore@@ Sorted@@ Array ( arr , n ) ; print@@ Array ( arr , n ) ; return 0 ; }
Types of Linked List 2641 | class Node { public : int data ; Node * next ; } ;
Remove all even parity nodes from a Dou@@ bly and Cir@@ cul@@ ar Sing@@ ly Linked List 2652 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; void push ( struct Node * * head_@@ ref , int data ) { struct Node * ptr@@ 1 = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; struct Node * temp = * head_@@ ref ; ptr@@ 1 -> data = data ; ptr@@ 1 -> next = * head_@@ ref ; if ( * head_@@ ref != NULL ) { while ( temp -> next != * head_@@ ref ) temp = temp -> next ; temp -> next = ptr@@ 1 ; } else ptr@@ 1 -> next = ptr@@ 1 ; * head_@@ ref = ptr@@ 1 ; } void delete@@ Node ( Node * & head_@@ ref , Node * del ) { if ( head_@@ ref == del ) head_@@ ref = del -> next ; struct Node * temp = head_@@ ref ; while ( temp -> next != del ) { temp = temp -> next ; } temp -> next = del -> next ; free ( del ) ; return ; } bool is@@ Even@@ Par@@ ity ( int x ) { int parity = 0 ; while ( x != 0 ) { if ( x & 1 ) parity ++ ; x = x >> 1 ; } if ( parity % 2 == 0 ) return true ; else return false ; } void delete@@ Even@@ Par@@ ity@@ Nodes ( Node * & head ) { if ( head == NULL ) return ; if ( head == head -> next ) { if ( is@@ Even@@ Par@@ ity ( head -> data ) ) head = NULL ; return ; } struct Node * ptr = head ; struct Node * next ; do { next = ptr -> next ; if ( is@@ Even@@ Par@@ ity ( ptr -> data ) ) delete@@ Node ( head , ptr ) ; ptr = next ; } while ( ptr != head ) ; if ( head == head -> next ) { if ( is@@ Even@@ Par@@ ity ( head -> data ) ) head = NULL ; return ; } } void print@@ List ( struct Node * head ) { if ( head == NULL ) { cout << " Empty ▁ List STRNEWLINE " ; return ; } struct Node * temp = head ; if ( head != NULL ) { do { printf ( " % d ▁ " , temp -> data ) ; temp = temp -> next ; } while ( temp != head ) ; } } int main ( ) { struct Node * head = NULL ; push ( & head , 21 ) ; push ( & head , 13 ) ; push ( & head , 6 ) ; push ( & head , 34 ) ; push ( & head , 9 ) ; push ( & head , 11 ) ; delete@@ Even@@ Par@@ ity@@ Nodes ( head ) ; print@@ List ( head ) ; return 0 ; }
Remove all the Even Digit Sum Nodes from a Cir@@ cul@@ ar Sing@@ ly Linked List 2653 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; void push ( struct Node * * head_@@ ref , int data ) { struct Node * ptr@@ 1 = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; struct Node * temp = * head_@@ ref ; ptr@@ 1 -> data = data ; ptr@@ 1 -> next = * head_@@ ref ; if ( * head_@@ ref != NULL ) { while ( temp -> next != * head_@@ ref ) temp = temp -> next ; temp -> next = ptr@@ 1 ; } else ptr@@ 1 -> next = ptr@@ 1 ; * head_@@ ref = ptr@@ 1 ; } void delete@@ Node ( Node * head_@@ ref , Node * del ) { struct Node * temp = head_@@ ref ; if ( head_@@ ref == del ) head_@@ ref = del -> next ; while ( temp -> next != del ) { temp = temp -> next ; } temp -> next = del -> next ; free ( del ) ; return ; } int digit@@ Sum ( int num ) { int sum = 0 ; while ( num ) { sum += ( num % 10 ) ; num /= 10 ; } return sum ; } void delete@@ Even@@ Digit@@ Sum@@ Nodes ( Node * head ) { struct Node * ptr = head ; struct Node * next ; do { if ( ! ( digit@@ Sum ( ptr -> data ) & 1 ) ) delete@@ Node ( head , ptr ) ; next = ptr -> next ; ptr = next ; } while ( ptr != head ) ; } void print@@ List ( struct Node * head ) { struct Node * temp = head ; if ( head != NULL ) { do { printf ( " % d ▁ " , temp -> data ) ; temp = temp -> next ; } while ( temp != head ) ; } } int main ( ) { struct Node * head = NULL ; push ( & head , 21 ) ; push ( & head , 13 ) ; push ( & head , 6 ) ; push ( & head , 34 ) ; push ( & head , 11 ) ; push ( & head , 9 ) ; delete@@ Even@@ Digit@@ Sum@@ Nodes ( head ) ; print@@ List ( head ) ; return 0 ; }
Search an Element in Dou@@ bly Cir@@ cul@@ ar Linked List 2673 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; struct Node * prev ; } ; void insert@@ Node ( struct Node * * start , int value ) { if ( * start == NULL ) { struct Node * new_node = new Node ; new_node -> data = value ; new_node -> next = new_node -> prev = new_node ; * start = new_node ; return ; } Node * last = ( * start ) -> prev ; struct Node * new_node = new Node ; new_node -> data = value ; new_node -> next = * start ; ( * start ) -> prev = new_node ; new_node -> prev = last ; last -> next = new_node ; } void display@@ List ( struct Node * start ) { struct Node * temp = start ; while ( temp -> next != start ) { printf ( " % d ▁ " , temp -> data ) ; temp = temp -> next ; } printf ( " % d ▁ " , temp -> data ) ; } int search@@ List ( struct Node * start , int search ) { struct Node * temp = start ; int count = 0 , flag = 0 , value ; if ( temp == NULL ) return -1 ; else { while ( temp -> next != start ) { count ++ ; if ( temp -> data == search ) { flag = 1 ; count -- ; break ; } temp = temp -> next ; } if ( temp -> data == search ) { count ++ ; flag = 1 ; } if ( flag == 1 ) cout << " STRNEWLINE " << search << " ▁ found ▁ at ▁ location ▁ " << count << endl ; else cout << " STRNEWLINE " << search << " ▁ not ▁ found " << endl ; } } int main ( ) { struct Node * start = NULL ; insert@@ Node ( & start , 4 ) ; insert@@ Node ( & start , 5 ) ; insert@@ Node ( & start , 7 ) ; insert@@ Node ( & start , 8 ) ; insert@@ Node ( & start , 6 ) ; printf ( " Created ▁ circular ▁ dou@@ bly ▁ linked ▁ list ▁ is : ▁ " ) ; display@@ List ( start ) ; search@@ List ( start , 5 ) ; return 0 ; }
Count of all prime weight nodes between given nodes in the given Tree 2682 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define MAX 1000 NEW_LINE int weight [ MAX ] ; int level [ MAX ] ; int par [ MAX ] ; bool prime [ MAX + 1 ] ; vector < int > graph [ MAX ] ; void Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( ) { memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= MAX ; i += p ) prime [ i ] = false ; } } } void dfs ( int node , int parent , int h ) { par [ node ] = parent ; level [ node ] = h ; for ( int child : graph [ node ] ) { if ( child == parent ) continue ; dfs ( child , node , h + 1 ) ; } } int find@@ Prime@@ On@@ Path ( int u , int v ) { int count = 0 ; if ( level [ u ] > level [ v ] ) swap ( u , v ) ; int d = level [ v ] - level [ u ] ; while ( d -- ) { if ( prime [ weight [ v ] ] ) count ++ ; v = par [ v ] ; } if ( v == u ) { if ( prime [ weight [ v ] ] ) count ++ ; return count ; } while ( v != u ) { if ( prime [ weight [ v ] ] ) count ++ ; if ( prime [ weight [ u ] ] ) count ++ ; u = par [ u ] ; v = par [ v ] ; } if ( prime [ weight [ v ] ] ) count ++ ; return count ; } int main ( ) { Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( ) ; weight [ 1 ] = 5 ; weight [ 2 ] = 10 ; weight [ 3 ] = 11 ; weight [ 4 ] = 8 ; weight [ 5 ] = 6 ; graph [ 1 ] . push_back ( 2 ) ; graph [ 2 ] . push_back ( 3 ) ; graph [ 2 ] . push_back ( 4 ) ; graph [ 1 ] . push_back ( 5 ) ; dfs ( 1 , -1 , 0 ) ; int u = 3 , v = 5 ; cout << find@@ Prime@@ On@@ Path ( u , v ) << endl ; return 0 ; }
Minimum and maximum node that lies in the path connecting two nodes in a Binary Tree 2689 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; struct Node { Node * left ; Node * right ; int data ; } ; Node * newNode ( int key ) { Node * node = new Node ( ) ; node -> left = node -> right = NULL ; node -> data = key ; return node ; } bool Find@@ Path ( Node * root , vector < int > & path , int key ) { if ( root == NULL ) return false ; path . push_back ( root -> data ) ; if ( root -> data == key ) return true ; if ( Find@@ Path ( root -> left , path , key ) || Find@@ Path ( root -> right , path , key ) ) return true ; path . pop_back ( ) ; return false ; } int min@@ Max@@ Node@@ In@@ Path ( Node * root , int a , int b ) { vector < int > Path@@ 1 ; vector < int > Path@@ 2 ; int min@@ 1 = INT_MAX ; int max@@ 1 = INT_@@ MIN ; int min@@ 2 = INT_MAX ; int max@@ 2 = INT_@@ MIN ; int i = 0 ; int j = 0 ; if ( Find@@ Path ( root , Path@@ 1 , a ) && Find@@ Path ( root , Path@@ 2 , b ) ) { for ( i = 0 ; i < Path@@ 1 . size ( ) && Path@@ 2 . size ( ) ; i ++ ) if ( Path@@ 1 [ i ] != Path@@ 2 [ i ] ) break ; i -- ; j = i ; for ( ; i < Path@@ 1 . size ( ) ; i ++ ) { if ( min@@ 1 > Path@@ 1 [ i ] ) min@@ 1 = Path@@ 1 [ i ] ; if ( max@@ 1 < Path@@ 1 [ i ] ) max@@ 1 = Path@@ 1 [ i ] ; } for ( ; j < Path@@ 2 . size ( ) ; j ++ ) { if ( min@@ 2 > Path@@ 2 [ j ] ) min@@ 2 = Path@@ 2 [ j ] ; if ( max@@ 2 < Path@@ 2 [ j ] ) max@@ 2 = Path@@ 2 [ j ] ; } cout << " Min ▁ = ▁ " << min ( min@@ 1 , min@@ 2 ) << endl ; cout << " Max ▁ = ▁ " << max ( max@@ 1 , max@@ 2 ) ; } else cout << " Max = -1 " ; } int main ( ) { Node * root = newNode ( 20 ) ; root -> left = newNode ( 8 ) ; root -> right = newNode ( 22 ) ; root -> left -> left = newNode ( 5 ) ; root -> left -> right = newNode ( 3 ) ; root -> right -> left = newNode ( 4 ) ; root -> right -> right = newNode ( 25 ) ; root -> left -> right -> left = newNode ( 10 ) ; root -> left -> right -> right = newNode ( 14 ) ; int a = 5 ; int b = 14@@ 54 ; min@@ Max@@ Node@@ In@@ Path ( root , a , b ) ; return 0 ; }
L@@ CA for general or n 2698 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define MAX@@ N 10000@@ 1 NEW_LINE vector < int > tree [ MAX@@ N ] ; int path [ 3 ] [ MAX@@ N ] ; void dfs ( int cur , int prev , int path@@ Number , int ptr , int node , bool & flag ) { for ( int i = 0 ; i < tree [ cur ] . size ( ) ; i ++ ) { if ( tree [ cur ] [ i ] != prev and ! flag ) { path [ path@@ Number ] [ ptr ] = tree [ cur ] [ i ] ; if ( tree [ cur ] [ i ] == node ) { flag = true ; path [ path@@ Number ] [ ptr + 1 ] = -1 ; return ; } dfs ( tree [ cur ] [ i ] , cur , path@@ Number , ptr + 1 , node , flag ) ; } } } int L@@ CA ( int a , int b ) { if ( a == b ) return a ; path [ 1 ] [ 0 ] = path [ 2 ] [ 0 ] = 1 ; bool flag = false ; dfs ( 1 , 0 , 1 , 1 , a , flag ) ; flag = false ; dfs ( 1 , 0 , 2 , 1 , b , flag ) ; int i = 0 ; while ( path [ 1 ] [ i ] == path [ 2 ] [ i ] ) i ++ ; return path [ 1 ] [ i - 1 ] ; } void addEdge ( int a , int b ) { tree [ a ] . push_back ( b ) ; tree [ b ] . push_back ( a ) ; } int main ( ) { int n = 8 ; addEdge ( 1 , 2 ) ; addEdge ( 1 , 3 ) ; addEdge ( 2 , 4 ) ; addEdge ( 2 , 5 ) ; addEdge ( 2 , 6 ) ; addEdge ( 3 , 7 ) ; addEdge ( 3 , 8 ) ; cout << " L@@ CA ( 4 , ▁ 7 ) ▁ = ▁ " << L@@ CA ( 4 , 7 ) << endl ; cout << " L@@ CA ( 4 , ▁ 6 ) ▁ = ▁ " << L@@ CA ( 4 , 6 ) << endl ; return 0 ; }
Check if a large number is di@@ visible by a number which is a power of 2 2719 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool check@@ If@@ Di@@ visible ( string str , long long int num ) { long long int power@@ Of@@ 2 = log2 ( num ) ; if ( str . length ( ) < power@@ Of@@ 2 ) return false ; if ( power@@ Of@@ 2 == 0 ) return true ; long long int i , number = 0 ; int len = str . length ( ) ; for ( i = len - power@@ Of@@ 2 ; i < len ; i ++ ) { number += ( str [ i ] - '0' ) * pow ( 10 , power@@ Of@@ 2 - 1 ) ; power@@ Of@@ 2 -- ; } if ( number % num ) return false ; else return true ; } int main ( ) { string str = "@@ 213@@ 467@@ 75@@ 65@@ 64" ; long long int num = 4 ; if ( check@@ If@@ Di@@ visible ( str , num ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
Maximum length of sub@@ array such that all elements are equal in the sub@@ array 2731 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int lon@@ gest_@@ sub@@ array ( int arr [ ] , int d ) { int i = 0 , j = 1 , e = 0 ; for ( i = 0 ; i < d - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { j = j + 1 ; } else { j = 1 ; } if ( e < j ) { e = j ; } } return e ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << lon@@ gest_@@ sub@@ array ( arr , N ) ; }
Nodes with prime degree in an un@@ directed Graph 2762 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int n = 100@@ 05 ; vector < bool > Prime ( n + 1 , true ) ; void Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( ) { int i , j ; Prime [ 0 ] = Prime [ 1 ] = false ; for ( i = 2 ; i * i <= 100@@ 05 ; i ++ ) { if ( Prime [ i ] ) { for ( j = 2 * i ; j < 100@@ 05 ; j += i ) { Prime [ j ] = false ; } } } } void prime@@ Degree@@ Nodes ( int N , int M , int edges [ ] [ 2 ] ) { vector < int > Ad@@ j [ N + 1 ] ; for ( int i = 0 ; i < M ; i ++ ) { int x = edges [ i ] [ 0 ] ; int y = edges [ i ] [ 1 ] ; Ad@@ j [ x ] . push_back ( y ) ; Ad@@ j [ y ] . push_back ( x ) ; } Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( ) ; for ( int i = 1 ; i <= N ; i ++ ) { int x = Ad@@ j [ i ] . size ( ) ; if ( Prime [ x ] ) cout << i << ' ▁ ' ; } } int main ( ) { int N = 4 , M = 6 ; int edges [ M ] [ 2 ] = { { 1 , 2 } , { 1 , 3 } , { 1 , 4 } , { 2 , 3 } , { 2 , 4 } , { 3 , 4 } } ; prime@@ Degree@@ Nodes ( N , M , edges ) ; return 0 ; }
Number of ways to color N 2765 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; const int mod = 100000000@@ 7 ; int count@@ W@@ ays ( int colored [ ] , int count , int n ) { if ( count == n ) { return 1 ; } int answer = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { if ( colored [ i ] == 0 ) { if ( colored [ i - 1 ] == 1 colored [ i + 1 ] == 1 ) { colored [ i ] = 1 ; answer = ( answer + count@@ W@@ ays ( colored , count + 1 , n ) ) % mod ; colored [ i ] = 0 ; } } } return answer ; } int way@@ sTo@@ Color ( int arr [ ] , int n , int k ) { int colored [ n + 2 ] = { 0 } ; for ( int i = 0 ; i < k ; i ++ ) { colored [ arr [ i ] ] = 1 ; } return count@@ W@@ ays ( colored , k , n ) ; } int main ( ) { int N = 6 ; int K = 3 ; int arr [ K ] = { 1 , 2 , 6 } ; cout << way@@ sTo@@ Color ( arr , N , K ) ; return 0 ; }
Check if a Sequence is a concatenation of two permutations 2779 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool check@@ Permutation ( int arr [ ] , int n ) { long long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; long long prefix [ n + 1 ] = { 0 } ; prefix [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix [ i ] = prefix [ i - 1 ] + arr [ i ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { long long l@@ sum = prefix [ i ] ; long long r@@ sum = sum - prefix [ i ] ; long long l_@@ len = i + 1 , r_@@ len = n - i - 1 ; if ( ( ( 2 * l@@ sum ) == ( l_@@ len * ( l_@@ len + 1 ) ) ) && ( ( 2 * r@@ sum ) == ( r_@@ len * ( r_@@ len + 1 ) ) ) ) return true ; } return false ; } int main ( ) { int arr [ ] = { 1 , 2 , 5 , 3 , 4 , 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( int ) ; if ( check@@ Permutation ( arr , n ) ) cout << " Yes STRNEWLINE " ; else cout << " No STRNEWLINE " ; return 0 ; }
Find Next number having distinct digits from the given number N 2781 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ Next@@ Number ( int n ) { int h [ 10 ] = { 0 } ; int i = 0 , ms@@ b = n , rem = 0 ; int next_@@ num = -1 , count = 0 ; while ( ms@@ b > 9 ) { rem = ms@@ b % 10 ; h [ rem ] = 1 ; ms@@ b /= 10 ; count ++ ; } h [ ms@@ b ] = 1 ; count ++ ; for ( i = ms@@ b + 1 ; i < 10 ; i ++ ) { if ( h [ i ] == 0 ) { next_@@ num = i ; break ; } } if ( next_@@ num == -1 ) { for ( i = 1 ; i < ms@@ b ; i ++ ) { if ( h [ i ] == 0 ) { next_@@ num = i ; count ++ ; break ; } } } if ( next_@@ num > 0 ) { for ( i = 0 ; i < 10 ; i ++ ) { if ( h [ i ] == 0 ) { ms@@ b = i ; break ; } } for ( i = 1 ; i < count ; i ++ ) { next_@@ num = ( ( next_@@ num * 10 ) + ms@@ b ) ; } if ( next_@@ num > n ) cout << next_@@ num << " STRNEWLINE " ; else cout << " Not ▁ Possible ▁ STRNEWLINE " ; } else { cout << " Not ▁ Possible ▁ STRNEWLINE " ; } } int main ( ) { int n = 2019 ; find@@ Next@@ Number ( n ) ; return 0 ; }
Find a N 2782 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ The@@ Number ( int n ) { if ( n == 1 ) { cout << " Imp@@ ossible " << endl ; return ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { cout << "5" ; } cout << "4" ; } int main ( ) { int n = 12 ; find@@ The@@ Number ( n ) ; return 0 ; }
Queries to check whether bitwise AND of a sub@@ array is even or odd 2784 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; const int MAX@@ N = 10000@@ 05 ; int even [ MAX@@ N ] , odd [ MAX@@ N ] ; void pre@@ compute ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) odd [ i ] = 1 ; if ( arr [ i ] % 2 == 0 ) even [ i ] = 1 ; } for ( int i = 1 ; i < n ; i ++ ) { even [ i ] = even [ i ] + even [ i - 1 ] ; odd [ i ] = odd [ i ] + odd [ i - 1 ] ; } } bool is@@ Odd ( int L , int R ) { int cnt = odd [ R ] ; if ( L > 0 ) cnt -= odd [ L - 1 ] ; if ( cnt == R - L + 1 ) return true ; return false ; } void perform@@ Queries ( int a [ ] , int n , int q [ ] [ 2 ] , int m ) { pre@@ compute ( a , n ) ; for ( int i = 0 ; i < m ; i ++ ) { int L = q [ i ] [ 0 ] , R = q [ i ] [ 1 ] ; if ( is@@ Odd ( L , R ) ) cout << " Odd STRNEWLINE " ; else cout << " Even STRNEWLINE " ; } } int main ( ) { int a [ ] = { 2 , 1 , 5 , 7 , 6 , 8 , 9 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int q [ ] [ 2 ] = { { 0 , 2 } , { 1 , 2 } , { 2 , 3 } , { 3 , 6 } } ; int m = sizeof ( q ) / sizeof ( q [ 0 ] ) ; perform@@ Queries ( a , n , q , m ) ; return 0 ; }
Op@@ ti@@ mal Strategy for a Game | Special G@@ old Coin 2797 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; string get@@ Win@@ ner ( string str , int len ) { int total = 0 ; if ( str [ 0 ] == ' G ' str [ len - 1 ] == ' G ' ) return " First " ; else { for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == ' S ' ) { total ++ ; } } if ( ( total % 2 ) == 1 ) return " First " ; return " Second " ; } } int main ( ) { string str = " GS@@ SS " ; int len = str . length ( ) ; cout << get@@ Win@@ ner ( str , len ) ; return 0 ; }
Re@@ arrange array elements such that Bit@@ wise AND of first N 2799 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ Arr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; } void find@@ Arrange@@ ment ( int arr [ ] , int n ) { if ( n < 2 ) { cout << " - 1" ; return ; } int min@@ Val = * min_@@ element ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == min@@ Val ) { swap ( arr [ i ] , arr [ n - 1 ] ) ; break ; } } int and@@ Val = arr [ 0 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { and@@ Val &= arr [ i ] ; } if ( and@@ Val == arr [ n - 1 ] ) print@@ Arr ( arr , n ) ; else cout << " - 1" ; } int main ( ) { int arr [ ] = { 1 , 5 , 3 , 3 } ; int n = sizeof ( arr ) / sizeof ( int ) ; find@@ Arrange@@ ment ( arr , n ) ; return 0 ; }
Maximum prime moves to convert X to Y 2800 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max@@ Operations ( int X , int Y ) { if ( X > Y ) return -1 ; int diff = Y - X ; if ( diff == 1 ) return -1 ; if ( diff % 2 == 0 ) return ( diff / 2 ) ; return ( 1 + ( ( diff - 3 ) / 2 ) ) ; } int main ( ) { int X = 5 , Y = 16 ; cout << max@@ Operations ( X , Y ) ; return 0 ; }
Random list of M non 2810 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ Arr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; } void random@@ List ( int m , int n ) { int arr [ m ] = { 0 } ; srand ( time ( 0 ) ) ; for ( int i = 0 ; i < n ; i ++ ) { arr [ rand ( ) % m ] ++ ; } print@@ Arr ( arr , m ) ; } int main ( ) { int m = 4 , n = 8 ; random@@ List ( m , n ) ; return 0 ; }
Find maximum value of the last element after redu@@ cing the array with given operations 2829 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find_@@ maximum@@ _value ( int a [ ] , int n ) { int sum = 0 ; int minimum = INT_MAX ; int pos = 0 , neg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { minimum = min ( minimum , abs ( a [ i ] ) ) ; sum += abs ( a [ i ] ) ; if ( a [ i ] >= 0 ) pos += 1 ; else neg += 1 ; } if ( pos > 0 && neg > 0 ) return sum ; return ( sum - 2 * minimum ) ; } int main ( ) { int a [ ] = { 5 , 4 , 6 , 2 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << find_@@ maximum@@ _value ( a , n ) ; return 0 ; }
Find smallest number K such that K % p = 0 and q % K = 0 2841 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int getMin@@ Val ( int p , int q ) { if ( q % p == 0 ) return p ; return -1 ; } int main ( ) { int p = 24 , q = 48 ; cout << getMin@@ Val ( p , q ) ; return 0 ; }
Lex@@ ico@@ graphic@@ ally smallest string with given string as prefix 2883 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is_@@ prefix ( string temp , string str ) { if ( temp . length ( ) < str . length ( ) ) return 0 ; else { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] != temp [ i ] ) return 0 ; } return 1 ; } } string lex@@ ico@@ graphic@@ ally@@ String ( string input [ ] , int n , string str ) { sort ( input , input + n ) ; for ( int i = 0 ; i < n ; i ++ ) { string temp = input [ i ] ; if ( is_@@ prefix ( temp , str ) ) { return temp ; } } return " - 1" ; } int main ( ) { string arr [ ] = { " apple " , " appe " , " ap@@ l " , " a@@ ap@@ l " , " app@@ ax " } ; string S = " app " ; int N = 5 ; cout << lex@@ ico@@ graphic@@ ally@@ String ( arr , N , S ) ; return 0 ; }
Minim@@ ize the sum of pair which upon removing divi@@ des the Array into 3 sub@@ arrays 2884 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int min@@ Sum@@ Pair ( int arr [ ] , int N ) { if ( N < 5 ) { return -1 ; } int prefix@@ Min [ N ] ; prefix@@ Min [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < N - 1 ; i ++ ) { prefix@@ Min [ i ] = min ( arr [ i ] , prefix@@ Min [ i - 1 ] ) ; } int ans = INT_MAX ; for ( int i = 3 ; i < N - 1 ; i ++ ) { ans = min ( ans , arr [ i ] + prefix@@ Min [ i - 2 ] ) ; } return ans ; } int main ( ) { int arr [ ] = { 5 , 2 , 4 , 6 , 3 , 7 } ; int N = sizeof ( arr ) / sizeof ( int ) ; cout << min@@ Sum@@ Pair ( arr , N ) << endl ; return 0 ; }
Count of different numbers di@@ visible by 3 that can be obtained by changing at most one digit 2887 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ Count ( string number ) { int sum = 0 ; for ( int i = 0 ; i < number . length ( ) ; ++ i ) { sum += number [ i ] - 48 ; } int count = 0 ; for ( int i = 0 ; i < number . length ( ) ; ++ i ) { int remaining_@@ sum = sum - ( number [ i ] - 48 ) ; for ( int j = 0 ; j <= 9 ; ++ j ) { if ( ( remaining_@@ sum + j ) % 3 == 0 && j != number [ i ] - 48 ) { ++ count ; } } } cout << count ; } int main ( ) { string number = "@@ 23@@ 5" ; find@@ Count ( number ) ; }
Maxim@@ ize the smallest array element by increment@@ ing all elements in a K 2894 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define ll long long NEW_LINE ll n , m , k , l , r , i ; ll check ( ll v , vector < ll > & a ) { ll te@@ c = 0 , ans = 0 ; vector < ll > b ( n + k + 1 ) ; for ( i = 0 ; i < n ; i ++ ) { te@@ c -= b [ i ] ; if ( a [ i ] + te@@ c < v ) { ll mov = v - a [ i ] - te@@ c ; ans = ans + mov ; te@@ c += mov ; b [ i + k ] = mov ; } } return ( ans <= m ) ; } ll Find@@ Lar@@ gest ( vector < ll > a ) { l = 1 ; r = pow ( 10 , 10 ) ; while ( r - l > 0 ) { ll tm = ( l + r + 1 ) / 2 ; if ( check ( tm , a ) ) l = tm ; else r = tm - 1 ; } return l ; } int main ( ) { vector < ll > a { 2 , 2 , 2 , 2 , 1 , 1 } ; m = 2 ; k = 3 ; n = a . size ( ) ; cout << Find@@ Lar@@ gest ( a ) ; return 0 ; }
Maxim@@ ize boxes required to keep at least one black and one white sh@@ ir@@ t 2912 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void number@@ of@@ Boxes ( int W , int B , int O ) { int low = 0 , high = min ( W , B ) ; int ans = 0 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( ( ( W >= mid ) and ( B >= mid ) ) and ( ( W - mid ) + ( B - mid ) + O ) >= mid ) { ans = mid ; low = mid + 1 ; } else high = mid - 1 ; } cout << ans ; } int main ( ) { int W = 3 , B = 3 , O = 1 ; number@@ of@@ Boxes ( W , B , O ) ; return 0 ; }
Find all possible pairs with given Bit@@ wise OR and Bit@@ wise XOR values 2942 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ Pairs ( int A , int B ) { for ( int i = 1 ; i <= B ; i ++ ) { int y = A ^ i ; if ( y > 0 and ( i y ) == B ) { cout << i << " ▁ " << y << endl ; } } } int main ( ) { int A = 8 , B = 10 ; find@@ Pairs ( A , B ) ; return 0 ; }
Find Unique ID and Domain Name of a Web@@ site from a string 2946 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ char ( char x ) { if ( ( x >= ' A ' && x <= ' Z ' ) || ( x >= ' a ' && x <= ' z ' ) ) { return 1 ; } return 0 ; } bool is@@ num ( char x ) { if ( x >= '0' && x <= '9' ) return 1 ; return 0 ; } void find@@ Id@@ and@@ Domain ( string S , int N ) { string ID , Domain ; vector < string > words ; string curr = " " ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] == ' ▁ ' ) { words . push_back ( curr ) ; curr = " " ; } else { if ( S [ i ] == ' . ' ) { if ( i + 1 == N || ( i + 1 < N && S [ i + 1 ] == ' ▁ ' ) ) continue ; } curr += S [ i ] ; } } if ( curr . length ( ) ) words . push_back ( curr ) ; for ( string ss : words ) { if ( ss . size ( ) == 10 ) { bool flag = 0 ; for ( int j = 0 ; j <= 9 ; j ++ ) { if ( j >= 5 && j < 9 ) { if ( is@@ num ( ss [ j ] ) == 0 ) flag = 1 ; } else { if ( is@@ char ( ss [ j ] ) == 0 ) flag = 1 ; } } if ( ! flag ) { ID = ss ; } } if ( ss . substr ( 0 , 3 ) == " www " && ss . substr ( ss . length ( ) - 3 , 3 ) == " com " ) { Domain = ss . substr ( 4 , ss . size ( ) - 4 ) ; } } cout << " ID ▁ = ▁ " << ID << endl ; cout << " Domain ▁ = ▁ " << Domain ; } int main ( ) { string S = " We ▁ th@@ ank ▁ ABC@@ DE@@ 1234@@ F ▁ for ▁ visi@@ ting ▁ " " us ▁ and ▁ bu@@ ying ▁ " " products ▁ item ▁ AM@@ Z@@ rr @ ! k . ▁ For ▁ more ▁ " " offers , ▁ visit ▁ " " us ▁ at ▁ www . amazon . com " ; int N = S . length ( ) ; find@@ Id@@ and@@ Domain ( S , N ) ; return 0 ; }
Count trip@@ lets from a sorted array having difference between adjacent elements equal to D 2958 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Trip@@ lets ( int D , vector < int > & arr ) { unordered_map < int , int > freq ; int ans = 0 ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { if ( freq . find ( arr [ i ] - D ) != freq . end ( ) && freq . find ( arr [ i ] - 2 * D ) != freq . end ( ) ) { ans += freq [ arr [ i ] - D ] * freq [ arr [ i ] - 2 * D ] ; } freq [ arr [ i ] ] ++ ; } return ans ; } int main ( ) { vector < int > arr { 1 , 2 , 4 , 5 , 7 , 8 , 10 } ; int D = 1 ; cout << count@@ Trip@@ lets ( D , arr ) ; return 0 ; }
Size of smallest square that contains N non 2978 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool bound ( int w , int h , int N , int x ) { int val = ( x / w ) * ( x / h ) ; if ( val >= N ) return true ; else return false ; } int Find@@ Square ( int N , int W , int H ) { int i = 1 ; int j = W * H * N ; while ( i < j ) { int mid = i + ( j - i ) / 2 ; if ( bound ( W , H , N , mid ) ) j = mid ; else i = mid + 1 ; } return j ; } int main ( ) { int W = 2 ; int H = 3 ; int N = 10 ; cout << Find@@ Square ( N , W , H ) ; }
Check if a number can be represented as a sum of a Prime Number and a Perf@@ ect Square 2992 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( bool prime [ ] , int n ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) { prime [ i ] = false ; } } } } void sum@@ Of@@ Prime@@ Square ( int n ) { bool flag = false ; bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( prime , n ) ; for ( int i = 0 ; i <= n ; i ++ ) { if ( ! prime [ i ] ) continue ; int dif = n - i ; if ( ceil ( ( double ) sqrt ( dif ) ) == floor ( ( double ) sqrt ( dif ) ) ) { flag = true ; break ; } } if ( flag ) { cout << " Yes " ; } else cout << " No " ; } int main ( ) { int N = 27 ; sum@@ Of@@ Prime@@ Square ( N ) ; return 0 ; }
Check if any sub@@ array of length M repeats at least K times consec@@ uti@@ vely or not 2995 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; bool check ( int arr [ ] , int M , int K , int ind ) { for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 1 ; j < K ; j ++ ) { if ( arr [ ind + i ] != arr [ ind + i + j * M ] ) { return false ; } } } return true ; } bool Sub@@ array@@ Repeat@@ s@@ K@@ or@@ More ( int arr [ ] , int N , int M , int K ) { for ( int ind = 0 ; ind <= N - M * K ; ind ++ ) { if ( check ( arr , M , K , ind ) ) { return true ; } } return false ; } int main ( ) { int arr [ ] = { 2 , 1 , 2 , 1 , 1 , 1 , 3 } ; int M = 2 , K = 2 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( Sub@@ array@@ Repeat@@ s@@ K@@ or@@ More ( arr , N , M , K ) ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
S@@ malle@@ st value of N such that the sum of all natural numbers from K to N is at least X 2998 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void minimum@@ Number ( int K , int X ) { if ( K > X ) { cout << " - 1" ; return ; } int ans = 0 ; int sum = 0 ; for ( int i = K ; i <= X ; i ++ ) { sum += i ; if ( sum >= X ) { ans = i ; break ; } } cout << ans ; } int main ( ) { int K = 5 , X = 13 ; minimum@@ Number ( K , X ) ; return 0 ; }
Find the peak index of a given array 3010 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int peak@@ Index ( int arr [ ] , int N ) { if ( N < 3 ) return -1 ; int i = 0 ; while ( i + 1 < N ) { if ( arr [ i + 1 ] < arr [ i ] arr [ i ] == arr [ i + 1 ] ) break ; i ++ ; } if ( i == 0 i == N - 1 ) return -1 ; int ans = i ; while ( i < N - 1 ) { if ( arr [ i ] < arr [ i + 1 ] arr [ i ] == arr [ i + 1 ] ) break ; i ++ ; } if ( i == N - 1 ) return ans ; return -1 ; } int main ( ) { int arr [ ] = { 0 , 1 , 0 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << peak@@ Index ( arr , N ) << " STRNEWLINE " ; return 0 ; }
Count pairs ( i , j ) from an array such that | arr [ i ] | and | arr [ j ] | both lies between | arr [ i ] 3018 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ Pairs ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) arr [ i ] = abs ( arr [ i ] ) ; sort ( arr , arr + N ) ; int left = 0 ; int ans = 0 ; for ( int right = 0 ; right < N ; right ++ ) { while ( 2 * arr [ left ] < arr [ right ] ) left ++ ; ans += ( right - left ) ; } cout << ans ; } int main ( ) { int arr [ ] = { 1 , 3 , 5 , 7 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; find@@ Pairs ( arr , N ) ; return 0 ; }
Number of sub@@ arrays having even product 3038 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void even@@ product ( int arr [ ] , int length ) { int count = 0 ; for ( int i = 0 ; i < length + 1 ; i ++ ) { int product = 1 ; for ( int j = i ; j < length + 1 ; j ++ ) { product *= arr [ j ] ; if ( product % 2 == 0 ) ++ count ; } } cout << count ; } int main ( ) { int arr [ ] = { 7 , 5 , 4 , 9 } ; int length = ( sizeof ( arr ) / sizeof ( arr [ 0 ] ) ) - 1 ; even@@ product ( arr , length ) ; }
Count ways to partition a Binary String such that each substring contains exactly two 0 s 3132 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int total@@ W@@ ays ( int n , string str ) { vector < int > Idx@@ Of@@ 0@@ s ; int cnt@@ W@@ ays = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '0' ) { Idx@@ Of@@ 0@@ s . push_back ( i ) ; } } int M = Idx@@ Of@@ 0@@ s . size ( ) ; if ( M == 0 or M % 2 ) { return 0 ; } for ( int i = 2 ; i < M ; i += 2 ) { cnt@@ W@@ ays = cnt@@ W@@ ays * ( Idx@@ Of@@ 0@@ s [ i ] - Idx@@ Of@@ 0@@ s [ i - 1 ] ) ; } return cnt@@ W@@ ays ; } int main ( ) { string str = "00@@ 100" ; int n = str . length ( ) ; cout << total@@ W@@ ays ( n , str ) ; return 0 ; }
Count sub@@ arrays consisting of first K natural numbers in descending order 3140 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int Count@@ Sub@@ array ( int arr [ ] , int n , int k ) { int temp = k , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == temp ) { if ( temp == 1 ) { count ++ ; temp = k ; } else temp -- ; } else { temp = k ; if ( arr [ i ] == k ) i -- ; } } return count ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 7 , 9 , 3 , 2 , 1 , 8 , 3 , 2 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 3 ; cout << Count@@ Sub@@ array ( arr , N , K ) ; return 0 ; }
Count di@@ visors which generates same Quo@@ ti@@ ent and Remain@@ der 3171 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void count@@ Di@@ visors ( long long int n ) { int count = 0 ; vector < long long int > divisor ; for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) divisor . push_back ( i ) ; else { divisor . push_back ( i ) ; divisor . push_back ( n / i ) ; } } } divisor . push_back ( n ) ; for ( auto x : divisor ) { x -= 1 ; if ( ( n / x ) == ( n % x ) ) count ++ ; } cout << count ; } int main ( ) { long long int N = 100000000@@ 0000 ; count@@ Di@@ visors ( N ) ; return 0 ; }
Lon@@ gest increasing sub@@ sequence consisting of elements from indices di@@ visible by previously selected indices 3208 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ MaxLength ( int N , vector < int > arr ) { vector < int > dp ( N + 1 , 1 ) ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 2 * i ; j <= N ; j += i ) { if ( arr [ i - 1 ] < arr [ j - 1 ] ) { dp [ j ] = max ( dp [ j ] , dp [ i ] + 1 ) ; } } } return * max_@@ element ( dp . begin ( ) , dp . end ( ) ) ; } int main ( ) { vector < int > arr { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ; int N = arr . size ( ) ; cout << find@@ MaxLength ( N , arr ) ; return 0 ; }
Find an integral solution of the non 3267 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; long long power ( long long x , long long N ) { long long res = 1 ; while ( N > 0 ) { if ( N & 1 ) { res = ( res * x ) ; } x = ( x * x ) ; N = N >> 1 ; } return res ; } void find@@ Val@@ X_@@ Y ( long long N ) { if ( N <= 1 ) { cout << -1 << endl ; return ; } int x@@ Max ; x@@ Max = log2 ( N ) ; int y@@ Max ; y@@ Max = ( log2 ( N ) / log2 ( 5.0 ) ) ; for ( long long i = 1 ; i <= x@@ Max ; i ++ ) { for ( long long j = 1 ; j <= y@@ Max ; j ++ ) { long long a = power ( 2 , i ) ; long long b = power ( 5 , j ) ; if ( a + b == N ) { cout << i << " ▁ " << j << endl ; return ; } } } cout << -1 << endl ; } int main ( ) { long long N = 129 ; find@@ Val@@ X_@@ Y ( N ) ; return 0 ; }
Queries to flip characters of a binary string in given range 3277 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; string toggle@@ Query ( string str , int Q [ ] [ 2 ] , int M ) { int N = str . length ( ) ; int prefix@@ Cnt [ N + 1 ] = { 0 } ; for ( int i = 0 ; i < M ; i ++ ) { prefix@@ Cnt [ Q [ i ] [ 0 ] ] += 1 ; prefix@@ Cnt [ Q [ i ] [ 1 ] + 1 ] -= 1 ; } for ( int i = 1 ; i <= N ; i ++ ) { prefix@@ Cnt [ i ] += prefix@@ Cnt [ i - 1 ] ; } for ( int i = 0 ; i < N ; i ++ ) { if ( prefix@@ Cnt [ i ] % 2 ) { str [ i ] = '1' - str [ i ] + '0' ; } } return str ; } int main ( ) { string str = "@@ 101@@ 01@@ 0" ; int Q [ ] [ 2 ] = { { 0 , 1 } , { 2 , 5 } , { 2 , 3 } , { 1 , 4 } , { 0 , 5 } } ; int M = sizeof ( Q ) / sizeof ( Q [ 0 ] ) ; cout << toggle@@ Query ( str , Q , M ) ; }
Length of longest sub@@ array with increasing contiguous elements 3295 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max@@ i@@ Con@@ sec@@ uti@@ ve@@ Sub@@ array ( int arr [ ] , int N ) { int max@@ i = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { int cnt = 1 , j ; for ( j = i ; j < N ; j ++ ) { if ( arr [ j + 1 ] == arr [ j ] + 1 ) { cnt ++ ; } else { break ; } } max@@ i = max ( max@@ i , cnt ) ; i = j ; } return max@@ i ; } int main ( ) { int N = 11 ; int arr [ ] = { 1 , 3 , 4 , 2 , 3 , 4 , 2 , 3 , 5 , 6 , 7 } ; cout << max@@ i@@ Con@@ sec@@ uti@@ ve@@ Sub@@ array ( arr , N ) ; return 0 ; }
Maximum number of elements that can be removed such that ME@@ X of the given array remains unchanged 3303 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void count@@ Remo@@ v@@ able@@ Elem ( int arr [ ] , int N ) { int hash [ N + 1 ] = { 0 } ; int me@@ x = N + 1 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] <= N ) hash [ arr [ i ] ] = 1 ; } for ( int i = 1 ; i <= N ; i ++ ) { if ( hash [ i ] == 0 ) { me@@ x = i ; break ; } } cout << N - ( me@@ x - 1 ) ; } int main ( ) { int arr [ ] = { 2 , 3 , 5 , 1 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; count@@ Remo@@ v@@ able@@ Elem ( arr , N ) ; return 0 ; }
Print all positions of a given string having count of smaller characters equal on both sides 3304 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ Indexes ( string str ) { int N = str . length ( ) ; int cnt@@ Freq [ 256 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { cnt@@ Freq [ str [ i ] ] ++ ; } int cnt@@ Left@@ Freq [ 256 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { int cnt@@ Left = 0 ; int cnt@@ Right = 0 ; for ( int j = str [ i ] - 1 ; j >= 0 ; j -- ) { cnt@@ Left += cnt@@ Left@@ Freq [ j ] ; cnt@@ Right += cnt@@ Freq [ j ] - cnt@@ Left@@ Freq [ j ] ; } cnt@@ Left@@ Freq [ str [ i ] ] ++ ; if ( cnt@@ Left == cnt@@ Right && cnt@@ Left != 0 ) { cout << i << " ▁ " ; } } } int main ( ) { string str = " a@@ ab@@ ac@@ d@@ ab@@ bb " ; print@@ Indexes ( str ) ; }
Check if a string is concatenation of another given string 3343 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool check@@ Concat ( string str1 , string str2 ) { int N = str1 . length ( ) ; int M = str2 . length ( ) ; if ( N % M != 0 ) { return false ; } for ( int i = 0 ; i < N ; i ++ ) { if ( str1 [ i ] != str2 [ i % M ] ) { return false ; } } return true ; } int main ( ) { string str1 = " abc@@ abc@@ abc " ; string str2 = " abc " ; if ( check@@ Concat ( str1 , str2 ) ) { cout << " Yes " ; } else { cout << " No " ; } }
Count positions in Binary Matrix having equal count of set bits in corresponding row and column 3357 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Position ( vector < vector < int > > mat ) { int n = mat . size ( ) ; int m = mat [ 0 ] . size ( ) ; vector < int > row ( n ) ; vector < int > col ( m ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) { col [ j ] ++ ; row [ i ] ++ ; } } } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( row [ i ] == col [ j ] ) { count ++ ; } } } return count ; } int main ( ) { vector < vector < int > > mat = { { 0 , 1 } , { 1 , 1 } } ; cout << ( count@@ Position ( mat ) ) ; }
Pair having all other given pairs ly@@ ing between its minimum and maximum 3358 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void position ( int arr [ ] [ 2 ] , int N ) { int pos = -1 ; int count ; for ( int i = 0 ; i < N ; i ++ ) { count = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ i ] [ 0 ] <= arr [ j ] [ 0 ] && arr [ i ] [ 1 ] >= arr [ j ] [ 1 ] ) { count ++ ; } } if ( count == N ) { pos = i ; } } if ( pos == -1 ) { cout << pos ; } else { cout << pos + 1 ; } } int main ( ) { int arr [ ] [ 2 ] = { { 3 , 3 } , { 1 , 3 } , { 2 , 2 } , { 2 , 3 } , { 1 , 2 } } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; position ( arr , N ) ; }
Node whose removal minim@@ izes the maximum size forest from an N 3384 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int mini = 105 , ans , n ; vector < vector < int > > g ( 100 ) ; int size [ 100 ] ; void create_@@ graph ( ) { g [ 1 ] . push_back ( 2 ) ; g [ 2 ] . push_back ( 1 ) ; g [ 1 ] . push_back ( 3 ) ; g [ 3 ] . push_back ( 1 ) ; g [ 1 ] . push_back ( 4 ) ; g [ 4 ] . push_back ( 1 ) ; g [ 2 ] . push_back ( 5 ) ; g [ 5 ] . push_back ( 2 ) ; g [ 2 ] . push_back ( 6 ) ; g [ 6 ] . push_back ( 2 ) ; } void dfs ( int node , int parent ) { size [ node ] = 1 ; int mx = 0 ; for ( int y : g [ node ] ) { if ( y == parent ) continue ; dfs ( y , node ) ; size [ node ] += size [ y ] ; mx = max ( mx , size [ y ] ) ; } mx = max ( mx , n - size [ node ] ) ; if ( mx < mini ) { mini = mx ; ans = node ; } } int main ( ) { n = 6 ; create_@@ graph ( ) ; dfs ( 1 , -1 ) ; cout << ans << " STRNEWLINE " ; return 0 ; }
Check if array can be sorted by sw@@ apping pairs having GC@@ D equal to the smallest element in the array 3423 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void is@@ Possible ( int arr [ ] , int N ) { int mn = INT_MAX ; int B [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { mn = min ( mn , arr [ i ] ) ; B [ i ] = arr [ i ] ; } sort ( arr , arr + N ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] != B [ i ] ) { if ( B [ i ] % mn != 0 ) { cout << " No " ; return ; } } } cout << " Yes " ; return ; } int main ( ) { int N = 6 ; int arr [ ] = { 4 , 3 , 6 , 6 , 2 , 9 } ; is@@ Possible ( arr , N ) ; return 0 ; }
Check if all array elements are present in a given stack or not 3429 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool check@@ Arr@@ In@@ Stack ( stack < int > s , int arr [ ] , int n ) { map < int , int > freq ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; while ( ! s . empty ( ) ) { int pop@@ ped@@ E@@ le = s . top ( ) ; s . pop ( ) ; if ( freq [ pop@@ ped@@ E@@ le ] ) freq [ pop@@ ped@@ E@@ le ] -= 1 ; } if ( freq . size ( ) == 0 ) return 0 ; return 1 ; } int main ( ) { stack < int > s ; s . push ( 10 ) ; s . push ( 20 ) ; s . push ( 30 ) ; s . push ( 40 ) ; s . push ( 50 ) ; int arr [ ] = { 20 , 30 } ; int n = sizeof arr / sizeof arr [ 0 ] ; if ( check@@ Arr@@ In@@ Stack ( s , arr , n ) ) cout << " YES STRNEWLINE " ; else cout << " NO STRNEWLINE " ; }
Minimum size substring to be removed to make a given string pal@@ ind@@ ro@@ mic 3448 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; string pal@@ ind@@ ro@@ me@@ Prefix ( string S ) { int n = S . size ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { string curr = S . substr ( 0 , i + 1 ) ; int l = 0 , r = curr . size ( ) - 1 ; bool is_p@@ al@@ ind@@ ro@@ me = 1 ; while ( l < r ) { if ( curr [ l ] != curr [ r ] ) { is_p@@ al@@ ind@@ ro@@ me = 0 ; break ; } l ++ ; r -- ; } if ( is_p@@ al@@ ind@@ ro@@ me ) return curr ; } return " " ; } string max@@ Pal@@ ind@@ ro@@ me ( string S ) { int n = S . size ( ) ; if ( n <= 1 ) { return S ; } string pre = " " , su@@ ff = " " ; int i = 0 , j = n - 1 ; while ( S [ i ] == S [ j ] && i < j ) { i ++ ; j -- ; } i -- ; j ++ ; pre = S . substr ( 0 , i + 1 ) ; su@@ ff = S . substr ( j ) ; if ( j - i == 1 ) { return pre + su@@ ff ; } if ( j - i == 2 ) { string mid_@@ char = S . substr ( i + 1 , 1 ) ; return pre + mid_@@ char + su@@ ff ; } string re@@ m_@@ str = S . substr ( i + 1 , j - i - 1 ) ; string pre_@@ of_@@ re@@ m_@@ str = pal@@ ind@@ ro@@ me@@ Prefix ( re@@ m_@@ str ) ; reverse ( re@@ m_@@ str . begin ( ) , re@@ m_@@ str . end ( ) ) ; string su@@ ff_@@ of_@@ re@@ m_@@ str = pal@@ ind@@ ro@@ me@@ Prefix ( re@@ m_@@ str ) ; if ( pre_@@ of_@@ re@@ m_@@ str . size ( ) >= su@@ ff_@@ of_@@ re@@ m_@@ str . size ( ) ) { return pre + pre_@@ of_@@ re@@ m_@@ str + su@@ ff ; } else { return pre + su@@ ff_@@ of_@@ re@@ m_@@ str + su@@ ff ; } } int main ( ) { string S = " ge@@ ek@@ s@@ for@@ s@@ kee@@ g " ; cout << max@@ Pal@@ ind@@ ro@@ me ( S ) ; return 0 ; }
Sum of all distances between occurrences of same characters in a given string 3496 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Sum ( string s ) { int sum = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { for ( int j = i + 1 ; j < s . size ( ) ; j ++ ) { if ( s [ i ] == s [ j ] ) { sum += ( j - i ) ; } } } return sum ; } int main ( ) { string s = " tt@@ t " ; cout << find@@ Sum ( s ) << endl ; }
Minim@@ ize count of fli@@ ps required such that no substring of 0 s have length exce@@ eding K 3534 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int min@@ _f@@ li@@ ps ( string & str , int k ) { if ( str . size ( ) == 0 ) return 0 ; int ans = 0 ; int cn@@ t_@@ zeros = 0 ; for ( char ch : str ) { if ( ch == '0' ) { ++ cn@@ t_@@ zeros ; } else { cn@@ t_@@ zeros = 0 ; } if ( cn@@ t_@@ zeros == k ) { ++ ans ; cn@@ t_@@ zeros = 0 ; } } return ans ; } int main ( ) { string str = "11@@ 1000000@@ 11" ; int k = 3 ; cout << min@@ _f@@ li@@ ps ( str , k ) ; return 0 ; }
Count of N digit Numbers having no pair of equal consecutive Digits 3597 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void count ( int N ) { if ( N == 1 ) { cout << ( 10 ) << endl ; return ; } int dp [ N ] [ 10 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 1 ; i < 10 ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) { int temp = 0 ; for ( int j = 0 ; j < 10 ; j ++ ) temp += dp [ i - 1 ] [ j ] ; for ( int j = 0 ; j < 10 ; j ++ ) dp [ i ] [ j ] = temp - dp [ i - 1 ] [ j ] ; } int ans = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) ans += dp [ N - 1 ] [ i ] ; cout << ans << endl ; } int main ( ) { int N = 2 ; count ( N ) ; return 0 ; }
Queries to find the count of connected Non 3604 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int ctr = 0 ; int find ( vector < int > & parent , int x ) { if ( parent [ x ] == x ) return x ; parent [ x ] = find ( parent , parent [ x ] ) ; return parent [ x ] ; } void set@@ Union ( vector < int > & parent , vector < int > & rank , int x , int y ) { int parent@@ x = find ( parent , x ) ; int paren@@ ty = find ( parent , y ) ; if ( paren@@ ty == parent@@ x ) return ; ctr -- ; if ( rank [ parent@@ x ] < rank [ paren@@ ty ] ) { parent [ parent@@ x ] = paren@@ ty ; } else if ( rank [ parent@@ x ] > rank [ paren@@ ty ] ) { parent [ paren@@ ty ] = parent@@ x ; } else { parent [ parent@@ x ] = paren@@ ty ; rank [ paren@@ ty ] ++ ; } } vector < int > solve ( int n , int m , vector < pair < int , int > > & query ) { vector < int > result ( query . size ( ) ) ; vector < int > parent ( n * m ) ; for ( int i = 0 ; i < n * m ; i ++ ) parent [ i ] = i ; vector < int > rank ( n * m , 1 ) ; vector < bool > grid ( n * m , 0 ) ; for ( int i = 0 ; i < query . size ( ) ; i ++ ) { int x = query [ i ] . first ; int y = query [ i ] . second ; if ( grid [ m * x + y ] == 1 ) { result [ i ] = ctr ; continue ; } grid [ m * x + y ] = 1 ; ctr ++ ; if ( x > 0 and grid [ m * ( x - 1 ) + y ] == 1 ) set@@ Union ( parent , rank , m * x + y , m * ( x - 1 ) + y ) ; if ( y > 0 and grid [ m * ( x ) + y - 1 ] == 1 ) set@@ Union ( parent , rank , m * x + y , m * ( x ) + y - 1 ) ; if ( x < n - 1 and grid [ m * ( x + 1 ) + y ] == 1 ) set@@ Union ( parent , rank , m * x + y , m * ( x + 1 ) + y ) ; if ( y < m - 1 and grid [ m * ( x ) + y + 1 ] == 1 ) set@@ Union ( parent , rank , m * x + y , m * ( x ) + y + 1 ) ; result [ i ] = ctr ; } return result ; } int main ( ) { int N = 3 , M = 3 , K = 4 ; vector < pair < int , int > > query = { { 0 , 0 } , { 1 , 1 } , { 1 , 0 } , { 1 , 2 } } ; vector < int > result = solve ( N , M , query ) ; for ( int i = 0 ; i < K ; i ++ ) cout << result [ i ] << " ▁ " ; }
Minimum number of leaves required to be removed from a Tree to satisfy the given condition 3628 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int cnt = 0 ; void dfs ( int * val , int * cost , vector < vector < int > > & tr , int u , int s ) { s = s + cost [ u ] ; if ( s < 0 ) s = 0 ; if ( s > val [ u ] ) return ; cnt ++ ; for ( int i = 0 ; i < tr [ u ] . size ( ) ; i ++ ) { dfs ( val , cost , tr , tr [ u ] [ i ] , s ) ; } } int main ( ) { int n = 9 ; int val [ ] = { 88 , 22 , 83 , 14 , 95 , 91 , 98 , 53 , 11 } ; int cost [ ] = { -1 , 24 , -@@ 8 , 67 , 64 , 65 , 12 , -@@ 80 , 8 } ; vector < vector < int > > tr ( n + 1 ) ; tr [ 0 ] . push_back ( 3 ) ; tr [ 0 ] . push_back ( 4 ) ; tr [ 4 ] . push_back ( 6 ) ; tr [ 6 ] . push_back ( 2 ) ; tr [ 2 ] . push_back ( 1 ) ; tr [ 2 ] . push_back ( 8 ) ; tr [ 8 ] . push_back ( 5 ) ; tr [ 5 ] . push_back ( 7 ) ; dfs ( val , cost , tr , 0 , 0 ) ; cout << n - cnt ; return 0 ; }
Find Second largest element in an array | Set 2 3665 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; vector < int > find@@ Lar@@ gest ( int beg , int end , vector < int > arr , int n ) { if ( beg == end ) { vector < int > compared ( n , 0 ) ; compared [ 0 ] = 1 ; compared [ 1 ] = arr [ beg ] ; return compared ; } vector < int > compare@@ d1 = find@@ Lar@@ gest ( beg , ( beg + end ) / 2 , arr , n ) ; vector < int > compare@@ d2 = find@@ Lar@@ gest ( ( beg + end ) / 2 + 1 , end , arr , n ) ; if ( compare@@ d1 [ 1 ] > compare@@ d2 [ 1 ] ) { int k = compare@@ d1 [ 0 ] + 1 ; compare@@ d1 [ 0 ] = k ; compare@@ d1 [ k ] = compare@@ d2 [ 1 ] ; return compare@@ d1 ; } else { int k = compare@@ d2 [ 0 ] + 1 ; compare@@ d2 [ 0 ] = k ; compare@@ d2 [ k ] = compare@@ d1 [ 1 ] ; return compare@@ d2 ; } } void find@@ Second@@ Lar@@ gest ( int end , vector < int > arr ) { vector < int > compare@@ d1 = find@@ Lar@@ gest ( 0 , end - 1 , arr , end ) ; vector < int > compare@@ d2 = find@@ Lar@@ gest ( 2 , compare@@ d1 [ 0 ] + 2 , compare@@ d1 , compare@@ d1 [ 0 ] ) ; cout << compare@@ d2 [ 1 ] ; } int main ( ) { int N = 10 ; vector < int > arr { 20 , 199@@ 0 , 12 , 11@@ 10 , 1 , 59 , 12 , 15 , 120 , 11@@ 10 } ; find@@ Second@@ Lar@@ gest ( N , arr ) ; return 0 ; }
Count of Reverse Bit@@ on@@ ic Sub@@ strings in a given String 3666 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int Count@@ sub@@ String ( char str [ ] , int n ) { int c = 0 ; for ( int len = 1 ; len <= n ; len ++ ) { for ( int i = 0 ; i <= n - len ; i ++ ) { int j = i + len - 1 ; char temp = str [ i ] , f = 0 ; if ( j == i ) { c ++ ; continue ; } int k = i + 1 ; while ( temp > str [ k ] && k <= j ) { temp = str [ k ] ; k ++ ; } if ( k > j ) { c ++ ; f = 2 ; } while ( temp < str [ k ] && k <= j && f != 2 ) { temp = str [ k ] ; k ++ ; } if ( k > j && f != 2 ) { c ++ ; f = 0 ; } } } return c ; } int main ( ) { char str [ ] = " ba@@ de " ; cout << Count@@ sub@@ String ( str , strlen ( str ) ) ; return 0 ; }
Construct a sequence from given frequencies of N consecutive integers with unit adjacent difference 3702 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; vector < int > generate@@ Sequence ( int * freq , int n ) { map < int , int > m ; int total = 0 ; for ( int i = 0 ; i < n ; i ++ ) { m [ i ] = freq [ i ] ; total += freq [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( m [ i ] ) { vector < int > sequence ; auto m@@ copy = m ; m@@ copy [ i ] -- ; sequence . push_back ( i ) ; int last = i ; for ( int i = 0 ; i < total - 1 ; i ++ ) { if ( m@@ copy [ last - 1 ] ) { m@@ copy [ last - 1 ] -- ; sequence . push_back ( last - 1 ) ; last -- ; } else if ( m@@ copy [ last + 1 ] ) { m@@ copy [ last + 1 ] -- ; sequence . push_back ( last + 1 ) ; last ++ ; } else break ; } if ( sequence . size ( ) == total ) { return sequence ; } } } vector < int > empty ; return empty ; } void Print@@ Sequence ( int freq [ ] , int n ) { vector < int > sequence = generate@@ Sequence ( freq , n ) ; if ( sequence . size ( ) == 0 ) { cout << " - 1" ; } else { for ( int i = 0 ; i < sequence . size ( ) ; i ++ ) { cout << sequence [ i ] << " ▁ " ; } } } int main ( ) { int freq [ ] = { 2 , 2 , 2 , 3 , 1 } ; int N = 5 ; Print@@ Sequence ( freq , N ) ; return 0 ; }
Change in Medi@@ an of given array after deleting given elements 3730 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void medi@@ an@@ Change ( vector < int > & ar@@ r1 , vector < int > & ar@@ r2 ) { int N = ar@@ r1 . size ( ) ; vector < float > median ; if ( N & 1 ) { median . push_back ( ar@@ r1 [ N / 2 ] * 1.0 ) ; } else { median . push_back ( ( ar@@ r1 [ N / 2 ] + ar@@ r1 [ ( N - 1 ) / 2 ] ) / 2.0 ) ; } for ( auto & x : ar@@ r2 ) { auto it = find ( ar@@ r1 . begin ( ) , ar@@ r1 . end ( ) , x ) ; ar@@ r1 . erase ( it ) ; N -- ; if ( N & 1 ) { median . push_back ( ar@@ r1 [ N / 2 ] * 1.0 ) ; } else { median . push_back ( ( ar@@ r1 [ N / 2 ] + ar@@ r1 [ ( N - 1 ) / 2 ] ) / 2.0 ) ; } } for ( int i = 0 ; i < median . size ( ) - 1 ; i ++ ) { cout << median [ i + 1 ] - median [ i ] << ' ▁ ' ; } } int main ( ) { vector < int > ar@@ r1 = { 2 , 4 , 6 , 8 , 10 } ; vector < int > ar@@ r2 = { 4 , 6 } ; medi@@ an@@ Change ( ar@@ r1 , ar@@ r2 ) ; return 0 ; }
Count of distinct power of prime factor of N 3737 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Fa@@ c ( int n ) { int m = n ; int count = 0 ; for ( int i = 2 ; ( i * i ) <= m ; ++ i ) { int total = 0 ; while ( n % i == 0 ) { n /= i ; ++ total ; } int temp = 0 ; for ( int j = 1 ; ( temp + j ) <= total ; ++ j ) { temp += j ; ++ count ; } } if ( n != 1 ) ++ count ; return count ; } int main ( ) { int N = 24 ; cout << count@@ Fa@@ c ( N ) ; return 0 ; }
Find the missing number in unordered Arith@@ metic Prog@@ ression 3742 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Missing ( int arr [ ] , int left , int right , int diff ) { if ( right <= left ) return INT_MAX ; int mid = left + ( right - left ) / 2 ; if ( arr [ mid + 1 ] - arr [ mid ] != diff ) return ( arr [ mid ] + diff ) ; if ( mid > 0 && arr [ mid ] - arr [ mid - 1 ] != diff ) return ( arr [ mid - 1 ] + diff ) ; if ( arr [ mid ] == arr [ 0 ] + mid * diff ) return find@@ Missing ( arr , mid + 1 , right , diff ) ; return find@@ Missing ( arr , left , mid - 1 , diff ) ; } int missing@@ Element ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int diff = ( arr [ n - 1 ] - arr [ 0 ] ) / n ; return find@@ Missing ( arr , 0 , n - 1 , diff ) ; } int main ( ) { int arr [ ] = { 2 , 8 , 6 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << missing@@ Element ( arr , n ) ; return 0 ; }
Minimum value of K such that sum of cub@@ es of first K natural number is greater than equal to N 3757 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int nai@@ ve_@@ find_@@ x ( int N ) { int c = 0 , i ; for ( i = 1 ; i < N ; i ++ ) { c += i * i * i ; if ( c >= N ) break ; } return i ; } int main ( ) { int N = 100 ; cout << nai@@ ve_@@ find_@@ x ( N ) ; return 0 ; }
XOR of pairwise sum of every unordered pairs in an array 3795 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int xor@@ Of@@ Sum ( int a [ ] , int n ) { int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) answer ^= ( a [ i ] + a [ j ] ) ; } return answer ; } int main ( ) { int n = 3 ; int A [ n ] = { 1 , 2 , 3 } ; cout << xor@@ Of@@ Sum ( A , n ) ; return 0 ; }
Lar@@ gest and smallest Fi@@ bon@@ ac@@ ci numbers in an Array 3798 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void create@@ Hash ( set < int > & hash , int max@@ Element ) { int prev = 0 , curr = 1 ; hash . insert ( prev ) ; hash . insert ( curr ) ; while ( curr <= max@@ Element ) { int temp = curr + prev ; hash . insert ( temp ) ; prev = curr ; curr = temp ; } } void fi@@ bon@@ ac@@ ci ( int arr [ ] , int n ) { int max_@@ val = * max_@@ element ( arr , arr + n ) ; set < int > hash ; create@@ Hash ( hash , max_@@ val ) ; int minimum = INT_MAX ; int maximum = INT_@@ MIN ; for ( int i = 0 ; i < n ; i ++ ) { if ( hash . find ( arr [ i ] ) != hash . end ( ) ) { minimum = min ( minimum , arr [ i ] ) ; maximum = max ( maximum , arr [ i ] ) ; } } cout << minimum << " , ▁ " << maximum << endl ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; fi@@ bon@@ ac@@ ci ( arr , n ) ; return 0 ; }
Check if an Array is a permutation of numbers from 1 to N 3802 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool permutation ( int arr [ ] , int n ) { set < int > hash ; int max@@ E@@ le = 0 ; for ( int i = 0 ; i < n ; i ++ ) { hash . insert ( arr [ i ] ) ; max@@ E@@ le = max ( max@@ E@@ le , arr [ i ] ) ; } if ( max@@ E@@ le != n ) return false ; if ( hash . size ( ) == n ) return true ; return false ; } int main ( ) { int arr [ ] = { 1 , 2 , 5 , 3 , 2 } ; int n = sizeof ( arr ) / sizeof ( int ) ; if ( permutation ( arr , n ) ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
Minimum increments to convert to an array of consecutive integers 3868 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool check ( int m , int n , int arr [ ] ) { int desired [ n ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { desired [ i ] = m ; m -- ; } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > desired [ i ] desired [ i ] < 1 ) { return false ; } } return true ; } int min@@ Operations ( int arr [ ] , int n ) { int start = ( int ) arr [ n - 1 ] ; int end = * ( max_@@ element ( arr , arr + n ) ) + n ; int max_@@ arr = 0 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( check ( mid , n , arr ) ) { max_@@ arr = mid ; end = mid - 1 ; } else { start = mid + 1 ; } } int desired [ n ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { desired [ i ] = max_@@ arr ; max_@@ arr -- ; } int operations = 0 ; for ( int i = 0 ; i < n ; i ++ ) { operations += ( desired [ i ] - arr [ i ] ) ; } return operations ; } int main ( ) { int arr [ ] = { 4 , 4 , 5 , 5 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << min@@ Operations ( arr , n ) ; return 0 ; }
Cost to make a string Pan@@ agram | Set 2 3917 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int cost@@ To@@ Pan@@ agram ( string str , int cost [ ] ) { int i , n = str . length ( ) ; int occurrences [ 26 ] = { 0 } ; for ( i = 0 ; i < n ; i ++ ) occurrences [ str [ i ] - ' a ' ] ++ ; int gain = 0 ; for ( i = 0 ; i < 26 ; i ++ ) { if ( occurrences [ i ] == 0 ) gain -= ( 2 * cost [ i ] ) ; else if ( occurrences [ i ] > 1 ) gain += ( cost [ i ] * ( occurrences [ i ] - 1 ) ) ; } if ( gain >= 0 ) return 0 ; return ( gain * -1 ) ; } int main ( ) { int cost [ ] = { 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 } ; string str = " ge@@ ek@@ s@@ forge@@ e@@ ks " ; cout << cost@@ To@@ Pan@@ agram ( str , cost ) ; }
Weigh@@ ted sum of the characters of a string in an array | Set 2 3918 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int str@@ Score ( string str [ ] , string s , int n ) { unordered_map < string , int > m ; for ( int i = 0 ; i < n ; i ++ ) m [ str [ i ] ] = i + 1 ; if ( m . find ( s ) == m . end ( ) ) return 0 ; int score = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) score += s [ i ] - ' a ' + 1 ; score = score * m [ s ] ; return score ; } int main ( ) { string str [ ] = { " ge@@ ek@@ s@@ forge@@ e@@ ks " , " algorithms " , " stack " } ; string s = " algorithms " ; int n = sizeof ( str ) / sizeof ( str [ 0 ] ) ; int score = str@@ Score ( str , s , n ) ; cout << score ; return 0 ; }
Replace all occurrences of pi with 3.14 in a given string 3966 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; string replace@@ Pi ( string input ) { string output ; int size = input . length ( ) ; for ( int i = 0 ; i < size ; ++ i ) { if ( i + 1 < size and input [ i ] == ' p ' and input [ i + 1 ] == ' i ' ) { output += "@@ 3.14@@ " ; i ++ ; } else { output += input [ i ] ; } } return output ; } int main ( ) { string input = "2 ▁ * ▁ pi ▁ + ▁ 3 ▁ * ▁ pi ▁ = ▁ 5 ▁ * ▁ pi " ; cout << replace@@ Pi ( input ) ; return 0 ; }
Number of elements that can be seen from right side 3968 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int numberOf@@ Elements ( int height [ ] , int n ) { int max_@@ so@@ _f@@ ar = 0 ; int co@@ un = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( height [ i ] > max_@@ so@@ _f@@ ar ) { max_@@ so@@ _f@@ ar = height [ i ] ; co@@ un ++ ; } } return co@@ un ; } int main ( ) { int n = 6 ; int height [ ] = { 4 , 8 , 2 , 0 , 0 , 5 } ; cout << numberOf@@ Elements ( height , n ) ; return 0 ; }
Sum and Product of minimum and maximum element of an Array 3980 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int get@@ Min ( int arr [ ] , int n ) { int res = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) res = min ( res , arr [ i ] ) ; return res ; } int getMax ( int arr [ ] , int n ) { int res = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) res = max ( res , arr [ i ] ) ; return res ; } int find@@ Sum ( int arr [ ] , int n ) { int min = get@@ Min ( arr , n ) ; int max = getMax ( arr , n ) ; return min + max ; } int find@@ Product ( int arr [ ] , int n ) { int min = get@@ Min ( arr , n ) ; int max = getMax ( arr , n ) ; return min * max ; } int main ( ) { int arr [ ] = { 12 , 1234 , 45 , 67 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Sum ▁ = ▁ " << find@@ Sum ( arr , n ) << endl ; cout << " Product ▁ = ▁ " << find@@ Product ( arr , n ) ; return 0 ; }
Sort the given string using character search 4061 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; string sort@@ String ( string str , int n ) { string new_@@ str = " " ; for ( int i = ' a ' ; i <= ' z ' ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( str [ j ] == i ) new_@@ str += str [ j ] ; return new_@@ str ; } int main ( ) { string str = " ge@@ ek@@ s@@ forge@@ e@@ ks " ; int n = str . size ( ) ; cout << sort@@ String ( str , n ) ; return 0 ; }
Find the number of times every day occurs in a month 4070 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void occurren@@ ce@@ Days ( int n , string first@@ day ) { string days [ ] = { " Monday " , " T@@ ue@@ sday " , " W@@ ed@@ ne@@ sday " , " Th@@ ur@@ sday " , " Fri@@ day " , " S@@ atur@@ day " , " Sunday " } ; int count [ 7 ] ; for ( int i = 0 ; i < 7 ; i ++ ) count [ i ] = 4 ; int pos ; for ( int i = 0 ; i < 7 ; i ++ ) { if ( first@@ day == days [ i ] ) { pos = i ; break ; } } int inc = n - 28 ; for ( int i = pos ; i < pos + inc ; i ++ ) { if ( i > 6 ) count [ i % 7 ] = 5 ; else count [ i ] = 5 ; } for ( int i = 0 ; i < 7 ; i ++ ) { cout << days [ i ] << " ▁ " << count [ i ] << endl ; } } int main ( ) { int n = 31 ; string first@@ day = " T@@ ue@@ sday " ; occurren@@ ce@@ Days ( n , first@@ day ) ; return 0 ; }
Random@@ ized Binary Search Algorithm 4107 | #@@ include <@@ io@@ stream@@ > NEW_LINE #@@ include <@@ c@@ time@@ > NEW_LINE using namespace std ; int get@@ Random ( int x , int y ) { srand ( time ( NULL ) ) ; return ( x + rand ( ) % ( y - x + 1 ) ) ; } int random@@ ized@@ Binary@@ Search ( int arr [ ] , int l , int r , int x ) { while ( l <= r ) { int m = get@@ Random ( l , r ) ; if ( arr [ m ] == x ) return m ; if ( arr [ m ] < x ) l = m + 1 ; else r = m - 1 ; } return -1 ; } int main ( void ) { int arr [ ] = { 2 , 3 , 4 , 10 , 40 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 10 ; int result = random@@ ized@@ Binary@@ Search ( arr , 0 , n - 1 , x ) ; ( result == -1 ) ? printf ( " Element ▁ is ▁ not ▁ present ▁ in ▁ array " ) : printf ( " Element ▁ is ▁ present ▁ at ▁ index ▁ % d " , result ) ; return 0 ; }
Check if an array of pairs can be sorted by sw@@ apping pairs with different first elements 4137 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Sorted ( pair < int , int > * arr , int N ) { for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] . first > arr [ i - 1 ] . first ) { return false ; } } return true ; } string is@@ Possible@@ To@@ Sort ( pair < int , int > * arr , int N ) { int group = arr [ 0 ] . second ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] . second != group ) { return " Yes " ; } } if ( is@@ Sorted ( arr , N ) ) { return " Yes " ; } else { return " No " ; } } int main ( ) { pair < int , int > arr [ ] = { { 34@@ 0000 , 2 } , { 45@@ 000 , 1 } , { 30000 , 2 } , { 50000 , 4 } } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << is@@ Possible@@ To@@ Sort ( arr , N ) ; return 0 ; }
Length of longest strictly increasing subset with each pair of adjacent elements satis@@ fying the condition 2 * A [ i ] â ‰@@ ¥ A [ i + 1 ] 4150 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void max@@ Len@@ Subset ( int a [ ] , int n ) { sort ( a , a + n ) ; int index = 0 , maxlen = -1 ; int i = 0 ; while ( i < n ) { int j = i ; int len = 1 ; while ( j < n - 1 ) { if ( 2 * a [ j ] >= a [ j + 1 ] ) { len ++ ; } else break ; j ++ ; } if ( maxlen < len ) { maxlen = len ; index = i ; } j ++ ; i = j ; } i = index ; while ( maxlen > 0 ) { cout << a [ i ] << " ▁ " ; maxlen -- ; i ++ ; } } int main ( ) { int a [ ] = { 3 , 1 , 5 , 11 } ; int n = sizeof ( a ) / sizeof ( int ) ; max@@ Len@@ Subset ( a , n ) ; return 0 ; }
Maximum sum of absolute differences between distinct pairs of a trip@@ let from an array 4171 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void maximum@@ Sum ( int arr [ ] , int N ) { int sum ; sort ( arr , arr + N ) ; sum = ( arr [ N - 1 ] - arr [ 0 ] ) + ( arr [ N - 2 ] - arr [ 0 ] ) + ( arr [ N - 1 ] - arr [ N - 2 ] ) ; cout << sum ; } int main ( ) { int arr [ ] = { 1 , 3 , 4 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; maximum@@ Sum ( arr , N ) ; return 0 ; }
Make the array elements equal by performing given operations minimum number of times 4191 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void min@@ Operation ( int a [ ] , int N ) { int tot@@ Ops = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { tot@@ Ops += abs ( a [ i ] - a [ i + 1 ] ) ; } int max@@ Ops = max ( abs ( a [ 0 ] - a [ 1 ] ) , abs ( a [ N - 1 ] - a [ N - 2 ] ) ) ; for ( int i = 1 ; i < N - 1 ; i ++ ) { max@@ Ops = max ( max@@ Ops , abs ( a [ i ] - a [ i - 1 ] ) + abs ( a [ i ] - a [ i + 1 ] ) - abs ( a [ i - 1 ] - a [ i + 1 ] ) ) ; } cout << tot@@ Ops - max@@ Ops << endl ; } int main ( ) { int arr [ ] = { 1 , -1 , 0 , 1 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; min@@ Operation ( arr , N ) ; return 0 ; }
Minimum increments or decre@@ ments by D required to make all array elements equal 4215 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void num@@ Operation ( int arr [ ] , int N , int D ) { sort ( arr , arr + N ) ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( ( arr [ i + 1 ] - arr [ i ] ) % D != 0 ) { cout << " - 1" ; return ; } } int count = 0 ; int mid = arr [ N / 2 ] ; for ( int i = 0 ; i < N ; i ++ ) { count += abs ( mid - arr [ i ] ) / D ; } cout << count ; } int main ( ) { int N = 4 , D = 2 ; int arr [ ] = { 2 , 4 , 6 , 8 } ; num@@ Operation ( arr , N , D ) ; }
Maxim@@ ize sum of second minimum@@ s of each K length partitions of the array 4216 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ Sum ( int A [ ] , int N , int K ) { sort ( A , A + N ) ; int sum = 0 ; for ( int i = N / K ; i < N ; i += K - 1 ) { sum += A [ i ] ; } cout << sum ; } int main ( ) { int K = 4 ; int A [ ] = { 2 , 3 , 1 , 4 , 7 , 5 , 6 , 1 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; find@@ Sum ( A , N , K ) ; return 0 ; }
Count pairs ( i , j ) from given array such that i K * arr [ j ] 4238 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int merge ( int arr [ ] , int temp [ ] , int l , int m , int r , int K ) { int i = l ; int j = m + 1 ; int cnt = 0 ; for ( int l = 0 ; i <= m ; i ++ ) { bool found = false ; while ( j <= r ) { if ( arr [ i ] >= K * arr [ j ] ) { found = true ; } else break ; j ++ ; } if ( found ) { cnt += j - ( m + 1 ) ; j -- ; } } int k = l ; i = l ; j = m + 1 ; while ( i <= m && j <= r ) { if ( arr [ i ] <= arr [ j ] ) temp [ k ++ ] = arr [ i ++ ] ; else temp [ k ++ ] = arr [ j ++ ] ; } while ( i <= m ) temp [ k ++ ] = arr [ i ++ ] ; while ( j <= r ) temp [ k ++ ] = arr [ j ++ ] ; for ( int i = l ; i <= r ; i ++ ) arr [ i ] = temp [ i ] ; return cnt ; } int merge@@ Sort@@ Util ( int arr [ ] , int temp [ ] , int l , int r , int K ) { int cnt = 0 ; if ( l < r ) { int m = ( l + r ) / 2 ; cnt += merge@@ Sort@@ Util ( arr , temp , l , m , K ) ; cnt += merge@@ Sort@@ Util ( arr , temp , m + 1 , r , K ) ; cnt += merge ( arr , temp , l , m , r , K ) ; } return cnt ; } int merge@@ Sort ( int arr [ ] , int N , int K ) { int temp [ N ] ; cout << merge@@ Sort@@ Util ( arr , temp , 0 , N - 1 , K ) ; } int main ( ) { int arr [ ] = { 5 , 6 , 2 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 2 ; merge@@ Sort ( arr , N , K ) ; return 0 ; }
Selection Sort VS Bu@@ bble Sort 4241 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; void Bubble@@ _S@@ ort ( int arr [ ] , int n ) { bool flag ; for ( int i = 1 ; i < n ; ++ i ) { flag = false ; for ( int j = 0 ; j <= ( n - i - 1 ) ; ++ j ) { if ( arr [ j ] > arr [ j + 1 ] ) { swap ( arr [ j ] , arr [ j + 1 ] ) ; flag = true ; } } if ( flag == false ) break ; } } int main ( ) { int n = 5 ; int arr [ 5 ] = { 2 , 0 , 1 , 4 , 3 } ; Bubble@@ _S@@ ort ( arr , n ) ; cout << " The ▁ Sorted ▁ Array ▁ by ▁ using ▁ Bu@@ bble ▁ Sort ▁ is ▁ : ▁ " ; for ( int i = 0 ; i < n ; ++ i ) cout << arr [ i ] << " ▁ " ; return 0 ; }
Minim@@ ize consecutive remo@@ vals of elements of the same type to empty given array 4249 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void min@@ Remo@@ vals ( int A [ ] , int N ) { sort ( A , A + N ) ; int mx = A [ N - 1 ] ; int sum = 1 ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; } if ( sum - mx >= mx ) { cout << 0 << " STRNEWLINE " ; } else { cout << 2 * mx - sum << " STRNEWLINE " ; } } int main ( ) { int A [ ] = { 3 , 3 , 2 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; min@@ Remo@@ vals ( A , N ) ; return 0 ; }
Area of the largest rectangle formed by lines parallel to X and Y axis from given set of points 4272 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max@@ Rectangle ( vector < vector < int > > sequence , int size ) { long long int X_@@ C@@ ord [ size ] , Y_@@ C@@ ord [ size ] ; for ( int i = 0 ; i < size ; i ++ ) { X_@@ C@@ ord [ i ] = sequence [ i ] [ 0 ] ; Y_@@ C@@ ord [ i ] = sequence [ i ] [ 1 ] ; } sort ( X_@@ C@@ ord , X_@@ C@@ ord + size ) ; sort ( Y_@@ C@@ ord , Y_@@ C@@ ord + size ) ; long long int X_@@ Max = 0 , Y_@@ Max = 0 ; for ( int i = 0 ; i < size - 1 ; i ++ ) { X_@@ Max = max ( X_@@ Max , X_@@ C@@ ord [ i + 1 ] - X_@@ C@@ ord [ i ] ) ; Y_@@ Max = max ( Y_@@ Max , Y_@@ C@@ ord [ i + 1 ] - Y_@@ C@@ ord [ i ] ) ; } return X_@@ Max * Y_@@ Max ; } int main ( ) { vector < vector < int > > point = { { -2 , 0 } , { 2 , 0 } , { 4 , 0 } , { 4 , 2 } } ; int n = point . size ( ) ; cout << max@@ Rectangle ( point , n ) ; }
Re@@ arrange two given arrays such that sum of same indexed elements lies within given range 4275 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void check@@ Arrange@@ ment ( int A1 [ ] , int A2 [ ] , int n , int k ) { sort ( A1 , A1 + n ) ; sort ( A2 , A2 + n , greater < int > ( ) ) ; int flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( A1 [ i ] + A2 [ i ] > k ) || ( A1 [ i ] + A2 [ i ] < k / 2 ) ) { flag = 1 ; break ; } } if ( flag == 1 ) cout << " No " ; else cout << " Yes " ; } int main ( ) { int ar@@ r1 [ ] = { 1 , 3 , 4 , 5 } ; int ar@@ r2 [ ] = { 2 , 0 , 1 , 1 } ; int K = 6 ; int N = sizeof ( ar@@ r1 ) / sizeof ( ar@@ r1 [ 0 ] ) ; check@@ Arrange@@ ment ( ar@@ r1 , ar@@ r2 , N , K ) ; return 0 ; }
Check if a decre@@ asing Array can be sorted using Triple cyclic shift 4358 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void sort@@ array ( int arr [ ] , int N ) { if ( N == 3 ) cout << " NO " << endl ; else if ( N % 4 == 0 N % 4 == 1 ) { cout << " YES " << endl ; cout << ( N / 2 ) << endl ; int k = 1 ; for ( int l = 0 ; l < ( N / 4 ) ; l ++ ) { cout << k << " ▁ " << k + 1 << " ▁ " << N << endl ; cout << k + 1 << " ▁ " << N << " ▁ " << N - 1 << endl ; k = k + 2 ; N = N - 2 ; } } else cout << " NO " << endl ; } int main ( ) { int N = 5 ; int arr [ ] = { 5 , 4 , 3 , 2 , 1 } ; sort@@ array ( arr , N ) ; return 0 ; }
Minim@@ ize sum of smallest elements from K sub@@ sequences of length L 4369 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Min@@ Sum ( int arr [ ] , int K , int L , int size ) { if ( K * L > size ) return -1 ; int min@@ sum = 0 ; sort ( arr , arr + size ) ; for ( int i = 0 ; i < K ; i ++ ) min@@ sum += arr [ i ] ; return min@@ sum ; } int main ( ) { int arr [ ] = { 2 , 15 , 5 , 1 , 35 , 16 , 67 , 10 } ; int K = 3 ; int L = 2 ; int length = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << find@@ Min@@ Sum ( arr , K , L , length ) ; return 0 ; }
K@@ th smallest or largest element in un@@ sorted Array | Set 4 4378 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int find@@ K@@ th@@ S@@ malle@@ st ( int arr [ ] , int n , int k ) { int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } int counter [ max + 1 ] = { 0 } ; int smallest = 0 ; for ( int i = 0 ; i < n ; i ++ ) { counter [ arr [ i ] ] ++ ; } for ( int num = 1 ; num <= max ; num ++ ) { if ( counter [ num ] > 0 ) { smallest += counter [ num ] ; } if ( smallest >= k ) { return num ; } } } int main ( ) { int arr [ ] = { 7 , 1 , 4 , 4 , 20 , 15 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 5 ; cout << find@@ K@@ th@@ S@@ malle@@ st ( arr , N , K ) ; return 0 ; }
Sort Matrix in altern@@ ating ascending and descending order row@@ wise 4392 | #@@ include <@@ st@@ dio@@ .@@ h@@ > NEW_LINE #@@ define N 4 NEW_LINE void func ( int a [ ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) { if ( i % 2 == 0 ) { for ( int j = 0 ; j < N ; j ++ ) { for ( int k = j + 1 ; k < N ; ++ k ) { if ( a [ i ] [ j ] > a [ i ] [ k ] ) { int temp = a [ i ] [ j ] ; a [ i ] [ j ] = a [ i ] [ k ] ; a [ i ] [ k ] = temp ; } } } } else { for ( int j = 0 ; j < N ; j ++ ) { for ( int k = j + 1 ; k < N ; ++ k ) { if ( a [ i ] [ j ] < a [ i ] [ k ] ) { int temp = a [ i ] [ j ] ; a [ i ] [ j ] = a [ i ] [ k ] ; a [ i ] [ k ] = temp ; } } } } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { printf ( " % d ▁ " , a [ i ] [ j ] ) ; } printf ( " STRNEWLINE " ) ; } } int main ( ) { int a [ N ] [ N ] = { { 5 , 7 , 3 , 4 } , { 9 , 5 , 8 , 2 } , { 6 , 3 , 8 , 1 } , { 5 , 8 , 9 , 3 } } ; func ( a ) ; return 0 ; }
Find weight of M@@ ST in a complete graph with edge 4412 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; map < int , int > g [ 2@@ 0000@@ 5 ] ; set < int > s , ns ; void dfs ( int x ) { vector < int > v ; v . clear ( ) ; ns . clear ( ) ; for ( int it : s ) { if ( ! g [ x ] [ it ] ) { v . push_back ( it ) ; } else { ns . insert ( it ) ; } } s = ns ; for ( int i : v ) { dfs ( i ) ; } } void weight@@ Of@@ M@@ ST ( int N ) { int cnt = 0 ; for ( int i = 1 ; i <= N ; ++ i ) { s . insert ( i ) ; } for ( ; s . size ( ) ; ) { ++ cnt ; int t = * s . begin ( ) ; s . erase ( t ) ; dfs ( t ) ; } cout << cnt - 1 ; } int main ( ) { int N = 6 , M = 11 ; int edges [ ] [ ] = { { 1 , 3 } , { 1 , 4 } , { 1 , 5 } , { 1 , 6 } , { 2 , 3 } , { 2 , 4 } , { 2 , 5 } , { 2 , 6 } , { 3 , 4 } , { 3 , 5 } , { 3 , 6 } } ; for ( int i = 0 ; i < M ; ++ i ) { int u = edges [ i ] [ 0 ] ; int v = edges [ i ] [ 1 ] ; g [ u ] [ v ] = 1 ; g [ v ] [ u ] = 1 ; } weight@@ Of@@ M@@ ST ( N ) ; return 0 ; }
Sort elements of an array in increasing order of absolute difference of adjacent elements 4414 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void sort@@ Diff ( vector < int > arr , int n ) { sort ( arr . begin ( ) , arr . end ( ) ) ; vector < int > out ; while ( n > 0 ) { out . push_back ( arr [ n / 2 ] ) ; arr . erase ( arr . begin ( ) + n / 2 ) ; n = n - 1 ; } for ( auto i : out ) cout << i << " ▁ " ; } int main ( ) { vector < int > a = { 8 , 1 , 2 , 3 , 0 } ; int n = 5 ; sort@@ Diff ( a , n ) ; }
Count of distinct possible pairs such that the element from A is greater than the element from B 4420 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Pairs ( vector < int > A , vector < int > B ) { int n = A . size ( ) ; sort ( A . begin ( ) , A . end ( ) ) ; sort ( B . begin ( ) , B . end ( ) ) ; int ans = 0 , i ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] > B [ ans ] ) { ans ++ ; } } return ans ; } int main ( ) { vector < int > A = { 30 , 28 , 45 , 22 } ; vector < int > B = { 35 , 25 , 22 , 48 } ; cout << count@@ Pairs ( A , B ) ; return 0 ; }
Sort the Array by rever@@ sing the numbers in it 4450 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int rever@@ s@@ Digits ( int num ) { int rev_@@ num = 0 ; while ( num > 0 ) { rev_@@ num = rev_@@ num * 10 + num % 10 ; num = num / 10 ; } return rev_@@ num ; } void sort@@ Arr ( int arr [ ] , int n ) { vector < pair < int , int > > vp ; for ( int i = 0 ; i < n ; i ++ ) { vp . push_back ( make_pair ( rever@@ s@@ Digits ( arr [ i ] ) , arr [ i ] ) ) ; } sort ( vp . begin ( ) , vp . end ( ) ) ; for ( int i = 0 ; i < vp . size ( ) ; i ++ ) cout << vp [ i ] . second << " ▁ " ; } int main ( ) { int arr [ ] = { 12 , 10 , 102 , 31 , 15 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sort@@ Arr ( arr , n ) ; return 0 ; }
Ar@@ range numbers to form a valid sequence 4468 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; vector < int > org@@ az@@ ine@@ In@@ Order ( vector < int > vec , vector < int > op , int n ) { vector < int > result ( n ) ; sort ( vec . begin ( ) , vec . end ( ) ) ; int i = 0 , j = n - 1 , k = 0 ; while ( i <= j && k <= n - 2 ) { if ( op [ k ] == ' < ' ) { result [ k ] = vec [ i ++ ] ; } else { result [ k ] = vec [ j -- ] ; } k ++ ; } result [ n - 1 ] = vec [ i ] ; return result ; } int main ( ) { vector < int > vec ( { 8 , 2 , 7 , 1 , 5 , 9 } ) ; vector < int > op ( { ' > ' , ' > ' , ' < ' , ' > ' , ' < ' } ) ; vector < int > result = org@@ az@@ ine@@ In@@ Order ( vec , op , vec . size ( ) ) ; for ( int i = 0 ; i < result . size ( ) ; i ++ ) { cout << result [ i ] << " ▁ " ; } return 0 ; }
Find Partition Line such that sum of values on left and right is equal 4488 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; const int MAX = 1000 ; bool line@@ Exists ( int x [ ] , int y [ ] , int v [ ] , int n ) { int size = ( 2 * MAX ) + 1 ; long arr [ size ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { arr [ x [ i ] + MAX ] += v [ i ] ; } for ( int i = 1 ; i < size ; i ++ ) arr [ i ] += arr [ i - 1 ] ; if ( arr [ size - 1 ] == 0 ) return true ; if ( arr [ size - 1 ] - arr [ 0 ] == 0 ) return true ; for ( int i = 1 ; i < size - 1 ; i ++ ) { if ( arr [ i - 1 ] == arr [ size - 1 ] - arr [ i - 1 ] ) return true ; if ( arr [ i - 1 ] == arr [ size - 1 ] - arr [ i ] ) return true ; if ( arr [ i ] == arr [ size - 1 ] - arr [ i ] ) return true ; } if ( arr [ size - 2 ] == 0 ) return true ; return false ; } int main ( ) { int x [ ] = { -@@ 3 , 5 , 8 } ; int y [ ] = { 8 , 7 , 9 } ; int v [ ] = { 8 , 2 , 10 } ; int n = sizeof ( x ) / sizeof ( int ) ; if ( line@@ Exists ( x , y , v , n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
Maximum sum of minimum@@ s of pairs in an array 4490 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max@@ Sum ( int a [ ] , int n ) { sort ( a , a + n ) ; int sum = 0 ; for ( int i = 0 ; i < n - 1 ; i += 2 ) { sum += a [ i ] ; } return sum ; } int main ( ) { int arr [ ] = { 1 , 3 , 2 , 1 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << max@@ Sum ( arr , n ) ; return 0 ; }
Minimum increment operations to make K elements equal 4499 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int min@@ Operations ( vector < int > ar , int k ) { sort ( ar . begin ( ) , ar . end ( ) ) ; int ops@@ Needed = 0 ; for ( int i = 0 ; i < k ; i ++ ) { ops@@ Needed += ar [ k - 1 ] - ar [ i ] ; } int ans = ops@@ Needed ; for ( int i = k ; i < ar . size ( ) ; i ++ ) { ops@@ Needed = ops@@ Needed - ( ar [ i - 1 ] - ar [ i - k ] ) ; ops@@ Needed += ( k - 1 ) * ( ar [ i ] - ar [ i - 1 ] ) ; ans = min ( ans , ops@@ Needed ) ; } return ans ; } int main ( ) { vector < int > arr = { 3 , 1 , 9 , 100 } ; int n = arr . size ( ) ; int k = 3 ; cout << min@@ Operations ( arr , k ) ; return 0 ; }
Un@@ bounded Fr@@ actional K@@ nap@@ s@@ ack 4524 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; float kn@@ ap@@ S@@ ack ( int W , float wt [ ] , float val [ ] , int n ) { float max@@ ratio = INT_@@ MIN ; int max@@ index = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( val [ i ] / wt [ i ] ) > max@@ ratio ) { max@@ ratio = ( val [ i ] / wt [ i ] ) ; max@@ index = i ; } } return ( W * max@@ ratio ) ; } int main ( ) { float val [ ] = { 14 , 27 , 44 , 19 } ; float wt [ ] = { 6 , 7 , 9 , 8 } ; int n = sizeof ( val ) / sizeof ( val [ 0 ] ) ; int W = 50 ; cout << kn@@ ap@@ S@@ ack ( W , wt , val , n ) ; return 0 ; }
Merge two B@@ ST@@ s with constant extra space 4539 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; class Node { public : int data ; Node * left ; Node * right ; Node ( int x ) { data = x ; left = right = NULL ; } } ; void in@@ order ( Node * root ) { if ( root != NULL ) { in@@ order ( root -> left ) ; cout << root -> data << " ▁ " ; in@@ order ( root -> right ) ; } } void merge ( Node * roo@@ t1 , Node * root@@ 2 ) { if ( ! roo@@ t1 && ! root@@ 2 ) return ; if ( ! roo@@ t1 ) { in@@ order ( root@@ 2 ) ; return ; } if ( ! root@@ 2 ) { in@@ order ( roo@@ t1 ) ; return ; } Node * temp1 = roo@@ t1 ; Node * prev@@ 1 = NULL ; while ( temp1 -> left ) { prev@@ 1 = temp1 ; temp1 = temp1 -> left ; } Node * temp2 = root@@ 2 ; Node * pre@@ v2 = NULL ; while ( temp2 -> left ) { pre@@ v2 = temp2 ; temp2 = temp2 -> left ; } if ( temp1 -> data <= temp2 -> data ) { cout << temp1 -> data << " ▁ " ; if ( prev@@ 1 == NULL ) { merge ( roo@@ t1 -> right , root@@ 2 ) ; } else { prev@@ 1 -> left = temp1 -> right ; merge ( roo@@ t1 , root@@ 2 ) ; } } else { cout << temp2 -> data << " ▁ " ; if ( pre@@ v2 == NULL ) { merge ( roo@@ t1 , root@@ 2 -> right ) ; } else { pre@@ v2 -> left = temp2 -> right ; merge ( roo@@ t1 , root@@ 2 ) ; } } } int main ( ) { Node * roo@@ t1 = NULL , * root@@ 2 = NULL ; roo@@ t1 = new Node ( 3 ) ; roo@@ t1 -> left = new Node ( 1 ) ; roo@@ t1 -> right = new Node ( 5 ) ; root@@ 2 = new Node ( 4 ) ; root@@ 2 -> left = new Node ( 2 ) ; root@@ 2 -> right = new Node ( 6 ) ; merge ( roo@@ t1 , root@@ 2 ) ; return 0 ; }
Count number of subsets whose median is also present in the same subset 4561 | #@@ include <@@ algorithm@@ > NEW_LINE #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; long long mod = 100000000@@ 7 ; long long arr [ 1001 ] [ 1001 ] ; void Pre@@ process ( ) { arr [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= 1000 ; ++ i ) { arr [ i ] [ 0 ] = 1 ; for ( int j = 1 ; j < i ; ++ j ) { arr [ i ] [ j ] = ( arr [ i - 1 ] [ j - 1 ] + arr [ i - 1 ] [ j ] ) % mod ; } arr [ i ] [ i ] = 1 ; } } long long pow@@ mod ( long long a , long long n ) { if ( ! n ) return 1 ; long long pt = pow@@ mod ( a , n / 2 ) ; pt = ( pt * pt ) % mod ; if ( n % 2 ) return ( pt * a ) % mod ; else return pt ; } long long Count@@ Subset ( int * val , int n ) { long long ans = pow@@ mod ( 2 , n - 1 ) ; sort ( val , val + n ) ; for ( int i = 0 ; i < n ; ++ i ) { int j = i + 1 ; while ( j < n && val [ j ] == val [ i ] ) { int r = n - 1 - j ; int l = i ; ans = ( ans + arr [ l + r ] [ l ] ) % mod ; j ++ ; } } return ans ; } int main ( ) { Pre@@ process ( ) ; int val [ ] = { 2 , 3 , 2 } ; int n = sizeof ( val ) / sizeof ( val [ 0 ] ) ; cout << Count@@ Subset ( val , n ) << endl ; return 0 ; }
Re@@ order the position of the words in alphabe@@ tical order 4564 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void re@@ Ar@@ range ( string words [ ] , int n ) { map < string , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ words [ i ] ] = i + 1 ; sort ( words , words + n ) ; for ( int i = 0 ; i < n ; i ++ ) cout << mp [ words [ i ] ] << " ▁ " ; } int main ( ) { string words [ ] = { " live " , " place " , " travel " , " word " , " sky " } ; int n = sizeof ( words ) / sizeof ( words [ 0 ] ) ; re@@ Ar@@ range ( words , n ) ; }
Delete odd and even numbers at alternate step such that sum of remaining elements is minim@@ ized 4570 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int Minimize@@ left@@ Over@@ Sum ( int a [ ] , int n ) { vector < int > v1 , v2 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 ) v1 . push_back ( a [ i ] ) ; else v2 . push_back ( a [ i ] ) ; } if ( v1 . size ( ) > v2 . size ( ) ) { sort ( v1 . begin ( ) , v1 . end ( ) ) ; sort ( v2 . begin ( ) , v2 . end ( ) ) ; int x = v1 . size ( ) - v2 . size ( ) - 1 ; int sum = 0 ; int i = 0 ; while ( i < x ) { sum += v1 [ i ++ ] ; } return sum ; } else if ( v2 . size ( ) > v1 . size ( ) ) { sort ( v1 . begin ( ) , v1 . end ( ) ) ; sort ( v2 . begin ( ) , v2 . end ( ) ) ; int x = v2 . size ( ) - v1 . size ( ) - 1 ; int sum = 0 ; int i = 0 ; while ( i < x ) { sum += v2 [ i ++ ] ; } return sum ; } else return 0 ; } int main ( ) { int a [ ] = { 2 , 2 , 2 , 2 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << Minimize@@ left@@ Over@@ Sum ( a , n ) ; return 0 ; }
Find A and B from list of di@@ visors 4588 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ Numbers ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int A = arr [ n - 1 ] , B = -1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( A % arr [ i ] != 0 ) { B = arr [ i ] ; break ; } if ( i - 1 >= 0 && arr [ i ] == arr [ i - 1 ] ) { B = arr [ i ] ; break ; } } cout << " A ▁ = ▁ " << A << " , ▁ B ▁ = ▁ " << B ; } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 8 , 16 , 1 , 2 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; print@@ Numbers ( arr , n ) ; return 0 ; }
Find the modified array after performing k operations of given type 4589 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ Array ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; } void remove@@ Min ( int arr [ ] , int n ) { int i , min@@ Val = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) min@@ Val = min ( min@@ Val , arr [ i ] ) ; for ( i = 0 ; i < n ; i ++ ) arr [ i ] = arr [ i ] - min@@ Val ; } void removeFrom@@ Max ( int arr [ ] , int n ) { int i , maxVal = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) maxVal = max ( maxVal , arr [ i ] ) ; for ( i = 0 ; i < n ; i ++ ) arr [ i ] = maxVal - arr [ i ] ; } void modify@@ Array ( int arr [ ] , int n , int k ) { if ( k % 2 == 0 ) remove@@ Min ( arr , n ) ; else removeFrom@@ Max ( arr , n ) ; print@@ Array ( arr , n ) ; } int main ( ) { int arr [ ] = { 4 , 8 , 12 , 16 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ; modify@@ Array ( arr , n , k ) ; return 0 ; }
Product of non 4656 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Product ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int prod = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) prod = prod * arr [ i ] ; } return prod ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 1 , 1 , 4 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << find@@ Product ( arr , n ) ; return 0 ; }
Sort 3 numbers 4687 | #@@ include <@@ algorithm@@ > NEW_LINE #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int main ( ) { int a [ ] = { 10 , 12 , 5 } ; sort ( a , a + 3 ) ; for ( int i = 0 ; i < 3 ; i ++ ) cout << a [ i ] << " ▁ " ; return 0 ; }
Subtr@@ action in the Array 4720 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define ll long long int NEW_LINE void operations ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; ll i = 0 , sum = 0 ; while ( k -- ) { while ( i < n && arr [ i ] - sum == 0 ) i ++ ; if ( i < n && arr [ i ] - sum > 0 ) { cout << arr [ i ] - sum << " ▁ " ; sum = arr [ i ] ; } else cout << 0 << endl ; } } int main ( ) { int k = 5 ; int arr [ ] = { 3 , 6 , 4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; operations ( arr , n , k ) ; return 0 ; }
Re@@ arrange an array to minimize sum of product of consecutive pair elements 4800 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int min@@ Sum ( int arr [ ] , int n ) { vector < int > even@@ Arr ; vector < int > odd@@ Arr ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n / 2 ) odd@@ Arr . push_back ( arr [ i ] ) ; else even@@ Arr . push_back ( arr [ i ] ) ; } sort ( even@@ Arr . begin ( ) , even@@ Arr . end ( ) , greater < int > ( ) ) ; int i = 0 , sum = 0 ; for ( int j = 0 ; j < even@@ Arr . size ( ) ; j ++ ) { arr [ i ++ ] = even@@ Arr [ j ] ; arr [ i ++ ] = odd@@ Arr [ j ] ; sum += even@@ Arr [ j ] * odd@@ Arr [ j ] ; } return sum ; } int main ( ) { int arr [ ] = { 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Minimum ▁ required ▁ sum ▁ = ▁ " << min@@ Sum ( arr , n ) ; cout << " Sorted array in required format : " ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
Sort even 4805 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void bit@@ on@@ ic@@ Generator ( int arr [ ] , int n ) { vector < int > even@@ Arr ; vector < int > odd@@ Arr ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! ( i % 2 ) ) even@@ Arr . push_back ( arr [ i ] ) ; else odd@@ Arr . push_back ( arr [ i ] ) ; } sort ( even@@ Arr . begin ( ) , even@@ Arr . end ( ) ) ; sort ( odd@@ Arr . begin ( ) , odd@@ Arr . end ( ) , greater < int > ( ) ) ; int i = 0 ; for ( int j = 0 ; j < even@@ Arr . size ( ) ; j ++ ) arr [ i ++ ] = even@@ Arr [ j ] ; for ( int j = 0 ; j < odd@@ Arr . size ( ) ; j ++ ) arr [ i ++ ] = odd@@ Arr [ j ] ; } int main ( ) { int arr [ ] = { 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; bit@@ on@@ ic@@ Generator ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
Sort an array according to count of set bits 4819 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Bits ( int a ) { int count = 0 ; while ( a ) { if ( a & 1 ) count += 1 ; a = a >> 1 ; } return count ; } void sort@@ By@@ Set@@ BitCount ( int arr [ ] , int n ) { vector < vector < int > > count ( 32 ) ; int set@@ bit@@ count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { set@@ bit@@ count = count@@ Bits ( arr [ i ] ) ; count [ set@@ bit@@ count ] . push_back ( arr [ i ] ) ; } for ( int i = 31 ; i >= 0 ; i -- ) { vector < int > v1 = count [ i ] ; for ( int i = 0 ; i < v1 . size ( ) ; i ++ ) arr [ j ++ ] = v1 [ i ] ; } } void print@@ Arr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sort@@ By@@ Set@@ BitCount ( arr , n ) ; print@@ Arr ( arr , n ) ; return 0 ; }
Minimum sum of two numbers formed from digits of an array 4826 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int solve ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int a = 0 , b = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i & 1 ) a = a * 10 + arr [ i ] ; else b = b * 10 + arr [ i ] ; } return a + b ; } int main ( ) { int arr [ ] = { 6 , 8 , 4 , 5 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Sum ▁ is ▁ " << solve ( arr , n ) ; return 0 ; }
K 4882 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; long long K@@ th@@ Solution ( long long X , long long K ) { long long ans = 0 ; for ( int i = 0 ; i < 64 ; i ++ ) { if ( ! ( X & ( 1@@ LL << i ) ) ) { if ( K & 1 ) { ans |= ( 1@@ LL << i ) ; } K >>= 1 ; if ( ! K ) { break ; } } } return ans ; } int main ( ) { long long X = 5 , K = 5 ; cout << K@@ th@@ Solution ( X , K ) ; return 0 ; }
Find an an@@ agram of given String having different characters at corresponding indices 4892 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ An@@ agram ( string s ) { string check = s ; int i = 0 , j = s . length ( ) - 1 ; while ( i < s . length ( ) && j >= 0 ) { if ( s [ i ] != s [ j ] && check [ i ] != s [ j ] && check [ j ] != s [ i ] ) { swap ( s [ i ] , s [ j ] ) ; i ++ ; j = s . length ( ) - 1 ; } else { j -- ; } } if ( s . length ( ) % 2 != 0 ) { int mid = s . length ( ) / 2 ; if ( check [ mid ] == s [ mid ] ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( check [ i ] != s [ mid ] && s [ i ] != s [ mid ] ) { swap ( s [ i ] , s [ mid ] ) ; break ; } } } } bool ok = true ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( check [ i ] == s [ i ] ) { ok = false ; break ; } } if ( ok ) cout << s ; else cout << -1 ; } int main ( ) { string S = " ge@@ ek " ; find@@ An@@ agram ( S ) ; return 0 ; }
Minimum time required to print given string from a circular container based on given conditions 4895 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void min@@ Time ( string word ) { int ans = 0 ; int curr = 0 ; for ( int i = 0 ; i < word . length ( ) ; i ++ ) { int k = word [ i ] - ' a ' ; int a = abs ( curr - k ) ; int b = 26 - abs ( curr - k ) ; ans += min ( a , b ) ; ans ++ ; curr = word [ i ] - ' a ' ; } cout << ans ; } int main ( ) { string str = " z@@ j@@ pc " ; min@@ Time ( str ) ; return 0 ; }
Generate an array of maximum sum such that each element exceeds all elements present either on its left or right 4913 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void maximum@@ Sum@@ Array ( int arr [ ] , int N ) { vector < int > arr@@ A ( N ) , ans ( N ) ; int max@@ Sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) arr@@ A [ i ] = arr [ i ] ; for ( int i = 0 ; i < N ; i ++ ) { vector < int > arr@@ B ( N ) ; int maximum = arr@@ A [ i ] ; arr@@ B [ i ] = maximum ; for ( int j = i - 1 ; j >= 0 ; j -- ) { arr@@ B [ j ] = min ( maximum , arr@@ A [ j ] ) ; maximum = arr@@ B [ j ] ; } maximum = arr@@ A [ i ] ; for ( int j = i + 1 ; j < N ; j ++ ) { arr@@ B [ j ] = min ( maximum , arr@@ A [ j ] ) ; maximum = arr@@ B [ j ] ; } int sum = 0 ; for ( int j = 0 ; j < N ; j ++ ) sum += arr@@ B [ j ] ; if ( sum > max@@ Sum ) { max@@ Sum = sum ; ans = arr@@ B ; } } for ( int val : ans ) { cout << val << " ▁ " ; } } int main ( ) { int A [ ] = { 10 , 6 , 8 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; maximum@@ Sum@@ Array ( A , N ) ; return 0 ; }
Lex@@ ico@@ graphic@@ ally largest string possible by repeatedly appending first character of two given strings 4921 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; string lar@@ gest@@ Merge ( string word@@ 1 , string word@@ 2 ) { string merge = " " ; while ( word@@ 1 . size ( ) != 0 || word@@ 2 . size ( ) != 0 ) { if ( word@@ 1 >= word@@ 2 ) { merge = merge + word@@ 1 [ 0 ] ; word@@ 1 . erase ( word@@ 1 . begin ( ) + 0 ) ; } else { merge = merge + word@@ 2 [ 0 ] ; word@@ 2 . erase ( word@@ 2 . begin ( ) + 0 ) ; } } return merge ; } int main ( ) { string S1 = " xyz@@ xyz " ; string S2 = " xy@@ wz@@ xy@@ x " ; cout << lar@@ gest@@ Merge ( S1 , S2 ) ; return 0 ; }
Count the combination of 4 s and / or 5 s required to make each Array element 0 4929 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void sum@@ Of@@ Combin@@ ation@@ Of@@ 4@@ OR@@ 5 ( vector < int > arr , int N ) { vector < int > ans ( N , -1 ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] < 4 ) { continue ; } int sum = INT_MAX , cnt = 0 ; for ( int j = 0 ; j <= arr [ i ] ; j += 4 ) { if ( ( arr [ i ] - j ) % 5 == 0 ) { sum = min ( sum , cnt + ( arr [ i ] - j ) / 5 ) ; } cnt ++ ; } if ( sum != INT_MAX ) ans [ i ] = sum ; } for ( auto num : ans ) cout << num << " ▁ " ; } int main ( ) { vector < int > arr = { 7 , 15 , 17 , 22 } ; int N = arr . size ( ) ; sum@@ Of@@ Combin@@ ation@@ Of@@ 4@@ OR@@ 5 ( arr , N ) ; return 0 ; }
Lex@@ ico@@ graphic@@ ally largest string possible by at most K replacements 4966 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; string lar@@ gest@@ String ( string s , int k ) { for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] != ' z ' && k > 0 ) { s [ i ] = ' z ' ; k -- ; } } return s ; } int main ( ) { string s = " db@@ za " ; int k = 1 ; cout << lar@@ gest@@ String ( s , k ) << endl ; return 0 ; }
Count characters of a string which when removed individ@@ ually makes the string equal to another string 4969 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void Remove@@ One@@ Char ( string A , string B , int N , int M ) { int X = 0 ; int Y = N - 1 ; for ( int i = 0 ; i < M ; i ++ ) { if ( A [ X ] != B [ i ] ) break ; X ++ ; } for ( int i = M - 1 ; i >= 0 ; i -- ) { if ( A [ Y ] != B [ i ] ) break ; Y -- ; } if ( N - M == 1 && Y < X ) { cout << X - Y + 1 << endl ; for ( int i = Y ; i <= X ; i ++ ) cout << i + 1 << " ▁ " ; cout << endl ; } else cout << -1 << endl ; } int main ( ) { string A = " ab@@ aa@@ c " ; string B = " ab@@ ac " ; int N = A . length ( ) ; int M = B . length ( ) ; Remove@@ One@@ Char ( A , B , N , M ) ; }
Count of pairs of integers up to X and Y that generates equal Quo@@ ti@@ ent and Remain@@ der 4974 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void count@@ Of@@ Pairs ( int x , int y ) { int count = 0 ; for ( int k = 1 ; k * k <= x ; ++ k ) { count += max ( 0 , min ( y , x / k - 1 ) - k ) ; } cout << count << " STRNEWLINE " ; } int main ( ) { int x = 4 ; int y = 5 ; count@@ Of@@ Pairs ( x , y ) ; return 0 ; }
Find the date after next half year from a given date 4981 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; void getDate ( int d , string m ) { int days [ ] = { 31 , 29 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 } ; string month [ ] = { " January " , " February " , " March " , " April " , " May " , " June " , " July " , " August " , " Sep@@ tember " , " Octo@@ ber " , " No@@ vember " , " December " } ; int cnt = 183 ; int cur_@@ month ; for ( int i = 0 ; i < 12 ; i ++ ) if ( m == month [ i ] ) cur_@@ month = i ; int cur_@@ date = d ; while ( 1 ) { while ( cnt > 0 && cur_@@ date <= days [ cur_@@ month ] ) { cnt -= 1 ; cur_@@ date += 1 ; } if ( cnt == 0 ) break ; cur_@@ month = ( cur_@@ month + 1 ) % 12 ; cur_@@ date = 1 ; } cout << cur_@@ date << " ▁ " << month [ cur_@@ month ] << endl ; } int main ( ) { int D = 15 ; string M = " January " ; getDate ( D , M ) ; return 0 ; }
Find the last element after repeatedly removing every second element from either end altern@@ ately 5011 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ Last@@ Element ( int arr [ ] , int N ) { bool left@@ Turn = true ; int remain@@ Elements = N ; int step = 1 ; int head = 1 ; while ( remain@@ Elements > 1 ) { if ( left@@ Turn ) { head = head + step ; } else { if ( remain@@ Elements % 2 == 1 ) head = head + step ; } remain@@ Elements = remain@@ Elements / 2 ; step = step * 2 ; left@@ Turn = ! left@@ Turn ; } cout << arr [ head - 1 ] ; } int main ( ) { int arr [ ] = { 2 , 3 , 5 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; print@@ Last@@ Element ( arr , N ) ; return 0 ; }
Check if a string can be split into 3 sub@@ strings such that one of them is a substring of the other two 5018 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; string freq@@ Check ( string S , int N ) { int hash [ 26 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { hash [ S [ i ] - ' a ' ] ++ ; } for ( int i = 0 ; i < 26 ; i ++ ) { if ( hash [ i ] > 2 ) { return " Yes " ; } } return " No " ; } int main ( ) { string S = " ge@@ ek@@ seek@@ forge@@ e@@ ks " ; int N = S . length ( ) ; cout << freq@@ Check ( S , N ) ; return 0 ; }
Minimum number of steps required to place all 1 s at a single index 5032 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void min@@ steps ( vector < int > & A ) { int n = A . size ( ) ; vector < int > left ( n , 0 ) , right ( n , 0 ) , res ( n , 0 ) ; int count = A [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { left [ i ] = left [ i - 1 ] + count ; count += A [ i ] ; } count = A [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { right [ i ] = right [ i + 1 ] + count ; count += A [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { res [ i ] = left [ i ] + right [ i ] ; cout << res [ i ] << " ▁ " ; } cout << " STRNEWLINE " ; } int main ( ) { vector < int > A = { 1 , 0 , 1 , 0 } ; min@@ steps ( A ) ; }
Minim@@ ize fli@@ ps on K 5033 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void minimum@@ Operations ( vector < int > & A , int K ) { vector < int > is@@ flipped ( A . size ( ) , 0 ) ; int ans = 0 ; for ( int i = 0 ; i < A . size ( ) ; i ++ ) { if ( i > 0 ) { is@@ flipped [ i ] += is@@ flipped [ i - 1 ] ; is@@ flipped [ i ] %= 2 ; } if ( A [ i ] == 0 && ! is@@ flipped [ i ] ) { if ( ( A . size ( ) - i + 1 ) <= K ) { cout << -1 ; return ; } ans ++ ; is@@ flipped [ i ] ++ ; is@@ flipped [ i + K ] -- ; } else if ( A [ i ] == 1 && is@@ flipped [ i ] ) { if ( ( A . size ( ) - i + 1 ) <= K ) { cout << -1 ; return ; } ans ++ ; is@@ flipped [ i ] ++ ; is@@ flipped [ i + K ] -- ; } } cout << ans ; } int main ( ) { vector < int > arr = { 0 , 1 , 0 } ; int K = 1 ; minimum@@ Operations ( arr , K ) ; return 0 ; }
Reduce all array elements to zero by performing given operations thri@@ ce 5054 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void Convert@@ Array ( int arr [ ] , int N ) { if ( N == 1 ) { cout << " Operation ▁ 1 ▁ : ▁ " << 1 << " ▁ " << 1 << endl ; cout << " Added ▁ elements : ▁ " << -1 * arr [ 0 ] << endl ; cout << endl ; cout << " Operation ▁ 2 ▁ : ▁ " << 1 << " ▁ " << 1 << endl ; cout << " Added ▁ elements : ▁ " << 1 * arr [ 0 ] << endl ; cout << endl ; cout << " Operation ▁ 3 ▁ : ▁ " << 1 << " ▁ " << 1 << endl ; cout << " Added ▁ elements : ▁ " << -1 * arr [ 0 ] << endl ; } else { cout << " Operation ▁ 1 ▁ : ▁ " << 1 << " ▁ " << N << endl ; cout << " Added ▁ elements : ▁ " ; for ( int i = 0 ; i < N ; i ++ ) { cout << -1 * arr [ i ] * N << " ▁ " ; } cout << endl ; cout << endl ; cout << " Operation ▁ 2 ▁ : ▁ " << 1 << " ▁ " << N - 1 << endl ; cout << " Added ▁ elements : ▁ " ; for ( int i = 0 ; i < N - 1 ; i ++ ) { cout << arr [ i ] * ( N - 1 ) << " ▁ " ; } cout << endl ; cout << endl ; cout << " Operation ▁ 3 ▁ : ▁ " << N << " ▁ " << N << endl ; cout << " Added ▁ elements : ▁ " ; cout << arr [ N - 1 ] * ( N - 1 ) << endl ; } } int main ( ) { int arr [ ] = { 1 , 3 , 2 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; Convert@@ Array ( arr , N ) ; return 0 ; }
Count pairs from an array with even product of count of distinct prime factors 5055 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define MAX 1000000 NEW_LINE void count@@ Of@@ Prime@@ factors ( vector < int > & Count@@ Distin@@ ct ) { bool prime [ MAX + 1 ] ; for ( int i = 0 ; i <= MAX ; i ++ ) { Count@@ Distin@@ ct [ i ] = 0 ; prime [ i ] = true ; } for ( long long int i = 2 ; i <= MAX ; i ++ ) { if ( prime [ i ] == true ) { Count@@ Distin@@ ct [ i ] = 1 ; for ( long long int j = i * 2 ; j <= MAX ; j += i ) { Count@@ Distin@@ ct [ j ] ++ ; prime [ j ] = false ; } } } } int Count@@ Even@@ Pair ( int A [ ] , int B [ ] , int N , int M ) { vector < int > count@@ Distin@@ ct ( MAX + 1 ) ; count@@ Of@@ Prime@@ factors ( count@@ Distin@@ ct ) ; int even@@ Count = 0 ; int odd@@ Count = 0 ; int even@@ Pairs = 0 ; for ( int i = 0 ; i < M ; i ++ ) { if ( count@@ Distin@@ ct [ B [ i ] ] == 0 ) continue ; if ( count@@ Distin@@ ct [ B [ i ] ] & 1 ) { odd@@ Count ++ ; } else { even@@ Count ++ ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( count@@ Distin@@ ct [ A [ i ] ] == 0 ) continue ; if ( count@@ Distin@@ ct [ A [ i ] ] & 1 ) { even@@ Pairs += ( even@@ Count ) ; } else { even@@ Pairs += even@@ Count + odd@@ Count ; } } return even@@ Pairs ; } int main ( ) { int A [ ] = { 1 , 2 , 3 } ; int B [ ] = { 4 , 5 , 6 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int M = sizeof ( B ) / sizeof ( B [ 0 ] ) ; cout << Count@@ Even@@ Pair ( A , B , N , M ) ; return 0 ; }
Minimum array elements required to be subtrac@@ ted from either end to reduce K to 0 5057 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int lon@@ gest@@ Sub@@ array ( int arr [ ] , int N , int K ) { unordered_map < int , int > um ; int sum = 0 , maxLen = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; if ( sum == K ) maxLen = i + 1 ; if ( um . find ( sum ) == um . end ( ) ) um [ sum ] = i ; if ( um . find ( sum - K ) != um . end ( ) ) { if ( maxLen < ( i - um [ sum - K ] ) ) maxLen = i - um [ sum - K ] ; } } return maxLen ; } void min@@ Required@@ Operation ( int arr [ ] , int N , int K ) { int Total@@ Sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) Total@@ Sum += arr [ i ] ; int maxLen = lon@@ gest@@ Sub@@ array ( arr , N , Total@@ Sum - K ) ; if ( maxLen == -1 ) { cout << -1 ; } else cout << N - maxLen ; } int main ( ) { int arr [ ] = { 1 , 3 , 1 , 1 , 2 } ; int K = 4 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; min@@ Required@@ Operation ( arr , N , K ) ; return 0 ; }
Count even and odd Bit@@ wise X@@ OR@@ s of consecutive numbers in a range [ L , R ] starting from L 5066 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void count@@ Even@@ Odd ( int L , int R ) { int range = R - L + 1 ; int even = ( range / 4 ) * 2 ; if ( ( L & 1 ) && ( range % 4 == 3 ) ) { even ++ ; } else if ( ! ( L & 1 ) && ( range % 4 ) ) { even ++ ; } cout << " Even ▁ = ▁ " << even << " , ▁ Odd ▁ = ▁ " << range - even ; } int main ( ) { int L = 2 , R = 7 ; count@@ Even@@ Odd ( L , R ) ; return 0 ; }
Count maximum number of consu@@ mable candi@@ es 5075 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int maximum@@ C@@ and@@ y ( int candi@@ es [ ] , int safety [ ] , int N , int M ) { int total = 0 ; int ans = INT_MAX ; bool all_@@ safe = true ; for ( int i = 0 ; i < N ; i ++ ) { if ( candi@@ es [ i ] + M > safety [ i ] ) { all_@@ safe = false ; ans = min ( ans , safety [ i ] ) ; } else { ans = min ( ans , candi@@ es [ i ] + M ) ; } total += candi@@ es [ i ] ; } if ( all_@@ safe ) return total ; else return ans ; } int main ( ) { int A [ ] = { 2 , 4 , 1 , 9 , 6 } ; int B [ ] = { 8 , 7 , 3 , 12 , 7 } ; int M = 0 ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << maximum@@ C@@ and@@ y ( A , B , N , M ) ; return 0 ; }
Generate an N 5081 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void construct_@@ Array ( int N , int K ) { for ( int i = 1 ; i <= N ; i ++ ) { cout << K * i << " ▁ " ; } } int main ( ) { int N = 3 , K = 3 ; construct_@@ Array ( N , K ) ; return 0 ; }
Generate an N 5083 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void Print ( int N ) { if ( ( N / 2 ) % 2 == 1 || ( N % 2 == 1 ) ) { cout << -1 << endl ; return ; } int Cur@@ Even = 2 , Cur@@ Odd = 1 ; int Sum@@ Odd = 0 , Sum@@ Even = 0 ; for ( int i = 0 ; i < ( N / 2 ) ; i ++ ) { cout << Cur@@ Even << " ▁ " ; Sum@@ Even += Cur@@ Even ; Cur@@ Even += 2 ; } for ( int i = 0 ; i < N / 2 - 1 ; i ++ ) { cout << Cur@@ Odd << " ▁ " ; Sum@@ Odd += Cur@@ Odd ; Cur@@ Odd += 2 ; } Cur@@ Odd = Sum@@ Even - Sum@@ Odd ; cout << Cur@@ Odd << ' ' ; } int main ( ) { int N = 12 ; Print ( N ) ; return 0 ; }
Minimum prefix increments required to make all elements of an array multip@@ les of another array 5088 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int Minimum@@ Moves ( int A [ ] , int B [ ] , int N ) { int total@@ Operations = 0 ; int carry = 0 ; int K = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { int nearest@@ Multiple = ceil ( ( double ) ( A [ i ] + carry ) / ( double ) ( B [ i ] ) ) * B [ i ] ; K = nearest@@ Multiple - ( A [ i ] + carry ) ; total@@ Operations += K ; carry += K ; } return total@@ Operations ; } int main ( ) { int A [ ] = { 3 , 4 , 5 , 2 , 5 , 5 , 9 } ; int B [ ] = { 1 , 1 , 9 , 6 , 3 , 8 , 7 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << Minimum@@ Moves ( A , B , N ) << endl ; return 0 ; }
Minim@@ ize deviation of an array by given operations 5091 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void minimum@@ Deviation ( int A [ ] , int N ) { set < int > s ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) s . insert ( A [ i ] ) ; else s . insert ( 2 * A [ i ] ) ; } int diff = * s . rbegin ( ) - * s . begin ( ) ; while ( ( int ) s . size ( ) && * s . rbegin ( ) % 2 == 0 ) { int max@@ El = * s . rbegin ( ) ; s . erase ( max@@ El ) ; s . insert ( max@@ El / 2 ) ; diff = min ( diff , * s . rbegin ( ) - * s . begin ( ) ) ; } cout << diff ; } int main ( ) { int A [ ] = { 4 , 1 , 5 , 20 , 3 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; minimum@@ Deviation ( A , N ) ; return 0 ; }
Find the player with least 0 s after empty@@ ing a Binary String by removing non 5096 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void Find@@ win@@ ner@@ Of@@ Game ( string & S ) { int cnt@@ Zero = 0 ; int cnt@@ Con@@ One = 0 ; int nim@@ Sum = 0 ; int N = S . length ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] == '1' ) { cnt@@ Con@@ One += 1 ; } else { nim@@ Sum ^= cnt@@ Con@@ One ; cnt@@ Con@@ One = 0 ; cnt@@ Zero ++ ; } } nim@@ Sum ^= cnt@@ Con@@ One ; if ( cnt@@ Zero % 2 == 0 ) { cout << " Ti@@ e " ; } else if ( nim@@ Sum ) { cout << " player ▁ 1" ; } else { cout << " player ▁ 2" ; } } int main ( ) { string S = "01@@ 100@@ 11" ; Find@@ win@@ ner@@ Of@@ Game ( S ) ; }
Minim@@ ize array elements required to be incremented or decre@@ mented to convert given array into a Fi@@ bon@@ ac@@ ci Series 5118 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int min@@ Moves ( vector < int > arr ) { int N = arr . size ( ) ; if ( N <= 2 ) return 0 ; int ans = INT_MAX ; for ( int i = -1 ; i <= 1 ; i ++ ) { for ( int j = -1 ; j <= 1 ; j ++ ) { int num1 = arr [ 0 ] + i ; int num2 = arr [ 1 ] + j ; int flag = 1 ; int moves = abs ( i ) + abs ( j ) ; for ( int idx = 2 ; idx < N ; idx ++ ) { int num = num1 + num2 ; if ( abs ( arr [ idx ] - num ) > 1 ) flag = 0 ; else moves += abs ( arr [ idx ] - num ) ; num1 = num2 ; num2 = num ; } if ( flag ) ans = min ( ans , moves ) ; } } if ( ans == INT_MAX ) return -1 ; return ans ; } int main ( ) { vector < int > arr = { 4 , 8 , 9 , 17 , 27 } ; cout << min@@ Moves ( arr ) << endl ; return 0 ; }
Maximum possible sum of K even multip@@ les of 5 in a given range 5140 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void max@@ k@@ sum ( int L , int R , int K ) { int N = ( R / 10 - L / 10 ) + 1 ; if ( K > N ) { cout << -1 ; return ; } R = R / 10 ; int X = R - K ; int sum = 10 * ( ( R * ( R + 1 ) ) / 2 - ( X * ( X + 1 ) ) / 2 ) ; cout << sum ; } int main ( ) { int L = 16 , R = 60 , K = 4 ; max@@ k@@ sum ( L , R , K ) ; return 0 ; }
Maxim@@ ize length of longest non 5192 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Lon@@ gest@@ Non@@ Decre@@ asing ( int A [ ] , int N ) { int res = 0 ; int start = 0 ; int end = N - 1 ; int prev = -1 ; while ( start <= end ) { if ( A [ start ] <= A [ end ] ) { if ( prev == -1 ) { prev = A [ start ] ; res ++ ; start ++ ; } else { if ( A [ start ] >= prev ) { res ++ ; prev = A [ start ] ; start ++ ; } else if ( A [ end ] >= prev ) { res ++ ; prev = A [ end ] ; end -- ; } else { break ; } } } else { if ( prev == -1 ) { prev = A [ end ] ; res ++ ; end -- ; } else { if ( A [ end ] >= prev ) { res ++ ; prev = A [ end ] ; end -- ; } else if ( A [ start ] >= prev ) { res ++ ; prev = A [ start ] ; start ++ ; } else { break ; } } } } return res ; } int main ( ) { int A [ ] = { 1 , 1 , 3 , 5 , 4 , 3 , 6 , 2 , 1 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << find@@ Lon@@ gest@@ Non@@ Decre@@ asing ( A , N ) ; return 0 ; }
Non 5196 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ Pairs ( int N ) { for ( int i = 0 ; i <= N ; i ++ ) { cout << " ( " << i << " , ▁ " << N - i << " ) , ▁ " ; } } int main ( ) { int N = 5 ; find@@ Pairs ( N ) ; return 0 ; }
Minim@@ ize adding odd and subtrac@@ ting even numbers to make all array elements equal to K 5216 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int Min@@ Operation ( int arr [ ] , int N , int K ) { int cnt@@ Op@@ e = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( K > arr [ i ] ) { if ( ( K - arr [ i ] ) % 2 == 0 ) { cnt@@ Op@@ e += 2 ; } else { cnt@@ Op@@ e += 1 ; } } else if ( K < arr [ i ] ) { if ( ( K - arr [ i ] ) % 2 == 0 ) { cnt@@ Op@@ e += 1 ; } else { cnt@@ Op@@ e += 2 ; } } } return cnt@@ Op@@ e ; } int main ( ) { int arr [ ] = { 8 , 7 , 2 , 1 , 3 } ; int K = 5 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << Min@@ Operation ( arr , N , K ) ; return 0 ; }
Neare@@ st smaller number to N having multiplic@@ ative inverse under modulo N equal to that number 5222 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int cl@@ st@@ Num ( int N ) { return ( N - 1 ) ; } int main ( ) { int N = 11 ; cout << cl@@ st@@ Num ( N ) ; }
Mean of array generated by products of all pairs of the given array 5228 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; float pair@@ Product@@ Mean ( int arr [ ] , int N ) { vector < int > pair@@ Array ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { int pair@@ Product = arr [ i ] * arr [ j ] ; pair@@ Array . push_back ( pair@@ Product ) ; } } int length = pair@@ Array . size ( ) ; float sum = 0 ; for ( int i = 0 ; i < length ; i ++ ) sum += pair@@ Array [ i ] ; float mean ; if ( length != 0 ) mean = sum / length ; else mean = 0 ; return mean ; } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << fixed << setprecision ( 2 ) << pair@@ Product@@ Mean ( arr , N ) ; return 0 ; }
Minim@@ ize positive product of two given numbers by at most N decre@@ ments 5238 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int min@@ Prod ( int X , int Y , int N ) { if ( X <= Y ) { if ( N < X ) return ( X - N ) * Y ; else { return max ( Y - ( N - X + 1 ) , 1 ) ; } } if ( Y >= N ) return ( Y - N ) * X ; return max ( X - ( N - Y + 1 ) , 1 ) ; ; } int main ( ) { int X = 47 , Y = 42 , N = 167 ; cout << min@@ Prod ( X , Y , N ) ; }
Check if any permutation of array contains sum of every adjacent pair not di@@ visible by 3 5268 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void factor@@ sOf@@ 3 ( int arr [ ] , int N ) { int a = 0 , b = 0 , c = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 3 == 0 ) a ++ ; else if ( arr [ i ] % 3 == 1 ) b ++ ; else if ( arr [ i ] % 3 == 2 ) c ++ ; } if ( a >= 1 && a <= b + c + 1 ) cout << " Yes " << endl ; else if ( a == 0 && b == 0 && c > 0 ) cout << " Yes " << endl ; else if ( a == 0 && c == 0 && b > 0 ) cout << " Yes " << endl ; else cout << " No " << endl ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; factor@@ sOf@@ 3 ( arr , N ) ; return 0 ; }
Maxim@@ ize count of empty water bott@@ les from N filled bott@@ les 5272 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max@@ Bo@@ tt@@ les ( int n , int e ) { int s = 0 , b = 0 ; int a = n ; while ( a != 0 ) { s = s + a ; a = ( a + b ) / e ; b = n - ( a * e ) ; n = a + b ; } return s ; } int main ( ) { int n = 9 , e = 3 ; int s = max@@ Bo@@ tt@@ les ( n , e ) ; cout << s << endl ; }
Count all N digit numbers whose digits are multiple of X 5273 | #@@ include <@@ st@@ dio@@ .@@ h@@ > NEW_LINE #@@ define ll long long NEW_LINE ll power ( ll x , ll n ) { ll temp ; if ( n == 0 ) return 1 ; temp = power ( x , n / 2 ) ; if ( n % 2 == 0 ) return temp * temp ; else return x * temp * temp ; } ll count_@@ Tot@@ al_@@ Numbers ( ll n , ll x ) { ll total , multip@@ les = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { if ( i % x == 0 ) multip@@ les ++ ; } if ( n == 1 ) return multip@@ les ; total = ( multip@@ les - 1 ) * power ( multip@@ les , n - 1 ) ; return total ; } int main ( ) { ll N = 1 , X = 3 ; printf ( " % lld ▁ " , count_@@ Tot@@ al_@@ Numbers ( N , X ) ) ; return 0 ; }
Minim@@ ize array length by repeatedly replacing pairs of un@@ equal adjacent array elements by their sum 5282 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int minLength ( int A [ ] , int N ) { int elem = A [ 0 ] , count = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( A [ i ] == elem ) { count ++ ; } else { break ; } } if ( count == N ) return N ; else return 1 ; } int main ( ) { int arr [ ] = { 2 , 1 , 3 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minLength ( arr , N ) << endl ; return 0 ; }
Split array into minimum number of sub@@ arrays having GC@@ D of its first and last element exce@@ eding 1 5287 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int min@@ Sub@@ arrays ( int arr [ ] , int n ) { int right = n - 1 ; int left = 0 ; int sub@@ arrays = 0 ; while ( right >= 0 ) { for ( left = 0 ; left <= right ; left += 1 ) { if ( __@@ gcd ( arr [ left ] , arr [ right ] ) > 1 ) { sub@@ arrays += 1 ; right = left - 1 ; break ; } if ( left == right && __@@ gcd ( arr [ left ] , arr [ right ] ) == 1 ) { return 0 ; } } } return sub@@ arrays ; } int main ( ) { int N = 6 ; int arr [ ] = { 2 , 3 , 4 , 4 , 4 , 3 } ; cout << min@@ Sub@@ arrays ( arr , N ) ; return 0 ; }
Find all missing numbers from a given sorted array 5298 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ Missing@@ Elements ( int arr [ ] , int N ) { int diff = arr [ 0 ] - 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] - i != diff ) { while ( diff < arr [ i ] - i ) { cout << i + diff << " ▁ " ; diff ++ ; } } } } int main ( ) { int arr [ ] = { 6 , 7 , 10 , 11 , 13 } ; int N = sizeof ( arr ) / sizeof ( int ) ; print@@ Missing@@ Elements ( arr , N ) ; return 0 ; }
Find all missing numbers from a given sorted array 5299 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ Missing@@ Elements ( int arr [ ] , int N ) { int b [ arr [ N - 1 ] + 1 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { b [ arr [ i ] ] = 1 ; } for ( int i = arr [ 0 ] ; i <= arr [ N - 1 ] ; i ++ ) { if ( b [ i ] == 0 ) { cout << i << " ▁ " ; } } } int main ( ) { int arr [ ] = { 6 , 7 , 10 , 11 , 13 } ; int N = sizeof ( arr ) / sizeof ( int ) ; print@@ Missing@@ Elements ( arr , N ) ; return 0 ; }
Possible number of Trees having N vertex 5306 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; const int mod = 1e@@ 9 + 7 ; int power ( int x , int y ) { if ( y == 0 ) return 1 ; int p = power ( x , y / 2 ) % mod ; p = ( p * p ) % mod ; if ( y & 1 ) p = ( x * p ) % mod ; return p ; } int NumberOf@@ Trees ( int arr [ ] , int N ) { int max@@ Element = * max_@@ element ( arr , arr + N ) ; int level [ max@@ Element + 1 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { level [ arr [ i ] ] ++ ; } if ( arr [ 0 ] != 0 level [ 0 ] != 1 ) { return 0 ; } int ans = 1 ; for ( int i = 0 ; i < max@@ Element ; i ++ ) { ans = ( ans * power ( level [ i ] , level [ i + 1 ] ) ) % mod ; } return ans ; } int main ( ) { int N = 7 ; int arr [ ] = { 0 , 3 , 2 , 1 , 2 , 2 , 1 } ; cout << NumberOf@@ Trees ( arr , N ) ; return 0 ; }
Count of carry operations on adding two Binary numbers 5309 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int carry@@ Count ( int num1 , int num2 ) { int count = 0 ; while ( num2 != 0 ) { int carry = num1 & num2 ; num1 = num1 ^ num2 ; num2 = carry << 1 ; count += __builtin@@ _pop@@ count ( num2 ) ; } return count ; } int main ( ) { int A = 15 , B = 10 ; cout << carry@@ Count ( 15 , 10 ) ; return 0 ; }
Lead a life problem 5312 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int calculate@@ Pro@@ fit ( int n , int * ear@@ nings , int * cost , int e ) { int pro@@ fit = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int ear@@ ning_@@ per_@@ day = 0 ; int dail@@ y_@@ sp@@ ent_@@ food = 0 ; if ( i == ( n - 1 ) ) { ear@@ ning_@@ per_@@ day = ear@@ nings [ i ] * e ; pro@@ fit = pro@@ fit + ear@@ ning_@@ per_@@ day ; break ; } if ( cost [ i ] < ear@@ nings [ i ] ) { ear@@ ning_@@ per_@@ day = ear@@ nings [ i ] * e ; dail@@ y_@@ sp@@ ent_@@ food = cost [ i ] * e ; pro@@ fit = pro@@ fit + ear@@ ning_@@ per_@@ day - dail@@ y_@@ sp@@ ent_@@ food ; } } cout << pro@@ fit << endl ; } int main ( ) { int n = 4 ; int ear@@ nings [ ] = { 1 , 8 , 6 , 7 } ; int cost [ ] = { 1 , 3 , 4 , 1 } ; int e = 5 ; calculate@@ Pro@@ fit ( n , ear@@ nings , cost , e ) ; }
Split N into two integers whose addition to A and B makes them equal 5336 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ Pair ( int A , int B , int N ) { int X , Y ; X = N - B + A ; if ( X % 2 != 0 ) { cout << " - 1" ; } else { X = X / 2 ; Y = N - X ; cout << X << " ▁ " << Y ; } } int main ( ) { int A = 1 ; int B = 3 ; int N = 4 ; find@@ Pair ( A , B , N ) ; return 0 ; }
Find the amplitude and number of w@@ aves for the given array 5339 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool check ( int a [ ] , int n ) { int ma = a [ 1 ] - a [ 0 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( ( a [ i ] > a [ i - 1 ] && a [ i + 1 ] < a [ i ] ) || ( a [ i ] < a [ i - 1 ] && a [ i + 1 ] > a [ i ] ) ) ma = max ( ma , abs ( a [ i ] - a [ i + 1 ] ) ) ; else return false ; } cout << " Ampli@@ tude ▁ = ▁ " << ma ; cout << endl ; return true ; } int main ( ) { int a [ ] = { 1 , 2 , 1 , 5 , 0 , 7 , -@@ 6 } ; int n = sizeof a / sizeof a [ 0 ] ; int wave = ( n - 1 ) / 2 ; if ( check ( a , n ) ) cout << " W@@ aves ▁ = ▁ " << wave ; else cout << " - 1" ; return 0 ; }
Generate a Binary String without any consecutive 0 ' s ▁ and ▁ at ▁ most ▁ K ▁ consecutive ▁ 1' s 5384 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; string Construct@@ Binary@@ String ( int N , int M , int K ) { if ( M < ( N - 1 ) || M > K * ( N + 1 ) ) return " - 1" ; string ans = " " ; int l = min ( K , M / ( N - 1 ) ) ; int temp = N ; while ( temp -- ) { ans += '0' ; if ( temp == 0 ) break ; for ( int i = 0 ; i < l ; i ++ ) { ans += '1' ; } } M -= ( N - 1 ) * l ; if ( M == 0 ) return ans ; l = min ( M , K ) ; for ( int i = 0 ; i < l ; i ++ ) ans += '1' ; M -= l ; while ( M > 0 ) { ans = '1' + ans ; M -- ; } return ans ; } int main ( ) { int N = 5 , M = 9 , K = 2 ; cout << Construct@@ Binary@@ String ( N , M , K ) ; }
Perf@@ ect Square factors of a Number 5393 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int noOf@@ Factors ( int N ) { if ( N == 1 ) return 1 ; int count = 0 ; int ans = 1 ; while ( N % 2 == 0 ) { count ++ ; N = N / 2 ; } ans *= ( count / 2 + 1 ) ; for ( int i = 3 ; i * i <= N ; i = i + 2 ) { count = 0 ; while ( N % i == 0 ) { count ++ ; N = N / i ; } ans *= ( count / 2 + 1 ) ; } return ans ; } int main ( ) { int N = 100 ; cout << noOf@@ Factors ( N ) ; return 0 ; }
Path traver@@ sed using exactly M coins in K jumps 5481 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print_@@ path ( int N , int jump , int coin ) { if ( jump > coin || jump * ( N - 1 ) < coin ) { cout << " - 1" << endl ; } else { int pos = 1 ; while ( jump > 0 ) { int tmp = min ( N - 1 , coin - ( jump - 1 ) ) ; if ( pos + tmp <= N ) { pos += tmp ; } else { pos -= tmp ; } cout << pos << " ▁ " ; coin -= tmp ; jump -= 1 ; } } } int main ( ) { int N = 5 , K = 4 , M = 12 ; print_@@ path ( N , K , M ) ; return 0 ; }
Minimum fli@@ ps required to generate continuous sub@@ strings of 0 â €@@ ™ s and 1 â €@@ ™ s 5491 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int min@@ Changes ( string str , int N ) { int res ; int count@@ 0 = 0 , count@@ 1 = 0 ; for ( char x : str ) { count@@ 0 += ( x == '0' ) ; } res = count@@ 0 ; for ( char x : str ) { count@@ 0 -= ( x == '0' ) ; count@@ 1 += ( x == '1' ) ; res = min ( res , count@@ 1 + count@@ 0 ) ; } return res ; } int main ( ) { int N = 9 ; string str = "@@ 0001@@ 0100@@ 1" ; cout << min@@ Changes ( str , N ) ; return 0 ; }
Count number of triangles possible for the given sides range 5493 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count_@@ triangles ( int a , int b , int c , int d ) { int ans = 0 ; for ( int x = a ; x <= b ; ++ x ) { int num_@@ greater_@@ th@@ an_@@ d = max ( d , c + x ) - max ( d , b + x - 1 ) ; ans += num_@@ greater_@@ th@@ an_@@ d * ( d - c + 1 ) ; int r = min ( max ( c , c + x ) , d ) - c ; int l = min ( max ( c , b + x - 1 ) , d ) - c ; int x1 = ( r * ( r + 1 ) ) / 2 ; int x2 = ( l * ( l + 1 ) ) / 2 ; ans += x1 - x2 ; } return ans ; } int main ( ) { int a = 2 , b = 3 , c = 4 , d = 5 ; cout << count_@@ triangles ( a , b , c , d ) << endl ; return 0 ; }
Split a number as sum of K numbers which are not di@@ visible by K 5500 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; void print@@ K@@ Parts ( int N , int K ) { if ( N % K == 0 ) { for ( int i = 1 ; i < K ; i ++ ) cout << "1 , ▁ " ; cout << N - ( K - 1 ) << endl ; } else { if ( K == 2 ) { cout << " Not ▁ Possible " << endl ; return ; } for ( int i = 1 ; i < K - 1 ; i ++ ) cout << 1 << " , ▁ " ; cout << 2 << " , ▁ " << N - K << endl ; } } int main ( ) { int N = 18 , K = 5 ; print@@ K@@ Parts ( N , K ) ; return 0 ; }
Find the maximum sum ( a + b ) for a given input integer N satis@@ fying the given condition 5538 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int get@@ Largest@@ Sum ( int N ) { int max_@@ sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = i + 1 ; j <= N ; j ++ ) { if ( i * j % ( i + j ) == 0 ) max_@@ sum = max ( max_@@ sum , i + j ) ; } } return max_@@ sum ; } int main ( ) { int N = 25 ; int max_@@ sum = get@@ Largest@@ Sum ( N ) ; cout << max_@@ sum << endl ; return 0 ; }
Number of indices pair such that element pair sum from first Array is greater than second Array 5558 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int get@@ Pairs ( vector < int > A , vector < int > B , int n ) { vector < int > D ( n ) ; for ( int i = 0 ; i < n ; i ++ ) { D [ i ] = A [ i ] - B [ i ] ; } sort ( D . begin ( ) , D . end ( ) ) ; long long total = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( D [ i ] > 0 ) { total += n - i - 1 ; } else { int k = upper_bound ( D . begin ( ) , D . end ( ) , - D [ i ] ) - D . begin ( ) ; total += n - k ; } } return total ; } int main ( ) { int n = 5 ; vector < int > A ; vector < int > B ; A . push_back ( 4 ) ; A . push_back ( 8 ) ; A . push_back ( 2 ) ; A . push_back ( 6 ) ; A . push_back ( 2 ) ; B . push_back ( 4 ) ; B . push_back ( 5 ) ; B . push_back ( 4 ) ; B . push_back ( 1 ) ; B . push_back ( 3 ) ; cout << get@@ Pairs ( A , B , n ) ; }
Minimum number of Fac@@ tori@@ als whose sum is equal to N 5562 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE #@@ define ll long long int NEW_LINE using namespace std ; ll fact [ 14 ] ; int size = 1 ; void pre@@ Compute ( int N ) { fact [ 0 ] = 1 ; for ( int i = 1 ; fact [ i - 1 ] <= N ; i ++ ) { fact [ i ] = ( fact [ i - 1 ] * i ) ; size ++ ; } } void find@@ Min ( int N ) { pre@@ Compute ( N ) ; int original@@ N = N ; vector < int > ans ; for ( int i = size - 1 ; i >= 0 ; i -- ) { while ( N >= fact [ i ] ) { N -= fact [ i ] ; ans . push_back ( fact [ i ] ) ; } } cout << ans . size ( ) << " STRNEWLINE " ; for ( int i = 0 ; i < ans . size ( ) ; i ++ ) cout << ans [ i ] << " ▁ " ; } int main ( ) { int n = 27 ; find@@ Min ( n ) ; return 0 ; }
Count of sub@@ arrays with sum at least K 5591 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int k_@@ sum ( int a [ ] , int n , int k ) { int r = 0 , sum = 0 ; int ans = 0 ; for ( int l = 0 ; l < n ; l ++ ) { while ( sum < k ) { if ( r == n ) break ; else { sum += a [ r ] ; r ++ ; } } if ( sum < k ) break ; ans += n - r + 1 ; sum -= a [ l ] ; } return ans ; } int main ( ) { int a [ ] = { 6 , 1 , 2 , 7 } , k = 10 ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << k_@@ sum ( a , n , k ) ; return 0 ; }
Maximum Sum of Products of two arrays by to@@ g@@ gl@@ ing adjacent bits 5597 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max@@ Sum ( int ar@@ r1 [ ] , int ar@@ r2 [ ] , int n ) { int initial@@ Par@@ ity = 0 , final@@ Par@@ ity = 0 ; int sum = 0 , min@@ Positive = INT_MAX , max@@ Negative = INT_@@ MIN ; for ( int i = 0 ; i < n ; i ++ ) { initial@@ Par@@ ity += ar@@ r2 [ i ] ; if ( ar@@ r1 [ i ] >= 0 ) { final@@ Par@@ ity += 1 ; sum += ar@@ r1 [ i ] ; min@@ Positive = min ( min@@ Positive , ar@@ r1 [ i ] ) ; } else { max@@ Negative = max ( max@@ Negative , ar@@ r1 [ i ] ) ; } } if ( initial@@ Par@@ ity % 2 == final@@ Par@@ ity % 2 ) { return sum ; } else { if ( min@@ Positive + max@@ Negative >= 0 ) { return sum + max@@ Negative ; } else { return sum - min@@ Positive ; } } } int main ( ) { int ar@@ r1 [ ] = { 2 , -@@ 4 , 5 , 3 } ; int ar@@ r2 [ ] = { 0 , 1 , 0 , 1 } ; int n = sizeof ( ar@@ r1 ) / sizeof ( ar@@ r1 [ 0 ] ) ; cout << max@@ Sum ( ar@@ r1 , ar@@ r2 , n ) << endl ; return 0 ; }
Find the minimum capacity of the train required to hold the pass@@ eng@@ ers 5605 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int min@@ Capacity ( int enter [ ] , int exit [ ] , int n ) { int min@@ Cap = 0 ; int curr@@ Cap = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr@@ Cap = curr@@ Cap + enter [ i ] - exit [ i ] ; min@@ Cap = max ( min@@ Cap , curr@@ Cap ) ; } return min@@ Cap ; } int main ( ) { int enter [ ] = { 3 , 5 , 2 , 0 } ; int exit [ ] = { 0 , 2 , 4 , 4 } ; int n = sizeof ( enter ) / sizeof ( enter [ 0 ] ) ; cout << min@@ Capacity ( enter , exit , n ) ; return 0 ; }
Minimum element left from the array after performing given operations 5610 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int get@@ Min ( int arr [ ] , int n ) { int min@@ Val = * min_@@ element ( arr , arr + n ) ; return min@@ Val ; } int main ( ) { int arr [ ] = { 5 , 3 , 1 , 6 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << get@@ Min ( arr , n ) ; return 0 ; }
Length of longest sub 5625 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int lon@@ gest@@ Sub@@ array ( int arr [ ] , int n ) { int max@@ Mean = 0 ; for ( int i = 1 ; i < n ; i ++ ) max@@ Mean = max ( max@@ Mean , ( arr [ i ] + arr [ i - 1 ] ) / 2 ) ; int ans = 0 ; int sub@@ array@@ Length = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= max@@ Mean ) ans = max ( ans , ++ sub@@ array@@ Length ) ; else sub@@ array@@ Length = 0 ; return ans ; } int main ( ) { int arr [ ] = { 4 , 3 , 3 , 2 , 1 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << lon@@ gest@@ Sub@@ array ( arr , n ) ; return 0 ; }
Convert given integer X to the form 2 ^ N 5627 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; const int MAX = 24 ; int count@@ Op ( int x ) { int arr [ MAX ] ; arr [ 0 ] = 1 ; for ( int i = 1 ; i < MAX ; i ++ ) arr [ i ] = arr [ i - 1 ] * 2 ; int temp = x ; bool flag = true ; int ans ; int operations = 0 ; bool flag@@ 2 = false ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( arr [ i ] - 1 == x ) flag@@ 2 = true ; if ( arr [ i ] > x ) { ans = i ; break ; } } if ( flag@@ 2 ) return 0 ; while ( flag ) { if ( arr [ ans ] < x ) ans ++ ; operations ++ ; for ( int i = 0 ; i < MAX ; i ++ ) { int take = x ^ ( arr [ i ] - 1 ) ; if ( take <= arr [ ans ] - 1 ) { if ( take > temp ) temp = take ; } } if ( temp == arr [ ans ] - 1 ) { flag = false ; break ; } temp ++ ; operations ++ ; x = temp ; if ( x == arr [ ans ] - 1 ) flag = false ; } return operations ; } int main ( ) { int x = 39 ; cout << count@@ Op ( x ) ; return 0 ; }
Maximum money that can be with@@ drawn in two steps 5639 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max@@ Coins ( int X , int Y ) { if ( X < Y ) swap ( X , Y ) ; int coins = X ; X -- ; coins += max ( X , Y ) ; return coins ; } int main ( ) { int X = 7 , Y = 5 ; cout << max@@ Coins ( X , Y ) ; return 0 ; }
Replace all elements by difference of sums of positive and negative numbers after that element 5664 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; void print@@ Array ( int N , int arr [ ] ) { for ( int i = 0 ; i < N ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << endl ; } void repl@@ aced@@ Array ( int N , int arr [ ] ) { int pos_@@ sum , neg_@@ sum , i , j , diff ; for ( i = 0 ; i < N ; i ++ ) { pos_@@ sum = 0 ; neg_@@ sum = 0 ; for ( j = i + 1 ; j < N ; j ++ ) { if ( arr [ j ] > 0 ) pos_@@ sum += arr [ j ] ; else neg_@@ sum += arr [ j ] ; } diff = abs ( pos_@@ sum ) - abs ( neg_@@ sum ) ; arr [ i ] = abs ( diff ) ; } } int main ( ) { int N = 5 ; int arr [ ] = { 1 , -1 , 2 , 3 , -2 } ; repl@@ aced@@ Array ( N , arr ) ; print@@ Array ( N , arr ) ; N = 6 ; int ar@@ r1 [ ] = { -@@ 3 , -@@ 4 , -2 , 5 , 1 , -2 } ; repl@@ aced@@ Array ( N , ar@@ r1 ) ; print@@ Array ( N , ar@@ r1 ) ; return 0 ; }
Find the Side of the smallest Square that can contain given 4 Big Squ@@ ares 5688 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; long long int max ( long long a , long long b ) { if ( a > b ) return a ; else return b ; } long long int smalle@@ st@@ Side ( long long int a [ ] ) { sort ( a , a + 4 ) ; long long side@@ 1 , side@@ 2 , side@@ 3 , side@@ 4 , side@@ 11 , side@@ 12 , side@@ Of@@ Square ; side@@ 1 = a [ 0 ] + a [ 3 ] ; side@@ 2 = a [ 1 ] + a [ 2 ] ; side@@ 3 = a [ 0 ] + a [ 1 ] ; side@@ 4 = a [ 2 ] + a [ 3 ] ; side@@ 11 = max ( side@@ 1 , side@@ 2 ) ; side@@ 12 = max ( side@@ 3 , side@@ 4 ) ; side@@ Of@@ Square = max ( side@@ 11 , side@@ 12 ) ; return side@@ Of@@ Square ; } int main ( ) { long long int side [ 4 ] ; cout << " Test ▁ Case ▁ 1 STRNEWLINE " ; side [ 0 ] = 2 ; side [ 1 ] = 2 ; side [ 2 ] = 2 ; side [ 3 ] = 2 ; cout << smalle@@ st@@ Side ( side ) << endl ; cout << " Test Case 2 " side [ 0 ] = 100000000@@ 000000 ; side [ 1 ] = 12345@@ 00000000@@ 00 ; side [ 2 ] = 987@@ 65@@ 00000000@@ 00 ; side [ 3 ] = 987@@ 65432@@ 1000000 ; cout << smalle@@ st@@ Side ( side ) << endl ; return 0 ; }
Maximum sum of all elements of array after performing given operations 5699 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max@@ Sub@@ Array@@ Sum ( int a [ ] , int size ) { int max_@@ so@@ _f@@ ar = INT_@@ MIN , max_@@ ending_@@ here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_@@ ending_@@ here = max_@@ ending_@@ here + a [ i ] ; if ( max_@@ so@@ _f@@ ar < max_@@ ending_@@ here ) max_@@ so@@ _f@@ ar = max_@@ ending_@@ here ; if ( max_@@ ending_@@ here < 0 ) max_@@ ending_@@ here = 0 ; } return max_@@ so@@ _f@@ ar ; } int max@@ Sum ( int a [ ] , int n ) { int S = 0 ; int S1 = max@@ Sub@@ Array@@ Sum ( a , n ) ; for ( int i = 0 ; i < n ; i ++ ) S += a [ i ] ; return ( 2 * S1 - S ) ; } int main ( ) { int a [ ] = { -@@ 35 , 32 , -@@ 24 , 0 , 27 , -@@ 10 , 0 , -@@ 19 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << max@@ Sum ( a , n ) ; return 0 ; }
Maximum score after fli@@ pping a Binary Matrix at@@ most K times 5722 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; const int n = 3 ; const int m = 4 ; int max@@ Matrix@@ Score ( int A [ n ] [ m ] , int K ) { map < int , int > update ; for ( int i = 0 ; i < n ; ++ i ) { if ( A [ i ] [ 0 ] == 0 ) { int ans = 0 ; for ( int j = 1 ; j < m ; ++ j ) ans = ans + A [ i ] [ j ] * pow ( 2 , m - j - 1 ) ; update [ ans ] = i ; } } map < int , int > :: iterator it = update . begin ( ) ; while ( K > 0 && it != update . end ( ) ) { int idx = it -> second ; for ( int j = 0 ; j < m ; ++ j ) A [ idx ] [ j ] = ( A [ idx ] [ j ] + 1 ) % 2 ; it ++ ; K -- ; } int ans = 0 ; for ( int j = 0 ; j < m ; ++ j ) { int zero = 0 , one = 0 ; for ( int i = 0 ; i < n ; ++ i ) { A [ i ] [ j ] == 0 ? zero ++ : one ++ ; } if ( K > 0 && zero > one ) { ans += zero * pow ( 2 , m - j - 1 ) ; K -- ; } else ans += one * pow ( 2 , m - j - 1 ) ; } return ans ; } int main ( ) { int A [ n ] [ m ] = { { 0 , 0 , 1 , 1 } , { 1 , 0 , 1 , 0 } , { 1 , 1 , 0 , 0 } } ; int K = 2 ; cout << max@@ Matrix@@ Score ( A , K ) ; return 0 ; }
Re@@ arrange an array to maxim@@ ize sum of Bit@@ wise AND of same 5929 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int maxim@@ ize@@ And ( int i , int mask , int * A , int * B , int N , vector < vector < int > > & dp ) { if ( i == N ) return 0 ; if ( dp [ i ] [ mask ] != -1 ) return dp [ i ] [ mask ] ; for ( int j = 0 ; j < N ; ++ j ) { if ( ! ( mask & ( 1 << j ) ) ) { dp [ i ] [ mask ] = max ( dp [ i ] [ mask ] , ( A [ i ] & B [ j ] ) + maxim@@ ize@@ And ( i + 1 , mask | ( 1 << j ) , A , B , N , dp ) ) ; } } return dp [ i ] [ mask ] ; } int maxim@@ ize@@ And@@ Util ( int * A , int * B , int N ) { vector < vector < int > > dp ( N , vector < int > ( 1 << N + 1 , -1 ) ) ; return maxim@@ ize@@ And ( 0 , 0 , A , B , N , dp ) ; } int main ( ) { int A [ ] = { 3 , 5 , 7 , 11 } ; int B [ ] = { 2 , 6 , 10 , 12 } ; int N = sizeof A / sizeof A [ 0 ] ; cout << maxim@@ ize@@ And@@ Util ( A , B , N ) ; }
Length of longest increasing sub@@ sequence in a string 5958 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int li@@ s@@ O@@ tim@@ ised ( string s ) { int dp [ 30 ] = { 0 } ; int N = s . size ( ) ; int lis = INT_@@ MIN ; for ( int i = 0 ; i < N ; i ++ ) { int val = s [ i ] - ' a ' ; int curr = 0 ; for ( int j = 0 ; j < val ; j ++ ) { curr = max ( curr , dp [ j ] ) ; } curr ++ ; lis = max ( lis , curr ) ; dp [ val ] = max ( dp [ val ] , curr ) ; } return lis ; } int main ( ) { string s = " f@@ dry@@ uti@@ ag@@ h@@ f@@ se " ; cout << li@@ s@@ O@@ tim@@ ised ( s ) ; return 0 ; }
Sum of length of two smallest subsets possible from a given array with sum at least K 5959 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; const int MAX = 1e@@ 9 ; int Minimum@@ Length ( int A [ ] , int N , int K ) { sort ( A , A + N ) ; int suffix [ N + 1 ] = { 0 } ; for ( int i = N - 1 ; i >= 0 ; i -- ) suffix [ i ] = suffix [ i + 1 ] + A [ i ] ; int dp [ N + 1 ] [ K + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) for ( int j = 0 ; j <= K ; j ++ ) dp [ i ] [ j ] = MAX ; dp [ N ] [ 0 ] = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = K ; j >= 0 ; j -- ) { if ( j <= A [ i ] ) { dp [ i ] [ j ] = A [ i ] ; continue ; } if ( dp [ i + 1 ] [ j - A [ i ] ] == MAX ) dp [ i ] [ j ] = MAX ; else dp [ i ] [ j ] = min ( dp [ i + 1 ] [ j ] , dp [ i + 1 ] [ j - A [ i ] ] + A [ i ] ) ; } } for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( suffix [ i ] - dp [ i ] [ K ] >= K ) { return N - i ; } } return -1 ; } int main ( ) { int arr [ ] = { 7 , 4 , 5 , 6 , 8 } ; int K = 13 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << Minimum@@ Length ( arr , N , K ) ; return 0 ; }
Probability that the sum of all numbers obtained on throwing a di@@ ce N times lies between two given integers 5989 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; float dp [ 105 ] [ 6@@ 05 ] ; float find ( int N , int sum ) { if ( dp [ N ] [ sum ] ) return dp [ N ] [ sum ] ; if ( sum > 6 * N sum < N ) return 0 ; if ( N == 1 ) { if ( sum >= 1 && sum <= 6 ) return 1.0 / 6 ; else return 0 ; } for ( int i = 1 ; i <= 6 ; i ++ ) dp [ N ] [ sum ] = dp [ N ] [ sum ] + find ( N - 1 , sum - i ) / 6 ; return dp [ N ] [ sum ] ; } int main ( ) { int N = 4 , a = 13 , b = 17 ; float probability = 0.0 ; for ( int sum = a ; sum <= b ; sum ++ ) probability = probability + find ( N , sum ) ; cout << fixed << setprecision ( 6 ) << probability ; return 0 ; }
Medi@@ an of Bit@@ wise XOR of all sub@@ matrices starting from the top left corner 5998 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; double find@@ Med@@ XOR ( int mat [ ] [ 2 ] , int N , int M ) { int dp [ N ] [ M ] ; int med [ N * M ] ; dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] ; med [ 0 ] = dp [ 0 ] [ 0 ] ; int len = 1 ; for ( int i = 1 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ^ mat [ i ] [ 0 ] ; med [ len ++ ] = dp [ i ] [ 0 ] ; } for ( int i = 1 ; i < M ; i ++ ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] ^ mat [ 0 ] [ i ] ; med [ len ++ ] = dp [ 0 ] [ i ] ; } for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 1 ; j < M ; j ++ ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ^ dp [ i ] [ j - 1 ] ^ dp [ i - 1 ] [ j - 1 ] ^ mat [ i ] [ j ] ; med [ len ++ ] = dp [ i ] [ j ] ; } } sort ( med , med + len ) ; if ( len % 2 == 0 ) { return ( med [ ( len / 2 ) ] + med [ ( len / 2 ) - 1 ] ) / 2.0 ; } return med [ len / 2 ] ; } int main ( ) { int mat [ ] [ 2 ] = { { 1 , 2 } , { 2 , 3 } } ; int N = sizeof ( mat ) / sizeof ( mat [ 0 ] ) ; int M = 2 ; cout << find@@ Med@@ XOR ( mat , N , M ) ; return 0 ; }
Check if an array can be split into 3 sub@@ sequences of equal sum or not 6083 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; map < string , int > dp ; int check@@ Equal@@ Sum@@ Util ( int arr [ ] , int N , int sm@@ 1 , int sm@@ 2 , int sm@@ 3 , int j ) { string s = to_string ( sm@@ 1 ) + " _ " + to_string ( sm@@ 2 ) + to_string ( j ) ; if ( j == N ) { if ( sm@@ 1 == sm@@ 2 && sm@@ 2 == sm@@ 3 ) return 1 ; else return 0 ; } if ( dp . find ( s ) != dp . end ( ) ) return dp [ s ] ; else { int l = check@@ Equal@@ Sum@@ Util ( arr , N , sm@@ 1 + arr [ j ] , sm@@ 2 , sm@@ 3 , j + 1 ) ; int m = check@@ Equal@@ Sum@@ Util ( arr , N , sm@@ 1 , sm@@ 2 + arr [ j ] , sm@@ 3 , j + 1 ) ; int r = check@@ Equal@@ Sum@@ Util ( arr , N , sm@@ 1 , sm@@ 2 , sm@@ 3 + arr [ j ] , j + 1 ) ; return dp [ s ] = max ( max ( l , m ) , r ) ; } } void check@@ Equal@@ Sum ( int arr [ ] , int N ) { int sum@@ 1 , sum@@ 2 , sum@@ 3 ; sum@@ 1 = sum@@ 2 = sum@@ 3 = 0 ; if ( check@@ Equal@@ Sum@@ Util ( arr , N , sum@@ 1 , sum@@ 2 , sum@@ 3 , 0 ) == 1 ) { cout << " Yes " ; } else { cout << " No " ; } } int main ( ) { int arr [ ] = { 17 , 34 , 59 , 23 , 17 , 67 , 57 , 2 , 18 , 59 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; check@@ Equal@@ Sum ( arr , N ) ; return 0 ; }
Binary Matrix after fli@@ pping sub@@ matrices in given range for Q queries 6084 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void manipulation ( vector < vector < int > > & matrix , vector < int > & q ) { int x1 = q [ 0 ] , y1 = q [ 1 ] , x2 = q [ 2 ] , y2 = q [ 3 ] ; for ( int i = x1 - 1 ; i < x2 ; i ++ ) { for ( int j = y1 - 1 ; j < y2 ; j ++ ) { if ( matrix [ i ] [ j ] == 1 ) matrix [ i ] [ j ] = 0 ; else matrix [ i ] [ j ] = 1 ; } } } void queri@@ es_@@ fx@@ n ( vector < vector < int > > & matrix , vector < vector < int > > & queries ) { for ( auto q : queries ) manipulation ( matrix , q ) ; } int main ( ) { vector < vector < int > > matrix = { { 0 , 1 , 0 } , { 1 , 1 , 0 } } ; vector < vector < int > > queries = { { 1 , 1 , 2 , 3 } , { 1 , 1 , 1 , 1 } , { 1 , 2 , 2 , 3 } } ; queri@@ es_@@ fx@@ n ( matrix , queries ) ; cout << " [ " ; for ( int i = 0 ; i < matrix . size ( ) ; i ++ ) { cout << " [ " ; for ( int j = 0 ; j < matrix [ i ] . size ( ) ; j ++ ) cout << matrix [ i ] [ j ] << " ▁ " ; if ( i == matrix . size ( ) - 1 ) cout << " ] " ; else cout << " ] , ▁ " ; } cout << " ] " ; }
Count of ways in which N can be represented as sum of Fi@@ bon@@ ac@@ ci numbers without repeti@@ tion 6096 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; long long fi@@ b [ 101 ] , d@@ p1 [ 101 ] ; long long d@@ p2 [ 101 ] , v [ 101 ] ; void fi@@ bon@@ ac@@ ci ( ) { fi@@ b [ 1 ] = 1 ; fi@@ b [ 2 ] = 2 ; for ( int i = 3 ; i <= 87 ; i ++ ) { fi@@ b [ i ] = fi@@ b [ i - 1 ] + fi@@ b [ i - 2 ] ; } } int find ( int num ) { int cnt = 0 ; for ( int i = 87 ; i > 0 ; i -- ) { if ( num >= fi@@ b [ i ] ) { v [ cnt ++ ] = i ; num -= fi@@ b [ i ] ; } } reverse ( v , v + cnt ) ; d@@ p1 [ 0 ] = 1 ; d@@ p2 [ 0 ] = ( v [ 0 ] - 1 ) / 2 ; for ( int i = 1 ; i < cnt ; i ++ ) { d@@ p1 [ i ] = d@@ p1 [ i - 1 ] + d@@ p2 [ i - 1 ] ; d@@ p2 [ i ] = ( ( v [ i ] - v [ i - 1 ] ) / 2 ) * d@@ p2 [ i - 1 ] + ( ( v [ i ] - v [ i - 1 ] - 1 ) / 2 ) * d@@ p1 [ i - 1 ] ; } return ( d@@ p1 [ cnt - 1 ] + d@@ p2 [ cnt - 1 ] ) ; } int main ( ) { fi@@ bon@@ ac@@ ci ( ) ; int num = 13 ; cout << find ( num ) ; return 0 ; }
Count of N 6100 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void count@@ Num@@ s ( int N ) { int l = ( int ) pow ( 10 , N - 1 ) ; int r = ( int ) pow ( 10 , N ) - 1 ; int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { int xor@@ r = 0 , temp = i ; while ( temp > 0 ) { xor@@ r = xor@@ r ^ ( temp % 10 ) ; temp /= 10 ; } if ( xor@@ r <= 9 ) count ++ ; } cout << count ; } int main ( ) { int N = 2 ; count@@ Num@@ s ( N ) ; }
Count of all sub@@ sequences having adjacent elements with different parity 6130 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; long long getCount ( int n , int k ) { if ( n == 1 ) return 10 ; long long dp [ n + 1 ] [ 11 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j < 11 ; j ++ ) dp [ i ] [ j ] = 0 ; } for ( int i = 1 ; i <= 9 ; i ++ ) dp [ 1 ] [ i ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { int l = max ( 0 , j - k ) ; int r = min ( 9 , j + k ) ; dp [ i ] [ l ] += dp [ i - 1 ] [ j ] ; dp [ i ] [ r + 1 ] -= dp [ i - 1 ] [ j ] ; } for ( int j = 1 ; j <= 9 ; j ++ ) dp [ i ] [ j ] += dp [ i ] [ j - 1 ] ; } long long count = 0 ; for ( int i = 0 ; i <= 9 ; i ++ ) count += dp [ n ] [ i ] ; return count ; } int main ( ) { int N = 2 , K = 1 ; cout << getCount ( N , K ) ; }
Find if there is a path between two vertices in a directed graph | Set 2 6131 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define X 6 NEW_LINE #@@ define Z 2 NEW_LINE bool exist@@ Path ( int V , int edges [ X ] [ Z ] , int u , int v ) { bool mat [ V ] [ V ] ; memset ( mat , false , sizeof ( mat ) ) ; for ( int i = 0 ; i < X ; i ++ ) mat [ edges [ i ] [ 0 ] ] [ edges [ i ] [ 1 ] ] = true ; for ( int k = 0 ; k < V ; k ++ ) { for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { mat [ i ] [ j ] = mat [ i ] [ j ] || mat [ i ] [ k ] && mat [ k ] [ j ] ; } } } if ( u >= V v >= V ) { return false ; } if ( mat [ u ] [ v ] ) return true ; return false ; } int main ( ) { int V = 4 ; int edges [ X ] [ Z ] = { { 0 , 2 } , { 0 , 1 } , { 1 , 2 } , { 2 , 3 } , { 2 , 0 } , { 3 , 3 } } ; int u = 1 , v = 3 ; if ( exist@@ Path ( V , edges , u , v ) ) cout << " Yes STRNEWLINE " ; else cout << " No STRNEWLINE " ; return 0 ; }
Maxim@@ ize the numbers of splits in an Array having sum di@@ visible by 3 6132 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int calculate_@@ maximum@@ _@@ splits ( int arr [ ] , int N ) { int pre [ ] = { 0 , -1 , -1 } ; int dp [ N ] ; memset ( dp , 0 , sizeof ( dp ) ) ; int C = 0 ; for ( int i = 0 ; i < N ; i ++ ) { C = C + arr [ i ] ; C = C % 3 ; if ( pre [ C ] == -1 ) { dp [ i ] = dp [ i - 1 ] ; } else { dp [ i ] = max ( dp [ i - 1 ] , dp [ pre [ C ] ] + 1 ) ; } pre [ C ] = i ; } return dp [ N - 1 ] ; } int main ( ) { int arr [ ] = { 2 , 36 , 1 , 9 , 2 , 0 , 1 , 8 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ( calculate_@@ maximum@@ _@@ splits ( arr , N ) ) ; }
S@@ malle@@ st index in given range of indices which is not equal to X 6138 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void pre@@ compute ( int next@@ pos [ ] , int arr [ ] , int N ) { next@@ pos [ N - 1 ] = N ; for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] == arr [ i + 1 ] ) next@@ pos [ i ] = next@@ pos [ i + 1 ] ; else next@@ pos [ i ] = i + 1 ; } } void find@@ Index ( int query [ ] [ 3 ] , int arr [ ] , int N , int Q ) { int next@@ pos [ N ] ; pre@@ compute ( next@@ pos , arr , N ) ; for ( int i = 0 ; i < Q ; i ++ ) { int l , r , x ; l = query [ i ] [ 0 ] ; r = query [ i ] [ 1 ] ; x = query [ i ] [ 2 ] ; int ans = -1 ; if ( arr [ l ] != x ) ans = l ; else { int d = next@@ pos [ l ] ; if ( d <= r ) ans = d ; } cout << ans << " STRNEWLINE " ; } } int main ( ) { int N , Q ; N = 6 ; Q = 3 ; int arr [ ] = { 1 , 2 , 1 , 1 , 3 , 5 } ; int query [ Q ] [ 3 ] = { { 0 , 3 , 1 } , { 1 , 5 , 2 } , { 2 , 3 , 1 } } ; find@@ Index ( query , arr , N , Q ) ; return 0 ; }
Check if one string can be converted to other using given operation 6176 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void two@@ Strings@@ Equality ( string s , string t ) { int n = s . length ( ) ; vector < vector < int > > dp ( n , vector < int > ( n + 1 , 0 ) ) ; if ( s [ n - 1 ] == t [ 0 ] ) dp [ n - 1 ] [ 1 ] = 1 ; if ( s [ n - 1 ] == t [ n - 1 ] ) dp [ n - 1 ] [ 0 ] = 1 ; for ( int i = n - 1 ; i > 0 ; i -- ) { for ( int j = 0 ; j <= n - i ; j ++ ) { if ( dp [ i ] [ j ] ) { if ( s [ i - 1 ] == t [ j ] ) dp [ i - 1 ] [ j + 1 ] = 1 ; if ( s [ i - 1 ] == t [ i + j - 1 ] ) dp [ i - 1 ] [ j ] = 1 ; } } } bool ans = false ; for ( int i = 0 ; i <= n ; i ++ ) { if ( dp [ 0 ] [ i ] == 1 ) { ans = true ; break ; } } if ( ans == true ) cout << " Yes " << " STRNEWLINE " ; else cout << " No " << " STRNEWLINE " ; } int main ( ) { string S = " ab@@ ab " ; string T = " b@@ aa@@ b " ; two@@ Strings@@ Equality ( S , T ) ; return 0 ; }
Check if a matrix contains a square sub@@ matrix with 0 as boundary element 6182 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool has@@ Square@@ Of@@ Zero@@ es ( vector < vector < int > > & matrix , int r1 , int c1 , int r2 , int c2 , unordered_map < string , bool > & cache ) ; bool is@@ Square@@ Of@@ Zero@@ es ( vector < vector < int > > & matrix , int r1 , int c1 , int r2 , int c2 ) ; bool square@@ Of@@ Zero@@ es ( vector < vector < int > > matrix ) { int last@@ Idx = matrix . size ( ) - 1 ; unordered_map < string , bool > cache ; return has@@ Square@@ Of@@ Zero@@ es ( matrix , 0 , 0 , last@@ Idx , last@@ Idx , cache ) ; } bool has@@ Square@@ Of@@ Zero@@ es ( vector < vector < int > > & matrix , int r1 , int c1 , int r2 , int c2 , unordered_map < string , bool > & cache ) { if ( r1 >= r2 c1 >= c2 ) return false ; string key = to_string ( r1 ) + ' - ' + to_string ( c1 ) + ' - ' + to_string ( r2 ) + ' - ' + to_string ( c2 ) ; if ( cache . find ( key ) != cache . end ( ) ) return cache [ key ] ; cache [ key ] = is@@ Square@@ Of@@ Zero@@ es ( matrix , r1 , c1 , r2 , c2 ) || has@@ Square@@ Of@@ Zero@@ es ( matrix , r1 + 1 , c1 + 1 , r2 - 1 , c2 - 1 , cache ) || has@@ Square@@ Of@@ Zero@@ es ( matrix , r1 , c1 + 1 , r2 - 1 , c2 , cache ) || has@@ Square@@ Of@@ Zero@@ es ( matrix , r1 + 1 , c1 , r2 , c2 - 1 , cache ) || has@@ Square@@ Of@@ Zero@@ es ( matrix , r1 + 1 , c1 + 1 , r2 , c2 , cache ) || has@@ Square@@ Of@@ Zero@@ es ( matrix , r1 , c1 , r2 - 1 , c2 - 1 , cache ) ; return cache [ key ] ; } bool is@@ Square@@ Of@@ Zero@@ es ( vector < vector < int > > & matrix , int r1 , int c1 , int r2 , int c2 ) { for ( int row = r1 ; row < r2 + 1 ; row ++ ) { if ( matrix [ row ] [ c1 ] != 0 matrix [ row ] [ c2 ] != 0 ) return false ; } for ( int col = c1 ; col < c2 + 1 ; col ++ ) { if ( matrix [ r1 ] [ col ] != 0 matrix [ r2 ] [ col ] != 0 ) return false ; } return true ; } int main ( ) { vector < vector < int > > matrix { { 1 , 1 , 1 , 0 , 1 , 0 } , { 0 , 0 , 0 , 0 , 0 , 1 } , { 0 , 1 , 1 , 1 , 0 , 1 } , { 0 , 0 , 0 , 1 , 0 , 1 } , { 0 , 1 , 1 , 1 , 0 , 1 } , { 0 , 0 , 0 , 0 , 0 , 1 } } ; int ans ; ans = square@@ Of@@ Zero@@ es ( matrix ) ; if ( ans == 1 ) { cout << " True " << endl ; } else { cout << " False " << endl ; } }
Check if a substring can be Pal@@ ind@@ ro@@ mic by replacing K characters for Q queries 6220 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void can@@ Make@@ P@@ ali@@ Queries ( string str , vector < vector < int > > & Q ) { int n = str . length ( ) ; vector < vector < int > > dp ( 26 , vector < int > ( n , 0 ) ) ; for ( int i = 0 ; i < 26 ; i ++ ) { char current@@ Char = i + ' a ' ; for ( int j = 0 ; j < n ; j ++ ) { if ( j == 0 ) { dp [ i ] [ j ] = ( str [ j ] == current@@ Char ) ; } else { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + ( str [ j ] == current@@ Char ) ; } } } for ( auto query : Q ) { int left = query [ 0 ] ; int right = query [ 1 ] ; int k = query [ 2 ] ; int un@@ Matched@@ Count = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { int occurrence = dp [ i ] [ right ] - dp [ i ] [ left ] + ( str [ left ] == ( i + ' a ' ) ) ; if ( occurrence & 1 ) un@@ Matched@@ Count ++ ; } int ans = un@@ Matched@@ Count / 2 ; if ( ans <= k ) { cout << " YES STRNEWLINE " ; } else { cout << " NO STRNEWLINE " ; } } } int main ( ) { string str = " Ge@@ ek@@ s@@ for@@ Ge@@ e@@ ks " ; vector < vector < int > > Q ; Q = { { 1 , 5 , 3 } , { 5 , 7 , 0 } , { 8 , 11 , 3 } , { 3 , 10 , 5 } , { 0 , 9 , 5 } } ; can@@ Make@@ P@@ ali@@ Queries ( str , Q ) ; return 0 ; }
Maximum sum such that exactly half of the elements are selected and no two adjacent 6243 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int Maximum@@ Sum ( int a [ ] , int n ) { int dp [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < n + 1 ; j ++ ) dp [ i ] [ j ] = INT_@@ MIN ; } for ( int i = 0 ; i < n + 1 ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { int val = INT_@@ MIN ; if ( ( i - 2 >= 0 && dp [ i - 2 ] [ j - 1 ] != INT_@@ MIN ) i - 2 < 0 ) { val = a [ i - 1 ] + ( i - 2 >= 0 ? dp [ i - 2 ] [ j - 1 ] : 0 ) ; } if ( i - 1 >= j ) { val = max ( val , dp [ i - 1 ] [ j ] ) ; } dp [ i ] [ j ] = val ; } } return dp [ n ] [ n / 2 ] ; } int main ( ) { int A [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << Maximum@@ Sum ( A , N ) ; return 0 ; }
Count the number of ways to divide N in k groups increment@@ ally 6279 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int dp [ 500 ] [ 500 ] [ 500 ] ; int calculate ( int pos , int prev , int left , int k ) { if ( pos == k ) { if ( left == 0 ) return 1 ; else return 0 ; } if ( left == 0 ) return 0 ; if ( dp [ pos ] [ prev ] [ left ] != -1 ) return dp [ pos ] [ prev ] [ left ] ; int answer = 0 ; for ( int i = prev ; i <= left ; i ++ ) { answer += calculate ( pos + 1 , i , left - i , k ) ; } return dp [ pos ] [ prev ] [ left ] = answer ; } int count@@ Way@@ sto@@ Divide ( int n , int k ) { memset ( dp , -1 , sizeof ( dp ) ) ; return calculate ( 0 , 1 , n , k ) ; } int main ( ) { int N = 8 ; int K = 4 ; cout << count@@ Way@@ sto@@ Divide ( N , K ) ; return 0 ; }
Maximum number of multip@@ les in an array before any element 6301 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; const int MAX = 100000 ; int di@@ visors [ MAX ] ; int generate@@ Di@@ visors ( int n ) { for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { di@@ visors [ i ] ++ ; } else { di@@ visors [ i ] ++ ; di@@ visors [ n / i ] ++ ; } } } } int find@@ Max@@ Multip@@ les ( int * arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans = max ( di@@ visors [ arr [ i ] ] , ans ) ; generate@@ Di@@ visors ( arr [ i ] ) ; } return ans ; } int main ( ) { int arr [ ] = { 8 , 1 , 28 , 4 , 2 , 6 , 7 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << find@@ Max@@ Multip@@ les ( arr , n ) ; return 0 ; }
Egg@@ s dro@@ pping pu@@ zzle | Set 2 6305 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int egg@@ Drop ( int n , int k ) { vector < vector < int > > dp ( k + 1 , vector < int > ( n + 1 , 0 ) ) ; int x = 0 ; while ( dp [ x ] [ n ] < k ) { x ++ ; for ( int i = 1 ; i <= n ; i ++ ) dp [ x ] [ i ] = dp [ x - 1 ] [ i - 1 ] + dp [ x - 1 ] [ i ] + 1 ; } return x ; } int main ( ) { int n = 2 , k = 36 ; cout << egg@@ Drop ( n , k ) ; return 0 ; }
Number of square matrices with all 1 s 6312 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define n 3 NEW_LINE #@@ define m 3 NEW_LINE int count@@ Square@@ Matrices ( int a [ ] [ m ] , int N , int M ) { int count = 0 ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 1 ; j < M ; j ++ ) { if ( a [ i ] [ j ] == 0 ) continue ; a [ i ] [ j ] = min ( min ( a [ i - 1 ] [ j ] , a [ i ] [ j - 1 ] ) , a [ i - 1 ] [ j - 1 ] ) + 1 ; } } for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) count += a [ i ] [ j ] ; return count ; } int main ( ) { int arr [ ] [ m ] = { { 1 , 0 , 1 } , { 1 , 1 , 0 } , { 1 , 1 , 0 } } ; cout << count@@ Square@@ Matrices ( arr , n , m ) ; return 0 ; }
K@@ nap@@ s@@ ack with large Weights 6330 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define V@@ _S@@ UM_@@ MAX 1000 NEW_LINE #@@ define N_@@ MAX 100 NEW_LINE #@@ define W_@@ MAX 10000000 NEW_LINE int dp [ V@@ _S@@ UM_@@ MAX + 1 ] [ N_@@ MAX ] ; bool v [ V@@ _S@@ UM_@@ MAX + 1 ] [ N_@@ MAX ] ; int solve@@ D@@ p ( int r , int i , int * w , int * val , int n ) { if ( r <= 0 ) return 0 ; if ( i == n ) return W_@@ MAX ; if ( v [ r ] [ i ] ) return dp [ r ] [ i ] ; v [ r ] [ i ] = 1 ; dp [ r ] [ i ] = min ( solve@@ D@@ p ( r , i + 1 , w , val , n ) , w [ i ] + solve@@ D@@ p ( r - val [ i ] , i + 1 , w , val , n ) ) ; return dp [ r ] [ i ] ; } int max@@ Weight ( int * w , int * val , int n , int c ) { for ( int i = V@@ _S@@ UM_@@ MAX ; i >= 0 ; i -- ) { if ( solve@@ D@@ p ( i , 0 , w , val , n ) <= c ) { return i ; } } return 0 ; } int main ( ) { int w [ ] = { 3 , 4 , 5 } ; int val [ ] = { 30 , 50 , 60 } ; int n = sizeof ( w ) / sizeof ( int ) ; int C = 8 ; cout << max@@ Weight ( w , val , n , C ) ; return 0 ; }
Number of subsets with a given AND value 6362 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define max@@ N 20 NEW_LINE #@@ define max@@ M 64 NEW_LINE int d@@ p1 [ max@@ N ] [ max@@ M ] ; bool v1 [ max@@ N ] [ max@@ M ] ; int find@@ Cnt ( int * arr , int i , int curr , int n , int m ) { if ( i == n ) { return ( curr == m ) ; } if ( v1 [ i ] [ curr ] ) return d@@ p1 [ i ] [ curr ] ; v1 [ i ] [ curr ] = 1 ; d@@ p1 [ i ] [ curr ] = find@@ Cnt ( arr , i + 1 , curr , n , m ) + find@@ Cnt ( arr , i + 1 , ( curr & arr [ i ] ) , n , m ) ; return d@@ p1 [ i ] [ curr ] ; } int main ( ) { int arr [ ] = { 0 , 0 , 0 } ; int n = sizeof ( arr ) / sizeof ( int ) ; int m = 0 ; cout << find@@ Cnt ( arr , 0 , ( ( 1 << 6 ) - 1 ) , n , m ) ; return 0 ; }
Number of ways to get a given sum with n number of m 6407 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define mod 100000000@@ 7 NEW_LINE int dp [ 55 ] [ 55 ] ; int N@@ oo@@ f@@ W@@ ays ( int face , int throws , int sum ) { if ( sum == 0 && throws == 0 ) return 1 ; if ( sum < 0 throws == 0 ) return 0 ; if ( dp [ throws ] [ sum ] != -1 ) return dp [ throws ] [ sum ] ; int ans = 0 ; for ( int i = 1 ; i <= face ; i ++ ) { ans += N@@ oo@@ f@@ W@@ ays ( face , throws - 1 , sum - i ) ; } return dp [ throws ] [ sum ] = ans ; } int main ( ) { int faces = 6 , throws = 3 , sum = 12 ; memset ( dp , -1 , sizeof dp ) ; cout << N@@ oo@@ f@@ W@@ ays ( faces , throws , sum ) << endl ; return 0 ; }
Queries for bitwise AND in the given matrix 6436 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE #@@ define bits@@ count 32 NEW_LINE #@@ define n 3 NEW_LINE using namespace std ; int prefix_@@ count [ bits@@ count ] [ n ] [ n ] ; void find@@ Prefix@@ Count ( int arr [ ] [ n ] ) { for ( int i = 0 ; i < bits@@ count ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { prefix_@@ count [ i ] [ j ] [ 0 ] = ( ( arr [ j ] [ 0 ] >> i ) & 1 ) ; for ( int k = 1 ; k < n ; k ++ ) { prefix_@@ count [ i ] [ j ] [ k ] = ( ( arr [ j ] [ k ] >> i ) & 1 ) ; prefix_@@ count [ i ] [ j ] [ k ] += prefix_@@ count [ i ] [ j ] [ k - 1 ] ; } } } for ( int i = 0 ; i < bits@@ count ; i ++ ) for ( int j = 1 ; j < n ; j ++ ) for ( int k = 0 ; k < n ; k ++ ) prefix_@@ count [ i ] [ j ] [ k ] += prefix_@@ count [ i ] [ j - 1 ] [ k ] ; } int range@@ And ( int x1 , int y1 , int x2 , int y2 ) { int ans = 0 ; for ( int i = 0 ; i < bits@@ count ; i ++ ) { int p ; if ( x1 == 0 and y1 == 0 ) p = prefix_@@ count [ i ] [ x2 ] [ y2 ] ; else if ( x1 == 0 ) p = prefix_@@ count [ i ] [ x2 ] [ y2 ] - prefix_@@ count [ i ] [ x2 ] [ y1 - 1 ] ; else if ( y1 == 0 ) p = prefix_@@ count [ i ] [ x2 ] [ y2 ] - prefix_@@ count [ i ] [ x1 - 1 ] [ y2 ] ; else p = prefix_@@ count [ i ] [ x2 ] [ y2 ] - prefix_@@ count [ i ] [ x1 - 1 ] [ y2 ] - prefix_@@ count [ i ] [ x2 ] [ y1 - 1 ] + prefix_@@ count [ i ] [ x1 - 1 ] [ y1 - 1 ] ; if ( p == ( x2 - x1 + 1 ) * ( y2 - y1 + 1 ) ) ans = ( ans | ( 1 << i ) ) ; } return ans ; } int main ( ) { int arr [ ] [ n ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; find@@ Prefix@@ Count ( arr ) ; int queries [ ] [ 4 ] = { { 1 , 1 , 1 , 1 } , { 1 , 2 , 2 , 2 } } ; int q = sizeof ( queries ) / sizeof ( queries [ 0 ] ) ; for ( int i = 0 ; i < q ; i ++ ) cout << range@@ And ( queries [ i ] [ 0 ] , queries [ i ] [ 1 ] , queries [ i ] [ 2 ] , queries [ i ] [ 3 ] ) << endl ; return 0 ; }
Find the number of binary strings of length N with at least 3 consecutive 1 s 6458 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int n ; int solve ( int i , int x , int dp [ ] [ 4 ] ) { if ( i < 0 ) return x == 3 ; if ( dp [ i ] [ x ] != -1 ) return dp [ i ] [ x ] ; dp [ i ] [ x ] = solve ( i - 1 , 0 , dp ) ; dp [ i ] [ x ] += solve ( i - 1 , x + 1 , dp ) ; return dp [ i ] [ x ] ; } int main ( ) { n = 4 ; int dp [ n ] [ 4 ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) dp [ i ] [ j ] = -1 ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] [ 3 ] = ( 1 << ( i + 1 ) ) ; } cout << solve ( n - 1 , 0 , dp ) ; return 0 ; }
Lon@@ gest sub@@ array having maximum sum 6571 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max@@ Sub@@ Array@@ Sum ( int arr [ ] , int size ) { int max_@@ so@@ _f@@ ar = arr [ 0 ] ; int curr_@@ max = arr [ 0 ] ; for ( int i = 1 ; i < size ; i ++ ) { curr_@@ max = max ( arr [ i ] , curr_@@ max + arr [ i ] ) ; max_@@ so@@ _f@@ ar = max ( max_@@ so@@ _f@@ ar , curr_@@ max ) ; } return max_@@ so@@ _f@@ ar ; } int len@@ Of@@ Long@@ Sub@@ arr@@ With@@ Given@@ Sum ( int arr [ ] , int n , int k ) { unordered_map < int , int > um ; int sum = 0 , maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum == k ) maxLen = i + 1 ; if ( um . find ( sum ) == um . end ( ) ) um [ sum ] = i ; if ( um . find ( sum - k ) != um . end ( ) ) { if ( maxLen < ( i - um [ sum - k ] ) ) maxLen = i - um [ sum - k ] ; } } return maxLen ; } int len@@ Long@@ Sub@@ arr@@ With@@ Max@@ Sum ( int arr [ ] , int n ) { int max@@ Sum = max@@ Sub@@ Array@@ Sum ( arr , n ) ; return len@@ Of@@ Long@@ Sub@@ arr@@ With@@ Given@@ Sum ( arr , n , max@@ Sum ) ; } int main ( ) { int arr [ ] = { 5 , -2 , -1 , 3 , -@@ 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Length ▁ of ▁ longest ▁ sub@@ array ▁ having ▁ maximum ▁ sum ▁ = ▁ " << len@@ Long@@ Sub@@ arr@@ With@@ Max@@ Sum ( arr , n ) ; return 0 ; }
Partition@@ ing into two contiguous element sub@@ arrays with equal sums 6628 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; struct data { int element ; int position ; } ; struct data find@@ Min@@ Element ( int arr [ ] , int n ) { struct data result ; int prefix@@ Sum [ n ] = { 0 } ; int suffix@@ Sum [ n ] = { 0 } ; prefix@@ Sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { prefix@@ Sum [ i ] = prefix@@ Sum [ i - 1 ] + arr [ i ] ; } suffix@@ Sum [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { suffix@@ Sum [ i ] = suffix@@ Sum [ i + 1 ] + arr [ i ] ; } int min = suffix@@ Sum [ 0 ] ; int pos ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( abs ( suffix@@ Sum [ i + 1 ] - prefix@@ Sum [ i ] ) < min ) { min = abs ( suffix@@ Sum [ i + 1 ] - prefix@@ Sum [ i ] ) ; if ( suffix@@ Sum [ i + 1 ] < prefix@@ Sum [ i ] ) pos = i + 1 ; else pos = i ; } } result . element = min ; result . position = pos ; return result ; } int main ( ) { int arr [ ] = { 10 , 1 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; struct data values ; values = find@@ Min@@ Element ( arr , n ) ; cout << " Minimum ▁ element ▁ : ▁ " << values . element << endl << " Position ▁ : ▁ " << values . position ; return 0 ; }
Minimum remo@@ vals from array to make max 6662 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Ind ( int key , int i , int n , int k , int arr [ ] ) { int start , end , mid , ind = -1 ; start = i + 1 ; end = n - 1 ; while ( start < end ) { mid = start + ( end - start ) / 2 ; if ( arr [ mid ] - key <= k ) { ind = mid ; start = mid + 1 ; } else { end = mid ; } } return ind ; } int remo@@ vals ( int arr [ ] , int n , int k ) { int i , j , ans = n - 1 ; sort ( arr , arr + n ) ; for ( i = 0 ; i < n ; i ++ ) { j = find@@ Ind ( arr [ i ] , i , n , k , arr ) ; if ( j != -1 ) { ans = min ( ans , n - ( j - i + 1 ) ) ; } } return ans ; } int main ( ) { int a [ ] = { 1 , 3 , 4 , 9 , 10 , 11 , 12 , 17 , 20 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int k = 4 ; cout << remo@@ vals ( a , n , k ) ; return 0 ; }
Length of Lon@@ gest Bal@@ anced Sub@@ sequence 6736 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int maxLength ( char s [ ] , int n ) { int invalid@@ Open@@ Br@@ aces = 0 ; int invalid@@ Close@@ Br@@ aces = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ( ' ) { invalid@@ Open@@ Br@@ aces ++ ; } else { if ( invalid@@ Open@@ Br@@ aces == 0 ) { invalid@@ Close@@ Br@@ aces ++ ; } else { invalid@@ Open@@ Br@@ aces -- ; } } } return ( n - ( invalid@@ Open@@ Br@@ aces + invalid@@ Close@@ Br@@ aces ) ) ; } int main ( ) { char s [ ] = " ( ) ( ( ( ( ( ( ) " ; int n = strlen ( s ) ; cout << maxLength ( s , n ) << endl ; return 0 ; }
Lon@@ gest Common Sub@@ sequence with at most k changes allowed 6746 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define MAX 10 NEW_LINE int l@@ cs ( int dp [ MAX ] [ MAX ] [ MAX ] , int ar@@ r1 [ ] , int n , int ar@@ r2 [ ] , int m , int k ) { if ( k < 0 ) return -@@ 1e@@ 7 ; if ( n < 0 m < 0 ) return 0 ; int & ans = dp [ n ] [ m ] [ k ] ; if ( ans != -1 ) return ans ; ans = max ( l@@ cs ( dp , ar@@ r1 , n - 1 , ar@@ r2 , m , k ) , l@@ cs ( dp , ar@@ r1 , n , ar@@ r2 , m - 1 , k ) ) ; if ( ar@@ r1 [ n - 1 ] == ar@@ r2 [ m - 1 ] ) ans = max ( ans , 1 + l@@ cs ( dp , ar@@ r1 , n - 1 , ar@@ r2 , m - 1 , k ) ) ; ans = max ( ans , 1 + l@@ cs ( dp , ar@@ r1 , n - 1 , ar@@ r2 , m - 1 , k - 1 ) ) ; return ans ; } int main ( ) { int k = 1 ; int ar@@ r1 [ ] = { 1 , 2 , 3 , 4 , 5 } ; int ar@@ r2 [ ] = { 5 , 3 , 1 , 4 , 2 } ; int n = sizeof ( ar@@ r1 ) / sizeof ( ar@@ r1 [ 0 ] ) ; int m = sizeof ( ar@@ r2 ) / sizeof ( ar@@ r2 [ 0 ] ) ; int dp [ MAX ] [ MAX ] [ MAX ] ; memset ( dp , -1 , sizeof ( dp ) ) ; cout << l@@ cs ( dp , ar@@ r1 , n , ar@@ r2 , m , k ) << endl ; return 0 ; }
Maximum length sub@@ sequence with difference between adjacent elements as either 0 or 1 6761 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max@@ Len@@ Sub ( int arr [ ] , int n ) { int m@@ ls [ n ] , max = 0 ; for ( int i = 0 ; i < n ; i ++ ) m@@ ls [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( abs ( arr [ i ] - arr [ j ] ) <= 1 && m@@ ls [ i ] < m@@ ls [ j ] + 1 ) m@@ ls [ i ] = m@@ ls [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( max < m@@ ls [ i ] ) max = m@@ ls [ i ] ; return max ; } int main ( ) { int arr [ ] = { 2 , 5 , 6 , 3 , 7 , 6 , 5 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Maximum ▁ length ▁ sub@@ sequence ▁ = ▁ " << max@@ Len@@ Sub ( arr , n ) ; return 0 ; }
n 6774 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define max 100000 NEW_LINE int base@@ conversion ( int arr [ ] , int num , int base ) { int i = 0 , rem , j ; if ( num == 0 ) { return 0 ; } while ( num > 0 ) { rem = num % base ; arr [ i ++ ] = rem ; num /= base ; } return i ; } int main ( ) { int arr [ max ] = { 0 } ; int n = 10 ; int size = base@@ conversion ( arr , n - 1 , 6 ) ; if ( size == 0 ) cout << size ; for ( int i = size - 1 ; i >= 0 ; i -- ) { cout << arr [ i ] ; } return 0 ; }
Count of arrays in which all adjacent elements are such that one of them divide the another 6826 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE #@@ define MAX 1000 NEW_LINE using namespace std ; int nu@@ mo@@ f@@ Array ( int n , int m ) { int dp [ MAX ] [ MAX ] ; vector < int > di [ MAX ] ; vector < int > mu [ MAX ] ; memset ( dp , 0 , sizeof dp ) ; memset ( di , 0 , sizeof di ) ; memset ( mu , 0 , sizeof mu ) ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 2 * i ; j <= m ; j += i ) { di [ j ] . push_back ( i ) ; mu [ i ] . push_back ( j ) ; } di [ i ] . push_back ( i ) ; } for ( int i = 1 ; i <= m ; i ++ ) dp [ 1 ] [ i ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { dp [ i ] [ j ] = 0 ; for ( auto x : di [ j ] ) dp [ i ] [ j ] += dp [ i - 1 ] [ x ] ; for ( auto x : mu [ j ] ) dp [ i ] [ j ] += dp [ i - 1 ] [ x ] ; } } int ans = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { ans += dp [ n ] [ i ] ; di [ i ] . clear ( ) ; mu [ i ] . clear ( ) ; } return ans ; } int main ( ) { int n = 3 , m = 3 ; cout << nu@@ mo@@ f@@ Array ( n , m ) << " STRNEWLINE " ; return 0 ; }
Fin@@ ding the maximum square sub 6849 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE #@@ define Row 6 NEW_LINE #@@ define Col 6 NEW_LINE using namespace std ; int lar@@ gest@@ K@@ Sub@@ matrix ( int a [ ] [ Col ] ) { int dp [ Row ] [ Col ] ; memset ( dp , sizeof ( dp ) , 0 ) ; int result = 0 ; for ( int i = 0 ; i < Row ; i ++ ) { for ( int j = 0 ; j < Col ; j ++ ) { if ( i == 0 j == 0 ) dp [ i ] [ j ] = 1 ; else { if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] && a [ i ] [ j ] == a [ i ] [ j - 1 ] && a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) dp [ i ] [ j ] = min ( min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) , dp [ i - 1 ] [ j - 1 ] ) + 1 ; else dp [ i ] [ j ] = 1 ; } result = max ( result , dp [ i ] [ j ] ) ; } } return result ; } int main ( ) { int a [ Row ] [ Col ] = { 2 , 2 , 3 , 3 , 4 , 4 , 5 , 5 , 7 , 7 , 7 , 4 , 1 , 2 , 7 , 7 , 7 , 4 , 4 , 4 , 7 , 7 , 7 , 4 , 5 , 5 , 5 , 1 , 2 , 7 , 8 , 7 , 9 , 4 , 4 , 4 } ; cout << lar@@ gest@@ K@@ Sub@@ matrix ( a ) << endl ; return 0 ; }
Number of sub@@ sequences in a string di@@ visible by n 6850 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Di@@ visible@@ Sub@@ seq ( string str , int n ) { int len = str . length ( ) ; int dp [ len ] [ n ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ ( str [ 0 ] - '0' ) % n ] ++ ; for ( int i = 1 ; i < len ; i ++ ) { dp [ i ] [ ( str [ i ] - '0' ) % n ] ++ ; for ( int j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ; dp [ i ] [ ( j * 10 + ( str [ i ] - '0' ) ) % n ] += dp [ i - 1 ] [ j ] ; } } return dp [ len - 1 ] [ 0 ] ; } int main ( ) { string str = "12@@ 34" ; int n = 4 ; cout << count@@ Di@@ visible@@ Sub@@ seq ( str , n ) ; return 0 ; }
Printing Lon@@ gest Common Sub@@ sequence | Set 2 ( Printing All ) 6941 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define N 100 NEW_LINE int L [ N ] [ N ] ; set < string > find@@ L@@ CS ( string X , string Y , int m , int n ) { set < string > s ; if ( m == 0 n == 0 ) { s . insert ( " " ) ; return s ; } if ( X [ m - 1 ] == Y [ n - 1 ] ) { set < string > tmp = find@@ L@@ CS ( X , Y , m - 1 , n - 1 ) ; for ( string str : tmp ) s . insert ( str + X [ m - 1 ] ) ; } else { if ( L [ m - 1 ] [ n ] >= L [ m ] [ n - 1 ] ) s = find@@ L@@ CS ( X , Y , m - 1 , n ) ; if ( L [ m ] [ n - 1 ] >= L [ m - 1 ] [ n ] ) { set < string > tmp = find@@ L@@ CS ( X , Y , m , n - 1 ) ; s . insert ( tmp . begin ( ) , tmp . end ( ) ) ; } } return s ; } int L@@ CS ( string X , string Y , int m , int n ) { for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } return L [ m ] [ n ] ; } int main ( ) { string X = " AG@@ TG@@ AT@@ G " ; string Y = " GT@@ TAG " ; int m = X . length ( ) ; int n = Y . length ( ) ; cout << " L@@ CS ▁ length ▁ is ▁ " << L@@ CS ( X , Y , m , n ) << endl ; set < string > s = find@@ L@@ CS ( X , Y , m , n ) ; for ( string str : s ) cout << str << endl ; return 0 ; }
Number of non 6943 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Integr@@ al@@ Solutions ( int n ) { return ( ( n + 1 ) * ( n + 2 ) ) / 2 ; } int main ( ) { int n = 3 ; cout << count@@ Integr@@ al@@ Solutions ( n ) ; return 0 ; }
Partition problem | DP 7040 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool isSub@@ set@@ Sum ( int arr [ ] , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 && sum != 0 ) return false ; if ( arr [ n - 1 ] > sum ) return isSub@@ set@@ Sum ( arr , n - 1 , sum ) ; return isSub@@ set@@ Sum ( arr , n - 1 , sum ) || isSub@@ set@@ Sum ( arr , n - 1 , sum - arr [ n - 1 ] ) ; } bool find@@ Parti@@ ion ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; return isSub@@ set@@ Sum ( arr , n , sum / 2 ) ; } int main ( ) { int arr [ ] = { 3 , 1 , 5 , 9 , 12 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( find@@ Parti@@ ion ( arr , n ) == true ) cout << " Can ▁ be ▁ divided ▁ into ▁ two ▁ subsets ▁ " " of ▁ equal ▁ sum " ; else cout << " Can ▁ not ▁ be ▁ divided ▁ into ▁ two ▁ subsets " " ▁ of ▁ equal ▁ sum " ; return 0 ; }
Maximum amount of money that can be collected by a player in a game of coins 7123 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find ( int N , vector < vector < int > > Arr ) { int amount = 0 ; vector < int > mid_@@ odd ; for ( int i = 0 ; i < N ; i ++ ) { int si@@ z = Arr [ i ] . size ( ) ; for ( int j = 0 ; j < si@@ z / 2 ; j ++ ) amount = amount + Arr [ i ] [ j ] ; if ( si@@ z % 2 == 1 ) mid_@@ odd . push_back ( Arr [ i ] [ si@@ z / 2 ] ) ; } sort ( mid_@@ odd . begin ( ) , mid_@@ odd . end ( ) ) ; for ( int i = 0 ; i < mid_@@ odd . size ( ) ; i ++ ) if ( i % 2 == 0 ) amount = amount + mid_@@ odd [ i ] ; cout << amount << endl ; } int main ( ) { int N = 2 ; vector < vector < int > > Arr { { 5 , 2 , 3 , 4 } , { 1 , 6 } } ; find ( N , Arr ) ; }
Print matrix elements from top 7137 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ Diag@@ onal@@ Traversal ( vector < vector < int > > & nums ) { int max_size = nums . size ( ) ; for ( int i = 0 ; i < nums . size ( ) ; i ++ ) { if ( max_size < nums [ i ] . size ( ) ) { max_size = nums [ i ] . size ( ) ; } } vector < vector < int > > v ( 2 * max_size - 1 ) ; for ( int i = 0 ; i < nums . size ( ) ; i ++ ) { for ( int j = 0 ; j < nums [ i ] . size ( ) ; j ++ ) { v [ i + j ] . push_back ( nums [ i ] [ j ] ) ; } } for ( int i = 0 ; i < v . size ( ) ; i ++ ) { reverse ( v [ i ] . begin ( ) , v [ i ] . end ( ) ) ; for ( int j = 0 ; j < v [ i ] . size ( ) ; j ++ ) cout << v [ i ] [ j ] << " ▁ " ; } } int main ( ) { vector < vector < int > > arr = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; print@@ Diag@@ onal@@ Traversal ( arr ) ; return 0 ; }
Sum of all odd length sub@@ arrays 7148 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int O@@ dd@@ Length@@ Sum ( vector < int > & arr ) { int sum = 0 ; int l = arr . size ( ) ; for ( int i = 0 ; i < l ; i ++ ) { for ( int j = i ; j < l ; j += 2 ) { for ( int k = i ; k <= j ; k ++ ) { sum += arr [ k ] ; } } } return sum ; } int main ( ) { vector < int > arr = { 1 , 5 , 3 , 1 , 2 } ; cout << O@@ dd@@ Length@@ Sum ( arr ) ; return 0 ; }
Re@@ present K as sum of N 7177 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; long long N_@@ bon@@ ac@@ ci [ 100 ] ; void N_@@ bon@@ ac@@ ci_@@ nums ( int n , int k ) { N_@@ bon@@ ac@@ ci [ 0 ] = 1 ; for ( int i = 1 ; i <= 50 ; ++ i ) { for ( int j = i - 1 ; j >= i - k and j >= 0 ; -- j ) N_@@ bon@@ ac@@ ci [ i ] += N_@@ bon@@ ac@@ ci [ j ] ; } vector < long long > ans ; for ( int i = 50 ; i >= 0 ; -- i ) if ( n - N_@@ bon@@ ac@@ ci [ i ] >= 0 ) { ans . push_back ( N_@@ bon@@ ac@@ ci [ i ] ) ; n -= N_@@ bon@@ ac@@ ci [ i ] ; } if ( ans . size ( ) == 1 ) ans . push_back ( 0 ) ; cout << ans . size ( ) << endl ; for ( int i = 0 ; i < ans . size ( ) ; ++ i ) cout << ans [ i ] << " , ▁ " ; } int main ( ) { int n = 21 , k = 5 ; N_@@ bon@@ ac@@ ci_@@ nums ( n , k ) ; return 0 ; }
Bit@@ on@@ ic string 7181 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int check@@ Bit@@ on@@ ic ( string s ) { int i , j ; for ( i = 1 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] > s [ i - 1 ] ) continue ; if ( s [ i ] <= s [ i - 1 ] ) break ; } if ( i == s . size ( ) - 1 ) return 1 ; for ( j = i + 1 ; j < s . size ( ) ; j ++ ) { if ( s [ j ] < s [ j - 1 ] ) continue ; if ( s [ j ] >= s [ j - 1 ] ) break ; } i = j ; if ( i != s . size ( ) ) return 0 ; return 1 ; } int main ( ) { string s = " abc@@ df@@ g@@ cb@@ a " ; ( check@@ Bit@@ on@@ ic ( s ) == 1 ) ? cout << " YES " : cout << " NO " ; return 0 ; }
Generate a unique Array of length N with sum of all sub@@ arrays di@@ visible by N 7184 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void make@@ Array ( int a [ ] , int n ) { for ( int i = 1 ; i <= n ; i ++ ) cout << i * n << " ▁ " ; } int main ( ) { int N = 6 ; int arr [ N ] ; make@@ Array ( arr , N ) ; }
Check whether the string can be printed using same row of q@@ wer@@ ty keyp@@ ad 7214 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int check@@ Q@@ wer@@ ty@@ Row ( char x ) { set < char > first_@@ row = { '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '0' , ' - ' , ' = ' } ; set < char > second_@@ row = { ' Q ' , ' W ' , ' E ' , ' R ' , ' T ' , ' Y ' , ' U ' , ' I ' , ' O ' , ' P ' , ' [ ' , ' ] ' , ' q ' , ' w ' , ' e ' , ' r ' , ' t ' , ' y ' , ' u ' , ' i ' , ' o ' , ' p ' } ; set < char > third_@@ row = { ' A ' , ' S ' , ' D ' , ' F ' , ' G ' , ' H ' , ' J ' , ' K ' , ' L ' , ' ; ' , ' : ' , ' a ' , ' s ' , ' d ' , ' f ' , ' g ' , ' h ' , ' j ' , ' k ' , ' l ' } ; set < char > four@@ th_@@ row = { ' Z ' , ' X ' , ' C ' , ' V ' , ' B ' , ' N ' , ' M ' , ' , ' , ' . ' , ' / ' , ' z ' , ' x ' , ' c ' , ' v ' , ' b ' , ' n ' , ' m ' } ; if ( first_@@ row . count ( x ) > 0 ) { return 1 ; } else if ( second_@@ row . count ( x ) > 0 ) { return 2 ; } else if ( third_@@ row . count ( x ) > 0 ) { return 3 ; } else if ( four@@ th_@@ row . count ( x ) > 0 ) { return 4 ; } return 0 ; } bool check@@ Validity ( string str ) { char x = str [ 0 ] ; int row = check@@ Q@@ wer@@ ty@@ Row ( x ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { x = str [ i ] ; if ( row != check@@ Q@@ wer@@ ty@@ Row ( x ) ) { return false ; } } return true ; } int main ( ) { string str = " Ge@@ ek@@ s@@ for@@ Ge@@ e@@ ks " ; if ( check@@ Validity ( str ) ) cout << " Yes " ; else cout << " No " ; return ( 0 ) ; }
Last digit of sum of numbers in the given range in the Fi@@ bon@@ ac@@ ci series 7217 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; long long fi@@ b ( long long n ) { long long f0 = 0 ; long long f1 = 1 ; if ( n == 0 ) return 0 ; if ( n == 1 ) return 1 ; else { long long rem = n % 60 ; if ( rem == 0 ) return 0 ; for ( long long i = 2 ; i < rem + 3 ; i ++ ) { long long f = ( f0 + f1 ) % 60 ; f0 = f1 ; f1 = f ; } long long s = f1 - 1 ; return s ; } } int main ( ) { long long m = 100@@ 87@@ 88@@ 7 ; long long n = 29@@ 83@@ 09@@ 789@@ 9 ; long long final = abs ( fi@@ b ( n ) - fi@@ b ( m - 1 ) ) ; cout << final % 10 << endl ; }
Print Triangle separated pattern 7234 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int print@@ Pattern ( int i , int j , int n ) { if ( j >= n ) { return 0 ; } if ( i >= n ) { return 1 ; } if ( j == i j == n - 1 - i ) { if ( i == n - 1 - j ) { cout << " / " ; } else { cout << " \ \@@ " ; } } else { cout << " * " ; } if ( print@@ Pattern ( i , j + 1 , n ) == 1 ) { return 1 ; } cout << endl ; return print@@ Pattern ( i + 1 , 0 , n ) ; } int main ( ) { int N = 9 ; print@@ Pattern ( 0 , 0 , N ) ; return 0 ; }
Reverse the sub@@ strings of the given String according to the given Array of indices 7249 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void reverse@@ Str ( string & str , int l , int h ) { int n = h - l ; for ( int i = 0 ; i < n / 2 ; i ++ ) { swap ( str [ i + l ] , str [ n - i - 1 + l ] ) ; } } void reverse@@ String ( string & s , int A [ ] , int n ) { reverse@@ Str ( s , 0 , A [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) reverse@@ Str ( s , A [ i - 1 ] , A [ i ] ) ; reverse@@ Str ( s , A [ n - 1 ] , s . length ( ) ) ; } int main ( ) { string s = " abcdef@@ gh " ; int A [ ] = { 2 , 4 , 6 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; reverse@@ String ( s , A , n ) ; cout << s ; return 0 ; }
Find the element in the matrix generated by given rules 7263 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int getElement ( int N , int r , int c ) { if ( r > c ) return 0 ; if ( r == 1 ) { return c ; } int a = ( r + 1 ) * pow ( 2 , r - 2 ) ; int d = pow ( 2 , r - 1 ) ; c = c - r ; int element = a + d * c ; return element ; } int main ( ) { int N = 4 , R = 3 , C = 4 ; cout << getElement ( N , R , C ) ; return 0 ; }
Check if a string can be formed from another string using given constraints 7298 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool check ( string S1 , string S2 ) { int n1 = S1 . size ( ) ; int n2 = S2 . size ( ) ; unordered_map < int , int > mp ; for ( int i = 0 ; i < n1 ; i ++ ) { mp [ S1 [ i ] ] ++ ; } for ( int i = 0 ; i < n2 ; i ++ ) { if ( mp [ S2 [ i ] ] ) { mp [ S2 [ i ] ] -- ; } else if ( mp [ S2 [ i ] - 1 ] && mp [ S2 [ i ] - 2 ] ) { mp [ S2 [ i ] - 1 ] -- ; mp [ S2 [ i ] - 2 ] -- ; } else { return false ; } } return true ; } int main ( ) { string S1 = " abb@@ at " ; string S2 = " cat " ; if ( check ( S1 , S2 ) ) cout << " YES " ; else cout << " NO " ; }
Count of pal@@ ind@@ ro@@ mic strings of size upto N consisting of first K alphab@@ ets occur@@ ring at most twice 7354 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int length@@ NP@@ al@@ ind@@ ro@@ me ( int N , int K ) { int half = N / 2 ; if ( N & 1 ) { half += 1 ; } int ans = 1 ; for ( int i = 1 ; i <= half ; i ++ ) { ans *= K ; K -- ; } return ans ; } int pal@@ ind@@ ro@@ mic@@ Strings ( int N , int K ) { if ( N == 1 ) { return K ; } if ( N == 2 ) { return 2 * K ; } int ans = 0 ; ans += ( 2 * K ) ; for ( int i = 3 ; i <= N ; i ++ ) { ans += length@@ NP@@ al@@ ind@@ ro@@ me ( i , K ) ; } return ans ; } int main ( ) { int N = 4 , K = 3 ; cout << pal@@ ind@@ ro@@ mic@@ Strings ( N , K ) ; return 0 ; }
Minimum number of characters required to be added to a String such that all lowercase alphab@@ ets occurs as a sub@@ sequence in increasing order 7356 | #@@ include " bits / std@@ c + + . h " NEW_LINE using namespace std ; int L@@ CS ( string & S , int N , string & T , int M , vector < vector < int > > & dp ) { if ( N == 0 or M == 0 ) return 0 ; if ( dp [ N ] [ M ] != -1 ) return dp [ N ] [ M ] ; if ( S [ N - 1 ] == T [ M - 1 ] ) { return dp [ N ] [ M ] = 1 + L@@ CS ( S , N - 1 , T , M - 1 , dp ) ; } return dp [ N ] [ M ] = max ( L@@ CS ( S , N - 1 , T , M , dp ) , L@@ CS ( S , N , T , M - 1 , dp ) ) ; } int minimum@@ Character ( string & S ) { string T = " abcdefghijklmnopqrstuvwx@@ yz " ; int N = S . length ( ) , M = T . length ( ) ; vector < vector < int > > dp ( N + 1 , vector < int > ( M + 1 , -1 ) ) ; return ( 26 - L@@ CS ( S , N , T , M , dp ) ) ; } int main ( ) { string S = " abc@@ d@@ adc " ; cout << minimum@@ Character ( S ) ; return 0 ; }
Find smallest number formed by inserting given digit 7378 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; string Min@@ Value ( string N , int X ) { int len = N . size ( ) ; int position = len + 1 ; if ( N [ 0 ] == ' - ' ) { for ( int i = len - 1 ; i >= 1 ; i -- ) { if ( ( N [ i ] - '0' ) < X ) { position = i ; } } } else { for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( ( N [ i ] - '0' ) > X ) { position = i ; } } } N . insert ( N . begin ( ) + position , X + '0' ) ; return N ; } int main ( ) { string N = "@@ 89@@ " ; int X = 1 ; cout << Min@@ Value ( N , X ) << " STRNEWLINE " ; }
Maximum count of “ 01@@ 0. . ” sub@@ sequences that can be removed from given Binary String 7385 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; void count@@ Operations ( string S ) { int n = S . length ( ) ; int ans = 0 ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( S [ i ] == '0' ) { cnt ++ ; } else { if ( cnt > 0 ) { cnt -- ; ans ++ ; } } } cout << ans ; } int main ( ) { string S = "11@@ 00@@ 1101@@ 0" ; count@@ Operations ( S ) ; return 0 ; }
Check if a permutation of S2 can be obtained by adding or removing characters from S1 7393 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Prime ( int n ) { if ( n <= 1 ) return false ; else if ( n == 2 ) return true ; else if ( n % 2 == 0 ) return false ; for ( int i = 3 ; i <= sqrt ( n ) ; i += 2 ) { if ( n % i == 0 ) return false ; } return true ; } void check@@ Permutation ( string s1 , string s2 ) { int freq [ 26 ] = { 0 } ; for ( char ch : s1 ) { freq [ ch - ' a ' ] -- ; } for ( char ch : s2 ) { freq [ ch - ' a ' ] ++ ; } bool is@@ All@@ Changes@@ Prime = true ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] == 0 ) { continue ; } else if ( ! is@@ Prime ( abs ( freq [ i ] ) ) ) { is@@ All@@ Changes@@ Prime = false ; break ; } } if ( is@@ All@@ Changes@@ Prime ) { cout << " Yes " ; } else { cout << " No " ; } } int main ( ) { string S1 = " ge@@ k@@ for@@ g@@ k " ; string S2 = " ge@@ ek@@ s@@ forge@@ e@@ ks " ; check@@ Permutation ( S1 , S2 ) ; }
Minimum number of replacement done of substring "@@ 01" with "11@@ 0" to remove it completely 7397 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void minimum@@ Operations ( string S , int N ) { int ans = 0 ; int cnt@@ One = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( S [ i ] == '0' ) { ans += cnt@@ One ; cnt@@ One *= 2 ; } else cnt@@ One ++ ; } cout << ans ; } int main ( ) { string S = "00@@ 1" ; int N = S . length ( ) ; minimum@@ Operations ( S , N ) ; return 0 ; }
Count strings having sum of ASCII values of characters equal to a Prime or Arm@@ strong Number 7420 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Prime ( int num ) { bool flag = false ; if ( num > 1 ) { for ( int i = 2 ; i < num ; i ++ ) { if ( ( num % i ) == 0 ) { flag = true ; break ; } } } if ( flag ) return false ; else return true ; } int order ( int x ) { int n = 0 ; while ( x != 0 ) { n = n + 1 ; x = x / 10 ; } return n ; } bool is@@ Arm@@ strong ( int x ) { int n = order ( x ) ; int temp = x ; int sum@@ 1 = 0 ; while ( temp != 0 ) { int r = temp % 10 ; sum@@ 1 = sum@@ 1 + pow ( r , n ) ; temp = temp / 10 ; } return ( sum@@ 1 == x ) ; } int count_@@ arm@@ strong ( vector < string > li ) { int c = 0 ; for ( string ele : li ) { int val = 0 ; for ( char che : ele ) val += che ; if ( is@@ Arm@@ strong ( val ) ) c += 1 ; } return c ; } int count_@@ prime ( vector < string > li ) { int c = 0 ; for ( string ele : li ) { int val = 0 ; for ( char che : ele ) val += che ; if ( is@@ Prime ( val ) ) c += 1 ; } return c ; } int main ( ) { vector < string > arr = { " ge@@ ek@@ s@@ forge@@ e@@ ks " , " a " , " computer " , " sci@@ ence " , " portal " , " for " , " ge@@ e@@ ks " } ; cout << " Number ▁ of ▁ Arm@@ strong ▁ Strings ▁ are : ▁ " << count_@@ arm@@ strong ( arr ) << endl ; cout << " Number ▁ of ▁ Prime ▁ Strings ▁ are : ▁ " << count_@@ prime ( arr ) << endl ; }
Count points which are re@@ visited while following the path specified by a given string 7471 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count ( string S , int X , int Y ) { int N = S . length ( ) ; int temp_@@ x = 0 , temp_@@ y = 0 ; int count = 0 ; set < pair < int , int > > s ; s . insert ( { X , Y } ) ; for ( int i = 0 ; i < N ; i ++ ) { temp_@@ x = X ; temp_@@ y = Y ; if ( S [ i ] == ' U ' ) { X ++ ; } else if ( S [ i ] == ' D ' ) { X -- ; } else if ( S [ i ] == ' R ' ) { Y ++ ; } else { Y -- ; } if ( s . find ( { temp_@@ x + X , temp_@@ y + Y } ) != s . end ( ) ) { count ++ ; } else { s . insert ( { temp_@@ x + X , temp_@@ y + Y } ) ; } } return count ; } int main ( ) { string S = " R@@ DD@@ UD@@ L " ; int X = 0 , Y = 0 ; cout << count ( S , X , Y ) ; return 0 ; }
Minim@@ ize cost to re@@ arrange sub@@ strings to convert a string to a Bal@@ anced Bracket Sequence 7514 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void count@@ Min@@ Moves ( string str ) { int n = str . size ( ) ; int a [ n ] = { 0 } ; int j , ans = 0 , i , sum = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ) ' ) { a [ i ] += sum - 1 ; } else { a [ i ] += sum + 1 ; } sum = a [ i ] ; } if ( sum == 0 ) { i = 1 ; while ( i < n ) { j = i - 1 ; while ( i < n && a [ i ] != 0 ) i ++ ; if ( i < n && a [ i - 1 ] < 0 ) { ans += i - j ; if ( j == 0 ) ans ++ ; } i ++ ; } cout << ans << endl ; } else cout << " - 1 STRNEWLINE " ; } int main ( ) { string str = " ) ( ( ) " ; count@@ Min@@ Moves ( str ) ; return 0 ; }
Minim@@ ize a binary string by repeatedly removing even length sub@@ strings of same characters 7540 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void Print@@ Stack ( stack < char > s ) { if ( s . empty ( ) ) return ; char x = s . top ( ) ; s . pop ( ) ; Print@@ Stack ( s ) ; cout << x ; s . push ( x ) ; } void min@@ String ( string s ) { stack < char > Stack ; Stack . push ( s [ 0 ] ) ; for ( int i = 1 ; i < s . size ( ) ; i ++ ) { if ( Stack . empty ( ) ) { Stack . push ( s [ i ] ) ; } else { if ( Stack . top ( ) == s [ i ] ) { Stack . pop ( ) ; } else { Stack . push ( s [ i ] ) ; } } } Print@@ Stack ( Stack ) ; } int main ( ) { string str = "@@ 101@@ 00@@ 1" ; min@@ String ( str ) ; return 0 ; }
Remove all duplicate adjacent characters from a string using Stack 7572 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; string Short@@ en@@ String ( string str1 ) { stack < char > st ; int i = 0 ; while ( i < str1 . length ( ) ) { if ( st . empty ( ) || str1 [ i ] != st . top ( ) ) { st . push ( str1 [ i ] ) ; i ++ ; } else { st . pop ( ) ; i ++ ; } } if ( st . empty ( ) ) { return ( " Empty ▁ String " ) ; } else { string short_@@ string = " " ; while ( ! st . empty ( ) ) { short_@@ string = st . top ( ) + short_@@ string ; st . pop ( ) ; } return ( short_@@ string ) ; } } int main ( ) { string str1 = " az@@ zx@@ zy " ; cout << Short@@ en@@ String ( str1 ) ; return 0 ; }
Reverse words in a given string | Set 2 7579 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ Rev ( string str ) { stack < string > st ; stringstream ss ( str ) ; string temp ; while ( getline ( ss , temp , ' ▁ ' ) ) { st . push ( temp ) ; } while ( ! st . empty ( ) ) { cout << st . top ( ) << " ▁ " ; st . pop ( ) ; } } int main ( ) { string str ; str = " ge@@ e@@ ks ▁ qui@@ z ▁ practice ▁ code " ; print@@ Rev ( str ) ; return 0 ; }
Maximum number of set bits count in a K 7641 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max@@ Set@@ BitCount ( string s , int k ) { int maxCount = 0 , n = s . length ( ) ; int count = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( s [ i ] == '1' ) count ++ ; } maxCount = count ; for ( int i = k ; i < n ; i ++ ) { if ( s [ i - k ] == '1' ) count -- ; if ( s [ i ] == '1' ) count ++ ; maxCount = max ( maxCount , count ) ; } return maxCount ; } int main ( ) { string s = "100@@ 11@@ 101@@ 0" ; int k = 3 ; cout << ( max@@ Set@@ BitCount ( s , k ) ) ; return 0 ; }
Check if there exists a permutation of given string which doesn '@@ t contain any monoton@@ ous substring 7665 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool check ( string s ) { bool ok = true ; for ( int i = 0 ; i + 1 < s . size ( ) ; ++ i ) ok &= ( abs ( s [ i ] - s [ i + 1 ] ) != 1 ) ; return ok ; } string monoton@@ ous@@ String ( string s ) { string odd = " " , even = " " ; for ( int i = 0 ; i < s . size ( ) ; ++ i ) { if ( s [ i ] % 2 == 0 ) odd += s [ i ] ; else even += s [ i ] ; } sort ( odd . begin ( ) , odd . end ( ) ) ; sort ( even . begin ( ) , even . end ( ) ) ; if ( check ( odd + even ) ) return " Yes " ; else if ( check ( even + odd ) ) return " Yes " ; return " No " ; } int main ( ) { string str = " abcd " ; string ans ; ans = monoton@@ ous@@ String ( str ) ; cout << ans << endl ; return 0 ; }
Make the string lex@@ ico@@ graphic@@ ally smallest and non pal@@ ind@@ ro@@ mic by replacing exactly one character 7678 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; string find@@ Str ( string S ) { int n = S . size ( ) ; for ( int i = 0 ; i < n / 2 ; ++ i ) { if ( S [ i ] != ' a ' ) { S [ i ] = ' a ' ; return S ; } } S [ n - 1 ] = ' b ' ; return n < 2 ? " ▁ - 1 ▁ " : S ; } int main ( ) { string str = " a " ; cout << find@@ Str ( str ) << endl ; string str1 = " ab@@ cc@@ ba " ; cout << find@@ Str ( str1 ) << endl ; return 0 ; }
Transform string str1 into str2 by taking characters from string str@@ 3 7680 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void convert@@ String ( string str1 , string str2 , string str@@ 3 ) { map < char , int > freq ; for ( int i = 0 ; str@@ 3 [ i ] ; i ++ ) { freq [ str@@ 3 [ i ] ] ++ ; } int ptr@@ 1 = 0 ; int ptr2 = 0 ; bool flag = true ; while ( ptr@@ 1 < str1 . length ( ) && ptr2 < str2 . length ( ) ) { if ( str1 [ ptr@@ 1 ] == str2 [ ptr2 ] ) { ptr@@ 1 ++ ; ptr2 ++ ; } else { if ( freq [ str@@ 3 [ ptr2 ] ] > 0 ) { freq [ str@@ 3 [ ptr2 ] ] -- ; ptr2 ++ ; } else { flag = false ; break ; } } } if ( flag && ptr@@ 1 == str1 . length ( ) && ptr2 == str2 . length ( ) ) { cout << " YES " << endl ; } else { cout << " NO " << endl ; } } int main ( ) { string str1 = " ab@@ yz@@ fe " ; string str2 = " abcde@@ yz@@ f " ; string str@@ 3 = " pop@@ ode " ; convert@@ String ( str1 , str2 , str@@ 3 ) ; return 0 ; }
Count the number of strings in an array whose distinct characters are less than equal to M 7694 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE #@@ include <@@ set@@ > NEW_LINE using namespace std ; void distinct ( string S [ ] , int M , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { set < char > set1 ; for ( int j = 0 ; j < S [ i ] . length ( ) ; j ++ ) { if ( set1 . find ( S [ i ] [ j ] ) == set1 . end ( ) ) set1 . insert ( S [ i ] [ j ] ) ; } int c = set1 . size ( ) ; if ( c <= M ) count += 1 ; } cout << ( count ) ; } int main ( ) { string S [ ] = { " HER@@ BI@@ VO@@ RES " , " A@@ ER@@ OP@@ LAN@@ E " , " GE@@ EK@@ S@@ FOR@@ GE@@ E@@ KS " } ; int M = 7 ; int n = sizeof ( S ) / sizeof ( S [ 0 ] ) ; distinct ( S , M , n ) ; return 0 ; }
Construct a string of length L such that each substring of length X has exactly Y distinct letters 7699 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; void String ( int l , int x , int y ) { int p = 97 ; for ( int j = 0 ; j < l ; j ++ ) { char ans = ( char ) ( p + ( j % y ) ) ; cout << ans ; } } int main ( ) { int l = 6 ; int x = 5 ; int y = 3 ; String ( l , x , y ) ; return 0 ; }
Periodic Binary String With Minimum Period and a Given Binary String as Sub@@ sequence . 7712 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ Periodic@@ String ( string S ) { int l = 2 * S . length ( ) ; int count = 0 ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) { if ( S [ i ] == '1' ) count ++ ; } if ( count == S . length ( ) count == 0 ) cout << S << " STRNEWLINE " ; else { char arr [ l ] ; for ( int i = 0 ; i < l ; i += 2 ) { arr [ i ] = '1' ; arr [ i + 1 ] = '0' ; } for ( int i = 0 ; i < l ; i ++ ) cout << arr [ i ] ; cout << " STRNEWLINE " ; } } int main ( ) { string S = "@@ 1111@@ 00@@ 1" ; find@@ Periodic@@ String ( S ) ; return 0 ; }
Count the minimum number of groups formed in a string 7718 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void group_@@ formed ( string S ) { int count = 1 ; for ( int i = 0 ; i < S . size ( ) - 1 ; i ++ ) { if ( S [ i ] != S [ i + 1 ] ) count += 1 ; } cout << ( count ) ; } int main ( ) { string S = " TT@@ WWW " ; group_@@ formed ( S ) ; }
String obtained by rever@@ sing and comp@@ lement@@ ing a Binary string K times 7728 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; string Reverse@@ Comp@@ lement ( string s , int n , int k ) { int rev = ( k + 1 ) / 2 ; int complement = k - rev ; if ( rev % 2 ) reverse ( s . begin ( ) , s . end ( ) ) ; if ( complement % 2 ) { for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '0' ) s [ i ] = '1' ; else s [ i ] = '0' ; } } return s ; } int main ( ) { string str = "100@@ 11" ; int k = 5 ; int n = str . size ( ) ; cout << Reverse@@ Comp@@ lement ( str , n , k ) ; return 0 ; }
Check if any permutation of string is a K times repeated string 7731 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool repe@@ ating@@ String ( string s , int n , int k ) { if ( n % k != 0 ) { return false ; } int frequency [ 123 ] ; for ( int i = 0 ; i < 123 ; i ++ ) { frequency [ i ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { frequency [ s [ i ] ] ++ ; } int repeat = n / k ; for ( int i = 0 ; i < 123 ; i ++ ) { if ( frequency [ i ] % repeat != 0 ) { return false ; } } return true ; } int main ( ) { string s = " abc@@ d@@ cb@@ a " ; int n = s . size ( ) ; int k = 3 ; if ( repe@@ ating@@ String ( s , n , k ) ) { cout << " Yes " << endl ; } else { cout << " No " << endl ; } return 0 ; }
Program to print the given digit in words 7768 | #@@ include " bits / std@@ c + + . h " NEW_LINE using namespace std ; void print@@ Value ( char digit ) { switch ( digit ) { case '0' : cout << " Zero ▁ " ; break ; case '1' : cout << " One ▁ " ; break ; case '2' : cout << " Two ▁ " ; break ; case '3' : cout << " Three ▁ " ; break ; case '4' : cout << " Four ▁ " ; break ; case '5' : cout << " Fi@@ ve ▁ " ; break ; case '6' : cout << " Si@@ x ▁ " ; break ; case '7' : cout << " Se@@ ven ▁ " ; break ; case '8' : cout << " E@@ ight ▁ " ; break ; case '9' : cout << " N@@ ine ▁ " ; break ; } } void print@@ Word ( string N ) { int i , length = N . length ( ) ; for ( i = 0 ; i < length ; i ++ ) { print@@ Value ( N [ i ] ) ; } } int main ( ) { string N = "123" ; print@@ Word ( N ) ; return 0 ; }
Jar@@ o and Jar@@ o 7774 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; double jar@@ o_@@ distance ( string s1 , string s2 ) { if ( s1 == s2 ) return 1.0 ; int len1 = s1 . length ( ) , len2 = s2 . length ( ) ; int max_@@ dist = floor ( max ( len1 , len2 ) / 2 ) - 1 ; int match = 0 ; int hash@@ _s@@ 1 [ s1 . length ( ) ] = { 0 } , hash@@ _s@@ 2 [ s2 . length ( ) ] = { 0 } ; for ( int i = 0 ; i < len1 ; i ++ ) { for ( int j = max ( 0 , i - max_@@ dist ) ; j < min ( len2 , i + max_@@ dist + 1 ) ; j ++ ) if ( s1 [ i ] == s2 [ j ] && hash@@ _s@@ 2 [ j ] == 0 ) { hash@@ _s@@ 1 [ i ] = 1 ; hash@@ _s@@ 2 [ j ] = 1 ; match ++ ; break ; } } if ( match == 0 ) return 0.0 ; double t = 0 ; int point = 0 ; for ( int i = 0 ; i < len1 ; i ++ ) if ( hash@@ _s@@ 1 [ i ] ) { while ( hash@@ _s@@ 2 [ point ] == 0 ) point ++ ; if ( s1 [ i ] != s2 [ point ++ ] ) t ++ ; } t /= 2 ; return ( ( ( double ) match ) / ( ( double ) len1 ) + ( ( double ) match ) / ( ( double ) len2 ) + ( ( double ) match - t ) / ( ( double ) match ) ) / 3.0 ; } int main ( ) { string s1 = " CR@@ ATE " , s2 = " TRACE " ; cout << jar@@ o_@@ distance ( s1 , s2 ) << endl ; return 0 ; }
Minimum sw@@ aps required to make a binary string di@@ visible by 2 ^ k 7787 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Min@@ Sw@@ aps ( string s , int k ) { int ans = 0 ; int c_@@ one = 0 , c_@@ zero = 0 ; for ( int i = s . size ( ) - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == '1' ) c_@@ one ++ ; if ( s [ i ] == '0' ) c_@@ zero ++ , ans += c_@@ one ; if ( c_@@ zero == k ) break ; } if ( c_@@ zero < k ) return -1 ; return ans ; } int main ( ) { string s = "100@@ 11@@ 1" ; int k = 2 ; cout << find@@ Min@@ Sw@@ aps ( s , k ) ; return 0 ; }
Remove vo@@ w@@ els from a string stored in a Binary Tree 7789 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; struct Node { char data ; Node * left , * right ; Node ( char _val ) { data = _val ; left = right = NULL ; } } ; Node * add@@ in@@ BT ( Node * root , char data ) { if ( root == NULL ) { root = new Node ( data ) ; } else { queue < Node * > Q ; Q . push ( root ) ; while ( ! Q . empty ( ) ) { Node * temp = Q . front ( ) ; Q . pop ( ) ; if ( temp -> left == NULL ) { temp -> left = new Node ( data ) ; break ; } else Q . push ( temp -> left ) ; if ( temp -> right == NULL ) { temp -> right = new Node ( data ) ; break ; } else Q . push ( temp -> right ) ; } } return root ; } void print ( Node * root ) { queue < Node * > Q ; Q . push ( root ) ; while ( Q . size ( ) ) { Node * temp = Q . front ( ) ; Q . pop ( ) ; cout << temp -> data ; if ( temp -> left ) Q . push ( temp -> left ) ; if ( temp -> right ) Q . push ( temp -> right ) ; } } bool check@@ vo@@ wel ( char ch ) { ch = tolower ( ch ) ; if ( ch == ' a ' ch == ' e ' ch == ' i ' ch == ' o ' ch == ' u ' ) { return true ; } else { return false ; } } Node * remove@@ vo@@ w@@ els ( Node * root ) { queue < Node * > Q ; Q . push ( root ) ; Node * roo@@ t1 = NULL ; while ( ! Q . empty ( ) ) { Node * temp = Q . front ( ) ; Q . pop ( ) ; if ( ! check@@ vo@@ wel ( temp -> data ) ) { roo@@ t1 = add@@ in@@ BT ( roo@@ t1 , temp -> data ) ; } if ( temp -> left ) { Q . push ( temp -> left ) ; } if ( temp -> right ) { Q . push ( temp -> right ) ; } } return roo@@ t1 ; } int main ( ) { string s = " ge@@ e@@ ks " ; Node * root = NULL ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { root = add@@ in@@ BT ( root , s [ i ] ) ; } root = remove@@ vo@@ w@@ els ( root ) ; print ( root ) ; return 0 ; }
Queries to find the count of vo@@ w@@ els in the sub@@ strings of the given string 7809 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define N 2 NEW_LINE bool is@@ Vo@@ wel ( char ch ) { return ( ch == ' a ' ch == ' e ' ch == ' i ' ch == ' o ' ch == ' u ' ) ; } void perform@@ Queries ( string str , int len , int queries [ ] [ N ] , int q ) { int pre [ len ] ; if ( is@@ Vo@@ wel ( str [ 0 ] ) ) pre [ 0 ] = 1 ; else pre [ 0 ] = 0 ; for ( int i = 1 ; i < len ; i ++ ) { if ( is@@ Vo@@ wel ( str [ i ] ) ) pre [ i ] = 1 + pre [ i - 1 ] ; else pre [ i ] = pre [ i - 1 ] ; } for ( int i = 0 ; i < q ; i ++ ) { if ( queries [ i ] [ 0 ] == 0 ) { cout << pre [ queries [ i ] [ 1 ] ] << " STRNEWLINE " ; } else { cout << ( pre [ queries [ i ] [ 1 ] ] - pre [ queries [ i ] [ 0 ] - 1 ] ) << " STRNEWLINE " ; } } } int main ( ) { string str = " ge@@ ek@@ s@@ forge@@ e@@ ks " ; int len = str . length ( ) ; int queries [ ] [ N ] = { { 1 , 3 } , { 2 , 4 } , { 1 , 9 } } ; int q = ( sizeof ( queries ) / sizeof ( queries [ 0 ] ) ) ; perform@@ Queries ( str , len , queries , q ) ; return 0 ; }
Number of ways to split a binary number such that every part is di@@ visible by 2 7813 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define max@@ N 20 NEW_LINE #@@ define max@@ M 64 NEW_LINE int cnt@@ Splits ( string s ) { if ( s [ s . size ( ) - 1 ] == '1' ) return 0 ; int c_@@ zero = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) c_@@ zero += ( s [ i ] == '0' ) ; return ( int ) pow ( 2 , c_@@ zero - 1 ) ; } int main ( ) { string s = "100@@ 10" ; cout << cnt@@ Splits ( s ) ; return 0 ; }
Find the occurrence of the given binary pattern in the binary representation of the array elements 7837 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; string dec@@ To@@ Binary ( int n ) { int binary@@ Num [ 32 ] ; int i = 0 ; while ( n > 0 ) { binary@@ Num [ i ] = n % 2 ; n = n / 2 ; i ++ ; } string binary = " " ; for ( int j = i - 1 ; j >= 0 ; j -- ) binary += to_string ( binary@@ Num [ j ] ) ; return binary ; } int count@@ Freq ( string & pat , string & txt ) { int M = pat . length ( ) ; int N = txt . length ( ) ; int res = 0 ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; if ( j == M ) { res ++ ; j = 0 ; } } return res ; } void find@@ Occurren@@ ce ( int arr [ ] , int n , string pattern ) { for ( int i = 0 ; i < n ; i ++ ) { string binary = dec@@ To@@ Binary ( arr [ i ] ) ; cout << count@@ Freq ( pattern , binary ) << " ▁ " ; } } int main ( ) { int arr [ ] = { 5 , 106 , 7 , 8 } ; string pattern = "10" ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; find@@ Occurren@@ ce ( arr , n , pattern ) ; return 0 ; }
Find the winner of the game 7844 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find_@@ winner ( string str , int n ) { string str1 = " " , str2 = " " ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { str1 += str [ i ] ; } else { str2 += str [ i ] ; } } sort ( str1 . begin ( ) , str1 . end ( ) ) ; sort ( str2 . begin ( ) , str2 . end ( ) ) ; if ( str1 < str2 ) cout << " A " ; else if ( str2 < str1 ) cout << " B " ; else cout << " Ti@@ e " ; } int main ( ) { string str = " ge@@ ek@@ s@@ forge@@ e@@ ks " ; int n = str . length ( ) ; find_@@ winner ( str , n ) ; return 0 ; }
Program to duplicate Vo@@ w@@ els in String 7855 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Vo@@ wel ( char ch ) { ch = toupper ( ch ) ; return ( ch == ' A ' ch == ' E ' ch == ' I ' ch == ' O ' ch == ' U ' ) ; } string duplicate@@ Vo@@ w@@ els ( string str ) { int t = str . length ( ) ; string res = " " ; for ( int i = 0 ; i < t ; i ++ ) { if ( is@@ Vo@@ wel ( str [ i ] ) ) { res += str [ i ] ; } res += str [ i ] ; } return res ; } int main ( ) { string str = " hello@@ world " ; cout << " Original ▁ String : ▁ " << str << endl ; string res = duplicate@@ Vo@@ w@@ els ( str ) ; cout << " String ▁ with ▁ Vo@@ w@@ els ▁ duplicated : ▁ " << res << endl ; }
Recursive program to replace all occurrences of pi with 3.14 in a given string 7867 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; string replace@@ Pi ( string s ) { if ( s . length ( ) == 0 || s . length ( ) == 1 ) return s ; if ( s [ 0 ] == ' p ' && s [ 1 ] == ' i ' ) { string small@@ Output = replace@@ Pi ( s . substr ( 2 ) ) ; return "@@ 3.14@@ " + small@@ Output ; } else { return s [ 0 ] + replace@@ Pi ( s . substr ( 1 ) ) ; } } int main ( ) { string s = " pi@@ pp@@ pi@@ i@@ ip@@ i " ; string result = replace@@ Pi ( s ) ; cout << result << endl ; return 0 ; }
Lon@@ gest sub@@ sequence with at least one character appearing in every string 7873 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define MAX 26 NEW_LINE int lar@@ gest@@ Sub@@ Seq ( string arr [ ] , int n ) { int count [ MAX ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { string str = arr [ i ] ; bool hash [ MAX ] = { 0 } ; for ( int j = 0 ; j < str . length ( ) ; j ++ ) { hash [ str [ j ] - ' a ' ] = true ; } for ( int j = 0 ; j < MAX ; j ++ ) { if ( hash [ j ] ) count [ j ] ++ ; } } return * ( max_@@ element ( count , count + MAX ) ) ; } int main ( ) { string arr [ ] = { " ab " , " bc " , " de " } ; int n = sizeof ( arr ) / sizeof ( string ) ; cout << lar@@ gest@@ Sub@@ Seq ( arr , n ) ; return 0 ; }
Distin@@ ct strings such that they contains given strings as sub 7879 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; set < string > string@@ Set ; void find_@@ permutation ( string & str1 , string & str2 , int len1 , int len2 , int i , int j , string res ) { if ( res . length ( ) == len1 + len2 ) { string@@ Set . insert ( res ) ; return ; } if ( i < len1 ) find_@@ permutation ( str1 , str2 , len1 , len2 , i + 1 , j , res + str1 [ i ] ) ; if ( j < len2 ) find_@@ permutation ( str1 , str2 , len1 , len2 , i , j + 1 , res + str2 [ j ] ) ; } void print_@@ set ( ) { set < string > :: iterator itr ; for ( itr = string@@ Set . begin ( ) ; itr != string@@ Set . end ( ) ; itr ++ ) cout << ( * itr ) << endl ; } int main ( ) { string str1 = " aa " , str2 = " ab " ; int len1 = str1 . length ( ) ; int len2 = str2 . length ( ) ; find_@@ permutation ( str1 , str2 , len1 , len2 , 0 , 0 , " " ) ; print_@@ set ( ) ; return 0 ; }
Count of non 7882 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int count@@ Sub@@ Str ( string s , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 2 ; ) { if ( s [ i ] == '0' && s [ i + 1 ] == '1' && s [ i + 2 ] == '0' ) { count ++ ; i += 3 ; } else if ( s [ i ] == '1' && s [ i + 1 ] == '0' && s [ i + 2 ] == '1' ) { count ++ ; i += 3 ; } else { i ++ ; } } return count ; } int main ( ) { string s = "@@ 101@@ 0101@@ 01@@ 01" ; int n = s . length ( ) ; cout << count@@ Sub@@ Str ( s , n ) ; return 0 ; }
Find distinct characters in distinct sub@@ strings of a string 7883 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Total@@ Distin@@ ct ( string str ) { int cnt = 0 ; set < string > items ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { string temp = " " ; set < char > ans ; for ( int j = i ; j < str . length ( ) ; ++ j ) { temp = temp + str [ j ] ; ans . insert ( str [ j ] ) ; if ( items . find ( temp ) == items . end ( ) ) { items . insert ( temp ) ; cnt += ans . size ( ) ; } } } return cnt ; } int main ( ) { string str = " AB@@ CA " ; cout << count@@ Total@@ Distin@@ ct ( str ) ; return 0 ; }
Reverse the Words of a String using Stack 7894 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void reverse ( char k [ ] ) { stack < char * > s ; char * token = strtok ( k , " ▁ " ) ; while ( token != NULL ) { s . push ( token ) ; token = strtok ( NULL , " ▁ " ) ; } while ( ! s . empty ( ) ) { cout << s . top ( ) << " ▁ " ; s . pop ( ) ; } } int main ( ) { char k [ ] = " ge@@ e@@ ks ▁ for ▁ ge@@ e@@ ks " ; reverse ( k ) ; return 0 ; }
Count of three non 7900 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Pal@@ in ( int i , int j , int k , int l , int p , int q , string s ) { int start = i , end = q ; while ( start < end ) { if ( s [ start ] != s [ end ] ) return false ; start ++ ; if ( start == j + 1 ) start = k ; end -- ; if ( end == p - 1 ) end = l ; } return true ; } int count@@ Sub@@ Str ( string s ) { int count = 0 ; int n = s . size ( ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i ; j < n - 2 ; j ++ ) { for ( int k = j + 1 ; k < n - 1 ; k ++ ) { for ( int l = k ; l < n - 1 ; l ++ ) { for ( int p = l + 1 ; p < n ; p ++ ) { for ( int q = p ; q < n ; q ++ ) { if ( is@@ Pal@@ in ( i , j , k , l , p , q , s ) ) { count ++ ; } } } } } } } return count ; } int main ( ) { string s = " abc@@ a " ; cout << count@@ Sub@@ Str ( s ) ; return 0 ; }
Find the last non repe@@ ating character in string 7909 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; const int MAX = 256 ; static string last@@ Non@@ Repe@@ ating ( string str , int n ) { int freq [ MAX ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) freq [ str . at ( i ) ] ++ ; for ( int i = n - 1 ; i >= 0 ; i -- ) { char ch = str . at ( i ) ; if ( freq [ ch ] == 1 ) { string res ; res += ch ; return res ; } } return " - 1" ; } int main ( ) { string str = " Ge@@ ek@@ sFor@@ Ge@@ e@@ ks " ; int n = str . size ( ) ; cout << last@@ Non@@ Repe@@ ating ( str , n ) ; return 0 ; }
Maximum length pal@@ ind@@ ro@@ me that can be created with characters in range L and R 7926 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define N 4 NEW_LINE int perform@@ Queries ( int l , int r , int prefix [ N ] [ 26 ] ) { l -- ; r -- ; bool flag = false ; int count = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { int cnt = prefix [ r ] [ i ] ; if ( l > 0 ) cnt -= prefix [ l - 1 ] [ i ] ; if ( cnt % 2 == 1 ) { flag = true ; count += cnt - 1 ; } else count += cnt ; } if ( flag ) count += 1 ; return count ; } void pre@@ Calculate ( string s , int prefix [ N ] [ 26 ] ) { int n = s . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { prefix [ i ] [ s [ i ] - ' a ' ] ++ ; } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) prefix [ i ] [ j ] += prefix [ i - 1 ] [ j ] ; } } int main ( ) { string s = " am@@ im " ; int prefix [ N ] [ 26 ] ; memset ( prefix , 0 , sizeof prefix ) ; pre@@ Calculate ( s , prefix ) ; int queries [ ] [ 2 ] = { { 1 , 4 } , { 3 , 4 } } ; int q = sizeof ( queries ) / sizeof ( queries [ 0 ] ) ; for ( int i = 0 ; i < q ; i ++ ) { cout << perform@@ Queries ( queries [ i ] [ 0 ] , queries [ i ] [ 1 ] , prefix ) << endl ; } return 0 ; }
Cap@@ it@@ alize the first and last character of each word in a string 7942 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; string First@@ And@@ Last ( string str ) { string ch = str ; for ( int i = 0 ; i < ch . length ( ) ; i ++ ) { int k = i ; while ( i < ch . length ( ) && ch [ i ] != ' ▁ ' ) i ++ ; ch [ k ] = ( char ) ( ch [ k ] >= ' a ' && ch [ k ] <= ' z ' ? ( ( int ) ch [ k ] - 32 ) : ( int ) ch [ k ] ) ; ch [ i - 1 ] = ( char ) ( ch [ i - 1 ] >= ' a ' && ch [ i - 1 ] <= ' z ' ? ( ( int ) ch [ i - 1 ] - 32 ) : ( int ) ch [ i - 1 ] ) ; } return ch ; } int main ( ) { string str = " Ge@@ e@@ ks ▁ for ▁ Ge@@ e@@ ks " ; cout << str << " STRNEWLINE " ; cout << First@@ And@@ Last ( str ) ; }
Find the longest sub 7945 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; vector < int > compute_@@ l@@ ps ( string s ) { int n = s . size ( ) ; vector < int > l@@ ps ( n ) ; int len = 0 ; l@@ ps [ 0 ] = 0 ; int i = 1 ; while ( i < n ) { if ( s [ i ] == s [ len ] ) { len ++ ; l@@ ps [ i ] = len ; i ++ ; } else { if ( len != 0 ) len = l@@ ps [ len - 1 ] ; else { l@@ ps [ i ] = 0 ; i ++ ; } } } return l@@ ps ; } void Lon@@ gest@@ substring ( string s ) { vector < int > l@@ ps = compute_@@ l@@ ps ( s ) ; int n = s . size ( ) ; if ( l@@ ps [ n - 1 ] == 0 ) { cout << -1 ; return ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( l@@ ps [ i ] == l@@ ps [ n - 1 ] ) { cout << s . substr ( 0 , l@@ ps [ i ] ) ; return ; } } if ( l@@ ps [ l@@ ps [ n - 1 ] - 1 ] == 0 ) cout << -1 ; else cout << s . substr ( 0 , l@@ ps [ l@@ ps [ n - 1 ] - 1 ] ) ; } int main ( ) { string s = " fix@@ prefix@@ suffix " ; Lon@@ gest@@ substring ( s ) ; return 0 ; }
Find the first maximum length even word from a string 7967 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; string find@@ Max@@ Len@@ Even ( string str ) { int n = str . length ( ) ; int i = 0 ; int curr@@ len = 0 ; int maxlen = 0 ; int st = -1 ; while ( i < n ) { if ( str [ i ] == ' ▁ ' ) { if ( curr@@ len % 2 == 0 ) { if ( maxlen < curr@@ len ) { maxlen = curr@@ len ; st = i - curr@@ len ; } } curr@@ len = 0 ; } else { curr@@ len ++ ; } i ++ ; } if ( curr@@ len % 2 == 0 ) { if ( maxlen < curr@@ len ) { maxlen = curr@@ len ; st = i - curr@@ len ; } } if ( st == -1 ) return " - 1" ; return str . substr ( st , maxlen ) ; } int main ( ) { string str = " this ▁ is ▁ a ▁ test ▁ string " ; cout << find@@ Max@@ Len@@ Even ( str ) ; return 0 ; }
Minimum length substring with exactly K distinct characters 7968 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; string find@@ Min@@ Len@@ Str ( string str , int k ) { int n = str . length ( ) ; int st = 0 ; int end = 0 ; int cnt [ 26 ] ; memset ( cnt , 0 , sizeof ( cnt ) ) ; int dist@@ E@@ le = 0 ; int curr@@ len ; int min@@ len = n ; int start@@ Ind = -1 ; while ( end < n ) { cnt [ str [ end ] - ' a ' ] ++ ; if ( cnt [ str [ end ] - ' a ' ] == 1 ) dist@@ E@@ le ++ ; if ( dist@@ E@@ le > k ) { while ( st < end && dist@@ E@@ le > k ) { if ( cnt [ str [ st ] - ' a ' ] == 1 ) dist@@ E@@ le -- ; cnt [ str [ st ] - ' a ' ] -- ; st ++ ; } } if ( dist@@ E@@ le == k ) { while ( st < end && cnt [ str [ st ] - ' a ' ] > 1 ) { cnt [ str [ st ] - ' a ' ] -- ; st ++ ; } curr@@ len = end - st + 1 ; if ( curr@@ len < min@@ len ) { min@@ len = curr@@ len ; start@@ Ind = st ; } } end ++ ; } return str . substr ( start@@ Ind , min@@ len ) ; } int main ( ) { string str = " ef@@ ec@@ fe@@ fd " ; int k = 4 ; cout << find@@ Min@@ Len@@ Str ( str , k ) ; return 0 ; }
Character pairs from two strings with even sum 7977 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int total@@ Pairs ( string s1 , string s2 ) { int a1 = 0 , b1 = 0 ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { if ( int ( s1 [ i ] ) % 2 != 0 ) a1 ++ ; else b1 ++ ; } int a2 = 0 , b2 = 0 ; for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { if ( int ( s2 [ i ] ) % 2 != 0 ) a2 ++ ; else b2 ++ ; } return ( ( a1 * a2 ) + ( b1 * b2 ) ) ; } int main ( ) { string s1 = " ge@@ e@@ ks " , s2 = " for " ; cout << total@@ Pairs ( s1 , s2 ) ; return 0 ; }
Find the minimum number of preprocess moves required to make two strings equal 7980 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int Pre@@ process ( string A , string B ) { int n = A . size ( ) ; int ans = 0 ; for ( int i = 0 ; i < n / 2 ; i ++ ) { map < char , int > mp ; mp [ A [ i ] ] ++ ; mp [ A [ n - i - 1 ] ] ++ ; mp [ B [ i ] ] ++ ; mp [ B [ n - i - 1 ] ] ++ ; int sz = mp . size ( ) ; if ( sz == 4 ) ans += 2 ; else if ( sz == 3 ) ans += 1 + ( A [ i ] == A [ n - i - 1 ] ) ; else if ( sz == 2 ) ans += mp [ A [ i ] ] != 2 ; } if ( n % 2 == 1 && A [ n / 2 ] != B [ n / 2 ] ) ans ++ ; return ans ; } int main ( ) { string A = " ab@@ ac@@ aba " , B = " bac@@ ab@@ aa " ; cout << Pre@@ process ( A , B ) ; return 0 ; }
Sub@@ string Reverse Pattern 8033 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ Pattern ( char s [ ] , int n ) { cout << s << " STRNEWLINE " ; int i = 0 , j = n - 2 ; while ( i < j ) { char c = s [ i ] ; s [ i ] = s [ j ] ; s [ j ] = c ; i ++ ; j -- ; } i = 0 ; j = n - 2 ; while ( j - i > 1 ) { s [ i ] = s [ j ] = ' * ' ; cout << s << " STRNEWLINE " ; i ++ ; j -- ; } } int main ( ) { char s [ ] = " ge@@ e@@ ks " ; int n = sizeof ( s ) / sizeof ( s [ 0 ] ) ; print@@ Pattern ( s , n ) ; return 0 ; }
Find Bit whose minimum sequence fli@@ ps makes all bits same 8054 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; char bit@@ ToBe@@ Fli@@ pped ( string s ) { char last = s [ s . length ( ) - 1 ] ; char first = s [ 0 ] ; if ( last == first ) { if ( last == '0' ) { return '1' ; } else { return '0' ; } } else if ( last != first ) { return last ; } } int main ( ) { string s = "11@@ 0101@@ 100@@ 0" ; cout << bit@@ ToBe@@ Fli@@ pped ( s ) << endl ; return 0 ; }
Program to check if all characters have even frequency 8116 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; bool check ( string s ) { int freq [ 26 ] = { 0 } ; int n = s . length ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) freq [ s [ i ] - 97 ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( freq [ i ] % 2 == 1 ) return false ; return true ; } int main ( ) { string s = " ab@@ acc@@ aba " ; check ( s ) ? cout << " Yes " << endl : cout << " No " << endl ; return 0 ; }
Remove even frequency characters from the string 8128 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void solve ( string s ) { unordered_map < char , int > m ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { m [ s [ i ] ] ++ ; } string new_@@ string = " " ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( m [ s [ i ] ] % 2 == 0 ) continue ; new_@@ string += s [ i ] ; } cout << new_@@ string << endl ; } int main ( ) { string s = " a@@ ab@@ bb@@ d@@ dee@@ ec@@ c " ; solve ( s ) ; return 0 ; }
Minim@@ ize the length of string by removing occurrence of only one character 8151 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int minimum@@ Length ( string s ) { int max@@ O@@ cc = 0 , n = s . length ( ) ; int arr [ 26 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) arr [ s [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( arr [ i ] > max@@ O@@ cc ) max@@ O@@ cc = arr [ i ] ; return ( n - max@@ O@@ cc ) ; } int main ( ) { string str = " af@@ d@@ de@@ w@@ q@@ d " ; cout << minimum@@ Length ( str ) ; return 0 ; }
Minimum operation require to make first and last character same 8156 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; const int MAX = INT_MAX ; int min@@ Operation ( string & s , int i , int j , int count ) { if ( ( i >= s . size ( ) && j < 0 ) || ( i == j ) ) return MAX ; if ( s [ i ] == s [ j ] ) return count ; if ( i >= s . size ( ) ) return min@@ Operation ( s , i , j - 1 , count + 1 ) ; else if ( j < 0 ) return min@@ Operation ( s , i + 1 , j , count + 1 ) ; else return min ( min@@ Operation ( s , i , j - 1 , count + 1 ) , min@@ Operation ( s , i + 1 , j , count + 1 ) ) ; } int main ( ) { string s = " bac@@ def@@ gh@@ ip@@ alo@@ p " ; int ans = min@@ Operation ( s , 0 , s . size ( ) - 1 , 0 ) ; if ( ans == MAX ) cout << -1 ; else cout << ans ; return 0 ; }
Lon@@ gest common an@@ agram sub@@ sequence from N strings 8176 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; const int MAX_@@ CHAR = 26 ; void frequency ( int fr@@ e [ ] [ MAX_@@ CHAR ] , string s [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { string str = s [ i ] ; for ( int j = 0 ; j < str . size ( ) ; j ++ ) fr@@ e [ i ] [ str [ j ] - ' a ' ] ++ ; } } void Lon@@ gest@@ Sequence ( int fr@@ e [ ] [ MAX_@@ CHAR ] , int n ) { for ( int i = MAX_@@ CHAR - 1 ; i >= 0 ; i -- ) { int mi = fr@@ e [ 0 ] [ i ] ; for ( int j = 1 ; j < n ; j ++ ) mi = min ( fr@@ e [ j ] [ i ] , mi ) ; while ( mi -- ) cout << ( char ) ( ' a ' + i ) ; } } int main ( ) { string s [ ] = { " lo@@ o " , " lo@@ l " , " o@@ live " } ; int n = sizeof ( s ) / sizeof ( s [ 0 ] ) ; int fr@@ e [ n ] [ 26 ] = { 0 } ; frequency ( fr@@ e , s , n ) ; Lon@@ gest@@ Sequence ( fr@@ e , n ) ; return 0 ; }
Minimum bit changes in Binary Cir@@ cul@@ ar array to reach a index 8221 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void minimum@@ Flip ( string s , int x , int y ) { s = s + s ; bool is@@ Op@@ posi@@ te = false ; if ( x > y ) { swap ( x , y ) ; is@@ Op@@ posi@@ te = true ; } int val@@ Clock@@ wise = 0 ; char cur = s [ x ] ; for ( int i = x ; i <= y ; i ++ ) { if ( s [ i ] != cur ) { cur = s [ i ] ; val@@ Clock@@ wise ++ ; } } int val@@ An@@ tic@@ lock@@ wise = 0 ; cur = s [ y ] ; x += s . length ( ) ; for ( int i = y ; i <= x ; i ++ ) { if ( s [ i ] != cur ) { cur = s [ i ] ; val@@ An@@ tic@@ lock@@ wise ++ ; } } if ( val@@ Clock@@ wise <= val@@ An@@ tic@@ lock@@ wise ) { if ( ! is@@ Op@@ posi@@ te ) cout << " Clock@@ wise ▁ " << val@@ Clock@@ wise << endl ; else cout << " An@@ ti - clockwise ▁ " << val@@ An@@ tic@@ lock@@ wise << endl ; } else { if ( ! is@@ Op@@ posi@@ te ) cout << " An@@ ti - clockwise ▁ " << val@@ An@@ tic@@ lock@@ wise << endl ; else cout << " Clock@@ wise ▁ " << val@@ Clock@@ wise << endl ; } } int main ( ) { int x = 0 , y = 8 ; string s = "@@ 0001@@ 10" ; minimum@@ Flip ( s , x , y ) ; return 0 ; }
Lex@@ ico@@ graphical Maximum substring of string 8240 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; string Lex@@ ico@@ graphic@@ al@@ Max@@ String ( string str ) { char max@@ char = ' a ' ; vector < int > index ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] >= max@@ char ) { max@@ char = str [ i ] ; index . push_back ( i ) ; } } string max@@ string = " " ; for ( int i = 0 ; i < index . size ( ) ; i ++ ) { if ( str . substr ( index [ i ] , str . length ( ) ) > max@@ string ) { max@@ string = str . substr ( index [ i ] , str . length ( ) ) ; } } return max@@ string ; } int main ( ) { string str = " ac@@ bac@@ bc " ; cout << Lex@@ ico@@ graphic@@ al@@ Max@@ String ( str ) ; return 0 ; }
Reverse each word in a linked list node 8276 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; struct Node { string c ; struct Node * next ; } ; struct Node * newNode ( string c ) { Node * temp = new Node ; temp -> c = c ; temp -> next = NULL ; return temp ; } ; void reverse_@@ word ( string & str ) { reverse ( str . begin ( ) , str . end ( ) ) ; } void reverse ( struct Node * head ) { struct Node * ptr = head ; while ( ptr != NULL ) { reverse_@@ word ( ptr -> c ) ; ptr = ptr -> next ; } } void print@@ List ( struct Node * head ) { while ( head != NULL ) { cout << head -> c << " ▁ " ; head = head -> next ; } } int main ( ) { Node * head = newNode ( " Ge@@ ek@@ s@@ forge@@ e@@ ks " ) ; head -> next = newNode ( " a " ) ; head -> next -> next = newNode ( " computer " ) ; head -> next -> next -> next = newNode ( " sci@@ ence " ) ; head -> next -> next -> next -> next = newNode ( " portal " ) ; head -> next -> next -> next -> next -> next = newNode ( " for " ) ; head -> next -> next -> next -> next -> next -> next = newNode ( " ge@@ e@@ ks " ) ; cout << " List ▁ before ▁ reverse : ▁ STRNEWLINE " ; print@@ List ( head ) ; reverse ( head ) ; cout << " List after reverse : " ; print@@ List ( head ) ; return 0 ; }
Find i '@@ th Index character in a binary string obtained after n iterations 8289 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void binary_@@ conversion ( string & s , int m ) { while ( m ) { int tmp = m % 2 ; s += tmp + '0' ; m = m / 2 ; } reverse ( s . begin ( ) , s . end ( ) ) ; } int find_@@ character ( int n , int m , int i ) { string s ; binary_@@ conversion ( s , m ) ; string s1 = " " ; for ( int x = 0 ; x < n ; x ++ ) { for ( int y = 0 ; y < s . length ( ) ; y ++ ) { if ( s [ y ] == '1' ) s1 += "10" ; else s1 += "@@ 01" ; } s = s1 ; s1 = " " ; } return s [ i ] - '0' ; } int main ( ) { int m = 5 , n = 2 , i = 8 ; cout << find_@@ character ( n , m , i ) ; return 0 ; }
Sum of all sub@@ sequences of a number 8301 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Sub@@ Sequence ( string s , int num ) { int res = 0 ; int i = 0 ; while ( num ) { if ( num & 1 ) res += s [ i ] - '0' ; i ++ ; num = num >> 1 ; } return res ; } int combined@@ Sum ( string s ) { int n = s . length ( ) ; int c_@@ sum = 0 ; int range = ( 1 << n ) - 1 ; for ( int i = 0 ; i <= range ; i ++ ) c_@@ sum += find@@ Sub@@ Sequence ( s , i ) ; return c_@@ sum ; } int main ( ) { string s = "123" ; cout << combined@@ Sum ( s ) ; return 0 ; }
Create a new string by altern@@ ately combining the characters of two hal@@ ves of the string in reverse 8323 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void solve ( string s ) { int l = s . length ( ) ; int x = l / 2 ; int y = l ; string p = " " ; while ( x > 0 && y > l / 2 ) { p += s [ x - 1 ] ; x -- ; p += s [ y - 1 ] ; y -- ; } if ( y > l / 2 ) { p += s [ y - 1 ] ; y -- ; } cout << p ; } int main ( ) { string s = " sun@@ sh@@ ine " ; solve ( s ) ; return 0 ; }
Convert string X to an an@@ agram of string Y with minimum replacements 8334 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define MAX 26 NEW_LINE void print@@ An@@ agram@@ And@@ Changes ( string X , string Y ) { int coun@@ tx [ MAX ] = { 0 } , coun@@ ty [ MAX ] = { 0 } , ctr@@ x [ MAX ] = { 0 } , c@@ try [ MAX ] = { 0 } ; int change = 0 ; int l = X . length ( ) ; for ( int i = 0 ; i < l ; i ++ ) { coun@@ tx [ X [ i ] - ' A ' ] ++ ; coun@@ ty [ Y [ i ] - ' A ' ] ++ ; } for ( int i = 0 ; i < MAX ; i ++ ) { if ( coun@@ tx [ i ] > coun@@ ty [ i ] ) ctr@@ x [ i ] += ( coun@@ tx [ i ] - coun@@ ty [ i ] ) ; else if ( coun@@ tx [ i ] < coun@@ ty [ i ] ) c@@ try [ i ] += ( coun@@ ty [ i ] - coun@@ tx [ i ] ) ; change += abs ( coun@@ ty [ i ] - coun@@ tx [ i ] ) ; } for ( int i = 0 ; i < l ; i ++ ) { if ( ctr@@ x [ X [ i ] - ' A ' ] == 0 ) continue ; int j ; for ( j = 0 ; j < MAX ; j ++ ) if ( ( c@@ try [ j ] ) > 0 ) break ; if ( coun@@ tx [ X [ i ] - ' A ' ] == ctr@@ x [ X [ i ] - ' A ' ] X [ i ] - ' A ' > j ) { coun@@ tx [ X [ i ] - ' A ' ] -- ; ctr@@ x [ X [ i ] - ' A ' ] -- ; c@@ try [ j ] -- ; X [ i ] = ' A ' + j ; } else coun@@ tx [ X [ i ] - ' A ' ] -- ; } cout << " An@@ agram ▁ : ▁ " << X << endl ; cout << " Number ▁ of ▁ changes ▁ made ▁ : ▁ " << change / 2 ; } int main ( ) { string x = " CDB@@ ABC " , y = " AD@@ C@@ AB@@ D " ; print@@ An@@ agram@@ And@@ Changes ( x , y ) ; return 0 ; }
Count occurrences of a word in string 8374 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Occurren@@ ces ( char * str , string word ) { char * p ; vector < string > a ; p = strtok ( str , " ▁ " ) ; while ( p != NULL ) { a . push_back ( p ) ; p = strtok ( NULL , " ▁ " ) ; } int c = 0 ; for ( int i = 0 ; i < a . size ( ) ; i ++ ) if ( word == a [ i ] ) c ++ ; return c ; } int main ( ) { char str [ ] = " Ge@@ ek@@ s@@ for@@ Ge@@ e@@ ks ▁ A ▁ computer ▁ sci@@ ence ▁ portal ▁ for ▁ ge@@ e@@ ks ▁ " ; string word = " portal " ; cout << count@@ Occurren@@ ces ( str , word ) ; return 0 ; }
Split the string into sub@@ strings using delimiter 8379 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; vector < string > split@@ Strings ( string str , char dl ) { string word = " " ; int num = 0 ; str = str + dl ; int l = str . size ( ) ; vector < string > sub@@ str@@ _list ; for ( int i = 0 ; i < l ; i ++ ) { if ( str [ i ] != dl ) word = word + str [ i ] ; else { if ( ( int ) word . size ( ) != 0 ) sub@@ str@@ _list . push_back ( word ) ; word = " " ; } } return sub@@ str@@ _list ; } int main ( ) { string str = " ge@@ e@@ ks ; for ; ge@@ e@@ ks " ; char dl = ' ; ' ; vector < string > res = split@@ Strings ( str , dl ) ; for ( auto x : res ) cout << x << endl ; return 0 ; }
Lon@@ gest sub@@ sequence of the form 0 * 1 * 0 * in a binary string 8398 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int lon@@ gest@@ Sub@@ seq ( string s ) { int n = s . length ( ) ; int pre_@@ count_@@ 0 [ n + 2 ] ; int pre_@@ count_@@ 1 [ n + 1 ] ; int post_@@ count_@@ 0 [ n + 1 ] ; pre_@@ count_@@ 0 [ 0 ] = 0 ; post_@@ count_@@ 0 [ n + 1 ] = 0 ; pre_@@ count_@@ 1 [ 0 ] = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { pre_@@ count_@@ 0 [ j ] = pre_@@ count_@@ 0 [ j - 1 ] ; pre_@@ count_@@ 1 [ j ] = pre_@@ count_@@ 1 [ j - 1 ] ; post_@@ count_@@ 0 [ n - j + 1 ] = post_@@ count_@@ 0 [ n - j + 2 ] ; if ( s [ j - 1 ] == '0' ) pre_@@ count_@@ 0 [ j ] ++ ; else pre_@@ count_@@ 1 [ j ] ++ ; if ( s [ n - j ] == '0' ) post_@@ count_@@ 0 [ n - j + 1 ] ++ ; } if ( pre_@@ count_@@ 0 [ n ] == n pre_@@ count_@@ 0 [ n ] == 0 ) return n ; int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= n ; j ++ ) ans = max ( pre_@@ count_@@ 0 [ i - 1 ] + pre_@@ count_@@ 1 [ j ] - pre_@@ count_@@ 1 [ i - 1 ] + post_@@ count_@@ 0 [ j + 1 ] , ans ) ; return ans ; } int main ( ) { string s = "@@ 0000@@ 11@@ 10000@@ 0" ; cout << lon@@ gest@@ Sub@@ seq ( s ) ; return 0 ; }
Distin@@ ct permutations of the string | Set 2 8401 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool should@@ Swap ( char str [ ] , int start , int curr ) { for ( int i = start ; i < curr ; i ++ ) if ( str [ i ] == str [ curr ] ) return 0 ; return 1 ; } void find@@ Per@@ mutations ( char str [ ] , int index , int n ) { if ( index >= n ) { cout << str << endl ; return ; } for ( int i = index ; i < n ; i ++ ) { bool check = should@@ Swap ( str , index , i ) ; if ( check ) { swap ( str [ index ] , str [ i ] ) ; find@@ Per@@ mutations ( str , index + 1 , n ) ; swap ( str [ index ] , str [ i ] ) ; } } } int main ( ) { char str [ ] = " AB@@ CA " ; int n = strlen ( str ) ; find@@ Per@@ mutations ( str , 0 , n ) ; return 0 ; }
Maximum number of characters between any two same character in a string 8408 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; const int MAX_@@ CHAR = 256 ; int maximum@@ Chars ( string & str ) { int n = str . length ( ) ; int res = -1 ; int first@@ Ind [ MAX_@@ CHAR ] ; for ( int i = 0 ; i < MAX_@@ CHAR ; i ++ ) first@@ Ind [ i ] = -1 ; for ( int i = 0 ; i < n ; i ++ ) { int first_@@ ind = first@@ Ind [ str [ i ] ] ; if ( first_@@ ind == -1 ) first@@ Ind [ str [ i ] ] = i ; else res = max ( res , abs ( i - first_@@ ind - 1 ) ) ; } return res ; } int main ( ) { string str = " ab@@ ba " ; cout << maximum@@ Chars ( str ) ; return 0 ; }
Length of the longest substring with equal 1 s and 0 s 8414 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool isValid ( string p ) { int n = p . length ( ) ; int c1 = 0 , c0 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( p [ i ] == '0' ) c0 ++ ; if ( p [ i ] == '1' ) c1 ++ ; } return ( c0 == c1 ) ? true : false ; } int lon@@ gest@@ Sub ( string s ) { int max_len = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( isValid ( s . substr ( i , j - i + 1 ) ) && max_len < j - i + 1 ) max_len = j - i + 1 ; } } return max_len ; } int main ( ) { string s = "@@ 101@@ 00@@ 100@@ 0" ; cout << lon@@ gest@@ Sub ( s ) ; return 0 ; }
Generate two output strings depending upon occurrence of character in input string . 8428 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; const int MAX_@@ CHAR = 256 ; void print@@ Du@@ o ( string & str ) { int count@@ Char [ MAX_@@ CHAR ] = { 0 } ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) count@@ Char [ str [ i ] - ' a ' ] ++ ; string str1 = " " , str2 = " " ; for ( int i = 0 ; i < MAX_@@ CHAR ; i ++ ) { if ( count@@ Char [ i ] > 1 ) str2 = str2 + ( char ) ( i + ' a ' ) ; else if ( count@@ Char [ i ] == 1 ) str1 = str1 + ( char ) ( i + ' a ' ) ; } cout << " String ▁ with ▁ characters ▁ occur@@ ring ▁ " << " once : STRNEWLINE " ; cout << str1 << " STRNEWLINE " ; cout << " String ▁ with ▁ characters ▁ occur@@ ring ▁ " << " multiple ▁ times : STRNEWLINE " ; cout << str2 << " STRNEWLINE " ; } int main ( ) { string str = " lo@@ v@@ eto@@ code " ; print@@ Du@@ o ( str ) ; return 0 ; }
Find repeated character present first in a string 8445 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE #@@ include <@@ string@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Repeat@@ First@@ N2 ( char * s ) { int p = -1 , i , j ; for ( i = 0 ; i < strlen ( s ) ; i ++ ) { for ( j = i + 1 ; j < strlen ( s ) ; j ++ ) { if ( s [ i ] == s [ j ] ) { p = i ; break ; } } if ( p != -1 ) break ; } return p ; } int main ( ) { char str [ ] = " ge@@ ek@@ s@@ forge@@ e@@ ks " ; int pos = find@@ Repeat@@ First@@ N2 ( str ) ; if ( pos == -1 ) cout << " Not ▁ found " ; else cout << str [ pos ] ; return 0 ; }
Given two strings check which string makes a pal@@ ind@@ ro@@ me first 8473 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; const int MAX_@@ CHAR = 26 ; char string@@ Pal@@ ind@@ ro@@ me ( string A , string B ) { int count@@ A [ MAX_@@ CHAR ] = { 0 } ; int count@@ B [ MAX_@@ CHAR ] = { 0 } ; int l1 = A . length ( ) , l2 = B . length ( ) ; for ( int i = 0 ; i < l1 ; i ++ ) count@@ A [ A [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < l2 ; i ++ ) count@@ B [ B [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( ( count@@ A [ i ] > 1 && count@@ B [ i ] == 0 ) ) return ' A ' ; return ' B ' ; } int main ( ) { string a = " abcde@@ a " ; string b = " bc@@ de@@ sg " ; cout << string@@ Pal@@ ind@@ ro@@ me ( a , b ) ; return 0 ; }
Maximum length substring having all same characters after k changes 8500 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int find@@ Len ( string & A , int n , int k , char ch ) { int maxlen = 1 ; int cnt = 0 ; int l = 0 , r = 0 ; while ( r < n ) { if ( A [ r ] != ch ) ++ cnt ; while ( cnt > k ) { if ( A [ l ] != ch ) -- cnt ; ++ l ; } maxlen = max ( maxlen , r - l + 1 ) ; ++ r ; } return maxlen ; } int answer ( string & A , int n , int k ) { int maxlen = 1 ; for ( int i = 0 ; i < 26 ; ++ i ) { maxlen = max ( maxlen , find@@ Len ( A , n , k , i + ' A ' ) ) ; maxlen = max ( maxlen , find@@ Len ( A , n , k , i + ' a ' ) ) ; } return maxlen ; } int main ( ) { int n = 5 , k = 2 ; string A = " AB@@ AB@@ A " ; cout << " Maximum ▁ length ▁ = ▁ " << answer ( A , n , k ) << endl ; n = 6 , k = 4 ; string B = " HH@@ HH@@ HH " ; cout << " Maximum ▁ length ▁ = ▁ " << answer ( B , n , k ) << endl ; return 0 ; }
Maximum and minimum sums from two numbers with digit replacements 8626 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int replace@@ Di@@ g ( int x , int from , int to ) { int result = 0 ; int multiply = 1 ; while ( x > 0 ) { int remin@@ der = x % 10 ; if ( remin@@ der == from ) result = result + to * multiply ; else result = result + remin@@ der * multiply ; multiply *= 10 ; x = x / 10 ; } return result ; } void calculate@@ MinMax@@ Sum ( int x1 , int x2 ) { int min@@ Sum = replace@@ Di@@ g ( x1 , 6 , 5 ) + replace@@ Di@@ g ( x2 , 6 , 5 ) ; int max@@ Sum = replace@@ Di@@ g ( x1 , 5 , 6 ) + replace@@ Di@@ g ( x2 , 5 , 6 ) ; cout << " Minimum ▁ sum ▁ = ▁ " << min@@ Sum ; cout << " n@@ Maximum ▁ sum ▁ = ▁ " << max@@ Sum ; } int main ( ) { int x1 = 5@@ 46@@ 6 , x2 = 455@@ 5 ; calculate@@ MinMax@@ Sum ( x1 , x2 ) ; return 0 ; }
E@@ fficient method for 2 '@@ s complement of a binary string 8634 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; string find@@ Tw@@ os@@ complement ( string str ) { int n = str . length ( ) ; int i ; for ( i = n - 1 ; i >= 0 ; i -- ) if ( str [ i ] == '1' ) break ; if ( i == -1 ) return '1' + str ; for ( int k = i - 1 ; k >= 0 ; k -- ) { if ( str [ k ] == '1' ) str [ k ] = '0' ; else str [ k ] = '1' ; } return str ; ; } int main ( ) { string str = "@@ 0000@@ 01@@ 01" ; cout << find@@ Tw@@ os@@ complement ( str ) ; return 0 ; }
Sum of all subsets whose sum is a Perf@@ ect Number from a given array 8822 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int is@@ Perf@@ ect ( int x ) { int sum_@@ div = 1 ; for ( int i = 2 ; i <= x / 2 ; ++ i ) { if ( x % i == 0 ) { sum_@@ div += i ; } } if ( sum_@@ div == x ) { return 1 ; } else return 0 ; } void sub@@ set@@ Sum ( int arr [ ] , int n ) { long long total = 1 << n ; for ( long long i = 0 ; i < total ; i ++ ) { long long sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( i & ( 1 << j ) ) sum += arr [ j ] ; if ( is@@ Perf@@ ect ( sum ) ) { cout << sum << " ▁ " ; } } } int main ( ) { int arr [ ] = { 5 , 4 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sub@@ set@@ Sum ( arr , N ) ; return 0 ; }
Generate all N digit numbers having absolute difference as K between adjacent digits 8832 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void check@@ Until ( int num , int K , int N , vector < int > & ans ) { if ( N == 1 ) { ans . push_back ( num ) ; return ; } if ( ( num % 10 + K ) <= 9 ) check@@ Until ( 10 * num + ( num % 10 + K ) , K , N - 1 , ans ) ; if ( K ) { if ( ( num % 10 - K ) >= 0 ) check@@ Until ( 10 * num + num % 10 - K , K , N - 1 , ans ) ; } } void check ( int K , int N , vector < int > & ans ) { for ( int i = 1 ; i <= 9 ; i ++ ) { check@@ Until ( i , K , N , ans ) ; } } void print ( vector < int > & ans ) { for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { cout << ans [ i ] << " , ▁ " ; } } int main ( ) { int N = 4 , K = 8 ; vector < int > ans ; check ( K , N , ans ) ; print ( ans ) ; return 0 ; }
Rat in a Ma@@ ze with multiple steps or jump allowed 8863 | #@@ include <@@ st@@ dio@@ .@@ h@@ > NEW_LINE #@@ define N 4 NEW_LINE bool solve@@ Ma@@ ze@@ Util ( int ma@@ ze [ N ] [ N ] , int x , int y , int sol [ N ] [ N ] ) ; void print@@ Solution ( int sol [ N ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) printf ( " ▁ % d ▁ " , sol [ i ] [ j ] ) ; printf ( " STRNEWLINE " ) ; } } bool is@@ Safe ( int ma@@ ze [ N ] [ N ] , int x , int y ) { if ( x >= 0 && x < N && y >= 0 && y < N && ma@@ ze [ x ] [ y ] != 0 ) return true ; return false ; } bool solve@@ Ma@@ ze ( int ma@@ ze [ N ] [ N ] ) { int sol [ N ] [ N ] = { { 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 } } ; if ( solve@@ Ma@@ ze@@ Util ( ma@@ ze , 0 , 0 , sol ) == false ) { printf ( " Solution ▁ doesn ' t ▁ exist " ) ; return false ; } print@@ Solution ( sol ) ; return true ; } bool solve@@ Ma@@ ze@@ Util ( int ma@@ ze [ N ] [ N ] , int x , int y , int sol [ N ] [ N ] ) { if ( x == N - 1 && y == N - 1 ) { sol [ x ] [ y ] = 1 ; return true ; } if ( is@@ Safe ( ma@@ ze , x , y ) == true ) { sol [ x ] [ y ] = 1 ; for ( int i = 1 ; i <= ma@@ ze [ x ] [ y ] && i < N ; i ++ ) { if ( solve@@ Ma@@ ze@@ Util ( ma@@ ze , x + i , y , sol ) == true ) return true ; if ( solve@@ Ma@@ ze@@ Util ( ma@@ ze , x , y + i , sol ) == true ) return true ; } sol [ x ] [ y ] = 0 ; return false ; } return false ; } int main ( ) { int ma@@ ze [ N ] [ N ] = { { 2 , 1 , 0 , 0 } , { 3 , 0 , 0 , 1 } , { 0 , 1 , 0 , 1 } , { 0 , 0 , 0 , 1 } } ; solve@@ Ma@@ ze ( ma@@ ze ) ; return 0 ; }
Expected number of moves to reach the end of a board | Matrix Expon@@ enti@@ ation 8921 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE #@@ define maxSize 50 NEW_LINE using namespace std ; vector < vector < double > > matrix_@@ product ( vector < vector < double > > a , vector < vector < double > > b ) { vector < vector < double > > c ( 7 ) ; for ( int i = 0 ; i < 7 ; i ++ ) c [ i ] . resize ( 7 , 0 ) ; for ( int i = 0 ; i < 7 ; i ++ ) for ( int j = 0 ; j < 7 ; j ++ ) for ( int k = 0 ; k < 7 ; k ++ ) c [ i ] [ j ] += a [ i ] [ k ] * b [ k ] [ j ] ; return c ; } vector < vector < double > > mul_@@ exp@@ o ( vector < vector < double > > mul , int p ) { vector < vector < double > > s = { { 1 , 0 , 0 , 0 , 0 , 0 , 0 } , { 0 , 1 , 0 , 0 , 0 , 0 , 0 } , { 0 , 0 , 1 , 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 1 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 , 1 , 0 , 0 } , { 0 , 0 , 0 , 0 , 0 , 1 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 1 } } ; while ( p != 1 ) { if ( p % 2 == 1 ) s = matrix_@@ product ( s , mul ) ; mul = matrix_@@ product ( mul , mul ) ; p /= 2 ; } return matrix_@@ product ( mul , s ) ; } double expected@@ Steps ( int x ) { if ( x == 0 ) return 0 ; if ( x <= 6 ) return 6 ; vector < vector < double > > mul = { { ( double ) 7 / 6 , 1 , 0 , 0 , 0 , 0 , 0 } , { 0 , 0 , 1 , 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 1 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 , 1 , 0 , 0 } , { 0 , 0 , 0 , 0 , 0 , 1 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 1 } , { ( double ) -1 / 6 , 0 , 0 , 0 , 0 , 0 , 0 } } ; mul = mul_@@ exp@@ o ( mul , x - 6 ) ; return ( mul [ 0 ] [ 0 ] + mul [ 1 ] [ 0 ] + mul [ 2 ] [ 0 ] + mul [ 3 ] [ 0 ] + mul [ 4 ] [ 0 ] + mul [ 5 ] [ 0 ] ) * 6 ; } int main ( ) { int n = 10 ; cout << expected@@ Steps ( n - 1 ) ; return 0 ; }
Find 2 ^ ( 2 ^ A ) % B 8938 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define ll long long NEW_LINE ll F ( ll A , ll B ) { if ( A == 1 ) return ( 4 % B ) ; else { ll temp = F ( A - 1 , B ) ; return ( temp * temp ) % B ; } } int main ( ) { ll A = 25 , B = 50 ; cout << F ( A , B ) ; return 0 ; }
Find bit@@ on@@ ic point in given bit@@ on@@ ic sequence 8966 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int binary@@ Search ( int arr [ ] , int left , int right ) { if ( left <= right ) { int mid = ( left + right ) / 2 ; if ( arr [ mid - 1 ] < arr [ mid ] && arr [ mid ] > arr [ mid + 1 ] ) return mid ; if ( arr [ mid ] < arr [ mid + 1 ] ) return binary@@ Search ( arr , mid + 1 , right ) ; else return binary@@ Search ( arr , left , mid - 1 ) ; } return -1 ; } int main ( ) { int arr [ ] = { 6 , 7 , 8 , 11 , 9 , 5 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int index = binary@@ Search ( arr , 1 , n - 2 ) ; if ( index != -1 ) cout << arr [ index ] ; return 0 ; }
Check if it is possible to reach the point ( X , Y ) using distances given in an array 8986 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int is@@ Possible@@ To@@ Re@@ ach ( int A [ ] , int N , int X , int Y ) { double distance = sqrt ( double ( X * X + Y * Y ) ) ; double mx = 0 ; for ( int i = 0 ; i < N ; i ++ ) { mx += double ( A [ i ] ) ; } if ( mx < distance ) { cout << " NO " ; return 0 ; } if ( ( mx - distance ) < 0.000001 ) { cout << " YES " ; return 0 ; } for ( int i = 0 ; i < N ; i ++ ) { if ( distance + mx < double ( 2 ) * double ( A [ i ] ) ) { cout << " No " ; return 0 ; } } cout << " Yes " ; return 0 ; } int main ( ) { int A [ ] = { 2 , 5 } ; int X = 5 , Y = 4 ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; is@@ Possible@@ To@@ Re@@ ach ( A , N , X , Y ) ; return 0 ; }
Find the angle between tang@@ ents drawn from a given external point to a Circle 9005 | #@@ include <@@ c@@ math@@ > NEW_LINE #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; double point_@@ distance ( int x1 , int y1 , int x2 , int y2 ) { int p = ( x2 - x1 ) ; int q = ( y2 - y1 ) ; double distance = sqrt ( p * p + q * q ) ; return distance ; } void tang@@ ent@@ Angle ( int x1 , int y1 , int x2 , int y2 , double radius ) { double distance = point_@@ distance ( x1 , y1 , x2 , y2 ) ; if ( radius / distance > 1 radius / distance < -1 ) { cout << -1 ; } double result = 2 * asin ( radius / distance ) * 180 / 3.14@@ 15 ; cout << result << " ▁ degrees " ; } int main ( ) { int radius = 4 ; int x1 = 7 , y1 = 12 ; int x2 = 3 , y2 = 4 ; tang@@ ent@@ Angle ( x1 , y1 , x2 , y2 , radius ) ; return 0 ; }
Find the area of rho@@ m@@ bus from given Angle and Side length 9061 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define RADI@@ AN 0.01@@ 745@@ 329@@ 252 NEW_LINE float Area@@ _@@ of_@@ R@@ ho@@ m@@ bus ( int a , int theta ) { float area = ( a * a ) * sin ( ( RADI@@ AN * theta ) ) ; return area ; } int main ( ) { int a = 4 ; int theta = 60 ; float ans = Area@@ _@@ of_@@ R@@ ho@@ m@@ bus ( a , theta ) ; printf ( " % 0.2f " , ans ) ; return 0 ; }
Length of diagonal of a paralle@@ log@@ ram using adjacent sides and angle between them 9063 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define PI 3.14@@ 7 NEW_LINE double Length@@ _@@ Diagonal ( int a , int b , double theta ) { double diagonal = sqrt ( ( pow ( a , 2 ) + pow ( b , 2 ) ) - 2 * a * b * cos ( theta * ( PI / 180 ) ) ) ; return diagonal ; } int main ( ) { int a = 3 ; int b = 5 ; double theta = 45 ; double ans = Length@@ _@@ Diagonal ( a , b , theta ) ; printf ( " % .2f " , ans ) ; }
Maximum number of tiles required to cover the floor of given size using 2 x1 size tiles 9064 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void maximum@@ Tiles ( int n , int m ) { cout << ( m * n ) / 2 << endl ; } int main ( ) { int M = 3 ; int N = 4 ; maximum@@ Tiles ( N , M ) ; return 0 ; }
Minimum Sum of Eu@@ clidean Di@@ stances to all given Points 9067 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; double find ( double x , double y , vector < vector < int > > & p ) { double mind = 0 ; for ( int i = 0 ; i < p . size ( ) ; i ++ ) { double a = p [ i ] [ 0 ] , b = p [ i ] [ 1 ] ; mind += sqrt ( ( x - a ) * ( x - a ) + ( y - b ) * ( y - b ) ) ; } return mind ; } double getMin@@ Dist@@ Sum ( vector < vector < int > > & p ) { double x = 0 , y = 0 ; for ( int i = 0 ; i < p . size ( ) ; i ++ ) { x += p [ i ] [ 0 ] ; y += p [ i ] [ 1 ] ; } x = x / p . size ( ) ; y = y / p . size ( ) ; double mind = find ( x , y , p ) ; return mind ; } int main ( ) { vector < vector < int > > vec = { { 0 , 1 } , { 1 , 0 } , { 1 , 2 } , { 2 , 1 } } ; double d = getMin@@ Dist@@ Sum ( vec ) ; cout << d << endl ; return 0 ; }
Number of quad@@ ri@@ later@@ al formed with N distinct points on circum@@ ference of Circle 9087 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i < n + 1 ; i ++ ) res = res * i ; return res ; } int n@@ Cr ( int n , int r ) { return ( fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ) ; } int main ( ) { int n = 5 ; cout << ( n@@ Cr ( n , 4 ) ) ; }
Minimum area of square holding two identical rectangles 9090 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int area@@ Square ( int L , int B ) { int large = max ( L , B ) ; int small = min ( L , B ) ; if ( large >= 2 * small ) return large * large ; else return ( 2 * small ) * ( 2 * small ) ; } int main ( ) { int L = 7 ; int B = 4 ; cout << area@@ Square ( L , B ) ; return 0 ; }
Find if the gl@@ ass will be empty or not when the rate of dr@@ in@@ king is given 9141 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; double pie = 3.1415@@ 9265@@ 35@@ 89@@ 7 ; double find@@ solution ( double d , double h , double m , double n ) { double k = ( 4 * m ) / ( pie * d * d ) ; if ( n > k ) return -1 ; double ans = ( h / ( k - n ) ) ; return ans ; } int main ( ) { double d = 1 , h = 1 , m = 1 , n = 1 ; cout << find@@ solution ( d , h , m , n ) ; return 0 ; }
Angle sub@@ ten@@ ded by an arc at the centre of a circle 9146 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int angle ( int n ) { return 2 * n ; } int main ( ) { int n = 30 ; cout << angle ( n ) ; return 0 ; }
Check whether Quad@@ ri@@ later@@ al is valid or not if angles are given 9158 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool Valid ( int a , int b , int c , int d ) { if ( a + b + c + d == 360 ) return true ; return false ; } int main ( ) { int a = 80 , b = 70 , c = 100 , d = 110 ; if ( Valid ( a , b , c , d ) ) cout << " Valid ▁ quad@@ ri@@ later@@ al " ; else cout << " Invalid ▁ quad@@ ri@@ later@@ al " ; return 0 ; }
Length of the chord the circle if length of the another chord which is equ@@ ally in@@ clin@@ ed through the diameter is given 9182 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void l@@ eng@@ chord ( int z ) { cout << " The ▁ length ▁ is ▁ " << z << endl ; } int main ( ) { int z = 48 ; l@@ eng@@ chord ( z ) ; return 0 ; }
Count pairs from an array having equal sum and quotient 10017 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Pairs ( int a [ ] , int n ) { int count = 0 ; map < double , int > mp ; for ( int i = 0 ; i < n ; i ++ ) { int y = a [ i ] ; if ( y != 0 && y != 1 ) { double x = ( ( y * 1.0 ) / ( 1 - y ) ) * y ; count += mp [ x ] ; } mp [ y ] ++ ; } return count ; } int main ( ) { int arr [ ] = { -@@ 4 , -@@ 3 , 0 , 2 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << count@@ Pairs ( arr , N ) ; return 0 ; }
Queries to count numbers from a range which does not contain digit K in their decimal or octal representation 10019 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool contains ( int num , int K , int base ) { bool is@@ There = 0 ; while ( num ) { int remainder = num % base ; if ( remainder == K ) { is@@ There = 1 ; } num /= base ; } return is@@ There ; } void count ( int n , int k , vector < vector < int > > v ) { int pref [ 10000@@ 05 ] = { 0 } ; for ( int i = 1 ; i < 1e6 + 5 ; i ++ ) { bool present = contains ( i , k , 10 ) || contains ( i , k , 8 ) ; pref [ i ] += pref [ i - 1 ] + present ; } for ( int i = 0 ; i < n ; ++ i ) { cout << v [ i ] [ 1 ] - v [ i ] [ 0 ] + 1 - ( pref [ v [ i ] [ 1 ] ] - pref [ v [ i ] [ 0 ] - 1 ] ) << ' ▁ ' ; } } int main ( ) { int K = 7 ; vector < vector < int > > Q = { { 2 , 5 } , { 1 , 15 } } ; int N = Q . size ( ) ; count ( N , K , Q ) ; }
Count P@@ ron@@ ic numbers from a given range 10045 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int pr@@ on@@ ic ( int num ) { int N = ( int ) sqrt ( num ) ; if ( N * ( N + 1 ) <= num ) { return N ; } return N - 1 ; } int count@@ P@@ ron@@ ic ( int A , int B ) { return pr@@ on@@ ic ( B ) - pr@@ on@@ ic ( A - 1 ) ; } int main ( ) { int A = 3 ; int B = 20 ; cout << count@@ P@@ ron@@ ic ( A , B ) ; return 0 ; }
Minim@@ ize sw@@ aps required to place largest and smallest array elements at first and last array indices 10067 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int minimum@@ Moves ( int * a , int n ) { int min_@@ element = INT_MAX ; int max_@@ element = INT_@@ MIN ; int min_@@ ind = -1 ; int max_@@ ind = -1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] <= min_@@ element ) { min_@@ element = a [ i ] ; min_@@ ind = i ; } if ( a [ i ] > max_@@ element ) { max_@@ element = a [ i ] ; max_@@ ind = i ; } } if ( max_@@ ind == min_@@ ind ) { return 0 ; } else if ( max_@@ ind > min_@@ ind ) { return max_@@ ind + ( n - min_@@ ind - 2 ) ; } else { return max_@@ ind + n - min_@@ ind - 1 ; } } int main ( ) { int arr [ ] = { 35 , 46 , 17 , 23 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minimum@@ Moves ( arr , N ) << endl ; }
Find the index of the smallest element to be removed to make sum of array di@@ visible by K 10069 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Index ( int arr [ ] , int n , int K ) { int sum = 0 ; int res = -1 ; int mini = 1e@@ 9 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { int temp = sum - arr [ i ] ; if ( temp % K == 0 ) { if ( res == -1 mini > arr [ i ] ) { res = i + 1 ; mini = arr [ i ] ; } } } return res ; } int main ( ) { int arr [ ] = { 14 , 7 , 8 , 2 , 4 } ; int K = 7 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << find@@ Index ( arr , N , K ) ; return 0 ; }
Count odd and even Bin@@ omial Coefficients of N 10123 | #@@ include <@@ io@@ stream@@ > NEW_LINE #@@ include <@@ math@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Set@@ Bits ( int N ) { int count = 0 ; while ( N ) { N = N & ( N - 1 ) ; count ++ ; } return count ; } int main ( ) { int N = 4 ; int bits = count@@ Set@@ Bits ( N ) ; cout << " Odd ▁ " << " : ▁ " << pow ( 2 , bits ) << " STRNEWLINE " ; cout << " Even ▁ " << " : ▁ " << N + 1 - pow ( 2 , bits ) << " STRNEWLINE " ; return 0 ; }
Program to calculate Variance of first N Natur@@ al Numbers 10127 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; long double find_@@ Variance ( int n ) { long long int numerator = n * n - 1 ; long double ans = ( numerator * 1.0 ) / 12 ; return ans ; } int main ( ) { int N = 5 ; cout << fixed << setprecision ( 6 ) << find_@@ Variance ( N ) ; }
Difference between sum of odd and even frequ@@ ent elements in an Array 10129 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Sum ( int arr [ ] , int N ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { mp [ arr [ i ] ] ++ ; } int sum_@@ odd = 0 , sum_@@ even = 0 ; for ( auto itr = mp . begin ( ) ; itr != mp . end ( ) ; itr ++ ) { if ( itr -> second % 2 != 0 ) sum_@@ odd += ( itr -> first ) * ( itr -> second ) ; if ( itr -> second % 2 == 0 ) sum_@@ even += ( itr -> first ) * ( itr -> second ) ; } int diff = sum_@@ even - sum_@@ odd ; return diff ; } int main ( ) { int arr [ ] = { 1 , 5 , 5 , 2 , 4 , 3 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << find@@ Sum ( arr , N ) ; return 0 ; }
Sum of the first N terms of XOR Fi@@ bon@@ ac@@ ci series 10133 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ Sum ( int a , int b , int n ) { if ( n == 1 ) { cout << a ; return ; } int s = a + b ; for ( int i = 0 ; i < n - 2 ; i ++ ) { int x = a xor b ; s += x ; a = b ; b = x ; } cout << s ; } int main ( ) { int a = 2 , b = 5 , N = 8 ; find@@ Sum ( a , b , N ) ; return 0 ; }
Minimum value to be added to maxim@@ ize Bit@@ wise XOR of the given array 10138 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; unsigned int ones@@ Comp@@ lement ( unsigned int n , int max@@ Element ) { int bits = floor ( log2 ( max@@ Element ) ) + 1 ; return ( ( 1 << bits ) - 1 ) ^ n ; } int find@@ Number ( int arr [ ] , int n ) { unsigned int res = 0 ; int max@@ Element = 0 ; for ( int i = 0 ; i < n ; i ++ ) { res = res ^ arr [ i ] ; if ( max@@ Element < arr [ i ] ) max@@ Element = arr [ i ] ; } res = ones@@ Comp@@ lement ( res , max@@ Element ) ; return ( res ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << find@@ Number ( arr , N ) ; return 0 ; }
Lar@@ gest divisor of a number not di@@ visible by another given number 10155 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ The@@ Gre@@ atest@@ X ( int P , int Q ) { map < int , int > di@@ visi@@ ors ; for ( int i = 2 ; i * i <= Q ; i ++ ) { while ( Q % i == 0 and Q > 1 ) { Q /= i ; di@@ visi@@ ors [ i ] ++ ; } } if ( Q > 1 ) di@@ visi@@ ors [ Q ] ++ ; int ans = 0 ; for ( auto i : di@@ visi@@ ors ) { int frequency = i . second ; int temp = P ; int cur = 0 ; while ( temp % i . first == 0 ) { temp /= i . first ; cur ++ ; } if ( cur < frequency ) { ans = P ; break ; } temp = P ; for ( int j = cur ; j >= frequency ; j -- ) { temp /= i . first ; } ans = max ( temp , ans ) ; } cout << ans ; } int main ( ) { int P = 10 , Q = 4 ; find@@ The@@ Gre@@ atest@@ X ( P , Q ) ; return 0 ; }
Count set bits in Bit@@ wise XOR of all adjacent elements upto N 10165 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ X@@ OR@@ Set@@ Bits@@ Ad@@ j@@ Elem@@ Range@@ 1_@@ N ( int N ) { int total_@@ set_@@ bits = 0 ; int bit_@@ Position = 1 ; while ( N ) { total_@@ set_@@ bits += ( ( N + 1 ) / 2 * bit_@@ Position ) ; N -= ( N + 1 ) / 2 ; bit_@@ Position ++ ; } return total_@@ set_@@ bits ; } int main ( ) { int N = 4 ; cout << count@@ X@@ OR@@ Set@@ Bits@@ Ad@@ j@@ Elem@@ Range@@ 1_@@ N ( N ) ; return 0 ; }
Maxim@@ ize Bit@@ wise AND of first element with complement of remaining elements for any permutation of given Array 10212 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define size_@@ int 32 NEW_LINE int function@@ Max ( int arr [ ] , int n ) { vector < int > set@@ Bit [ 32 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < size_@@ int ; j ++ ) { if ( arr [ i ] & ( 1 << j ) ) set@@ Bit [ j ] . push_back ( i ) ; } } for ( int i = size_@@ int ; i >= 0 ; i -- ) { if ( set@@ Bit [ i ] . size ( ) == 1 ) { swap ( arr [ 0 ] , arr [ set@@ Bit [ i ] [ 0 ] ] ) ; break ; } } int max@@ And = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { max@@ And = max@@ And & ( ~ arr [ i ] ) ; } return max@@ And ; } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 8 , 16 } ; int n = sizeof arr / sizeof arr [ 0 ] ; cout << function@@ Max ( arr , n ) ; return 0 ; }
Highe@@ st power of 2 that divi@@ des the LC@@ M of first N Natur@@ al numbers . 10219 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int highest@@ Power ( int n ) { return log ( n ) / log ( 2 ) ; } int main ( ) { int n = 15 ; cout << highest@@ Power ( n ) ; return 0 ; }
Check whether a number can be represented as difference of two consecutive cub@@ es 10230 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print ( int N ) { for ( int i = 0 ; i < 100000 ; i ++ ) { if ( pow ( i + 1 , 3 ) - pow ( i , 3 ) == N ) { cout << i << ' ▁ ' << i + 1 ; return ; } } } bool is@@ Per@@ fec@@ t@@ Square ( long double x ) { long double sr = sqrt ( x ) ; return ( ( sr - floor ( sr ) ) == 0 ) ; } bool diff@@ Cube ( int N ) { return is@@ Per@@ fec@@ t@@ Square ( 12 * N - 3 ) ; } int main ( ) { int N = 19 ; if ( diff@@ Cube ( N ) ) { cout << " Yes STRNEWLINE " ; print ( N ) ; } else { cout << " No STRNEWLINE " ; } return 0 ; }
Is it possible to reach N and M from 1 and 0 respectively as per given condition 10249 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is_@@ possible ( int x , int y ) { if ( x < 2 && y != 0 ) return false ; y = y - x + 1 ; if ( y % 2 == 0 && y >= 0 ) return true ; else return false ; } int main ( ) { int x = 5 , y = 2 ; if ( is_@@ possible ( x , y ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
Construct a Maximum Binary Tree from two given Binary Trees 10253 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; class Node { public : int data ; Node * left , * right ; Node ( int data , Node * left , Node * right ) { this -> data = data ; this -> left = left ; this -> right = right ; } } ; Node * newNode ( int data ) { Node * tmp = new Node ( data , NULL , NULL ) ; return tmp ; } void in@@ order ( Node * node ) { if ( node == NULL ) return ; in@@ order ( node -> left ) ; cout << node -> data << " ▁ " ; in@@ order ( node -> right ) ; } Node * Maximum@@ Binary@@ Tree ( Node * t1 , Node * t2 ) { if ( t1 == NULL ) return t2 ; if ( t2 == NULL ) return t1 ; t1 -> data = max ( t1 -> data , t2 -> data ) ; t1 -> left = Maximum@@ Binary@@ Tree ( t1 -> left , t2 -> left ) ; t1 -> right = Maximum@@ Binary@@ Tree ( t1 -> right , t2 -> right ) ; return t1 ; } int main ( ) { Node * roo@@ t1 = newNode ( 3 ) ; roo@@ t1 -> left = newNode ( 2 ) ; roo@@ t1 -> right = newNode ( 6 ) ; roo@@ t1 -> left -> left = newNode ( 20 ) ; Node * root@@ 2 = newNode ( 5 ) ; root@@ 2 -> left = newNode ( 1 ) ; root@@ 2 -> right = newNode ( 8 ) ; root@@ 2 -> left -> right = newNode ( 2 ) ; root@@ 2 -> right -> right = newNode ( 8 ) ; Node * root@@ 3 = Maximum@@ Binary@@ Tree ( roo@@ t1 , root@@ 2 ) ; in@@ order ( root@@ 3 ) ; }
Fast Expon@@ ention using Bit Manip@@ ulation 10267 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int power@@ Optim@@ ised ( int a , int n ) { int ans = 1 ; while ( n > 0 ) { int last_@@ bit = ( n & 1 ) ; if ( last_@@ bit ) { ans = ans * a ; } a = a * a ; n = n >> 1 ; } return ans ; } int main ( ) { int a = 3 , n = 5 ; cout << power@@ Optim@@ ised ( a , n ) ; return 0 ; }
Maxim@@ ize count of distinct elements possible in an Array from the given operation 10285 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int gcd ( int x , int y ) { if ( x == 0 ) return y ; return gcd ( y % x , x ) ; } int find@@ Distin@@ ct ( int arr [ ] , int n ) { int maximum = * max_@@ element ( arr , arr + n ) ; if ( n == 1 ) return 1 ; if ( n == 2 ) { return ( maximum / gcd ( arr [ 0 ] , arr [ 1 ] ) ) ; } int k = gcd ( arr [ 0 ] , arr [ 1 ] ) ; for ( int i = 2 ; i < n ; i ++ ) { k = gcd ( k , arr [ i ] ) ; } return ( maximum / k ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << find@@ Distin@@ ct ( arr , n ) ; return 0 ; }
Check whether count of odd and even factors of a number are equal 10303 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define ll@@ i long long int NEW_LINE void is@@ Equal@@ Factors ( ll@@ i N ) { ll@@ i ev@@ _count = 0 , o@@ d_@@ count = 0 ; for ( ll@@ i i = 1 ; i <= sqrt ( N ) + 1 ; i ++ ) { if ( N % i == 0 ) { if ( i == N / i ) { if ( i % 2 == 0 ) ev@@ _count += 1 ; else o@@ d_@@ count += 1 ; } else { if ( i % 2 == 0 ) ev@@ _count += 1 ; else o@@ d_@@ count += 1 ; if ( ( N / i ) % 2 == 0 ) ev@@ _count += 1 ; else o@@ d_@@ count += 1 ; } } } if ( ev@@ _count == o@@ d_@@ count ) cout << " YES " << endl ; else cout << " NO " << endl ; } int main ( ) { ll@@ i N = 10 ; is@@ Equal@@ Factors ( N ) ; return 0 ; }
Maximum OR value of a pair in an Array | Set 2 10320 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max@@ OR ( int arr [ ] , int n ) { int max_value = * max_@@ element ( arr , arr + n ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans = max ( ans , ( max_value arr [ i ] ) ) ; } return ans ; } int main ( ) { int arr [ ] = { 3 , 6 , 8 , 16 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << max@@ OR ( arr , n ) ; return 0 ; }
Primitive Ab@@ und@@ ant Number 10372 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int getS@@ um ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) sum = sum + i ; { sum = sum + i ; sum = sum + ( n / i ) ; } } } return sum ; } bool check@@ Ab@@ und@@ ant ( int n ) { return ( getS@@ um ( n ) - n > n ) ; } bool is@@ De@@ fici@@ ent ( int n ) { return ( getS@@ um ( n ) < ( 2 * n ) ) ; } bool check@@ Primitive@@ Ab@@ und@@ ant ( int num ) { if ( ! check@@ Ab@@ und@@ ant ( num ) ) { return false ; } for ( int i = 2 ; i <= sqrt ( num ) ; i ++ ) { if ( num % i == 0 && i != num ) { if ( i * i == num ) { if ( ! is@@ De@@ fici@@ ent ( i ) ) { return false ; } } else if ( ! is@@ De@@ fici@@ ent ( i ) || ! is@@ De@@ fici@@ ent ( num / i ) ) { return false ; } } } return true ; } int main ( ) { int n = 20 ; if ( check@@ Primitive@@ Ab@@ und@@ ant ( n ) ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
Can@@ ada Numbers 10375 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int div@@ Sum ( int num ) { int result = 0 ; for ( int i = 1 ; i <= sqrt ( num ) ; i ++ ) { if ( num % i == 0 ) { if ( i == ( num / i ) ) result += i ; else result += ( i + num / i ) ; } } return ( result - 1 - num ) ; } int getS@@ um ( int n ) { int sum = 0 ; while ( n != 0 ) { int r = n % 10 ; sum = sum + r * r ; n = n / 10 ; } return sum ; } bool is@@ Can@@ ada ( int n ) { return div@@ Sum ( n ) == getS@@ um ( n ) ; } int main ( ) { int n = 125 ; if ( is@@ Can@@ ada ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
Count of elements not di@@ visible by any other elements of Array 10399 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ E@@ le ( int a [ ] , int n ) { int len = 0 ; unordered_map < int , int > h@@ map ; for ( int i = 0 ; i < n ; i ++ ) { len = max ( len , a [ i ] ) ; h@@ map [ a [ i ] ] ++ ; } bool v [ len + 1 ] ; for ( int i = 0 ; i <= len ; i ++ ) { v [ i ] = true ; } for ( int i = 0 ; i < n ; i ++ ) { if ( v [ a [ i ] ] == false ) continue ; for ( int j = 2 * a [ i ] ; j <= len ; j += a [ i ] ) { v [ j ] = false ; } } int count = 0 ; for ( int i = 1 ; i <= len ; i ++ ) { if ( v [ i ] == true && h@@ map . count ( i ) == 1 && h@@ map [ i ] == 1 ) { count += 1 ; } } return count ; } int main ( ) { int arr [ ] = { 86 , 45 , 18 , 4 , 8 , 28 , 19 , 33 , 2 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << count@@ E@@ le ( arr , n ) ; return 0 ; }
Maxim@@ ize sum of absolute difference between adjacent elements in Array with sum K 10406 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max@@ Adjac@@ ent@@ Difference ( int N , int K ) { if ( N == 1 ) { return 0 ; } if ( N == 2 ) { return K ; } return 2 * K ; } int main ( ) { int N = 6 ; int K = 11 ; cout << max@@ Adjac@@ ent@@ Difference ( N , K ) ; return 0 ; }
Check if row 10413 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Pal ( int a [ 3 ] [ 3 ] , int n , int m ) { for ( int i = 0 ; i < n / 2 ; i ++ ) { for ( int j = 0 ; j < m - 1 ; j ++ ) { if ( a [ i ] [ j ] != a [ n - 1 - i ] [ m - 1 - j ] ) return false ; } } return true ; } int main ( ) { int n = 3 , m = 3 ; int a [ 3 ] [ 3 ] = { { 1 , 2 , 3 } , { 4 , 5 , 4 } , { 3 , 2 , 1 } } ; if ( is@@ Pal ( a , n , m ) ) { cout << " YES " << endl ; } else { cout << " NO " << endl ; } }
Un@@ touch@@ able Number 10440 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int div@@ Sum ( int num ) { int result = 0 ; for ( int i = 2 ; i <= sqrt ( num ) ; i ++ ) { if ( num % i == 0 ) { if ( i == ( num / i ) ) result += i ; else result += ( i + num / i ) ; } } return ( result + 1 ) ; } bool isUn@@ touch@@ able ( int n ) { for ( int i = 1 ; i <= 2 * n ; i ++ ) { if ( div@@ Sum ( i ) == n ) return false ; } return true ; } int main ( ) { int N = 52 ; if ( isUn@@ touch@@ able ( n ) ) cout << " Yes " ; else cout << " No " ; }
120 10477 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int gon@@ Num@@ 120 ( int n ) { return ( 118 * n * n - 116 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << gon@@ Num@@ 120 ( n ) ; return 0 ; }
Construct an Array such that cube sum of all element is a perfect square 10546 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void construct@@ Array ( int N ) { int arr [ N ] ; for ( int i = 1 ; i <= N ; i ++ ) { arr [ i - 1 ] = i ; } for ( int i = 0 ; i < N ; i ++ ) { cout << arr [ i ] << " , ▁ " ; } } int main ( ) { int N = 6 ; construct@@ Array ( N ) ; return 0 ; }
Pair of integers having difference of their fi@@ fth power as X 10563 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ Pair ( int x ) { int lim = 120 ; for ( int i = - lim ; i <= lim ; i ++ ) { for ( int j = - lim ; j <= lim ; j ++ ) { if ( pow ( i , 5 ) - pow ( j , 5 ) == x ) { cout << i << ' ▁ ' << j << endl ; return ; } } } cout << " - 1" ; } signed main ( ) { int X = 33 ; find@@ Pair ( X ) ; return 0 ; }
Check if a number is Full Fi@@ bon@@ ac@@ ci or not 10578 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Per@@ fec@@ t@@ Square ( int x ) { int s = sqrt ( x ) ; return ( s * s == x ) ; } bool is@@ Fi@@ bon@@ ac@@ ci ( int n ) { return is@@ Per@@ fec@@ t@@ Square ( 5 * n * n + 4 ) || is@@ Per@@ fec@@ t@@ Square ( 5 * n * n - 4 ) ; } bool check@@ Digits ( int n ) { while ( n ) { int dig = n % 10 ; if ( dig == 4 && dig == 6 && dig == 7 && dig == 9 ) return false ; n /= 10 ; } return true ; } int is@@ Full@@ fi@@ bon@@ ac@@ ci ( int n ) { return ( check@@ Digits ( n ) && is@@ Fi@@ bon@@ ac@@ ci ( n ) ) ; } int main ( ) { int n = 13 ; if ( is@@ Full@@ fi@@ bon@@ ac@@ ci ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
Length of the longest altern@@ ating even odd sub@@ array 10601 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int lon@@ gest@@ Even@@ O@@ dd@@ Sub@@ array ( int a [ ] , int n ) { int longest = 1 ; int cnt = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ( a [ i ] + a [ i + 1 ] ) % 2 == 1 ) { cnt ++ ; } else { longest = max ( longest , cnt ) ; cnt = 1 ; } } if ( longest == 1 ) return 0 ; return max ( cnt , longest ) ; } int main ( ) { int a [ ] = { 1 , 2 , 3 , 4 , 5 , 7 , 8 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << lon@@ gest@@ Even@@ O@@ dd@@ Sub@@ array ( a , n ) ; return 0 ; }
S@@ malle@@ st number to make Array sum at most K by divid@@ ing each element 10669 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Min@@ Di@@ visor ( int arr [ ] , int n , int limit ) { int low = 0 , high = 1e@@ 9 ; while ( low < high ) { int mid = ( low + high ) / 2 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += ceil ( ( double ) arr [ i ] / ( double ) mid ) ; } if ( sum <= limit ) high = mid ; else low = mid + 1 ; } return low ; } int main ( ) { int arr [ ] = { 2 , 3 , 4 , 9 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 6 ; cout << find@@ Min@@ Di@@ visor ( arr , N , K ) ; }
Find the maximum sum pair in an Array with even parity 10679 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; const int sz = 1e@@ 3 ; bool is@@ Even@@ Par@@ ity ( int x ) { int parity = 0 ; while ( x != 0 ) { if ( x & 1 ) parity ++ ; x = x >> 1 ; } if ( parity % 2 == 0 ) return true ; else return false ; } void print@@ Array ( int arr [ ] , int len ) { for ( int i = 0 ; i < len ; i ++ ) { cout << arr [ i ] << ' ▁ ' ; } } void find@@ Pair@@ Even@@ Par@@ ity ( int arr [ ] , int len ) { int first@@ Maximum = INT_@@ MIN ; int second@@ Maximum = INT_@@ MIN ; for ( int i = 0 ; i < len ; i ++ ) { if ( is@@ Even@@ Par@@ ity ( arr [ i ] ) ) { if ( arr [ i ] >= first@@ Maximum ) { second@@ Maximum = first@@ Maximum ; first@@ Maximum = arr [ i ] ; } else if ( arr [ i ] >= second@@ Maximum ) { second@@ Maximum = arr [ i ] ; } } } cout << first@@ Maximum << " ▁ " << second@@ Maximum ; } int main ( ) { int arr [ ] = { 18 , 15 , 8 , 9 , 14 } ; int len = sizeof ( arr ) / sizeof ( int ) ; find@@ Pair@@ Even@@ Par@@ ity ( arr , len ) ; return 0 ; }
Program to check if N is a Hexag@@ onal Number or not 10680 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Hexag@@ onal ( int N ) { float val = 8 * N + 1 ; float x = 1 + sqrt ( val ) ; float n = ( x ) / 4 ; if ( ( n - ( int ) n ) == 0 ) return true ; else return false ; } int main ( ) { int N = 14 ; if ( is@@ Hexag@@ onal ( N ) == true ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
Count all sub@@ arrays whose sum can be split as difference of squares of two Inte@@ gers 10685 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int Solve ( int arr [ ] , int n ) { int temp = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { temp = 0 ; for ( int j = i ; j < n ; j ++ ) { temp += arr [ j ] ; if ( ( temp + 2 ) % 4 != 0 ) count ++ ; } } return count ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; int N = sizeof ( arr ) / sizeof ( int ) ; cout << Solve ( arr , N ) ; return 0 ; }
Check whether a number can be represented by the product of two squares 10688 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool prod@@ Square ( int n ) { for ( long i = 2 ; i * i <= n ; i ++ ) for ( long j = 2 ; j <= n ; j ++ ) if ( i * i * j * j == n ) return true ; return false ; } int main ( ) { int n = 25 ; if ( prod@@ Square ( n ) ) cout << " Yes " ; else cout << " No " ; }
Find N distinct integers with zero sum 10701 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ Numbers ( int N ) { for ( int i = 1 ; i <= N / 2 ; i ++ ) { cout << i << " , ▁ " << - i << " , ▁ " ; } if ( N % 2 == 1 ) cout << 0 ; } int main ( ) { int N = 10 ; find@@ Numbers ( N ) ; }
Count the numbers which can convert N to 1 using given operation 10707 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Values ( int N ) { vector < int > div ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { div . push_back ( i ) ; if ( N != i * i ) { div . push_back ( N / i ) ; } } } int answer = 0 ; for ( int i = 1 ; i * i <= N - 1 ; i ++ ) { if ( ( N - 1 ) % i == 0 ) { if ( i * i == N - 1 ) answer ++ ; else answer += 2 ; } } for ( auto d : div ) { int K = N ; while ( K % d == 0 ) K /= d ; if ( ( K - 1 ) % d == 0 ) answer ++ ; } return answer ; } int main ( ) { int N = 6 ; cout << count@@ Values ( N ) ; return 0 ; }
Divide array in two maximum equal length arrays of similar and dis@@ similar elements 10753 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void Solve ( int arr [ ] , int size , int n ) { vector < int > v ( n + 1 ) ; for ( int i = 0 ; i < size ; i ++ ) v [ arr [ i ] ] ++ ; int max@@ 1 = ( max_@@ element ( v . begin ( ) , v . end ( ) ) - v . begin ( ) ) ; int diff@@ 1 = n + 1 - count ( v . begin ( ) , v . end ( ) , 0 ) ; int max_size = max ( min ( v [ max@@ 1 ] - 1 , diff@@ 1 ) , min ( v [ max@@ 1 ] , diff@@ 1 - 1 ) ) ; cout << " Maximum ▁ size ▁ is ▁ : " << max_size << " STRNEWLINE " ; cout << " The ▁ First ▁ Array ▁ Is ▁ : ▁ STRNEWLINE " ; for ( int i = 0 ; i < max_size ; i ++ ) { cout << max@@ 1 << " ▁ " ; v [ max@@ 1 ] -= 1 ; } cout << " STRNEWLINE " ; cout << " The ▁ Second ▁ Array ▁ Is ▁ : ▁ STRNEWLINE " ; for ( int i = 0 ; i < ( n + 1 ) ; i ++ ) { if ( v [ i ] > 0 ) { cout << i << " ▁ " ; max_size -- ; } if ( max_size < 1 ) break ; } cout << " STRNEWLINE " ; } int main ( ) { int n = 7 ; int arr [ ] = { 1 , 2 , 1 , 5 , 1 , 6 , 7 , 2 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; Solve ( arr , size , n ) ; return 0 ; }
Unique element in an array where all elements occur K times except one | Set 2 10755 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ unique ( vector < int > & a , int k ) { int res = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { int p = 0 ; for ( int j = 0 ; j < a . size ( ) ; j ++ ) { p += ( abs ( a [ j ] ) & ( 1 << i ) ) != 0 ? 1 : 0 ; } p %= k ; res += pow ( 2 , i ) * p ; } int c = 0 ; for ( auto x : a ) if ( x == res ) { c = 1 ; break ; } return c == 1 ? res : - res ; } int main ( ) { vector < int > a = { 12 , 12 , 2 , 2 , 3 } ; int k = 2 ; cout << find@@ unique ( a , k ) << " STRNEWLINE " ; }
Minimum volume of con@@ e that can be circum@@ scri@@ bed about a sphere of radius R 10771 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; float Volum@@ e_@@ of_@@ con@@ e ( float R ) { float V = ( 1 / 3.0 ) * ( 3.14 ) * ( 2 * ( R * R ) ) * ( 4 * R ) ; return V ; } int main ( ) { float R = 10.0 ; cout << Volum@@ e_@@ of_@@ con@@ e ( R ) ; }
Program to find Surface Area and Volume of Oct@@ ag@@ onal Pri@@ sm 10776 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; void find_@@ volume ( float area , float h ) { float Volume = ( area * h ) ; cout << " Volume : ▁ " << Volume << endl ; } void find_@@ Sur@@ face_@@ area ( float area , float a , float h ) { float Sur@@ face_@@ area = ( 2 * area ) + ( 8 * a * h ) ; cout << " Surface ▁ area : ▁ " << Sur@@ face_@@ area << endl ; } int main ( ) { float h = 1 ; float a = 6 ; float d = 2 ; float area = 2 * a * d ; find_@@ Sur@@ face_@@ area ( area , a , h ) ; find_@@ volume ( area , h ) ; return 0 ; }
Elements of Array which can be expressed as power of some integer to given exponent K 10784 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define ll long long NEW_LINE double n@@ th@@ Root ( ll A , ll N ) { double x@@ Pre = 7 ; double eps = 1e-3 ; double del@@ X = INT_MAX ; double x@@ K ; while ( del@@ X > eps ) { x@@ K = ( ( N - 1.0 ) * x@@ Pre + ( double ) A / pow ( x@@ Pre , N - 1 ) ) / ( double ) N ; del@@ X = abs ( x@@ K - x@@ Pre ) ; x@@ Pre = x@@ K ; } return x@@ K ; } bool check ( ll no , int k ) { double k@@ th_@@ root = n@@ th@@ Root ( no , k ) ; ll num = k@@ th_@@ root ; if ( abs ( num - k@@ th_@@ root ) < 1e-4 ) return true ; return false ; } void print@@ Exp@@ o ( ll arr [ ] , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { if ( check ( arr [ i ] , k ) ) cout << arr [ i ] << " ▁ " ; } } int main ( ) { int K = 6 ; ll arr [ ] = { 46@@ 65@@ 6 , 64 , 256 , 7@@ 29 , 16 , 1000 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; print@@ Exp@@ o ( arr , n , K ) ; return 0 ; }
Count of sub@@ sequences whose product is a difference of square of two integers 10786 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int Cnt@@ cont@@ Sub@@ s ( int a [ ] , int n ) { int c = 0 , d = 0 , i , sum = 1 , j ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 != 0 a [ i ] % 4 == 0 ) d ++ ; sum = a [ i ] ; for ( j = i + 1 ; j < n ; j ++ ) { sum = sum * a [ j ] ; if ( sum % 2 != 0 sum % 4 == 0 ) c ++ ; } sum = 1 ; } return c + d ; } int main ( ) { int arr [ ] = { 5 , 4 , 2 , 9 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << Cnt@@ cont@@ Sub@@ s ( arr , n ) ; return 0 ; }
Sum of all Perf@@ ect numbers ly@@ ing in the range [ L , R ] 10793 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE #@@ define ll int NEW_LINE using namespace std ; long long pref [ 100@@ 010 ] ; int is@@ Perf@@ ect ( int n ) { int sum = 1 ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i * i != n ) sum = sum + i + n / i ; else sum = sum + i ; } } if ( sum == n && n != 1 ) return n ; return 0 ; } void pre@@ computation ( ) { for ( int i = 1 ; i <= 100000 ; ++ i ) { pref [ i ] = pref [ i - 1 ] + is@@ Perf@@ ect ( i ) ; } } int main ( ) { int L = 6 , R = 28 ; pre@@ computation ( ) ; cout << pref [ R ] - pref [ L - 1 ] ; return 0 ; }
Count of numbers upto M with GC@@ D equals to K when paired with M 10797 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int Euler@@ To@@ ti@@ ent@@ Function ( int limit ) { int copy = limit ; vector < int > primes ; for ( int i = 2 ; i * i <= limit ; i ++ ) { if ( limit % i == 0 ) { while ( limit % i == 0 ) { limit /= i ; } primes . push_back ( i ) ; } } if ( limit >= 2 ) { primes . push_back ( limit ) ; } int ans = copy ; for ( auto it : primes ) { ans = ( ans / it ) * ( it - 1 ) ; } return ans ; } void Count@@ GC@@ D ( int m , int k ) { if ( m % k != 0 ) { cout << 0 << endl ; return ; } if ( m == k ) { cout << 2 << endl ; return ; } int limit = m / k ; int ans = Euler@@ To@@ ti@@ ent@@ Function ( limit ) ; cout << ans << endl ; } int main ( ) { int M = 9 ; int K = 1 ; Count@@ GC@@ D ( M , K ) ; return 0 ; }
Sum of numbers in the K@@ th level of a Fi@@ bon@@ ac@@ ci triangle 10800 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define MAX 1000000 NEW_LINE int fi@@ b ( int n ) { double phi = ( 1 + sqrt ( 5 ) ) / 2 ; return round ( pow ( phi , n ) / sqrt ( 5 ) ) ; } int calculate@@ Sum ( int l , int r ) { int sum = fi@@ b ( r + 2 ) - fi@@ b ( l + 1 ) ; return sum ; } int sum@@ Fi@@ bon@@ ac@@ ci ( int k ) { int l = ( k * ( k - 1 ) ) / 2 ; int r = l + k ; int sum = calculate@@ Sum ( l , r - 1 ) ; return sum ; } int main ( ) { int k = 3 ; cout << sum@@ Fi@@ bon@@ ac@@ ci ( k ) ; return 0 ; }
Print the sequence of size N in which every term is sum of previous K terms 10802 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; void sum@@ Of@@ Prev@@ K ( int N , int K ) { int arr [ N ] ; arr [ 0 ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) { int j = i - 1 , count = 0 , sum = 0 ; while ( j >= 0 && count < K ) { sum += arr [ j ] ; j -- ; count ++ ; } arr [ i ] = sum ; } for ( int i = 0 ; i < N ; i ++ ) { cout << arr [ i ] << " ▁ " ; } } int main ( ) { int N = 10 , K = 4 ; sum@@ Of@@ Prev@@ K ( N , K ) ; return 0 ; }
Find the real and imaginary part of a Complex number 10810 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ Real@@ And@@ Ima@@ g ( string s ) { int l = s . length ( ) ; int i ; if ( s . find ( ' + ' ) < l ) { i = s . find ( ' + ' ) ; } else { i = s . find ( ' - ' ) ; } string real = s . substr ( 0 , i ) ; string imaginary = s . substr ( i + 1 , l - i - 2 ) ; cout << " Real ▁ part : ▁ " << real << " STRNEWLINE " ; cout << " Ima@@ gin@@ ary ▁ part : ▁ " << imaginary << " STRNEWLINE " ; } int main ( ) { string s = "3 + 4i " ; find@@ Real@@ And@@ Ima@@ g ( s ) ; return 0 ; }
Count pairs in array such that one element is reverse of another 10823 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int reverse ( int num ) { int rev_@@ num = 0 ; while ( num > 0 ) { rev_@@ num = rev_@@ num * 10 + num % 10 ; num = num / 10 ; } return rev_@@ num ; } int count@@ Reverse ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( reverse ( arr [ i ] ) == arr [ j ] ) { res ++ ; } return res ; } int main ( ) { int a [ ] = { 16 , 61 , 12 , 21 , 25 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << count@@ Reverse ( a , n ) ; return 0 ; }
Find the Sum of the series 1 / 2 10836 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ Series@@ Sum ( int N ) { double sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i & 1 ) { sum += ( double ) i / ( i + 1 ) ; } else { sum -= ( double ) i / ( i + 1 ) ; } } cout << sum << endl ; } int main ( ) { int N = 10 ; print@@ Series@@ Sum ( N ) ; return 0 ; }
Program to add two integers of given base 10840 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; string sum@@ Base@@ B ( string a , string b , int base ) { int len@@ _a , len_@@ b ; len@@ _a = a . size ( ) ; len_@@ b = b . size ( ) ; string sum , s ; s = " " ; sum = " " ; int diff ; diff = abs ( len@@ _a - len_@@ b ) ; for ( int i = 1 ; i <= diff ; i ++ ) s += "0" ; if ( len@@ _a < len_@@ b ) a = s + a ; else b = s + b ; int curr , carry = 0 ; for ( int i = max ( len@@ _a , len_@@ b ) - 1 ; i > -1 ; i -- ) { curr = carry + ( a [ i ] - '0' ) + ( b [ i ] - '0' ) ; carry = curr / base ; curr = curr % base ; sum = ( char ) ( curr + '0' ) + sum ; } if ( carry > 0 ) sum = ( char ) ( carry + '0' ) + sum ; return sum ; } int main ( ) { string a , b , sum ; int base ; a = "123" ; b = "@@ 234@@ " ; base = 6 ; sum = sum@@ Base@@ B ( a , b , base ) ; cout << sum << endl ; return 0 ; }
Count of Fi@@ bon@@ ac@@ ci di@@ visors of a given number 10858 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void create@@ Hash ( set < int > & hash , int max@@ Element ) { int prev = 0 , curr = 1 ; hash . insert ( prev ) ; hash . insert ( curr ) ; while ( curr <= max@@ Element ) { int temp = curr + prev ; hash . insert ( temp ) ; prev = curr ; curr = temp ; } } int count@@ Fi@@ bon@@ ac@@ ci@@ Di@@ visors ( int n ) { set < int > hash ; create@@ Hash ( hash , n ) ; int cnt = 0 ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( ( n / i == i ) && ( hash . find ( n / i ) != hash . end ( ) ) ) cnt ++ ; else { if ( hash . find ( n / i ) != hash . end ( ) ) cnt ++ ; if ( hash . find ( n / ( n / i ) ) != hash . end ( ) ) cnt ++ ; } } } return cnt ; } int main ( ) { int n = 12 ; cout << count@@ Fi@@ bon@@ ac@@ ci@@ Di@@ visors ( n ) ; return 0 ; }
Check if number formed by joining two Numbers is Perf@@ ect Cube 10874 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Per@@ fec@@ t@@ Cube ( int x ) { long double cr = round ( c@@ br@@ t ( x ) ) ; return ( cr * cr * cr == x ) ; } void check@@ Cube ( int a , int b ) { string s1 = to_string ( a ) ; string s2 = to_string ( b ) ; int c = sto@@ i ( s1 + s2 ) ; if ( is@@ Per@@ fec@@ t@@ Cube ( c ) ) { cout << " Yes " ; } else { cout << " No " ; } } int main ( ) { int a = 6 ; int b = 4 ; check@@ Cube ( a , b ) ; return 0 ; }
Find the next Non 10879 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Per@@ fec@@ t@@ Square ( int x ) { int s = sqrt ( x ) ; return ( s * s == x ) ; } bool is@@ Fi@@ bon@@ ac@@ ci ( int N ) { return is@@ Per@@ fec@@ t@@ Square ( 5 * N * N + 4 ) || is@@ Per@@ fec@@ t@@ Square ( 5 * N * N - 4 ) ; } int next@@ Non@@ Fi@@ bon@@ ac@@ ci ( int N ) { if ( N <= 3 ) return 4 ; if ( is@@ Fi@@ bon@@ ac@@ ci ( N + 1 ) ) return N + 2 ; else return N + 1 ; } int main ( ) { int N = 3 ; cout << next@@ Non@@ Fi@@ bon@@ ac@@ ci ( N ) << endl ; N = 5 ; cout << next@@ Non@@ Fi@@ bon@@ ac@@ ci ( N ) << endl ; N = 7 ; cout << next@@ Non@@ Fi@@ bon@@ ac@@ ci ( N ) << endl ; }
Count of prime digits of a Number which divi@@ des the number 10882 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Digit ( int n ) { bool prime [ 10 ] ; memset ( prime , false , sizeof ( prime ) ) ; prime [ 2 ] = prime [ 3 ] = true ; prime [ 5 ] = prime [ 7 ] = true ; int temp = n , count = 0 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 && prime [ d ] ) count ++ ; } return count ; } int main ( ) { int n = 10@@ 32 ; cout << count@@ Digit ( n ) << endl ; return 0 ; }
Print a pair of numbers with the given Sum and Product 10887 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ Roots ( int b , int c ) { int a = 1 ; int d = b * b - 4 * a * c ; double sq@@ rt_@@ val = sqrt ( abs ( d ) ) ; if ( d > 0 ) { double x = - b + sq@@ rt_@@ val ; double y = - b - sq@@ rt_@@ val ; int roo@@ t1 = ( x ) / ( 2 * a ) ; int root@@ 2 = ( y ) / ( 2 * a ) ; if ( roo@@ t1 + root@@ 2 == -1 * b && roo@@ t1 * root@@ 2 == c ) cout << roo@@ t1 << " , ▁ " << root@@ 2 ; else cout << -1 ; } else if ( d == 0 ) { int root = - b / ( 2 * a ) ; if ( root + root == -1 * b && root * root == c ) cout << root << " , ▁ " << root ; else cout << -1 ; } else { cout << -1 ; } cout << endl ; } int main ( ) { int S = 5 , P = 6 ; find@@ Roots ( - S , P ) ; S = 5 , P = 9 ; find@@ Roots ( - S , P ) ; return 0 ; }
Print N numbers such that their product is a Perf@@ ect Cube 10888 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ Numbers ( int N ) { int i = 1 ; while ( i <= N ) { cout << ( i * i * i ) << " ▁ " ; i ++ ; } } int main ( ) { int N = 4 ; find@@ Numbers ( N ) ; }
Check if N can be expressed as product of 3 distinct numbers 10898 | #@@ include " bits / std@@ c + + . h " NEW_LINE using namespace std ; void get@@ numbers ( int n ) { vector < int > divisor ; for ( int i = 2 ; i * i <= n ; i ++ ) { while ( n % i == 0 ) { divisor . push_back ( i ) ; n /= i ; } } if ( n != 1 ) { divisor . push_back ( n ) ; } int a , b , c , size ; a = b = c = 1 ; size = divisor . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { if ( a == 1 ) { a = a * divisor [ i ] ; } else if ( b == 1 b == a ) { b = b * divisor [ i ] ; } else { c = c * divisor [ i ] ; } } if ( a == 1 b == 1 c == 1 a == b b == c a == c ) { cout << " - 1" << endl ; } else { cout << a << ' ▁ ' << b << ' ▁ ' << c << endl ; } } int main ( ) { int n = 64 ; get@@ numbers ( n ) ; }
Check if all Prime factors of number N are unique or not 10899 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; vector < int > prime@@ Factors ( int n ) { int i , j ; vector < int > Prime ; if ( n % 2 == 0 ) { Prime . push_back ( 2 ) ; } while ( n % 2 == 0 ) { n = n / 2 ; } for ( i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { Prime . push_back ( i ) ; } while ( n % i == 0 ) { n = n / i ; } } if ( n > 2 ) { Prime . push_back ( n ) ; } return Prime ; } void check@@ Distinct@@ Prime ( int n ) { vector < int > Prime = prime@@ Factors ( n ) ; int product = 1 ; for ( auto i : Prime ) { product *= i ; } if ( product == n ) cout << " YES " ; else cout << " NO " ; } int main ( ) { int N = 30 ; check@@ Distinct@@ Prime ( N ) ; return 0 ; }
Calculate sum of all integers from 1 to N , excluding perfect power of 2 10927 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ Sum ( int N ) { int sum = ( N ) * ( N + 1 ) / 2 ; int r = log2 ( N ) + 1 ; int exp@@ Sum = pow ( 2 , r ) - 1 ; cout << sum - exp@@ Sum << endl ; } int main ( ) { int N = 2 ; find@@ Sum ( N ) ; return 0 ; }
Area of plot remaining at the end 9194 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int remaining@@ Area ( int N , int M , int K ) { while ( K -- && N && M ) { if ( N > M ) N = N - M ; else M = M - N ; } if ( N > 0 && M > 0 ) return N * M ; else return 0 ; } int main ( ) { int N = 5 , M = 3 , K = 2 ; cout << remaining@@ Area ( N , M , K ) ; return 0 ; }
Check if it is possible to create a polygon with given n sides 9208 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Possible ( int a [ ] , int n ) { int sum = 0 , max@@ S = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; max@@ S = max ( a [ i ] , max@@ S ) ; } if ( ( sum - max@@ S ) > max@@ S ) return true ; return false ; } int main ( ) { int a [ ] = { 2 , 3 , 4 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; if ( is@@ Possible ( a , n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
Find the coordinates of the fourth vertex of a rectangle with given 3 vertices 9220 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; pair < int , int > find@@ Four@@ th@@ Vertex ( int n , int m , string s [ ] ) { map < int , int > row , col ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( s [ i ] [ j ] == ' * ' ) { row [ i ] ++ ; col [ j ] ++ ; } int x , y ; for ( auto tm : row ) if ( tm . second == 1 ) x = tm . first ; for ( auto tm : col ) if ( tm . second == 1 ) y = tm . first ; return make_pair ( x + 1 , y + 1 ) ; } int main ( ) { string s [ ] = { " * . * " , " * . . " , " . . . " } ; int n = sizeof ( s ) / sizeof ( s [ 0 ] ) ; int m = s [ 0 ] . length ( ) ; auto rs = find@@ Four@@ th@@ Vertex ( n , m , s ) ; cout << rs . first << " ▁ " << rs . second ; }
Lar@@ gest right circular con@@ e that can be in@@ scri@@ bed within a sphere which is in@@ scri@@ bed within a cube 9224 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; float con@@ e ( float a ) { if ( a < 0 ) return -1 ; float r = ( a * sqrt ( 2 ) ) / 3 ; float h = ( 2 * a ) / 3 ; float V = 3.14 * pow ( r , 2 ) * h ; return V ; } int main ( ) { float a = 5 ; cout << con@@ e ( a ) << endl ; return 0 ; }
Lar@@ gest Square that can be in@@ scri@@ bed within a hex@@ ag@@ on 9251 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; float square@@ Area ( float a ) { if ( a < 0 ) return -1 ; float area = pow ( 1.@@ 268 , 2 ) * pow ( a , 2 ) ; return area ; } int main ( ) { float a = 6 ; cout << square@@ Area ( a ) << endl ; return 0 ; }
Length of ro@@ pe tied around three equal circ@@ les touch@@ ing each other 9260 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define PI 3.14@@ 159@@ 265 NEW_LINE float length_@@ ro@@ pe ( float r ) { return ( ( 2 * PI * r ) + 6 * r ) ; } int main ( ) { float r = 7 ; cout << ceil ( length_@@ ro@@ pe ( r ) ) << endl ; return 0 ; }
Volume of big@@ gest sphere within a right circular cylinder 9266 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; float sp@@ h ( float r , float h ) { if ( r < 0 && h < 0 ) return -1 ; float R = r ; return R ; } int main ( ) { float r = 4 , h = 8 ; cout << sp@@ h ( r , h ) << endl ; return 0 ; }
Minimum Cu@@ ts can be made in the Ch@@ ess@@ board such that it is not divided into 2 parts 9276 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int numberOf@@ Cu@@ ts ( int M , int N ) { int result = 0 ; result = ( M - 1 ) * ( N - 1 ) ; return result ; } int main ( ) { int M = 4 , N = 4 ; int Cu@@ ts = numberOf@@ Cu@@ ts ( M , N ) ; cout << " Maximum ▁ cuts ▁ = ▁ " << Cu@@ ts ; return 0 ; }
Equation of par@@ ab@@ ola from its focus and direc@@ tri@@ x 9285 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE #@@ include <@@ io@@ manip@@ > NEW_LINE #@@ include <@@ io@@ stream@@ > NEW_LINE #@@ include <@@ math@@ .@@ h@@ > NEW_LINE using namespace std ; void equ@@ ation_@@ par@@ ab@@ ola ( float x1 , float y1 , float a , float b , float c ) { float t = a * a + b * b ; float a1 = t - ( a * a ) ; float b1 = t - ( b * b ) ; float c1 = ( -2 * t * x1 ) - ( 2 * c * a ) ; float d1 = ( -2 * t * y1 ) - ( 2 * c * b ) ; float e1 = -2 * a * b ; float f1 = ( - c * c ) + ( t * x1 * x1 ) + ( t * y1 * y1 ) ; std :: cout << std :: fixed ; std :: cout << std :: setprecision ( 1 ) ; cout << " equation ▁ of ▁ par@@ ab@@ ola ▁ is ▁ " << a1 << " ▁ x ^ 2 ▁ + ▁ " << b1 << " ▁ y ^ 2 ▁ + ▁ " << c1 << " ▁ x ▁ + ▁ " << d1 << " ▁ y ▁ + ▁ " << e1 << " ▁ xy ▁ + ▁ " << f1 << " ▁ = ▁ 0 . " ; } int main ( ) { float x1 = 0 ; float y1 = 0 ; float a = 3 ; float b = -@@ 4 ; float c = 2 ; equ@@ ation_@@ par@@ ab@@ ola ( x1 , y1 , a , b , c ) ; return 0 ; }
Program to find the Area and Per@@ imeter of a Se@@ mic@@ ir@@ cle 9291 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; float area ( float r ) { return ( 0.5 ) * ( 3.14 ) * ( r * r ) ; } float per@@ imeter ( float r ) { return ( 3.14 ) * ( r ) ; } int main ( ) { int r = 10 ; cout << " The ▁ Area ▁ of ▁ Se@@ mic@@ ir@@ cle : ▁ " << area ( r ) << endl ; cout << " The ▁ Per@@ imeter ▁ of ▁ Se@@ mic@@ ir@@ cle : ▁ " << per@@ imeter ( r ) << endl ; return 0 ; }
Check if it is possible to move from ( 0 , 0 ) to ( x , y ) in N steps 9306 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool Arri@@ ve ( int a , int b , int n ) { if ( n >= abs ( a ) + abs ( b ) and ( n - ( abs ( a ) + abs ( b ) ) ) % 2 == 0 ) return true ; return false ; } int main ( ) { int a = 5 , b = 5 , n = 11 ; if ( Arri@@ ve ( a , b , n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
Area of largest triangle that can be in@@ scri@@ bed within a rectangle 9317 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; float triangle@@ area ( float l , float b ) { if ( l < 0 b < 0 ) return -1 ; float area = ( l * b ) / 2 ; return area ; } int main ( ) { float l = 5 , b = 4 ; cout << triangle@@ area ( l , b ) << endl ; return 0 ; }
Area of a largest square fit in a right angle triangle 9335 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; float square@@ Area ( float l , float b , float h ) { if ( l < 0 b < 0 h < 0 ) return -1 ; float a = ( l * b ) / ( l + b ) ; return a * a ; } int main ( ) { float l = 5 , b = 12 , h = 13 ; cout << square@@ Area ( l , b , h ) << endl ; return 0 ; }
Inter@@ sec@@ ting rectangle when bottom 9357 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void Find@@ Points ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x4 , int y@@ 4 ) { int x5 = max ( x1 , x3 ) ; int y@@ 5 = max ( y1 , y3 ) ; int x@@ 6 = min ( x2 , x4 ) ; int y@@ 6 = min ( y2 , y@@ 4 ) ; if ( x5 > x@@ 6 y@@ 5 > y@@ 6 ) { cout << " No ▁ intersection " ; return ; } cout << " ( " << x5 << " , ▁ " << y@@ 5 << " ) ▁ " ; cout << " ( " << x@@ 6 << " , ▁ " << y@@ 6 << " ) ▁ " ; int x@@ 7 = x5 ; int y@@ 7 = y@@ 6 ; cout << " ( " << x@@ 7 << " , ▁ " << y@@ 7 << " ) ▁ " ; int x@@ 8 = x@@ 6 ; int y@@ 8 = y@@ 5 ; cout << " ( " << x@@ 8 << " , ▁ " << y@@ 8 << " ) ▁ " ; } int main ( ) { int x1 = 0 , y1 = 0 , x2 = 10 , y2 = 8 ; int x3 = 2 , y3 = 3 , x4 = 7 , y@@ 4 = 9 ; Find@@ Points ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y@@ 4 ) ; return 0 ; }
Program to find equation of a plane passing through 3 points 9364 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE #@@ include <@@ math@@ .@@ h@@ > NEW_LINE #@@ include <@@ io@@ stream@@ > NEW_LINE #@@ include <@@ io@@ manip@@ > NEW_LINE using namespace std ; void equ@@ ation_@@ plane ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 , float x3 , float y3 , float z3 ) { float a1 = x2 - x1 ; float b1 = y2 - y1 ; float c1 = z2 - z1 ; float a2 = x3 - x1 ; float b2 = y3 - y1 ; float c2 = z3 - z1 ; float a = b1 * c2 - b2 * c1 ; float b = a2 * c1 - a1 * c2 ; float c = a1 * b2 - b1 * a2 ; float d = ( - a * x1 - b * y1 - c * z1 ) ; std :: cout << std :: fixed ; std :: cout << std :: setprecision ( 2 ) ; cout << " equation ▁ of ▁ plane ▁ is ▁ " << a << " ▁ x ▁ + ▁ " << b << " ▁ y ▁ + ▁ " << c << " ▁ z ▁ + ▁ " << d << " ▁ = ▁ 0 . " ; } int main ( ) { float x1 = -1 ; float y1 = 2 ; float z1 = 1 ; float x2 = 0 ; float y2 = -@@ 3 ; float z2 = 2 ; float x3 = 1 ; float y3 = 1 ; float z3 = -@@ 4 ; equ@@ ation_@@ plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) ; return 0 ; }
Program to determine the oct@@ ant of the ax@@ ial plane 9368 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE #@@ include <@@ math@@ .@@ h@@ > NEW_LINE using namespace std ; void oct@@ ant ( float x , float y , float z ) { if ( x >= 0 && y >= 0 && z >= 0 ) cout << " Point ▁ lies ▁ in ▁ 1st ▁ oct@@ ant STRNEWLINE " ; else if ( x < 0 && y >= 0 && z >= 0 ) cout << " Point ▁ lies ▁ in ▁ 2nd ▁ oct@@ ant STRNEWLINE " ; else if ( x < 0 && y < 0 && z >= 0 ) cout << " Point ▁ lies ▁ in ▁ 3rd ▁ oct@@ ant STRNEWLINE " ; else if ( x >= 0 && y < 0 && z >= 0 ) cout << " Point ▁ lies ▁ in ▁ 4@@ th ▁ oct@@ ant STRNEWLINE " ; else if ( x >= 0 && y >= 0 && z < 0 ) cout << " Point ▁ lies ▁ in ▁ 5@@ th ▁ oct@@ ant STRNEWLINE " ; else if ( x < 0 && y >= 0 && z < 0 ) cout << " Point ▁ lies ▁ in ▁ 6@@ th ▁ oct@@ ant STRNEWLINE " ; else if ( x < 0 && y < 0 && z < 0 ) cout << " Point ▁ lies ▁ in ▁ 7@@ th ▁ oct@@ ant STRNEWLINE " ; else if ( x >= 0 && y < 0 && z < 0 ) cout << " Point ▁ lies ▁ in ▁ 8@@ th ▁ oct@@ ant STRNEWLINE " ; } int main ( ) { float x = 2 , y = 3 , z = 4 ; oct@@ ant ( x , y , z ) ; x = -@@ 4 , y = 2 , z = -@@ 8 ; oct@@ ant ( x , y , z ) ; x = -@@ 6 , y = -2 , z = 8 ; oct@@ ant ( x , y , z ) ; return 0 ; }
Pent@@ ag@@ onal Pyram@@ id@@ al Number 9380 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int pent@@ ag@@ on_@@ pyram@@ id@@ al ( int n ) { return n * n * ( n + 1 ) / 2 ; } int main ( ) { int n = 4 ; cout << pent@@ ag@@ on_@@ pyram@@ id@@ al ( n ) << endl ; return 0 ; }
Find the other end point of a line with given one end and mid 9407 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; void other@@ EndPoint ( int x1 , int y1 , int m1 , int m2 ) { float x2 = ( float ) ( 2 * m1 - x1 ) ; float y2 = ( float ) ( 2 * m2 - y1 ) ; cout << " x2 ▁ = ▁ " << x2 << " , ▁ " << " y2 ▁ = ▁ " << y2 ; } int main ( ) { int x1 = -@@ 4 , y1 = -1 , m1 = 3 , m2 = 5 ; other@@ EndPoint ( x1 , y1 , m1 , m2 ) ; return 0 ; }
Count of acute , ob@@ t@@ use and right triangles with given sides 9510 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ Triangle ( int a [ ] , int n ) { int b [ n + 2 ] ; for ( int i = 0 ; i < n ; i ++ ) b [ i ] = a [ i ] * a [ i ] ; sort ( a , a + n ) ; sort ( b , b + n ) ; int x = 0 , y = 0 , z = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int p = i + 1 ; int q = i + 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { while ( p < n - 1 && b [ i ] + b [ j ] >= b [ p + 1 ] ) p ++ ; q = max ( q , p ) ; while ( q < n - 1 && a [ i ] + a [ j ] > a [ q + 1 ] ) q ++ ; if ( b [ i ] + b [ j ] == b [ p ] ) { x += max ( p - j - 1 , 0 ) ; y ++ ; z += q - p ; } else { x += max ( p - j , 0 ) ; z += q - p ; } } } cout << " Ac@@ u@@ te ▁ Triangle : ▁ " << x << endl ; cout << " Right ▁ Triangle : ▁ " << y << endl ; cout << " Ob@@ t@@ use ▁ Triangle : ▁ " << z << endl ; } int main ( ) { int arr [ ] = { 2 , 3 , 9 , 10 , 12 , 15 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; find@@ Triangle ( arr , n ) ; return 0 ; }
Area of a polygon with given n ordered vertices 9521 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; double polygon@@ Area ( double X [ ] , double Y [ ] , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; } return abs ( area / 2.0 ) ; } int main ( ) { double X [ ] = { 0 , 2 , 4 } ; double Y [ ] = { 1 , 3 , 7 } ; int n = sizeof ( X ) / sizeof ( X [ 0 ] ) ; cout << polygon@@ Area ( X , Y , n ) ; }
Program to find area of a triangle 9528 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; double polygon@@ Area ( double X [ ] , double Y [ ] , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; } return abs ( area / 2.0 ) ; } int main ( ) { double X [ ] = { 0 , 2 , 4 } ; double Y [ ] = { 1 , 3 , 7 } ; int n = sizeof ( X ) / sizeof ( X [ 0 ] ) ; cout << polygon@@ Area ( X , Y , n ) ; }
Lar@@ gest integer upto N having gre@@ atest prime factor greater than its square root 9543 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; const int max@@ n = 10000@@ 1 ; int gp@@ f [ max@@ n ] ; void modified@@ Si@@ eve ( ) { memset ( gp@@ f , 0 , sizeof ( gp@@ f ) ) ; gp@@ f [ 0 ] = 0 ; gp@@ f [ 1 ] = 1 ; for ( int i = 2 ; i < max@@ n ; i ++ ) { if ( gp@@ f [ i ] > 0 ) continue ; for ( int j = i ; j < max@@ n ; j += i ) { gp@@ f [ j ] = max ( i , gp@@ f [ j ] ) ; } } } int gre@@ atest@@ Valid@@ Int ( int N ) { modified@@ Si@@ eve ( ) ; for ( int i = N ; i > 0 ; i -- ) { if ( gp@@ f [ i ] > sqrt ( i ) ) { return i ; } } return -1 ; } int main ( ) { int N = 25 ; cout << gre@@ atest@@ Valid@@ Int ( N ) ; return 0 ; }
Find sub@@ factorial of a number 9547 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; double sub@@ factorial ( int N ) { double res = 0 , fact = 1 ; int count = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { fact = fact * i ; if ( count % 2 == 0 ) res = res - ( 1 / fact ) ; else res = res + ( 1 / fact ) ; count ++ ; } return fact * ( 1 + res ) ; } int main ( ) { int N = 4 ; cout << sub@@ factorial ( N ) ; return 0 ; }
Count of pair of integers ( x , y ) such that difference between square of x and y is a perfect square 9549 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Pairs ( int N ) { int res = 0 ; for ( int q = 1 ; q * q <= N ; q ++ ) { int max@@ P = min ( 2 * N - q , N / q ) ; if ( max@@ P < q ) continue ; int cnt = max@@ P - q + 1 ; res += ( cnt / 2 + ( cnt & 1 ) ) ; } return res ; } int main ( ) { int N = 3 ; cout << count@@ Pairs ( N ) ; return 0 ; }
Find the last positive element remaining after repeated subtr@@ actions of smallest positive element from all Array elements 9573 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int last@@ Positive@@ Element ( vector < int > arr ) { int N = arr . size ( ) ; if ( N == 1 ) return arr [ 0 ] ; int gre@@ atest = -1 , second@@ Gre@@ atest = -1 ; for ( int x : arr ) { if ( x >= gre@@ atest ) { second@@ Gre@@ atest = gre@@ atest ; gre@@ atest = x ; } else if ( x >= second@@ Gre@@ atest ) { second@@ Gre@@ atest = x ; } } return gre@@ atest - second@@ Gre@@ atest ; } int main ( ) { vector < int > arr = { 3 , 5 , 4 , 7 } ; cout << last@@ Positive@@ Element ( arr ) ; return 0 ; }
Sum of all subsets of a given size ( = K ) 9609 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ Sum@@ Of@@ All@@ Sub@@ sets ( int arr [ ] , int n , int k ) { int factor@@ i@@ al_@@ N = 1 , factor@@ i@@ al_@@ d = 1 , factor@@ i@@ al_@@ D = 1 ; for ( int i = 1 ; i <= n - 1 ; i ++ ) factor@@ i@@ al_@@ N *= i ; for ( int i = 1 ; i <= k - 1 ; i ++ ) factor@@ i@@ al_@@ d *= i ; for ( int i = 1 ; i <= n - k ; i ++ ) factor@@ i@@ al_@@ D *= i ; int freq = factor@@ i@@ al_@@ N / ( factor@@ i@@ al_@@ d * factor@@ i@@ al_@@ D ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; sum = sum * freq ; cout << " Sum ▁ of ▁ all ▁ subsets ▁ of ▁ size ▁ = ▁ " << k << " ▁ is ▁ = > ▁ " << sum << endl ; } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 5 } ; int n = 4 , k = 2 ; find@@ Sum@@ Of@@ All@@ Sub@@ sets ( arr , n , k ) ; return 0 ; }
Maxim@@ ize XOR by selecting 3 numbers in range [ 0 , A ] , [ 0 , B ] , and [ 0 , C ] respectively 9612 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int maximum@@ Trip@@ let@@ XOR ( int A , int B , int C ) { int ans = 0 ; for ( int i = 30 ; i >= 0 ; i -- ) { int cur = 1 << i ; if ( A >= cur ) { ans += cur ; A -= cur ; } else if ( B >= cur ) { ans += cur ; B -= cur ; } else if ( C >= cur ) { ans += cur ; C -= cur ; } } return ans ; } int main ( ) { int A = 6 ; int B = 2 ; int C = 10 ; cout << maximum@@ Trip@@ let@@ XOR ( A , B , C ) ; }
Lon@@ gest remaining array of distinct elements possible after repeated removal of maximum and minimum elements of trip@@ lets 9626 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max@@ Unique@@ Elements ( int A [ ] , int N ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { mp [ A [ i ] ] ++ ; } int cnt = 0 ; for ( auto x : mp ) { if ( x . second % 2 == 0 ) { cnt ++ ; } } int ans = mp . size ( ) ; if ( cnt % 2 == 1 ) { ans -- ; } return ans ; } int main ( ) { int N = 5 ; int A [ ] = { 1 , 2 , 1 , 3 , 7 } ; cout << max@@ Unique@@ Elements ( A , N ) ; }
Count cells in a grid from which maximum number of cells can be reached by K vertical or horizontal jumps 9640 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int m = 100000000@@ 7 ; int power ( int x , int y ) { int res = 1 ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % m ; y = y >> 1 ; x = ( x * x ) % m ; } return res ; } int count@@ N@@ Digit@@ Number ( int N ) { int ne = N / 2 + N % 2 ; int no = floor ( N / 2 ) ; return power ( 4 , ne ) * power ( 5 , no ) ; } int main ( ) { int N = 5 ; cout << count@@ N@@ Digit@@ Number ( N ) % m << endl ; }
Count of pairs in range [ P , Q ] with numbers as multiple of R and their product lie in range [ P * Q / 4 , P * Q ] 9706 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ Pairs ( int p , int q , int r ) { vector < int > v ; for ( int i = p ; i <= q ; i ++ ) { if ( i % r == 0 ) { v . push_back ( i ) ; } } vector < pair < int , int > > ans ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { for ( int j = i + 1 ; j < v . size ( ) ; j ++ ) { if ( v [ i ] * v [ j ] >= p * q / 4 && v [ i ] * v [ j ] <= p * q ) { ans . push_back ( { v [ i ] , v [ j ] } ) ; } } } if ( ans . size ( ) == 0 ) { cout << -1 << endl ; } else { for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { cout << ans [ i ] . first << " ▁ " << ans [ i ] . second << endl ; } } } int main ( ) { int p = 14 , q = 30 , r = 5 ; find@@ Pairs ( p , q , r ) ; return 0 ; }
Maxim@@ ize product of sub@@ array sum with its maximum element 9718 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int K@@ ad@@ ane ( int arr [ ] , int n ) { int lar@@ gest@@ Sum = 0 , curr@@ Max = 0 ; int curr@@ Sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr@@ Sum += arr [ i ] ; curr@@ Max = max ( curr@@ Max , arr [ i ] ) ; lar@@ gest@@ Sum = max ( lar@@ gest@@ Sum , curr@@ Max * curr@@ Sum ) ; if ( curr@@ Sum < 0 ) { curr@@ Max = 0 ; curr@@ Sum = 0 ; } } return lar@@ gest@@ Sum ; } int maximum@@ Weight ( int arr [ ] , int n ) { int lar@@ gest@@ Sum = K@@ ad@@ ane ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = - arr [ i ] ; } lar@@ gest@@ Sum = max ( lar@@ gest@@ Sum , K@@ ad@@ ane ( arr , n ) ) ; return lar@@ gest@@ Sum ; } int main ( ) { int arr [ ] = { 2 , -@@ 3 , 8 , -2 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maximum@@ Weight ( arr , N ) ; return 0 ; }
Maximum number of multiplication by 3 or division by 2 operations possible on an array 9729 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int maximum@@ Tur@@ ns ( int arr [ ] , int N ) { int Count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { while ( arr [ i ] % 2 == 0 ) { Count ++ ; arr [ i ] = arr [ i ] / 2 ; } } return Count ; } int main ( ) { int arr [ ] = { 5 , 2 , 4 } ; int M = 3 , K = 2 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maximum@@ Tur@@ ns ( arr , N ) ; return 0 ; }
Dist@@ ribute the white and black objects into maximum groups under certain constraints 9731 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void is@@ Possible ( int W , int B , int D ) { if ( W > B ) swap ( W , B ) ; if ( B > W * ( D + 1 ) ) cout << " NO " << endl ; else cout << " YES " << endl ; } int main ( ) { int W = 2 ; int B = 5 ; int D = 2 ; is@@ Possible ( W , B , D ) ; return 0 ; }
Find the maximum GC@@ D possible for some pair in a given range [ L , R ] 9734 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int GC@@ D ( int a , int b ) { if ( b == 0 ) return a ; return GC@@ D ( b , a % b ) ; } int max@@ G@@ CD@@ InRange ( int L , int R ) { int ans = 1 ; for ( int Z = R ; Z >= 1 ; Z -- ) { if ( ( R / Z ) - ( L - 1 ) / Z > 1 ) { ans = Z ; break ; } } return ans ; } int main ( ) { int L = 102 ; int R = 139 ; cout << max@@ G@@ CD@@ InRange ( L , R ) ; return 0 ; }
Find Prime number just less than and just greater each element of given Array 9738 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Prime ( int X ) { for ( int i = 2 ; i * i <= X ; i ++ ) return false ; return true ; } void print@@ Pri@@ mes ( int A [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = A [ i ] - 1 ; ; j -- ) { if ( is@@ Prime ( j ) ) { cout << j << " ▁ " ; break ; } } for ( int j = A [ i ] + 1 ; ; j ++ ) { if ( is@@ Prime ( j ) ) { cout << j << " ▁ " ; break ; } } cout << endl ; } } int main ( ) { int A [ ] = { 17 , 28 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; print@@ Pri@@ mes ( A , N ) ; return 0 ; }
S@@ malle@@ st number required to be added to M to make it di@@ visible by N 9791 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Num ( int N , int K ) { int rem = ( N + K ) % K ; if ( rem == 0 ) return N ; else return N + K - rem ; } int find@@ S@@ malle@@ st ( int M , int N ) { int x = find@@ Num ( M , N ) ; return x - M ; } int main ( ) { int M = 100 , N = 28 ; cout << find@@ S@@ malle@@ st ( M , N ) ; return 0 ; }
Minimum time required to schedule K processes 9812 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int min@@ Time ( int A [ ] , int n , int K ) { int max_@@ ability = A [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { max_@@ ability = max ( max_@@ ability , A [ i ] ) ; } int tmp [ max_@@ ability + 1 ] = { 0 } ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { tmp [ A [ i ] ] ++ ; } for ( int i = max_@@ ability ; i >= 0 ; i -- ) { if ( tmp [ i ] != 0 ) { if ( tmp [ i ] * i < K ) { K -= ( i * tmp [ i ] ) ; tmp [ i / 2 ] += tmp [ i ] ; count += tmp [ i ] ; if ( K <= 0 ) { return count ; } } else { if ( K % i != 0 ) { count += ( K / i ) + 1 ; } else { count += ( K / i ) ; } return count ; } } } return -1 ; } int main ( ) { int arr [ ] = { 3 , 1 , 7 , 2 , 4 } ; int N = 5 ; int K = 15 ; cout << min@@ Time ( arr , N , K ) ; return 0 ; }
Minimum operations required to make all elements in an array of first N odd numbers equal 9825 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int min@@ Operations ( int N ) { int arr [ N ] ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] = ( 2 * i ) + 1 ; sum = sum + arr [ i ] ; } int mid = 0 ; if ( N % 2 == 0 ) { mid = sum / N ; } else { mid = arr [ N / 2 ] ; } int ans = 0 ; for ( int i = 0 ; i < N / 2 ; i ++ ) { ans += mid - arr [ i ] ; } return ans ; } int main ( ) { int N = 6 ; cout << min@@ Operations ( N ) ; return 0 ; }
Queries to update array by adding or multiply@@ ing array elements and print the element present at specified index 9847 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void Query ( int arr [ ] , int N , vector < vector < int > > Q ) { int mul = 1 ; int add = 0 ; for ( int i = 0 ; i < Q . size ( ) ; i ++ ) { if ( Q [ i ] [ 0 ] == 0 ) { add = add + Q [ i ] [ 1 ] ; } else if ( Q [ i ] [ 0 ] == 1 ) { mul = mul * Q [ i ] [ 1 ] ; add = add * Q [ i ] [ 1 ] ; } else { int ans = arr [ Q [ i ] [ 1 ] ] * mul + add ; cout << ans << " ▁ " ; } } } int main ( ) { int arr [ ] = { 3 , 1 , 23 , 45 , 100 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; vector < vector < int > > Q = { { 1 , 2 } , { 0 , 10 } , { 2 , 3 } , { 1 , 5 } , { 2 , 4 } } ; Query ( arr , N , Q ) ; return 0 ; }
Maximum sum of pairs that are at least K distance ap@@ art in an array 9850 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int getMax@@ Pair@@ Sum ( int arr [ ] , int N , int K ) { int pre@@ Max [ N ] ; pre@@ Max [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { pre@@ Max [ i ] = max ( pre@@ Max [ i - 1 ] , arr [ i ] ) ; } int res = INT_@@ MIN ; for ( int i = K ; i < N ; i ++ ) { res = max ( res , arr [ i ] + pre@@ Max [ i - K ] ) ; } return res ; } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 8 , 6 , 3 } ; int K = 3 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << getMax@@ Pair@@ Sum ( arr , N , K ) ; return 0 ; }
Count pairs from an array having GC@@ D equal to the minimum element in the pair 9853 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int Count@@ Pairs ( int arr [ ] , int N ) { int res = 0 ; map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { mp [ arr [ i ] ] ++ ; } for ( auto p : mp ) { int x = p . first ; int y = p . second ; if ( x == 1 ) { res += N - 1 ; continue ; } res += ( y * ( y - 1 ) ) / 2 ; for ( int j = 2 ; j <= sqrt ( x ) ; j ++ ) { if ( x % j == 0 ) { res += mp [ j ] ; if ( j != x / j ) res += mp [ x / j ] ; } } } return res ; } int main ( ) { int arr [ ] = { 2 , 3 , 1 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << Count@@ Pairs ( arr , N ) ; return 0 ; }
Minim@@ ize sum of an array having Bit@@ wise AND of all its pairs present in a given matrix 9876 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Min@@ Sum ( vector < vector < int > > mat , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int res = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( i != j ) { res |= mat [ i ] [ j ] ; } } sum += res ; } return sum ; } int main ( ) { vector < vector < int > > mat = { { -1 , 2 , 3 } , { 9 , -1 , 7 } , { 4 , 5 , -1 } } ; int N = mat . size ( ) ; cout << find@@ Min@@ Sum ( mat , N ) ; return 0 ; }
Minim@@ ize maximum difference between adjacent elements possible by removing a single array element 9880 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max@@ Adjac@@ ent@@ Difference ( vector < int > A ) { int diff = 0 ; for ( int i = 1 ; i < ( int ) A . size ( ) ; i ++ ) { diff = max ( diff , A [ i ] - A [ i - 1 ] ) ; } return diff ; } int Minimum@@ Value ( int arr [ ] , int N ) { int Min@@ Value = INT_MAX ; for ( int i = 0 ; i < N ; i ++ ) { vector < int > new_@@ arr ; for ( int j = 0 ; j < N ; j ++ ) { if ( i == j ) continue ; new_@@ arr . push_back ( arr [ j ] ) ; } Min@@ Value = min ( Min@@ Value , max@@ Adjac@@ ent@@ Difference ( new_@@ arr ) ) ; } return Min@@ Value ; } int main ( ) { int arr [ ] = { 1 , 3 , 7 , 8 } ; int N = sizeof ( arr ) / sizeof ( int ) ; cout << Minimum@@ Value ( arr , N ) ; return 0 ; }
Number of Anti@@ symmetric Relations on a set of N elements 9884 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; const int mod = 100000000@@ 7 ; int power ( long long x , unsigned int y ) { int res = 1 ; x = x % mod ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % mod ; y = y >> 1 ; x = ( x * x ) % mod ; } return res ; } int anti@@ symmetri@@ c@@ Relation ( int N ) { return ( power ( 2 , N ) * 1@@ LL * power ( 3 , ( N * N - N ) / 2 ) ) % mod ; } int main ( ) { int N = 2 ; cout << anti@@ symmetri@@ c@@ Relation ( N ) ; return 0 ; }
Count pairs with odd Bit@@ wise XOR that can be removed and replaced by their Bit@@ wise OR 9893 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void count@@ Pairs ( int arr [ ] , int N ) { int even = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; } if ( N - even >= 1 ) { cout << even ; return ; } cout << 0 ; } int main ( ) { int arr [ ] = { 5 , 4 , 7 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; count@@ Pairs ( arr , N ) ; return 0 ; }
Permutation of first N natural numbers having given array as the prefix maximum array 9896 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool check@@ Permutation ( int ans [ ] , int a [ ] , int n ) { int Max = INT_@@ MIN ; for ( int i = 0 ; i < n ; i ++ ) { Max = max ( Max , ans [ i ] ) ; if ( Max != a [ i ] ) return false ; } return true ; } void find@@ Permutation ( int a [ ] , int n ) { int ans [ n ] = { 0 } ; unordered_map < int , int > um ; for ( int i = 0 ; i < n ; i ++ ) { if ( um . find ( a [ i ] ) == um . end ( ) ) { ans [ i ] = a [ i ] ; um [ a [ i ] ] = i ; } } vector < int > v ; int j = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( um . find ( i ) == um . end ( ) ) { v . push_back ( i ) ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( ans [ i ] == 0 ) { ans [ i ] = v [ j ] ; j ++ ; } } if ( check@@ Permutation ( ans , a , n ) ) { for ( int i = 0 ; i < n ; i ++ ) { cout << ans [ i ] << " ▁ " ; } } else cout << " - 1" ; } int main ( ) { int arr [ ] = { 1 , 3 , 4 , 5 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; find@@ Permutation ( arr , N ) ; return 0 ; }
Find all pairs raised to power K differs by exactly N 9922 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void Valid@@ Pairs ( int X , int K ) { long long int count = 0 ; for ( int A = -@@ 1000 ; A <= 1000 ; A ++ ) { for ( int B = -@@ 1000 ; B <= 1000 ; B ++ ) { if ( pow ( A , K ) - pow ( B , K ) == X ) { count ++ ; cout << A << " ▁ " << B << endl ; } } } if ( count == 0 ) { cout << " - 1" ; } } int main ( ) { long long int X = 33 ; int K = 5 ; Valid@@ Pairs ( X , K ) ; return 0 ; }
XOR of major diagonal elements of a 3D Matrix 9927 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ XOR ( vector < vector < vector < int > > > & mat , int N ) { int XOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { XOR ^= mat [ i ] [ i ] [ i ] ; XOR ^= mat [ i ] [ i ] [ N - i - 1 ] ; } cout << XOR << " STRNEWLINE " ; } int main ( ) { vector < vector < vector < int > > > mat = { { { 1 , 2 } , { 3 , 4 } } , { { 5 , 6 } , { 7 , 8 } } } ; int N = mat . size ( ) ; find@@ XOR ( mat , N ) ; return 0 ; }
Find the player who wins the game of pl@@ acing alternate + and 9929 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void check@@ Win@@ ner ( int arr [ ] , int N ) { int diff = 0 ; for ( int i = 0 ; i < N ; i ++ ) { diff -= arr [ i ] ; } if ( diff % 2 == 0 ) { cout << " A " ; } else { cout << " B " ; } } int main ( ) { int arr [ ] = { 1 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; check@@ Win@@ ner ( arr , N ) ; return 0 ; }
Program to check if a number can be expressed as an even power of 2 or not 9942 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool check@@ Even@@ Power ( long long int N ) { if ( ( N & ( N - 1 ) ) != 0 ) return false ; N = N & 0x5@@ 5555@@ 555 ; return ( N > 0 ) ; } int main ( ) { int N = 4 ; cout << check@@ Even@@ Power ( N ) ; return 0 ; }
Maximum sum of K 9954 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int distinct ( int arr [ ] , int n ) { map < int , int > mp@@ p ; for ( int i = 0 ; i < n ; i ++ ) { mp@@ p [ arr [ i ] ] = 1 ; } return mp@@ p . size ( ) ; } int max@@ Sub@@ Sum ( int arr [ ] , int n , int k , int total@@ Distin@@ ct ) { if ( k > n ) return 0 ; int max@@ m = 0 , sum = 0 ; for ( int i = 0 ; i < n - k + 1 ; i ++ ) { sum = 0 ; set < int > st ; for ( int j = i ; j < i + k ; j ++ ) { sum += arr [ j ] ; st . insert ( arr [ j ] ) ; } if ( ( int ) st . size ( ) == total@@ Distin@@ ct ) max@@ m = max ( sum , max@@ m ) ; } return max@@ m ; } int main ( ) { int arr [ ] = { 7 , 7 , 2 , 4 , 2 , 7 , 4 , 6 , 6 , 6 } ; int K = 6 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int total@@ Distin@@ ct = distinct ( arr , N ) ; cout << ( max@@ Sub@@ Sum ( arr , N , K , total@@ Distin@@ ct ) ) ; return 0 ; }
Partition array into two sub@@ arrays with every element in the right sub@@ array strictly greater than every element in left sub@@ array 9963 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void partition@@ Array ( int * a , int n ) { int * Min = new int [ n ] ; int Min@@ i = INT_MAX ; for ( int i = n - 1 ; i >= 0 ; i -- ) { Min@@ i = min ( Min@@ i , a [ i ] ) ; Min [ i ] = Min@@ i ; } int Max@@ i = INT_@@ MIN ; int ind = -1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { Max@@ i = max ( Max@@ i , a [ i ] ) ; if ( Max@@ i < Min [ i + 1 ] ) { ind = i ; break ; } } if ( ind != -1 ) { for ( int i = 0 ; i <= ind ; i ++ ) cout << a [ i ] << " ▁ " ; cout << endl ; for ( int i = ind + 1 ; i < n ; i ++ ) cout << a [ i ] << " ▁ " ; } else cout << " Imp@@ ossible " ; } int main ( ) { int arr [ ] = { 5 , 3 , 2 , 7 , 9 } ; int N = 5 ; partition@@ Array ( arr , N ) ; return 0 ; }
Count ways to represent an integer as an exponent 9979 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; long long int gcd ( long long int a , long long int b ) { while ( b > 0 ) { long long int rem = a % b ; a = b ; b = rem ; } return a ; } int count@@ NumberOf@@ W@@ ays ( long long int n ) { if ( n == 1 ) return -1 ; long long int g = 0 ; int power = 0 ; while ( n % 2 == 0 ) { power ++ ; n /= 2 ; } g = gcd ( g , power ) ; for ( int i = 3 ; i <= sqrt ( n ) ; i += 2 ) { power = 0 ; while ( n % i == 0 ) { power ++ ; n /= i ; } g = gcd ( g , power ) ; } if ( n > 2 ) g = gcd ( g , 1 ) ; int ways = 1 ; power = 0 ; while ( g % 2 == 0 ) { g /= 2 ; power ++ ; } ways *= ( power + 1 ) ; for ( int i = 3 ; i <= sqrt ( g ) ; i += 2 ) { power = 0 ; while ( g % i == 0 ) { power ++ ; g /= i ; } ways *= ( power + 1 ) ; } if ( g > 2 ) ways *= 2 ; return ways ; } int main ( ) { int N = 64 ; cout << count@@ NumberOf@@ W@@ ays ( N ) ; return 0 ; }
Count of Oct@@ al numbers upto N digits 10970 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count ( int N ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += 7 * pow ( 8 , i - 1 ) ; } return sum ; } int main ( ) { int N = 4 ; cout << count ( N ) ; return 0 ; }
Maxim@@ ize value of ( a + b ) such that ( a * a 10978 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int maxValue ( int n ) { return n ; } int main ( ) { int n = 1 ; cout << maxValue ( n ) ; return 0 ; }
Length of S@@ malle@@ st sub@@ array in range 1 to N with sum greater than a given value 11007 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int using@@ Binary@@ Search ( int start , int end , int N , int S ) { if ( start >= end ) return start ; int mid = start + ( end - start ) / 2 ; int total@@ Sum = ( N * ( N + 1 ) ) / 2 ; int mid@@ Sum = ( mid * ( mid + 1 ) ) / 2 ; if ( ( total@@ Sum - mid@@ Sum ) <= S ) { return using@@ Binary@@ Search ( start , mid , N , S ) ; } return using@@ Binary@@ Search ( mid + 1 , end , N , S ) ; } int main ( ) { int N , S ; N = 5 ; S = 11 ; cout << ( N - using@@ Binary@@ Search ( 1 , N , N , S ) + 1 ) << endl ; return 0 ; }
Check if Sum and XOR of all elements of array is equal 11013 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int equal_@@ xor_@@ sum ( int arr [ ] , int n ) { int Sum = 0 ; int Xor = 0 ; for ( int i = 0 ; i < n ; i ++ ) { Sum = Sum + arr [ i ] ; Xor = Xor ^ arr [ i ] ; } if ( Sum == Xor ) cout << " YES " ; else cout << " NO " ; return 0 ; } int main ( ) { int arr [ ] = { 6 , 3 , 7 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; equal_@@ xor_@@ sum ( arr , n ) ; return 0 ; }
Reduce a number to 1 by performing given operations | Set 2 11019 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int set_@@ bits ( int n ) { int count = 0 ; while ( n ) { count += n % 2 ; n /= 2 ; } return count ; } int min@@ Steps ( int n ) { int ans = 0 ; while ( n != 1 ) { if ( n % 2 == 0 ) n /= 2 ; else if ( n == 3 or set_@@ bits ( n - 1 ) < set_@@ bits ( n + 1 ) ) n -- ; else n ++ ; ans ++ ; } return ans ; } int main ( ) { int n = 15 ; cout << min@@ Steps ( n ) ; return 0 ; }
Find two numbers with the given LC@@ M and minimum possible difference 11024 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int l@@ cm ( int a , int b ) { return ( a / __@@ gcd ( a , b ) * b ) ; } void find@@ Num@@ s ( int x ) { int ans ; for ( int i = 1 ; i <= sqrt ( x ) ; i ++ ) { if ( x % i == 0 && l@@ cm ( i , x / i ) == x ) { ans = i ; } } cout << ans << " ▁ " << ( x / ans ) ; } int main ( ) { int x = 12 ; find@@ Num@@ s ( x ) ; return 0 ; }
Remove one element to get minimum OR value 11055 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int min@@ OR ( int * arr , int n ) { if ( n == 1 ) return 0 ; int pre [ n ] , su@@ f [ n ] ; pre [ 0 ] = arr [ 0 ] , su@@ f [ n - 1 ] = arr [ n - 1 ] ; for ( int i = 1 ; i < n ; i ++ ) pre [ i ] = ( pre [ i - 1 ] arr [ i ] ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) su@@ f [ i ] = ( su@@ f [ i + 1 ] arr [ i ] ) ; int ans = min ( pre [ n - 2 ] , su@@ f [ 1 ] ) ; for ( int i = 1 ; i < n - 1 ; i ++ ) ans = min ( ans , ( pre [ i - 1 ] su@@ f [ i + 1 ] ) ) ; return ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << min@@ OR ( arr , n ) ; return 0 ; }
Check if a number is Eu@@ ler P@@ se@@ ud@@ op@@ ri@@ me 11109 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Cnt ( int * arr , int n , int k ) { int ret = 0 ; int i = 0 ; while ( i < n ) { int j = i + 1 ; while ( j < n and arr [ j ] > = arr [ j - 1 ] ) j ++ ; int x = max ( 0 , j - i - k + 1 ) ; ret += ( x * ( x + 1 ) ) / 2 ; i = j ; } return ret ; } int main ( ) { int arr [ ] = { 5 , 4 , 3 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( int ) ; int k = 2 ; cout << find@@ Cnt ( arr , n , k ) ; return 0 ; }
Number of K '@@ s such that the given array can be divided into two sets satis@@ fying the given conditions 11121 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int two_@@ sets ( int a [ ] , int n ) { sort ( a , a + n ) ; return a [ n / 2 ] - a [ ( n / 2 ) - 1 ] ; } int main ( ) { int a [ ] = { 1 , 4 , 4 , 6 , 7 , 9 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << two_@@ sets ( a , n ) ; return 0 ; }
Find the K@@ th position element of the given sequence 11128 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int k@@ th@@ Num ( int n , int k ) { int a = ( n + 1 ) / 2 ; if ( k > a ) return ( 2 * ( k - a ) ) ; return ( 2 * k - 1 ) ; } int main ( ) { int n = 7 , k = 7 ; cout << k@@ th@@ Num ( n , k ) ; return 0 ; }
Number of colo@@ ured 0 '@@ s in an N 11139 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count ( int n ) { return n * ( 3 * n - 1 ) / 2 ; } int main ( ) { int n = 3 ; cout << count ( n ) ; return 0 ; }
Find the deleted value from the array when average of original elements is given 11149 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Missing ( int arr [ ] , int n , int k , int avg ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int num = ( avg * ( n + k ) ) - sum ; int den = k ; if ( num % den != 0 ) return -1 ; return ( num / den ) ; } int main ( ) { int k = 3 , avg = 4 ; int arr [ ] = { 2 , 7 , 3 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << find@@ Missing ( arr , n , k , avg ) ; return 0 ; }
Sum of values of all possible non 11168 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int sum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } sum = sum * pow ( 2 , n - 1 ) ; return sum ; } int main ( ) { int arr [ ] = { 2 , 1 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << sum ( arr , n ) ; return 0 ; }
Minimum absolute difference between N and any power of 2 11173 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int prev@@ Power@@ of@@ 2 ( int n ) { int p = ( int ) log2 ( n ) ; return ( int ) pow ( 2 , p ) ; } int next@@ PowerOf@@ 2 ( int n ) { int p = 1 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( p < n ) p <<= 1 ; return p ; } int min@@ Diff ( int n ) { int low = prev@@ Power@@ of@@ 2 ( n ) ; int high = next@@ PowerOf@@ 2 ( n ) ; return min ( n - low , high - n ) ; } int main ( ) { int n = 6 ; cout << min@@ Diff ( n ) ; return 0 ; }
Check whether N is a Factor@@ ion or not 11181 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define MAX 10 NEW_LINE bool is@@ Factor@@ ion ( int n ) { int fact [ MAX ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i < MAX ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ; int org = n ; int sum = 0 ; while ( n > 0 ) { int d = n % 10 ; sum += fact [ d ] ; n /= 10 ; } if ( sum == org ) return true ; return false ; } int main ( ) { int n = 405@@ 85 ; if ( is@@ Factor@@ ion ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
Color all boxes in line such that every M consecutive boxes are unique 11182 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define MOD 100000000@@ 7 NEW_LINE int mod@@ Fact ( int n , int m ) { int result = 1 ; for ( int i = 1 ; i <= m ; i ++ ) result = ( result * i ) % MOD ; return result ; } int main ( ) { int n = 3 , m = 2 ; cout << mod@@ Fact ( n , m ) ; return 0 ; }
Maximum count of common di@@ visors of A and B such that all are co 11185 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max@@ Common@@ Factors ( int a , int b ) { int gcd = __@@ gcd ( a , b ) ; int ans = 1 ; for ( int i = 2 ; i * i <= gcd ; i ++ ) { if ( gcd % i == 0 ) { ans ++ ; while ( gcd % i == 0 ) gcd /= i ; } } if ( gcd != 1 ) ans ++ ; return ans ; } int main ( ) { int a = 12 , b = 18 ; cout << max@@ Common@@ Factors ( a , b ) ; return 0 ; }
Count total unset bits in all the numbers from 1 to N 11216 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Un@@ set@@ Bits ( int n ) { int cnt = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int temp = i ; while ( temp ) { if ( temp % 2 == 0 ) cnt ++ ; temp = temp / 2 ; } } return cnt ; } int main ( ) { int n = 5 ; cout << count@@ Un@@ set@@ Bits ( n ) ; return 0 ; }
Check if the sum of digits of number is di@@ visible by all of its digits 11223 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Di@@ visible ( long long int n ) { long long int temp = n ; int sum = 0 ; while ( n ) { int digit = n % 10 ; sum += digit ; n /= 10 ; } n = temp ; while ( n ) { int digit = n % 10 ; if ( sum % digit != 0 ) return false ; n /= 10 ; } return true ; } int main ( ) { long long int n = 123 ; if ( is@@ Di@@ visible ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
Maximum items that can be bou@@ ght with the given type of coins 11227 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; const int CO@@ ST = 3 ; int max@@ Items ( int x , int y , int z ) { int type1 = x / CO@@ ST ; x %= CO@@ ST ; int type2 = y / CO@@ ST ; y %= CO@@ ST ; int type@@ 3 = z / CO@@ ST ; z %= CO@@ ST ; int type@@ 4 = min ( x , min ( y , z ) ) ; int max@@ Items = type1 + type2 + type@@ 3 + type@@ 4 ; return max@@ Items ; } int main ( ) { int x = 4 , y = 5 , z = 6 ; cout << max@@ Items ( x , y , z ) ; return 0 ; }
Number of Sub@@ sequences with Even and Odd Sum | Set 2 11254 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; pair < int , int > count@@ Sum ( int arr [ ] , int n ) { int NumberOf@@ O@@ d@@ ds = 0 , NumberOf@@ Ev@@ ens = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] & 1 ) NumberOf@@ O@@ d@@ ds ++ ; NumberOf@@ Ev@@ ens = n - NumberOf@@ O@@ d@@ ds ; int NumberOf@@ O@@ dd@@ Sub@@ sequences = ( 1 << NumberOf@@ Ev@@ ens ) * ( 1 << ( NumberOf@@ O@@ d@@ ds - 1 ) ) ; int NumberOf@@ Even@@ Sub@@ sequences = ( 1 << n ) - 1 - NumberOf@@ O@@ dd@@ Sub@@ sequences ; return { NumberOf@@ Even@@ Sub@@ sequences , NumberOf@@ O@@ dd@@ Sub@@ sequences } ; } int main ( ) { int arr [ ] = { 1 , 2 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; pair < int , int > ans = count@@ Sum ( arr , n ) ; cout << " Even@@ Sum ▁ = ▁ " << ans . first ; cout << " ▁ O@@ dd@@ Sum ▁ = ▁ " << ans . second ; return 0 ; }
Find prime numbers in the first half and second half of an array 11319 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool prime ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } void pri@@ me_@@ range ( int start , int end , int * a ) { for ( int i = start ; i < end ; i ++ ) { if ( prime ( a [ i ] ) ) cout << a [ i ] << " ▁ " ; } } void Print ( int arr [ ] , int n ) { cout << " Prime ▁ numbers ▁ in ▁ the ▁ first ▁ half ▁ are ▁ " ; pri@@ me_@@ range ( 0 , n / 2 , arr ) ; cout << endl ; cout << " Prime ▁ numbers ▁ in ▁ the ▁ second ▁ half ▁ are ▁ " ; pri@@ me_@@ range ( n / 2 , n , arr ) ; cout << endl ; } int main ( ) { int arr [ ] = { 2 , 5 , 10 , 15 , 17 , 21 , 23 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; Print ( arr , n ) ; return 0 ; }
Removing a number from array without changing its arithmetic mean 11328 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int Find@@ Element ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + a [ i ] ; if ( sum % n == 0 ) { int m = sum / n ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] == m ) return m ; } return -1 ; } int main ( ) { int a [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( a ) / sizeof ( int ) ; cout << Find@@ Element ( a , n ) ; return 0 ; }
Count of N digit numbers possible which satisfy the given conditions 11339 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } int Count_@@ number ( int N ) { return ( N * fact ( N ) ) ; } int main ( ) { int N = 2 ; cout << Count_@@ number ( N ) ; return 0 ; }
Number of hours after which the second person moves ahead of the first person if they travel at a given speed 11349 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Hours ( int a , int b , int k ) { if ( a >= b ) return -1 ; int time = k / ( b - a ) ; time = time + 1 ; return time ; } int main ( ) { int a = 4 , b = 5 , k = 1 ; cout << find@@ Hours ( a , b , k ) ; return 0 ; }
Number of ways of distribu@@ ting N identical objects in R distinct groups with no groups empty 11352 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int n@@ cr ( int n , int r ) { int ans = 1 ; for ( int i = 1 ; i <= r ; i += 1 ) { ans *= ( n - r + i ) ; ans /= i ; } return ans ; } int NoOf@@ Distribu@@ tions ( int N , int R ) { return n@@ cr ( N - 1 , R - 1 ) ; } int main ( ) { int N = 4 ; int R = 3 ; cout << NoOf@@ Distribu@@ tions ( N , R ) ; return 0 ; }
Find the minimum number of elements that should be removed to make an array good 11371 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int Min@@ Remove ( int a [ ] , int n , int k ) { vector < int > cnt ( k , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) cnt [ 0 ] ++ ; else if ( cnt [ a [ i ] - 1 ] > 0 ) { cnt [ a [ i ] - 1 ] -- ; cnt [ a [ i ] ] ++ ; } } return n - ( k * cnt [ k - 1 ] ) ; } int main ( ) { int a [ ] = { 0 , 1 , 2 , 3 , 4 , 0 , 1 , 0 , 1 , 2 , 3 , 4 } , k = 5 ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << Min@@ Remove ( a , n , k ) ; return 0 ; }
Print Lower He@@ ss@@ en@@ berg matrix of order N 11383 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void Lower@@ He@@ ss@@ en@@ ber@@ g@@ Matrix ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( j > i + 1 ) cout << '0' << " ▁ " ; else cout << rand ( ) % 10 << " ▁ " ; } cout << " STRNEWLINE " ; } } int main ( ) { int n = 4 ; Lower@@ He@@ ss@@ en@@ ber@@ g@@ Matrix ( n ) ; return 0 ; }
Count Distin@@ ct Rect@@ angles in N * N Ch@@ ess@@ board 11387 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count ( int N ) { int a = 0 ; a = ( N * ( N + 1 ) ) / 2 ; return a ; } int main ( ) { int N = 4 ; cout << count ( N ) ; }
Sum of all mer@@ sen@@ ne numbers present in an array 11389 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int is@@ Mer@@ sen@@ ne ( int n ) { while ( n != 0 ) { int r = n % 2 ; if ( r == 0 ) return false ; n /= 2 ; } return true ; } int sum@@ Of@@ Mer@@ sen@@ ne ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 && is@@ Mer@@ sen@@ ne ( arr [ i ] ) ) { sum += arr [ i ] ; } } return sum ; } int main ( ) { int arr [ ] = { 17 , 6 , 7 , 63 , 3 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << ( sum@@ Of@@ Mer@@ sen@@ ne ( arr , n ) ) ; return 0 ; }
Total number of days taken to complete the task if after certain days one person leaves 11404 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int numberOf@@ Days ( int a , int b , int n ) { int Days = b * ( n + a ) / ( a + b ) ; return Days ; } int main ( ) { int a = 10 , b = 20 , n = 5 ; cout << numberOf@@ Days ( a , b , n ) ; return 0 ; }
Maximum number of people that can be killed with strength P 11417 | #@@ include <@@ algorithm@@ > NEW_LINE #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; long square@@ Series ( long n ) { return ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; } long max@@ People ( long n ) { long low = 0 ; long high = 1000000@@ L ; long ans = 0L ; while ( low <= high ) { long mid = low + ( ( high - low ) / 2 ) ; long value = square@@ Series ( mid ) ; if ( value <= n ) { ans = mid ; low = mid + 1 ; } else { high = mid - 1 ; } } return ans ; } int main ( ) { long p = 14 ; cout << max@@ People ( p ) ; return 0 ; }
Check whether product of integers from a to b is positive , negative or zero 11425 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; void solve ( long long int a , long long int b ) { if ( a > 0 && b > 0 ) { cout << " Positive " ; } else if ( a <= 0 && b >= 0 ) { cout << " Zero " << endl ; } else { long long int n = abs ( a - b ) + 1 ; if ( n % 2 == 0 ) { cout << " Positive " << endl ; } else { cout << " Negative " << endl ; } } } int main ( ) { int a = -@@ 10 , b = -2 ; solve ( a , b ) ; return 0 ; }
Find sum of factor@@ i@@ als in an array 11461 | #@@ include <@@ io@@ stream@@ > NEW_LINE #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int factorial ( int n ) { int f = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { f *= i ; } return f ; } int sum@@ Fac@@ tori@@ al ( int * arr , int n ) { int s = 0 , i ; for ( i = 0 ; i < n ; i ++ ) { s += factorial ( arr [ i ] ) ; } return s ; } int main ( ) { int arr [ ] = { 7 , 3 , 5 , 4 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << sum@@ Fac@@ tori@@ al ( arr , n ) ; return 0 ; }
Check if given two straight lines are identical or not 11475 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void id@@ str@@ t ( double a1 , double b1 , double c1 , double a2 , double b2 , double c2 ) { if ( ( a1 / a2 == b1 / b2 ) && ( a1 / a2 == c1 / c2 ) && ( b1 / b2 == c1 / c2 ) ) cout << " The ▁ given ▁ straight " << " ▁ lines ▁ are ▁ identical " << endl ; else cout << " The ▁ given ▁ straight " << " ▁ lines ▁ are ▁ not ▁ identical " << endl ; } int main ( ) { double a1 = -2 , b1 = 4 , c1 = 3 , a2 = -@@ 6 , b2 = 12 , c2 = 9 ; id@@ str@@ t ( a1 , b1 , c1 , a2 , b2 , c2 ) ; return 0 ; }
S@@ malle@@ st N digit number which is a multiple of 5 11488 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int smalle@@ st@@ Multiple ( int n ) { if ( n == 1 ) return 5 ; return pow ( 10 , n - 1 ) ; } int main ( ) { int n = 4 ; cout << smalle@@ st@@ Multiple ( n ) ; return 0 ; }
Number of ways of choo@@ sing K equal sub@@ strings of any length for every query 11515 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define maxlen 100 NEW_LINE void generate@@ Sub@@ Strings ( string s , unordered_map < string , int > & mp@@ p ) { int l = s . length ( ) ; for ( int i = 0 ; i < l ; i ++ ) { string temp = " " ; for ( int j = i ; j < l ; j ++ ) { temp += s [ j ] ; mp@@ p [ temp ] += 1 ; } } } void bin@@ omi@@ al@@ Coeff ( int C [ maxlen ] [ maxlen ] ) { int i , j ; for ( i = 0 ; i < 100 ; i ++ ) { for ( j = 0 ; j < 100 ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } } int answer@@ Query ( unordered_map < string , int > & mp@@ p , int C [ maxlen ] [ maxlen ] , int k ) { int ans = 0 ; for ( auto it : mp@@ p ) { if ( it . second >= k ) ans += C [ it . second ] [ k ] ; } return ans ; } int main ( ) { string s = " a@@ ab@@ aa@@ b " ; unordered_map < string , int > mp@@ p ; generate@@ Sub@@ Strings ( s , mp@@ p ) ; int C [ maxlen ] [ maxlen ] ; memset ( C , 0 , sizeof C ) ; bin@@ omi@@ al@@ Coeff ( C ) ; int queries [ ] = { 2 , 3 , 4 } ; int q = sizeof ( queries ) / sizeof ( queries [ 0 ] ) ; for ( int i = 0 ; i < q ; i ++ ) cout << answer@@ Query ( mp@@ p , C , queries [ i ] ) << endl ; return 0 ; }
XOR of all the elements in the given range [ L , R ] 11530 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; long compute@@ XOR ( const int n ) { switch ( n & 3 ) { case 0 : return n ; case 1 : return 1 ; case 2 : return n + 1 ; case 3 : return 0 ; } } int main ( ) { int l = 1 , r = 4 ; cout << ( compute@@ XOR ( r ) ^ compute@@ XOR ( l - 1 ) ) ; return 0 ; }
Sum of Fi@@ bon@@ ac@@ ci Numbers in a range 11545 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define ll long long int NEW_LINE int fi@@ b ( int n ) { double phi = ( 1 + sqrt ( 5 ) ) / 2 ; return round ( pow ( phi , n ) / sqrt ( 5 ) ) ; } ll calculate@@ Sum ( int l , int r ) { ll sum = 0 ; for ( int i = l ; i <= r ; i ++ ) sum += fi@@ b ( i ) ; return sum ; } int main ( ) { int l = 4 , r = 8 ; cout << calculate@@ Sum ( l , r ) ; return 0 ; }
Count of all N digit numbers such that num + Rev ( num ) = 10 ^ N 11584 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Numbers ( int n ) { if ( n % 2 == 1 ) return 0 ; return ( 9 * pow ( 10 , n / 2 - 1 ) ) ; } int main ( ) { int n = 2 ; cout << count@@ Numbers ( n ) ; return 0 ; }
Probability of A win@@ ning the match when individual probabilities of hit@@ ting the target given 11615 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; double get@@ Probability ( int a , int b , int c , int d ) { double p = ( double ) a / ( double ) b ; double q = ( double ) c / ( double ) d ; double ans = p * ( 1 / ( 1 - ( 1 - q ) * ( 1 - p ) ) ) ; return ans ; } int main ( ) { int a = 1 , b = 2 , c = 10 , d = 11 ; cout << get@@ Probability ( a , b , c , d ) ; return 0 ; }
Sum of minimum element of all sub 11630 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Min@@ Sum ( int arr [ ] , int n ) { int oc@@ c = n - 1 , sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] * pow ( 2 , oc@@ c ) ; oc@@ c -- ; } return sum ; } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << find@@ Min@@ Sum ( arr , n ) ; return 0 ; }
Sum of all Sub@@ matrices of a Given Matrix 11652 | #@@ include <@@ io@@ stream@@ > NEW_LINE #@@ define n 3 NEW_LINE using namespace std ; int matrix@@ Sum ( int arr [ ] [ n ] ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { int top_@@ left = ( i + 1 ) * ( j + 1 ) ; int bottom_@@ right = ( n - i ) * ( n - j ) ; sum += ( top_@@ left * bottom_@@ right * arr [ i ] [ j ] ) ; } return sum ; } int main ( ) { int arr [ ] [ n ] = { { 1 , 1 , 1 } , { 1 , 1 , 1 } , { 1 , 1 , 1 } } ; cout << matrix@@ Sum ( arr ) ; return 0 ; }
Count primes that can be expressed as sum of two consecutive primes and 1 11664 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define N 10000@@ 5 NEW_LINE bool i@@ spri@@ me [ N ] ; bool can [ N ] ; vector < int > Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( ) { memset ( i@@ spri@@ me , true , sizeof ( i@@ spri@@ me ) ) ; for ( int p = 2 ; p * p < N ; p ++ ) { if ( i@@ spri@@ me [ p ] == true ) { for ( int i = p * p ; i < N ; i += p ) i@@ spri@@ me [ i ] = false ; } } vector < int > primes ; for ( int i = 2 ; i < N ; i ++ ) if ( i@@ spri@@ me [ i ] ) primes . push_back ( i ) ; return primes ; } int Pri@@ me_@@ Numbers ( int n ) { vector < int > primes = Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( ) ; for ( int i = 0 ; i < ( int ) ( primes . size ( ) ) - 1 ; i ++ ) if ( primes [ i ] + primes [ i + 1 ] + 1 < N ) can [ primes [ i ] + primes [ i + 1 ] + 1 ] = true ; int ans = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( can [ i ] and i@@ spri@@ me [ i ] ) { ans ++ ; } } return ans ; } int main ( ) { int n = 50 ; cout << Pri@@ me_@@ Numbers ( n ) ; return 0 ; }
Mid@@ point ellipse drawing algorithm 11721 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void mid@@ p@@ te@@ llip@@ se ( int rx , int ry , int xc , int yc ) { float dx , dy , d1 , d2 , x , y ; x = 0 ; y = ry ; d1 = ( ry * ry ) - ( rx * rx * ry ) + ( 0.25 * rx * rx ) ; dx = 2 * ry * ry * x ; dy = 2 * rx * rx * y ; while ( dx < dy ) { cout << x + xc << " ▁ , ▁ " << y + yc << endl ; cout << - x + xc << " ▁ , ▁ " << y + yc << endl ; cout << x + xc << " ▁ , ▁ " << - y + yc << endl ; cout << - x + xc << " ▁ , ▁ " << - y + yc << endl ; if ( d1 < 0 ) { x ++ ; dx = dx + ( 2 * ry * ry ) ; d1 = d1 + dx + ( ry * ry ) ; } else { x ++ ; y -- ; dx = dx + ( 2 * ry * ry ) ; dy = dy - ( 2 * rx * rx ) ; d1 = d1 + dx - dy + ( ry * ry ) ; } } d2 = ( ( ry * ry ) * ( ( x + 0.5 ) * ( x + 0.5 ) ) ) + ( ( rx * rx ) * ( ( y - 1 ) * ( y - 1 ) ) ) - ( rx * rx * ry * ry ) ; while ( y >= 0 ) { cout << x + xc << " ▁ , ▁ " << y + yc << endl ; cout << - x + xc << " ▁ , ▁ " << y + yc << endl ; cout << x + xc << " ▁ , ▁ " << - y + yc << endl ; cout << - x + xc << " ▁ , ▁ " << - y + yc << endl ; if ( d2 > 0 ) { y -- ; dy = dy - ( 2 * rx * rx ) ; d2 = d2 + ( rx * rx ) - dy ; } else { y -- ; x ++ ; dx = dx + ( 2 * ry * ry ) ; dy = dy - ( 2 * rx * rx ) ; d2 = d2 + dx - dy + ( rx * rx ) ; } } } int main ( ) { mid@@ p@@ te@@ llip@@ se ( 10 , 15 , 50 , 50 ) ; return 0 ; }
Find the final X and Y when they are Alter@@ ing under given condition 11727 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; void alter ( long long int x , long long int y ) { while ( true ) { if ( x == 0 y == 0 ) break ; if ( x >= 2 * y ) x = x % ( 2 * y ) ; else if ( y >= 2 * x ) y = y % ( 2 * x ) ; else break ; } cout << " X = " << x << " , ▁ " << " Y = " << y ; } int main ( ) { long long int x = 12 , y = 5 ; alter ( x , y ) ; return 0 ; }
Per@@ mutations of string such that no two vo@@ w@@ els are adjacent 11781 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int factorial ( int n ) { int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) fact = fact * i ; return fact ; } int n@@ cr ( int n , int r ) { return factorial ( n ) / ( factorial ( r ) * factorial ( n - r ) ) ; } int count@@ W@@ ays ( string str ) { int freq [ 26 ] = { 0 } ; int n@@ vo@@ w@@ els = 0 , n@@ con@@ son@@ ants = 0 ; int v@@ places , c@@ ways , v@@ ways ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) ++ freq [ str [ i ] - ' a ' ] ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( i == 0 i == 4 i == 8 i == 14 i == 20 ) n@@ vo@@ w@@ els += freq [ i ] ; else n@@ con@@ son@@ ants += freq [ i ] ; } v@@ places = n@@ con@@ son@@ ants + 1 ; c@@ ways = factorial ( n@@ con@@ son@@ ants ) ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( i != 0 && i != 4 && i != 8 && i != 14 && i != 20 && freq [ i ] > 1 ) { c@@ ways = c@@ ways / factorial ( freq [ i ] ) ; } } v@@ ways = n@@ cr ( v@@ places , n@@ vo@@ w@@ els ) * factorial ( n@@ vo@@ w@@ els ) ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( i == 0 i == 4 i == 8 i == 14 i == 20 && freq [ i ] > 1 ) { v@@ ways = v@@ ways / factorial ( freq [ i ] ) ; } } return c@@ ways * v@@ ways ; } int main ( ) { string str = " permutation " ; cout << count@@ W@@ ays ( str ) << endl ; return 0 ; }
Sum of elements in an array having prime frequency 11866 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( bool prime [ ] , int p_@@ size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_@@ size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_@@ size ; i += p ) prime [ i ] = false ; } } } int sum@@ Of@@ Elements ( int arr [ ] , int n ) { bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( prime , n + 1 ) ; int i , j ; unordered_map < int , int > m ; for ( i = 0 ; i < n ; i ++ ) m [ arr [ i ] ] ++ ; int sum = 0 ; for ( auto it = m . begin ( ) ; it != m . end ( ) ; it ++ ) { if ( prime [ it -> second ] ) { sum += ( it -> first ) ; } } return sum ; } int main ( ) { int arr [ ] = { 5 , 4 , 6 , 5 , 4 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << sum@@ Of@@ Elements ( arr , n ) ; return 0 ; }
Count pairs from two arrays whose modulo operation yields K 11902 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int total@@ Pairs ( int ar@@ r1 [ ] , int ar@@ r2 [ ] , int K , int n , int m ) { set < pair < int , int > > s ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( ar@@ r1 [ i ] > ar@@ r2 [ j ] ) { if ( ar@@ r1 [ i ] % ar@@ r2 [ j ] == K ) s . insert ( make_pair ( ar@@ r1 [ i ] , ar@@ r2 [ j ] ) ) ; } else { if ( ar@@ r2 [ j ] % ar@@ r1 [ i ] == K ) s . insert ( make_pair ( ar@@ r2 [ j ] , ar@@ r1 [ i ] ) ) ; } } } return s . size ( ) ; } int main ( ) { int ar@@ r1 [ ] = { 8 , 3 , 7 , 50 } ; int ar@@ r2 [ ] = { 5 , 1 , 10 , 4 } ; int K = 3 ; int n = sizeof ( ar@@ r1 ) / sizeof ( ar@@ r1 [ 0 ] ) ; int m = sizeof ( ar@@ r2 ) / sizeof ( ar@@ r2 [ 0 ] ) ; cout << total@@ Pairs ( ar@@ r1 , ar@@ r2 , K , n , m ) ; return 0 ; }
S@@ malle@@ st prime number missing in an array 11915 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define ll long long int NEW_LINE vector < ll > find@@ Prime ( int MAX ) { bool pm [ MAX + 1 ] ; memset ( pm , true , sizeof ( pm ) ) ; pm [ 0 ] = pm [ 1 ] = false ; for ( int i = 2 ; i <= MAX ; i ++ ) if ( pm [ i ] ) for ( int j = 2 * i ; j <= MAX ; j += i ) pm [ j ] = false ; vector < ll > prime ; for ( int i = 0 ; i <= MAX ; i ++ ) if ( pm [ i ] ) prime . push_back ( i ) ; return prime ; } int find@@ S@@ malle@@ st ( int arr [ ] , int n ) { int MAX = * max_@@ element ( arr , arr + n ) ; vector < ll > prime = find@@ Prime ( MAX ) ; unordered_@@ set < int > s ; for ( int i = 0 ; i < n ; i ++ ) s . insert ( arr [ i ] ) ; int ans = -1 ; for ( int i = 0 ; i < prime . size ( ) ; i ++ ) if ( s . find ( prime [ i ] ) == s . end ( ) ) { ans = prime [ i ] ; break ; } return ans ; } int main ( ) { int arr [ ] = { 3 , 0 , 1 , 2 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( find@@ S@@ malle@@ st ( arr , n ) == -1 ) cout << " No ▁ prime ▁ number ▁ missing " ; else cout << find@@ S@@ malle@@ st ( arr , n ) ; return 0 ; }
Program to find the pro@@ fit or loss when CP of N items is equal to SP of M items 11922 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void pro@@ fit@@ Loss ( int N , int M ) { if ( N == M ) cout << " No ▁ Pro@@ fit ▁ nor ▁ Loss " ; else { float result = 0.0 ; result = float ( abs ( N - M ) ) / M ; if ( N - M < 0 ) cout << " Loss ▁ = ▁ - " << result * 100 << " % " ; else cout << " Pro@@ fit ▁ = ▁ " << result * 100 << " % " ; } } int main ( ) { int N = 8 , M = 9 ; pro@@ fit@@ Loss ( N , M ) ; return 0 ; }
Check whether sum of digits at odd places of a number is di@@ visible by K 11968 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool Sum@@ Di@@ visible ( int n , int k ) { int sum = 0 , position = 1 ; while ( n > 0 ) { if ( position % 2 == 1 ) sum += n % 10 ; n = n / 10 ; position ++ ; } if ( sum % k == 0 ) return true ; return false ; } int main ( ) { int n = 59@@ 24@@ 52 ; int k = 3 ; if ( Sum@@ Di@@ visible ( n , k ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
Check whether sum of digits at odd places of a number is di@@ visible by K 11969 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool sum@@ Di@@ visible ( int n , int k ) { int sum = 0 ; string num = to_string ( n ) ; int i ; for ( i = 0 ; i < num . size ( ) ; i ++ ) { if ( i % 2 != 0 ) { sum = sum + ( num [ i ] - '0' ) ; } } if ( sum % k == 0 ) { return true ; } else { return false ; } } int main ( ) { int n = 59@@ 24@@ 52 ; int k = 3 ; if ( sum@@ Di@@ visible ( n , k ) ) { cout << ( " YES " ) ; } else { cout << ( " NO " ) ; } return 0 ; }
Maximum count of equal numbers in an array after performing given operations 12011 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int Equal@@ Numbers ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; if ( sum % n ) return n - 1 ; return n ; } int main ( ) { int a [ ] = { 1 , 4 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << Equal@@ Numbers ( a , n ) ; return 0 ; }
Print values of ' a ' in equation ( a + b ) <= n and a + b is di@@ visible by x 12038 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void Possible@@ Values ( int b , int x , int n ) { int least@@ di@@ visible = ( b / x + 1 ) * x ; int flag = 1 ; while ( least@@ di@@ visible <= n ) { if ( least@@ di@@ visible - b >= 1 ) { cout << least@@ di@@ visible - b << " ▁ " ; least@@ di@@ visible += x ; flag = 0 ; } else break ; } if ( flag ) cout << -1 ; } int main ( ) { int b = 10 , x = 6 , n = 40 ; Possible@@ Values ( b , x , n ) ; return 0 ; }
Check whether the given number is Eu@@ cli@@ d Number or not 12077 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define MAX 10000 NEW_LINE unordered_@@ set < long long int > s ; void Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( ) { bool prime [ MAX ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } long long int product = 1 ; for ( int p = 2 ; p < MAX ; p ++ ) { if ( prime [ p ] ) { product = product * p ; s . insert ( product + 1 ) ; } } } bool is@@ Eu@@ cli@@ d ( long n ) { if ( s . find ( n ) != s . end ( ) ) return true ; else return false ; } int main ( ) { Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( ) ; long n = 31 ; if ( is@@ Eu@@ cli@@ d ( n ) ) cout << " YES STRNEWLINE " ; else cout << " NO STRNEWLINE " ; n = 42 ; if ( is@@ Eu@@ cli@@ d ( n ) ) cout << " YES STRNEWLINE " ; else cout << " NO STRNEWLINE " ; return 0 ; }
Number of solutions for x < y , where a <= x <= b and c <= y <= d and x , y are integers 12087 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int NumberOf@@ Solutions ( int a , int b , int c , int d ) { int ans = 0 ; for ( int i = a ; i <= b ; i ++ ) if ( d >= max ( c , i + 1 ) ) ans += d - max ( c , i + 1 ) + 1 ; return ans ; } int main ( ) { int a = 2 , b = 3 , c = 3 , d = 4 ; cout << NumberOf@@ Solutions ( a , b , c , d ) ; return 0 ; }
Program to find N@@ th term of series 4 , 14 , 28 , 46 , 68 , 94 , 124 , 158 , ... . . 12144 | #@@ include <@@ io@@ stream@@ > NEW_LINE #@@ include <@@ math@@ .@@ h@@ > NEW_LINE using namespace std ; int n@@ th@@ Term ( int n ) { return 2 * pow ( n , 2 ) + 4 * n - 2 ; } int main ( ) { int N = 4 ; cout << n@@ th@@ Term ( N ) << endl ; return 0 ; }
Sum of Area of all possible square inside a rectangle 12244 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int calculate@@ Area@@ Sum ( int l , int b ) { int size = 1 ; int maxSize = min ( l , b ) ; int total@@ Area = 0 ; for ( int i = 1 ; i <= maxSize ; i ++ ) { int total@@ Squ@@ ares = ( l - size + 1 ) * ( b - size + 1 ) ; int area = total@@ Squ@@ ares * size * size ; total@@ Area += area ; size ++ ; } return total@@ Area ; } int main ( ) { int l = 4 , b = 3 ; cout << calculate@@ Area@@ Sum ( l , b ) ; return 0 ; }
Check if Decimal representation of an Oct@@ al number is di@@ visible by 7 12264 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int check ( int n ) { int sum = 0 ; while ( n != 0 ) { sum += n % 10 ; n = n / 10 ; } if ( sum % 7 == 0 ) return 1 ; else return 0 ; } int main ( ) { int n = 25 ; ( check ( n ) == 1 ) ? cout << " YES " : cout << " NO " ; return 0 ; }
Egg@@ s dro@@ pping pu@@ zzle ( Bin@@ omial Coefficient and Binary Search Solution ) 12287 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int bin@@ omi@@ al@@ Coeff ( int x , int n , int k ) { int sum = 0 , term = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { term *= x - i + 1 ; term /= i ; sum += term ; if ( sum > k ) return sum ; } return sum ; } int min@@ Tri@@ als ( int n , int k ) { int low = 1 , high = k ; while ( low < high ) { int mid = ( low + high ) / 2 ; if ( bin@@ omi@@ al@@ Coeff ( mid , n , k ) < k ) low = mid + 1 ; else high = mid ; } return low ; } int main ( ) { cout << min@@ Tri@@ als ( 2 , 10 ) ; return 0 ; }
Find next pal@@ ind@@ ro@@ me prime 12288 | #@@ include <@@ io@@ stream@@ > NEW_LINE #@@ include <@@ string@@ > NEW_LINE using namespace std ; bool is@@ Prime ( int num ) { if ( num < 2 num % 2 == 0 ) return num == 2 ; for ( int i = 3 ; i * i <= num ; i += 2 ) if ( num % i == 0 ) return false ; return true ; } int prime@@ Pal@@ ind@@ ro@@ me ( int N ) { if ( 8 <= N && N <= 11 ) return 11 ; for ( int x = 1 ; x < 100000 ; ++ x ) { string s = to_string ( x ) , r ( s . rbegin ( ) , s . rend ( ) ) ; int y = sto@@ i ( s + r . substr ( 1 ) ) ; if ( y >= N && is@@ Prime ( y ) ) return y ; } return -1 ; } int main ( ) { cout << prime@@ Pal@@ ind@@ ro@@ me ( 112 ) ; return 0 ; }
Hyper@@ factorial of a number 12294 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE #@@ include <@@ boost/@@ multip@@ reci@@ sion@@ /@@ cpp_@@ int@@ .@@ h@@ pp@@ > NEW_LINE using namespace boost :: multiprecision ; using namespace std ; int@@ 1024@@ _t boost_@@ hyper@@ factorial ( int num ) { int@@ 1024@@ _t val = 1 ; for ( int i = 1 ; i <= num ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { val *= i ; } } return val ; } int main ( ) { int num = 5 ; cout << boost_@@ hyper@@ factorial ( num ) ; return 0 ; }
Number of sub arrays with odd sum 12308 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ O@@ dd@@ Sum ( int ar [ ] , int n ) { int temp [ 2 ] = { 1 , 0 } ; int result = 0 , val = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { val = ( ( val + ar [ i ] ) % 2 + 2 ) % 2 ; temp [ val ] ++ ; } result = ( temp [ 0 ] * temp [ 1 ] ) ; return ( result ) ; } int main ( ) { int ar [ ] = { 5 , 4 , 4 , 5 , 1 , 3 } ; int n = sizeof ( ar ) / sizeof ( ar [ 0 ] ) ; cout << " The ▁ Number ▁ of ▁ Sub@@ arrays ▁ with ▁ odd " " ▁ sum ▁ is ▁ " << count@@ O@@ dd@@ Sum ( ar , n ) ; return ( 0 ) ; }
C@@ entered Hex@@ a@@ dec@@ ag@@ onal Number 12359 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int center_@@ hexa@@ dec@@ ag@@ on@@ al_@@ num ( long int n ) { return 8 * n * n - 8 * n + 1 ; } int main ( ) { long int n = 2 ; cout << n << " th ▁ centered ▁ hexa@@ dec@@ ag@@ onal ▁ number ▁ : ▁ " << center_@@ hexa@@ dec@@ ag@@ on@@ al_@@ num ( n ) ; cout << endl ; n = 12 ; cout << n << " th ▁ centered ▁ hexa@@ dec@@ ag@@ onal ▁ num@@ be ▁ : ▁ " << center_@@ hexa@@ dec@@ ag@@ on@@ al_@@ num ( n ) ; return 0 ; }
Program to compare m ^ n and n ^ m 12364 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void check ( unsigned long long m , unsigned long long int n ) { double RHS = m * ( double ) log ( n ) ; double LHS = n * ( double ) log ( m ) ; if ( LHS > RHS ) cout << " m ^ n ▁ > ▁ n ^ m " ; else if ( LHS < RHS ) cout << " m ^ n ▁ < ▁ n ^ m " ; else cout << " m ^ n ▁ = ▁ n ^ m " ; } int main ( ) { unsigned long long m = 987@@ 65432@@ 1 , n = 12345@@ 69@@ 87 ; check ( m , n ) ; return 0 ; }
Sum of series 1 * 1 * 2 ! + 2 * 2 * 3 ! + …@@ … . . + n * n * ( n + 1 ) ! 12394 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int factorial ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } int calculate@@ Series ( int n ) { return 2 + ( n * n + n - 2 ) * factorial ( n + 1 ) ; } int main ( ) { int n = 3 ; cout << calculate@@ Series ( n ) ; return 0 ; }
Sum of square 12408 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Sum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( ( i * ( i + 1 ) * ( 2 * i + 1 ) ) / 6 ) ; return sum ; } int main ( ) { int n = 3 ; cout << find@@ Sum ( n ) << endl ; return 0 ; }
Con@@ ne@@ ll Sequence 12476 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; vector < long long int > gen ( long long int n , vector < long long int > r ) { long long int a = r [ r . size ( ) - 1 ] ; a ++ ; for ( int i = 1 ; i <= n ; a += 2 , i ++ ) r . push_back ( a ) ; return r ; } vector < long long int > con@@ ell ( long long int n ) { vector < long long int > res ; long long int k = 1 ; res . push_back ( 0 ) ; while ( 1 ) { res = gen ( k , res ) ; k ++ ; int j = res . size ( ) - 1 ; while ( j != n && j + k > n ) k -- ; if ( j >= n ) break ; } res . erase ( res . begin ( ) ) ; return res ; } int main ( ) { long long int n = 10 ; cout << " The ▁ first ▁ " << n << " ▁ terms ▁ are " << endl ; vector < long long int > res = con@@ ell ( n ) ; for ( int i = 0 ; i < res . size ( ) ; i ++ ) cout << res [ i ] << " ▁ " ; cout << endl ; return 0 ; }
Ni@@ com@@ ach@@ u '@@ s The@@ o@@ rem 12507 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void Ni@@ com@@ achu@@ The@@ or@@ um_@@ sum ( int n ) { int sum = 0 ; for ( int k = 1 ; k <= n ; k ++ ) sum += k * k * k ; int tri@@ No = n * ( n + 1 ) / 2 ; if ( sum == tri@@ No * tri@@ No ) cout << " Yes " ; else cout << " No " ; } int main ( ) { int n = 5 ; Ni@@ com@@ achu@@ The@@ or@@ um_@@ sum ( n ) ; return 0 ; }
LC@@ M of factorial and its neighbors 12517 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; unsigned int factorial ( unsigned int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; } int LC@@ MO@@ f@@ Neigh@@ bour@@ Fact ( int n ) { return factorial ( n + 1 ) ; } int main ( ) { int N = 5 ; cout << LC@@ MO@@ f@@ Neigh@@ bour@@ Fact ( N ) << " STRNEWLINE " ; return 0 ; }
Check if a number is sand@@ wi@@ ch@@ ed between primes 12585 | #@@ include <@@ io@@ stream@@ > NEW_LINE #@@ include <@@ c@@ math@@ > NEW_LINE using namespace std ; bool is@@ Prime ( int n ) { if ( n == 0 n == 1 ) return false ; int root = sqrt ( n ) ; for ( int i = 2 ; i <= root ; i ++ ) if ( n % i == 0 ) return false ; return true ; } bool is@@ Sand@@ wit@@ ch@@ ed ( int n ) { return ( is@@ Prime ( n - 1 ) && is@@ Prime ( n + 1 ) ) ; } int main ( ) { int n = 64@@ 2 ; cout << n << " ▁ : ▁ " ; if ( is@@ Sand@@ wit@@ ch@@ ed ( n ) ) cout << " Yes STRNEWLINE " ; else cout << " No STRNEWLINE " ; n = 9 ; cout << n << " ▁ : ▁ " ; if ( is@@ Sand@@ wit@@ ch@@ ed ( n ) ) cout << " Yes STRNEWLINE " ; else cout << " No STRNEWLINE " ; return 0 ; }
Square Free Number 12592 | # include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Square@@ Free ( int n ) { if ( n % 2 == 0 ) n = n / 2 ; if ( n % 2 == 0 ) return false ; for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { n = n / i ; if ( n % i == 0 ) return false ; } } return true ; } int main ( ) { int n = 10 ; if ( is@@ Square@@ Free ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
Find sum of odd factors of a number 12683 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int su@@ mo@@ fo@@ dd@@ Factors ( int n ) { int res = 1 ; while ( n % 2 == 0 ) n = n / 2 ; for ( int i = 3 ; i <= sqrt ( n ) ; i ++ ) { int count = 0 , curr_@@ sum = 1 ; int curr_@@ term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; curr_@@ term *= i ; curr_@@ sum += curr_@@ term ; } res *= curr_@@ sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; } int main ( ) { int n = 30 ; cout << su@@ mo@@ fo@@ dd@@ Factors ( n ) ; return 0 ; }
Find sum of odd factors of a number 12684 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int count@@ Solutions ( int n , int val ) { int total = 0 ; if ( n == 1 && val >= 0 ) return 1 ; for ( int i = 0 ; i <= val ; i ++ ) { total += count@@ Solutions ( n - 1 , val - i ) ; } return total ; } int main ( ) { int n = 5 ; int val = 20 ; cout << count@@ Solutions ( n , val ) ; }
N@@ arc@@ is@@ sist@@ ic number 12778 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Digit ( int n ) { if ( n == 0 ) return 0 ; return 1 + count@@ Digit ( n / 10 ) ; } bool check ( int n ) { int l = count@@ Digit ( n ) ; int dup = n ; int sum = 0 ; while ( dup ) { sum += pow ( dup % 10 , l ) ; dup /= 10 ; } return ( n == sum ) ; } int main ( ) { int n = 16@@ 34 ; if ( check ( n ) ) cout << " yes " ; else cout << " no " ; return 0 ; }
Lar@@ gest number by which given 3 numbers should be divided such that they leaves same remainder 12819 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } int same@@ Remain@@ der ( int a , int b , int c ) { int a1 = ( b - a ) , b1 = ( c - b ) , c1 = ( c - a ) ; return gcd ( a1 , gcd ( b1 , c1 ) ) ; } int main ( ) { int a = 62 , b = 132 , c = 237 ; cout << same@@ Remain@@ der ( a , b , c ) << endl ; return 0 ; }
Lar@@ gest number less than N whose each digit is prime number 12913 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; char * Prime@@ Digit@@ Number ( char N [ ] , int size ) { char * ans = ( char * ) malloc ( size * sizeof ( char ) ) ; int ns = 0 ; int small = 0 ; int i ; int p [ ] = { 0 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 0 } ; int prev@@ prime [ ] = { 0 , 0 , 0 , 2 , 3 , 3 , 5 , 5 , 7 , 7 } ; if ( size == 1 ) { ans [ 0 ] = prev@@ prime [ N [ 0 ] - '0' ] + '0' ; ans [ 1 ] = ' \0' ; return ans ; } if ( N [ 0 ] == '1' ) { for ( int i = 0 ; i < size - 1 ; i ++ ) ans [ i ] = '7' ; ans [ size - 1 ] = ' \0' ; return ans ; } for ( i = 0 ; i < size && small == 0 ; i ++ ) { if ( p [ N [ i ] - '0' ] == 1 ) { ans [ ns ++ ] = N [ i ] ; } else { if ( p [ N [ i ] - '0' ] == 0 && prev@@ prime [ N [ i ] - '0' ] != 0 ) { ans [ ns ++ ] = prev@@ prime [ N [ i ] - '0' ] + '0' ; small = 1 ; } else if ( p [ N [ i ] - '0' ] == 0 && prev@@ prime [ N [ i ] - '0' ] == 0 ) { int j = i ; while ( j > 0 && p [ N [ j ] - '0' ] == 0 && prev@@ prime [ N [ j ] - '0' ] == 0 ) { ans [ j ] = N [ j ] = '7' ; N [ j - 1 ] = prev@@ prime [ N [ j - 1 ] - '0' ] + '0' ; ans [ j - 1 ] = N [ j - 1 ] ; small = 1 ; j -- ; } i = ns ; } } } if ( small == 0 ) { if ( prev@@ prime [ N [ size - 1 ] - '0' ] + '0' != '0' ) ans [ size - 1 ] = prev@@ prime [ N [ size - 1 ] - '0' ] + '0' ; else { int j = size - 1 ; while ( j > 0 && prev@@ prime [ N [ j ] - '0' ] == 0 ) { ans [ j ] = N [ j ] = '7' ; N [ j - 1 ] = prev@@ prime [ N [ j - 1 ] - '0' ] + '0' ; ans [ j - 1 ] = N [ j - 1 ] ; small = 1 ; j -- ; } } } for ( ; ns < size ; ns ++ ) ans [ ns ] = '7' ; ans [ ns ] = ' \0' ; int k = 0 ; while ( ans [ k ] == '0' ) k ++ ; return ans + k ; } int main ( ) { char N [ ] = "100@@ 0" ; int size = strlen ( N ) ; cout << Prime@@ Digit@@ Number ( N , size ) << endl ; return 0 ; }
Check if a number is power of k using base changing method 12932 | #@@ include <@@ io@@ stream@@ > NEW_LINE #@@ include <@@ algorithm@@ > NEW_LINE using namespace std ; bool is@@ PowerOf@@ K ( unsigned int n , unsigned int k ) { bool one@@ Seen = false ; while ( n > 0 ) { int digit = n % k ; if ( digit > 1 ) return false ; if ( digit == 1 ) { if ( one@@ Seen ) return false ; one@@ Seen = true ; } n /= k ; } return true ; } int main ( ) { int n = 64 , k = 4 ; if ( is@@ PowerOf@@ K ( n , k ) ) cout << " Yes " ; else cout << " No " ; }
Maximum sum of Bit@@ wise XOR of elements with their respective positions in a permutation of size N 10051 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int calc@@ Sc@@ r ( vector < int > arr ) { int ans = 0 ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) ans += ( i ^ arr [ i ] ) ; return ans ; } int getMax ( vector < int > arr , int ans , vector < bool > chosen , int N ) { if ( arr . size ( ) == N ) { ans = max ( ans , calc@@ Sc@@ r ( arr ) ) ; return ans ; } for ( int i = 0 ; i < N ; i ++ ) { if ( chosen [ i ] ) continue ; chosen [ i ] = true ; arr . push_back ( i ) ; ans = getMax ( arr , ans , chosen , N ) ; chosen [ i ] = false ; arr . pop_back ( ) ; } return ans ; } int main ( ) { int N = 2 ; vector < int > arr ; int ans = -1 ; vector < bool > chosen ( N , false ) ; ans = getMax ( arr , ans , chosen , N ) ; cout << ans << endl ; }
K di@@ stant prime pairs in a given range 10186 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ Prime@@ No@@ s ( int L , int R , unordered_map < int , int > & M ) { for ( int i = L ; i <= R ; i ++ ) { M [ i ] ++ ; } if ( M . find ( 1 ) != M . end ( ) ) { M . erase ( 1 ) ; } for ( int i = 2 ; i <= sqrt ( R ) ; i ++ ) { int multiple = 2 ; while ( ( i * multiple ) <= R ) { if ( M . find ( i * multiple ) != M . end ( ) ) { M . erase ( i * multiple ) ; } multiple ++ ; } } } void get@@ Prime@@ Pairs ( int L , int R , int K ) { unordered_map < int , int > M ; find@@ Prime@@ No@@ s ( L , R , M ) ; for ( auto & it : M ) { if ( M . find ( it . first + K ) != M . end ( ) ) { cout << " ( " << it . first << " , ▁ " << it . first + K << " ) ▁ " ; } } } int main ( ) { int L = 1 , R = 19 ; int K = 6 ; get@@ Prime@@ Pairs ( L , R , K ) ; return 0 ; }
655@@ 37 10473 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int gon@@ Num@@ 655@@ 37 ( int n ) { return ( 65535 * n * n - 655@@ 33 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << gon@@ Num@@ 655@@ 37 ( n ) ; return 0 ; }
Count pairs in an array such that the absolute difference between them is Ã@@ ƒ@@ Æ ’ Ã † â €@@ ™ Ã@@ ƒ@@ â € Ã ¢ â ‚@@ ¬ â „@@ ¢ Ã@@ ƒ@@ Æ ’ Ã ¢ â ‚@@ ¬ Ã@@ ƒ ¢ Ã ¢ â € š ¬ Ã ¢ â € ž ¢ Ã@@ ƒ@@ Æ ’ Ã † â €@@ ™ Ã@@ ƒ ¢ Ã ¢ â € š ¬ Ã@@ ƒ@@ Æ ’@@ ¢ Ã@@ ƒ ¢ Ã ¢ â ‚@@ ¬ Å ¡@@ ¬ Ã@@ ƒ ¢ Ã ¢ â ‚@@ ¬ Å ¾@@ ¢ Ã@@ ƒ@@ Æ ’ Ã † â €@@ ™ Ã@@ ƒ@@ â € Ã ¢ â ‚@@ ¬ â „@@ ¢ Ã@@ ƒ@@ Æ ’@@ ¢ Ã@@ ƒ ¢ Ã ¢ â ‚@@ ¬ Å ¡@@ ¬ Ã@@ ƒ@@ Æ ’ Ã † â €@@ ™@@ ¢ Ã@@ ƒ@@ Æ ’@@ ¢ Ã@@ ƒ ¢ Ã ¢ â € š ¬ Ã …@@ ¡@@ ¬ Ã@@ ƒ@@ Æ ’@@ ¢ Ã@@ ƒ ¢ Ã ¢ â € š ¬ Ã …@@ ¾@@ ¢@@ ¢ Ã@@ ƒ@@ Æ ’ Ã † â €@@ ™ Ã@@ ƒ@@ â € Ã ¢ â ‚@@ ¬ â „@@ ¢ Ã@@ ƒ@@ Æ ’ Ã ¢ â ‚@@ ¬ Ã@@ ƒ ¢ Ã ¢ â € š ¬ Ã ¢ â € ž ¢ Ã@@ ƒ@@ Æ ’ Ã † â €@@ ™ Ã@@ ƒ ¢ Ã ¢ â € š ¬ Ã@@ ƒ@@ Æ ’@@ ¢ Ã@@ ƒ ¢ Ã ¢ â ‚@@ ¬ Å ¡@@ ¬ Ã@@ ƒ ¢ Ã ¢ â ‚@@ ¬ Å ¾@@ ¢@@ ¢ Ã@@ ƒ@@ Æ ’ Ã † â €@@ ™ Ã@@ ƒ@@ â € Ã ¢ â ‚@@ ¬ â „@@ ¢ Ã@@ ƒ@@ Æ ’ Ã ¢ â ‚@@ ¬ Ã@@ ƒ ¢ Ã ¢ â € š ¬ Ã ¢ â € ž ¢@@ ¢ Ã@@ ƒ@@ Æ ’ Ã † â €@@ ™ Ã@@ ƒ@@ â € Ã ¢ â ‚@@ ¬ â „@@ ¢@@ ¢ Ã@@ ƒ@@ Æ ’ Ã † â €@@ ™@@ ¢ Ã@@ ƒ@@ Æ ’@@ ¢ Ã@@ ƒ ¢ Ã ¢ â ‚@@ ¬ Å ¡@@ ¬ Ã@@ ƒ@@ â €@@ ¦@@ ¡@@ ¬ Ã@@ ƒ@@ Æ ’ Ã † â €@@ ™ Ã@@ ƒ ¢ Ã ¢ â € š ¬@@ ¦@@ ¡@@ ¬@@ °@@ ¥ K 11337 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int cnt = 0 ; int i = 0 , j = 1 ; while ( i < n && j < n ) { j = ( j <= i ) ? ( i + 1 ) : j ; while ( j < n && ( arr [ j ] - arr [ i ] ) < k ) j ++ ; cnt += ( n - j ) ; i ++ ; } return cnt ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ; cout << count ( arr , n , k ) ; return 0 ; }
Find integers that divi@@ des maximum number of elements of the array 11690 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void maximum@@ Factor ( vector < int > arr ) { int n = arr . size ( ) ; vector < int > rank ; vector < int > factors ; int max = * max_@@ element ( arr . begin ( ) , arr . end ( ) ) ; for ( int i = 2 ; i <= max ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] % i == 0 ) count += 1 ; rank . push_back ( count ) ; factors . push_back ( i ) ; } } int m = * max_@@ element ( rank . begin ( ) , rank . end ( ) ) ; for ( int i = 0 ; i < rank . size ( ) ; i ++ ) { if ( rank [ i ] == m ) cout << factors [ i ] << " ▁ " ; } } int main ( ) { vector < int > arr = { 120 , 15 , 24 , 63 , 18 } ; maximum@@ Factor ( arr ) ; }
Sum of the multip@@ les of two numbers below N 11823 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int find@@ Sum ( int n , int a , int b ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( i % a == 0 i % b == 0 ) sum += i ; return sum ; } int main ( ) { int n = 10 , a = 3 , b = 5 ; cout << find@@ Sum ( n , a , b ) ; return 0 ; }
Medi@@ an 11831 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; double find@@ Medi@@ an ( int a [ ] , int n ) { sort ( a , a + n ) ; if ( n % 2 != 0 ) return ( double ) a [ n / 2 ] ; return ( double ) ( a [ ( n - 1 ) / 2 ] + a [ n / 2 ] ) / 2.0 ; } int main ( ) { int a [ ] = { 1 , 3 , 4 , 2 , 7 , 5 , 8 , 6 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << " Medi@@ an ▁ = ▁ " << find@@ Medi@@ an ( a , n ) << endl ; return 0 ; }
Program for C@@ entered I@@ co@@ sa@@ hedr@@ al Number 12405 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int cen@@ tered@@ I@@ co@@ sa@@ hedral@@ Num ( int n ) { return ( 2 * n + 1 ) * ( 5 * n * n + 5 * n + 3 ) / 3 ; } int main ( ) { int n = 10 ; cout << cen@@ tered@@ I@@ co@@ sa@@ hedral@@ Num ( n ) << endl ; n = 12 ; cout << cen@@ tered@@ I@@ co@@ sa@@ hedral@@ Num ( n ) << endl ; return 0 ; }
Do@@ dec@@ ag@@ onal number 12417 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int Do@@ dec@@ ag@@ on@@ al_@@ number ( int n ) { return 5 * n * n - 4 * n ; } int main ( ) { int n = 7 ; cout << Do@@ dec@@ ag@@ on@@ al_@@ number ( n ) << endl ; n = 12 ; cout << Do@@ dec@@ ag@@ on@@ al_@@ number ( n ) << endl ; return 0 ; }
Average of even numbers till a given even number 12639 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int average@@ Even ( int n ) { if ( n % 2 != 0 ) { cout << " Invalid ▁ Input " ; return -1 ; } return ( n + 2 ) / 2 ; } int main ( ) { int n = 16 ; cout << average@@ Even ( n ) << endl ; return 0 ; }
Find Harmon@@ ic mean using Arith@@ metic mean and Geo@@ metric mean 12817 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; double compute ( int a , int b ) { double AM , GM , H@@ M ; AM = ( a + b ) / 2 ; GM = sqrt ( a * b ) ; H@@ M = ( GM * GM ) / AM ; return H@@ M ; } int main ( ) { int a = 5 , b = 15 ; double H@@ M = compute ( a , b ) ; cout << " Harmon@@ ic ▁ Mean ▁ between ▁ " << a << " ▁ and ▁ " << b << " ▁ is ▁ " << H@@ M ; return 0 ; }
A product array pu@@ zzle | Set 2 ( O ( 1 ) Space ) 13033 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define EPS 1e-@@ 9 NEW_LINE void product@@ Pu@@ zzle ( int a [ ] , int n ) { long double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( long double ) log10 ( a [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) cout << ( int ) ( EPS + pow ( ( long double ) 10.@@ 00 , sum - log10 ( a [ i ] ) ) ) << " ▁ " ; } int main ( ) { int a [ ] = { 10 , 3 , 5 , 6 , 2 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << " The ▁ product ▁ array ▁ is : ▁ STRNEWLINE " ; product@@ Pu@@ zzle ( a , n ) ; return 0 ; }
P@@ ell Number 13054 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int p@@ ell ( int n ) { if ( n <= 2 ) return n ; return 2 * p@@ ell ( n - 1 ) + p@@ ell ( n - 2 ) ; } int main ( ) { int n = 4 ; cout << " ▁ " << p@@ ell ( n ) ; return 0 ; }
Find minimum value to assign all array elements so that array product becomes greater 13116 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE #@@ define ll long long NEW_LINE #@@ define ld long double NEW_LINE using namespace std ; ll find@@ Min@@ Value ( ll arr [ ] , ll n ) { sort ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) val += ( ld ) ( log ( ( ld ) ( arr [ i ] ) ) ) ; ll left = arr [ 0 ] , right = arr [ n - 1 ] + 1 ; ll ans ; while ( left <= right ) { ll mid = ( left + right ) / 2 ; ld temp = ( ld ) n * ( ld ) ( log ( ( ld ) ( mid ) ) ) ; if ( val < temp ) { ans = mid ; right = mid - 1 ; } else left = mid + 1 ; } return ans ; } int main ( ) { ll arr [ ] = { 4 , 2 , 1 , 10 , 6 } ; ll n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << find@@ Min@@ Value ( arr , n ) << endl ; return 0 ; }
Find other two sides of a right angle triangle 13135 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ Other@@ Si@@ des ( int n ) { if ( n & 1 ) { if ( n == 1 ) cout << -1 << endl ; else { int b = ( n * n - 1 ) / 2 ; int c = ( n * n + 1 ) / 2 ; cout << " b ▁ = ▁ " << b << " , ▁ c ▁ = ▁ " << c << endl ; } } else { if ( n == 2 ) cout << -1 << endl ; else { int b = n * n / 4 - 1 ; int c = n * n / 4 + 1 ; cout << " b ▁ = ▁ " << b << " , ▁ c ▁ = ▁ " << c << endl ; } } } int main ( ) { int a = 3 ; print@@ Other@@ Si@@ des ( a ) ; return 0 ; }
Sum of di@@ visors of factorial of a number 13140 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int fact ( int n ) { if ( n == 0 ) return 1 ; return n * fact ( n - 1 ) ; } int div ( int x ) { int ans = 0 ; for ( int i = 1 ; i <= x ; i ++ ) if ( x % i == 0 ) ans += i ; return ans ; } int sum@@ Fact@@ Div ( int n ) { return div ( fact ( n ) ) ; } int main ( ) { int n = 4 ; cout << sum@@ Fact@@ Div ( n ) ; }
Sum of di@@ visors of factorial of a number 13141 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE #@@ include <@@ math@@ .@@ h@@ > NEW_LINE using namespace std ; vector < int > all@@ Pri@@ mes ; void si@@ eve ( int n ) { vector < bool > prime ( n + 1 , true ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) all@@ Pri@@ mes . push_back ( p ) ; } int factor@@ ial@@ Di@@ visors ( int n ) { int result = 1 ; for ( int i = 0 ; i < all@@ Pri@@ mes . size ( ) ; i ++ ) { int p = all@@ Pri@@ mes [ i ] ; int exp = 0 ; while ( p <= n ) { exp = exp + ( n / p ) ; p = p * all@@ Pri@@ mes [ i ] ; } result = result * ( pow ( all@@ Pri@@ mes [ i ] , exp + 1 ) - 1 ) / ( all@@ Pri@@ mes [ i ] - 1 ) ; } return result ; } int main ( ) { cout << factor@@ ial@@ Di@@ visors ( 4 ) ; return 0 ; }
Pan@@ digital number in a given base 13179 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool check@@ Pan@@ digital ( int b , char n [ ] ) { if ( strlen ( n ) < b ) return false ; bool hash [ b ] ; memset ( hash , false , sizeof ( hash ) ) ; for ( int i = 0 ; i < strlen ( n ) ; i ++ ) { if ( n [ i ] >= '0' && n [ i ] <= '9' ) hash [ n [ i ] - '0' ] = true ; else if ( n [ i ] - ' A ' <= b - 11 ) hash [ n [ i ] - ' A ' + 10 ] = true ; } for ( int i = 0 ; i < b ; i ++ ) if ( hash [ i ] == false ) return false ; return true ; } int main ( ) { int b = 13 ; char n [ ] = "12@@ 98@@ 45@@ 03@@ 76@@ ABC " ; ( check@@ Pan@@ digital ( b , n ) ) ? ( cout << " Yes " << endl ) : ( cout << " No " << endl ) ; return 0 ; }
Number of occurrences of 2 as a digit in numbers from 0 to n 13188 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int numberOf@@ 2@@ sin@@ Range ( int n ) { string s = " " ; for ( int i = 0 ; i < n + 1 ; i ++ ) s += to_string ( i ) ; int count = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == '2' ) { count ++ ; } } return count ; } int main ( ) { int n = 30 ; cout << numberOf@@ 2@@ sin@@ Range ( n ) ; return 0 ; }
Find ways an Integer can be expressed as sum of n 13222 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int power ( int num , unsigned int n ) { if ( n == 0 ) return 1 ; else if ( n % 2 == 0 ) return power ( num , n / 2 ) * power ( num , n / 2 ) ; else return num * power ( num , n / 2 ) * power ( num , n / 2 ) ; } int check@@ Recursive ( int x , int n , int curr_@@ num = 1 , int curr_@@ sum = 0 ) { int results = 0 ; int p = power ( curr_@@ num , n ) ; while ( p + curr_@@ sum < x ) { results += check@@ Recursive ( x , n , curr_@@ num + 1 , p + curr_@@ sum ) ; curr_@@ num ++ ; p = power ( curr_@@ num , n ) ; } if ( p + curr_@@ sum == x ) results ++ ; return results ; } int main ( ) { int x = 10 , n = 2 ; cout << check@@ Recursive ( x , n ) ; return 0 ; }
Number The@@ ory | Gener@@ ators of finite cyclic group under addition 13225 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } int print@@ Gener@@ ators ( unsigned int n ) { cout << "1 ▁ " ; for ( int i = 2 ; i < n ; i ++ ) if ( gcd ( i , n ) == 1 ) cout << i << " ▁ " ; } int main ( ) { int n = 10 ; print@@ Gener@@ ators ( n ) ; return 0 ; }
Find sum of di@@ visors of all the di@@ visors of a natural number 13275 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int sum@@ Di@@ visor@@ sOf@@ Di@@ visors ( int n ) { map < int , int > mp ; for ( int j = 2 ; j <= sqrt ( n ) ; j ++ ) { int count = 0 ; while ( n % j == 0 ) { n /= j ; count ++ ; } if ( count ) mp [ j ] = count ; } if ( n != 1 ) mp [ n ] = 1 ; int ans = 1 ; for ( auto it : mp ) { int pw = 1 ; int sum = 0 ; for ( int i = it . second + 1 ; i >= 1 ; i -- ) { sum += ( i * pw ) ; pw *= it . first ; } ans *= sum ; } return ans ; } int main ( ) { int n = 10 ; cout << sum@@ Di@@ visor@@ sOf@@ Di@@ visors ( n ) ; return 0 ; }
Find sum of modulo K of first N natural number 13297 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Sum ( int N , int K ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) ans += ( i % K ) ; return ans ; } int main ( ) { int N = 10 , K = 2 ; cout << find@@ Sum ( N , K ) << endl ; return 0 ; }
Find Square Root under Modul@@ o p | Set 2 ( Sh@@ an@@ ks T@@ on@@ ell@@ i algorithm ) 13415 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int pow ( int base , int exponent , int modulus ) { int result = 1 ; base = base % modulus ; while ( exponent > 0 ) { if ( exponent % 2 == 1 ) result = ( result * base ) % modulus ; exponent = exponent >> 1 ; base = ( base * base ) % modulus ; } return result ; } int gcd ( int a , int b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; } int order ( int p , int b ) { if ( gcd ( p , b ) != 1 ) { printf ( " p ▁ and ▁ b ▁ are ▁ not ▁ co - prime . STRNEWLINE " ) ; return -1 ; } int k = 3 ; while ( 1 ) { if ( pow ( b , k , p ) == 1 ) return k ; k ++ ; } } int conver@@ tx@@ 2e ( int x , int & e ) { e = 0 ; while ( x % 2 == 0 ) { x /= 2 ; e ++ ; } return x ; } int ST@@ on@@ ell@@ i ( int n , int p ) { if ( gcd ( n , p ) != 1 ) { printf ( " a ▁ and ▁ p ▁ are ▁ not ▁ co@@ prime STRNEWLINE " ) ; return -1 ; } if ( pow ( n , ( p - 1 ) / 2 , p ) == ( p - 1 ) ) { printf ( " no ▁ sqrt ▁ possible STRNEWLINE " ) ; return -1 ; } int s , e ; s = conver@@ tx@@ 2e ( p - 1 , e ) ; int q ; for ( q = 2 ; ; q ++ ) { if ( pow ( q , ( p - 1 ) / 2 , p ) == ( p - 1 ) ) break ; } int x = pow ( n , ( s + 1 ) / 2 , p ) ; int b = pow ( n , s , p ) ; int g = pow ( q , s , p ) ; int r = e ; while ( 1 ) { int m ; for ( m = 0 ; m < r ; m ++ ) { if ( order ( p , b ) == -1 ) return -1 ; if ( order ( p , b ) == pow ( 2 , m ) ) break ; } if ( m == 0 ) return x ; x = ( x * pow ( g , pow ( 2 , r - m - 1 ) , p ) ) % p ; g = pow ( g , pow ( 2 , r - m ) , p ) ; b = ( b * g ) % p ; if ( b == 1 ) return x ; r = m ; } } int main ( ) { int n = 2 ; int p = 113 ; int x = ST@@ on@@ ell@@ i ( n , p ) ; if ( x == -1 ) printf ( " Mod@@ ular ▁ square ▁ root ▁ is ▁ not ▁ exist STRNEWLINE " ) ; else printf ( " Mod@@ ular ▁ square ▁ root ▁ of ▁ % d ▁ and ▁ % d ▁ is ▁ % d STRNEWLINE " , n , p , x ) ; }
Program to find the Roots of Quadrati@@ c equation 13418 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ Roots ( int a , int b , int c ) { if ( a == 0 ) { cout << " Invalid " ; return ; } int d = b * b - 4 * a * c ; double sq@@ rt_@@ val = sqrt ( abs ( d ) ) ; if ( d > 0 ) { cout << " Roots ▁ are ▁ real ▁ and ▁ different ▁ STRNEWLINE " ; cout << ( double ) ( - b + sq@@ rt_@@ val ) / ( 2 * a ) << " STRNEWLINE " << ( double ) ( - b - sq@@ rt_@@ val ) / ( 2 * a ) ; } else if ( d == 0 ) { cout << " Roots ▁ are ▁ real ▁ and ▁ same ▁ STRNEWLINE " ; cout << - ( double ) b / ( 2 * a ) ; } { cout << " Roots ▁ are ▁ complex ▁ STRNEWLINE " ; cout << - ( double ) b / ( 2 * a ) << " ▁ + ▁ i " << sq@@ rt_@@ val << " STRNEWLINE " << - ( double ) b / ( 2 * a ) << " ▁ - ▁ i " << sq@@ rt_@@ val ; } } int main ( ) { int a = 1 , b = -@@ 7 , c = 12 ; find@@ Roots ( a , b , c ) ; return 0 ; }
Find all di@@ visors of a natural number | Set 2 13429 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ Di@@ visors ( int n ) { vector < int > v ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) printf ( " % d ▁ " , i ) ; else { printf ( " % d ▁ " , i ) ; v . push_back ( n / i ) ; } } } for ( int i = v . size ( ) - 1 ; i >= 0 ; i -- ) printf ( " % d ▁ " , v [ i ] ) ; } int main ( ) { printf ( " The ▁ di@@ visors ▁ of ▁ 100 ▁ are : ▁ n " ) ; print@@ Di@@ visors ( 100 ) ; return 0 ; }
Find all factors of a natural number | Set 1 13431 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; void print@@ Di@@ visors ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) if ( n % i == 0 ) cout << " ▁ " << i ; } int main ( ) { cout << " The ▁ di@@ visors ▁ of ▁ 100 ▁ are : ▁ STRNEWLINE " ; print@@ Di@@ visors ( 100 ) ; return 0 ; }
Find all factors of a natural number | Set 1 13432 | #@@ include <@@ io@@ stream@@ > NEW_LINE #@@ include <@@ math@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ Di@@ visors ( int n ) { for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) cout << " ▁ " << i ; cout << " ▁ " << i << " ▁ " << n / i ; } } } int main ( ) { cout << " The ▁ di@@ visors ▁ of ▁ 100 ▁ are : ▁ STRNEWLINE " ; print@@ Di@@ visors ( 100 ) ; return 0 ; }
Sol@@ ving f ( n ) = ( 1 ) + ( 2 * 3 ) + ( 4 * 5 * 6 ) . . . n using Recur@@ sion 13443 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int series@@ Sum ( int calculated , int current , int N ) { int i , cur = 1 ; if ( current == N + 1 ) return 0 ; for ( i = calculated ; i < calculated + current ; i ++ ) cur *= i ; return cur + series@@ Sum ( i , current + 1 , N ) ; } int main ( ) { int N = 5 ; cout << series@@ Sum ( 1 , 1 , N ) << endl ; return 0 ; }
Compute n@@ Cr % p | Set 2 ( Lu@@ cas The@@ o@@ rem ) 13471 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int n@@ Cr@@ Mod@@ pD@@ P ( int n , int r , int p ) { int C [ r + 1 ] ; memset ( C , 0 , sizeof ( C ) ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = min ( i , r ) ; j > 0 ; j -- ) C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p ; } return C [ r ] ; } int n@@ Cr@@ Mod@@ p@@ Lu@@ cas ( int n , int r , int p ) { if ( r == 0 ) return 1 ; int ni = n % p , ri = r % p ; } int main ( ) { int n = 1000 , r = 900 , p = 13 ; cout << " Value ▁ of ▁ n@@ Cr ▁ % ▁ p ▁ is ▁ " << n@@ Cr@@ Mod@@ p@@ Lu@@ cas ( n , r , p ) ; return 0 ; }
Mod@@ ular multiplic@@ ative inverse 13511 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int mod@@ Inverse ( int a , int m ) { int m0 = m ; int y = 0 , x = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { int q = a / m ; int t = m ; m = a % m , a = t ; t = y ; y = x - q * y ; x = t ; } if ( x < 0 ) x += m0 ; return x ; } int main ( ) { int a = 3 , m = 11 ; cout << " Mod@@ ular ▁ multiplic@@ ative ▁ inverse ▁ is ▁ " << mod@@ Inverse ( a , m ) ; return 0 ; }
Eu@@ ler '@@ s To@@ ti@@ ent Function 13513 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } int phi ( unsigned int n ) { unsigned int result = 1 ; for ( int i = 2 ; i < n ; i ++ ) if ( gcd ( i , n ) == 1 ) result ++ ; return result ; } int main ( ) { int n ; for ( n = 1 ; n <= 10 ; n ++ ) cout << " phi ( " << n << " ) ▁ = ▁ " << phi ( n ) << endl ; return 0 ; }
Program to print first n Fi@@ bon@@ ac@@ ci Numbers | Set 1 13539 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ Fi@@ bon@@ ac@@ ci@@ Numbers ( int n ) { int f1 = 0 , f2 = 1 , i ; if ( n < 1 ) return ; cout << f1 << " ▁ " ; for ( i = 1 ; i < n ; i ++ ) { cout << f2 << " ▁ " ; int next = f1 + f2 ; f1 = f2 ; f2 = next ; } } int main ( ) { print@@ Fi@@ bon@@ ac@@ ci@@ Numbers ( 7 ) ; return 0 ; }
Program to find LC@@ M of two numbers 13544 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; long long gcd ( long long int a , long long int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } long long l@@ cm ( int a , int b ) { return ( a / gcd ( a , b ) ) * b ; } int main ( ) { int a = 15 , b = 20 ; cout << " LC@@ M ▁ of ▁ " << a << " ▁ and ▁ " << b << " ▁ is ▁ " << l@@ cm ( a , b ) ; return 0 ; }
Check if a number is multiple of 5 without using / and % operators 13565 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; # define MAX 11 NEW_LINE bool is@@ Multiple@@ of@@ 5 ( int n ) { char str [ MAX ] ; int len = strlen ( str ) ; if ( str [ len - 1 ] == '5' str [ len - 1 ] == '0' ) return true ; return false ; } int main ( ) { int n = 19 ; if ( is@@ Multiple@@ of@@ 5 ( n ) == true ) cout << n << " ▁ is ▁ multiple ▁ of ▁ 5" << endl ; else cout << n << " ▁ is ▁ not ▁ multiple ▁ of ▁ 5" << endl ; return 0 ; }
Write a program to reverse digits of a number 13575 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int rever@@ s@@ Digits ( int num ) { static int rev_@@ num = 0 ; static int base_@@ pos = 1 ; if ( num > 0 ) { rever@@ s@@ Digits ( num / 10 ) ; rev_@@ num += ( num % 10 ) * base_@@ pos ; base_@@ pos *= 10 ; } return rev_@@ num ; } int main ( ) { int num = 45@@ 62 ; cout << " Reverse ▁ of ▁ no . ▁ is ▁ " << rever@@ s@@ Digits ( num ) ; return 0 ; }
Modify a matrix by converting each element to XOR of its digits 13586 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; const int M = 3 ; const int N = 3 ; int find@@ XOR ( int X ) { int ans = 0 ; while ( X ) { ans ^= ( X % 10 ) ; X /= 10 ; } return ans ; } void print@@ X@@ OR@@ matrix ( int arr [ M ] [ N ] ) { for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { cout << arr [ i ] [ j ] << " ▁ " ; } cout << " STRNEWLINE " ; } } void convert@@ XOR ( int arr [ M ] [ N ] ) { for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int X = arr [ i ] [ j ] ; int temp = find@@ XOR ( X ) ; arr [ i ] [ j ] = temp ; } } print@@ X@@ OR@@ matrix ( arr ) ; } int main ( ) { int arr [ ] [ 3 ] = { { 27 , 173 , 5 } , { 21 , 6 , 6@@ 24 } , { 5 , 321 , 49 } } ; convert@@ XOR ( arr ) ; return 0 ; }
All about Bit Manip@@ ulation 13589 | int set@@ Bit ( int num , int i ) { return num | ( 1 << i ) ; }
Sum of Bit@@ wise OR of every array element paired with all other array elements 13598 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ OR@@ Sum@@ forEach@@ Element ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int req_@@ sum = 0 ; for ( int j = 0 ; j < N ; j ++ ) { req_@@ sum += ( arr [ i ] arr [ j ] ) ; } cout << req_@@ sum << " ▁ " ; } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; print@@ OR@@ Sum@@ forEach@@ Element ( arr , N ) ; return 0 ; }
Lar@@ gest number in the Array having frequency same as value 13630 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Largest@@ Number ( vector < int > & arr ) { for ( auto n : arr ) { n &= 0xFFFF ; if ( n <= arr . size ( ) ) { arr [ n - 1 ] += 0x10000 ; } } for ( auto i = arr . size ( ) ; i > 0 ; -- i ) { if ( ( arr [ i - 1 ] >> 16 ) == i ) return i ; } return -1 ; } int main ( ) { vector < int > arr = { 3 , 2 , 5 , 5 , 2 , 4 , 5 } ; cout << find@@ Largest@@ Number ( arr ) << endl ; return 0 ; }
Find a number such that maximum in array is minimum possible after XOR 13633 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int Recursive@@ Function ( vector < int > ref , int bit ) { if ( ref . size ( ) == 0 bit < 0 ) return 0 ; vector < int > curr_@@ on , curr_@@ off ; for ( int i = 0 ; i < ref . size ( ) ; i ++ ) { if ( ( ( ref [ i ] >> bit ) & 1 ) == 0 ) curr_@@ off . push_back ( ref [ i ] ) ; else curr_@@ on . push_back ( ref [ i ] ) ; } if ( curr_@@ off . size ( ) == 0 ) return Recursive@@ Function ( curr_@@ on , bit - 1 ) ; if ( curr_@@ on . size ( ) == 0 ) return Recursive@@ Function ( curr_@@ off , bit - 1 ) ; return min ( Recursive@@ Function ( curr_@@ off , bit - 1 ) , Recursive@@ Function ( curr_@@ on , bit - 1 ) ) + ( 1 << bit ) ; } void Print@@ Minimum ( int a [ ] , int n ) { vector < int > v ; for ( int i = 0 ; i < n ; i ++ ) v . push_back ( a [ i ] ) ; cout << Recursive@@ Function ( v , 30 ) << " STRNEWLINE " ; } int main ( ) { int arr [ ] = { 3 , 2 , 1 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; Print@@ Minimum ( arr , size ) ; return 0 ; }
XOR of all Prime numbers in an Array at positions di@@ visible by K 13643 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define MAX 10000@@ 05 NEW_LINE void Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( vector < bool > & prime ) { prime [ 1 ] = false ; prime [ 0 ] = false ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } } void pri@@ me_@@ xor ( int arr [ ] , int n , int k ) { vector < bool > prime ( MAX , true ) ; Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( prime ) ; long long int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { if ( ( i + 1 ) % k == 0 ) { ans ^= arr [ i ] ; } } } cout << ans << endl ; } int main ( ) { int arr [ ] = { 2 , 3 , 5 , 7 , 11 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 2 ; pri@@ me_@@ xor ( arr , n , K ) ; return 0 ; }
Count of numbers which can be made power of 2 by given operation 13712 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ PowerOf@@ Two ( int x ) { if ( x == 0 ) return false ; if ( ! ( x & ( x - 1 ) ) ) return true ; else return false ; } int count@@ Num ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( is@@ PowerOf@@ Two ( a [ i ] ) || is@@ PowerOf@@ Two ( a [ i ] + 1 ) ) count ++ ; } return count ; } int main ( ) { int arr [ ] = { 5 , 6 , 9 , 3 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << count@@ Num ( arr , n ) ; return 0 ; }
XOR of all elements of array with set bits equal to K 13727 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int xor@@ Given@@ Set@@ Bits ( int arr [ ] , int n , int k ) { vector < int > v ; for ( int i = 0 ; i < n ; i ++ ) { if ( __builtin@@ _pop@@ count ( arr [ i ] ) == k ) { v . push_back ( arr [ i ] ) ; } } int result = v [ 0 ] ; for ( int i = 1 ; i < v . size ( ) ; i ++ ) result = result ^ v [ i ] ; return result ; } int main ( ) { int arr [ ] = { 2 , 13 , 1 , 19 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; cout << xor@@ Given@@ Set@@ Bits ( arr , n , k ) ; return 0 ; }
Number of leading zeros in binary representation of a given number 13735 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Zeros ( int x ) { unsigned y ; int n = 32 ; y = x >> 16 ; if ( y != 0 ) { n = n - 16 ; x = y ; } y = x >> 8 ; if ( y != 0 ) { n = n - 8 ; x = y ; } y = x >> 4 ; if ( y != 0 ) { n = n - 4 ; x = y ; } y = x >> 2 ; if ( y != 0 ) { n = n - 2 ; x = y ; } y = x >> 1 ; if ( y != 0 ) return n - 2 ; return n - x ; } int main ( ) { int x = 101 ; cout << count@@ Zeros ( x ) ; return 0 ; }
Count pairs with Bit@@ wise OR as Even number 13776 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int find@@ Even@@ Pair ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( ! ( A [ i ] & 1 ) ) count ++ ; return count * ( count - 1 ) / 2 ; } int main ( ) { int A [ ] = { 5 , 6 , 2 , 8 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << find@@ Even@@ Pair ( A , N ) << endl ; return 0 ; }
Le@@ f@@ to@@ ver element after performing alternate Bit@@ wise OR and Bit@@ wise XOR operations on adjacent pairs 13826 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define N 1000 NEW_LINE int last@@ Element ( int a [ ] , int n ) { int steps = 1 ; vector < int > v [ N ] ; if ( n == 1 ) return a [ 0 ] ; for ( int i = 0 ; i < n ; i += 2 ) v [ steps ] . push_back ( a [ i ] a [ i + 1 ] ) ; while ( v [ steps ] . size ( ) > 1 ) { steps += 1 ; for ( int i = 0 ; i < v [ steps - 1 ] . size ( ) ; i += 2 ) { if ( steps & 1 ) v [ steps ] . push_back ( v [ steps - 1 ] [ i ] v [ steps - 1 ] [ i + 1 ] ) ; v [ steps ] . push_back ( v [ steps - 1 ] [ i ] ^ v [ steps - 1 ] [ i + 1 ] ) ; } } return v [ steps ] [ 0 ] ; } int main ( ) { int a [ ] = { 1 , 4 , 5 , 6 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int index = 0 ; int value = 2 ; a [ 0 ] = 2 ; cout << last@@ Element ( a , n ) << endl ; index = 3 ; value = 5 ; a [ index ] = value ; cout << last@@ Element ( a , n ) << endl ; return 0 ; }
XN@@ OR of two numbers 13858 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int x@@ nor ( int a , int b ) { if ( a < b ) swap ( a , b ) ; if ( a == 0 && b == 0 ) return 1 ; int a_@@ rem = 0 ; int b_@@ rem = 0 ; int count = 0 ; int x@@ nor@@ num = 0 ; while ( a ) { a_@@ rem = a & 1 ; b_@@ rem = b & 1 ; if ( a_@@ rem == b_@@ rem ) x@@ nor@@ num |= ( 1 << count ) ; count ++ ; a = a >> 1 ; b = b >> 1 ; } return x@@ nor@@ num ; } int main ( ) { int a = 10 , b = 50 ; cout << x@@ nor ( a , b ) ; return 0 ; }
Quo@@ ti@@ ent and remainder divid@@ ing by 2 ^ k ( a power of 2 ) 13870 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void divide ( int n , int m ) { cout << " Remain@@ der ▁ = ▁ " << ( ( n ) & ( m - 1 ) ) ; cout << " Quo@@ ti@@ ent = " } int main ( ) { int n = 43 , m = 8 ; divide ( n , m ) ; return 0 ; }
Check if one of the numbers is one '@@ s complement of the other 13885 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool are@@ All@@ Bits@@ Set ( unsigned int n ) { if ( n == 0 ) return false ; if ( ( ( n + 1 ) & n ) == 0 ) return true ; return false ; } bool is@@ One@@ s@@ Comp@@ lement@@ Of@@ Other ( unsigned int a , unsigned int b ) { return are@@ All@@ Bits@@ Set ( a ^ b ) ; } int main ( ) { unsigned int a = 10 , b = 5 ; if ( is@@ One@@ s@@ Comp@@ lement@@ Of@@ Other ( a , b ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
Count total bits in a number 13895 | #@@ include <@@ io@@ stream@@ > NEW_LINE #@@ include <@@ c@@ math@@ > NEW_LINE unsigned count@@ Bits ( unsigned int number ) { return ( int ) log2 ( number ) + 1 ; } int main ( ) { unsigned int num = 65 ; std :: cout << count@@ Bits ( num ) << ' ' ; return 0 ; }
Extract ' k ' bits from a given position in a number . 13915 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int bit@@ Extr@@ acted ( int number , int k , int p ) { return ( ( ( 1 << k ) - 1 ) & ( number >> ( p - 1 ) ) ) ; } int main ( ) { int number = 171 , k = 5 , p = 2 ; cout << " The ▁ extracted ▁ number ▁ is ▁ " << bit@@ Extr@@ acted ( number , k , p ) ; return 0 ; }
W@@ ays to represent a number as a sum of 1 ' s ▁ and ▁ 2' s 13965 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void multiply ( int F [ 2 ] [ 2 ] , int M [ 2 ] [ 2 ] ) { int x = F [ 0 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 0 ] ; int y = F [ 0 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 1 ] ; int z = F [ 1 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 0 ] ; int w = F [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] ; F [ 0 ] [ 0 ] = x ; F [ 0 ] [ 1 ] = y ; F [ 1 ] [ 0 ] = z ; F [ 1 ] [ 1 ] = w ; } void power ( int F [ 2 ] [ 2 ] , int n ) { if ( n == 0 n == 1 ) return ; int M [ 2 ] [ 2 ] = { { 1 , 1 } , { 1 , 0 } } ; power ( F , n / 2 ) ; multiply ( F , F ) ; if ( n % 2 != 0 ) multiply ( F , M ) ; } int count@@ W@@ ays ( int n ) { int F [ 2 ] [ 2 ] = { { 1 , 1 } , { 1 , 0 } } ; if ( n == 0 ) return 0 ; power ( F , n ) ; return F [ 0 ] [ 0 ] ; } int main ( ) { int n = 5 ; cout << count@@ W@@ ays ( n ) << endl ; return 0 ; }
XOR counts of 0 s and 1 s in binary representation 13976 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int count@@ XOR ( int n ) { int count@@ 0 = 0 , count@@ 1 = 0 ; while ( n ) { ( n % 2 == 0 ) ? count@@ 0 ++ : count@@ 1 ++ ; n /= 2 ; } return ( count@@ 0 ^ count@@ 1 ) ; } int main ( ) { int n = 31 ; cout << count@@ XOR ( n ) ; return 0 ; }
Equal Sum and XOR 13985 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int count@@ Values ( int n ) { int count@@ V = 0 ; for ( int i = 0 ; i <= n ; i ++ ) if ( ( n + i ) == ( n ^ i ) ) count@@ V ++ ; return count@@ V ; } int main ( ) { int n = 12 ; cout << count@@ Values ( n ) ; return 0 ; }
Calculate 7 n / 8 without using division and multiplication operators 14020 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int multiply@@ By@@ Se@@ ven@@ By@@ E@@ ight ( int n ) { return ( n - ( n >> 3 ) ) ; } int main ( ) { int n = 9 ; cout << multiply@@ By@@ Se@@ ven@@ By@@ E@@ ight ( n ) ; return 0 ; }
Maximum length pal@@ ind@@ ro@@ mic substring for every index such that it starts and ends at that index 3051 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Pal@@ ind@@ ro@@ me ( string S , int i , int j ) { while ( i < j ) { if ( S [ i ] != S [ j ] ) return false ; i ++ ; j -- ; } return true ; } void print@@ Lon@@ gest@@ Pal@@ ind@@ ro@@ me ( string S , int N ) { int pal@@ Length [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { int maxlength = 1 ; for ( int j = 0 ; j < i ; j ++ ) { if ( S [ j ] == S [ i ] ) { if ( is@@ Pal@@ ind@@ ro@@ me ( S , j , i ) ) { maxlength = i - j + 1 ; break ; } } } for ( int j = N - 1 ; j > i ; j -- ) { if ( S [ j ] == S [ i ] ) { if ( is@@ Pal@@ ind@@ ro@@ me ( S , i , j ) ) { maxlength = max ( j - i + 1 , maxlength ) ; break ; } } } pal@@ Length [ i ] = maxlength ; } for ( int i = 0 ; i < N ; i ++ ) { cout << pal@@ Length [ i ] << " ▁ " ; } } int main ( ) { string S = " bab@@ aba " ; int N = S . length ( ) ; print@@ Lon@@ gest@@ Pal@@ ind@@ ro@@ me ( S , N ) ; return 0 ; }
Check if array can be sorted with one swap 3944 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool check@@ Sorted ( int n , int arr [ ] ) { int b [ n ] ; for ( int i = 0 ; i < n ; i ++ ) b [ i ] = arr [ i ] ; sort ( b , b + n ) ; int ct = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != b [ i ] ) ct ++ ; if ( ct == 0 ct == 2 ) return true ; else return false ; } int main ( ) { int arr [ ] = { 1 , 5 , 3 , 4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( check@@ Sorted ( n , arr ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
Making elements distinct in a sorted array by minimum increments 4066 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int min@@ Sum ( int arr [ ] , int n ) { int sum = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) { int j = i ; while ( j < n && arr [ j ] <= arr [ j - 1 ] ) { arr [ j ] = arr [ j ] + 1 ; j ++ ; } } sum = sum + arr [ i ] ; } return sum ; } int main ( ) { int arr [ ] = { 2 , 2 , 3 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << min@@ Sum ( arr , n ) << endl ; return 0 ; }
Making elements distinct in a sorted array by minimum increments 4067 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int min@@ Sum ( int arr [ ] , int n ) { int sum = arr [ 0 ] , prev = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] <= prev ) { prev = prev + 1 ; sum = sum + prev ; } else { sum = sum + arr [ i ] ; prev = arr [ i ] ; } } return sum ; } int main ( ) { int arr [ ] = { 2 , 2 , 3 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << min@@ Sum ( arr , n ) << endl ; return 0 ; }
Count of distinct permutation of a String obtained by sw@@ apping only un@@ equal characters 4916 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int valid@@ Per@@ mutations ( string str ) { unordered_map < char , int > m ; int count = str . length ( ) , ans = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { m [ str [ i ] ] ++ ; } for ( int i = 0 ; i < str . length ( ) ; i ++ ) { ans += count - m [ str [ i ] ] ; m [ str [ i ] ] -- ; count -- ; } return ans + 1 ; } int main ( ) { string str = " sst@@ t " ; cout << valid@@ Per@@ mutations ( str ) ; return 0 ; }
Sorting array with reverse around middle 5766 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool if@@ Possible ( int arr [ ] , int n ) { int cp [ n ] ; copy ( arr , arr + n , cp ) ; sort ( cp , cp + n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! ( arr [ i ] == cp [ i ] ) && ! ( arr [ n - 1 - i ] == cp [ i ] ) ) return false ; } return true ; } int main ( ) { int arr [ ] = { 1 , 7 , 6 , 4 , 5 , 3 , 2 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( if@@ Possible ( arr , n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
Count of numbers between range having only non 6490 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; const int M = 20 ; int dp [ M ] [ 165 ] [ M ] [ 2 ] ; int n , m ; int count ( int pos , int sum , int rem , int ti@@ ght , int non@@ z , vector < int > num ) { if ( pos == num . size ( ) ) { if ( rem == 0 && sum == n ) return 1 ; return 0 ; } if ( dp [ pos ] [ sum ] [ rem ] [ ti@@ ght ] != -1 ) return dp [ pos ] [ sum ] [ rem ] [ ti@@ ght ] ; int ans = 0 ; int limit = ( ti@@ ght ? 9 : num [ pos ] ) ; for ( int d = 0 ; d <= limit ; d ++ ) { if ( d == 0 && non@@ z ) continue ; int curr@@ Sum = sum + d ; int curr@@ Rem = ( rem * 10 + d ) % m ; int curr@@ F = ti@@ ght || ( d < num [ pos ] ) ; ans += count ( pos + 1 , curr@@ Sum , curr@@ Rem , curr@@ F , non@@ z d , num ) ; } return dp [ pos ] [ sum ] [ rem ] [ ti@@ ght ] = ans ; } int solve ( int x ) { vector < int > num ; while ( x ) { num . push_back ( x % 10 ) ; x /= 10 ; } reverse ( num . begin ( ) , num . end ( ) ) ; memset ( dp , -1 , sizeof ( dp ) ) ; return count ( 0 , 0 , 0 , 0 , 0 , num ) ; } int main ( ) { int L = 1 , R = 100 ; n = 8 , m = 2 ; cout << solve ( R ) - solve ( L ) ; return 0 ; }
Maximum sub@@ array sum in O ( n ) using prefix sum 6682 | #@@ include <@@ io@@ stream@@ > NEW_LINE #@@ include <@@ limit@@ s@@ > NEW_LINE using namespace std ; int maximum@@ Sum@@ Sub@@ array ( int arr [ ] , int n ) { int min_@@ prefix_@@ sum = 0 ; int res = numeric_limits < int > :: min ( ) ; int prefix_@@ sum [ n ] ; prefix_@@ sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix_@@ sum [ i ] = prefix_@@ sum [ i - 1 ] + arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { res = max ( res , prefix_@@ sum [ i ] - min_@@ prefix_@@ sum ) ; min_@@ prefix_@@ sum = min ( min_@@ prefix_@@ sum , prefix_@@ sum [ i ] ) ; } return res ; } int main ( ) { int ar@@ r1 [ ] = { -2 , -@@ 3 , 4 , -1 , -2 , 1 , 5 , -@@ 3 } ; int n1 = sizeof ( ar@@ r1 ) / sizeof ( ar@@ r1 [ 0 ] ) ; cout << maximum@@ Sum@@ Sub@@ array ( ar@@ r1 , n1 ) << endl ; int ar@@ r2 [ ] = { 4 , -@@ 8 , 9 , -@@ 4 , 1 , -@@ 8 , -1 , 6 } ; int n2 = sizeof ( ar@@ r2 ) / sizeof ( ar@@ r2 [ 0 ] ) ; cout << maximum@@ Sum@@ Sub@@ array ( ar@@ r2 , n2 ) ; return 0 ; }
Counts paths from a point to reach Origin 6792 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Paths ( int n , int m ) { int dp [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; return dp [ n ] [ m ] ; } int main ( ) { int n = 3 , m = 2 ; cout << " ▁ Number ▁ of ▁ Paths ▁ " << count@@ Paths ( n , m ) ; return 0 ; }
How to solve a Dynamic Programming Problem ? 6837 | int dp [ MAX@@ N ] ; int solve ( int n ) { if ( n < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( dp [ n ] != -1 ) return dp [ n ] ; return dp [ n ] = solve ( n - 1 ) + solve ( n - 3 ) + solve ( n - 5 ) ; }
Printing Shor@@ test Common Super@@ sequence 6940 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; string print@@ Shor@@ test@@ Super@@ Seq ( string X , string Y ) { int m = X . length ( ) ; int n = Y . length ( ) ; int dp [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i ] [ j ] = j ; else if ( j == 0 ) dp [ i ] [ j ] = i ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } string str ; int i = m , j = n ; while ( i > 0 && j > 0 ) { if ( X [ i - 1 ] == Y [ j - 1 ] ) { str . push_back ( X [ i - 1 ] ) ; i -- , j -- ; } else if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j - 1 ] ) { str . push_back ( Y [ j - 1 ] ) ; j -- ; } else { str . push_back ( X [ i - 1 ] ) ; i -- ; } } while ( i > 0 ) { str . push_back ( X [ i - 1 ] ) ; i -- ; } while ( j > 0 ) { str . push_back ( Y [ j - 1 ] ) ; j -- ; } reverse ( str . begin ( ) , str . end ( ) ) ; return str ; } int main ( ) { string X = " AGG@@ TAB " ; string Y = " GX@@ TX@@ AY@@ B " ; cout << print@@ Shor@@ test@@ Super@@ Seq ( X , Y ) ; return 0 ; }
Printing Shor@@ test Common Super@@ sequence 7070 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int Matrix@@ Chain@@ Order ( int p [ ] , int n ) { int m [ n ] [ n ] ; int i , j , k , L , q ; for ( i = 1 ; i < n ; i ++ ) m [ i ] [ i ] = 0 ; for ( L = 2 ; L < n ; L ++ ) { for ( i = 1 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; m [ i ] [ j ] = INT_MAX ; for ( k = i ; k <= j - 1 ; k ++ ) { q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( q < m [ i ] [ j ] ) m [ i ] [ j ] = q ; } } } return m [ 1 ] [ n - 1 ] ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Minimum ▁ number ▁ of ▁ multiplic@@ ations ▁ is ▁ " << Matrix@@ Chain@@ Order ( arr , size ) ; get@@ char ( ) ; return 0 ; }
Coin Change | DP 7071 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count ( int S [ ] , int m , int n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 0 ; if ( m <= 0 && n >= 1 ) return 0 ; return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; } int main ( ) { int i , j ; int arr [ ] = { 1 , 2 , 3 } ; int m = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " ▁ " << count ( arr , m , 4 ) ; return 0 ; }
Find the count of sub@@ strings in alphabe@@ tic order 8070 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Sub@@ string@@ Count ( string str ) { int result = 0 ; int n = str . size ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( str [ i ] + 1 == str [ i + 1 ] ) { result ++ ; while ( str [ i ] + 1 == str [ i + 1 ] ) { i ++ ; } } } return result ; } int main ( ) { string str = " alphabet " ; cout << find@@ Sub@@ string@@ Count ( str ) << endl ; return 0 ; }
Round the given number to nearest multiple of 10 8348 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int round ( int n ) { int a = ( n / 10 ) * 10 ; int b = a + 10 ; return ( n - a > b - n ) ? b : a ; } int main ( ) { int n = 47@@ 22 ; cout << round ( n ) << endl ; return 0 ; }
Encrypt string with product of number of vo@@ w@@ els and con@@ son@@ ants in substring of size k 8366 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Vo@@ wel ( char c ) { return ( c == ' a ' c == ' e ' c == ' i ' c == ' o ' c == ' u ' ) ; } string encrypt@@ String ( string s , int n , int k ) { int count@@ Vo@@ w@@ els = 0 ; int count@@ Con@@ son@@ ants = 0 ; string ans = " " ; for ( int l = 0 ; l <= n - k ; l ++ ) { count@@ Vo@@ w@@ els = 0 ; count@@ Con@@ son@@ ants = 0 ; for ( int r = l ; r <= l + k - 1 ; r ++ ) { if ( is@@ Vo@@ wel ( s [ r ] ) == true ) count@@ Vo@@ w@@ els ++ ; else count@@ Con@@ son@@ ants ++ ; } ans += to_string ( count@@ Vo@@ w@@ els * count@@ Con@@ son@@ ants ) ; } return ans ; } int main ( ) { string s = " hello " ; int n = s . length ( ) ; int k = 2 ; cout << encrypt@@ String ( s , n , k ) << endl ; return 0 ; }
Ham@@ ming Distance between two strings 8624 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int ham@@ ming@@ Dist ( char * str1 , char * str2 ) { int i = 0 , count = 0 ; while ( str1 [ i ] != ' \0' ) { if ( str1 [ i ] != str2 [ i ] ) count ++ ; i ++ ; } return count ; } int main ( ) { char str1 [ ] = " ge@@ ek@@ spr@@ acti@@ ce " ; char str2 [ ] = " ner@@ d@@ spr@@ acti@@ se " ; cout << ham@@ ming@@ Dist ( str1 , str2 ) ; return 0 ; }
Program to find volume and surface area of pent@@ ag@@ onal pri@@ sm 9311 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; float surface@@ Area ( float a , float b , float h ) { return 5 * a * b + 5 * b * h ; } float volume ( float b , float h ) { return ( 5 * b * h ) / 2 ; } int main ( ) { float a = 5 ; float b = 3 ; float h = 7 ; cout << " surface ▁ area = ▁ " << surface@@ Area ( a , b , h ) << " , ▁ " ; cout << " volume = ▁ " << volume ( b , h ) ; }
Maxim@@ ize 3 rd element sum in quad@@ rup@@ let sets formed from given Array 2746 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int form@@ Quad@@ rup@@ lets ( int arr [ ] , int n ) { int ans = 0 , pairs = 0 ; pairs = n / 4 ; sort ( arr , arr + n , greater < int > ( ) ) ; for ( int i = 0 ; i < n - pairs ; i += 3 ) { ans += arr [ i + 2 ] ; } return ans ; } int main ( ) { int arr [ ] = { 2 , 1 , 7 , 5 , 5 , 4 , 1 , 1 , 3 , 3 , 2 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << form@@ Quad@@ rup@@ lets ( arr , n ) << endl ; return 0 ; }
Maxim@@ ize X such that sum of numbers in range [ 1 , X ] is at most K 2915 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int Count ( int N , int K ) { if ( K == 0 ) return 0 ; int res = 0 ; int low = 1 , high = N ; while ( low <= high ) { int mid = ( low + high ) / 2 ; int sum = ( mid * mid + mid ) / 2 ; if ( sum <= K ) { res = max ( res , mid ) ; low = mid + 1 ; } else { high = mid - 1 ; } } return res ; } int main ( ) { int N = 6 , K = 14 ; cout << Count ( N , K ) ; return 0 ; }
Maximum elements that can be removed from front of two arrays such that their sum is at most K 2947 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void max@@ Items ( int n , int m , int a [ ] , int b [ ] , int K ) { int count = 0 ; int A [ n + 1 ] ; int B [ m + 1 ] ; A [ 0 ] = 0 ; B [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { A [ i ] = a [ i - 1 ] + A [ i - 1 ] ; } for ( int i = 1 ; i <= m ; i ++ ) { B [ i ] = b [ i - 1 ] + B [ i - 1 ] ; } for ( int i = 0 ; i <= n ; i ++ ) { if ( A [ i ] > K ) break ; int rem = K - A [ i ] ; int j = 0 ; int lo = 0 , hi = m ; while ( lo <= hi ) { int mid = ( lo + hi ) / 2 ; if ( B [ mid ] <= rem ) { j = mid ; lo = mid + 1 ; } else { hi = mid - 1 ; } } count = max ( j + i , count ) ; } cout << count ; } int main ( ) { int n = 4 , m = 5 , K = 7 ; int A [ n ] = { 2 , 4 , 7 , 3 } ; int B [ m ] = { 1 , 9 , 3 , 4 , 5 } ; max@@ Items ( n , m , A , B , K ) ; return 0 ; }
Number which is co 2965 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Prime ( int N ) { if ( N == 1 ) return false ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) return false ; } return true ; } int find@@ Co@@ Prime ( int L , int R ) { int co@@ Prime ; for ( int i = R + 1 ; ; i ++ ) { if ( is@@ Prime ( i ) ) { co@@ Prime = i ; break ; } } return co@@ Prime ; } int main ( ) { int L = 16 , R = 17 ; cout << find@@ Co@@ Prime ( L , R ) ; return 0 ; }
Frequency of lex@@ ico@@ graphic@@ ally K@@ th smallest character in the a string 3062 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void K@@ th@@ Character ( string S , int N , int K ) { char str@@ array [ N + 1 ] ; strcpy ( str@@ array , S . c_str ( ) ) ; sort ( str@@ array , str@@ array + N ) ; char ch = str@@ array [ K - 1 ] ; int count = 0 ; for ( auto c : str@@ array ) { if ( c == ch ) count ++ ; } cout << count ; } int main ( ) { string S = " ge@@ ek@@ s@@ forge@@ e@@ ks " ; int N = S . length ( ) ; int K = 3 ; K@@ th@@ Character ( S , N , K ) ; return 0 ; }
Lon@@ gest substring with no pair of adjacent characters are adjacent English alphab@@ ets 3063 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ Sub@@ string ( string S ) { string T = " " ; string ans = " " ; int l = 0 ; T += S [ 0 ] ; for ( int i = 1 ; i < S . length ( ) ; i ++ ) { if ( abs ( S [ i ] - S [ i - 1 ] ) == 1 ) { l = T . length ( ) ; if ( l > ans . length ( ) ) { ans = T ; } T = " " ; T += S [ i ] ; } else { T += S [ i ] ; } } l = ( int ) T . length ( ) ; if ( l > ( int ) ans . length ( ) ) { ans = T ; } cout << ans << endl ; } int main ( ) { string S = " a@@ ab@@ d@@ ml " ; find@@ Sub@@ string ( S ) ; return 0 ; }
Count array elements whose all distinct digits appear in K 3113 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; static int noOf@@ Valid@@ K@@ bers ( int K , vector < int > arr ) { map < int , int > set ; while ( K != 0 ) { set [ K % 10 ] = 1 ; K = K / 10 ; } int count = 0 ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { int no = arr [ i ] ; bool flag = true ; while ( no != 0 ) { int digit = no % 10 ; if ( set . find ( digit ) == set . end ( ) ) { flag = false ; break ; } no = no / 10 ; } if ( flag == true ) { count ++ ; } } return count ; } int main ( ) { int K = 12 ; vector < int > arr = { 1 , 12 , 12@@ 22 , 13 , 2 } ; cout << ( noOf@@ Valid@@ K@@ bers ( K , arr ) ) ; }
S@@ malle@@ st divisor of N closest to X 3129 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define MAX 10000 NEW_LINE vector < vector < int > > di@@ visors ( MAX + 1 ) ; void compute@@ Di@@ visors ( ) { for ( int i = 1 ; i <= MAX ; i ++ ) { for ( int j = i ; j <= MAX ; j += i ) { di@@ visors [ j ] . push_back ( i ) ; } } } int get@@ Close@@ st ( int val1 , int val2 , int target ) { if ( target - val1 >= val2 - target ) return val2 ; else return val1 ; } int find@@ Close@@ st ( vector < int > & arr , int n , int target ) { if ( target <= arr [ 0 ] ) return arr [ 0 ] ; if ( target >= arr [ n - 1 ] ) return arr [ n - 1 ] ; int i = 0 , j = n , mid = 0 ; while ( i < j ) { mid = ( i + j ) / 2 ; if ( arr [ mid ] == target ) return arr [ mid ] ; if ( target < arr [ mid ] ) { if ( mid > 0 && target > arr [ mid - 1 ] ) return get@@ Close@@ st ( arr [ mid - 1 ] , arr [ mid ] , target ) ; j = mid ; } else { if ( mid < n - 1 && target < arr [ mid + 1 ] ) return get@@ Close@@ st ( arr [ mid ] , arr [ mid + 1 ] , target ) ; i = mid + 1 ; } } return arr [ mid ] ; } void print@@ Close@@ st ( int N , int X ) { compute@@ Di@@ visors ( ) ; int ans = find@@ Close@@ st ( di@@ visors [ N ] , di@@ visors [ N ] . size ( ) , X ) ; cout << ans ; } int main ( ) { int N = 16 , X = 5 ; print@@ Close@@ st ( N , X ) ; }
Count maximum concatenation of pairs from given array that are di@@ visible by 3 3161 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Div ( int arr [ ] , int n ) { int rem@@ 0 = 0 ; int re@@ m1 = 0 ; int re@@ m2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int digit@@ Sum = 0 ; digit@@ Sum += arr [ i ] ; if ( digit@@ Sum % 3 == 0 ) { rem@@ 0 += 1 ; } else if ( digit@@ Sum % 3 == 1 ) { re@@ m1 += 1 ; } else { re@@ m2 += 1 ; } } return ( rem@@ 0 / 2 + min ( re@@ m1 , re@@ m2 ) ) ; } int main ( ) { int arr [ ] = { 5 , 3 , 2 , 8 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ( count@@ Div ( arr , n ) ) ; }
Count array elements whose product of digits is a Composite Number 3245 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE #@@ include <@@ set@@ > NEW_LINE using namespace std ; #@@ define N 10000@@ 5 NEW_LINE void Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( bool prime [ ] , int p_@@ size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_@@ size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_@@ size ; i += p ) prime [ i ] = false ; } } } long long int digit@@ Product ( int number ) { long long int res = 1 ; while ( number > 0 ) { res *= ( number % 10 ) ; number /= 10 ; } return res ; } void Distinct@@ Composite@@ Digit@@ Product ( int arr [ ] , int n ) { set < int > output ; bool prime [ N + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( prime , N ) ; for ( int i = 0 ; i < n ; i ++ ) { long long int ans = digit@@ Product ( arr [ i ] ) ; if ( ans <= 1 ) { continue ; } if ( ! prime [ ans ] ) { output . insert ( ans ) ; } } cout << output . size ( ) << endl ; } int main ( ) { int arr [ ] = { 13 , 55 , 7 , 13 , 11 , 71 , 233 , 233 , 144 , 89 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; Distinct@@ Composite@@ Digit@@ Product ( arr , n ) ; return 0 ; }
Count pairs from a given range whose sum is a Prime Number in that range 3246 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void simple@@ Si@@ eve ( int l@@ mt , vector < int > & prime ) { bool Si@@ eve [ l@@ mt + 1 ] ; memset ( Si@@ eve , true , sizeof ( Si@@ eve ) ) ; Si@@ eve [ 0 ] = Si@@ eve [ 1 ] = false ; for ( int i = 2 ; i <= l@@ mt ; ++ i ) { if ( Si@@ eve [ i ] == true ) { prime . push_back ( i ) ; for ( int j = i * i ; j <= l@@ mt ; j += i ) { Si@@ eve [ j ] = false ; } } } } vector < bool > Seg@@ mented@@ Si@@ eve@@ Fn ( int low , int high ) { int l@@ mt = floor ( sqrt ( high ) ) + 1 ; vector < int > prime ; simple@@ Si@@ eve ( l@@ mt , prime ) ; int n = high - low + 1 ; vector < bool > seg@@ mented@@ Si@@ eve ( n + 1 , true ) ; for ( int i = 0 ; i < prime . size ( ) ; i ++ ) { int low@@ Li@@ m = floor ( low / prime [ i ] ) * prime [ i ] ; if ( low@@ Li@@ m < low ) { low@@ Li@@ m += prime [ i ] ; } for ( int j = low@@ Li@@ m ; j <= high ; j += prime [ i ] ) { if ( j != prime [ i ] ) { seg@@ mented@@ Si@@ eve [ j - low ] = false ; } } } return seg@@ mented@@ Si@@ eve ; } int count@@ Pai@@ rs@@ W@@ ho@@ se@@ Sum@@ Prime@@ L_@@ R ( int L , int R ) { vector < bool > seg@@ mented@@ Si@@ eve = Seg@@ mented@@ Si@@ eve@@ Fn ( L , R ) ; int cnt@@ Pairs = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( seg@@ mented@@ Si@@ eve [ i - L ] ) { cnt@@ Pairs += i / 2 ; } } return cnt@@ Pairs ; } int main ( ) { int L = 1 , R = 5 ; cout << count@@ Pai@@ rs@@ W@@ ho@@ se@@ Sum@@ Prime@@ L_@@ R ( L , R ) ; return 0 ; }
Count quad@@ rup@@ les of given type from given array 3255 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; const int max@@ N = 2002 ; int count@@ Sub@@ sequ@@ ec@@ e ( int a [ ] , int n ) { int i , j , k , l ; int answer = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { for ( k = j + 1 ; k < n ; k ++ ) { for ( l = k + 1 ; l < n ; l ++ ) { if ( a [ j ] == a [ l ] && a [ i ] == a [ k ] ) { answer ++ ; } } } } } return answer ; } int main ( ) { int a [ 7 ] = { 1 , 2 , 3 , 2 , 1 , 3 , 2 } ; cout << count@@ Sub@@ sequ@@ ec@@ e ( a , 7 ) ; return 0 ; }
Minim@@ ize sum of prime numbers added to make an array non 3463 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define MAX 10000000 NEW_LINE bool is@@ Prime [ MAX ] ; vector < int > primes ; void Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( ) { memset ( is@@ Prime , true , sizeof ( is@@ Prime ) ) ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( is@@ Prime [ p ] == true ) { for ( int i = p * p ; i <= MAX ; i += p ) is@@ Prime [ i ] = false ; } } for ( int p = 2 ; p <= MAX ; p ++ ) if ( is@@ Prime [ p ] ) primes . push_back ( p ) ; } int pri@@ me_@@ search ( vector < int > primes , int diff ) { int low = 0 ; int high = primes . size ( ) - 1 ; int res ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( primes [ mid ] == diff ) { return primes [ mid ] ; } else if ( primes [ mid ] < diff ) { low = mid + 1 ; } else { res = primes [ mid ] ; high = mid - 1 ; } } return res ; } int min@@ Cost ( int arr [ ] , int n ) { Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( ) ; int res = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { int diff = arr [ i - 1 ] - arr [ i ] ; int closest_@@ prime = pri@@ me_@@ search ( primes , diff ) ; res += closest_@@ prime ; arr [ i ] += closest_@@ prime ; } } return res ; } int main ( ) { int arr [ ] = { 2 , 1 , 5 , 4 , 3 } ; int n = 5 ; cout << min@@ Cost ( arr , n ) ; return 0 ; }
S@@ malle@@ st character in a string having minimum sum of distances between consecutive repeti@@ tions 3491 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; char min@@ Dist@@ Char ( string s ) { int n = s . length ( ) ; int * first = new int [ 26 ] ; int * last = new int [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { first [ i ] = -1 ; last [ i ] = -1 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( first [ s [ i ] - ' a ' ] == -1 ) { first [ s [ i ] - ' a ' ] = i ; } last [ s [ i ] - ' a ' ] = i ; } int min = INT_MAX ; char ans = '1' ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( last [ i ] == first [ i ] ) continue ; if ( min > last [ i ] - first [ i ] ) { min = last [ i ] - first [ i ] ; ans = i + ' a ' ; } } return ans ; } int main ( ) { string str = " ge@@ ek@@ s@@ forge@@ e@@ ks " ; cout << min@@ Dist@@ Char ( str ) ; return 0 ; }
Check if an array contains only one distinct element 3543 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void unique@@ Element ( int arr [ ] , int n ) { unordered_@@ set < int > set ; for ( int i = 0 ; i < n ; i ++ ) { set . insert ( arr [ i ] ) ; } if ( set . size ( ) == 1 ) { cout << " YES " << endl ; } else { cout << " NO " << endl ; } } int main ( ) { int arr [ ] = { 9 , 9 , 9 , 9 , 9 , 9 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; unique@@ Element ( arr , n ) ; return 0 ; }
Count of Root to Leaf Paths consisting of at most M consecutive Nodes having value K 3603 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; vector < int > adj [ 10000@@ 5 ] ; int visited [ 10000@@ 5 ] = { 0 } ; int ans = 0 ; void dfs ( int node , int count , int m , int arr [ ] , int k ) { visited [ node ] = 1 ; if ( arr [ node - 1 ] == k ) { count ++ ; } else { count = 0 ; } if ( count > m ) { return ; } if ( adj [ node ] . size ( ) == 1 && node != 1 ) { ans ++ ; } for ( auto x : adj [ node ] ) { if ( ! visited [ x ] ) { dfs ( x , count , m , arr , k ) ; } } } int main ( ) { int arr [ ] = { 2 , 1 , 3 , 2 , 1 , 2 , 1 } ; int N = 7 , K = 2 , M = 2 ; adj [ 1 ] . push_back ( 2 ) ; adj [ 2 ] . push_back ( 1 ) ; adj [ 1 ] . push_back ( 3 ) ; adj [ 3 ] . push_back ( 1 ) ; adj [ 2 ] . push_back ( 4 ) ; adj [ 4 ] . push_back ( 2 ) ; adj [ 2 ] . push_back ( 5 ) ; adj [ 5 ] . push_back ( 2 ) ; adj [ 3 ] . push_back ( 6 ) ; adj [ 6 ] . push_back ( 3 ) ; adj [ 3 ] . push_back ( 7 ) ; adj [ 7 ] . push_back ( 3 ) ; int counter = 0 ; dfs ( 1 , counter , M , arr , K ) ; cout << ans << " STRNEWLINE " ; return 0 ; }
Distance Tr@@ ave@@ led by Two Tra@@ ins together in the same Direction 3621 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int calc_@@ distance ( int A [ ] , int B [ ] , int n ) { int distance_@@ tr@@ ave@@ led_@@ A = 0 ; int distance_@@ tr@@ ave@@ led_@@ B = 0 ; int answer = 0 ; for ( int i = 0 ; i < 5 ; i ++ ) { distance_@@ tr@@ ave@@ led_@@ A += A [ i ] ; distance_@@ tr@@ ave@@ led_@@ B += B [ i ] ; if ( ( distance_@@ tr@@ ave@@ led_@@ A == distance_@@ tr@@ ave@@ led_@@ B ) && ( A [ i ] == B [ i ] ) ) { answer += A [ i ] ; } } return answer ; } int main ( ) { int A [ 5 ] = { 1 , 2 , 3 , 2 , 4 } ; int B [ 5 ] = { 2 , 1 , 3 , 1 , 4 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << calc_@@ distance ( A , B , N ) ; return 0 ; }
Find a pair in Array with second largest product 3633 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void max@@ Product ( int arr [ ] , int N ) { if ( N < 3 ) { return ; } int a = arr [ 0 ] , b = arr [ 1 ] ; int c = 0 , d = 0 ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] * arr [ j ] > a * b ) { c = a , d = b ; a = arr [ i ] , b = arr [ j ] ; } if ( arr [ i ] * arr [ j ] < a * b && arr [ i ] * arr [ j ] > c * d ) c = arr [ i ] , d = arr [ j ] ; } cout << c << " ▁ " << d ; } int main ( ) { int arr [ ] = { 5 , 2 , 67 , 45 , 160 , 78 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; max@@ Product ( arr , N ) ; return 0 ; }
Find largest factor of N such that N / F is less than K 3715 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ Max@@ Value ( int N , int K ) { int packages ; int max@@ i = 1 ; for ( int i = 1 ; i <= K ; i ++ ) { if ( N % i == 0 ) max@@ i = max ( max@@ i , i ) ; } packages = N / max@@ i ; cout << packages << endl ; } int main ( ) { int N = 8 , K = 7 ; find@@ Max@@ Value ( N , K ) ; return 0 ; }
Maxim@@ ize number of groups formed with size not smaller than its largest element 3760 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void make@@ Groups ( int a [ ] , int n ) { vector < int > v ( n + 1 , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { v [ a [ i ] ] ++ ; } int no_@@ of_@@ groups = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { no_@@ of_@@ groups += v [ i ] / i ; v [ i ] = v [ i ] % i ; } int i = 1 ; int total = 0 ; for ( i = 1 ; i <= n ; i ++ ) { if ( v [ i ] != 0 ) { total = v [ i ] ; break ; } } i ++ ; while ( i <= n ) { if ( v [ i ] != 0 ) { total += v [ i ] ; if ( total >= i ) { int rem = total - i ; no_@@ of_@@ groups ++ ; total = rem ; } } i ++ ; } cout << no_@@ of_@@ groups << " STRNEWLINE " ; } int main ( ) { int arr [ ] = { 2 , 3 , 1 , 2 , 2 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; make@@ Groups ( arr , size ) ; return 0 ; }
Maximum size of square such that all sub@@ matrices of that size have sum less than K 3797 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define N 4 NEW_LINE #@@ define M 5 NEW_LINE void pre@@ Process ( int mat [ N ] [ M ] , int aux [ N ] [ M ] ) { for ( int i = 0 ; i < M ; i ++ ) aux [ 0 ] [ i ] = mat [ 0 ] [ i ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) aux [ i ] [ j ] = mat [ i ] [ j ] + aux [ i - 1 ] [ j ] ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 1 ; j < M ; j ++ ) aux [ i ] [ j ] += aux [ i ] [ j - 1 ] ; } int sum@@ Query ( int aux [ N ] [ M ] , int t@@ li , int tl@@ j , int rb@@ i , int rb@@ j ) { int res = aux [ rb@@ i ] [ rb@@ j ] ; if ( t@@ li > 0 ) res = res - aux [ t@@ li - 1 ] [ rb@@ j ] ; if ( tl@@ j > 0 ) res = res - aux [ rb@@ i ] [ tl@@ j - 1 ] ; if ( t@@ li > 0 && tl@@ j > 0 ) res = res + aux [ t@@ li - 1 ] [ tl@@ j - 1 ] ; return res ; } bool check ( int mid , int aux [ N ] [ M ] , int K ) { bool satis@@ fies = true ; for ( int x = 0 ; x < N ; x ++ ) { for ( int y = 0 ; y < M ; y ++ ) { if ( x + mid - 1 <= N - 1 && y + mid - 1 <= M - 1 ) { if ( sum@@ Query ( aux , x , y , x + mid - 1 , y + mid - 1 ) > K ) satis@@ fies = false ; } } } return ( satis@@ fies == true ) ; } int maximum@@ Square@@ Size ( int mat [ N ] [ M ] , int K ) { int aux [ N ] [ M ] ; pre@@ Process ( mat , aux ) ; int low = 1 , high = min ( N , M ) ; int mid ; while ( high - low > 1 ) { mid = ( low + high ) / 2 ; if ( check ( mid , aux , K ) ) { low = mid ; } else high = mid ; } if ( check ( high , aux , K ) ) return high ; return low ; } int main ( ) { int K = 30 ; int mat [ N ] [ M ] = { { 1 , 2 , 3 , 4 , 6 } , { 5 , 3 , 8 , 1 , 2 } , { 4 , 6 , 7 , 5 , 5 } , { 2 , 4 , 8 , 9 , 4 } } ; cout << maximum@@ Square@@ Size ( mat , K ) ; return 0 ; }
Lon@@ gest sub 3850 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ Sub@@ Array ( int arr [ ] , int n ) { int sum = 0 ; int maxsize = -1 , start@@ index ; for ( int i = 0 ; i < n ; i ++ ) { if ( is@@ alpha ( arr [ i ] ) ) { arr [ i ] = 0 ; } else { arr [ i ] = 1 ; } } for ( int i = 0 ; i < n - 1 ; i ++ ) { sum = ( arr [ i ] == 0 ) ? -1 : 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { ( arr [ j ] == 0 ) ? ( sum += -1 ) : ( sum += 1 ) ; if ( sum == 0 && maxsize < j - i + 1 ) { maxsize = j - i + 1 ; start@@ index = i ; } } } if ( maxsize == -1 ) cout << maxsize ; else cout << start@@ index << " ▁ " << ( start@@ index + maxsize - 1 ) ; } int main ( ) { int arr [ ] = { ' A ' , ' B ' , ' X ' , 4 , 6 , ' X ' , ' a ' } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; find@@ Sub@@ Array ( arr , size ) ; return 0 ; }
Minimum steps required to reach the end of a matrix | Set 2 3875 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE #@@ define n 3 NEW_LINE using namespace std ; int min@@ Steps ( int arr [ ] [ n ] ) { bool v [ n ] [ n ] = { 0 } ; queue < pair < int , int > > q ; q . push ( { 0 , 0 } ) ; int depth = 0 ; while ( q . size ( ) != 0 ) { int x = q . size ( ) ; while ( x -- ) { pair < int , int > y = q . front ( ) ; int i = y . first , j = y . second ; q . pop ( ) ; if ( v [ i ] [ j ] ) continue ; if ( i == n - 1 && j == n - 1 ) return depth ; v [ i ] [ j ] = 1 ; if ( i + arr [ i ] [ j ] < n ) q . push ( { i + arr [ i ] [ j ] , j } ) ; if ( j + arr [ i ] [ j ] < n ) q . push ( { i , j + arr [ i ] [ j ] } ) ; } depth ++ ; } return -1 ; } int main ( ) { int arr [ n ] [ n ] = { { 1 , 1 , 1 } , { 1 , 1 , 1 } , { 1 , 1 , 1 } } ; cout << min@@ Steps ( arr ) ; return 0 ; }
Inte@@ gers from the range that are composed of a single distinct digit 3930 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool check@@ Distin@@ ct ( int x ) { int last = x % 10 ; while ( x ) { if ( x % 10 != last ) return false ; x = x / 10 ; } return true ; } int find@@ Count ( int L , int R ) { int count = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( check@@ Distin@@ ct ( i ) ) count += 1 ; } return count ; } int main ( ) { int L = 10 , R = 50 ; cout << find@@ Count ( L , R ) ; return 0 ; }
Lower Insertion Point 3932 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int Lower@@ Insertion@@ Point ( int arr [ ] , int n , int X ) { if ( X < arr [ 0 ] ) return 0 ; else if ( X > arr [ n - 1 ] ) return n ; int lower@@ Pnt = 0 ; int i = 1 ; while ( i < n && arr [ i ] < X ) { lower@@ Pnt = i ; i = i * 2 ; } while ( lower@@ Pnt < n && arr [ lower@@ Pnt ] < X ) lower@@ Pnt ++ ; return lower@@ Pnt ; } int main ( ) { int arr [ ] = { 2 , 3 , 4 , 4 , 5 , 6 , 7 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int X = 4 ; cout << Lower@@ Insertion@@ Point ( arr , n , X ) ; return 0 ; }
Check if a string contains a pal@@ ind@@ ro@@ mic sub 3961 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool check ( string s ) { for ( int i = 0 ; i < s . length ( ) - 1 ; i ++ ) if ( s [ i ] == s [ i + 1 ] ) return true ; return false ; } int main ( ) { string s = " x@@ z@@ yy@@ z " ; if ( check ( s ) ) cout << " YES " << endl ; else cout << " NO " << endl ; return 0 ; }
Number of anomal@@ ies in an array 3973 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int count@@ Ano@@ mal@@ ies ( int arr [ ] , int n , int k ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && abs ( arr [ i ] - arr [ j ] ) <= k ) break ; if ( j == n ) res ++ ; } return res ; } int main ( ) { int arr [ ] = { 7 , 1 , 8 } , k = 5 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << count@@ Ano@@ mal@@ ies ( arr , n , k ) ; return 0 ; }
Find pair with maximum difference in any column of a Matrix 3986 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int col@@ Max@@ Diff ( int mat [ N ] [ N ] ) { int max_@@ diff = INT_@@ MIN ; for ( int i = 0 ; i < N ; i ++ ) { int max_@@ val = mat [ 0 ] [ i ] , min_@@ val = mat [ 0 ] [ i ] ; for ( int j = 1 ; j < N ; j ++ ) { max_@@ val = max ( max_@@ val , mat [ j ] [ i ] ) ; min_@@ val = min ( min_@@ val , mat [ j ] [ i ] ) ; } max_@@ diff = max ( max_@@ diff , max_@@ val - min_@@ val ) ; } return max_@@ diff ; } int main ( ) { int mat [ N ] [ N ] = { { 1 , 2 , 3 , 4 , 5 } , { 5 , 3 , 5 , 4 , 0 } , { 5 , 6 , 7 , 8 , 9 } , { 0 , 6 , 3 , 4 , 12 } , { 9 , 7 , 12 , 4 , 3 } , } ; cout << " Max ▁ difference ▁ : ▁ " << col@@ Max@@ Diff ( mat ) << endl ; return 0 ; }
Find the only missing number in a sorted array 4014 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int find@@ missing ( int ar [ ] , int N ) { int l = 0 , r = N - 1 ; while ( l <= r ) { int mid = ( l + r ) / 2 ; if ( ar [ mid ] != mid + 1 && ar [ mid - 1 ] == mid ) return mid + 1 ; if ( ar [ mid ] != mid + 1 ) r = mid - 1 ; else l = mid + 1 ; } return -1 ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 7 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << find@@ missing ( arr , N ) ; return 0 ; }
Lar@@ gest gap in an array 4033 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int solve ( int a [ ] , int n ) { int max@@ 1 = INT_@@ MIN ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( abs ( a [ i ] - a [ j ] ) > max@@ 1 ) { max@@ 1 = abs ( a [ i ] - a [ j ] ) ; } } } return max@@ 1 ; } int main ( ) { int arr [ ] = { -1 , 2 , 3 , -@@ 4 , -@@ 10 , 22 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Lar@@ gest ▁ gap ▁ is ▁ : ▁ " << solve ( arr , size ) ; return 0 ; }
Maximum product quad@@ r@@ uple ( sub 4037 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max@@ Product ( int arr [ ] , int n ) { if ( n < 4 ) return -1 ; int max@@ A = INT_@@ MIN , max@@ B = INT_@@ MIN , max@@ C = INT_@@ MIN , max@@ D = INT_@@ MIN ; int min@@ A = INT_MAX , min@@ B = INT_MAX , min@@ C = INT_MAX , min@@ D = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max@@ A ) { max@@ D = max@@ C ; max@@ C = max@@ B ; max@@ B = max@@ A ; max@@ A = arr [ i ] ; } else if ( arr [ i ] > max@@ B ) { max@@ D = max@@ C ; max@@ C = max@@ B ; max@@ B = arr [ i ] ; } else if ( arr [ i ] > max@@ C ) { max@@ D = max@@ C ; max@@ C = arr [ i ] ; } else if ( arr [ i ] > max@@ D ) max@@ D = arr [ i ] ; if ( arr [ i ] < min@@ A ) { min@@ D = min@@ C ; min@@ C = min@@ B ; min@@ B = min@@ A ; min@@ A = arr [ i ] ; } else if ( arr [ i ] < min@@ B ) { min@@ D = min@@ C ; min@@ C = min@@ B ; min@@ B = arr [ i ] ; } else if ( arr [ i ] < min@@ C ) { min@@ D = min@@ C ; min@@ C = arr [ i ] ; } else if ( arr [ i ] < min@@ D ) min@@ D = arr [ i ] ; } int x = max@@ A * max@@ B * max@@ C * max@@ D ; int y = min@@ A * min@@ B * min@@ C * min@@ D ; int z = min@@ A * min@@ B * max@@ A * max@@ B ; return max ( x , max ( y , z ) ) ; } int main ( ) { int arr [ ] = { 1 , -@@ 4 , 3 , -@@ 6 , 7 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int max = max@@ Product ( arr , n ) ; if ( max == -1 ) cout << " No ▁ Quad@@ r@@ uple ▁ Exists " ; else cout << " Maximum ▁ product ▁ is ▁ " << max ; return 0 ; }
Modify a given matrix by pl@@ acing sorted boundary elements in clockwise manner 4162 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ Matrix ( vector < vector < int > > a ) { for ( auto x : a ) { for ( auto y : x ) { cout << y << " ▁ " ; } cout << " STRNEWLINE " ; } } void sort@@ Boundary@@ W@@ ise ( vector < vector < int > > a ) { int i , k = 0 , l = 0 ; int m = a . size ( ) , n = a [ 0 ] . size ( ) ; int n_@@ i , n_@@ k = 0 , n_@@ l = 0 , n_@@ m = m , n_@@ n = n ; while ( k < m && l < n ) { vector < int > boundary ; for ( i = l ; i < n ; ++ i ) { boundary . push_back ( a [ k ] [ i ] ) ; } k ++ ; for ( i = k ; i < m ; ++ i ) { boundary . push_back ( a [ i ] [ n - 1 ] ) ; } n -- ; if ( k < m ) { for ( i = n - 1 ; i >= l ; -- i ) { boundary . push_back ( a [ m - 1 ] [ i ] ) ; } m -- ; } if ( l < n ) { for ( i = m - 1 ; i >= k ; -- i ) { boundary . push_back ( a [ i ] [ l ] ) ; } l ++ ; } sort ( boundary . begin ( ) , boundary . end ( ) ) ; int ind = 0 ; for ( i = n_@@ l ; i < n_@@ n ; ++ i ) { a [ n_@@ k ] [ i ] = boundary [ ind ++ ] ; } n_@@ k ++ ; for ( i = n_@@ k ; i < n_@@ m ; ++ i ) { a [ i ] [ n_@@ n - 1 ] = boundary [ ind ++ ] ; } n_@@ n -- ; if ( n_@@ k < n_@@ m ) { for ( i = n_@@ n - 1 ; i >= n_@@ l ; -- i ) { a [ n_@@ m - 1 ] [ i ] = boundary [ ind ++ ] ; } n_@@ m -- ; } if ( n_@@ l < n_@@ n ) { for ( i = n_@@ m - 1 ; i >= n_@@ k ; -- i ) { a [ i ] [ n_@@ l ] = boundary [ ind ++ ] ; } n_@@ l ++ ; } } print@@ Matrix ( a ) ; } int main ( ) { vector < vector < int > > matrix = { { 9 , 7 , 4 , 5 } , { 1 , 6 , 2 , -@@ 6 } , { 12 , 20 , 2 , 0 } , { -@@ 5 , -@@ 6 , 7 , -2 } } ; sort@@ Boundary@@ W@@ ise ( matrix ) ; return 0 ; }
Maximum score possible from an array with jumps of at most length K 4183 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max@@ Score ( int i , int A [ ] , int K , int N , int dp [ ] ) { if ( i >= N - 1 ) return A [ N - 1 ] ; if ( dp [ i ] != -1 ) return dp [ i ] ; int score = INT_@@ MIN ; for ( int j = 1 ; j <= K ; j ++ ) { score = max ( score , max@@ Score ( i + j , A , K , N , dp ) ) ; } return dp [ i ] = score + A [ i ] ; } int get@@ Score ( int A [ ] , int N , int K ) { int dp [ N ] ; for ( int i = 0 ; i < N ; i ++ ) dp [ i ] = -1 ; cout << max@@ Score ( 0 , A , K , N , dp ) ; } int main ( ) { int A [ ] = { 100 , -@@ 30 , -@@ 50 , -@@ 15 , -@@ 20 , -@@ 30 } ; int K = 3 ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; get@@ Score ( A , N , K ) ; return 0 ; }
Check if an array can be sorted by sw@@ apping pairs from indices consisting of un@@ equal elements in another array 4185 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool check@@ if@@ Sorted ( int A [ ] , int B [ ] , int N ) { bool flag = false ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] > A [ i + 1 ] ) { flag = true ; break ; } } if ( ! flag ) { return true ; } int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( B [ i ] == 0 ) { count ++ ; break ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( B [ i ] == 1 ) { count ++ ; break ; } } if ( count == 2 ) { return true ; } return false ; } int main ( ) { int A [ ] = { 3 , 1 , 2 } ; int B [ ] = { 0 , 1 , 1 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; bool check = check@@ if@@ Sorted ( A , B , N ) ; if ( check ) { cout << " YES " << endl ; } else { cout << " NO " << endl ; } return 0 ; }
Sort an array by left shift@@ ing digits of array elements 4206 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Incre@@ asing ( vector < int > arr ) { for ( int i = 0 ; i < arr . size ( ) - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) return false ; } return true ; } vector < int > sort@@ Arr ( vector < int > arr ) { int prev = -1 ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { int opt@@ E@@ le = arr [ i ] ; string str@@ E@@ le = to_string ( arr [ i ] ) ; for ( int idx = 0 ; idx < str@@ E@@ le . size ( ) ; idx ++ ) { string str@@ E@@ le@@ 2 = str@@ E@@ le . substr ( idx ) + str@@ E@@ le . substr ( 0 , idx ) ; int temp = sto@@ i ( str@@ E@@ le@@ 2 ) ; if ( temp >= prev && temp < opt@@ E@@ le ) opt@@ E@@ le = temp ; } arr [ i ] = opt@@ E@@ le ; prev = arr [ i ] ; } if ( is@@ Incre@@ asing ( arr ) ) return arr ; else { arr = { -1 } ; return arr ; } } int main ( ) { vector < int > arr = { 511 , 321 , 323 , 4@@ 32 , 4@@ 33 } ; vector < int > res = sort@@ Arr ( arr ) ; for ( int i = 0 ; i < res . size ( ) ; i ++ ) cout << res [ i ] << " ▁ " ; return 0 ; }
Minim@@ ize the sum of differences of consecutive elements after removing exactly K elements 4471 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define N 100 NEW_LINE #@@ define INF 1000000 NEW_LINE int dp [ N ] [ N ] ; bool vis [ N ] [ N ] ; int find@@ Sum ( int * arr , int n , int k , int l , int r ) { if ( ( l ) + ( n - 1 - r ) == k ) return arr [ r ] - arr [ l ] ; if ( vis [ l ] [ r ] ) return dp [ l ] [ r ] ; vis [ l ] [ r ] = 1 ; return dp [ l ] [ r ] = min ( find@@ Sum ( arr , n , k , l , r - 1 ) , find@@ Sum ( arr , n , k , l + 1 , r ) ) ; } int32_t main ( ) { int arr [ ] = { 1 , 2 , 100 , 120 , 140 } ; int k = 2 ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << find@@ Sum ( arr , n , k , 0 , n - 1 ) ; }
Case 4532 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; string get@@ Sorted@@ String ( string s , int n ) { vector < char > v1 , v2 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] >= ' a ' && s [ i ] <= ' z ' ) v1 . push_back ( s [ i ] ) ; if ( s [ i ] >= ' A ' && s [ i ] <= ' Z ' ) v2 . push_back ( s [ i ] ) ; } sort ( v1 . begin ( ) , v1 . end ( ) ) ; sort ( v2 . begin ( ) , v2 . end ( ) ) ; int i = 0 , j = 0 ; for ( int k = 0 ; k < n ; k ++ ) { if ( s [ k ] >= ' a ' && s [ k ] <= ' z ' ) { s [ k ] = v1 [ i ] ; ++ i ; } else if ( s [ k ] >= ' A ' && s [ k ] <= ' Z ' ) { s [ k ] = v2 [ j ] ; ++ j ; } } return s ; } int main ( ) { string s = " g@@ E@@ ek@@ sf@@ Org@@ EE@@ k@@ S " ; int n = s . length ( ) ; cout << get@@ Sorted@@ String ( s , n ) ; return 0 ; }
Remove elements to make array sorted 4543 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void remove@@ Elements ( int arr [ ] , int n ) { int br@@ r [ n ] , l = 1 ; br@@ r [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( br@@ r [ l - 1 ] <= arr [ i ] ) { br@@ r [ l ] = arr [ i ] ; l ++ ; } } for ( int i = 0 ; i < l ; i ++ ) cout << br@@ r [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 10 , 12 , 9 , 10 , 2 , 13 , 14 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; remove@@ Elements ( arr , n ) ; return 0 ; }
Find number from its di@@ visors 4554 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ X ( int a [ ] , int n ) { sort ( a , a + n ) ; int x = a [ 0 ] * a [ n - 1 ] ; vector < int > vec ; for ( int i = 2 ; i * i <= x ; i ++ ) { if ( x % i == 0 ) { vec . push_back ( i ) ; if ( ( x / i ) != i ) vec . push_back ( x / i ) ; } } sort ( vec . begin ( ) , vec . end ( ) ) ; if ( vec . size ( ) != n ) return -1 ; else { int i = 0 ; for ( auto it : vec ) { if ( a [ i ++ ] != it ) return -1 ; } } return x ; } int main ( ) { int a [ ] = { 2 , 5 , 4 , 10 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << find@@ X ( a , n ) ; return 0 ; }
Product of all Sub@@ sequences of size K except the minimum and maximum Elements 4567 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define MOD 100000000@@ 7 NEW_LINE #@@ define ll long long NEW_LINE #@@ define max 101 NEW_LINE ll C [ max - 1 ] [ max - 1 ] ; ll power ( ll x , unsigned ll y ) { unsigned ll res = 1 ; x = x % MOD ; while ( y > 0 ) { if ( y & 1 ) { res = ( res * x ) % MOD ; } y = y >> 1 ; x = ( x * x ) % MOD ; } return res % MOD ; } void comb@@ i ( int n , int k ) { int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] % MOD + C [ i - 1 ] [ j ] % MOD ) % MOD ; } } } unsigned ll product ( ll a [ ] , int n , int k ) { unsigned ll ans = 1 ; sort ( a , a + n ) ; ll pow@@ a = C [ n - 1 ] [ k - 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { ll pow@@ la = C [ i ] [ k - 1 ] ; ll pow@@ fa = C [ n - i - 1 ] [ k - 1 ] ; ll po@@ we = ( ( pow@@ a % MOD ) - ( pow@@ la + pow@@ fa ) % MOD + MOD ) % MOD ; unsigned ll mul = power ( a [ i ] , po@@ we ) % MOD ; ans = ( ( ans % MOD ) * ( mul % MOD ) ) % MOD ; } return ans % MOD ; } int main ( ) { comb@@ i ( 100 , 100 ) ; ll arr [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof arr [ 0 ] ; int k = 3 ; unsigned ll ans = product ( arr , n , k ) ; cout << ans << endl ; return 0 ; }
Equ@@ ally divide into two sets such that one set has maximum distinct elements 4678 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int distribution ( int arr [ ] , int n ) { set < int , greater < int > > resources ; for ( int i = 0 ; i < n ; i ++ ) resources . insert ( arr [ i ] ) ; int m = resources . size ( ) ; return min ( m , n / 2 ) ; } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 1 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << distribution ( arr , n ) << endl ; return 0 ; }
Sort string of characters using Stack 4692 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ Sorted ( string s , int l ) { stack < char > Stack ; stack < char > temp@@ stack ; Stack . push ( s [ 0 ] ) ; for ( int i = 1 ; i < l ; i ++ ) { int a = s [ i ] ; int b = Stack . top ( ) ; if ( ( a - b ) >= 1 or ( a == b ) ) Stack . push ( s [ i ] ) ; else if ( ( b - a ) >= 1 ) { while ( ( b - a ) >= 1 ) { temp@@ stack . push ( Stack . top ( ) ) ; Stack . pop ( ) ; if ( Stack . size ( ) > 0 ) b = Stack . top ( ) ; else break ; } Stack . push ( s [ i ] ) ; while ( temp@@ stack . size ( ) > 0 ) { Stack . push ( temp@@ stack . top ( ) ) ; temp@@ stack . pop ( ) ; } } } string answer ; while ( Stack . size ( ) > 0 ) { answer = Stack . top ( ) + answer ; Stack . pop ( ) ; } cout << answer << endl ; } int main ( ) { string s = " ge@@ ek@@ s@@ forge@@ e@@ ks " ; int l = s . length ( ) ; print@@ Sorted ( s , l ) ; return 0 ; }
Maxim@@ ise the number of to@@ ys that can be purch@@ ased with amount K 4699 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int maximum@@ _to@@ ys ( int cost [ ] , int N , int K ) { int count = 0 , sum = 0 ; sort ( cost , cost + N ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( sum + cost [ i ] <= K ) { sum = sum + cost [ i ] ; count ++ ; } } return count ; } int main ( ) { int K = 50 ; int cost [ ] = { 1 , 12 , 5 , 111 , 200 , 1000 , 10 , 9 , 12 , 15 } ; int N = sizeof ( cost ) / sizeof ( cost [ 0 ] ) ; cout << maximum@@ _to@@ ys ( cost , N , K ) << endl ; return 0 ; }
Check if given array is almost sorted ( elements are at 4745 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool al@@ most@@ Sort ( int A [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( A [ i ] > A [ i + 1 ] ) { swap ( A [ i ] , A [ i + 1 ] ) ; i ++ ; } } for ( int i = 0 ; i < n - 1 ; i ++ ) if ( A [ i ] > A [ i + 1 ] ) return false ; return true ; } int main ( ) { int A [ ] = { 1 , 3 , 2 , 4 , 6 , 5 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; if ( al@@ most@@ Sort ( A , n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
Sort an array when two hal@@ ves are sorted 4802 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void merge@@ Two@@ Half ( int A [ ] , int n ) { int temp [ n ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( A [ i ] > A [ i + 1 ] ) { half_@@ i = i + 1 ; break ; } } if ( half_@@ i == 0 ) return ; int i = 0 , j = half_@@ i , k = 0 ; while ( i < half_@@ i && j < n ) { if ( A [ i ] < A [ j ] ) temp [ k ++ ] = A [ i ++ ] ; else temp [ k ++ ] = A [ j ++ ] ; } while ( i < half_@@ i ) temp [ k ++ ] = A [ i ++ ] ; while ( j < n ) temp [ k ++ ] = A [ j ++ ] ; for ( int i = 0 ; i < n ; i ++ ) A [ i ] = temp [ i ] ; } int main ( ) { int A [ ] = { 2 , 3 , 8 , -1 , 7 , 10 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; merge@@ Two@@ Half ( A , n ) ; for ( int i = 0 ; i < n ; i ++ ) cout << A [ i ] << " ▁ " ; return 0 ; }
Maxim@@ ize number of circular build@@ ings that can be covered by L length wire 4960 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; const double Pi = 3.1415@@ 92 ; int Max@@ Build@@ ings@@ Co@@ vered ( int arr [ ] , int N , int L ) { double curr_@@ sum = 0 ; int start = 0 , curr_@@ count = 0 , max_@@ count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { curr_@@ sum = curr_@@ sum + ( ( double ) arr [ i ] * Pi ) ; if ( i != 0 ) curr_@@ sum += 1 ; if ( curr_@@ sum <= L ) { curr_@@ count ++ ; } else if ( curr_@@ sum > L ) { curr_@@ sum = curr_@@ sum - ( ( double ) arr [ start ] * Pi ) ; curr_@@ sum -= 1 ; start ++ ; curr_@@ count -- ; } max_@@ count = max ( curr_@@ count , max_@@ count ) ; } return max_@@ count ; } int main ( ) { int arr [ ] = { 4 , 1 , 6 , 2 } ; int L = 24 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << Max@@ Build@@ ings@@ Co@@ vered ( arr , N , L ) ; return 0 ; }
Check if a Binary String can be split into disjoint sub@@ sequences which are equal to "01@@ 0" 4967 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Possible ( string s ) { int n = s . size ( ) ; int count_@@ 0 = 0 , count_@@ 1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '0' ) ++ count_@@ 0 ; else ++ count_@@ 1 ; if ( count_@@ 1 > count_@@ 0 ) return false ; } if ( count_@@ 0 != ( 2 * count_@@ 1 ) ) return false ; count_@@ 0 = 0 , count_@@ 1 = 0 ; for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( s [ i ] == '0' ) ++ count_@@ 0 ; else ++ count_@@ 1 ; if ( count_@@ 1 > count_@@ 0 ) return false ; } return true ; } int main ( ) { string s = "01@@ 0100@@ " ; if ( is@@ Possible ( s ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
Maxim@@ ize array product by changing any array element arr [ i ] to ( 5128 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Max@@ Val@@ By@@ Re@@ arr@@ Arr ( int arr [ ] , int N ) { int res = 0 ; res = ( N * ( N + 1 ) ) / 2 ; return res ; } int main ( ) { int arr [ ] = { 3 , 2 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << find@@ Max@@ Val@@ By@@ Re@@ arr@@ Arr ( arr , N ) ; return 0 ; }
Minimum characters to be replaced to make a string concatenation of a K 5229 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; float pair@@ Product@@ Mean ( int arr [ ] , int N ) { int suffix@@ Sum@@ Array [ N ] ; suffix@@ Sum@@ Array [ N - 1 ] = arr [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { suffix@@ Sum@@ Array [ i ] = suffix@@ Sum@@ Array [ i + 1 ] + arr [ i ] ; } int length = ( N * ( N - 1 ) ) / 2 ; float res = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { res += arr [ i ] * suffix@@ Sum@@ Array [ i + 1 ] ; } float mean ; if ( length != 0 ) mean = res / length ; else mean = 0 ; return mean ; } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << fixed << setprecision ( 2 ) << pair@@ Product@@ Mean ( arr , N ) ; return 0 ; }
Possible values of Q such that , for any value of R , their product is equal to X times their sum 5349 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void values_@@ of_@@ Q ( int X ) { vector < int > val_@@ Q ; for ( int i = 1 ; i <= X ; i ++ ) { if ( ( ( ( X + i ) * X ) ) % i == 0 ) { val_@@ Q . push_back ( X + i ) ; } } cout << val_@@ Q . size ( ) << endl ; for ( int i = 0 ; i < val_@@ Q . size ( ) ; i ++ ) { cout << val_@@ Q [ i ] << " ▁ " ; } } int main ( ) { int X = 3 ; values_@@ of_@@ Q ( X ) ; return 0 ; }
Sum of product of all integers upto N with their count of di@@ visors 5374 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; long long sum@@ Of@@ Factors ( int N ) { long long ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { long long first = i ; long long last = ( N / i ) * i ; long long factors = ( last - first ) / i + 1 ; long long total@@ Contribution = ( ( ( factors ) * ( factors + 1 ) ) / 2 ) * i ; ans += total@@ Contribution ; } return ans ; } int main ( ) { int N = 3 ; cout << sum@@ Of@@ Factors ( N ) ; }
Maximum pro@@ fit such that total sto@@ len value is less than K to get bonus 5432 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max@@ Pro@@ fit ( vector < int > value , int N , int K ) { sort ( value . begin ( ) , value . end ( ) ) ; int maxval = value [ N - 1 ] ; int max@@ Pro@@ fit = 0 ; int curr_@@ val ; do { curr_@@ val = 0 ; for ( int i = 0 ; i < N ; i ++ ) { curr_@@ val += value [ i ] ; if ( curr_@@ val <= K ) { max@@ Pro@@ fit = max ( curr_@@ val + maxval * ( i + 1 ) , max@@ Pro@@ fit ) ; } } } while ( next_@@ permutation ( value . begin ( ) , value . end ( ) ) ) ; return max@@ Pro@@ fit ; } int main ( ) { int N = 4 , K = 6 ; vector < int > values { 5 , 2 , 7 , 3 } ; cout << max@@ Pro@@ fit ( values , N , K ) ; }
Min operations to reduce N by multiply@@ ing by any number or taking square root 5435 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void minValue ( int n ) { while ( int ( sqrt ( n ) ) == sqrt ( n ) && n > 1 ) { n = sqrt ( n ) ; } for ( int i = sqrt ( n ) ; i > 1 ; i -- ) { while ( n % ( i * i ) == 0 ) n /= i ; } cout << n ; } int main ( ) { int N = 20 ; minValue ( N ) ; }
Final direction after visi@@ ting every cell of Matrix starting from ( 0 , 0 ) 5458 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ Direction ( int n , int m ) { if ( n > m ) { if ( m % 2 == 0 ) printf ( " Up STRNEWLINE " ) ; else printf ( " Down STRNEWLINE " ) ; } else { if ( n % 2 == 0 ) printf ( " Left STRNEWLINE " ) ; else printf ( " Right STRNEWLINE " ) ; } } int main ( ) { int n = 3 , m = 3 ; find@@ Direction ( n , m ) ; return 0 ; }
Find GC@@ D of each subtree of a given node in an N 5485 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; const int N = 1e@@ 5 + 5 ; vector < vector < int > > v ( N ) ; vector < int > val ( N ) ; vector < int > answer ( N ) ; int n ; int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } void DFS ( int node , int parent ) { answer [ node ] = val [ node ] ; for ( int child : v [ node ] ) { if ( child == parent ) continue ; DFS ( child , node ) ; answer [ node ] = gcd ( answer [ node ] , answer [ child ] ) ; } } void preprocess ( ) { DFS ( 1 , -1 ) ; } void find@@ GC@@ D ( int queries [ ] , int q ) { preprocess ( ) ; for ( int i = 0 ; i < q ; i ++ ) { int GC@@ D = answer [ queries [ i ] ] ; cout << " For ▁ subtree ▁ of ▁ " << queries [ i ] << " , ▁ GC@@ D ▁ = ▁ " << GC@@ D << endl ; } } int main ( ) { n = 5 ; v [ 1 ] . push_back ( 2 ) ; v [ 2 ] . push_back ( 1 ) ; v [ 1 ] . push_back ( 3 ) ; v [ 3 ] . push_back ( 1 ) ; v [ 3 ] . push_back ( 4 ) ; v [ 4 ] . push_back ( 3 ) ; v [ 3 ] . push_back ( 5 ) ; v [ 5 ] . push_back ( 3 ) ; val [ 1 ] = 2 ; val [ 2 ] = 3 ; val [ 3 ] = 4 ; val [ 4 ] = 8 ; val [ 5 ] = 16 ; int queries [ ] = { 2 , 3 , 1 } ; int q = sizeof ( queries ) / sizeof ( queries [ 0 ] ) ; find@@ GC@@ D ( queries , q ) ; return 0 ; }
Check if array can be converted into strictly decre@@ asing sequence 5503 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool check ( int * arr , int n ) { bool flag = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < n - i ) { flag = false ; } } if ( flag ) { return true ; } else { return false ; } } int main ( ) { int ar@@ r1 [ ] = { 11 , 11 , 11 , 11 } ; int n1 = sizeof ( ar@@ r1 ) / sizeof ( ar@@ r1 [ 0 ] ) ; if ( check ( ar@@ r1 , n1 ) ) { cout << " Yes " << endl ; } else { cout << " No " << endl ; } }
Check if array can be converted into strictly decre@@ asing sequence 5539 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int get@@ Largest@@ Sum ( int N ) { for ( int i = 1 ; i * i <= N ; i ++ ) { for ( int j = i + 1 ; j * j <= N ; j ++ ) { int k = N / j ; int a = k * i ; int b = k * j ; if ( a <= N && b <= N && a * b % ( a + b ) == 0 ) max_@@ sum = max ( max_@@ sum , a + b ) ; } } return max_@@ sum ; } int main ( ) { int N = 25 ; int max_@@ sum = get@@ Largest@@ Sum ( N ) ; cout << max_@@ sum << endl ; return 0 ; }
Count common elements in two arrays containing multip@@ les of N and M 5623 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } int l@@ cm ( int n , int m ) { return ( n * m ) / gcd ( n , m ) ; } int main ( ) { int n = 2 , m = 3 , k = 5 ; cout << k / l@@ cm ( n , m ) << endl ; return 0 ; }
Check whether a sub@@ sequence exists with sum equal to k if arr [ i ] > 2 * arr [ i 5626 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; bool CheckFor@@ Sequence ( int arr [ ] , int n , int k ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( k >= arr [ i ] ) k -= arr [ i ] ; } if ( k != 0 ) return false ; else return true ; } int main ( ) { int A [ ] = { 1 , 3 , 7 , 15 , 31 } ; int n = sizeof ( A ) / sizeof ( int ) ; cout << ( CheckFor@@ Sequence ( A , n , 18 ) ? " True " : " False " ) << endl ; return 0 ; }
Maximum possible sub 5630 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int Sub@@ array@@ Sum ( int a [ ] , int n , int x ) { int ans = -@@ 10000 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int cur@@ ans = 0 ; priority_@@ queue < int , vector < int > > pq ; priority_@@ queue < int , vector < int > , greater < int > > pq@@ 2 ; for ( int k = 0 ; k < n ; k ++ ) { if ( k >= i && k <= j ) { cur@@ ans += a [ k ] ; pq@@ 2 . push ( a [ k ] ) ; } else pq . push ( a [ k ] ) ; } ans = max ( ans , cur@@ ans ) ; for ( int k = 1 ; k <= x ; k ++ ) { if ( pq . empty ( ) || pq@@ 2 . empty ( ) || pq@@ 2 . top ( ) >= pq . top ( ) ) break ; cur@@ ans -= pq@@ 2 . top ( ) ; pq@@ 2 . pop ( ) ; cur@@ ans += pq . top ( ) ; pq . pop ( ) ; ans = max ( ans , cur@@ ans ) ; } } } return ans ; } int main ( ) { int a [ ] = { 5 , -1 , 2 , 3 , 4 , -2 , 5 } , x = 2 ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << Sub@@ array@@ Sum ( a , n , x ) ; return 0 ; }
Generate an array of size K which satis@@ fies the given conditions 5634 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void generate@@ Array ( int n , int k ) { vector < int > array ( k , 0 ) ; int remaining = n - int ( k * ( k + 1 ) / 2 ) ; if ( remaining < 0 ) cout << ( " NO " ) ; int right_@@ most = remaining % k ; int high = ceil ( remaining / ( k * 1.0 ) ) ; int low = floor ( remaining / ( k * 1.0 ) ) ; for ( int i = k - right_@@ most ; i < k ; i ++ ) array [ i ] = high ; for ( int i = 0 ; i < ( k - right_@@ most ) ; i ++ ) array [ i ] = low ; for ( int i = 0 ; i < k ; i ++ ) array [ i ] += i + 1 ; if ( k - 1 != remaining or k == 1 ) { for ( int u : array ) cout << u << " ▁ " ; } else if ( k == 2 or k == 3 ) printf ( " - 1 STRNEWLINE " ) ; else { array [ 1 ] -= 1 ; array [ k - 1 ] += 1 ; for ( int u : array ) cout << u << " ▁ " ; } } int main ( ) { int n = 26 , k = 6 ; generate@@ Array ( n , k ) ; return 0 ; }
Maximum count of sub 5684 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max@@ Sub@@ Strings ( string s , int k ) { int max@@ Sub@@ Str = 0 , n = s . size ( ) ; for ( int c = 0 ; c < 26 ; c ++ ) { char ch = ' a ' + c ; int curr = 0 ; for ( int i = 0 ; i <= n - k ; i ++ ) { if ( s [ i ] != ch ) continue ; int cnt = 0 ; while ( i < n && s [ i ] == ch && cnt != k ) { i ++ ; cnt ++ ; } i -- ; if ( cnt == k ) curr ++ ; } max@@ Sub@@ Str = max ( max@@ Sub@@ Str , curr ) ; } return max@@ Sub@@ Str ; } int main ( ) { string s = " aa@@ ac@@ a@@ ab@@ ba@@ a " ; int k = 2 ; cout << max@@ Sub@@ Strings ( s , k ) ; return 0 ; }
Minimum cost to reach a point N from 0 with two different operations allowed 5718 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int min@@ Cost ( int N , int P , int Q ) { int cost = 0 ; while ( N > 0 ) { if ( N & 1 ) { cost += P ; N -- ; } else { int temp = N / 2 ; if ( temp * P > Q ) cost += Q ; else cost += P * temp ; N /= 2 ; } } return cost ; } int main ( ) { int N = 9 , P = 5 , Q = 1 ; cout << min@@ Cost ( N , P , Q ) ; return 0 ; }
Schedule jobs so that each server gets equal load 5774 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int solve ( int a [ ] , int b [ ] , int n ) { int i ; long long int s = 0 ; for ( i = 0 ; i < n ; i ++ ) s += ( a [ i ] + b [ i ] ) ; if ( n == 1 ) return a [ 0 ] + b [ 0 ] ; if ( s % n != 0 ) return -1 ; int x = s / n ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) return -1 ; if ( i > 0 ) { a [ i ] += b [ i - 1 ] ; b [ i - 1 ] = 0 ; } if ( a [ i ] == x ) continue ; int y = a [ i ] + b [ i ] ; if ( i + 1 < n ) y += b [ i + 1 ] ; if ( y == x ) { a [ i ] = y ; b [ i ] = b [ i + 1 ] = 0 ; continue ; } if ( a [ i ] + b [ i ] == x ) { a [ i ] += b [ i ] ; b [ i ] = 0 ; continue ; } if ( i + 1 < n && a [ i ] + b [ i + 1 ] == x ) { a [ i ] += b [ i + 1 ] ; b [ i + 1 ] = 0 ; continue ; } return -1 ; } for ( i = 0 ; i < n ; i ++ ) if ( b [ i ] != 0 ) return -1 ; return x ; } int main ( ) { int a [ ] = { 6 , 14 , 21 , 1 } ; int b [ ] = { 15 , 7 , 10 , 10 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << solve ( a , b , n ) ; return 0 ; }
Check if it is possible to survi@@ ve on Is@@ land 5776 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void survi@@ val ( int S , int N , int M ) { if ( ( ( N * 6 ) < ( M * 7 ) && S > 6 ) M > N ) cout << " No STRNEWLINE " ; else { int days = ( M * S ) / N ; if ( ( ( M * S ) % N ) != 0 ) days ++ ; cout << " Yes ▁ " << days << endl ; } } int main ( ) { int S = 10 , N = 16 , M = 2 ; survi@@ val ( S , N , M ) ; return 0 ; }
Lon@@ gest sub@@ array with all even or all odd elements 5870 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int Lon@@ gest@@ O@@ dd@@ Even@@ Sub@@ array ( int A [ ] , int N ) { int dp [ N ] ; dp [ 0 ] = 1 ; int ans = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( ( A [ i ] % 2 == 0 && A [ i - 1 ] % 2 == 0 ) || ( A [ i ] % 2 != 0 && A [ i - 1 ] % 2 != 0 ) ) { dp [ i ] = dp [ i - 1 ] + 1 ; } else dp [ i ] = 1 ; } for ( int i = 0 ; i < N ; i ++ ) ans = max ( ans , dp [ i ] ) ; return ans ; } int main ( ) { int A [ ] = { 2 , 5 , 7 , 2 , 4 , 6 , 8 , 3 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << Lon@@ gest@@ O@@ dd@@ Even@@ Sub@@ array ( A , N ) ; return 0 ; }
Split array into sub@@ arrays such that sum of difference between their maximum@@ s and minimum@@ s is maximum 5947 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int getValue ( int arr [ ] , int N ) { int dp [ N ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] = 0 ; for ( int i = 1 ; i < N ; i ++ ) { int min@@ n = arr [ i ] ; int maxx = arr [ i ] ; for ( int j = i ; j >= 0 ; j -- ) { min@@ n = min ( arr [ j ] , min@@ n ) ; maxx = max ( arr [ j ] , maxx ) ; dp [ i ] = max ( dp [ i ] , maxx - min@@ n + ( ( j >= 1 ) ? dp [ j - 1 ] : 0 ) ) ; } } return dp [ N - 1 ] ; } int main ( ) { int arr [ ] = { 8 , 1 , 7 , 9 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << getValue ( arr , N ) ; return 0 ; }
Min number of operations to reduce N to 0 by subtrac@@ ting any digits from N 6145 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int reduce@@ Zero ( int N ) { vector < int > dp ( N + 1 , 1e@@ 9 ) ; dp [ 0 ] = 0 ; for ( int i = 0 ; i <= N ; i ++ ) { for ( char c : to_string ( i ) ) { dp [ i ] = min ( dp [ i ] , dp [ i - ( c - '0' ) ] + 1 ) ; } } return dp [ N ] ; } int main ( ) { int N = 25 ; cout << reduce@@ Zero ( N ) ; return 0 ; }
Count of sub@@ sequences of length at@@ most K containing distinct prime elements 6187 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool prime [ 10000@@ 1 ] ; void Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( ) { memset ( prime , true , sizeof ( prime ) ) ; prime [ 0 ] = prime [ 1 ] = false ; for ( int p = 2 ; p * p <= 100000 ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= 100000 ; i += p ) prime [ i ] = false ; } } } int distin@@ ct@@ Prime@@ Sub@@ Seq ( int a [ ] , int n , int k ) { Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( ) ; vector < int > primes ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ a [ i ] ] ) primes . push_back ( a [ i ] ) ; } int l = primes . size ( ) ; sort ( primes . begin ( ) , primes . end ( ) ) ; vector < int > b ; vector < int > dp ; int sum = 0 ; for ( int i = 0 ; i < l ; ) { int count = 1 , x = a [ i ] ; i ++ ; while ( i < l && a [ i ] == x ) { count ++ ; i ++ ; } b . push_back ( count ) ; dp . push_back ( count ) ; sum += count ; } int of_@@ length = 2 ; int len = dp . size ( ) ; int ans = 0 ; while ( of_@@ length <= k ) { int freq = 0 ; int prev = 0 ; for ( int i = 0 ; i < ( len - 1 ) ; i ++ ) { freq += dp [ i ] ; int j = sum - freq ; int sub@@ seq = b [ i ] * j ; ans += sub@@ seq ; dp [ i ] = sub@@ seq ; prev += dp [ i ] ; } len -- ; sum = prev ; of_@@ length ++ ; } ans += ( l + 1 ) ; return ans ; } int main ( ) { int a [ ] = { 1 , 2 , 2 , 3 , 3 , 4 , 5 } ; int n = sizeof ( a ) / sizeof ( int ) ; int k = 3 ; cout << distin@@ ct@@ Prime@@ Sub@@ Seq ( a , n , k ) ; return 0 ; }
Number of ways to split N as sum of K numbers from the given range 6207 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; const int mod = 100000000@@ 7 ; int dp [ 1000 ] [ 1000 ] ; int calculate ( int pos , int left , int k , int L , int R ) { if ( pos == k ) { if ( left == 0 ) return 1 ; else return 0 ; } if ( left == 0 ) return 0 ; if ( dp [ pos ] [ left ] != -1 ) return dp [ pos ] [ left ] ; int answer = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( i > left ) break ; answer = ( answer + calculate ( pos + 1 , left - i , k , L , R ) ) % mod ; } return dp [ pos ] [ left ] = answer ; } int count@@ Way@@ sto@@ Divide ( int n , int k , int L , int R ) { memset ( dp , -1 , sizeof ( dp ) ) ; return calculate ( 0 , n , k , L , R ) ; } int main ( ) { int N = 12 ; int K = 3 ; int L = 1 ; int R = 5 ; cout << count@@ Way@@ sto@@ Divide ( N , K , L , R ) ; return 0 ; }
Lar@@ gest Square in a Binary Matrix with at most K 1 s for multiple Queries 6211 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; const int MAX = 100 ; void lar@@ gest@@ Square ( int matrix [ ] [ MAX ] , int R , int C , int q_@@ i [ ] , int q_@@ j [ ] , int K , int Q ) { int count@@ DP [ R ] [ C ] ; memset ( count@@ DP , 0 , sizeof ( count@@ DP ) ) ; count@@ DP [ 0 ] [ 0 ] = matrix [ 0 ] [ 0 ] ; for ( int i = 1 ; i < R ; i ++ ) count@@ DP [ i ] [ 0 ] = count@@ DP [ i - 1 ] [ 0 ] + matrix [ i ] [ 0 ] ; for ( int j = 1 ; j < C ; j ++ ) count@@ DP [ 0 ] [ j ] = count@@ DP [ 0 ] [ j - 1 ] + matrix [ 0 ] [ j ] ; for ( int i = 1 ; i < R ; i ++ ) for ( int j = 1 ; j < C ; j ++ ) count@@ DP [ i ] [ j ] = matrix [ i ] [ j ] + count@@ DP [ i - 1 ] [ j ] + count@@ DP [ i ] [ j - 1 ] - count@@ DP [ i - 1 ] [ j - 1 ] ; for ( int q = 0 ; q < Q ; q ++ ) { int i = q_@@ i [ q ] ; int j = q_@@ j [ q ] ; int min_@@ dist = min ( min ( i , j ) , min ( R - i - 1 , C - j - 1 ) ) ; int ans = -1 , l = 0 , u = min_@@ dist ; while ( l <= u ) { int mid = ( l + u ) / 2 ; int x1 = i - mid , x2 = i + mid ; int y1 = j - mid , y2 = j + mid ; int count = count@@ DP [ x2 ] [ y2 ] ; if ( x1 > 0 ) count -= count@@ DP [ x1 - 1 ] [ y2 ] ; if ( y1 > 0 ) count -= count@@ DP [ x2 ] [ y1 - 1 ] ; if ( x1 > 0 && y1 > 0 ) count += count@@ DP [ x1 - 1 ] [ y1 - 1 ] ; if ( count <= K ) { ans = 2 * mid + 1 ; l = mid + 1 ; } else u = mid - 1 ; } cout << ans << " STRNEWLINE " ; } } int main ( ) { int matrix [ ] [ MAX ] = { { 1 , 0 , 1 , 0 , 0 } , { 1 , 0 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 } , { 1 , 0 , 0 , 1 , 0 } } ; int K = 9 , Q = 1 ; int q_@@ i [ ] = { 1 } ; int q_@@ j [ ] = { 2 } ; lar@@ gest@@ Square ( matrix , 4 , 5 , q_@@ i , q_@@ j , K , Q ) ; return 0 ; }
