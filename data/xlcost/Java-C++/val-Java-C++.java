import java . util . Arrays ; class GF@@ G { static void calculate@@ Span ( int price [ ] , int n , int S [ ] ) { S [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { S [ i ] = 1 ; for ( int j = i - 1 ; ( j >= 0 ) && ( price [ i ] >= price [ j ] ) ; j -- ) S [ i ] ++ ; } } static void print@@ Array ( int arr [ ] ) { System . out . print ( Arrays . toString ( arr ) ) ; } public static void main ( String [ ] args ) { int price [ ] = { 10 , 4 , 5 , 90 , 120 , 80 } ; int n = price . length ; int S [ ] = new int [ n ] ; calculate@@ Span ( price , n , S ) ; print@@ Array ( S ) ; } }
class Main { static void print@@ N@@ GE ( int arr [ ] , int n ) { int next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = - 1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { next = arr [ j ] ; break ; } } System . out . println ( arr [ i ] + " ▁ - - ▁ " + next ) ; } } public static void main ( String args [ ] ) { int arr [ ] = { 11 , 13 , 21 , 3 } ; int n = arr . length ; print@@ N@@ GE ( arr , n ) ; } }
import java . util . Stack ; class GF@@ G { static void Print@@ Min@@ Number@@ For@@ Pattern ( String seq ) { String result = " " ; Stack < Integer > stk = new Stack < Integer > ( ) ; for ( int i = 0 ; i <= seq . length ( ) ; i ++ ) { stk . push ( i + 1 ) ; if ( i == seq . length ( ) || seq . charAt ( i ) == ' I ' ) { while ( ! stk . empty ( ) ) { result += String . valueOf ( stk . peek ( ) ) ; result += " ▁ " ; stk . pop ( ) ; } } } System . out . println ( result ) ; } public static void main ( String [ ] args ) { Print@@ Min@@ Number@@ For@@ Pattern ( " ID@@ ID " ) ; Print@@ Min@@ Number@@ For@@ Pattern ( " I " ) ; Print@@ Min@@ Number@@ For@@ Pattern ( " DD " ) ; Print@@ Min@@ Number@@ For@@ Pattern ( " II " ) ; Print@@ Min@@ Number@@ For@@ Pattern ( " D@@ ID@@ I " ) ; Print@@ Min@@ Number@@ For@@ Pattern ( " I@@ ID@@ DD " ) ; Print@@ Min@@ Number@@ For@@ Pattern ( " DD@@ ID@@ DI@@ ID " ) ; } }
import java . util . HashMap ; import java . util . Map ; import java . util . Map . Entry ; class GF@@ G { static int most@@ Frequ@@ ent ( int arr [ ] , int n ) { Map < Integer , Integer > hp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int key = arr [ i ] ; if ( hp . containsKey ( key ) ) { int freq = hp . get ( key ) ; freq ++ ; hp . put ( key , freq ) ; } else { hp . put ( key , 1 ) ; } } int max_@@ count = 0 , res = - 1 ; for ( Entry < Integer , Integer > val : hp . entrySet ( ) ) { if ( max_@@ count < val . getValue ( ) ) { res = val . getKey ( ) ; max_@@ count = val . getValue ( ) ; } } return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 2 , 1 , 3 , 2 , 1 } ; int n = arr . length ; System . out . println ( most@@ Frequ@@ ent ( arr , n ) ) ; } }
import java . util . HashSet ; import java . util . Set ; public class Gf@@ G { static void find@@ Missing ( int a [ ] , int b [ ] , int n , int m ) { HashSet < Integer > s = new HashSet < > ( ) ; for ( int i = 0 ; i < m ; i ++ ) s . add ( b [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) if ( ! s . contains ( a [ i ] ) ) System . out . print ( a [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 6 , 3 , 4 , 5 } ; int b [ ] = { 2 , 4 , 3 , 1 , 0 } ; int n = a . length ; int m = b . length ; find@@ Missing ( a , b , n , m ) ; } }
import java . util . * ; import java . lang . * ; public class Gf@@ G { public static int subset ( int ar [ ] , int n ) { int res = 0 ; Arrays . sort ( ar ) ; for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ; for ( ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) count ++ ; else break ; } res = Math . max ( res , count ) ; } return res ; } public static void main ( String argc [ ] ) { int arr [ ] = { 5 , 6 , 9 , 3 , 4 , 3 , 4 } ; int n = 7 ; System . out . println ( subset ( arr , n ) ) ; } }
import java . util . * ; class GF@@ G { static void make@@ Permutation ( int [ ] a , int n ) { HashMap < Integer , Integer > count = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( count . containsKey ( a [ i ] ) ) { count . put ( a [ i ] , count . get ( a [ i ] ) + 1 ) ; } else { count . put ( a [ i ] , 1 ) ; } } int next_@@ missing = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( count . containsKey ( a [ i ] ) && count . get ( a [ i ] ) != 1 a [ i ] > n a [ i ] < 1 ) { count . put ( a [ i ] , count . get ( a [ i ] ) - 1 ) ; while ( count . containsKey ( next_@@ missing ) ) next_@@ missing ++ ; a [ i ] = next_@@ missing ; count . put ( next_@@ missing , 1 ) ; } } } public static void main ( String [ ] args ) { int A [ ] = { 2 , 2 , 3 , 3 } ; int n = A . length ; make@@ Permutation ( A , n ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( A [ i ] + " ▁ " ) ; } }
import java . util . * ; class Solution { public static void main ( String [ ] args ) { int arr [ ] = { 10 , 2 , - 2 , - 20 , 10 } ; int k = - 10 ; int n = arr . length ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = i ; j < n ; j ++ ) { sum += arr [ j ] ; if ( sum == k ) res ++ ; } } System . out . println ( res ) ; } }
import java . util . * ; class GF@@ G { public static void find@@ Pairs ( int ar@@ r1 [ ] , int ar@@ r2 [ ] , int n , int m , int x ) { HashMap < Integer , Integer > s = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) s . put ( ar@@ r1 [ i ] , 0 ) ; for ( int j = 0 ; j < m ; j ++ ) if ( s . containsKey ( x - ar@@ r2 [ j ] ) ) System . out . println ( x - ar@@ r2 [ j ] + " ▁ " + ar@@ r2 [ j ] ) ; } public static void main ( String [ ] args ) { int ar@@ r1 [ ] = { 1 , 0 , - 4 , 7 , 6 , 4 } ; int ar@@ r2 [ ] = { 0 , 2 , 4 , - 3 , 2 , 1 } ; int x = 8 ; find@@ Pairs ( ar@@ r1 , ar@@ r2 , ar@@ r1 . length , ar@@ r2 . length , x ) ; } }
class GF@@ G { static boolean find@@ Trip@@ let ( int a1 [ ] , int a2 [ ] , int a3 [ ] , int n1 , int n2 , int n3 , int sum ) { for ( int i = 0 ; i < n1 ; i ++ ) for ( int j = 0 ; j < n2 ; j ++ ) for ( int k = 0 ; k < n3 ; k ++ ) if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) return true ; return false ; } public static void main ( String [ ] args ) { int a1 [ ] = { 1 , 2 , 3 , 4 , 5 } ; int a2 [ ] = { 2 , 3 , 6 , 1 , 2 } ; int a3 [ ] = { 3 , 2 , 4 , 5 , 6 } ; int sum = 9 ; int n1 = a1 . length ; int n2 = a2 . length ; int n3 = a3 . length ; if ( find@@ Trip@@ let ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
import java . util . * ; class GF@@ G { static void longest ( int a [ ] , int n , int k ) { int [ ] freq = new int [ 7 ] ; int start = 0 , end = 0 , now = 0 , l = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq [ a [ i ] ] ++ ; if ( freq [ a [ i ] ] == 1 ) now ++ ; while ( now > k ) { freq [ a [ l ] ] -- ; if ( freq [ a [ l ] ] == 0 ) now -- ; l ++ ; } if ( i - l + 1 >= end - start + 1 ) { end = i ; start = l ; } } for ( int i = start ; i <= end ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; } public static void main ( String args [ ] ) { int a [ ] = { 6 , 5 , 1 , 2 , 3 , 2 , 1 , 4 , 5 } ; int n = a . length ; int k = 3 ; longest ( a , n , k ) ; } }
class Largest@@ Sub@@ Array { int find@@ Sub@@ Array ( int arr [ ] , int n ) { int sum = 0 ; int maxsize = - 1 , start@@ index = 0 ; int end@@ index = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { sum = ( arr [ i ] == 0 ) ? - 1 : 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] == 0 ) sum += - 1 ; else sum += 1 ; if ( sum == 0 && maxsize < j - i + 1 ) { maxsize = j - i + 1 ; start@@ index = i ; } } } end@@ index = start@@ index + maxsize - 1 ; if ( maxsize == - 1 ) System . out . println ( " No ▁ such ▁ sub@@ array " ) ; else System . out . println ( start@@ index + " ▁ to ▁ " + end@@ index ) ; return maxsize ; } public static void main ( String [ ] args ) { Largest@@ Sub@@ Array sub ; sub = new Largest@@ Sub@@ Array ( ) ; int arr [ ] = { 1 , 0 , 0 , 1 , 0 , 1 , 1 } ; int size = arr . length ; sub . find@@ Sub@@ Array ( arr , size ) ; } }
import java . io . * ; class GF@@ G { static void findAll@@ Trip@@ lets ( int arr [ ] , int n ) { for ( int i = 1 ; i < n - 1 ; i ++ ) { for ( int j = i - 1 , k = i + 1 ; j >= 0 && k < n ; ) { if ( arr [ j ] + arr [ k ] == 2 * arr [ i ] ) { System . out . println ( arr [ j ] + " ▁ " + arr [ i ] + " ▁ " + arr [ k ] ) ; k ++ ; j -- ; } else if ( arr [ j ] + arr [ k ] < 2 * arr [ i ] ) k ++ ; else j -- ; } } } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 6 , 9 , 12 , 17 , 22 , 31 , 32 , 35 , 42 } ; int n = arr . length ; findAll@@ Trip@@ lets ( arr , n ) ; } }
import java . util . * ; public class Main { public static void find@@ Trip@@ lets ( int a [ ] , int n , int sum ) { int i ; Arrays . sort ( a ) ; boolean flag = false ; for ( i = 0 ; i < n - 2 ; i ++ ) { if ( i == 0 a [ i ] > a [ i - 1 ] ) { int start = i + 1 ; int end = n - 1 ; int target = sum - a [ i ] ; while ( start < end ) { if ( start > i + 1 && a [ start ] == a [ start - 1 ] ) { start ++ ; continue ; } if ( end < n - 1 && a [ end ] == a [ end + 1 ] ) { end -- ; continue ; } if ( target == a [ start ] + a [ end ] ) { System . out . print ( " [ " + a [ i ] + " , " + a [ start ] + " , " + a [ end ] + " ] ▁ " ) ; flag = true ; start ++ ; end -- ; } else if ( target > ( a [ start ] + a [ end ] ) ) { start ++ ; } else { end -- ; } } } } if ( flag == false ) { System . out . print ( " No ▁ Such ▁ Trip@@ lets ▁ Exist " ) ; } } public static void main ( String [ ] args ) { int a [ ] = { 12 , 3 , 6 , 1 , 6 , 9 } ; int n = a . length ; int sum = 24 ; find@@ Trip@@ lets ( a , n , sum ) ; } }
class GF@@ G { static int count@@ Trip@@ lets ( int arr [ ] , int n , int m ) { int count = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) for ( int j = i + 1 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] * arr [ j ] * arr [ k ] == m ) count ++ ; return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 4 , 6 , 2 , 3 , 8 } ; int m = 24 ; System . out . println ( count@@ Trip@@ lets ( arr , arr . length , m ) ) ; } }
import java . util . * ; class ge@@ e@@ ks { public static int su@@ mo@@ f@@ length ( int [ ] arr , int n ) { Set < Integer > s = new HashSet < > ( ) ; int j = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( j < n && ! s . contains ( arr [ j ] ) ) { s . add ( arr [ i ] ) ; j ++ ; } ans += ( ( j - i ) * ( j - i + 1 ) ) / 2 ; s . remove ( arr [ i ] ) ; } return ans ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 4 } ; int n = arr . length ; System . out . println ( su@@ mo@@ f@@ length ( arr , n ) ) ; } }
class Rotate@@ Array { void left@@ Rotate@@ by@@ One ( int arr [ ] , int n ) { int i , temp ; temp = arr [ 0 ] ; for ( i = 0 ; i < n - 1 ; i ++ ) arr [ i ] = arr [ i + 1 ] ; arr [ n - 1 ] = temp ; } void left@@ Rotate ( int arr [ ] , int d , int n ) { for ( int i = 0 ; i < d ; i ++ ) left@@ Rotate@@ by@@ One ( arr , n ) ; } void print@@ Array ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { Rotate@@ Array rotate = new Rotate@@ Array ( ) ; int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; rotate . left@@ Rotate ( arr , 2 , 7 ) ; rotate . print@@ Array ( arr , 7 ) ; } }
class Main { static int search ( int arr [ ] , int l , int h , int key ) { if ( l > h ) return - 1 ; int mid = ( l + h ) / 2 ; if ( arr [ mid ] == key ) return mid ; if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ; return search ( arr , mid + 1 , h , key ) ; } if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 4 , 5 , 6 , 7 , 8 , 9 , 1 , 2 , 3 } ; int n = arr . length ; int key = 6 ; int i = search ( arr , 0 , n - 1 , key ) ; if ( i != - 1 ) System . out . println ( " Index : ▁ " + i ) ; else System . out . println ( " Key ▁ not ▁ found " ) ; } }
class Pair@@ In@@ Sorted@@ Rot@@ ated { static boolean pair@@ In@@ Sorted@@ Rot@@ ated ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; int l = ( i + 1 ) % n ; int r = i ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) return true ; if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 11 , 15 , 6 , 8 , 9 , 10 } ; int sum = 16 ; int n = arr . length ; if ( pair@@ In@@ Sorted@@ Rot@@ ated ( arr , n , sum ) ) System . out . print ( " Array ▁ has ▁ two ▁ elements " + " ▁ with ▁ sum ▁ 16" ) ; else System . out . print ( " Array ▁ doesn ' t ▁ have ▁ two " + " ▁ elements ▁ with ▁ sum ▁ 16 ▁ " ) ; } }
import java . io . * ; class GF@@ G { static void left@@ Rotate ( int arr [ ] , int n , int k ) { for ( int i = k ; i < k + n ; i ++ ) System . out . print ( arr [ i % n ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 5 , 7 , 9 } ; int n = arr . length ; int k = 2 ; left@@ Rotate ( arr , n , k ) ; System . out . println ( ) ; k = 3 ; left@@ Rotate ( arr , n , k ) ; System . out . println ( ) ; k = 4 ; left@@ Rotate ( arr , n , k ) ; System . out . println ( ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class Minimum { static int find@@ Min ( int arr [ ] , int low , int high ) { if ( high < low ) return arr [ 0 ] ; if ( high == low ) return arr [ low ] ; int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return arr [ mid + 1 ] ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ high ] > arr [ mid ] ) return find@@ Min ( arr , low , mid - 1 ) ; return find@@ Min ( arr , mid + 1 , high ) ; } public static void main ( String [ ] args ) { int ar@@ r1 [ ] = { 5 , 6 , 1 , 2 , 3 , 4 } ; int n1 = ar@@ r1 . length ; System . out . println ( " The ▁ minimum ▁ element ▁ is ▁ " + find@@ Min ( ar@@ r1 , 0 , n1 - 1 ) ) ; int ar@@ r2 [ ] = { 1 , 2 , 3 , 4 } ; int n2 = ar@@ r2 . length ; System . out . println ( " The ▁ minimum ▁ element ▁ is ▁ " + find@@ Min ( ar@@ r2 , 0 , n2 - 1 ) ) ; int arr@@ 3 [ ] = { 1 } ; int n3 = arr@@ 3 . length ; System . out . println ( " The ▁ minimum ▁ element ▁ is ▁ " + find@@ Min ( arr@@ 3 , 0 , n3 - 1 ) ) ; int arr@@ 4 [ ] = { 1 , 2 } ; int n@@ 4 = arr@@ 4 . length ; System . out . println ( " The ▁ minimum ▁ element ▁ is ▁ " + find@@ Min ( arr@@ 4 , 0 , n@@ 4 - 1 ) ) ; int arr@@ 5 [ ] = { 2 , 1 } ; int n@@ 5 = arr@@ 5 . length ; System . out . println ( " The ▁ minimum ▁ element ▁ is ▁ " + find@@ Min ( arr@@ 5 , 0 , n@@ 5 - 1 ) ) ; int arr@@ 6 [ ] = { 5 , 6 , 7 , 1 , 2 , 3 , 4 } ; int n@@ 6 = arr@@ 6 . length ; System . out . println ( " The ▁ minimum ▁ element ▁ is ▁ " + find@@ Min ( arr@@ 6 , 0 , n@@ 6 - 1 ) ) ; int arr@@ 7 [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int n@@ 7 = arr@@ 7 . length ; System . out . println ( " The ▁ minimum ▁ element ▁ is ▁ " + find@@ Min ( arr@@ 7 , 0 , n@@ 7 - 1 ) ) ; int arr@@ 8 [ ] = { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 1 } ; int n@@ 8 = arr@@ 8 . length ; System . out . println ( " The ▁ minimum ▁ element ▁ is ▁ " + find@@ Min ( arr@@ 8 , 0 , n@@ 8 - 1 ) ) ; int arr@@ 9 [ ] = { 3 , 4 , 5 , 1 , 2 } ; int n@@ 9 = arr@@ 9 . length ; System . out . println ( " The ▁ minimum ▁ element ▁ is ▁ " + find@@ Min ( arr@@ 9 , 0 , n@@ 9 - 1 ) ) ; } }
import java . util . * ; import java . lang . * ; class GF@@ G { public static void Split@@ And@@ Add ( int [ ] A , int length , int rotation ) { int [ ] tmp = new int [ length * 2 ] ; System . arraycopy ( A , 0 , tmp , 0 , length ) ; System . arraycopy ( A , 0 , tmp , length , length ) ; for ( int i = rotation ; i < rotation + length ; i ++ ) A [ i - rotation ] = tmp [ i ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 12 , 10 , 5 , 6 , 52 , 36 } ; int n = arr . length ; int position = 2 ; Split@@ And@@ Add ( arr , n , position ) ; for ( int i = 0 ; i < n ; ++ i ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
class GF@@ G { static void print@@ Array ( int A [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) System . out . print ( A [ i ] + " ▁ " ) ; System . out . println ( " " ) ; ; } static void reverse ( int arr [ ] , int l , int r ) { if ( l < r ) { arr = swap ( arr , l , r ) ; reverse ( arr , ++ l , -- r ) ; } } static void merge ( int arr [ ] , int l , int m , int r ) { int i = l ; int j = m + 1 ; while ( i <= m && arr [ i ] < 0 ) i ++ ; while ( j <= r && arr [ j ] < 0 ) j ++ ; reverse ( arr , i , m ) ; reverse ( arr , m + 1 , j - 1 ) ; reverse ( arr , i , j - 1 ) ; } static void Re@@ arrange@@ Pos@@ Neg ( int arr [ ] , int l , int r ) { if ( l < r ) { int m = l + ( r - l ) / 2 ; Re@@ arrange@@ Pos@@ Neg ( arr , l , m ) ; Re@@ arrange@@ Pos@@ Neg ( arr , m + 1 , r ) ; merge ( arr , l , m , r ) ; } } static int [ ] swap ( int [ ] arr , int i , int j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; return arr ; } public static void main ( String [ ] args ) { int arr [ ] = { - 12 , 11 , - 13 , - 5 , 6 , - 7 , 5 , - 3 , - 6 } ; int arr_@@ size = arr . length ; Re@@ arrange@@ Pos@@ Neg ( arr , 0 , arr_@@ size - 1 ) ; print@@ Array ( arr , arr_@@ size ) ; } }
import java . util . Arrays ; public class GF@@ G { static void re@@ arrange ( int [ ] arr , int n ) { int temp [ ] = arr . clone ( ) ; int small = 0 , large = n - 1 ; boolean flag = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( flag ) arr [ i ] = temp [ large -- ] ; else arr [ i ] = temp [ small ++ ] ; flag = ! flag ; } } public static void main ( String [ ] args ) { int arr [ ] = new int [ ] { 1 , 2 , 3 , 4 , 5 , 6 } ; System . out . println ( " Original ▁ Array ▁ " ) ; System . out . println ( Arrays . toString ( arr ) ) ; re@@ arrange ( arr , arr . length ) ; System . out . println ( " Modified ▁ Array ▁ " ) ; System . out . println ( Arrays . toString ( arr ) ) ; } }
public class Main { public static void re@@ arrange ( int arr [ ] , int n ) { int max_@@ ele = arr [ n - 1 ] ; int min_@@ ele = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { arr [ i ] = max_@@ ele ; max_@@ ele -= 1 ; } else { arr [ i ] = min_@@ ele ; min_@@ ele += 1 ; } } } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ; int n = arr . length ; System . out . println ( " Original ▁ Array " ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; re@@ arrange ( arr , n ) ; System . out . print ( " Modified Array "@@ )@@ ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
class Node { int data ; Node left , right ; Node ( int item ) { data = item ; left = right = null ; } } class Binary@@ Tree { Node root ; boolean is@@ Leaf ( Node node ) { if ( node == null ) return false ; if ( node . left == null && node . right == null ) return true ; return false ; } int left@@ Le@@ av@@ es@@ Sum ( Node node ) { int res = 0 ; if ( node != null ) { if ( is@@ Leaf ( node . left ) ) res += node . left . data ; else res += left@@ Le@@ av@@ es@@ Sum ( node . left ) ; res += left@@ Le@@ av@@ es@@ Sum ( node . right ) ; } return res ; } public static void main ( String args [ ] ) { Binary@@ Tree tree = new Binary@@ Tree ( ) ; tree . root = new Node ( 20 ) ; tree . root . left = new Node ( 9 ) ; tree . root . right = new Node ( 49 ) ; tree . root . left . right = new Node ( 12 ) ; tree . root . left . left = new Node ( 5 ) ; tree . root . right . left = new Node ( 23 ) ; tree . root . right . right = new Node ( 52 ) ; tree . root . left . right . right = new Node ( 12 ) ; tree . root . right . right . left = new Node ( 50 ) ; System . out . println ( " The ▁ sum ▁ of ▁ leaves ▁ is ▁ " + tree . left@@ Le@@ av@@ es@@ Sum ( tree . root ) ) ; } }
import java . util . Arrays ; class GF@@ G { static void se@@ greg@@ ate@@ Elements ( int arr [ ] , int n ) { int temp [ ] = new int [ n ] ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= 0 ) temp [ j ++ ] = arr [ i ] ; if ( j == n j == 0 ) return ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < 0 ) temp [ j ++ ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; } public static void main ( String arg [ ] ) { int arr [ ] = { 1 , - 1 , - 3 , - 2 , 7 , 5 , 11 , 6 } ; int n = arr . length ; se@@ greg@@ ate@@ Elements ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
import java . io . * ; import java . util . * ; class GF@@ G { static void swap ( int [ ] a , int i , int j ) { int temp = a [ i ] ; a [ i ] = a [ j ] ; a [ j ] = temp ; } static void print@@ Array ( int [ ] a , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; System . out . println ( ) ; } public static void main ( String args [ ] ) { int [ ] arr = { 1 , - 3 , 5 , 6 , - 3 , 6 , 7 , - 4 , 9 , 10 } ; int n = arr . length ; print@@ Array ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= 0 && i % 2 == 1 ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] < 0 && j % 2 == 0 ) { swap ( arr , i , j ) ; break ; } } } else if ( arr [ i ] < 0 && i % 2 == 0 ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] >= 0 && j % 2 == 1 ) { swap ( arr , i , j ) ; break ; } } } } print@@ Array ( arr , n ) ; } }
import java . io . * ; import java . util . * ; class GF@@ G { static int largest ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; return arr [ n - 1 ] ; } static public void main ( String [ ] args ) { int [ ] arr = { 10 , 324 , 45 , 90 , 98@@ 08 } ; int n = arr . length ; System . out . println ( largest ( arr , n ) ) ; } }
import java . util . * ; class GF@@ G { public static double find@@ Mean ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; return ( double ) sum / ( double ) n ; } public static double find@@ Medi@@ an ( int a [ ] , int n ) { Arrays . sort ( a ) ; if ( n % 2 != 0 ) return ( double ) a [ n / 2 ] ; return ( double ) ( a [ ( n - 1 ) / 2 ] + a [ n / 2 ] ) / 2.0 ; } public static void main ( String args [ ] ) { int a [ ] = { 1 , 3 , 4 , 2 , 7 , 5 , 8 , 6 } ; int n = a . length ; System . out . println ( " Mean ▁ = ▁ " + find@@ Mean ( a , n ) ) ; System . out . println ( " Medi@@ an ▁ = ▁ " + find@@ Medi@@ an ( a , n ) ) ; } }
class GF@@ G { static void print@@ 2@@ largest ( int arr [ ] , int arr_@@ size ) { int i , first , second ; if ( arr_@@ size < 2 ) { System . out . printf ( " ▁ Invalid ▁ Input ▁ " ) ; return ; } int largest = second = Integer . MIN_VALUE ; for ( i = 0 ; i < arr_@@ size ; i ++ ) { largest = Math . max ( largest , arr [ i ] ) ; } for ( i = 0 ; i < arr_@@ size ; i ++ ) { if ( arr [ i ] != largest ) second = Math . max ( second , arr [ i ] ) ; } if ( second == Integer . MIN_VALUE ) System . out . printf ( " There ▁ is ▁ no ▁ second ▁ " + "@@ largest element@@ NEW_@@ LINE@@ "@@ )@@ ; else System . out . printf ( " The ▁ second ▁ largest ▁ " + "@@ element is %@@ d@@ NEW_@@ LINE@@ "@@ , second@@ )@@ ; } public static void main ( String [ ] args ) { int arr [ ] = { 12 , 35 , 1 , 10 , 34 , 1 } ; int n = arr . length ; print@@ 2@@ largest ( arr , n ) ; } }
class GF@@ G { public static void print@@ 2@@ largest ( int arr [ ] , int arr_@@ size ) { int i , first , second ; if ( arr_@@ size < 2 ) { System . out . print ( " ▁ Invalid ▁ Input ▁ " ) ; return ; } first = second = Integer . MIN_VALUE ; for ( i = 0 ; i < arr_@@ size ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second && arr [ i ] != first ) second = arr [ i ] ; } if ( second == Integer . MIN_VALUE ) System . out . print ( " There ▁ is ▁ no ▁ second ▁ largest " + " element@@ NEW_@@ LINE@@ "@@ )@@ ; else System . out . print ( " The ▁ second ▁ largest ▁ element " + " ▁ is ▁ " + second ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 12 , 35 , 1 , 10 , 34 , 1 } ; int n = arr . length ; print@@ 2@@ largest ( arr , n ) ; } }
class Maximum@@ Sum { int Find@@ Max@@ Sum ( int arr [ ] , int n ) { int in@@ cl = arr [ 0 ] ; int ex@@ cl = 0 ; int ex@@ cl_@@ new ; int i ; for ( i = 1 ; i < n ; i ++ ) { ex@@ cl_@@ new = ( in@@ cl > ex@@ cl ) ? in@@ cl : ex@@ cl ; in@@ cl = ex@@ cl + arr [ i ] ; ex@@ cl = ex@@ cl_@@ new ; } return ( ( in@@ cl > ex@@ cl ) ? in@@ cl : ex@@ cl ) ; } public static void main ( String [ ] args ) { Maximum@@ Sum sum = new Maximum@@ Sum ( ) ; int arr [ ] = new int [ ] { 5 , 5 , 10 , 100 , 10 , 5 } ; System . out . println ( sum . Find@@ Max@@ Sum ( arr , arr . length ) ) ; } }
import java . io . * ; class GF@@ G { static int max@@ Sub@@ Array@@ Sum ( int a [ ] , int size ) { int max_@@ so@@ _f@@ ar = a [ 0 ] ; int curr_@@ max = a [ 0 ] ; for ( int i = 1 ; i < size ; i ++ ) { curr_@@ max = Math . max ( a [ i ] , curr_@@ max + a [ i ] ) ; max_@@ so@@ _f@@ ar = Math . max ( max_@@ so@@ _f@@ ar , curr_@@ max ) ; } return max_@@ so@@ _f@@ ar ; } public static void main ( String [ ] args ) { int a [ ] = { - 2 , - 3 , 4 , - 1 , - 2 , 1 , 5 , - 3 } ; int n = a . length ; int max_@@ sum = max@@ Sub@@ Array@@ Sum ( a , n ) ; System . out . println ( " Maximum ▁ contiguous ▁ sum ▁ is ▁ " + max_@@ sum ) ; } }
import java . util . * ; import java . io . * ; class GF@@ G { static int min@@ Jump@@ s ( int arr [ ] , int l , int h ) { if ( h == l ) return 0 ; if ( arr [ l ] == 0 ) return Integer . MAX_VALUE ; int min = Integer . MAX_VALUE ; for ( int i = l + 1 ; i <= h && i <= l + arr [ l ] ; i ++ ) { int jumps = min@@ Jump@@ s ( arr , i , h ) ; if ( jumps != Integer . MAX_VALUE && jumps + 1 < min ) min = jumps + 1 ; } return min ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 3 , 6 , 3 , 2 , 3 , 6 , 8 , 9 , 5 } ; int n = arr . length ; System . out . print ( " Minimum ▁ number ▁ of ▁ jumps ▁ to ▁ reach ▁ end ▁ is ▁ " + min@@ Jump@@ s ( arr , 0 , n - 1 ) ) ; } }
class GF@@ G { static int max@@ Sub@@ Array@@ Sum ( int a [ ] , int size ) { int max_@@ so@@ _f@@ ar = Integer . MIN_VALUE , max_@@ ending_@@ here = 0 , start = 0 , end = 0 , s = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_@@ ending_@@ here += a [ i ] ; if ( max_@@ so@@ _f@@ ar < max_@@ ending_@@ here ) { max_@@ so@@ _f@@ ar = max_@@ ending_@@ here ; start = s ; end = i ; } if ( max_@@ ending_@@ here < 0 ) { max_@@ ending_@@ here = 0 ; s = i + 1 ; } } return ( end - start + 1 ) ; } public static void main ( String [ ] args ) { int a [ ] = { - 2 , - 3 , 4 , - 1 , - 2 , 1 , 5 , - 3 } ; int n = a . length ; System . out . println ( max@@ Sub@@ Array@@ Sum ( a , n ) ) ; } }
import java . util . Arrays ; class GF@@ G { static boolean sorted@@ After@@ Swap ( int A [ ] , boolean B [ ] , int n ) { int i , j ; for ( i = 0 ; i < n - 1 ; i ++ ) { if ( B [ i ] ) { j = i ; while ( B [ j ] ) { j ++ ; } Arrays . sort ( A , i , 1 + j ) ; i = j ; } } for ( i = 0 ; i < n ; i ++ ) { if ( A [ i ] != i + 1 ) { return false ; } } return true ; } public static void main ( String [ ] args ) { int A [ ] = { 1 , 2 , 5 , 3 , 4 , 6 } ; boolean B [ ] = { false , true , true , true , false } ; int n = A . length ; if ( sorted@@ After@@ Swap ( A , B , n ) ) { System . out . println ( " A ▁ can ▁ be ▁ sorted " ) ; } else { System . out . println ( " A ▁ can ▁ not ▁ be ▁ sorted " ) ; } } }
import java . io . * ; import java . util . * ; class GF@@ G { static int find@@ NumberOf@@ Triangles ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] + arr [ j ] > arr [ k ] && arr [ i ] + arr [ k ] > arr [ j ] && arr [ k ] + arr [ j ] > arr [ i ] ) count ++ ; } } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 21 , 22 , 100 , 101 , 200 , 300 } ; int size = arr . length ; System . out . println ( " Total ▁ number ▁ of ▁ triangles ▁ possible ▁ is ▁ " + find@@ NumberOf@@ Triangles ( arr , size ) ) ; } }
import java . io . * ; import java . util . * ; class Count@@ Triangles { static int find@@ NumberOf@@ Triangles ( int arr [ ] ) { int n = arr . length ; Arrays . sort ( arr ) ; int count = 0 ; for ( int i = 0 ; i < n - 2 ; ++ i ) { int k = i + 2 ; for ( int j = i + 1 ; j < n ; ++ j ) { while ( k < n && arr [ i ] + arr [ j ] > arr [ k ] ) ++ k ; if ( k > j ) count += k - j - 1 ; } } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 21 , 22 , 100 , 101 , 200 , 300 } ; System . out . println ( " Total ▁ number ▁ of ▁ triangles ▁ is ▁ " + find@@ NumberOf@@ Triangles ( arr ) ) ; } }
class Equi@@ lib@@ ri@@ um@@ Index { int equi@@ lib@@ ri@@ um ( int arr [ ] , int n ) { int i , j ; int left@@ sum , right@@ sum ; for ( i = 0 ; i < n ; ++ i ) { left@@ sum = 0 ; right@@ sum = 0 ; for ( j = 0 ; j < i ; j ++ ) left@@ sum += arr [ j ] ; for ( j = i + 1 ; j < n ; j ++ ) right@@ sum += arr [ j ] ; if ( left@@ sum == right@@ sum ) return i ; } return - 1 ; } public static void main ( String [ ] args ) { Equi@@ lib@@ ri@@ um@@ Index equ@@ i = new Equi@@ lib@@ ri@@ um@@ Index ( ) ; int arr [ ] = { - 7 , 1 , 5 , 2 , - 4 , 3 , 0 } ; int arr_@@ size = arr . length ; System . out . println ( equ@@ i . equi@@ lib@@ ri@@ um ( arr , arr_@@ size ) ) ; } }
class Main { static int ceil@@ Search ( int arr [ ] , int low , int high , int x ) { int i ; if ( x <= arr [ low ] ) return low ; for ( i = low ; i < high ; i ++ ) { if ( arr [ i ] == x ) return i ; if ( arr [ i ] < x && arr [ i + 1 ] >= x ) return i + 1 ; } return - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 8 , 10 , 10 , 12 , 19 } ; int n = arr . length ; int x = 3 ; int index = ceil@@ Search ( arr , 0 , n - 1 , x ) ; if ( index == - 1 ) System . out . println ( " Ceil@@ ing ▁ of ▁ " + x + " ▁ doesn ' t ▁ exist ▁ in ▁ array " ) ; else System . out . println ( " ceiling ▁ of ▁ " + x + " ▁ is ▁ " + arr [ index ] ) ; } }
class Maj@@ ority@@ Element { int find@@ Candidate ( int a [ ] , int size ) { int maj@@ _index = 0 , count = 1 ; int i ; for ( i = 1 ; i < size ; i ++ ) { if ( a [ maj@@ _index ] == a [ i ] ) count ++ ; else count -- ; if ( count == 0 ) { maj@@ _index = i ; count = 1 ; } } return a [ maj@@ _index ] ; } boolean is@@ Maj@@ ority ( int a [ ] , int size , int c@@ and ) { int i , count = 0 ; for ( i = 0 ; i < size ; i ++ ) { if ( a [ i ] == c@@ and ) count ++ ; } if ( count > size / 2 ) return true ; else return false ; } void print@@ Maj@@ ority ( int a [ ] , int size ) { int c@@ and = find@@ Candidate ( a , size ) ; if ( is@@ Maj@@ ority ( a , size , c@@ and ) ) System . out . println ( " ▁ " + c@@ and + " ▁ " ) ; else System . out . println ( " No ▁ Maj@@ ority ▁ Element " ) ; } public static void main ( String [ ] args ) { Maj@@ ority@@ Element ma@@ jo@@ re@@ lement = new Maj@@ ority@@ Element ( ) ; int a [ ] = new int [ ] { 1 , 3 , 3 , 1 , 2 } ; int size = a . length ; ma@@ jo@@ re@@ lement . print@@ Maj@@ ority ( a , size ) ; } }
class GF@@ G { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static int find@@ Root ( pair arr [ ] , int n ) { int root = 0 ; for ( int i = 0 ; i < n ; i ++ ) { root += ( arr [ i ] . first - arr [ i ] . second ) ; } return root ; } public static void main ( String [ ] args ) { pair arr [ ] = { new pair ( 1 , 5 ) , new pair ( 2 , 0 ) , new pair ( 3 , 0 ) , new pair ( 4 , 0 ) , new pair ( 5 , 5 ) , new pair ( 6 , 5 ) } ; int n = arr . length ; System . out . printf ( "@@ %@@ d@@ NEW_@@ LINE@@ "@@ , find@@ Root@@ (@@ arr@@ , n@@ )@@ )@@ ; } }
class Binary@@ Tree { void fill@@ Depth ( int parent [ ] , int i , int depth [ ] ) { if ( depth [ i ] != 0 ) { return ; } if ( parent [ i ] == - 1 ) { depth [ i ] = 1 ; return ; } if ( depth [ parent [ i ] ] == 0 ) { fill@@ Depth ( parent , parent [ i ] , depth ) ; } depth [ i ] = depth [ parent [ i ] ] + 1 ; } int find@@ Height ( int parent [ ] , int n ) { int depth [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { depth [ i ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { fill@@ Depth ( parent , i , depth ) ; } int ht = depth [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( ht < depth [ i ] ) { ht = depth [ i ] ; } } return ht ; } public static void main ( String args [ ] ) { Binary@@ Tree tree = new Binary@@ Tree ( ) ; int parent [ ] = new int [ ] { - 1 , 0 , 0 , 1 , 1 , 3 , 5 } ; int n = parent . length ; System . out . println ( " Height ▁ is ▁ " + tree . find@@ Height ( parent , n ) ) ; } }
import java . io . * ; class GF@@ G { public void getPost@@ Order@@ B@@ ST ( int pre [ ] ) { int pivot@@ Point = 0 ; for ( int i = 1 ; i < pre . length ; i ++ ) { if ( pre [ 0 ] <= pre [ i ] ) { pivot@@ Point = i ; break ; } } for ( int i = pivot@@ Point - 1 ; i > 0 ; i -- ) { System . out . print ( pre [ i ] + " ▁ " ) ; } for ( int i = pre . length - 1 ; i >= pivot@@ Point ; i -- ) { System . out . print ( pre [ i ] + " ▁ " ) ; } System . out . print ( pre [ 0 ] ) ; }
class Node { int data ; Node left , right ; public Node ( int item ) { data = item ; left = right = null ; } } public class Binary@@ Tree { Node root ; int minimum@@ Depth ( ) { return minimum@@ Depth ( root ) ; } int minimum@@ Depth ( Node root ) { if ( root == null ) return 0 ; if ( root . left == null && root . right == null ) return 1 ; if ( root . left == null ) return minimum@@ Depth ( root . right ) + 1 ; if ( root . right == null ) return minimum@@ Depth ( root . left ) + 1 ; return Math . min ( minimum@@ Depth ( root . left ) , minimum@@ Depth ( root . right ) ) + 1 ; } public static void main ( String args [ ] ) { Binary@@ Tree tree = new Binary@@ Tree ( ) ; tree . root = new Node ( 1 ) ; tree . root . left = new Node ( 2 ) ; tree . root . right = new Node ( 3 ) ; tree . root . left . left = new Node ( 4 ) ; tree . root . left . right = new Node ( 5 ) ; System . out . println ( " The ▁ minimum ▁ depth ▁ of ▁ " + " binary ▁ tree ▁ is ▁ : ▁ " + tree . minimum@@ Depth ( ) ) ; } }
if ( in@@ M@@ ST [ v ] == false && key [ v ] > weight ) { key [ v ] = weight ; pq . add ( new Pair < Integer , Integer > ( key [ v ] , v ) ) ; parent [ v ] = u ; }
import java . io . * ; class GF@@ G { static int size = 4 ; static boolean check@@ Star ( int mat [ ] [ ] ) { int vertex@@ D1 = 0 , vertex@@ D@@ n_@@ 1 = 0 ; if ( size == 1 ) return ( mat [ 0 ] [ 0 ] == 0 ) ; if ( size == 2 ) return ( mat [ 0 ] [ 0 ] == 0 && mat [ 0 ] [ 1 ] == 1 && mat [ 1 ] [ 0 ] == 1 && mat [ 1 ] [ 1 ] == 0 ) ; for ( int i = 0 ; i < size ; i ++ ) { int degree@@ I = 0 ; for ( int j = 0 ; j < size ; j ++ ) if ( mat [ i ] [ j ] == 1 ) degree@@ I ++ ; if ( degree@@ I == 1 ) vertex@@ D1 ++ ; else if ( degree@@ I == size - 1 ) vertex@@ D@@ n_@@ 1 ++ ; } return ( vertex@@ D1 == ( size - 1 ) && vertex@@ D@@ n_@@ 1 == 1 ) ; } public static void main ( String args [ ] ) { int mat [ ] [ ] = { { 0 , 1 , 1 , 1 } , { 1 , 0 , 0 , 0 } , { 1 , 0 , 0 , 0 } , { 1 , 0 , 0 , 0 } } ; if ( check@@ Star ( mat ) ) System . out . print ( " Star ▁ Graph " ) ; else System . out . print ( " Not ▁ a ▁ Star ▁ Graph " ) ; } }
class Gf@@ G { static class Node { int data ; Node left , right ; } static Node newNode ( int data ) { Node temp = new Node ( ) ; temp . data = data ; temp . right = null ; temp . left = null ; return temp ; } static Node K@@ th@@ Largest@@ Using@@ Mor@@ ris@@ Traversal ( Node root , int k ) { Node curr = root ; Node K@@ largest = null ; int count = 0 ; while ( curr != null ) { if ( curr . right == null ) { if ( ++ count == k ) K@@ largest = curr ; curr = curr . left ; } else { Node succ = curr . right ; while ( succ . left != null && succ . left != curr ) succ = succ . left ; if ( succ . left == null ) { succ . left = curr ; curr = curr . right ; } else { succ . left = null ; if ( ++ count == k ) K@@ largest = curr ; curr = curr . left ; } } } return K@@ largest ; } public static void main ( String [ ] args ) { Node root = newNode ( 4 ) ; root . left = newNode ( 2 ) ; root . right = newNode ( 7 ) ; root . left . left = newNode ( 1 ) ; root . left . right = newNode ( 3 ) ; root . right . left = newNode ( 6 ) ; root . right . right = newNode ( 10 ) ; System . out . println ( " Fin@@ ding ▁ K - th ▁ largest ▁ Node ▁ in ▁ B@@ ST ▁ : ▁ " + K@@ th@@ Largest@@ Using@@ Mor@@ ris@@ Traversal ( root , 2 ) . data ) ; } }
import java . util . * ; public class TreeNode { int val ; TreeNode left ; TreeNode right ; TreeNode ( int x ) { val = x ; } } class Binary@@ Tree { static Set < TreeNode > set = new HashSet < > ( ) ; static Stack < TreeNode > stack = new Stack < > ( ) ; public TreeNode build@@ Tree ( int [ ] pre@@ order , int [ ] in@@ order ) { TreeNode root = null ; for ( int pre = 0 , in = 0 ; pre < pre@@ order . length ; ) { TreeNode node = null ; do { node = new TreeNode ( pre@@ order [ pre ] ) ; if ( root == null ) { root = node ; } if ( ! stack . isEmpty ( ) ) { if ( set . contains ( stack . peek ( ) ) ) { set . remove ( stack . peek ( ) ) ; stack . pop ( ) . right = node ; } else { stack . peek ( ) . left = node ; } } stack . push ( node ) ; } while ( pre@@ order [ pre ++ ] != in@@ order [ in ] && pre < pre@@ order . length ) ; node = null ; while ( ! stack . isEmpty ( ) && in < in@@ order . length && stack . peek ( ) . val == in@@ order [ in ] ) { node = stack . pop ( ) ; in ++ ; } if ( node != null ) { set . add ( node ) ; stack . push ( node ) ; } } return root ; } void print@@ In@@ order ( TreeNode node ) { if ( node == null ) return ; print@@ In@@ order ( node . left ) ; System . out . print ( node . val + " ▁ " ) ; print@@ In@@ order ( node . right ) ; } public static void main ( String args [ ] ) { Binary@@ Tree tree = new Binary@@ Tree ( ) ; int in [ ] = new int [ ] { 9 , 8 , 4 , 2 , 10 , 5 , 10 , 1 , 6 , 3 , 13 , 12 , 7 } ; int pre [ ] = new int [ ] { 1 , 2 , 4 , 8 , 9 , 5 , 10 , 10 , 3 , 6 , 7 , 12 , 13 } ; int len = in . length ; TreeNode root = tree . build@@ Tree ( pre , in ) ; tree . print@@ In@@ order ( root ) ; } }
class Solution { static class Node { Node left , right ; int data ; } static Node createNode ( int x ) { Node p = new Node ( ) ; p . data = x ; p . left = p . right = null ; return p ; } static void insert@@ Node ( Node root , int x ) { Node p = root , q = null ; while ( p != null ) { q = p ; if ( p . data < x ) p = p . right ; else p = p . left ; } if ( q == null ) p = createNode ( x ) ; else { if ( q . data < x ) q . right = createNode ( x ) ; else q . left = createNode ( x ) ; } } static int max@@ el@@ path ( Node q , int x ) { Node p = q ; int mx = - 1 ; while ( p . data != x ) { if ( p . data > x ) { mx = Math . max ( mx , p . data ) ; p = p . left ; } else { mx = Math . max ( mx , p . data ) ; p = p . right ; } } return Math . max ( mx , x ) ; } static int maximum@@ Element ( Node root , int x , int y ) { Node p = root ; while ( ( x < p . data && y < p . data ) || ( x > p . data && y > p . data ) ) { if ( x < p . data && y < p . data ) p = p . left ; else if ( x > p . data && y > p . data ) p = p . right ; } return Math . max ( max@@ el@@ path ( p , x ) , max@@ el@@ path ( p , y ) ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 18 , 36 , 9 , 6 , 12 , 10 , 1 , 8 } ; int a = 1 , b = 10 ; int n = arr . length ; Node root = createNode ( arr [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) insert@@ Node ( root , arr [ i ] ) ; System . out . println ( maximum@@ Element ( root , a , b ) ) ; } }
class GF@@ G { static int i = 0 ; static boolean is@@ Leaf ( int pre [ ] , int n , int min , int max ) { if ( i >= n ) { return false ; } if ( pre [ i ] > min && pre [ i ] < max ) { i ++ ; boolean left = is@@ Leaf ( pre , n , min , pre [ i - 1 ] ) ; boolean right = is@@ Leaf ( pre , n , pre [ i - 1 ] , max ) ; if ( ! left && ! right ) { System . out . print ( pre [ i - 1 ] + " ▁ " ) ; } return true ; } return false ; } static void print@@ Leaves ( int pre@@ order [ ] , int n ) { is@@ Leaf ( pre@@ order , n , Integer . MIN_VALUE , Integer . MAX_VALUE ) ; } public static void main ( String [ ] args ) { int pre@@ order [ ] = { 89@@ 0 , 325 , 29@@ 0 , 5@@ 30 , 96@@ 5 } ; int n = pre@@ order . length ; print@@ Leaves ( pre@@ order , n ) ; } }
import java . io . * ; public class Inter@@ change { static void inter@@ change@@ First@@ Last ( int m [ ] [ ] ) { int rows = m . length ; for ( int i = 0 ; i < m [ 0 ] . length ; i ++ ) { int t = m [ 0 ] [ i ] ; m [ 0 ] [ i ] = m [ rows - 1 ] [ i ] ; m [ rows - 1 ] [ i ] = t ; } } public static void main ( String args [ ] ) throws IOException { int m [ ] [ ] = { { 8 , 9 , 7 , 6 } , { 4 , 7 , 6 , 5 } , { 3 , 2 , 1 , 8 } , { 9 , 9 , 7 , 7 } } ; inter@@ change@@ First@@ Last ( m ) ; for ( int i = 0 ; i < m . length ; i ++ ) { for ( int j = 0 ; j < m [ 0 ] . length ; j ++ ) System . out . print ( m [ i ] [ j ] + " ▁ " ) ; System . out . println ( ) ; } } }
class Node { int data ; Node left , right ; public Node ( int data ) { this . data = data ; left = right = null ; } } class Binary@@ Tree { Node build@@ Util ( int in [ ] , int post [ ] , int in@@ Str@@ t , int in@@ End , int post@@ Str@@ t , int post@@ End ) { if ( in@@ Str@@ t > in@@ End ) return null ; Node node = new Node ( post [ post@@ End ] ) ; if ( in@@ Str@@ t == in@@ End ) return node ; int iIndex = search ( in , in@@ Str@@ t , in@@ End , node . data ) ; node . left = build@@ Util ( in , post , in@@ Str@@ t , iIndex - 1 , post@@ Str@@ t , post@@ Str@@ t - in@@ Str@@ t + iIndex - 1 ) ; node . right = build@@ Util ( in , post , iIndex + 1 , in@@ End , post@@ End - in@@ End + iIndex , post@@ End - 1 ) ; return node ; } int search ( int arr [ ] , int str@@ t , int end , int value ) { int i ; for ( i = str@@ t ; i <= end ; i ++ ) { if ( arr [ i ] == value ) break ; } return i ; } void pre@@ Order ( Node node ) { if ( node == null ) return ; System . out . print ( node . data + " ▁ " ) ; pre@@ Order ( node . left ) ; pre@@ Order ( node . right ) ; } public static void main ( String [ ] args ) { Binary@@ Tree tree = new Binary@@ Tree ( ) ; int in [ ] = new int [ ] { 4 , 8 , 2 , 5 , 1 , 6 , 3 , 7 } ; int post [ ] = new int [ ] { 8 , 4 , 5 , 2 , 6 , 7 , 3 , 1 } ; int n = in . length ; Node root = tree . build@@ Util ( in , post , 0 , n - 1 , 0 , n - 1 ) ; System . out . println ( " Pre@@ order ▁ of ▁ the ▁ constructed ▁ tree ▁ : ▁ " ) ; tree . pre@@ Order ( root ) ; } }
import java . io . * ; import java . util . * ; class GF@@ G { static int col@@ a = 2 , row@@ a = 3 , col@@ b = 3 , row@@ b = 2 ; static void K@@ ron@@ ec@@ ker@@ product ( int A [ ] [ ] , int B [ ] [ ] ) { int [ ] [ ] C = new int [ row@@ a * row@@ b ] [ col@@ a * col@@ b ] ; for ( int i = 0 ; i < row@@ a ; i ++ ) { for ( int k = 0 ; k < row@@ b ; k ++ ) { for ( int j = 0 ; j < col@@ a ; j ++ ) { for ( int l = 0 ; l < col@@ b ; l ++ ) { C [ i + l + 1 ] [ j + k + 1 ] = A [ i ] [ j ] * B [ k ] [ l ] ; System . out . print ( C [ i + l + 1 ] [ j + k + 1 ] + " ▁ " ) ; } } System . out . println ( ) ; } } } public static void main ( String [ ] args ) { int A [ ] [ ] = { { 1 , 2 } , { 3 , 4 } , { 1 , 0 } } ; int B [ ] [ ] = { { 0 , 5 , 2 } , { 6 , 7 , 3 } } ; K@@ ron@@ ec@@ ker@@ product ( A , B ) ; } }
import java . util . * ; import java . lang . * ; public class Gf@@ G { public static int find ( int n , int k ) { if ( n + 1 >= k ) return ( k - 1 ) ; else return ( 2 * n + 1 - k ) ; } public static void main ( String argc [ ] ) { int n = 4 , k = 7 ; int freq = find ( n , k ) ; if ( freq < 0 ) System . out . print ( " ▁ element " + " not exist NEW_LINE "@@ )@@ ; else System . out . print ( " ▁ Frequency " + " ▁ of ▁ " + k + " ▁ is ▁ " + freq + "@@ NEW_@@ LINE@@ "@@ )@@ ; } }
class GF@@ G { static int identity ( int num ) { int row , col ; for ( row = 0 ; row < num ; row ++ ) { for ( col = 0 ; col < num ; col ++ ) { if ( row == col ) System . out . print ( 1 + " ▁ " ) ; else System . out . print ( 0 + " ▁ " ) ; } System . out . println ( ) ; } return 0 ; } public static void main ( String args [ ] ) { int size = 5 ; identity ( size ) ; } }
import java . util . * ; class GF@@ G { static int MAX = 100 ; static void image@@ Swap ( int mat [ ] [ ] , int n ) { int row = 0 ; for ( int j = 0 ; j < n ; j ++ ) { Stack < Integer > s = new Stack < > ( ) ; int i = row , k = j ; while ( i < n && k >= 0 ) { s . push ( mat [ i ++ ] [ k -- ] ) ; } i = row ; k = j ; while ( i < n && k >= 0 ) { mat [ i ++ ] [ k -- ] = s . peek ( ) ; s . pop ( ) ; } } int column = n - 1 ; for ( int j = 1 ; j < n ; j ++ ) { Stack < Integer > s = new Stack < > ( ) ; int i = j , k = column ; while ( i < n && k >= 0 ) { s . push ( mat [ i ++ ] [ k -- ] ) ; } i = j ; k = column ; while ( i < n && k >= 0 ) { mat [ i ++ ] [ k -- ] = s . peek ( ) ; s . pop ( ) ; } } } static void print@@ Matrix ( int mat [ ] [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { System . out . print ( mat [ i ] [ j ] + " ▁ " ) ; } System . out . println ( " " ) ; } } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } , { 9 , 10 , 11 , 12 } , { 13 , 14 , 15 , 16 } } ; int n = 4 ; image@@ Swap ( mat , n ) ; print@@ Matrix ( mat , n ) ; } }
import java . io . * ; class GF@@ G { static int R = 4 ; static int C = 4 ; static int getTotal@@ Coverage@@ Of@@ Matrix ( int [ ] [ ] mat ) { int res = 0 ; for ( int i = 0 ; i < R ; i ++ ) { boolean is@@ One = false ; for ( int j = 0 ; j < C ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) is@@ One = true ; else if ( is@@ One ) res ++ ; } is@@ One = false ; for ( int j = C - 1 ; j >= 0 ; j -- ) { if ( mat [ i ] [ j ] == 1 ) is@@ One = true ; else if ( is@@ One ) res ++ ; } } for ( int j = 0 ; j < C ; j ++ ) { boolean is@@ One = false ; for ( int i = 0 ; i < R ; i ++ ) { if ( mat [ i ] [ j ] == 1 ) is@@ One = true ; else if ( is@@ One ) res ++ ; } is@@ One = false ; for ( int i = R - 1 ; i >= 0 ; i -- ) { if ( mat [ i ] [ j ] == 1 ) is@@ One = true ; else if ( is@@ One ) res ++ ; } } return res ; } static public void main ( String [ ] args ) { int [ ] [ ] mat = { { 0 , 0 , 0 , 0 } , { 1 , 0 , 0 , 1 } , { 0 , 1 , 1 , 0 } , { 0 , 1 , 0 , 0 } } ; System . out . println ( getTotal@@ Coverage@@ Of@@ Matrix ( mat ) ) ; } }
import java . io . * ; class GF@@ G { static int R = 3 ; static int C = 6 ; static void spir@@ al@@ Print ( int m , int n , int [ ] [ ] a , int c ) { int i , k = 0 , l = 0 ; int count = 0 ; while ( k < m && l < n ) { for ( i = l ; i < n ; ++ i ) { count ++ ; if ( count == c ) System . out . println ( a [ k ] [ i ] + " ▁ " ) ; } k ++ ; for ( i = k ; i < m ; ++ i ) { count ++ ; if ( count == c ) System . out . println ( a [ i ] [ n - 1 ] + " ▁ " ) ; } n -- ; if ( k < m ) { for ( i = n - 1 ; i >= l ; -- i ) { count ++ ; if ( count == c ) System . out . println ( a [ m - 1 ] [ i ] + " ▁ " ) ; } m -- ; } if ( l < n ) { for ( i = m - 1 ; i >= k ; -- i ) { count ++ ; if ( count == c ) System . out . println ( a [ i ] [ l ] + " ▁ " ) ; } l ++ ; } } } public static void main ( String [ ] args ) { int a [ ] [ ] = { { 1 , 2 , 3 , 4 , 5 , 6 } , { 7 , 8 , 9 , 10 , 11 , 12 } , { 13 , 14 , 15 , 16 , 17 , 18 } } ; int k = 17 ; spir@@ al@@ Print ( R , C , a , k ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class GF@@ G { static int count@@ Negative ( int M [ ] [ ] , int n , int m ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( M [ i ] [ j ] < 0 ) count += 1 ; else break ; } } return count ; } public static void main ( String [ ] args ) { int M [ ] [ ] = { { - 3 , - 2 , - 1 , 1 } , { - 2 , 2 , 3 , 4 } , { 4 , 5 , 7 , 8 } } ; System . out . println ( count@@ Negative ( M , 3 , 4 ) ) ; } }
import java . io . * ; class GF@@ G { static int N = 10 ; static int find@@ Largest@@ Plus ( int mat [ ] [ ] ) { int left [ ] [ ] = new int [ N ] [ N ] ; int right [ ] [ ] = new int [ N ] [ N ] ; int top [ ] [ ] = new int [ N ] [ N ] ; int bottom [ ] [ ] = new int [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { top [ 0 ] [ i ] = mat [ 0 ] [ i ] ; bottom [ N - 1 ] [ i ] = mat [ N - 1 ] [ i ] ; left [ i ] [ 0 ] = mat [ i ] [ 0 ] ; right [ i ] [ N - 1 ] = mat [ i ] [ N - 1 ] ; } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 1 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) left [ i ] [ j ] = left [ i ] [ j - 1 ] + 1 ; else left [ i ] [ j ] = 0 ; if ( mat [ j ] [ i ] == 1 ) top [ j ] [ i ] = top [ j - 1 ] [ i ] + 1 ; else top [ j ] [ i ] = 0 ; j = N - 1 - j ; if ( mat [ j ] [ i ] == 1 ) bottom [ j ] [ i ] = bottom [ j + 1 ] [ i ] + 1 ; else bottom [ j ] [ i ] = 0 ; if ( mat [ i ] [ j ] == 1 ) right [ i ] [ j ] = right [ i ] [ j + 1 ] + 1 ; else right [ i ] [ j ] = 0 ; j = N - 1 - j ; } } int n = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int len = Math . min ( Math . min ( top [ i ] [ j ] , bottom [ i ] [ j ] ) , Math . min ( left [ i ] [ j ] , right [ i ] [ j ] ) ) ; if ( len > n ) n = len ; } } if ( n > 0 ) return 4 * ( n - 1 ) + 1 ; return 0 ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 1 } , { 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 1 } , { 1 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 } , { 0 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 0 } , { 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 } , { 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 } , { 1 , 0 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 1 } , { 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 } , { 1 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 0 } } ; System . out . println ( find@@ Largest@@ Plus ( mat ) ) ; } }
class GF@@ G { static final int N = 4 ; static void add ( int A [ ] [ ] , int B [ ] [ ] , int C [ ] [ ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] ; } public static void main ( String [ ] args ) { int A [ ] [ ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int B [ ] [ ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int C [ ] [ ] = new int [ N ] [ N ] ; int i , j ; add ( A , B , C ) ; System . out . print ( "@@ Result matrix is NEW_@@ LINE@@ "@@ )@@ ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) System . out . print ( C [ i ] [ j ] + " ▁ " ) ; System . out . print ( "@@ NEW_@@ LINE@@ "@@ )@@ ; } } }
class GF@@ G { static final int N = 4 ; static void subtract ( int A [ ] [ ] , int B [ ] [ ] , int C [ ] [ ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ; } public static void main ( String [ ] args ) { int A [ ] [ ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int B [ ] [ ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int C [ ] [ ] = new int [ N ] [ N ] ; int i , j ; subtract ( A , B , C ) ; System . out . print ( "@@ Result matrix is NEW_@@ LINE@@ "@@ )@@ ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) System . out . print ( C [ i ] [ j ] + " ▁ " ) ; System . out . print ( "@@ NEW_@@ LINE@@ "@@ )@@ ; } } }
import java . util . * ; import java . lang . * ; import java . io . * ; class Peak@@ Element { static int find@@ Peak@@ Util ( int arr [ ] , int low , int high , int n ) { int mid = low + ( high - low ) / 2 ; if ( ( mid == 0 arr [ mid - 1 ] <= arr [ mid ] ) && ( mid == n - 1 arr [ mid + 1 ] <= arr [ mid ] ) ) return mid ; else if ( mid > 0 && arr [ mid - 1 ] > arr [ mid ] ) return find@@ Peak@@ Util ( arr , low , ( mid - 1 ) , n ) ; else return find@@ Peak@@ Util ( arr , ( mid + 1 ) , high , n ) ; } static int find@@ Peak ( int arr [ ] , int n ) { return find@@ Peak@@ Util ( arr , 0 , n - 1 , n ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 20 , 4 , 1 , 0 } ; int n = arr . length ; System . out . println ( " Index ▁ of ▁ a ▁ peak ▁ point ▁ is ▁ " + find@@ Peak ( arr , n ) ) ; } }
class Repeat@@ Element { void print@@ Repe@@ ating ( int arr [ ] , int size ) { int i , j ; System . out . println ( " Repe@@ ated ▁ Elements ▁ are ▁ : " ) ; for ( i = 0 ; i < size ; i ++ ) { for ( j = i + 1 ; j < size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) System . out . print ( arr [ i ] + " ▁ " ) ; } } } public static void main ( String [ ] args ) { Repeat@@ Element repeat = new Repeat@@ Element ( ) ; int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_@@ size = arr . length ; repeat . print@@ Repe@@ ating ( arr , arr_@@ size ) ; } }
class Repeat@@ Element { void print@@ Repe@@ ating ( int arr [ ] , int size ) { int S = 0 ; int P = 1 ; int x , y ; int D ; int n = size - 2 , i ; for ( i = 0 ; i < size ; i ++ ) { S = S + arr [ i ] ; P = P * arr [ i ] ; } S = S - n * ( n + 1 ) / 2 ; P = P / fact ( n ) ; D = ( int ) Math . sqrt ( S * S - 4 * P ) ; x = ( D + S ) / 2 ; y = ( S - D ) / 2 ; System . out . println ( " The ▁ two ▁ repe@@ ating ▁ elements ▁ are ▁ : " ) ; System . out . print ( x + " ▁ " + y ) ; } int fact ( int n ) { return ( n == 0 ) ? 1 : n * fact ( n - 1 ) ; } public static void main ( String [ ] args ) { Repeat@@ Element repeat = new Repeat@@ Element ( ) ; int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_@@ size = arr . length ; repeat . print@@ Repe@@ ating ( arr , arr_@@ size ) ; } }
class Repeat@@ Element { void print@@ Repe@@ ating ( int arr [ ] , int size ) { int xor = arr [ 0 ] ; int set_@@ bit_@@ no ; int i ; int n = size - 2 ; int x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) xor ^= arr [ i ] ; for ( i = 1 ; i <= n ; i ++ ) xor ^= i ; set_@@ bit_@@ no = ( xor & ~ ( xor - 1 ) ) ; for ( i = 0 ; i < size ; i ++ ) { int a = arr [ i ] & set_@@ bit_@@ no ; if ( a != 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } for ( i = 1 ; i <= n ; i ++ ) { int a = i & set_@@ bit_@@ no ; if ( a != 0 ) x = x ^ i ; else y = y ^ i ; } System . out . println ( " The ▁ two ▁ re@@ pp@@ e@@ ated ▁ elements ▁ are ▁ : " ) ; System . out . println ( x + " ▁ " + y ) ; } public static void main ( String [ ] args ) { Repeat@@ Element repeat = new Repeat@@ Element ( ) ; int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_@@ size = arr . length ; repeat . print@@ Repe@@ ating ( arr , arr_@@ size ) ; } }
class Main { static int linear@@ Search ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == i ) return i ; } return - 1 ; } public static void main ( String args [ ] ) { int arr [ ] = { - 10 , - 1 , 0 , 3 , 10 , 11 , 30 , 50 , 100 } ; int n = arr . length ; System . out . println ( " Fixed ▁ Point ▁ is ▁ " + linear@@ Search ( arr , n ) ) ; } }
class Sub@@ array@@ Sum { int sub@@ Array@@ Sum ( int arr [ ] , int n , int sum ) { int curr_@@ sum = arr [ 0 ] , start = 0 , i ; for ( i = 1 ; i <= n ; i ++ ) { while ( curr_@@ sum > sum && start < i - 1 ) { curr_@@ sum = curr_@@ sum - arr [ start ] ; start ++ ; } if ( curr_@@ sum == sum ) { int p = i - 1 ; System . out . println ( " Sum ▁ found ▁ between ▁ indexes ▁ " + start + " ▁ and ▁ " + p ) ; return 1 ; } if ( i < n ) curr_@@ sum = curr_@@ sum + arr [ i ] ; } System . out . println ( " No ▁ sub@@ array ▁ found " ) ; return 0 ; } public static void main ( String [ ] args ) { Sub@@ array@@ Sum array@@ sum = new Sub@@ array@@ Sum ( ) ; int arr [ ] = { 15 , 2 , 4 , 8 , 9 , 5 , 10 , 23 } ; int n = arr . length ; int sum = 23 ; array@@ sum . sub@@ Array@@ Sum ( arr , n , sum ) ; } }
import java . util . Arrays ; class GF@@ G { static int maximum ( int a , int b , int c ) { return Math . max ( Math . max ( a , b ) , c ) ; } static int minimum ( int a , int b , int c ) { return Math . min ( Math . min ( a , b ) , c ) ; } static void smalle@@ st@@ Difference@@ Trip@@ let ( int ar@@ r1 [ ] , int ar@@ r2 [ ] , int arr@@ 3 [ ] , int n ) { Arrays . sort ( ar@@ r1 ) ; Arrays . sort ( ar@@ r2 ) ; Arrays . sort ( arr@@ 3 ) ; int res_@@ min = 0 , res_@@ max = 0 , res@@ _m@@ id = 0 ; int i = 0 , j = 0 , k = 0 ; int diff = 2147483647 ; while ( i < n && j < n && k < n ) { int sum = ar@@ r1 [ i ] + ar@@ r2 [ j ] + arr@@ 3 [ k ] ; int max = maximum ( ar@@ r1 [ i ] , ar@@ r2 [ j ] , arr@@ 3 [ k ] ) ; int min = minimum ( ar@@ r1 [ i ] , ar@@ r2 [ j ] , arr@@ 3 [ k ] ) ; if ( min == ar@@ r1 [ i ] ) i ++ ; else if ( min == ar@@ r2 [ j ] ) j ++ ; else k ++ ; if ( diff > ( max - min ) ) { diff = max - min ; res_@@ max = max ; res@@ _m@@ id = sum - ( max + min ) ; res_@@ min = min ; } } System . out . print ( res_@@ max + " , ▁ " + res@@ _m@@ id + " , ▁ " + res_@@ min ) ; } public static void main ( String [ ] args ) { int ar@@ r1 [ ] = { 5 , 2 , 8 } ; int ar@@ r2 [ ] = { 10 , 7 , 12 } ; int arr@@ 3 [ ] = { 9 , 14 , 6 } ; int n = ar@@ r1 . length ; smalle@@ st@@ Difference@@ Trip@@ let ( ar@@ r1 , ar@@ r2 , arr@@ 3 , n ) ; } }
class Find@@ Trip@@ let { boolean find@@ 3@@ Numbers ( int A [ ] , int arr_@@ size , int sum ) { int l , r ; for ( int i = 0 ; i < arr_@@ size - 2 ; i ++ ) { for ( int j = i + 1 ; j < arr_@@ size - 1 ; j ++ ) { for ( int k = j + 1 ; k < arr_@@ size ; k ++ ) { if ( A [ i ] + A [ j ] + A [ k ] == sum ) { System . out . print ( " Trip@@ let ▁ is ▁ " + A [ i ] + " , ▁ " + A [ j ] + " , ▁ " + A [ k ] ) ; return true ; } } } } return false ; } public static void main ( String [ ] args ) { Find@@ Trip@@ let trip@@ let = new Find@@ Trip@@ let ( ) ; int A [ ] = { 1 , 4 , 45 , 6 , 10 , 8 } ; int sum = 22 ; int arr_@@ size = A . length ; trip@@ let . find@@ 3@@ Numbers ( A , arr_@@ size , sum ) ; } }
class Test { static int arr [ ] = new int [ ] { 1 , 2 , 3 , 4 } ; static void sub@@ Array ( int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { for ( int k = i ; k <= j ; k ++ ) System . out . print ( arr [ k ] + " ▁ " ) ; } } } public static void main ( String [ ] args ) { System . out . println ( " All ▁ Non - empty ▁ Sub@@ arrays " ) ; sub@@ Array ( arr . length ) ; } }
class Are@@ Con@@ sec@@ utive { boolean are@@ Con@@ sec@@ utive ( int arr [ ] , int n ) { if ( n < 1 ) return false ; int min = get@@ Min ( arr , n ) ; int max = getMax ( arr , n ) ; if ( max - min + 1 == n ) { boolean visited [ ] = new boolean [ n ] ; int i ; for ( i = 0 ; i < n ; i ++ ) { if ( visited [ arr [ i ] - min ] != false ) return false ; visited [ arr [ i ] - min ] = true ; } return true ; } return false ; } int get@@ Min ( int arr [ ] , int n ) { int min = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < min ) min = arr [ i ] ; } return min ; } int getMax ( int arr [ ] , int n ) { int max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } return max ; } public static void main ( String [ ] args ) { Are@@ Con@@ sec@@ utive consecutive = new Are@@ Con@@ sec@@ utive ( ) ; int arr [ ] = { 5 , 4 , 2 , 3 , 1 , 6 } ; int n = arr . length ; if ( consecutive . are@@ Con@@ sec@@ utive ( arr , n ) == true ) System . out . println ( " Array ▁ elements ▁ are ▁ consecutive " ) ; else System . out . println ( " Array ▁ elements ▁ are ▁ not ▁ consecutive " ) ; } }
class GF@@ G { public static int search ( int arr [ ] , int x ) { int n = arr . length ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) return i ; } return - 1 ; } public static void main ( String args [ ] ) { int arr [ ] = { 2 , 3 , 4 , 10 , 40 } ; int x = 10 ; int result = search ( arr , x ) ; if ( result == - 1 ) System . out . print ( " Element ▁ is ▁ not ▁ present ▁ in ▁ array " ) ; else System . out . print ( " Element ▁ is ▁ present ▁ at ▁ index ▁ " + result ) ; } }
class Binary@@ Search { int binary@@ Search ( int arr [ ] , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binary@@ Search ( arr , l , mid - 1 , x ) ; return binary@@ Search ( arr , mid + 1 , r , x ) ; } return - 1 ; } public static void main ( String args [ ] ) { Binary@@ Search ob = new Binary@@ Search ( ) ; int arr [ ] = { 2 , 3 , 4 , 10 , 40 } ; int n = arr . length ; int x = 10 ; int result = ob . binary@@ Search ( arr , 0 , n - 1 , x ) ; if ( result == - 1 ) System . out . println ( " Element ▁ not ▁ present " ) ; else System . out . println ( " Element ▁ found ▁ at ▁ index ▁ " + result ) ; } }
class Counting@@ Sort { void sort ( char arr [ ] ) { int n = arr . length ; char output [ ] = new char [ n ] ; int count [ ] = new int [ 256 ] ; for ( int i = 0 ; i < 256 ; ++ i ) count [ i ] = 0 ; for ( int i = 0 ; i < n ; ++ i ) ++ count [ arr [ i ] ] ; for ( int i = 1 ; i <= 255 ; ++ i ) count [ i ] += count [ i - 1 ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { output [ count [ arr [ i ] ] - 1 ] = arr [ i ] ; -- count [ arr [ i ] ] ; } for ( int i = 0 ; i < n ; ++ i ) arr [ i ] = output [ i ] ; } public static void main ( String args [ ] ) { Counting@@ Sort ob = new Counting@@ Sort ( ) ; char arr [ ] = { ' g ' , ' e ' , ' e ' , ' k ' , ' s ' , ' f ' , ' o ' , ' r ' , ' g ' , ' e ' , ' e ' , ' k ' , ' s ' } ; ob . sort ( arr ) ; System . out . print ( " Sorted ▁ character ▁ array ▁ is ▁ " ) ; for ( int i = 0 ; i < arr . length ; ++ i ) System . out . print ( arr [ i ] ) ; } }
import java . util . * ; class GF@@ G { static void count@@ Sort ( int [ ] arr ) { int max = Arrays . stream ( arr ) . max ( ) . getAs@@ Int ( ) ; int min = Arrays . stream ( arr ) . min ( ) . getAs@@ Int ( ) ; int range = max - min + 1 ; int count [ ] = new int [ range ] ; int output [ ] = new int [ arr . length ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { count [ arr [ i ] - min ] ++ ; } for ( int i = 1 ; i < count . length ; i ++ ) { count [ i ] += count [ i - 1 ] ; } for ( int i = arr . length - 1 ; i >= 0 ; i -- ) { output [ count [ arr [ i ] - min ] - 1 ] = arr [ i ] ; count [ arr [ i ] - min ] -- ; } for ( int i = 0 ; i < arr . length ; i ++ ) { arr [ i ] = output [ i ] ; } } static void print@@ Array ( int [ ] arr ) { for ( int i = 0 ; i < arr . length ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } System . out . println ( " " ) ; } public static void main ( String [ ] args ) { int [ ] arr = { - 5 , - 10 , 0 , - 3 , 8 , 5 , - 1 , 10 } ; count@@ Sort ( arr ) ; print@@ Array ( arr ) ; } }
import java . util . * ; import java . lang . * ; class GF@@ G { public static void cycle@@ Sort ( int arr [ ] , int n ) { int writes = 0 ; for ( int cycle@@ _start = 0 ; cycle@@ _start <= n - 2 ; cycle@@ _start ++ ) { int item = arr [ cycle@@ _start ] ; int pos = cycle@@ _start ; for ( int i = cycle@@ _start + 1 ; i < n ; i ++ ) if ( arr [ i ] < item ) pos ++ ; if ( pos == cycle@@ _start ) continue ; while ( item == arr [ pos ] ) pos += 1 ; if ( pos != cycle@@ _start ) { int temp = item ; item = arr [ pos ] ; arr [ pos ] = temp ; writes ++ ; } while ( pos != cycle@@ _start ) { pos = cycle@@ _start ; for ( int i = cycle@@ _start + 1 ; i < n ; i ++ ) if ( arr [ i ] < item ) pos += 1 ; while ( item == arr [ pos ] ) pos += 1 ; if ( item != arr [ pos ] ) { int temp = item ; item = arr [ pos ] ; arr [ pos ] = temp ; writes ++ ; } } } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 8 , 3 , 9 , 10 , 10 , 2 , 4 } ; int n = arr . length ; cycle@@ Sort ( arr , n ) ; System . out . println ( " After ▁ sort ▁ : ▁ " ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
class Closest@@ Pair { void print@@ Close@@ st ( int ar@@ 1 [ ] , int ar@@ 2 [ ] , int m , int n , int x ) { int diff = Integer . MAX_VALUE ; int res_@@ l = 0 , res_@@ r = 0 ; int l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( Math . abs ( ar@@ 1 [ l ] + ar@@ 2 [ r ] - x ) < diff ) { res_@@ l = l ; res_@@ r = r ; diff = Math . abs ( ar@@ 1 [ l ] + ar@@ 2 [ r ] - x ) ; } if ( ar@@ 1 [ l ] + ar@@ 2 [ r ] > x ) r -- ; else l ++ ; } System . out . print ( " The ▁ closest ▁ pair ▁ is ▁ [ " + ar@@ 1 [ res_@@ l ] + " , ▁ " + ar@@ 2 [ res_@@ r ] + " ] " ) ; } public static void main ( String args [ ] ) { Closest@@ Pair ob = new Closest@@ Pair ( ) ; int ar@@ 1 [ ] = { 1 , 4 , 5 , 7 } ; int ar@@ 2 [ ] = { 10 , 20 , 30 , 40 } ; int m = ar@@ 1 . length ; int n = ar@@ 2 . length ; int x = 38 ; ob . print@@ Close@@ st ( ar@@ 1 , ar@@ 2 , m , n , x ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class Activity@@ Selection { public static void print@@ Max@@ Activities ( int s [ ] , int f [ ] , int n ) { int i , j ; System . out . print ( " Following ▁ activities ▁ are ▁ selected ▁ : ▁ n " ) ; i = 0 ; System . out . print ( i + " ▁ " ) ; for ( j = 1 ; j < n ; j ++ ) { if ( s [ j ] >= f [ i ] ) { System . out . print ( j + " ▁ " ) ; i = j ; } } } public static void main ( String [ ] args ) { int s [ ] = { 1 , 3 , 0 , 5 , 8 , 5 } ; int f [ ] = { 2 , 4 , 6 , 7 , 9 , 9 } ; int n = s . length ; print@@ Max@@ Activities ( s , f , n ) ; } }
import java . util . * ; class GF@@ G { static int bin@@ omi@@ al@@ Coeff ( int n , int k ) { if ( k > n ) return 0 ; if ( k == 0 k == n ) return 1 ; return bin@@ omi@@ al@@ Coeff ( n - 1 , k - 1 ) + bin@@ omi@@ al@@ Coeff ( n - 1 , k ) ; } public static void main ( String [ ] args ) { int n = 5 , k = 2 ; System . out . printf ( " Value ▁ of ▁ C ( % d , ▁ % d ) ▁ is ▁ % d ▁ " , n , k , bin@@ omi@@ al@@ Coeff ( n , k ) ) ; } }
class GF@@ G { static int getCount ( char keyp@@ ad [ ] [ ] , int n ) { if ( keyp@@ ad == null n <= 0 ) return 0 ; if ( n == 1 ) return 10 ; int row [ ] = { 0 , 0 , - 1 , 0 , 1 } ; int col [ ] = { 0 , - 1 , 0 , 1 , 0 } ; int [ ] [ ] count = new int [ 10 ] [ n + 1 ] ; int i = 0 , j = 0 , k = 0 , move = 0 , ro = 0 , co = 0 , num = 0 ; int next@@ Num = 0 , totalCount = 0 ; for ( i = 0 ; i <= 9 ; i ++ ) { count [ i ] [ 0 ] = 0 ; count [ i ] [ 1 ] = 1 ; } for ( k = 2 ; k <= n ; k ++ ) { for ( i = 0 ; i < 4 ; i ++ ) { for ( j = 0 ; j < 3 ; j ++ ) { if ( keyp@@ ad [ i ] [ j ] != ' * ' && keyp@@ ad [ i ] [ j ] != ' # ' ) { num = keyp@@ ad [ i ] [ j ] - '0' ; count [ num ] [ k ] = 0 ; for ( move = 0 ; move < 5 ; move ++ ) { ro = i + row [ move ] ; co = j + col [ move ] ; if ( ro >= 0 && ro <= 3 && co >= 0 && co <= 2 && keyp@@ ad [ ro ] [ co ] != ' * ' && keyp@@ ad [ ro ] [ co ] != ' # ' ) { next@@ Num = keyp@@ ad [ ro ] [ co ] - '0' ; count [ num ] [ k ] += count [ next@@ Num ] [ k - 1 ] ; } } } } } } totalCount = 0 ; for ( i = 0 ; i <= 9 ; i ++ ) totalCount += count [ i ] [ n ] ; return totalCount ; } public static void main ( String [ ] args ) { char keyp@@ ad [ ] [ ] = { { '1' , '2' , '3' } , { '4' , '5' , '6' } , { '7' , '8' , '9' } , { ' * ' , '0' , ' # ' } } ; System . out . printf ( "@@ Count for numbers of length %@@ d@@ : %@@ d@@ NEW_@@ LINE@@ "@@ , 1@@ , getCount ( keyp@@ ad , 1 ) ) ; System . out . printf ( "@@ Count for numbers of length %@@ d@@ : %@@ d@@ NEW_@@ LINE@@ "@@ , 2@@ , getCount ( keyp@@ ad , 2 ) ) ; System . out . printf ( "@@ Count for numbers of length %@@ d@@ : %@@ d@@ NEW_@@ LINE@@ "@@ , 3@@ , getCount ( keyp@@ ad , 3 ) ) ; System . out . printf ( "@@ Count for numbers of length %@@ d@@ : %@@ d@@ NEW_@@ LINE@@ "@@ , 4@@ , getCount ( keyp@@ ad , 4 ) ) ; System . out . printf ( "@@ Count for numbers of length %@@ d@@ : %@@ d@@ NEW_@@ LINE@@ "@@ , 5@@ , getCount ( keyp@@ ad , 5 ) ) ; } }
class sum_@@ dig { static int count@@ Rec ( int n , int sum ) { if ( n == 0 ) return sum == 0 ? 1 : 0 ; if ( sum == 0 ) return 1 ; int ans = 0 ; for ( int i = 0 ; i <= 9 ; i ++ ) if ( sum - i >= 0 ) ans += count@@ Rec ( n - 1 , sum - i ) ; return ans ; } static int final@@ Count ( int n , int sum ) { int ans = 0 ; for ( int i = 1 ; i <= 9 ; i ++ ) if ( sum - i >= 0 ) ans += count@@ Rec ( n - 1 , sum - i ) ; return ans ; } public static void main ( String args [ ] ) { int n = 2 , sum = 5 ; System . out . println ( final@@ Count ( n , sum ) ) ; } }
public class GF@@ G { private static void find@@ Count ( int n , int sum ) { int start = ( int ) Math . pow ( 10 , n - 1 ) ; int end = ( int ) Math . pow ( 10 , n ) - 1 ; int count = 0 ; int i = start ; while ( i < end ) { int cur = 0 ; int temp = i ; while ( temp != 0 ) { cur += temp % 10 ; temp = temp / 10 ; } if ( cur == sum ) { count ++ ; i += 9 ; } else i ++ ; } System . out . println ( count ) ; } public static void main ( String [ ] args ) { int n = 3 ; int sum = 5 ; find@@ Count ( n , sum ) ; } }
class squares { static int getMin@@ Squ@@ ares ( int n ) { if ( n <= 3 ) return n ; int res = n ; for ( int x = 1 ; x <= n ; x ++ ) { int temp = x * x ; if ( temp > n ) break ; else res = Math . min ( res , 1 + getMin@@ Squ@@ ares ( n - temp ) ) ; } return res ; } public static void main ( String args [ ] ) { System . out . println ( getMin@@ Squ@@ ares ( 6 ) ) ; } }
import java . io . * ; import java . math . * ; class GF@@ G { static int sum@@ Of@@ Digit@@ sFrom@@ 1@@ To@@ N@@ Util ( int n , int a [ ] ) { if ( n < 10 ) return ( n * ( n + 1 ) / 2 ) ; int d = ( int ) ( Math . log10 ( n ) ) ; int p = ( int ) ( Math . ceil ( Math . pow ( 10 , d ) ) ) ; int ms@@ d = n / p ; return ( ms@@ d * a [ d ] + ( ms@@ d * ( ms@@ d - 1 ) / 2 ) * p + ms@@ d * ( 1 + n % p ) + sum@@ Of@@ Digit@@ sFrom@@ 1@@ To@@ N@@ Util ( n % p , a ) ) ; } static int sum@@ Of@@ Digit@@ sFrom@@ 1@@ To@@ N ( int n ) { int d = ( int ) ( Math . log10 ( n ) ) ; int a [ ] = new int [ d + 1 ] ; a [ 0 ] = 0 ; a [ 1 ] = 45 ; for ( int i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 10 + 45 * ( int ) ( Math . ceil ( Math . pow ( 10 , i - 1 ) ) ) ; return sum@@ Of@@ Digit@@ sFrom@@ 1@@ To@@ N@@ Util ( n , a ) ; } public static void main ( String args [ ] ) { int n = 328 ; System . out . println ( " Sum ▁ of ▁ digits ▁ in ▁ numbers ▁ " + " from ▁ 1 ▁ to ▁ " + n + " ▁ is ▁ " + sum@@ Of@@ Digit@@ sFrom@@ 1@@ To@@ N ( n ) ) ; } }
import java . io . * ; class GF@@ G { static int find@@ optimal ( int N ) { if ( N <= 6 ) return N ; int max = 0 ; int b ; for ( b = N - 3 ; b >= 1 ; b -- ) { int curr = ( N - b - 1 ) * find@@ optimal ( b ) ; if ( curr > max ) max = curr ; } return max ; } public static void main ( String [ ] args ) { int N ; for ( N = 1 ; N <= 20 ; N ++ ) System . out . println ( " Maximum ▁ Number ▁ of ▁ A ' s ▁ with ▁ key@@ stro@@ kes ▁ is ▁ " + N + find@@ optimal ( N ) ) ; } }
class GF@@ G { static void search ( String pat , String txt ) { int M = pat . length ( ) ; int N = txt . length ( ) ; int i = 0 ; while ( i <= N - M ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt . charAt ( i + j ) != pat . charAt ( j ) ) break ; if ( j == M ) { System . out . println ( " Pattern ▁ found ▁ at ▁ index ▁ " + i ) ; i = i + M ; } else if ( j == 0 ) i = i + 1 ; else i = i + j ; } } public static void main ( String [ ] args ) { String txt = " AB@@ CE@@ AB@@ CD@@ AB@@ CE@@ ABC@@ D " ; String pat = " ABC@@ D " ; search ( pat , txt ) ; } }
class GF@@ G { static float power ( float x , int y ) { float temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else { if ( y > 0 ) return x * temp * temp ; else return ( temp * temp ) / x ; } } public static void main ( String [ ] args ) { float x = 2 ; int y = - 3 ; System . out . printf ( " % f " , power ( x , y ) ) ; } }
class Main { static int get@@ Medi@@ an ( int ar@@ 1 [ ] , int ar@@ 2 [ ] , int n ) { int i = 0 ; int j = 0 ; int count ; int m1 = - 1 , m2 = - 1 ; for ( count = 0 ; count <= n ; count ++ ) { if ( i == n ) { m1 = m2 ; m2 = ar@@ 2 [ 0 ] ; break ; } else if ( j == n ) { m1 = m2 ; m2 = ar@@ 1 [ 0 ] ; break ; } if ( ar@@ 1 [ i ] <= ar@@ 2 [ j ] ) { m1 = m2 ; m2 = ar@@ 1 [ i ] ; i ++ ; } else { m1 = m2 ; m2 = ar@@ 2 [ j ] ; j ++ ; } } return ( m1 + m2 ) / 2 ; } public static void main ( String [ ] args ) { int ar@@ 1 [ ] = { 1 , 12 , 15 , 26 , 38 } ; int ar@@ 2 [ ] = { 2 , 13 , 17 , 30 , 45 } ; int n1 = ar@@ 1 . length ; int n2 = ar@@ 2 . length ; if ( n1 == n2 ) System . out . println ( " Medi@@ an ▁ is ▁ " + get@@ Medi@@ an ( ar@@ 1 , ar@@ 2 , n1 ) ) ; else System . out . println ( " arrays ▁ are ▁ of ▁ un@@ equal ▁ size " ) ; } }
class GF@@ G { static float square@@ Root ( float n ) { float x = n ; float y = 1 ; double e = 0.000001 ; while ( x - y > e ) { x = ( x + y ) / 2 ; y = n / x ; } return x ; } public static void main ( String [ ] args ) { int n = 50 ; System . out . printf ( " Square ▁ root ▁ of ▁ " + n + " ▁ is ▁ " + square@@ Root ( n ) ) ; } }
class GF@@ G { static int multiply ( int x , int y ) { if ( y == 0 ) return 0 ; if ( y > 0 ) return ( x + multiply ( x , y - 1 ) ) ; if ( y < 0 ) return - multiply ( x , - y ) ; return - 1 ; } public static void main ( String [ ] args ) { System . out . print ( "@@ NEW_@@ LINE@@ " + multiply@@ (@@ 5@@ , -@@ 11@@ )@@ )@@ ; } }
import java . io . * ; class GF@@ G { static int pow ( int a , int b ) { if ( b == 0 ) return 1 ; int answer = a ; int increment = a ; int i , j ; for ( i = 1 ; i < b ; i ++ ) { for ( j = 1 ; j < a ; j ++ ) { answer += increment ; } increment = answer ; } return answer ; } public static void main ( String [ ] args ) { System . out . println ( pow ( 5 , 3 ) ) ; } }
import java . io . * ; class GF@@ G { static int multiply ( int x , int y ) { if ( y > 0 ) return ( x + multiply ( x , y - 1 ) ) ; else return 0 ; } static int pow ( int a , int b ) { if ( b > 0 ) return multiply ( a , pow ( a , b - 1 ) ) ; else return 1 ; } public static void main ( String [ ] args ) { System . out . println ( pow ( 5 , 3 ) ) ; } }
class GF@@ G { static int sum , n ; static float get@@ Avg ( int x ) { sum += x ; return ( ( ( float ) sum ) / ++ n ) ; } static void stream@@ Avg ( float [ ] arr , int n ) { float avg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { avg = get@@ Avg ( ( int ) arr [ i ] ) ; System . out . println ( " Average ▁ of ▁ " + ( i + 1 ) + " ▁ numbers ▁ is ▁ " + avg ) ; } return ; } public static void main ( String [ ] args ) { float [ ] arr = new float [ ] { 10 , 20 , 30 , 40 , 50 , 60 } ; int n = arr . length ; stream@@ Avg ( arr , n ) ; } }
import java . io . * ; class GF@@ G { static int count ( int n ) { if ( n < 3 ) return n ; if ( n >= 3 && n < 10 ) return n - 1 ; int po = 1 ; while ( n / po > 9 ) po = po * 10 ; int ms@@ d = n / po ; if ( ms@@ d != 3 ) return count ( ms@@ d ) * count ( po - 1 ) + count ( ms@@ d ) + count ( n % po ) ; else return count ( ms@@ d * po - 1 ) ; } public static void main ( String [ ] args ) { int n = 57@@ 8 ; System . out . println ( count ( n ) ) ; } }
import java . io . * ; class GF@@ G { public static void print@@ Pas@@ cal ( int n ) { for ( int line = 1 ; line <= n ; line ++ ) { int C = 1 ; for ( int i = 1 ; i <= line ; i ++ ) { System . out . print ( C + " ▁ " ) ; C = C * ( line - i ) / i ; } System . out . println ( ) ; } } public static void main ( String [ ] args ) { int n = 5 ; print@@ Pas@@ cal ( n ) ; } }
import java . io . * ; class Combination { static void print@@ Combination ( int arr [ ] , int n , int r ) { int data [ ] = new int [ r ] ; combin@@ ation@@ Util ( arr , data , 0 , n - 1 , 0 , r ) ; } static void combin@@ ation@@ Util ( int arr [ ] , int data [ ] , int start , int end , int index , int r ) { if ( index == r ) { for ( int j = 0 ; j < r ; j ++ ) System . out . print ( data [ j ] + " ▁ " ) ; System . out . println ( " " ) ; return ; } for ( int i = start ; i <= end && end - i + 1 >= r - index ; i ++ ) { data [ index ] = arr [ i ] ; combin@@ ation@@ Util ( arr , data , i + 1 , end , index + 1 , r ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int r = 3 ; int n = arr . length ; print@@ Combination ( arr , n , r ) ; } }
class Find@@ Groups { int find@@ groups ( int arr [ ] , int n ) { int c [ ] = new int [ ] { 0 , 0 , 0 } ; int i ; int res = 0 ; for ( i = 0 ; i < n ; i ++ ) c [ arr [ i ] % 3 ] ++ ; res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) ; res += c [ 1 ] * c [ 2 ] ; res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 ; res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6 ; res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) ; res += c [ 0 ] * c [ 1 ] * c [ 2 ] ; return res ; } public static void main ( String [ ] args ) { Find@@ Groups groups = new Find@@ Groups ( ) ; int arr [ ] = { 3 , 6 , 7 , 2 , 9 } ; int n = arr . length ; System . out . println ( " Required ▁ number ▁ of ▁ groups ▁ are ▁ " + groups . find@@ groups ( arr , n ) ) ; } }
import java . io . * ; class GF@@ G { static int calc@@ Angle ( double h , double m ) { if ( h < 0 m < 0 h > 12 m > 60 ) System . out . println ( " Wrong ▁ input " ) ; if ( h == 12 ) h = 0 ; if ( m == 60 ) { m = 0 ; h += 1 ; if ( h > 12 ) h = h - 12 ; } int hour@@ _@@ angle = ( int ) ( 0.5 * ( h * 60 + m ) ) ; int minu@@ te_@@ angle = ( int ) ( 6 * m ) ; int angle = Math . abs ( hour@@ _@@ angle - minu@@ te_@@ angle ) ; angle = Math . min ( 360 - angle , angle ) ; return angle ; } public static void main ( String [ ] args ) { System . out . println ( calc@@ Angle ( 9 , 60 ) + " ▁ degree " ) ; System . out . println ( calc@@ Angle ( 3 , 30 ) + " ▁ degree " ) ; } }
class GF@@ G { static double find ( double p ) { return Math . ceil ( Math . sqrt ( 2 * 365 * Math . log ( 1 / ( 1 - p ) ) ) ) ; } public static void main ( String [ ] args ) { System . out . println ( find ( 0.@@ 70 ) ) ; } }
import java . io . * ; class GF@@ G { static int MAX_@@ ITER = 1000000 ; static double func ( double x ) { return ( x * x * x - x * x + 2 ) ; } static void reg@@ ula@@ Fal@@ si ( double a , double b ) { if ( func ( a ) * func ( b ) >= 0 ) { System . out . println ( " You ▁ have ▁ not ▁ assumed ▁ right ▁ a ▁ and ▁ b " ) ; } double c = a ; for ( int i = 0 ; i < MAX_@@ ITER ; i ++ ) { c = ( a * func ( b ) - b * func ( a ) ) / ( func ( b ) - func ( a ) ) ; if ( func ( c ) == 0 ) break ; else if ( func ( c ) * func ( a ) < 0 ) b = c ; else a = c ; } System . out . println ( " The ▁ value ▁ of ▁ root ▁ is ▁ : ▁ " + ( int ) c ) ; } public static void main ( String [ ] args ) { double a = - 200 , b = 300 ; reg@@ ula@@ Fal@@ si ( a , b ) ; } }
class GF@@ G { static int swap@@ Bits ( int x , int p1 , int p2 , int n ) { int set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 ) ; int set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 ) ; int xor = ( set1 ^ set2 ) ; xor = ( xor << p1 ) | ( xor << p2 ) ; int result = x ^ xor ; return result ; } public static void main ( String [ ] args ) { int res = swap@@ Bits ( 28 , 0 , 3 , 2 ) ; System . out . println ( " Result ▁ = ▁ " + res ) ; } }
class GF@@ G { static int fun ( int n ) { return n & ( n - 1 ) ; } public static void main ( String arg [ ] ) { int n = 7 ; System . out . print ( " The ▁ number ▁ after ▁ un@@ setting ▁ " + " the ▁ right@@ most ▁ set ▁ bit ▁ " + fun ( n ) ) ; } }
import java . io . * ; class GF@@ G { static int is@@ PowerOf@@ Four ( int n ) { int count = 0 ; int x = n & ( n - 1 ) ; if ( n > 0 && x == 0 ) { while ( n > 1 ) { n >>= 1 ; count += 1 ; } return ( count % 2 == 0 ) ? 1 : 0 ; } return 0 ; } public static void main ( String [ ] args ) { int test_@@ no = 64 ; if ( is@@ PowerOf@@ Four ( test_@@ no ) > 0 ) System . out . println ( test_@@ no + " ▁ is ▁ a ▁ power ▁ of ▁ 4" ) ; else System . out . println ( test_@@ no + " ▁ is ▁ not ▁ a ▁ power ▁ of ▁ 4" ) ; } }
public class AWS { static int min ( int x , int y ) { return y ^ ( ( x ^ y ) & - ( x << y ) ) ; } static int max ( int x , int y ) { return x ^ ( ( x ^ y ) & - ( x << y ) ) ; } public static void main ( String [ ] args ) { int x = 15 ; int y = 6 ; System . out . print ( " Minimum ▁ of ▁ " + x + " ▁ and ▁ " + y + " ▁ is ▁ " ) ; System . out . println ( min ( x , y ) ) ; System . out . print ( " Maximum ▁ of ▁ " + x + " ▁ and ▁ " + y + " ▁ is ▁ " ) ; System . out . println ( max ( x , y ) ) ; } }
import java . io . * ; import java . util . HashMap ; class O@@ dd@@ Occurren@@ ce { static int getO@@ dd@@ Occurren@@ ce ( int arr [ ] , int n ) { HashMap < Integer , Integer > h@@ map = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( h@@ map . containsKey ( arr [ i ] ) ) { int val = h@@ map . get ( arr [ i ] ) ; h@@ map . put ( arr [ i ] , val + 1 ) ; } else h@@ map . put ( arr [ i ] , 1 ) ; } for ( Integer a : h@@ map . keySet ( ) ) { if ( h@@ map . get ( a ) % 2 != 0 ) return a ; } return - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = new int [ ] { 2 , 3 , 5 , 4 , 5 , 2 , 4 , 3 , 5 , 2 , 4 , 4 , 2 } ; int n = arr . length ; System . out . println ( getO@@ dd@@ Occurren@@ ce ( arr , n ) ) ; } }
class GF@@ G { static int [ ] num_@@ to_@@ bits = new int [ ] { 0 , 1 , 1 , 2 , 1 , 2 , 2 , 3 , 1 , 2 , 2 , 3 , 2 , 3 , 3 , 4 } ; static int count@@ Set@@ Bits@@ Rec ( int num ) { int ni@@ bble = 0 ; if ( 0 == num ) return num_@@ to_@@ bits [ 0 ] ; ni@@ bble = num & 0xf ; return num_@@ to_@@ bits [ ni@@ bble ] + count@@ Set@@ Bits@@ Rec ( num >> 4 ) ; } public static void main ( String [ ] args ) { int num = 31 ; System . out . println ( count@@ Set@@ Bits@@ Rec ( num ) ) ; } }
import java . io . * ; class GF@@ G { static int next@@ PowerOf@@ 2 ( int n ) { n -- ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n ++ ; return n ; } public static void main ( String args [ ] ) { int n = 5 ; System . out . println ( next@@ PowerOf@@ 2 ( n ) ) ; } }
class GF@@ G { static boolean is@@ PowerOf@@ Two ( int n ) { if ( n == 0 ) return false ; return ( int ) ( Math . ceil ( ( Math . log ( n ) / Math . log ( 2 ) ) ) ) == ( int ) ( Math . floor ( ( ( Math . log ( n ) / Math . log ( 2 ) ) ) ) ) ; } public static void main ( String [ ] args ) { if ( is@@ PowerOf@@ Two ( 31 ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; if ( is@@ PowerOf@@ Two ( 64 ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GF@@ G { static boolean is@@ PowerOf@@ Two ( int n ) { if ( n == 0 ) return false ; while ( n != 1 ) { if ( n % 2 != 0 ) return false ; n = n / 2 ; } return true ; } public static void main ( String args [ ] ) { if ( is@@ PowerOf@@ Two ( 31 ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; if ( is@@ PowerOf@@ Two ( 64 ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GF@@ G { public static int getFirst@@ Set@@ Bit@@ Pos ( int n ) { return ( int ) ( ( Math . log10 ( n & - n ) ) / Math . log10 ( 2 ) ) + 1 ; } public static void main ( String [ ] args ) { int n = 12 ; System . out . println ( getFirst@@ Set@@ Bit@@ Pos ( n ) ) ; } }
class GF@@ G { static int swap@@ Bits ( int x ) { int even@@ _bits = x & 0x@@ AAAA@@ AAAA ; int od@@ d_@@ bits = x & 0x5@@ 5555@@ 555 ; even@@ _bits >>= 1 ; od@@ d_@@ bits <<= 1 ; return ( even@@ _bits od@@ d_@@ bits ) ; } public static void main ( String [ ] args ) { int x = 23 ; System . out . println ( swap@@ Bits ( x ) ) ; } }
class GF@@ G { static boolean is@@ PowerOf@@ Two ( int n ) { return n > 0 && ( ( n & ( n - 1 ) ) == 0 ) ; } static int find@@ Position ( int n ) { if ( ! is@@ PowerOf@@ Two ( n ) ) return - 1 ; int count = 0 ; while ( n > 0 ) { n = n >> 1 ; ++ count ; } return count ; } public static void main ( String [ ] args ) { int n = 0 ; int pos = find@@ Position ( n ) ; if ( pos == - 1 ) System . out . println ( " n ▁ = ▁ " + n + " , ▁ Invalid ▁ number " ) ; else System . out . println ( " n ▁ = ▁ " + n + " , ▁ Position ▁ " + pos ) ; n = 12 ; pos = find@@ Position ( n ) ; if ( pos == - 1 ) System . out . println ( " n ▁ = ▁ " + n + " , ▁ Invalid ▁ number " ) ; else System . out . println ( " n ▁ = ▁ " + n + " , ▁ Position ▁ " + pos ) ; n = 128 ; pos = find@@ Position ( n ) ; if ( pos == - 1 ) System . out . println ( " n ▁ = ▁ " + n + " , ▁ Invalid ▁ number " ) ; else System . out . println ( " n ▁ = ▁ " + n + " , ▁ Position ▁ " + pos ) ; } }
import java . io . * ; class Next@@ Gre@@ atest { static void next@@ Gre@@ atest ( int arr [ ] ) { int size = arr . length ; int max_@@ from_@@ right = arr [ size - 1 ] ; arr [ size - 1 ] = - 1 ; for ( int i = size - 2 ; i >= 0 ; i -- ) { int temp = arr [ i ] ; arr [ i ] = max_@@ from_@@ right ; if ( max_@@ from_@@ right < temp ) max_@@ from_@@ right = temp ; } } static void print@@ Array ( int arr [ ] ) { for ( int i = 0 ; i < arr . length ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 16 , 17 , 4 , 3 , 5 , 2 } ; next@@ Gre@@ atest ( arr ) ; System . out . println ( " The ▁ modified ▁ array : " ) ; print@@ Array ( arr ) ; } }
import java . io . * ; class GF@@ G { public static int max@@ Circular@@ Sum ( int a [ ] , int n ) { if ( n == 1 ) return a [ 0 ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } int curr_@@ max = a [ 0 ] , max_@@ so@@ _f@@ ar = a [ 0 ] , curr_@@ min = a [ 0 ] , min_@@ so@@ _f@@ ar = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { curr_@@ max = Math . max ( curr_@@ max + a [ i ] , a [ i ] ) ; max_@@ so@@ _f@@ ar = Math . max ( max_@@ so@@ _f@@ ar , curr_@@ max ) ; curr_@@ min = Math . min ( curr_@@ min + a [ i ] , a [ i ] ) ; min_@@ so@@ _f@@ ar = Math . min ( min_@@ so@@ _f@@ ar , curr_@@ min ) ; } if ( min_@@ so@@ _f@@ ar == sum ) { return max_@@ so@@ _f@@ ar ; } return Math . max ( max_@@ so@@ _f@@ ar , sum - min_@@ so@@ _f@@ ar ) ; } public static void main ( String [ ] args ) { int a [ ] = { 11 , 10 , - 20 , 5 , - 3 , - 5 , 8 , - 13 , 10 } ; int n = 9 ; System . out . println ( " Maximum ▁ circular ▁ sum ▁ is ▁ " + max@@ Circular@@ Sum ( a , n ) ) ; } }
class Maximum@@ Diff@@ rence { int max@@ Diff ( int arr [ ] , int arr_@@ size ) { int max_@@ diff = arr [ 1 ] - arr [ 0 ] ; int i , j ; for ( i = 0 ; i < arr_@@ size ; i ++ ) { for ( j = i + 1 ; j < arr_@@ size ; j ++ ) { if ( arr [ j ] - arr [ i ] > max_@@ diff ) max_@@ diff = arr [ j ] - arr [ i ] ; } } return max_@@ diff ; } public static void main ( String [ ] args ) { Maximum@@ Difference max@@ dif = new Maximum@@ Difference ( ) ; int arr [ ] = { 1 , 2 , 90 , 10 , 110 } ; System . out . println ( " Maximum ▁ difference ▁ is ▁ " + max@@ dif . max@@ Diff ( arr , 5 ) ) ; } }
class Main { static int find@@ Maximum ( int arr [ ] , int low , int high ) { if ( low == high ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] >= arr [ high ] ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] < arr [ high ] ) return arr [ high ] ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] > arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] < arr [ mid - 1 ] ) return find@@ Maximum ( arr , low , mid - 1 ) ; else return find@@ Maximum ( arr , mid + 1 , high ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 50 , 10 , 9 , 7 , 6 } ; int n = arr . length ; System . out . println ( " The ▁ maximum ▁ element ▁ is ▁ " + find@@ Maximum ( arr , 0 , n - 1 ) ) ; } }
class g@@ fg { static int find@@ Min@@ Sw@@ aps ( int arr [ ] , int n ) { int noOf@@ Zero@@ es [ ] = new int [ n ] ; int i , count = 0 ; noOf@@ Zero@@ es [ n - 1 ] = 1 - arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) { noOf@@ Zero@@ es [ i ] = noOf@@ Zero@@ es [ i + 1 ] ; if ( arr [ i ] == 0 ) noOf@@ Zero@@ es [ i ] ++ ; } for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 1 ) count += noOf@@ Zero@@ es [ i ] ; } return count ; } public static void main ( String args [ ] ) { int ar [ ] = { 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 } ; System . out . println ( find@@ Min@@ Sw@@ aps ( ar , ar . length ) ) ; } }
import java . io . * ; import java . util . * ; class GF@@ G { static int min@@ Swap@@ sTo@@ Sort ( int arr [ ] , int n ) { ArrayList < ArrayList < Integer > > arr@@ Pos = new ArrayList < ArrayList < Integer > > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { arr@@ Pos . add ( new ArrayList < Integer > ( Arrays . asList ( arr [ i ] , i ) ) ) ; } Collections . sort ( arr@@ Pos , new Comparator < ArrayList < Integer > > ( ) { @ Override public int compare ( ArrayList < Integer > o1 , ArrayList < Integer > o2 ) { return o1 . get ( 0 ) . compareTo ( o2 . get ( 0 ) ) ; } } ) ; boolean [ ] vis = new boolean [ n ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( vis [ i ] || arr@@ Pos . get ( i ) . get ( 1 ) == i ) continue ; int cycle@@ _size = 0 ; int j = i ; while ( ! vis [ j ] ) { vis [ j ] = true ; j = arr@@ Pos . get ( j ) . get ( 1 ) ; cycle@@ _size ++ ; } ans += ( cycle@@ _size - 1 ) ; } return ans ; } static int min@@ Swap@@ To@@ Make@@ Array@@ Same ( int a [ ] , int b [ ] , int n ) { Map < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { mp . put ( b [ i ] , i ) ; } for ( int i = 0 ; i < n ; i ++ ) b [ i ] = mp . get ( a [ i ] ) ; return min@@ Swap@@ sTo@@ Sort ( b , n ) ; } public static void main ( String [ ] args ) { int a [ ] = { 3 , 6 , 4 , 8 } ; int b [ ] = { 4 , 6 , 8 , 3 } ; int n = a . length ; System . out . println ( min@@ Swap@@ To@@ Make@@ Array@@ Same ( a , b , n ) ) ; } }
import java . util . Arrays ; class Test { static int arr [ ] = new int [ ] { 5 , 1 , 3 , 4 , 7 } ; static int count@@ Trip@@ lets ( int n , int sum ) { Arrays . sort ( arr ) ; int ans = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { int j = i + 1 , k = n - 1 ; while ( j < k ) { if ( arr [ i ] + arr [ j ] + arr [ k ] >= sum ) k -- ; else { ans += ( k - j ) ; j ++ ; } } } return ans ; } public static void main ( String [ ] args ) { int sum = 12 ; System . out . println ( count@@ Trip@@ lets ( arr . length , sum ) ) ; } }
import java . io . * ; class GF@@ G { static void print@@ Two@@ Elements ( int arr [ ] , int size ) { int i ; System . out . print ( " The ▁ repe@@ ating ▁ element ▁ is ▁ " ) ; for ( i = 0 ; i < size ; i ++ ) { int abs_@@ val = Math . abs ( arr [ i ] ) ; if ( arr [ abs_@@ val - 1 ] > 0 ) arr [ abs_@@ val - 1 ] = - arr [ abs_@@ val - 1 ] ; else System . out . println ( abs_@@ val ) ; } System . out . print ( " And ▁ the ▁ missing ▁ element ▁ is ▁ " ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] > 0 ) System . out . println ( i + 1 ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 7 , 3 , 4 , 5 , 5 , 6 , 2 } ; int n = arr . length ; print@@ Two@@ Elements ( arr , n ) ; } }
import java . util . * ; class Main { static void print@@ Two@@ Odd ( int arr [ ] , int size ) { int xor@@ 2 = arr [ 0 ] ; int set_@@ bit_@@ no ; int i ; int n = size - 2 ; int x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) xor@@ 2 = xor@@ 2 ^ arr [ i ] ; set_@@ bit_@@ no = xor@@ 2 & ~ ( xor@@ 2 - 1 ) ; for ( i = 0 ; i < size ; i ++ ) { if ( ( arr [ i ] & set_@@ bit_@@ no ) > 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } System . out . println ( " The ▁ two ▁ O@@ DD ▁ elements ▁ are ▁ " + x + " ▁ & ▁ " + y ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 3 , 1 } ; int arr_@@ size = arr . length ; print@@ Two@@ Odd ( arr , arr_@@ size ) ; } }
import java . io . * ; class Pair@@ Difference { static boolean find@@ Pair ( int arr [ ] , int n ) { int size = arr . length ; int i = 0 , j = 1 ; while ( i < size && j < size ) { if ( i != j && arr [ j ] - arr [ i ] == n ) { System . out . print ( " Pair ▁ Found : ▁ " + " ( ▁ " + arr [ i ] + " , ▁ " + arr [ j ] + " ▁ ) " ) ; return true ; } else if ( arr [ j ] - arr [ i ] < n ) j ++ ; else i ++ ; } System . out . print ( " No ▁ such ▁ pair " ) ; return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 8 , 30 , 40 , 100 } ; int n = 60 ; find@@ Pair ( arr , n ) ; } }
import java . util . * ; class four@@ Element@@ With@@ Sum { public static void four@@ Sum ( int X , int [ ] arr , Map < Integer , pair > map ) { int [ ] temp = new int [ arr . length ] ; for ( int i = 0 ; i < temp . length ; i ++ ) temp [ i ] = 0 ; for ( int i = 0 ; i < arr . length - 1 ; i ++ ) { for ( int j = i + 1 ; j < arr . length ; j ++ ) { int curr_@@ sum = arr [ i ] + arr [ j ] ; if ( map . containsKey ( X - curr_@@ sum ) ) { pair p = map . get ( X - curr_@@ sum ) ; if ( p . first != i && p . sec != i && p . first != j && p . sec != j && temp [ p . first ] == 0 && temp [ p . sec ] == 0 && temp [ i ] == 0 && temp [ j ] == 0 ) { System . out . printf ( " % d , % d , % d , % d " , arr [ i ] , arr [ j ] , arr [ p . first ] , arr [ p . sec ] ) ; temp [ p . sec ] = 1 ; temp [ i ] = 1 ; temp [ j ] = 1 ; break ; } } } } } public static Map < Integer , pair > two@@ Sum ( int [ ] nums ) { Map < Integer , pair > map = new HashMap < > ( ) ; for ( int i = 0 ; i < nums . length - 1 ; i ++ ) { for ( int j = i + 1 ; j < nums . length ; j ++ ) { map . put ( nums [ i ] + nums [ j ] , new pair ( i , j ) ) ; } } return map ; } public static class pair { int first , sec ; public pair ( int first , int sec ) { this . first = first ; this . sec = sec ; } } public static void main ( String args [ ] ) { int [ ] arr = { 10 , 20 , 30 , 40 , 1 , 2 } ; int n = arr . length ; int X = 91 ; Map < Integer , pair > map = two@@ Sum ( arr ) ; four@@ Sum ( X , arr , map ) ; } }
import java . io . * ; class Deletion { static int delete@@ Element ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == x ) break ; if ( i < n ) { n = n - 1 ; for ( int j = i ; j < n ; j ++ ) arr [ j ] = arr [ j + 1 ] ; } return n ; } public static void main ( String [ ] args ) { int arr [ ] = { 11 , 15 , 6 , 8 , 9 , 10 } ; int n = arr . length ; int x = 6 ; n = delete@@ Element ( arr , n , x ) ; System . out . println ( " Modified ▁ array ▁ is " ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
public class Maximum@@ Absolute@@ Difference { private static int max@@ Distance ( int [ ] array ) { int max@@ 1 = Integer . MIN_VALUE ; int min@@ 1 = Integer . MAX_VALUE ; int max@@ 2 = Integer . MIN_VALUE ; int min@@ 2 = Integer . MAX_VALUE ; for ( int i = 0 ; i < array . length ; i ++ ) { max@@ 1 = Math . max ( max@@ 1 , array [ i ] + i ) ; min@@ 1 = Math . min ( min@@ 1 , array [ i ] + i ) ; max@@ 2 = Math . max ( max@@ 2 , array [ i ] - i ) ; min@@ 2 = Math . min ( min@@ 2 , array [ i ] - i ) ; } return Math . max ( max@@ 1 - min@@ 1 , max@@ 2 - min@@ 2 ) ; } public static void main ( String [ ] args ) { int [ ] array = { - 70 , - 64 , - 6 , - 56 , 64 , 61 , - 57 , 16 , 48 , - 98 } ; System . out . println ( max@@ Distance ( array ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class Find@@ Closest@@ Number { public static int find@@ Close@@ st ( int arr [ ] , int target ) { int n = arr . length ; if ( target <= arr [ 0 ] ) return arr [ 0 ] ; if ( target >= arr [ n - 1 ] ) return arr [ n - 1 ] ; int i = 0 , j = n , mid = 0 ; while ( i < j ) { mid = ( i + j ) / 2 ; if ( arr [ mid ] == target ) return arr [ mid ] ; if ( target < arr [ mid ] ) { if ( mid > 0 && target > arr [ mid - 1 ] ) return get@@ Close@@ st ( arr [ mid - 1 ] , arr [ mid ] , target ) ; j = mid ; } else { if ( mid < n - 1 && target < arr [ mid + 1 ] ) return get@@ Close@@ st ( arr [ mid ] , arr [ mid + 1 ] , target ) ; i = mid + 1 ; } } return arr [ mid ] ; } public static int get@@ Close@@ st ( int val1 , int val2 , int target ) { if ( target - val1 >= val2 - target ) return val2 ; else return val1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 4 , 5 , 6 , 6 , 8 , 9 } ; int target = 11 ; System . out . println ( find@@ Close@@ st ( arr , target ) ) ; } }
class GF@@ G { static class Node { int data ; Node next ; } ; static void print@@ List ( Node node ) { while ( node != null ) { System . out . print ( node . data + " ▁ " ) ; node = node . next ; } System . out . println ( ) ; } static Node newNode ( int key ) { Node temp = new Node ( ) ; temp . data = key ; temp . next = null ; return temp ; } static Node insert@@ Be@@ g ( Node head , int val ) { Node temp = newNode ( val ) ; temp . next = head ; head = temp ; return head ; } static Node re@@ arrange ( Node head ) { Node even ; Node temp , prev_@@ temp ; Node i , j , k , l , ptr = null ; temp = ( head ) . next ; prev_@@ temp = head ; while ( temp != null ) { Node x = temp . next ; if ( temp . data % 2 != 0 ) { prev_@@ temp . next = x ; temp . next = ( head ) ; ( head ) = temp ; } else { prev_@@ temp = temp ; } temp = x ; } temp = ( head ) . next ; prev_@@ temp = ( head ) ; while ( temp != null && temp . data % 2 != 0 ) { prev_@@ temp = temp ; temp = temp . next ; } even = temp ; prev_@@ temp . next = null ; i = head ; j = even ; while ( j != null && i != null ) { k = i . next ; l = j . next ; i . next = j ; j . next = k ; ptr = j ; i = k ; j = l ; } if ( i == null ) { ptr . next = j ; } return head ; } public static void main ( String args [ ] ) { Node head = newNode ( 8 ) ; head = insert@@ Be@@ g ( head , 7 ) ; head = insert@@ Be@@ g ( head , 6 ) ; head = insert@@ Be@@ g ( head , 3 ) ; head = insert@@ Be@@ g ( head , 5 ) ; head = insert@@ Be@@ g ( head , 1 ) ; head = insert@@ Be@@ g ( head , 2 ) ; head = insert@@ Be@@ g ( head , 10 ) ; System . out . println ( " Linked ▁ List : " ) ; print@@ List ( head ) ; System . out . println ( " Re@@ arrange@@ d ▁ List " ) ; head = re@@ arrange ( head ) ; print@@ List ( head ) ; } }
import java . util . * ; class GF@@ G { static class Node { int data ; Node next ; } ; static Node head = null ; static void rotate ( int k ) { if ( k == 0 ) return ; Node current = head ; while ( current . next != null ) current = current . next ; current . next = head ; current = head ; for ( int i = 0 ; i < k - 1 ; i ++ ) current = current . next ; head = current . next ; current . next = null ; } static void push ( int new_data ) { Node new_node = new Node ( ) ; new_node . data = new_data ; new_node . next = head ; head = new_node ; } static void print@@ List ( Node node ) { while ( node != null ) { System . out . print ( node . data + " ▁ " ) ; node = node . next ; } } public static void main ( String [ ] args ) { for ( int i = 60 ; i > 0 ; i -= 10 ) push ( i ) ; System . out . print ( "@@ Given linked list NEW_@@ LINE@@ "@@ )@@ ; print@@ List ( head ) ; rotate ( 4 ) ; System . out . print ( " Rot@@ ated Linked list "@@ )@@ ; print@@ List ( head ) ; } }
import java . util . * ; class GF@@ G { public static void main ( String [ ] args ) { ArrayList < Integer > list = new ArrayList < > ( ) ; list . add ( 1 ) ; list . add ( 2 ) ; list . add ( 3 ) ; Iterator < Integer > it = list . iterator ( ) ; while ( it . hasNext ( ) ) { System . out . print ( it . next ( ) + " ▁ " ) ; } } }
import java . util . * ; class Node { int data ; Node next ; public Node ( int data ) { this . data = data ; this . next = null ; } } class g@@ fg { static Node root ; public static Node key@@ To@@ End ( Node head , int key ) { Node tail = head ; if ( head == null ) { return null ; } while ( tail . next != null ) { tail = tail . next ; } Node last = tail ; Node current = head ; Node prev = null ; Node pre@@ v2 = null ; while ( current != tail ) { if ( current . data == key && pre@@ v2 == null ) { prev = current ; current = current . next ; head = current ; last . next = prev ; last = last . next ; last . next = null ; prev = null ; } else { if ( current . data == key && pre@@ v2 != null ) { prev = current ; current = current . next ; pre@@ v2 . next = current ; last . next = prev ; last = last . next ; last . next = null ; } else if ( current != tail ) { pre@@ v2 = current ; current = current . next ; } } } return head ; } public static void display ( Node root ) { while ( root != null ) { System . out . print ( root . data + " ▁ " ) ; root = root . next ; } } public static void main ( String args [ ] ) { root = new Node ( 5 ) ; root . next = new Node ( 2 ) ; root . next . next = new Node ( 2 ) ; root . next . next . next = new Node ( 7 ) ; root . next . next . next . next = new Node ( 2 ) ; root . next . next . next . next . next = new Node ( 2 ) ; root . next . next . next . next . next . next = new Node ( 2 ) ; int key = 2 ; System . out . println ( " Linked ▁ List ▁ before ▁ operations ▁ : " ) ; display ( root ) ; System . out . println ( " Linked List after operations : "@@ )@@ ; root = key@@ To@@ End ( root , key ) ; display ( root ) ; } }
import java . util . * ; class GF@@ G { static class Node { int data ; Node next ; } ; static Node push ( Node head_@@ ref , int new_data ) { Node new_node = new Node ( ) ; new_node . data = new_data ; new_node . next = head_@@ ref ; head_@@ ref = new_node ; return head_@@ ref ; } static int sum@@ Of@@ Last@@ N_@@ Nodes@@ Util ( Node head , int n ) { if ( n <= 0 ) return 0 ; Stack < Integer > st = new Stack < Integer > ( ) ; int sum = 0 ; while ( head != null ) { st . push ( head . data ) ; head = head . next ; } while ( n -- > 0 ) { sum += st . peek ( ) ; st . pop ( ) ; } return sum ; } public static void main ( String [ ] args ) { Node head = null ; head = push ( head , 12 ) ; head = push ( head , 4 ) ; head = push ( head , 8 ) ; head = push ( head , 6 ) ; head = push ( head , 10 ) ; int n = 2 ; System . out . print ( " Sum ▁ of ▁ last ▁ " + n + " ▁ nodes ▁ = ▁ " + sum@@ Of@@ Last@@ N_@@ Nodes@@ Util ( head , n ) ) ; } }
import java . util . * ; class GF@@ G { static class Node { int data ; Node next ; } ; static Node head ; static void push ( Node head_@@ ref , int new_data ) { Node new_node = new Node ( ) ; new_node . data = new_data ; new_node . next = head_@@ ref ; head_@@ ref = new_node ; head = head_@@ ref ; } static void reverse@@ List ( Node head_@@ ref ) { Node current , prev , next ; current = head_@@ ref ; prev = null ; while ( current != null ) { next = current . next ; current . next = prev ; prev = current ; current = next ; } head_@@ ref = prev ; head = head_@@ ref ; } static int sum@@ Of@@ Last@@ N_@@ Nodes@@ Util ( int n ) { if ( n <= 0 ) return 0 ; reverse@@ List ( head ) ; int sum = 0 ; Node current = head ; while ( current != null && n -- > 0 ) { sum += current . data ; current = current . next ; } reverse@@ List ( head ) ; return sum ; } public static void main ( String [ ] args ) { push ( head , 12 ) ; push ( head , 4 ) ; push ( head , 8 ) ; push ( head , 6 ) ; push ( head , 10 ) ; int n = 2 ; System . out . println ( " Sum ▁ of ▁ last ▁ " + n + " ▁ nodes ▁ = ▁ " + sum@@ Of@@ Last@@ N_@@ Nodes@@ Util ( n ) ) ; } }
class GF@@ G { static class Node { int data ; Node next ; } ; static Node swap@@ Nodes ( Node head_@@ ref , Node curr@@ X , Node curr@@ Y , Node prev@@ Y ) { head_@@ ref = curr@@ Y ; prev@@ Y . next = curr@@ X ; Node temp = curr@@ Y . next ; curr@@ Y . next = curr@@ X . next ; curr@@ X . next = temp ; return head_@@ ref ; } static Node recur@@ Selection@@ Sort ( Node head ) { if ( head . next == null ) return head ; Node min = head ; Node before@@ Min = null ; Node ptr ; for ( ptr = head ; ptr . next != null ; ptr = ptr . next ) { if ( ptr . next . data < min . data ) { min = ptr . next ; before@@ Min = ptr ; } } if ( min != head ) head = swap@@ Nodes ( head , head , min , before@@ Min ) ; head . next = recur@@ Selection@@ Sort ( head . next ) ; return head ; } static Node sort ( Node head_@@ ref ) { if ( ( head_@@ ref ) == null ) return null ; head_@@ ref = recur@@ Selection@@ Sort ( head_@@ ref ) ; return head_@@ ref ; } static Node push ( Node head_@@ ref , int new_data ) { Node new_node = new Node ( ) ; new_node . data = new_data ; new_node . next = ( head_@@ ref ) ; ( head_@@ ref ) = new_node ; return head_@@ ref ; } static void print@@ List ( Node head ) { while ( head != null ) { System . out . print ( head . data + " ▁ " ) ; head = head . next ; } } public static void main ( String args [ ] ) { Node head = null ; head = push ( head , 6 ) ; head = push ( head , 4 ) ; head = push ( head , 8 ) ; head = push ( head , 12 ) ; head = push ( head , 10 ) ; System . out . println ( " Linked ▁ list ▁ before ▁ sorting : " ) ; print@@ List ( head ) ; head = sort ( head ) ; System . out . print ( " Linked list after sorting : "@@ )@@ ; print@@ List ( head ) ; } }
class GF@@ G { static class Node { int data ; Node next , prev ; } ; static Node insert ( Node head_@@ ref , int data ) { Node new_node = new Node ( ) ; new_node . data = data ; if ( head_@@ ref == null ) { new_node . next = new_node ; new_node . prev = new_node ; } else { Node last = ( head_@@ ref ) . prev ; new_node . next = head_@@ ref ; new_node . prev = last ; last . next = ( head_@@ ref ) . prev = new_node ; } head_@@ ref = new_node ; return head_@@ ref ; } static Node merge ( Node first , Node second ) { if ( first == null ) return second ; if ( second == null ) return first ; if ( first . data < second . data ) { first . next = merge ( first . next , second ) ; first . next . prev = first ; first . prev = null ; return first ; } else { second . next = merge ( first , second . next ) ; second . next . prev = second ; second . prev = null ; return second ; } } static Node merge@@ Util ( Node head@@ 1 , Node head@@ 2 ) { if ( head@@ 1 == null ) return head@@ 2 ; if ( head@@ 2 == null ) return head@@ 1 ; Node last_@@ node ; if ( head@@ 1 . prev . data < head@@ 2 . prev . data ) last_@@ node = head@@ 2 . prev ; else last_@@ node = head@@ 1 . prev ; head@@ 1 . prev . next = head@@ 2 . prev . next = null ; Node final@@ Head = merge ( head@@ 1 , head@@ 2 ) ; final@@ Head . prev = last_@@ node ; last_@@ node . next = final@@ Head ; return final@@ Head ; } static void print@@ List ( Node head ) { Node temp = head ; while ( temp . next != head ) { System . out . print ( temp . data + " ▁ " ) ; temp = temp . next ; } System . out . print ( temp . data + " ▁ " ) ; } public static void main ( String args [ ] ) { Node head@@ 1 = null , head@@ 2 = null ; head@@ 1 = insert ( head@@ 1 , 8 ) ; head@@ 1 = insert ( head@@ 1 , 5 ) ; head@@ 1 = insert ( head@@ 1 , 3 ) ; head@@ 1 = insert ( head@@ 1 , 1 ) ; head@@ 2 = insert ( head@@ 2 , 11 ) ; head@@ 2 = insert ( head@@ 2 , 9 ) ; head@@ 2 = insert ( head@@ 2 , 7 ) ; head@@ 2 = insert ( head@@ 2 , 2 ) ; Node new@@ Head = merge@@ Util ( head@@ 1 , head@@ 2 ) ; System . out . print ( " Final ▁ Sorted ▁ List : ▁ " ) ; print@@ List ( new@@ Head ) ; } }
import java . util . * ; class GF@@ G { static String min@@ Lex@@ Rotation ( String str ) { int n = str . length ( ) ; String arr [ ] = new String [ n ] ; String concat = str + str ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = concat . substring ( i , i + n ) ; } Arrays . sort ( arr ) ; return arr [ 0 ] ; } public static void main ( String [ ] args ) { System . out . println ( min@@ Lex@@ Rotation ( " GE@@ EK@@ S@@ FOR@@ GE@@ E@@ KS " ) ) ; System . out . println ( min@@ Lex@@ Rotation ( " GE@@ EK@@ SQU@@ I@@ Z " ) ) ; System . out . println ( min@@ Lex@@ Rotation ( " BC@@ AB@@ D@@ AD@@ AB " ) ) ; } }
import java . util . * ; class GF@@ G { static final int MAX = 1000 ; static final int log = 10 ; static int [ ] level = new int [ MAX ] ; static int [ ] [ ] l@@ ca = new int [ MAX ] [ log ] ; static int [ ] [ ] min@@ Weight = new int [ MAX ] [ log ] ; static int [ ] [ ] max@@ Weight = new int [ MAX ] [ log ] ; static Vector < Integer > [ ] graph = new Vector [ MAX ] ; static int [ ] weight = new int [ MAX ] ; private static void swap ( int x , int y ) { int temp = x ; x = y ; y = temp ; } static void addEdge ( int u , int v ) { graph [ u ] . add ( v ) ; graph [ v ] . add ( u ) ; } static void dfs ( int node , int parent , int h ) { l@@ ca [ node ] [ 0 ] = parent ; level [ node ] = h ; if ( parent != - 1 ) { min@@ Weight [ node ] [ 0 ] = Math . min ( weight [ node ] , weight [ parent ] ) ; max@@ Weight [ node ] [ 0 ] = Math . max ( weight [ node ] , weight [ parent ] ) ; } for ( int i = 1 ; i < log ; i ++ ) { if ( l@@ ca [ node ] [ i - 1 ] != - 1 ) { l@@ ca [ node ] [ i ] = l@@ ca [ l@@ ca [ node ] [ i - 1 ] ] [ i - 1 ] ; min@@ Weight [ node ] [ i ] = Math . min ( min@@ Weight [ node ] [ i - 1 ] , min@@ Weight [ l@@ ca [ node ] [ i - 1 ] ] [ i - 1 ] ) ; max@@ Weight [ node ] [ i ] = Math . max ( max@@ Weight [ node ] [ i - 1 ] , max@@ Weight [ l@@ ca [ node ] [ i - 1 ] ] [ i - 1 ] ) ; } } for ( int i : graph [ node ] ) { if ( i == parent ) continue ; dfs ( i , node , h + 1 ) ; } } static void find@@ MinMax@@ Weight ( int u , int v ) { int min@@ We@@ i = Integer . MAX_VALUE ; int max@@ We@@ i = Integer . MIN_VALUE ; if ( level [ u ] > level [ v ] ) swap ( u , v ) ; for ( int i = log - 1 ; i >= 0 ; i -- ) { if ( l@@ ca [ v ] [ i ] != - 1 && level [ l@@ ca [ v ] [ i ] ] >= level [ u ] ) { min@@ We@@ i = Math . min ( min@@ We@@ i , min@@ Weight [ v ] [ i ] ) ; max@@ We@@ i = Math . max ( max@@ We@@ i , max@@ Weight [ v ] [ i ] ) ; v = l@@ ca [ v ] [ i ] ; } } if ( v == u ) { System . out . print ( min@@ We@@ i + " ▁ " + max@@ We@@ i + "@@ NEW_@@ LINE@@ "@@ )@@ ; } else { for ( int i = log - 1 ; i >= 0 ; i -- ) { if ( v == - 1 ) v ++ ; if ( l@@ ca [ v ] [ i ] != l@@ ca [ u ] [ i ] ) { min@@ We@@ i = Math . min ( min@@ We@@ i , Math . min ( min@@ Weight [ v ] [ i ] , min@@ Weight [ u ] [ i ] ) ) ; max@@ We@@ i = Math . max ( max@@ We@@ i , Math . max ( max@@ Weight [ v ] [ i ] , max@@ Weight [ u ] [ i ] ) ) ; v = l@@ ca [ v ] [ i ] ; u = l@@ ca [ u ] [ i ] ; } } if ( u == - 1 ) u ++ ; min@@ We@@ i = Math . min ( min@@ We@@ i , Math . min ( min@@ Weight [ v ] [ 0 ] , min@@ Weight [ u ] [ 0 ] ) ) ; max@@ We@@ i = Math . max ( max@@ We@@ i , Math . max ( max@@ Weight [ v ] [ 0 ] , max@@ Weight [ u ] [ 0 ] ) ) ; System . out . print ( min@@ We@@ i + " ▁ " + max@@ We@@ i + "@@ NEW_@@ LINE@@ "@@ )@@ ; } } public static void main ( String [ ] args ) { int n = 5 ; for ( int i = 0 ; i < graph . length ; i ++ ) graph [ i ] = new Vector < Integer > ( ) ; addEdge ( 1 , 2 ) ; addEdge ( 1 , 5 ) ; addEdge ( 2 , 4 ) ; addEdge ( 2 , 3 ) ; weight [ 1 ] = - 1 ; weight [ 2 ] = 5 ; weight [ 3 ] = - 1 ; weight [ 4 ] = 3 ; weight [ 5 ] = - 2 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j < log ; j ++ ) { l@@ ca [ i ] [ j ] = - 1 ; min@@ Weight [ i ] [ j ] = Integer . MAX_VALUE ; max@@ Weight [ i ] [ j ] = Integer . MIN_VALUE ; } } dfs ( 1 , - 1 , 0 ) ; find@@ MinMax@@ Weight ( 1 , 3 ) ; find@@ MinMax@@ Weight ( 2 , 4 ) ; find@@ MinMax@@ Weight ( 3 , 5 ) ; } }
import java . util . * ; class GF@@ G { static int MAX = 1000 ; static int find@@ L@@ CA ( int n1 , int n2 , int parent [ ] ) { boolean [ ] visited = new boolean [ MAX ] ; visited [ n1 ] = true ; while ( parent [ n1 ] != - 1 ) { visited [ n1 ] = true ; n1 = parent [ n1 ] ; } visited [ n1 ] = true ; while ( ! visited [ n2 ] ) n2 = parent [ n2 ] ; return n2 ; } static void insert@@ Ad@@ j ( int parent [ ] , int i , int j ) { parent [ i ] = j ; } public static void main ( String [ ] args ) { int [ ] parent = new int [ MAX ] ; parent [ 20 ] = - 1 ; insert@@ Ad@@ j ( parent , 8 , 20 ) ; insert@@ Ad@@ j ( parent , 22 , 20 ) ; insert@@ Ad@@ j ( parent , 4 , 8 ) ; insert@@ Ad@@ j ( parent , 12 , 8 ) ; insert@@ Ad@@ j ( parent , 10 , 12 ) ; insert@@ Ad@@ j ( parent , 14 , 12 ) ; System . out . println ( find@@ L@@ CA ( 10 , 14 , parent ) ) ; } }
class GF@@ G { public static int solve ( int n , int m ) { int ans = n * ( m / 2 ) ; if ( m % 2 == 1 ) { ans += ( n + 1 ) / 2 ; } return ans ; } public static void main ( String args [ ] ) { int N = 5 ; int M = 3 ; System . out . println ( solve ( N , M ) ) ; } }
class GF@@ G { static int max_len = 10000@@ 5 ; static int cnt [ ] = new int [ max_len ] ; public static void pre@@ compute ( String s , String K ) { int n = s . length ( ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) { cnt [ i + 1 ] = cnt [ i ] ; if ( s . substring ( i , i + K . length ( ) ) . equals ( K ) ) { cnt [ i + 1 ] += 1 ; } } cnt [ n - 2 + 1 ] = cnt [ n - 2 ] ; } public static void main ( String [ ] args ) { String s = " ABC@@ ABC@@ AB@@ ABC " ; String K = " ABC " ; pre@@ compute ( s , K ) ; int Q [ ] [ ] = { { 1 , 6 } , { 5 , 11 } } ; for ( int it = 0 ; it < Q . length ; it ++ ) { System . out . println ( cnt [ Q [ it ] [ 1 ] - 1 ] - cnt [ Q [ it ] [ 0 ] - 1 ] ) ; } } }
class GF@@ G { static void count@@ Int@@ gr@@ al@@ Points ( int x1 , int y1 , int x2 , int y2 ) { System . out . println ( ( y2 - y1 - 1 ) * ( x2 - x1 - 1 ) ) ; } public static void main ( String args [ ] ) { int x1 = 1 , y1 = 1 ; int x2 = 4 , y2 = 4 ; count@@ Int@@ gr@@ al@@ Points ( x1 , y1 , x2 , y2 ) ; } }
class GF@@ G { static int min@@ Sum ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += ( n % 10 ) ; n /= 10 ; } if ( sum == 1 ) return 10 ; return sum ; } public static void main ( String [ ] args ) { int n = 18@@ 84 ; System . out . print ( min@@ Sum ( n ) ) ; } }
import java . io . * ; class GF@@ G { public static int repe@@ ating@@ Element ( int arr [ ] , int N ) { int M = 0 , sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; M = Math . max ( M , arr [ i ] ) ; } int sum@@ 1 = M * ( M + 1 ) / 2 ; int ans = ( sum - sum@@ 1 ) / ( N - M ) ; return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 6 , 4 , 3 , 1 , 5 , 2 } ; int N = arr . length ; System . out . println ( repe@@ ating@@ Element ( arr , N ) ) ; } }
import java . io . * ; class GF@@ G { public static int calculate@@ Max ( int N , int M , int K ) { int ans = - 1 ; int low = 0 , high = M ; while ( low <= high ) { int mid = ( low + high ) / 2 ; int val = 0 ; int L = K - 1 ; int R = N - K ; val += mid ; if ( mid >= L ) { val += ( L ) * ( 2 * mid - L - 1 ) / 2 ; } else { val += mid * ( mid - 1 ) / 2 + ( L - mid ) ; } if ( mid >= R ) { val += ( R ) * ( 2 * mid - R - 1 ) / 2 ; } else { val += mid * ( mid - 1 ) / 2 + ( R - mid ) ; } if ( val <= M ) { ans = Math . max ( ans , mid ) ; low = mid + 1 ; } else high = mid - 1 ; } return ans ; } public static void main ( String [ ] args ) { int N = 7 , M = 100 , K = 6 ; System . out . println ( calculate@@ Max ( N , M , K ) ) ; } }
import java . lang . * ; import java . util . * ; class GF@@ G { static int find_@@ index ( int arr [ ] , int N ) { int max_value = Integer . MIN_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { max_value = Math . max ( max_value , arr [ i ] ) ; } Map < Integer , Integer > store = new HashMap < > ( ) ; for ( int i = 1 ; i <= max_value ; i ++ ) { store . put ( i , store . getOr@@ Default ( i , 0 ) + 1 ) ; } if ( store . containsKey ( 1 ) ) { store . remove ( 1 ) ; } for ( int i = 2 ; i <= Math . sqrt ( max_value ) ; i ++ ) { int multiple = 2 ; while ( ( i * multiple ) <= max_value ) { if ( store . containsKey ( i * multiple ) ) { store . remove ( i * multiple ) ; } multiple ++ ; } } int pri@@ me_@@ sum_@@ from_@@ left = 0 ; int [ ] first_@@ array = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { first_@@ array [ i ] = pri@@ me_@@ sum_@@ from_@@ left ; if ( store . containsKey ( arr [ i ] ) ) { pri@@ me_@@ sum_@@ from_@@ left += arr [ i ] ; } } int pri@@ me_@@ sum_@@ from_@@ right = 0 ; int [ ] second_@@ array = new int [ N ] ; for ( int i = N - 1 ; i >= 0 ; i -- ) { second_@@ array [ i ] = pri@@ me_@@ sum_@@ from_@@ right ; if ( store . containsKey ( arr [ i ] ) ) { pri@@ me_@@ sum_@@ from_@@ right += arr [ i ] ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( first_@@ array [ i ] == second_@@ array [ i ] ) { return i ; } } return - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 11 , 4 , 7 , 6 , 13 , 1 , 5 } ; int N = arr . length ; System . out . println ( find_@@ index ( arr , N ) ) ; } }
class GF@@ G { static int find@@ Cost ( int [ ] A , int N ) { int total@@ Cost = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] == 0 ) { A [ i ] = 1 ; total@@ Cost += i ; } } return total@@ Cost ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 0 , 1 , 0 , 1 , 0 } ; int N = arr . length ; System . out . println ( find@@ Cost ( arr , N ) ) ; } }
import java . io . * ; import java . lang . * ; import java . util . * ; class GF@@ G { static boolean is@@ Greater@@ Equal ( int N , int K , int X ) { return ( ( N * 1L * ( N + 1 ) / 2 ) - ( ( K - 1 ) * 1L * K / 2 ) ) >= X ; } static void minimum@@ Number ( int K , int X ) { if ( K > X ) { System . out . println ( " - 1" ) ; return ; } int low = K , high = X , res = - 1 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( is@@ Greater@@ Equal ( mid , K , X ) ) { res = mid ; high = mid - 1 ; } else low = mid + 1 ; } System . out . println ( res ) ; } public static void main ( String [ ] args ) { int K = 5 , X = 13 ; minimum@@ Number ( K , X ) ; } }
import java . io . * ; import java . lang . * ; import java . util . * ; class GF@@ G { static int Get@@ Diff ( int A [ ] , int N ) { int Su@@ ff@@ Max@@ Arr [ ] = new int [ N ] ; Su@@ ff@@ Max@@ Arr [ N - 1 ] = A [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; -- i ) { Su@@ ff@@ Max@@ Arr [ i ] = Math . max ( Su@@ ff@@ Max@@ Arr [ i + 1 ] , A [ i + 1 ] ) ; } int Maximum@@ Sum = Integer . MIN_VALUE ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] < Su@@ ff@@ Max@@ Arr [ i ] ) Maximum@@ Sum = Math . max ( Maximum@@ Sum , A [ i ] + Su@@ ff@@ Max@@ Arr [ i ] ) ; } int Minimum@@ Sum = Integer . MAX_VALUE ; int Su@@ ff@@ Min@@ Arr [ ] = new int [ N ] ; Su@@ ff@@ Min@@ Arr [ N - 1 ] = Integer . MAX_VALUE ; for ( int i = N - 2 ; i >= 0 ; -- i ) { Su@@ ff@@ Min@@ Arr [ i ] = Math . min ( Su@@ ff@@ Min@@ Arr [ i + 1 ] , A [ i + 1 ] ) ; } for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] < Su@@ ff@@ Min@@ Arr [ i ] ) { Minimum@@ Sum = Math . min ( Minimum@@ Sum , A [ i ] + Su@@ ff@@ Min@@ Arr [ i ] ) ; } } return Math . abs ( Maximum@@ Sum - Minimum@@ Sum ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 1 , 3 , 7 , 5 , 6 } ; int N = arr . length ; System . out . println ( Get@@ Diff ( arr , N ) ) ; } }
import java . io . * ; import java . util . * ; class GF@@ G { static int sum@@ Of@@ Digits ( String s ) { int curr = 0 ; int ret = 0 ; for ( char ch : s . toCharArray ( ) ) { if ( ch >= 48 && ch <= 57 ) { curr = curr * 10 + ch - '0' ; } else { ret += curr ; curr = 0 ; } } ret += curr ; return ret ; } public static void main ( String [ ] args ) { String S = "11@@ aa@@ 32@@ bb@@ b@@ 5" ; System . out . print ( sum@@ Of@@ Digits ( S ) ) ; } }
public class GF@@ G { static void minimum@@ Operations ( int [ ] arr , int N ) { int odd@@ Cnt = 0 , even@@ Cnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { even@@ Cnt ++ ; } else { odd@@ Cnt ++ ; } } System . out . print ( Math . min ( odd@@ Cnt , even@@ Cnt ) ) ; } public static void main ( String args [ ] ) { int [ ] arr = { 4 , 1 , 2 } ; int N = arr . length ; minimum@@ Operations ( arr , N ) ; } }
import java . io . * ; import java . util . * ; class GF@@ G { static boolean check ( int a [ ] , int n ) { boolean flag = false ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( a [ i + 1 ] > a [ i ] && a [ i ] < a [ i - 1 ] ) flag = true ; } if ( flag ) return false ; else return true ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 5 , 2 } ; int N = arr . length ; if ( check ( arr , N ) ) System . out . print ( " YES " ) ; else System . out . print ( " NO " ) ; } }
import java . io . * ; import java . util . * ; class GF@@ G { static void min@@ Operations ( String S ) { int count = 0 ; for ( int i = 1 ; i < S . length ( ) ; i ++ ) { if ( S . charAt ( i ) != S . charAt ( i - 1 ) ) { count += 1 ; } } System . out . print ( count ) ; } public static void main ( String [ ] args ) { String S = "@@ 0101@@ 0101@@ 01" ; min@@ Operations ( S ) ; } }
import java . util . * ; class GF@@ G { static void numberOf@@ Pairs ( int arr [ ] , int N ) { int [ ] set_@@ bits = new int [ 31 ] ; Arrays . fill ( set_@@ bits , 0 ) ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int x = arr [ i ] ; int bit@@ pos = - 1 ; while ( x > 0 ) { bit@@ pos ++ ; x /= 2 ; } for ( int j = 0 ; j <= bit@@ pos ; j ++ ) { count += set_@@ bits [ j ] ; } set_@@ bits [ bit@@ pos ] ++ ; } System . out . println ( count ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 4 , 16 , 8 , 64 } ; int N = arr . length ; numberOf@@ Pairs ( arr , N ) ; } }
class GF@@ G { static void find@@ Maximum ( int arr [ ] , int N , int Q , int queries [ ] [ ] ) { int prefix_@@ max [ ] = new int [ N + 1 ] ; int suffix_@@ max [ ] = new int [ N + 1 ] ; prefix_@@ max [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { prefix_@@ max [ i ] = Math . max ( prefix_@@ max [ i - 1 ] , arr [ i ] ) ; } suffix_@@ max [ N - 1 ] = arr [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { suffix_@@ max [ i ] = Math . max ( suffix_@@ max [ i + 1 ] , arr [ i ] ) ; } for ( int i = 0 ; i < Q ; i ++ ) { int l = queries [ i ] [ 0 ] ; int r = queries [ i ] [ 1 ] ; if ( l == 0 && r == ( N - 1 ) ) System . out . print ( "@@ 0@@ NEW_@@ LINE@@ "@@ )@@ ; else if ( l == 0 ) System . out . print ( suffix_@@ max [ r + 1 ] + "@@ NEW_@@ LINE@@ "@@ )@@ ; else if ( r == ( N - 1 ) ) System . out . print ( prefix_@@ max [ l - 1 ] + "@@ NEW_@@ LINE@@ "@@ )@@ ; else System . out . print ( Math . max ( prefix_@@ max [ l - 1 ] , suffix_@@ max [ r + 1 ] ) + "@@ NEW_@@ LINE@@ "@@ )@@ ; } } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 6 , 8 , 10 , 15 } ; int N = arr . length ; int queries [ ] [ ] = { { 0 , 1 } , { 0 , 2 } , { 1 , 4 } } ; int Q = queries . length ; find@@ Maximum ( arr , N , Q , queries ) ; } }
class GF@@ G { static String min@@ Email ( String email ) { String ans = new String ( " " ) ; int len = email . length ( ) ; ans += email . charAt ( 0 ) ; int i = 1 ; boolean not@@ At = true ; while ( i < len ) { if ( i < len - 3 && not@@ At && email . charAt ( i ) == ' a ' && email . charAt ( i + 1 ) == ' t ' ) { ans += ' @ ' ; i += 1 ; not@@ At = false ; } else if ( i < len - 4 && email . charAt ( i ) == ' d ' && email . charAt ( i + 1 ) == ' o ' && email . charAt ( i + 2 ) == ' t ' ) { ans += ' . ' ; i += 2 ; } else { ans += email . charAt ( i ) ; } i += 1 ; } return ans ; } public static void main ( String [ ] args ) { String email = new String ( " ge@@ ek@@ s@@ forge@@ ek@@ sat@@ g@@ mail@@ dot@@ com " ) ; System . out . println ( min@@ Email ( email ) ) ; } }
import java . io . * ; class GF@@ G { static void count@@ Remaining@@ Elements ( int [ ] L1 , int [ ] L2 , int n ) { int one = 0 ; int zero = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( L1 [ i ] == 1 ) one ++ ; else zero ++ ; } int ans = n ; for ( int i = 0 ; i < n ; i ++ ) { if ( L2 [ i ] == 1 ) { one -- ; if ( one < 0 ) { ans = i ; break ; } } else { zero -- ; if ( zero < 0 ) { ans = i ; break ; } } } System . out . println ( n - ans ) ; } public static void main ( String [ ] args ) { int [ ] L1 = { 1 , 1 , 0 , 0 } ; int [ ] L2 = { 0 , 0 , 0 , 1 } ; int N = L1 . length ; count@@ Remaining@@ Elements ( L1 , L2 , N ) ; } }
class GF@@ G { static int LC@@ M ( int A , int B ) { return ( A * B / __@@ gcd ( A , B ) ) ; } static void find@@ S@@ malle@@ st@@ Number ( int X ) { int l@@ cm = 1 ; int temp = X ; while ( temp > 0 ) { int last = temp % 10 ; temp /= 10 ; if ( last == 0 ) continue ; l@@ cm = LC@@ M ( l@@ cm , last ) ; } int answer = ( ( X + l@@ cm - 1 ) / l@@ cm ) * l@@ cm ; System . out . print ( answer ) ; } static int __@@ gcd ( int a , int b ) { return b == 0 ? a : __@@ gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { int X = 280 ; find@@ S@@ malle@@ st@@ Number ( X ) ; } }
import java . io . * ; import java . util . * ; class GF@@ G { public static int find@@ Non@@ Multip@@ les ( int [ ] arr , int n , int k ) { Set < Integer > multip@@ les = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( ! multip@@ les . contains ( arr [ i ] ) ) { for ( int j = 1 ; j <= k / arr [ i ] ; j ++ ) { multip@@ les . add ( arr [ i ] * j ) ; } } } return k - multip@@ les . size ( ) ; } public static int count@@ Values ( int [ ] arr , int N , int L , int R ) { return find@@ Non@@ Multip@@ les ( arr , N , R ) - find@@ Non@@ Multip@@ les ( arr , N , L - 1 ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 2 , 3 , 4 , 5 , 6 } ; int N = arr . length ; int L = 1 ; int R = 20 ; System . out . println ( count@@ Values ( arr , N , L , R ) ) ; } }
import java . util . * ; class GF@@ G { static int find@@ Cnt@@ Trip@@ let ( int N ) { int cnt@@ Trip@@ let = 0 ; for ( int i = 1 ; i < N ; i ++ ) { if ( N % i != 0 ) { cnt@@ Trip@@ let += N / i ; } else { cnt@@ Trip@@ let += ( N / i ) - 1 ; } } return cnt@@ Trip@@ let ; } public static void main ( String [ ] args ) { int N = 3 ; System . out . println ( find@@ Cnt@@ Trip@@ let ( N ) ) ; } }
import java . util . * ; class GF@@ G { static void min@@ Collec@@ ting@@ Speed ( int [ ] pi@@ les , int H ) { int ans = - 1 ; int low = 1 , high ; high = Arrays . stream ( pi@@ les ) . max ( ) . getAs@@ Int ( ) ; while ( low <= high ) { int K = low + ( high - low ) / 2 ; int time = 0 ; for ( int ai : pi@@ les ) { time += ( ai + K - 1 ) / K ; } if ( time <= H ) { ans = K ; high = K - 1 ; } else { low = K + 1 ; } } System . out . print ( ans ) ; } static public void main ( String args [ ] ) { int [ ] arr = { 3 , 6 , 7 , 11 } ; int H = 8 ; min@@ Collec@@ ting@@ Speed ( arr , H ) ; } }
import java . util . * ; class GF@@ G { static int count@@ Sub@@ Array@@ Sign@@ Change ( int arr [ ] , int N ) { HashMap < Integer , Integer > prefix@@ Count = new HashMap < Integer , Integer > ( ) ; HashMap < Integer , Integer > suffix@@ Count = new HashMap < Integer , Integer > ( ) ; int total = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { total += arr [ i ] ; if ( suffix@@ Count . containsKey ( arr [ i ] ) ) { suffix@@ Count . put ( arr [ i ] , suffix@@ Count . get ( arr [ i ] ) + 1 ) ; } else { suffix@@ Count . put ( arr [ i ] , 1 ) ; } } int prefix@@ Sum = 0 ; int suffix@@ Sum = 0 ; int count = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { prefix@@ Sum += arr [ i ] ; if ( prefix@@ Count . containsKey ( arr [ i ] ) ) { prefix@@ Count . put ( arr [ i ] , prefix@@ Count . get ( arr [ i ] ) + 1 ) ; } else { prefix@@ Count . put ( arr [ i ] , 1 ) ; } suffix@@ Sum = total - prefix@@ Sum ; if ( suffix@@ Count . containsKey ( arr [ i ] ) ) { suffix@@ Count . put ( arr [ i ] , suffix@@ Count . get ( arr [ i ] ) - 1 ) ; } int diff = prefix@@ Sum - suffix@@ Sum ; if ( diff % 2 == 0 ) { int x = ( prefix@@ Count . containsKey ( diff / 2 ) ? prefix@@ Count . get ( diff / 2 ) : 0 ) + ( suffix@@ Count . containsKey ( - diff / 2 ) ? suffix@@ Count . get ( - diff / 2 ) : 0 ) ; count = count + x ; } } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 2 , - 3 , 3 } ; int N = arr . length ; System . out . print ( count@@ Sub@@ Array@@ Sign@@ Change ( arr , N ) ) ; } }
import java . util . * ; class GF@@ G { static int count@@ Common@@ Char ( int ind , String S ) { int cnt = 0 ; HashSet < Character > ls = new HashSet < Character > ( ) ; HashSet < Character > rs = new HashSet < Character > ( ) ; for ( int i = 0 ; i < ind ; ++ i ) { ls . add ( S . charAt ( i ) ) ; } for ( int i = ind ; i < S . length ( ) ; ++ i ) { rs . add ( S . charAt ( i ) ) ; } for ( char v : ls ) { if ( rs . contains ( v ) ) { ++ cnt ; } } return cnt ; } static void partition@@ String@@ With@@ Max@@ Com ( String S ) { int ans = 0 ; for ( int i = 1 ; i < S . length ( ) ; ++ i ) { ans = Math . max ( ans , count@@ Common@@ Char ( i , S ) ) ; } System . out . print ( ans + "@@ NEW_@@ LINE@@ "@@ )@@ ; } public static void main ( String [ ] args ) { String str = " aabb@@ ca " ; partition@@ String@@ With@@ Max@@ Com ( str ) ; } }
import java . util . * ; class GF@@ G { static String S@@ malle@@ st@@ String ( String s , char c ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) > c ) { String temp = s ; s = s . substring ( 0 , i ) ; s += c ; s += temp . substring ( i , temp . length ( ) ) ; return s ; } } s += c ; return s ; } public static void main ( String args [ ] ) { String S = " ac@@ d " ; char C = ' b ' ; System . out . println ( S@@ malle@@ st@@ String ( S , C ) ) ; } }
import java . util . * ; class GF@@ G { static int sum@@ Of@@ Path@@ Nodes ( int N ) { if ( N == 1 ) { return 1 ; } else if ( N == 2 N == 3 ) { return N + 1 ; } Vector < Integer > arr = new Vector < > ( ) ; arr . add ( 1 ) ; int k = 1 ; boolean flag = true ; while ( k < N ) { if ( flag == true ) { k *= 2 ; flag = false ; } else { k *= 4 ; flag = true ; } if ( k > N ) { break ; } arr . add ( k ) ; } int len = arr . size ( ) ; int [ ] prefix = new int [ len ] ; prefix [ 0 ] = 1 ; for ( int i = 1 ; i < len ; ++ i ) { prefix [ i ] = arr . get ( i ) + prefix [ i - 1 ] ; } int it = lowerBound ( prefix , 0 , len , N ) + 1 ; int ind = it - prefix [ 0 ] ; int final_@@ ans = 0 ; int temp = N ; while ( ind > 1 ) { int val = temp - prefix [ ind - 1 ] ; if ( ind % 2 != 0 ) { temp = prefix [ ind - 2 ] + ( val + 1 ) / 2 ; } else { temp = prefix [ ind - 2 ] + ( val + 3 ) / 4 ; } -- ind ; final_@@ ans += temp ; } final_@@ ans += ( N + 1 ) ; return final_@@ ans ; } static int lowerBound ( int [ ] a , int low , int high , int element ) { while ( low < high ) { int middle = low + ( high - low ) / 2 ; if ( element > a [ middle ] ) low = middle + 1 ; else high = middle ; } return low ; } public static void main ( String [ ] args ) { int N = 13 ; System . out . print ( sum@@ Of@@ Path@@ Nodes ( N ) + "@@ NEW_@@ LINE@@ "@@ )@@ ; } }
import java . util . * ; import java . util . Arrays ; import java . util . Collections ; class GF@@ G { static void re@@ arrange@@ Array ( int a [ ] , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += a [ i ] ; } if ( sum == 0 ) { System . out . print ( " - 1" ) ; return ; } sum = 0 ; int b = 0 ; Arrays . sort ( a ) ; for ( int i = 0 ; i < N ; i ++ ) { sum += a [ i ] ; if ( sum == 0 ) { if ( a [ i ] != a [ N - 1 ] ) { sum -= a [ i ] ; int temp = a [ i ] ; a [ i ] = a [ N - 1 ] ; a [ N - 1 ] = temp ; sum += a [ i ] ; } else { b = 1 ; break ; } } } if ( b == 1 ) { b = 0 ; sum = 0 ; Arrays . sort ( a ) ; for ( int i = N - 1 ; i >= 0 ; i -- ) { sum += a [ i ] ; if ( sum == 0 ) { if ( a [ i ] != a [ 0 ] ) { sum -= a [ i ] ; int temp = a [ i ] ; a [ i ] = a [ 0 ] ; a [ 0 ] = temp ; sum += a [ i ] ; } else { b = 1 ; break ; } } } } if ( b == 1 ) { System . out . print ( " - 1" + " ▁ " ) ; return ; } for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( a [ i ] + " ▁ " ) ; } } public static void main ( String args [ ] ) { int arr [ ] = { 1 , - 1 , 2 , 4 , 0 } ; int N = arr . length ; re@@ arrange@@ Array ( arr , N ) ; } }
import java . util . * ; class GF@@ G { static void find@@ Minimum@@ Operations ( char [ ] a , char [ ] b ) { int step = 0 ; int last_@@ index = 0 ; while ( ! Arrays . equals ( a , b ) ) { for ( int i = 0 ; i < a . length ; i ++ ) { if ( a [ i ] != b [ i ] ) { last_@@ index = i ; } } for ( int i = 0 ; i <= last_@@ index ; i ++ ) { a [ i ] = ( a [ i ] == '0' ) ? '1' : '0' ; } step ++ ; } System . out . print ( step ) ; } public static void main ( String [ ] args ) { String A = "@@ 101@@ 01@@ 0" , B = "11@@ 00@@ 11" ; find@@ Minimum@@ Operations ( A . toCharArray ( ) , B . toCharArray ( ) ) ; } }
import java . io . * ; import java . util . * ; class GF@@ G { static boolean is@@ Prime ( int num ) { if ( num <= 1 ) return false ; for ( int i = 2 ; i * i <= num ; i ++ ) if ( num % i == 0 ) return false ; return true ; } static boolean is@@ Ful@@ Prime ( int n ) { if ( ! is@@ Prime ( n ) ) return false ; else { while ( n > 0 ) { int rem = n % 10 ; if ( ! ( rem == 2 rem == 3 rem == 5 rem == 7 ) ) return false ; n = n / 10 ; } } return true ; } static int count@@ Ful@@ Prime ( int L , int R ) { int cnt = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( ( i % 2 ) != 0 && is@@ Ful@@ Prime ( i ) ) { cnt ++ ; } } return cnt ; } public static void main ( String [ ] args ) { int L = 1 , R = 100 ; int ans = 0 ; if ( L < 3 ) ans ++ ; System . out . println ( ans + count@@ Ful@@ Prime ( L , R ) ) ; } }
class GF@@ G { static boolean is_@@ prime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } static void count@@ Small@@ er@@ Pri@@ mes ( int ar [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int count = 0 ; for ( int j = i + 1 ; j < N ; j ++ ) { if ( ar [ j ] <= ar [ i ] && is_@@ prime ( ar [ j ] ) ) { count ++ ; } } System . out . print ( count + " ▁ " ) ; } } public static void main ( String [ ] args ) { int ar [ ] = { 43 , 3 , 5 , 7 , 2 , 41 } ; int N = ar . length ; count@@ Small@@ er@@ Pri@@ mes ( ar , N ) ; } }
import java . io . * ; class GF@@ G { static int minLength ( int arr [ ] , int N ) { for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ 0 ] != arr [ i ] ) { return 1 ; } } return N ; } public static void main ( String [ ] args ) { int [ ] arr = { 2 , 1 , 3 , 1 } ; int N = arr . length ; System . out . print ( minLength ( arr , N ) ) ; } }
class GF@@ G { static int num@@ Special ( int [ ] [ ] mat ) { int m = mat . length ; int n = mat [ 0 ] . length ; int [ ] rows = new int [ m ] ; int [ ] cols = new int [ n ] ; int i , j ; for ( i = 0 ; i < m ; i ++ ) { rows [ i ] = 0 ; for ( j = 0 ; j < n ; j ++ ) rows [ i ] += mat [ i ] [ j ] ; } for ( i = 0 ; i < n ; i ++ ) { cols [ i ] = 0 ; for ( j = 0 ; j < m ; j ++ ) cols [ i ] += mat [ j ] [ i ] ; } int cnt = 0 ; for ( i = 0 ; i < m ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] == 1 && rows [ i ] == 1 && cols [ j ] == 1 ) cnt ++ ; } } return cnt ; } public static void main ( String [ ] args ) { int [ ] [ ] mat = { { 1 , 0 , 0 } , { 0 , 0 , 1 } , { 0 , 0 , 0 } } ; System . out . print ( num@@ Special ( mat ) + "@@ NEW_@@ LINE@@ "@@ )@@ ; } }
import java . util . * ; class GF@@ G { public static Vector < Integer > min@@ max@@ Numbers ( int [ ] [ ] matrix , Vector < Integer > res ) { Set < Integer > set = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < matrix . length ; i ++ ) { int min@@ r = Integer . MAX_VALUE ; for ( int j = 0 ; j < matrix [ i ] . length ; j ++ ) { min@@ r = Math . min ( min@@ r , matrix [ i ] [ j ] ) ; } set . add ( min@@ r ) ; } for ( int j = 0 ; j < matrix [ 0 ] . length ; j ++ ) { int max@@ c = Integer . MIN_VALUE ; for ( int i = 0 ; i < matrix . length ; i ++ ) { max@@ c = Math . max ( max@@ c , matrix [ i ] [ j ] ) ; } if ( set . contains ( max@@ c ) ) { res . add ( max@@ c ) ; } } return res ; } public static void main ( String [ ] args ) { int [ ] [ ] mat = { { 1 , 10 , 4 } , { 9 , 3 , 8 } , { 15 , 16 , 17 } } ; Vector < Integer > ans = new Vector < Integer > ( ) ; ans = min@@ max@@ Numbers ( mat , ans ) ; if ( ans . size ( ) == 0 ) System . out . println ( " - 1" ) ; for ( int i = 0 ; i < ans . size ( ) ; i ++ ) System . out . println ( ans . get ( i ) ) ; } }
class GF@@ G { static int count@@ Pre@@ ce@@ ding@@ K ( int a [ ] , int n , int K ) { int [ ] prefix = new int [ n ] ; prefix [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] + a [ i ] ; } int ctr = 0 ; if ( prefix [ K - 1 ] < a [ K ] ) ctr ++ ; for ( int i = K + 1 ; i < n ; i ++ ) { if ( prefix [ i - 1 ] - prefix [ i - K - 1 ] < a [ i ] ) ctr ++ ; } return ctr ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 8 , 10 , - 2 , 7 , 5 , 5 , 9 , 15 } ; int N = arr . length ; int K = 2 ; System . out . print ( count@@ Pre@@ ce@@ ding@@ K ( arr , N , K ) ) ; } }
import java . util . * ; import java . lang . * ; class GF@@ G { static final int M = 1000 ; static int count@@ Num ( int N , int sum , int K , int st , int dp [ ] [ ] [ ] ) { if ( N == 0 && sum == 0 ) { return 1 ; } if ( N < 0 ) { return 0 ; } if ( dp [ N ] [ sum ] [ st ] != - 1 ) { return dp [ N ] [ sum ] [ st ] ; } int res = 0 ; int start = st == 1 ? 0 : 1 ; for ( int i = start ; i <= 9 ; i ++ ) { res += count@@ Num ( N - 1 , ( sum + i ) % K , K , ( ( st i ) > 0 ) ? 1 : 0 , dp ) ; } return dp [ N ] [ sum ] [ st ] = res ; } public static void main ( String [ ] args ) { int N = 2 , K = 7 ; int [ ] [ ] [ ] dp = new int [ M ] [ M ] [ 2 ] ; for ( int [ ] [ ] i : dp ) for ( int [ ] j : i ) Arrays . fill ( j , - 1 ) ; System . out . print ( count@@ Num ( N , 0 , K , 0 , dp ) ) ; } }
import java . util . * ; import java . lang . * ; class GF@@ G { static int min@@ Deletion ( String str ) { int n = str . length ( ) ; int first@@ Id@@ x1 = - 1 ; int last@@ Id@@ x0 = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == '1' ) { first@@ Id@@ x1 = i ; break ; } } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( str . charAt ( i ) == '0' ) { last@@ Id@@ x0 = i ; break ; } } if ( first@@ Id@@ x1 == - 1 last@@ Id@@ x0 == - 1 ) return 0 ; int count@@ 1 = 0 , count@@ 0 = 0 ; for ( int i = 0 ; i < last@@ Id@@ x0 ; i ++ ) { if ( str . charAt ( i ) == '1' ) { count@@ 1 ++ ; } } for ( int i = first@@ Id@@ x1 + 1 ; i < n ; i ++ ) { if ( str . charAt ( i ) == '1' ) { count@@ 0 ++ ; } } return Math . min ( count@@ 0 , count@@ 1 ) ; } public static void main ( String [ ] args ) { String str = "100@@ 01@@ 01" ; System . out . println ( min@@ Deletion ( str ) ) ; } }
import java . util . * ; class GF@@ G { public static void print_@@ substring ( String s ) { int n = s . length ( ) ; String str = " " ; Vector < Integer > ans = new Vector < Integer > ( ) ; if ( n == 0 ) { System . out . print ( " - 1" ) ; return ; } int [ ] last_@@ pos = new int [ 26 ] ; Arrays . fill ( last_@@ pos , - 1 ) ; for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( last_@@ pos [ s . charAt ( i ) - ' a ' ] == - 1 ) { last_@@ pos [ s . charAt ( i ) - ' a ' ] = i ; } } int min@@ p = - 1 ; for ( int i = 0 ; i < n ; ++ i ) { int lp = last_@@ pos [ s . charAt ( i ) - ' a ' ] ; min@@ p = Math . max ( min@@ p , lp ) ; if ( i == min@@ p ) { str += s . charAt ( i ) ; System . out . print ( str + ' ▁ ' ) ; min@@ p = - 1 ; str = " " ; } else { str += s . charAt ( i ) ; } } } public static void main ( String [ ] args ) { String S = " abab@@ cb@@ acade@@ fe@@ g@@ de@@ hi@@ jh@@ k@@ li@@ j " ; print_@@ substring ( S ) ; } }
import java . util . * ; class GF@@ G { static void partition@@ String ( String s ) { int n = s . length ( ) ; Vector < Integer > ans = new Vector < Integer > ( ) ; if ( n == 0 ) { System . out . print ( " - 1" ) ; return ; } int [ ] last_@@ pos = new int [ 26 ] ; Arrays . fill ( last_@@ pos , - 1 ) ; for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( last_@@ pos [ s . charAt ( i ) - ' a ' ] == - 1 ) { last_@@ pos [ s . charAt ( i ) - ' a ' ] = i ; } } int min@@ p = - 1 , p@@ len = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int lp = last_@@ pos [ s . charAt ( i ) - ' a ' ] ; min@@ p = Math . max ( min@@ p , lp ) ; ++ p@@ len ; if ( i == min@@ p ) { ans . add ( p@@ len ) ; min@@ p = - 1 ; p@@ len = 0 ; } } for ( int i = 0 ; i < ( int ) ans . size ( ) ; i ++ ) { System . out . print ( ans . get ( i ) + " ▁ " ) ; } } public static void main ( String [ ] args ) { String str = " ac@@ bb@@ cc " ; partition@@ String ( str ) ; } }
import java . util . * ; class GF@@ G { static boolean check ( String s , int k ) { int n = s . length ( ) ; for ( int i = 0 ; i < k ; i ++ ) { for ( int j = i ; j < n ; j += k ) { if ( s . charAt ( i ) != s . charAt ( j ) ) return false ; } } int c = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( s . charAt ( i ) == '0' ) c ++ ; else c -- ; } if ( c == 0 ) return true ; else return false ; } public static void main ( String [ ] args ) { String s = "@@ 101@@ 01@@ 0" ; int k = 2 ; if ( check ( s , k ) ) System . out . print ( " Yes " + "@@ NEW_@@ LINE@@ "@@ )@@ ; else System . out . print ( " No " + "@@ NEW_@@ LINE@@ "@@ )@@ ; } }
import java . util . * ; class GF@@ G { static int max@@ GC@@ D ( int n ) { int max@@ H@@ cf = Integer . MIN_VALUE ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i + 1 ; j <= n ; j ++ ) { max@@ H@@ cf = Math . max ( max@@ H@@ cf , __@@ gcd ( i , j ) ) ; } } return max@@ H@@ cf ; } static int __@@ gcd ( int a , int b ) { return b == 0 ? a : __@@ gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . print ( max@@ GC@@ D ( n ) ) ; } }
import java . util . * ; import java . lang . * ; class GF@@ G { static final double eps = 1e-6 ; static double func ( double a , double b , double c , double x ) { return a * x * x + b * x + c ; } static double find@@ Root ( double a , double b , double c , double low , double high ) { double x = - 1 ; while ( Math . abs ( high - low ) > eps ) { x = ( low + high ) / 2 ; if ( func ( a , b , c , low ) * func ( a , b , c , x ) <= 0 ) { high = x ; } else { low = x ; } } return x ; } static void solve ( double a , double b , double c , double A , double B ) { if ( func ( a , b , c , A ) * func ( a , b , c , B ) > 0 ) { System . out . println ( " No ▁ solution " ) ; } else { System . out . format ( " % .@@ 4f " , find@@ Root ( a , b , c , A , B ) ) ; } } public static void main ( String [ ] args ) { double a = 2 , b = - 3 , c = - 2 , A = 0 , B = 3 ; solve ( a , b , c , A , B ) ; } }
class GF@@ G { static int [ ] find@@ Sub@@ arrays ( int [ ] a ) { int n = a . length ; int [ ] freq = new int [ n + 1 ] ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { if ( count == 0 ) continue ; else { int value = count ; for ( int j = 1 ; j <= count ; j ++ ) { freq [ j ] += value ; value -- ; } count = 0 ; } } else count ++ ; } if ( count > 0 ) { int value = count ; for ( int j = 1 ; j <= count ; j ++ ) { freq [ j ] += value ; value -- ; } } return freq ; } static void count@@ Rect@@ angles ( int [ ] a , int [ ] b , int K ) { int n = a . length ; int m = b . length ; int [ ] sub@@ A = find@@ Sub@@ arrays ( a ) ; int [ ] sub@@ B = find@@ Sub@@ arrays ( b ) ; int total = 0 ; for ( int i = 1 ; i < sub@@ A . length ; i ++ ) { if ( K % i == 0 && ( K / i ) <= m ) { total = total + sub@@ A [ i ] * sub@@ B [ K / i ] ; } } System . out . print ( total ) ; } public static void main ( String [ ] args ) { int [ ] a = { 0 , 0 , 1 , 1 } ; int [ ] b = { 1 , 0 , 1 } ; int K = 2 ; count@@ Rect@@ angles ( a , b , K ) ; } }
import java . util . * ; class GF@@ G { static void print@@ Res ( Vector < Integer > res ) { Enumeration en@@ u = res . elements ( ) ; while ( en@@ u . hasMoreElements ( ) ) { System . out . print ( en@@ u . nextElement ( ) + " ▁ " ) ; } } static void print@@ L@@ BS ( int arr [ ] , int N ) { int lis [ ] = new int [ N ] ; int lds [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { lis [ i ] = lds [ i ] = 1 ; } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] < arr [ i ] ) { if ( lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; } } } for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = N - 1 ; j > i ; j -- ) { if ( arr [ j ] < arr [ i ] ) { if ( lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; } } } int Max@@ Val = arr [ 0 ] , inx = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( Max@@ Val < lis [ i ] + lds [ i ] - 1 ) { Max@@ Val = lis [ i ] + lds [ i ] - 1 ; inx = i ; } } int ct@@ 1 = lis [ inx ] ; Vector < Integer > res = new Vector < Integer > ( ) ; for ( int i = inx ; i >= 0 && ct@@ 1 > 0 ; i -- ) { if ( lis [ i ] == ct@@ 1 ) { res . add ( arr [ i ] ) ; ct@@ 1 -- ; } } Collections . reverse ( res ) ; int ct2 = lds [ inx ] - 1 ; for ( int i = inx ; i < N && ct2 > 0 ; i ++ ) { if ( lds [ i ] == ct2 ) { res . add ( arr [ i ] ) ; ct2 -- ; } } print@@ Res ( res ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 80 , 60 , 30 , 40 , 20 , 10 } ; int N = arr . length ; print@@ L@@ BS ( arr , N ) ; } }
import java . util . * ; class GF@@ G { static void solve ( int n , int arr [ ] ) { int i , ans = 0 ; for ( i = 0 ; i < n ; i ++ ) { int left = Math . max ( i - 1 , 0 ) ; int right = Math . min ( n - 1 , i + 1 ) ; while ( left >= 0 ) { if ( arr [ left ] > arr [ i ] ) { left ++ ; break ; } left -- ; } if ( left < 0 ) left ++ ; while ( right < n ) { if ( arr [ right ] > arr [ i ] ) { right -- ; break ; } right ++ ; } if ( right >= n ) right -- ; ans = 1 + right - left ; System . out . print ( ans + " ▁ " ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 2 , 1 } ; int n = arr . length ; solve ( n , arr ) ; } }
import java . util . * ; import java . io . * ; class GF@@ G { static int getS@@ um ( int BIT@@ ree [ ] , int index ) { int ans = 0 ; index += 1 ; while ( index > 0 ) { ans += BIT@@ ree [ index ] ; index -= index & ( - index ) ; } return ans ; } static void update@@ BIT ( int BIT@@ ree [ ] , int n , int index , int val ) { index = index + 1 ; while ( index <= n ) { BIT@@ ree [ index ] += val ; index += index & ( - index ) ; } } static int [ ] construct@@ BIT@@ ree ( int arr [ ] , int n ) { int [ ] BIT@@ ree = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) BIT@@ ree [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) update@@ BIT ( BIT@@ ree , n , i , arr [ i ] ) ; return BIT@@ ree ; } static int get@@ LowerBound ( int BIT@@ ree [ ] , int [ ] arr , int n , int k ) { int lb = - 1 ; int l = 0 , r = n - 1 ; while ( l <= r ) { int mid = l + ( r - l ) / 2 ; if ( getS@@ um ( BIT@@ ree , mid ) >= k ) { r = mid - 1 ; lb = mid ; } else l = mid + 1 ; } return lb ; } static void perform@@ Queries ( int A [ ] , int n , int q [ ] [ ] ) { int [ ] BIT@@ ree = construct@@ BIT@@ ree ( A , n ) ; for ( int i = 0 ; i < q . length ; i ++ ) { int id = q [ i ] [ 0 ] ; if ( id == 1 ) { int idx = q [ i ] [ 1 ] ; int val = q [ i ] [ 2 ] ; A [ idx ] += val ; update@@ BIT ( BIT@@ ree , n , idx , val ) ; } else { int k = q [ i ] [ 1 ] ; int lb = get@@ LowerBound ( BIT@@ ree , A , n , k ) ; System . out . println ( lb ) ; } } } public static void main ( String [ ] args ) { int A [ ] = { 1 , 2 , 3 , 5 , 8 } ; int n = A . length ; int [ ] [ ] q = { { 1 , 0 , 2 } , { 2 , 5 } , { 1 , 3 , 5 } } ; perform@@ Queries ( A , n , q ) ; } }
class GF@@ G { static boolean Continuous@@ Elements ( int a [ ] , int n ) { if ( n == 1 ) return false ; int curr = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] != a [ i - 1 ] ) { if ( curr == 1 ) return false ; else curr = 0 ; } curr ++ ; } if ( curr == 1 ) return false ; return true ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 1 , 2 , 2 , 1 , 3 , 3 } ; int n = a . length ; if ( Continuous@@ Elements ( a , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; class GF@@ G { static void maximum@@ Count ( int A [ ] , int B [ ] , int n ) { Queue < Integer > q = new LinkedList < > ( ) ; HashSet < Integer > s = new HashSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { s . add ( B [ i ] ) ; q . add ( B [ i ] ) ; } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! s . contains ( A [ i ] ) ) continue ; while ( ! q . isEmpty ( ) && q . peek ( ) != A [ i ] ) { s . remove ( q . peek ( ) ) ; q . remove ( ) ; count ++ ; } if ( A [ i ] == q . peek ( ) ) { q . remove ( ) ; s . remove ( A [ i ] ) ; } if ( q . isEmpty ( ) ) break ; } System . out . print ( count + "@@ NEW_@@ LINE@@ "@@ )@@ ; } public static void main ( String [ ] args ) { int N = 4 ; int A [ ] = { 1 , 2 , 3 , 4 } ; int B [ ] = { 1 , 2 , 4 , 3 } ; maximum@@ Count ( A , B , N ) ; } }
import java . util . * ; class GF@@ G { static int count_@@ elements ( int arr [ ] , int n ) { int count = 1 ; int max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { count += 1 ; max = arr [ i ] ; } } return count ; } public static void main ( String s [ ] ) { int arr [ ] = { 2 , 1 , 4 , 6 , 3 } ; int n = arr . length ; System . out . print ( count_@@ elements ( arr , n ) ) ; } }
import java . util . * ; class GF@@ G { public static int find@@ Subset ( int [ ] a , int n ) { int sum = 0 ; int cnt = 0 ; Vector < Integer > v = new Vector < > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( a [ i - 1 ] - i <= 0 ) { sum += a [ i - 1 ] - i ; cnt += 1 ; } else { v . add ( a [ i - 1 ] - i ) ; } } Collections . sort ( v ) ; int ptr = 0 ; while ( ptr < v . size ( ) && sum + v . get ( ptr ) <= 0 ) { cnt += 1 ; ptr += 1 ; sum += v . get ( ptr ) ; } return cnt ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 1 , 6 , 7 , 8 , 2 } ; int n = arr . length ; System . out . println ( find@@ Subset ( arr , n ) ) ; } }
import java . util . * ; class GF@@ G { static void check@@ Array ( int A [ ] , int B [ ] , int N ) { int start = 0 ; int end = N - 1 ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] != B [ i ] ) { start = i ; break ; } } for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( A [ i ] != B [ i ] ) { end = i ; break ; } } Collections . reverse ( Arrays . asList ( A ) ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] != B [ i ] ) { System . out . println ( " No " ) ; return ; } } System . out . println ( " Yes " ) ; } public static void main ( String [ ] args ) { int A [ ] = { 1 , 3 , 2 , 4 } ; int B [ ] = { 1 , 2 , 3 , 4 } ; int N = A . length ; check@@ Array ( A , B , N ) ; } }
import java . util . * ; class GF@@ G { static int get_@@ sub@@ set_@@ count ( int arr [ ] , int K , int N ) { Arrays . sort ( arr ) ; int left , right ; left = 0 ; right = N - 1 ; int ans = 0 ; while ( left <= right ) { if ( arr [ left ] + arr [ right ] < K ) { ans += 1 << ( right - left ) ; left ++ ; } else { right -- ; } } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 5 , 7 } ; int K = 8 ; int N = arr . length ; System . out . print ( get_@@ sub@@ set_@@ count ( arr , K , N ) ) ; } }
class GF@@ G { static int binary_@@ sear@@ ched_@@ find_@@ x ( int k ) { int l = 0 ; int r = k ; int ans = 0 ; while ( l <= r ) { int mid = l + ( r - l ) / 2 ; if ( Math . pow ( ( ( mid * ( mid + 1 ) ) / 2 ) , 2 ) >= k ) { ans = mid ; r = mid - 1 ; } else { l = mid + 1 ; } } return ans ; } public static void main ( String [ ] args ) { int N = 100 ; System . out . println ( binary_@@ sear@@ ched_@@ find_@@ x ( N ) ) ; } }
import java . io . * ; import java . util . * ; class GF@@ G { static int len@@ Of@@ Long@@ Z@@ ig@@ Z@@ ag@@ Arr ( int a [ ] , int n ) { int max = 1 , len = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( i % 2 == 0 && ( a [ i ] < a [ i + 1 ] ) ) len ++ ; else if ( i % 2 == 1 && ( a [ i ] > a [ i + 1 ] ) ) len ++ ; else { if ( max < len ) max = len ; len = 1 ; } } if ( max < len ) max = len ; return max ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = arr . length ; System . out . println ( len@@ Of@@ Long@@ Z@@ ig@@ Z@@ ag@@ Arr ( arr , n ) ) ; } }
import java . util . * ; class GF@@ G { static int check@@ Per@@ fec@@ t@@ Square ( long N , long start , long last ) { long mid = ( start + last ) / 2 ; if ( start > last ) { return - 1 ; } if ( mid * mid == N ) { return ( int ) mid ; } else if ( mid * mid > N ) { return check@@ Per@@ fec@@ t@@ Square ( N , start , mid - 1 ) ; } else { return check@@ Per@@ fec@@ t@@ Square ( N , mid + 1 , last ) ; } } public static void main ( String [ ] args ) { long N = 65 ; System . out . println ( check@@ Per@@ fec@@ t@@ Square ( N , 1 , N ) ) ; } }
class GF@@ G { static void find@@ Sub@@ Array ( int [ ] a , int n , int k ) { int [ ] pref = new int [ n ] ; pref [ 0 ] = 0 ; for ( int i = 1 ; i < n - 1 ; ++ i ) { pref [ i ] = pref [ i - 1 ] ; if ( a [ i ] > a [ i - 1 ] && a [ i ] > a [ i + 1 ] ) pref [ i ] ++ ; } int peak = 0 , left = 0 ; for ( int i = 0 ; i + k - 1 < n ; ++ i ) if ( pref [ i + k - 2 ] - pref [ i ] > peak ) { peak = pref [ i + k - 2 ] - pref [ i ] ; left = i ; } System . out . print ( " Left ▁ = ▁ " + ( left + 1 ) + "@@ NEW_@@ LINE@@ "@@ )@@ ; System . out . print ( " Right ▁ = ▁ " + ( left + k ) + "@@ NEW_@@ LINE@@ "@@ )@@ ; System . out . print ( " Peak ▁ = ▁ " + peak + "@@ NEW_@@ LINE@@ "@@ )@@ ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 2 , 3 , 2 , 1 } ; int n = arr . length ; int k = 3 ; find@@ Sub@@ Array ( arr , n , k ) ; } }
import java . util . * ; class GF@@ G { static void Find@@ Rank ( int arr [ ] , int length ) { System . out . print ( "1" + " ▁ " ) ; for ( int i = 1 ; i < arr . length ; i ++ ) { int rank = 1 ; for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] > arr [ i ] ) rank ++ ; } System . out . print ( rank + " ▁ " ) ; } } public static void main ( String args [ ] ) { int arr [ ] = { 88 , 14 , 69 , 30 , 29 , 89 } ; int len = arr . length ; Find@@ Rank ( arr , len ) ; } }
import java . util . * ; class GF@@ G { static int MAX = 10000@@ 05 ; static int [ ] fi@@ b@@ Up@@ to = new int [ MAX + 1 ] ; static void compute ( int sz ) { boolean [ ] is@@ Fi@@ b = new boolean [ sz + 1 ] ; int prev = 0 , curr = 1 ; is@@ Fi@@ b [ prev ] = is@@ Fi@@ b [ curr ] = true ; while ( curr <= sz ) { int temp = curr + prev ; if ( temp <= sz ) is@@ Fi@@ b [ temp ] = true ; prev = curr ; curr = temp ; } fi@@ b@@ Up@@ to [ 0 ] = 1 ; for ( int i = 1 ; i <= sz ; i ++ ) { fi@@ b@@ Up@@ to [ i ] = fi@@ b@@ Up@@ to [ i - 1 ] ; if ( is@@ Fi@@ b [ i ] ) fi@@ b@@ Up@@ to [ i ] ++ ; } } static int count@@ Of@@ Numbers ( int N , int K ) { compute ( N ) ; int low = 1 , high = N , ans = 0 ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; if ( mid - fi@@ b@@ Up@@ to [ mid ] >= K ) { ans = mid ; high = mid - 1 ; } else low = mid + 1 ; } return ( ans > 0 ? N - ans + 1 : 0 ) ; } public static void main ( String [ ] args ) { int N = 10 , K = 3 ; System . out . print ( count@@ Of@@ Numbers ( N , K ) ) ; } }
import java . util . * ; class GF@@ G { static int MAX = 26 ; static Vector < Integer > find@@ Count ( String a [ ] , String b [ ] , int n , int m ) { int [ ] freq = new int [ MAX ] ; Vector < Integer > smalle@@ st@@ Freq = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String s = a [ i ] ; Arrays . fill ( freq , 0 ) ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) { freq [ s . charAt ( j ) - ' a ' ] ++ ; } for ( int j = 0 ; j < MAX ; j ++ ) { if ( freq [ j ] > 0 ) { smalle@@ st@@ Freq . add ( freq [ j ] ) ; break ; } } } Collections . sort ( smalle@@ st@@ Freq ) ; Vector < Integer > ans = new Vector < Integer > ( ) ; for ( int i = 0 ; i < m ; i ++ ) { String s = b [ i ] ; Arrays . fill ( freq , 0 ) ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) { freq [ s . charAt ( j ) - ' a ' ] ++ ; } int frequency = 0 ; for ( int j = 0 ; j < MAX ; j ++ ) { if ( freq [ j ] > 0 ) { frequency = freq [ j ] ; break ; } } int [ ] array = new int [ smalle@@ st@@ Freq . size ( ) ] ; int k = 0 ; for ( Integer val : smalle@@ st@@ Freq ) { array [ k ] = val ; k ++ ; } int ind = lower_bound ( array , 0 , smalle@@ st@@ Freq . size ( ) , frequency ) ; ans . add ( ind ) ; } return ans ; } static int lower_bound ( int [ ] a , int low , int high , int element ) { while ( low < high ) { int middle = low + ( high - low ) / 2 ; if ( element > a [ middle ] ) low = middle + 1 ; else high = middle ; } return low ; } static void print@@ Answer ( String a [ ] , String b [ ] , int n , int m ) { Vector < Integer > ans = find@@ Count ( a , b , n , m ) ; for ( Integer it : ans ) { System . out . print ( it + " ▁ " ) ; } } public static void main ( String [ ] args ) { String A [ ] = { " aaa " , " aa " , " b@@ dc " } ; String B [ ] = { " cc@@ c@@ ch " , " cc@@ cd " } ; int n = A . length ; int m = B . length ; print@@ Answer ( A , B , n , m ) ; } }
import java . util . * ; class GF@@ G { static int count@@ LessThan ( int arr [ ] , int n , int key ) { int l = 0 , r = n - 1 ; int index = - 1 ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( arr [ m ] < key ) { l = m + 1 ; index = m ; } else { r = m - 1 ; } } return ( index + 1 ) ; } static int count@@ GreaterThan ( int arr [ ] , int n , int key ) { int l = 0 , r = n - 1 ; int index = - 1 ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( arr [ m ] <= key ) { l = m + 1 ; } else { r = m - 1 ; index = m ; } } if ( index == - 1 ) return 0 ; return ( n - index ) ; } static int count@@ Trip@@ lets ( int n , int a [ ] , int b [ ] , int c [ ] ) { Arrays . sort ( a ) ; Arrays . sort ( b ) ; Arrays . sort ( c ) ; int count = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int current = b [ i ] ; int low = count@@ LessThan ( a , n , current ) ; int high = count@@ GreaterThan ( c , n , current ) ; count += ( low * high ) ; } return count ; } public static void main ( String args [ ] ) { int a [ ] = { 1 , 5 } ; int b [ ] = { 2 , 4 } ; int c [ ] = { 3 , 6 } ; int size = a . length ; System . out . println ( count@@ Trip@@ lets ( size , a , b , c ) ) ; } }
import java . util . * ; class GF@@ G { static int di@@ visor@@ count ( int elem ) { int ans = 0 ; for ( int i = 1 ; i <= Math . sqrt ( elem ) ; i ++ ) { if ( elem % i == 0 ) { if ( i * i == elem ) ans ++ ; else ans += 2 ; } } return ans ; } static String find@@ winner ( int A [ ] , int B [ ] , int N , int M ) { for ( int i = 0 ; i < N ; i ++ ) { A [ i ] = di@@ visor@@ count ( A [ i ] ) ; } for ( int i = 0 ; i < M ; i ++ ) { B [ i ] = di@@ visor@@ count ( B [ i ] ) ; } Arrays . sort ( A ) ; Arrays . sort ( B ) ; int win@@ A = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int val = A [ i ] ; int start = 0 ; int end = M - 1 ; int index = - 1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( B [ mid ] <= val ) { index = mid ; start = mid + 1 ; } else { end = mid - 1 ; } } win@@ A += ( index + 1 ) ; } int win@@ B = N * M - win@@ A ; if ( win@@ A > win@@ B ) { return " A " ; } else if ( win@@ B > win@@ A ) { return " B " ; } return " Draw " ; } public static void main ( String [ ] args ) { int A [ ] = { 4 , 12 , 24 } ; int N = A . length ; int B [ ] = { 25 , 28 , 13 , 45 } ; int M = B . length ; System . out . print ( find@@ winner ( A , B , N , M ) ) ; } }
class GF@@ G { static boolean is@@ Possible ( int arr [ ] , int n , int dist , int k ) { int req = 0 ; int curr = 0 ; int prev = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( curr != n && arr [ curr ] - arr [ prev ] <= dist ) { curr ++ ; } req ++ ; if ( curr == n ) { break ; } prev = curr - 1 ; } if ( curr != n ) { return false ; } if ( req <= k ) { return true ; } return false ; } static int min@@ Distance ( int arr [ ] , int n , int k ) { int l = 0 ; int h = arr [ n - 1 ] ; int ans = 0 ; while ( l <= h ) { int m = ( l + h ) / 2 ; if ( is@@ Possible ( arr , n , m , k ) ) { ans = m ; h = m - 1 ; } else { l = m + 1 ; } } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 15 , 36 , 43 } ; int n = arr . length ; int k = 2 ; System . out . println ( min@@ Distance ( arr , n , k ) ) ; } }
class GF@@ G { static int count@@ Factor ( int P , int X ) { if ( X < P ) return 0 ; return ( X / P + count@@ Factor ( P , X / P ) ) ; } static int find@@ S@@ malle@@ st@@ X ( int Y ) { int low = 0 , high = 5 * Y ; int N = 0 ; while ( low <= high ) { int mid = ( high + low ) / 2 ; if ( count@@ Factor ( 5 , mid ) < Y ) { low = mid + 1 ; } else { N = mid ; high = mid - 1 ; } } return N ; } public static void main ( String args [ ] ) { int Y = 10 ; System . out . println ( find@@ S@@ malle@@ st@@ X ( Y ) ) ; } }
import java . util . * ; class Gf@@ G { static boolean prime [ ] = new boolean [ 1000000 + 5 ] ; static void find@@ Prime ( ) { Arrays . fill ( prime , true ) ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= 1000000 ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= 1000000 ; i += p ) prime [ i ] = false ; } } } static int len@@ Of@@ Long@@ Sub@@ arr ( int arr [ ] , int n ) { Map < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ; int sum = 0 , maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += prime [ arr [ i ] ] == false ? - 1 : 1 ; if ( sum == 1 ) maxLen = i + 1 ; else if ( ! um . containsKey ( sum ) ) um . put ( sum , i ) ; if ( um . containsKey ( sum - 1 ) ) { if ( maxLen < ( i - um . get ( sum - 1 ) ) ) maxLen = i - um . get ( sum - 1 ) ; } } return maxLen ; } public static void main ( String [ ] args ) { find@@ Prime ( ) ; int arr [ ] = { 1 , 9 , 3 , 4 , 5 , 6 , 7 , 8 } ; int n = arr . length ; System . out . println ( len@@ Of@@ Long@@ Sub@@ arr ( arr , n ) ) ; } }
import java . util . * ; class GF@@ G { static int value ; static boolean canBe@@ Optim@@ al@@ Value ( int K , int arr [ ] , int N , int B ) { int [ ] tmp = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) tmp [ i ] = ( arr [ i ] + K * ( i + 1 ) ) ; Arrays . sort ( tmp ) ; value = 0 ; for ( int i = 0 ; i < K ; i ++ ) value += tmp [ i ] ; return value <= B ; } static void find@@ NoOf@@ Element@@ sand@@ Value ( int arr [ ] , int N , int B ) { int ans = 0 ; value = 0 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( canBe@@ Optim@@ al@@ Value ( mid , arr , N , B ) ) { ans = mid ; start = mid + 1 ; } else end = mid - 1 ; } canBe@@ Optim@@ al@@ Value ( ans , arr , N , B ) ; System . out . print ( ans + " ▁ " + value + "@@ NEW_@@ LINE@@ "@@ )@@ ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 5 , 6 , 3 } ; int N = arr . length ; int B = 90 ; find@@ NoOf@@ Element@@ sand@@ Value ( arr , N , B ) ; } }
import java . io . * ; import java . util . * ; class GF@@ G { static void lex@@ i@@ Middle@@ S@@ malle@@ st ( int K , int N ) { if ( K % 2 == 0 ) { System . out . print ( K / 2 + " ▁ " ) ; for ( int i = 0 ; i < N - 1 ; ++ i ) { System . out . print ( K + " ▁ " ) ; } System . out . println ( ) ; return ; } ArrayList < Integer > a = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < N / 2 ; ++ i ) { if ( a . get ( a . size ( ) - 1 ) == 1 ) { a . remove ( a . size ( ) - 1 ) ; } else { int t = a . get ( a . size ( ) - 1 ) - 1 ; a . set ( a . get ( a . size ( ) - 1 ) , t ) ; while ( a . size ( ) < N ) { a . add ( K ) ; } } } for ( int i : a ) { System . out . print ( i + " ▁ " ) ; } System . out . println ( ) ; } public static void main ( String [ ] args ) { int K = 2 , N = 4 ; lex@@ i@@ Middle@@ S@@ malle@@ st ( K , N ) ; } }
import java . util . * ; class GF@@ G { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static void find@@ Pair ( pair arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int a = arr [ i ] . first , b = arr [ i ] . second ; for ( int j = i + 1 ; j < N ; j ++ ) { int c = arr [ j ] . first , d = arr [ j ] . second ; if ( a < c && b > d ) { System . out . println ( " ( " + a + " ▁ " + b + " ) , ▁ ( " + c + " ▁ " + d + " ) " ) ; return ; } } } System . out . println ( " NO ▁ SUCH ▁ PAIR ▁ EXIST " ) ; } public static void main ( String [ ] args ) { pair arr [ ] = { new pair ( 3 , 7 ) , new pair ( 21 , 23 ) , new pair ( 4 , 13 ) , new pair ( 1 , 2 ) , new pair ( 7 , - 1 ) } ; find@@ Pair ( arr , 5 ) ; } }
import java . io . * ; import java . util . Arrays ; class GF@@ G { static int max@@ Cost@@ ToRemove ( int arr [ ] , int N , int K ) { int max@@ Cost = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < N ; i += K ) { max@@ Cost += arr [ i + 1 ] ; } return max@@ Cost ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 4 , 1 , 5 , 1 , 5 , 3 } ; int N = arr . length ; int K = 4 ; System . out . print ( max@@ Cost@@ ToRemove ( arr , N , K ) ) ; } }
import java . io . * ; class GF@@ G { static boolean check@@ If@@ Possible@@ Merge ( int [ ] A , int [ ] B , int N ) { int i = 0 ; int j = 0 ; int prev = - 1 ; boolean flag = true ; while ( i < N && j < N ) { if ( A [ i ] < B [ j ] && prev != 0 ) { prev = 0 ; i ++ ; } else if ( B [ j ] < A [ i ] && prev != 1 ) { prev = 1 ; j ++ ; } else if ( A [ i ] == B [ j ] ) { if ( prev != 1 ) { prev = 1 ; j ++ ; } else { prev = 0 ; i ++ ; } } else { flag = false ; break ; } } return flag ; } public static void main ( String [ ] args ) { int [ ] A = { 3 , 5 , 8 } ; int [ ] B = { 2 , 4 , 6 } ; int N = A . length ; if ( check@@ If@@ Possible@@ Merge ( A , B , N ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
import java . util . * ; class GF@@ G { static int max@@ Sum ( int n , int a [ ] , int [ ] [ ] l , int q ) { Vector < Integer > v = new Vector < > ( ) ; int [ ] d = new int [ n ] ; for ( int i = 0 ; i < q ; i ++ ) { for ( int x = l [ i ] [ 0 ] ; x <= l [ i ] [ 1 ] ; x ++ ) { if ( d [ x ] == 0 ) { d [ x ] = 1 ; } } } HashSet < Integer > st = new HashSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( d [ i ] == 0 ) { v . add ( a [ i ] ) ; st . add ( i ) ; } } Collections . sort ( v ) ; Collections . reverse ( v ) ; int c = 0 ; for ( int it : st ) { a [ it ] = v . get ( c ) ; c ++ ; } int pref_@@ sum = 0 ; int temp_@@ sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { temp_@@ sum += a [ i ] ; pref_@@ sum += temp_@@ sum ; } return pref_@@ sum ; } public static void main ( String [ ] args ) { int [ ] arr = { - 8 , 4 , - 2 , - 6 , 4 , 7 , 1 } ; int N = arr . length ; int [ ] [ ] q = { { 0 , 0 } , { 4 , 5 } } ; int queries = q . length ; System . out . print ( max@@ Sum ( N , arr , q , queries ) ) ; } }
import java . lang . Math ; import java . util . Arrays ; import java . util . Collections ; class GF@@ G { static int Max@@ Re@@ arr@@ n@@ ge@@ Sum ( Integer A [ ] , Integer B [ ] , int N ) { Arrays . sort ( A ) ; Arrays . sort ( B , Collections . reverse@@ Order ( ) ) ; int max@@ Sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { max@@ Sum += Math . abs ( A [ i ] - B [ i ] ) ; } return max@@ Sum ; } public static void main ( String [ ] args ) { Integer A [ ] = { 1 , 2 , 2 , 4 , 5 } ; Integer B [ ] = { 5 , 5 , 5 , 6 , 6 } ; int N = A . length ; System . out . println ( Max@@ Re@@ arr@@ n@@ ge@@ Sum ( A , B , N ) ) ; } }
import java . util . * ; class GF@@ G { static void min@@ Heap@@ ify ( int br@@ r [ ] , int i , int M ) { int left = 2 * i + 1 ; int right = 2 * i + 2 ; int smallest = i ; if ( left < M && br@@ r [ left ] < br@@ r [ smallest ] ) { smallest = left ; } if ( right < M && br@@ r [ right ] < br@@ r [ smallest ] ) { smallest = right ; } if ( smallest != i ) { int temp = br@@ r [ i ] ; br@@ r [ i ] = br@@ r [ smallest ] ; br@@ r [ smallest ] = temp ; min@@ Heap@@ ify ( br@@ r , smallest , M ) ; } } static void merge ( int arr [ ] , int br@@ r [ ] , int N , int M ) { for ( int i = 0 ; i < N ; ++ i ) { if ( arr [ i ] > br@@ r [ 0 ] ) { int temp = arr [ i ] ; arr [ i ] = br@@ r [ 0 ] ; br@@ r [ 0 ] = temp ; min@@ Heap@@ ify ( br@@ r , 0 , M ) ; } } Arrays . sort ( br@@ r ) ; } static void print@@ Array ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 23 , 35 , 235 , 233@@ 5 } ; int br@@ r [ ] = { 3 , 5 } ; int N = arr . length ; int M = br@@ r . length ; merge ( arr , br@@ r , N , M ) ; print@@ Array ( arr , N ) ; print@@ Array ( br@@ r , M ) ; } }
import java . io . * ; import java . util . * ; class GF@@ G { static void max@@ Area ( int [ ] point_@@ x , int [ ] point_@@ y , int n , int length , int width ) { Arrays . sort ( point_@@ x ) ; Arrays . sort ( point_@@ y ) ; int dx = point_@@ x [ 0 ] ; int dy = point_@@ y [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { dx = Math . max ( dx , point_@@ x [ i ] - point_@@ x [ i - 1 ] ) ; dy = Math . max ( dy , point_@@ y [ i ] - point_@@ y [ i - 1 ] ) ; } dx = Math . max ( dx , ( length + 1 ) - point_@@ x [ n - 1 ] ) ; dy = Math . max ( dy , ( width + 1 ) - point_@@ y [ n - 1 ] ) ; System . out . println ( ( dx - 1 ) * ( dy - 1 ) ) ; } public static void main ( String [ ] args ) { int length = 15 , width = 8 ; int n = 3 ; int point_@@ x [ ] = { 3 , 11 , 8 } ; int point_@@ y [ ] = { 8 , 2 , 6 } ; max@@ Area ( point_@@ x , point_@@ y , n , length , width ) ; } }
import java . util . * ; class GF@@ G { static int find@@ Max@@ Value ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int ans = arr [ n - 1 ] ; int max@@ Possible = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; -- i ) { if ( max@@ Possible > 0 ) { if ( arr [ i ] >= max@@ Possible ) { ans += ( max@@ Possible - 1 ) ; max@@ Possible = max@@ Possible - 1 ; } else { max@@ Possible = arr [ i ] ; ans += max@@ Possible ; } } } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 4 , 1 , 5 } ; int n = arr . length ; System . out . print ( find@@ Max@@ Value ( arr , n ) ) ; } }
import java . util . * ; class GF@@ G { static void lex@@ Numbers ( int n ) { Vector < String > s = new Vector < String > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { s . add ( String . valueOf ( i ) ) ; } Collections . sort ( s ) ; Vector < Integer > ans = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) ans . add ( Integer . valueOf ( s . get ( i ) ) ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( ans . get ( i ) + " ▁ " ) ; } public static void main ( String [ ] args ) { int n = 15 ; lex@@ Numbers ( n ) ; } }
import java . util . * ; class GF@@ G { static void sorted@@ Adjac@@ ent@@ Differen@@ ces ( int arr [ ] , int n ) { int [ ] ans = new int [ n ] ; Arrays . sort ( arr ) ; int l = 0 , r = n - 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( i % 2 == 1 ) { ans [ i ] = arr [ l ] ; l ++ ; } else { ans [ i ] = arr [ r ] ; r -- ; } } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( ans [ i ] + " ▁ " ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 5 , - 2 , 4 , 8 , 6 , 4 , 5 } ; int n = arr . length ; sorted@@ Adjac@@ ent@@ Differen@@ ces ( arr , n ) ; } }
import java . util . * ; class GF@@ G { static boolean check@@ Is@@ AP ( double arr [ ] , int n ) { if ( n == 1 ) return true ; Arrays . sort ( arr ) ; double d = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] != d ) { return false ; } } return true ; } static boolean check@@ Is@@ GP ( double arr [ ] , int n ) { if ( n == 1 ) return true ; Arrays . sort ( arr ) ; double r = arr [ 1 ] / arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i ] / arr [ i - 1 ] != r ) return false ; } return true ; } static boolean check@@ Is@@ HP ( double arr [ ] , int n ) { if ( n == 1 ) { return true ; } double [ ] rec = new double [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { rec [ i ] = ( ( 1 / arr [ i ] ) ) ; } if ( check@@ Is@@ AP ( rec , n ) ) return true ; else return false ; } public static void main ( String [ ] args ) { double arr [ ] = { 1.0 / 5.0 , 1.0 / 10.0 , 1.0 / 15.0 , 1.0 / 20.0 } ; int n = arr . length ; int flag = 0 ; if ( check@@ Is@@ AP ( arr , n ) ) { System . out . print ( " Yes , ▁ An ▁ AP ▁ can ▁ be ▁ formed " + "@@ NEW_@@ LINE@@ "@@ )@@ ; flag = 1 ; } if ( check@@ Is@@ GP ( arr , n ) ) { System . out . print ( " Yes , ▁ A ▁ GP ▁ can ▁ be ▁ formed " + "@@ NEW_@@ LINE@@ "@@ )@@ ; flag = 1 ; } if ( check@@ Is@@ HP ( arr , n ) ) { System . out . print ( " Yes , ▁ A ▁ HP ▁ can ▁ be ▁ formed " + "@@ NEW_@@ LINE@@ "@@ )@@ ; flag = 1 ; } else if ( flag == 0 ) { System . out . print ( " No " ) ; } } }
import java . util . * ; class GF@@ G { static int sort@@ By@@ Freq ( Integer [ ] arr , int n ) { int max@@ E = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { max@@ E = Math . max ( max@@ E , arr [ i ] ) ; } int freq [ ] = new int [ max@@ E + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; } int cnt = 0 ; for ( int i = 0 ; i <= max@@ E ; i ++ ) { if ( freq [ i ] > 0 ) { int value = 100000 - i ; arr [ cnt ] = 100000 * freq [ i ] + value ; cnt ++ ; } } return cnt ; } static void print@@ Sorted@@ Array ( Integer [ ] arr , int cnt ) { for ( int i = 0 ; i < cnt ; i ++ ) { int frequency = arr [ i ] / 100000 ; int value = 100000 - ( arr [ i ] % 100000 ) ; for ( int j = 0 ; j < frequency ; j ++ ) { System . out . print ( value + " ▁ " ) ; } } } public static void main ( String [ ] args ) { Integer arr [ ] = { 4 , 4 , 5 , 6 , 4 , 2 , 2 , 8 , 5 } ; int n = arr . length ; int cnt = sort@@ By@@ Freq ( arr , n ) ; Arrays . sort ( arr , Collections . reverse@@ Order ( ) ) ; print@@ Sorted@@ Array ( arr , cnt ) ; } }
class GF@@ G { static int max_@@ element ( int arr [ ] , int n ) { int max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( max < arr [ i ] ) max = arr [ i ] ; } return max ; } static int max@@ Mod ( int arr [ ] , int n ) { int maxVal = max_@@ element ( arr , n ) ; int second@@ Max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < maxVal && arr [ i ] > second@@ Max ) { second@@ Max = arr [ i ] ; } } return second@@ Max ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 1 , 5 , 3 , 6 } ; int n = arr . length ; System . out . println ( max@@ Mod ( arr , n ) ) ; } }
import java . util . * ; class GF@@ G { static boolean is@@ Possible ( int A [ ] , int B [ ] , int n , int m , int x , int y ) { if ( x > n y > m ) return false ; Arrays . sort ( A ) ; Arrays . sort ( B ) ; if ( A [ x - 1 ] < B [ m - y ] ) return true ; else return false ; } public static void main ( String [ ] args ) { int A [ ] = { 1 , 1 , 1 , 1 , 1 } ; int B [ ] = { 2 , 2 } ; int n = A . length ; int m = B . length ; ; int x = 3 , y = 1 ; if ( is@@ Possible ( A , B , n , m , x , y ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GF@@ G { static int getNumber ( int n , int k ) { int [ ] arr = new int [ n ] ; int i = 0 ; int odd = 1 ; while ( odd <= n ) { arr [ i ++ ] = odd ; odd += 2 ; } int even = 2 ; while ( even <= n ) { arr [ i ++ ] = even ; even += 2 ; } return arr [ k - 1 ] ; } public static void main ( String [ ] args ) { int n = 8 , k = 5 ; System . out . println ( getNumber ( n , k ) ) ; } }
import java . util . * ; class GF@@ G { static int MAX = 10000@@ 5 ; static int M@@ in_@@ Replace ( int [ ] arr , int n , int k ) { Arrays . sort ( arr ) ; Integer [ ] freq = new Integer [ MAX ] ; Arrays . fill ( freq , 0 ) ; int p = 0 ; freq [ p ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) ++ freq [ p ] ; else ++ freq [ ++ p ] ; } Arrays . sort ( freq , Collections . reverse@@ Order ( ) ) ; int ans = 0 ; for ( int i = k ; i <= p ; i ++ ) ans += freq [ i ] ; return ans ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 7 , 8 , 2 , 3 , 2 , 3 } ; int n = arr . length ; int k = 2 ; System . out . println ( M@@ in_@@ Replace ( arr , n , k ) ) ; } }
import java . util . * ; class GF@@ G { static int Segment ( int x [ ] , int l [ ] , int n ) { if ( n == 1 ) return 1 ; int ans = 2 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( x [ i ] - l [ i ] > x [ i - 1 ] ) ans ++ ; else if ( x [ i ] + l [ i ] < x [ i + 1 ] ) { x [ i ] = x [ i ] + l [ i ] ; ans ++ ; } } return ans ; } public static void main ( String [ ] args ) { int x [ ] = { 1 , 3 , 4 , 5 , 8 } , l [ ] = { 10 , 1 , 2 , 2 , 5 } ; int n = x . length ; System . out . println ( Segment ( x , l , n ) ) ; } }
import java . util . Arrays ; class GF@@ G { static void print@@ Arrange@@ ment ( int a [ ] , int n ) { Arrays . sort ( a ) ; int b [ ] = new int [ n ] ; int low = 0 , high = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) b [ low ++ ] = a [ i ] ; else b [ high -- ] = a [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 ) { if ( b [ n - 1 ] + b [ 1 ] <= b [ i ] ) { System . out . print ( - 1 ) ; return ; } } else if ( i == ( n - 1 ) ) { if ( b [ n - 2 ] + b [ 0 ] <= b [ i ] ) { System . out . print ( - 1 ) ; return ; } } else { if ( b [ i - 1 ] + b [ i + 1 ] <= b [ i ] ) { System . out . print ( - 1 ) ; return ; } } } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( b [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 4 , 4 , 3 , 2 } ; int n = a . length ; print@@ Arrange@@ ment ( a , n ) ; } }
import java . io . * ; class GF@@ G { static int N = 2 ; static int M = 2 ; static boolean is@@ Matrix@@ Inc ( int a [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( i - 1 >= 0 ) { if ( a [ i ] [ j ] <= a [ i - 1 ] [ j ] ) return false ; } if ( j - 1 >= 0 ) { if ( a [ i ] [ j ] <= a [ i ] [ j - 1 ] ) return false ; } } } return true ; } public static void main ( String [ ] args ) { int a [ ] [ ] = { { 2 , 10 } , { 11 , 20 } } ; if ( is@@ Matrix@@ Inc ( a ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
import java . util . * ; class GF@@ G { static int N = 1000000@@ 5 ; static int [ ] prime = new int [ N ] ; static void se@@ ive ( ) { for ( int i = 2 ; i < N ; i ++ ) { if ( prime [ i ] == 0 ) { for ( int j = i + i ; j < N ; j += i ) { prime [ j ] = 1 ; } } } prime [ 1 ] = 1 ; } static int max@@ Size@@ Arr ( int arr [ ] , int n , int k ) { ArrayList < Integer > v = new ArrayList < Integer > ( ) ; ArrayList < Integer > diff = new ArrayList < Integer > ( ) ; int num = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] == 1 ) { v . add ( i ) ; } } num = 0 ; for ( int i = 1 ; i < v . size ( ) ; i ++ ) { diff . add ( v . get ( i ) - v . get ( i - 1 ) - 1 ) ; } Collections . sort ( diff ) ; for ( int i = 1 ; i < diff . size ( ) ; i ++ ) { diff . set ( i , diff . get ( i ) + diff . get ( i - 1 ) ) ; } if ( k > n || ( k == 0 && v . size ( ) > 0 ) ) { return - 1 ; } else if ( v . size ( ) <= k ) { return ( n - k ) ; } else if ( v . size ( ) > k ) { int tt = v . size ( ) - k ; int sum = 0 ; sum += diff . get ( tt - 1 ) ; int res = n - ( v . size ( ) + sum ) ; return res ; } return 1 ; } public static void main ( String [ ] args ) { se@@ ive ( ) ; int [ ] arr = { 2 , 4 , 2 , 2 , 4 , 2 , 4 , 2 } ; int n = arr . length ; int k = 2 ; System . out . println ( max@@ Size@@ Arr ( arr , n , k ) ) ; } }
import java . util . * ; class GF@@ G { static class Node { int data ; Node next ; } ; static Node start ; static void sort@@ List ( Node head ) { int start@@ Val = 1 ; while ( head != null ) { head . data = start@@ Val ; start@@ Val ++ ; head = head . next ; } } static void push ( Node head_@@ ref , int new_data ) { Node new_node = new Node ( ) ; new_node . data = new_data ; new_node . next = head_@@ ref ; head_@@ ref = new_node ; start = head_@@ ref ; } static void print@@ List ( Node node ) { while ( node != null ) { System . out . print ( node . data + " ▁ " ) ; node = node . next ; } } public static void main ( String [ ] args ) { start = null ; push ( start , 2 ) ; push ( start , 1 ) ; push ( start , 6 ) ; push ( start , 4 ) ; push ( start , 5 ) ; push ( start , 3 ) ; sort@@ List ( start ) ; print@@ List ( start ) ; } }
import java . util . * ; class GF@@ G { public static int count@@ Trip@@ let@@ s@@ LessThan ( int [ ] arr , int n , int val ) { Arrays . sort ( arr ) ; int ans = 0 ; int j , k ; int sum ; for ( int i = 0 ; i < n - 2 ; i ++ ) { j = i + 1 ; k = n - 1 ; while ( j != k ) { sum = arr [ i ] + arr [ j ] + arr [ k ] ; if ( sum > val ) k -- ; else { ans += ( k - j ) ; j ++ ; } } } return ans ; } public static int count@@ Trip@@ lets ( int arr [ ] , int n , int a , int b ) { int res ; res = count@@ Trip@@ let@@ s@@ LessThan ( arr , n , b ) - count@@ Trip@@ let@@ s@@ LessThan ( arr , n , a - 1 ) ; return res ; } public static void main ( String [ ] args ) { int [ ] arr = { 2 , 7 , 5 , 3 , 8 , 4 , 1 , 9 } ; int n = arr . length ; int a = 8 , b = 16 ; System . out . println ( " " + count@@ Trip@@ lets ( arr , n , a , b ) ) ; } }
import java . io . * ; import java . util . Arrays ; class GF@@ G { static int max@@ Level ( int [ ] boxes , int n ) { Arrays . sort ( boxes ) ; int prev_@@ width = boxes [ 0 ] ; int prev_@@ count = 1 ; int curr_@@ count = 0 ; int curr_@@ width = 0 ; for ( int i = 1 ; i < n ; i ++ ) { curr_@@ width += boxes [ i ] ; curr_@@ count += 1 ; if ( curr_@@ width > prev_@@ width && curr_@@ count > prev_@@ count ) { prev_@@ width = curr_@@ width ; prev_@@ count = curr_@@ count ; curr_@@ count = 0 ; curr_@@ width = 0 ; ans ++ ; } } return ans ; } static public void main ( String [ ] args ) { int [ ] boxes = { 10 , 20 , 30 , 50 , 60 , 70 } ; int n = boxes . length ; System . out . println ( max@@ Level ( boxes , n ) ) ; } }
import java . io . * ; class GF@@ G { static int merge ( int arr [ ] , int temp [ ] , int left , int mid , int right ) { int inv_@@ count = 0 ; int i = left ; int j = mid ; int k = left ; while ( ( i <= mid - 1 ) && ( j <= right ) ) { if ( arr [ i ] <= arr [ j ] ) temp [ k ++ ] = arr [ i ++ ] ; else { temp [ k ++ ] = arr [ j ++ ] ; inv_@@ count = inv_@@ count + ( mid - i ) ; } } while ( i <= mid - 1 ) temp [ k ++ ] = arr [ i ++ ] ; while ( j <= right ) temp [ k ++ ] = arr [ j ++ ] ; for ( i = left ; i <= right ; i ++ ) arr [ i ] = temp [ i ] ; return inv_@@ count ; } static int _@@ merge@@ Sort ( int arr [ ] , int temp [ ] , int left , int right ) { int mid , inv_@@ count = 0 ; if ( right > left ) { mid = ( right + left ) / 2 ; inv_@@ count = _@@ merge@@ Sort ( arr , temp , left , mid ) ; inv_@@ count += _@@ merge@@ Sort ( arr , temp , mid + 1 , right ) ; inv_@@ count += merge ( arr , temp , left , mid + 1 , right ) ; } return inv_@@ count ; } static int count@@ Sw@@ aps ( int arr [ ] , int n ) { int temp [ ] = new int [ n ] ; return _@@ merge@@ Sort ( arr , temp , 0 , n - 1 ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 20 , 6 , 4 , 5 } ; int n = arr . length ; System . out . println ( " Number ▁ of ▁ sw@@ aps ▁ is ▁ " + count@@ Sw@@ aps ( arr , n ) ) ; } }
class GF@@ G { static int minimum@@ Size@@ Array ( int S , int P ) { if ( S == P ) { return 1 ; } for ( int i = 2 ; i <= S ; i ++ ) { double d = i ; if ( ( S / d ) >= Math . pow ( P , 1.0 / d ) ) { return i ; } } return - 1 ; } public static void main ( String args [ ] ) { int S = 5 , P = 6 ; System . out . println ( minimum@@ Size@@ Array ( S , P ) ) ; } }
import java . util . * ; class GF@@ G { static int max@@ Sub@@ seq ( int arr [ ] , int N , int K ) { int sum = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( K == 0 ) break ; if ( arr [ i ] < 0 ) { arr [ i ] = - arr [ i ] ; K -- ; } } for ( int i = 0 ; i < N ; i ++ ) if ( arr [ i ] > 0 ) sum += arr [ i ] ; return sum ; } public static void main ( String [ ] args ) { int [ ] arr = { 6 , - 10 , - 1 , 0 , - 4 , 2 } ; int K = 2 ; int N = arr . length ; System . out . println ( max@@ Sub@@ seq ( arr , N , K ) ) ; } }
import java . io . * ; class GF@@ G { static void print@@ The@@ Array ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } static void re@@ arrange ( int arr [ ] , int N ) { if ( ( N & 1 ) != 0 ) N -- ; int od@@ d_@@ idx = 1 , ev@@ en_@@ idx = 0 ; int i , max_@@ elem = arr [ N - 1 ] + 1 ; for ( i = 0 ; i < N / 2 ; i ++ ) { arr [ i ] += ( arr [ od@@ d_@@ idx ] % max_@@ elem ) * max_@@ elem ; od@@ d_@@ idx += 2 ; } for ( ; i < N ; i ++ ) { arr [ i ] += ( arr [ ev@@ en_@@ idx ] % max_@@ elem ) * max_@@ elem ; ev@@ en_@@ idx += 2 ; } for ( i = 0 ; i < N ; i ++ ) { arr [ i ] = arr [ i ] / max_@@ elem ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 16 , 18 , 19 } ; int N = arr . length ; re@@ arrange ( arr , N ) ; print@@ The@@ Array ( arr , N ) ; } }
import java . util . * ; class GF@@ G { static boolean check ( int num ) { int sm = 0 ; int num2 = num * num ; while ( num > 0 ) { sm += num % 10 ; num /= 10 ; } int sm@@ 2 = 0 ; while ( num2 > 0 ) { sm@@ 2 += num2 % 10 ; num2 /= 10 ; } return ( ( sm * sm ) == sm@@ 2 ) ; } static int convert ( String s ) { int val = 0 ; s = reverse ( s ) ; int cur = 1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { val += ( s . charAt ( i ) - '0' ) * cur ; cur *= 10 ; } return val ; } static void generate ( String s , int len , HashSet < Integer > uniq ) { if ( s . length ( ) == len ) { if ( check ( convert ( s ) ) ) { uniq . add ( convert ( s ) ) ; } return ; } for ( int i = 0 ; i <= 3 ; i ++ ) { generate ( s + ( char ) ( i + '0' ) , len , uniq ) ; } } static String reverse ( String input ) { char [ ] a = input . toCharArray ( ) ; int l , r = a . length - 1 ; for ( l = 0 ; l < r ; l ++ , r -- ) { char temp = a [ l ] ; a [ l ] = a [ r ] ; a [ r ] = temp ; } return String . valueOf ( a ) ; } static int total@@ Numbers ( int L , int R ) { int ans = 0 ; int max_len = ( int ) ( Math . log10 ( R ) + 1 ) ; HashSet < Integer > uniq = new HashSet < Integer > ( ) ; for ( int i = 1 ; i <= max_len ; i ++ ) { generate ( " " , i , uniq ) ; } for ( int x : uniq ) { if ( x >= L && x <= R ) { ans ++ ; } } return ans ; } public static void main ( String [ ] args ) { int L = 22 , R = 22 ; System . out . print ( total@@ Numbers ( L , R ) ) ; } }
import java . util . * ; class GF@@ G { static int count@@ Arrays ( int n , int k ) { Vector < Integer > [ ] di@@ visors = new Vector [ k + 1 ] ; for ( int i = 0 ; i < di@@ visors . length ; i ++ ) di@@ visors [ i ] = new Vector < Integer > ( ) ; for ( int i = 1 ; i <= k ; i ++ ) { for ( int j = 2 * i ; j <= k ; j += i ) { di@@ visors [ j ] . add ( i ) ; } } int [ ] [ ] dp = new int [ n + 1 ] [ k + 1 ] ; for ( int j = 1 ; j <= k ; j ++ ) { dp [ 1 ] [ j ] = 1 ; } for ( int x = 2 ; x <= n ; x ++ ) { int sum = 0 ; for ( int j = 1 ; j <= k ; j ++ ) { sum += dp [ x - 1 ] [ j ] ; } for ( int y = 1 ; y <= k ; y ++ ) { dp [ x ] [ y ] = sum ; for ( int d : di@@ visors [ y ] ) { dp [ x ] [ y ] = ( dp [ x ] [ y ] - dp [ x - 1 ] [ d ] ) ; } } } int sum = 0 ; for ( int j = 1 ; j <= k ; j ++ ) { sum += dp [ n ] [ j ] ; } return sum ; } public static void main ( String [ ] args ) { int N = 2 , K = 3 ; System . out . print ( count@@ Arrays ( N , K ) ) ; } }
class GF@@ G { public static int find@@ Maximum@@ Points ( int N , int X [ ] , int H [ ] ) { int ans = 0 ; int prev = Integer . MIN_VALUE ; for ( int i = 0 ; i < N ; ++ i ) { if ( prev < ( X [ i ] - H [ i ] ) ) { ++ ans ; prev = X [ i ] ; } else if ( i == N - 1 || ( X [ i ] + H [ i ] ) < X [ i + 1 ] ) { ++ ans ; prev = X [ i ] + H [ i ] ; } else { prev = X [ i ] ; } } return ans ; } public static void main ( String args [ ] ) { int X [ ] = { 1 , 2 , 3 } ; int H [ ] = { 2 , 5 , 5 } ; int N = X . length ; System . out . println ( find@@ Maximum@@ Points ( N , X , H ) ) ; } }
import java . util . * ; public class MyClass { static void possible@@ Numbers ( Set < Integer > numbers , int N , int M , int A , int B ) { if ( M == 0 ) { numbers . add ( N ) ; return ; } possible@@ Numbers ( numbers , N + A , M - 1 , A , B ) ; possible@@ Numbers ( numbers , N + B , M - 1 , A , B ) ; } public static void main ( String args [ ] ) { int N = 5 , M = 3 , A = 4 , B = 6 ; Set < Integer > numbers = new HashSet < Integer > ( ) ; possible@@ Numbers ( numbers , N , M , A , B ) ; Iterator < Integer > i = numbers . iterator ( ) ; while ( i . hasNext ( ) ) System . out . print ( i . next ( ) + " ▁ " ) ; } }
import java . io . * ; class GF@@ G { static int reduce@@ To@@ One ( long N ) { int cnt = 0 ; while ( N != 1 ) { if ( N == 2 || ( N % 2 == 1 ) ) { N = N - 1 ; cnt ++ ; } else if ( N % 2 == 0 ) { N = N / ( N / 2 ) ; cnt ++ ; } } return cnt ; } public static void main ( String [ ] args ) { long N = 35 ; System . out . println ( reduce@@ To@@ One ( N ) ) ; } }
import java . util . Vector ; class GF@@ G { static void solve ( int S , int K , int N ) { if ( K > N ) { System . out . println ( " - 1" ) ; return ; } int max_@@ sum = 0 , min_@@ sum = 0 ; for ( int i = 1 ; i <= K ; i ++ ) { min_@@ sum += i ; max_@@ sum += N - i + 1 ; } if ( S < min_@@ sum S > max_@@ sum ) { System . out . println ( " - 1" ) ; return ; } int s1 = 0 ; Vector < Integer > nums = new Vector < > ( ) ; for ( int i = 1 ; i <= N ; i ++ ) { if ( s1 > S ) break ; s1 += i ; nums . add ( i ) ; } Vector < Integer > answer = new Vector < > ( ) ; int s2 = 0 ; for ( int i = 0 ; i < K - 1 ; i ++ ) { answer . add ( nums . get ( i ) ) ; s2 += nums . get ( i ) ; } answer . add ( S - s2 ) ; int Max = N ; for ( int i = answer . size ( ) - 1 ; i >= 0 ; i -- ) { if ( answer . get ( i ) > Max ) { int extra = answer . get ( i ) - Max ; if ( i - 1 >= 0 ) answer . set ( i - 1 , answer . get ( i - 1 ) + extra ) ; answer . set ( i , Max ) ; Max -- ; } else break ; } for ( int x : answer ) System . out . print ( x + " ▁ " ) ; System . out . println ( ) ; } public static void main ( String [ ] args ) { int S = 15 , K = 4 , N = 8 ; solve ( S , K , N ) ; } }
import java . io . * ; import java . util . * ; class GF@@ G { static void min@@ Size@@ Arr ( int A [ ] , int N , int K ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += A [ i ] ; if ( K > sum ) { System . out . print ( - 1 ) ; return ; } if ( K == sum ) { for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( A [ i ] + " ▁ " ) ; } return ; } int tar = sum - K ; HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ; um . put ( 0 , - 1 ) ; int left = 0 , right = 0 ; int cur = 0 , max@@ i = - 1 ; for ( int i = 0 ; i < N ; i ++ ) { cur += A [ i ] ; if ( um . containsKey ( cur - tar ) && i - um . get ( cur - tar ) > max@@ i ) { max@@ i = i - um . get ( cur - tar ) ; right = i ; left = um . get ( cur - tar ) ; } if ( ! um . containsKey ( cur ) ) um . put ( cur , i ) ; } if ( max@@ i == - 1 ) System . out . println ( - 1 ) ; else { for ( int i = 0 ; i <= left ; i ++ ) System . out . print ( A [ i ] + " ▁ " ) ; for ( int i = 0 ; i < right ; i ++ ) System . out . print ( A [ N - i - 1 ] + " ▁ " ) ; } } public static void main ( String [ ] args ) { int N = 7 ; int A [ ] = { 3 , 2 , 1 , 1 , 1 , 1 , 3 } ; int K = 10 ; min@@ Size@@ Arr ( A , N , K ) ; } }
import java . util . * ; class GF@@ G { static void find@@ Equation ( int A , int B , int C , int K ) { System . out . print ( A + " ▁ " + K * B + " ▁ " + K * K * C ) ; } public static void main ( String [ ] args ) { int A = 1 , B = 2 , C = 1 , K = 2 ; find@@ Equation ( A , B , C , K ) ; } }
import java . io . * ; class GF@@ G { static void can@@ Array@@ Be@@ Redu@@ ced ( int [ ] arr , int N ) { if ( N == 1 ) { System . out . print ( arr [ 0 ] ) ; return ; } if ( arr [ 0 ] < arr [ N - 1 ] ) { System . out . print ( arr [ N - 1 ] ) ; } else System . out . print ( " Not ▁ Possible " ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 6 , 5 , 2 , 4 , 1 , 3 , 7 } ; int N = arr . length ; can@@ Array@@ Be@@ Redu@@ ced ( arr , N ) ; } }
import java . util . * ; class GF@@ G { static void construct@@ Array ( int arr [ ] , int N ) { int br@@ r [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { int K = ( int ) ( Math . log ( arr [ i ] ) / Math . log ( 2 ) ) ; int R = ( int ) Math . pow ( 2 , K ) ; br@@ r [ i ] = R ; } for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( br@@ r [ i ] + " ▁ " ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 11 , 5 , 7 , 3 , 2 } ; int N = arr . length ; construct@@ Array ( arr , N ) ; } }
import java . io . * ; import java . util . * ; class GF@@ G { static void min@@ Op@@ sTo@@ Turn@@ Arr@@ To@@ Zero ( int [ ] arr , int N ) { Set < Integer > st = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( st . contains ( arr [ i ] ) arr [ i ] == 0 ) { continue ; } else { st . add ( arr [ i ] ) ; } } System . out . println ( st . size ( ) ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 3 , 7 , 3 } ; int N = arr . length ; min@@ Op@@ sTo@@ Turn@@ Arr@@ To@@ Zero ( arr , N ) ; } }
import java . io . * ; import java . util . * ; class GF@@ G { static boolean Check@@ All@@ Equal ( int arr [ ] , int N ) { for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ 0 ] != arr [ i ] ) { return false ; } } return true ; } static int min@@ Cnt@@ Operations ( int arr [ ] , int N ) { int Max = Arrays . stream ( arr ) . max ( ) . getAs@@ Int ( ) ; boolean is@@ Power@@ 2 ; if ( ( int ) ( Math . ceil ( ( Math . log ( N ) / Math . log ( N ) ) ) ) == ( int ) ( Math . floor ( ( ( Math . log ( N ) / Math . log ( 2 ) ) ) ) ) ) { is@@ Power@@ 2 = true ; } else { is@@ Power@@ 2 = false ; } if ( is@@ Power@@ 2 && Check@@ All@@ Equal ( arr , N ) ) { return ( int ) ( Math . log ( Max ) / Math . log ( 2 ) ) ; } else { return ( int ) Math . ceil ( Math . log ( Max ) / Math . log ( 2 ) ) + 1 ; } } public static void main ( String [ ] args ) { int [ ] arr = new int [ ] { 2 , 4 } ; int N = arr . length ; System . out . println ( min@@ Cnt@@ Operations ( arr , N ) ) ; } }
import java . util . * ; class GF@@ G { static int find@@ Max@@ Val@@ By@@ Re@@ arr@@ Arr ( int arr [ ] , int N ) { Arrays . sort ( arr ) ; int res = 0 ; do { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += __@@ gcd ( i + 1 , arr [ i ] ) ; } res = Math . max ( res , sum ) ; } while ( next_@@ permutation ( arr ) ) ; return res ; } static int __@@ gcd ( int a , int b ) { return b == 0 ? a : __@@ gcd ( b , a % b ) ; } static boolean next_@@ permutation ( int [ ] p ) { for ( int a = p . length - 2 ; a >= 0 ; -- a ) if ( p [ a ] < p [ a + 1 ] ) for ( int b = p . length - 1 ; ; -- b ) if ( p [ b ] > p [ a ] ) { int t = p [ a ] ; p [ a ] = p [ b ] ; p [ b ] = t ; for ( ++ a , b = p . length - 1 ; a < b ; ++ a , -- b ) { t = p [ a ] ; p [ a ] = p [ b ] ; p [ b ] = t ; } return true ; } return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 2 , 1 } ; int N = arr . length ; System . out . print ( find@@ Max@@ Val@@ By@@ Re@@ arr@@ Arr ( arr , N ) ) ; } }
import java . util . * ; class GF@@ G { static int sum@@ zero ( int arr [ ] , int N , int K ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } if ( sum == 0 ) System . out . print ( " Yes " ) ; else if ( sum > 0 ) { if ( sum % K == 0 ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } else System . out . print ( " No " ) ; return 0 ; } public static void main ( String [ ] args ) { int K , N ; int ar@@ r1 [ ] = { 1 , - 6 , 2 , 2 } ; K = 1 ; N = ar@@ r1 . length ; sum@@ zero ( ar@@ r1 , N , K ) ; } }
import java . util . * ; class GF@@ G { static void path_to_@@ root ( int node ) { while ( node >= 1 ) { System . out . print ( node + " ▁ " ) ; node /= 2 ; } } public static void main ( String [ ] args ) { int N = 7 ; path_to_@@ root ( N ) ; } }
import java . io . * ; class GF@@ G { static void find@@ S@@ malle@@ st@@ Number@@ Possible ( int N , int K ) { if ( N > 45 * K ) { System . out . print ( " - 1" ) ; return ; } StringBuilder res = new StringBuilder ( ) ; int count = 0 ; for ( int i = 9 ; i >= 1 { if ( count == K ) { i -- ; count = 0 ; } if ( N > i ) { N -= i ; res . append ( ( char ) ( '0' + i ) ) ; } else { res . append ( ( char ) ( '0' + N ) ) ; N = 0 ; break ; } count ++ ; } res . reverse ( ) ; System . out . print ( res . toString ( ) ) ; } public static void main ( String [ ] args ) { int N = 25 , K = 3 ; find@@ S@@ malle@@ st@@ Number@@ Possible ( N , K ) ; } }
import java . util . * ; class GF@@ G { static void result ( int n ) { if ( n > 45 ) { System . out . print ( - 1 ) ; return ; } String res = " " ; int digit = 9 ; while ( n > digit ) { res = ( char ) ( '0' + digit ) + res ; n -= digit ; digit -= 1 ; } if ( n > 0 ) { res = ( char ) ( '0' + n ) + res ; } System . out . print ( res ) ; } public static void main ( String [ ] args ) { int N = 19 ; result ( N ) ; } }
class GF@@ G { static void find@@ Numbers ( int a@@ X@@ OR@@ b , int a@@ AND@@ b , int a@@ X@@ OR@@ c , int a@@ AND@@ c , int b@@ X@@ OR@@ c , int b@@ AND@@ c ) { int a , b , c ; int a@@ SUM@@ b ; int a@@ SUM@@ c ; int b@@ SUM@@ c ; a@@ SUM@@ b = a@@ X@@ OR@@ b + a@@ AND@@ b * 2 ; a@@ SUM@@ c = a@@ X@@ OR@@ c + a@@ AND@@ c * 2 ; b@@ SUM@@ c = b@@ X@@ OR@@ c + b@@ AND@@ c * 2 ; a = ( a@@ SUM@@ b - b@@ SUM@@ c + a@@ SUM@@ c ) / 2 ; b = a@@ SUM@@ b - a ; c = a@@ SUM@@ c - a ; System . out . print ( " a ▁ = ▁ " + a ) ; System . out . print ( " , ▁ b ▁ = ▁ " + b ) ; System . out . print ( " , ▁ c ▁ = ▁ " + c ) ; } public static void main ( String [ ] args ) { int a@@ X@@ OR@@ b = 30 , a@@ AND@@ b = 0 , a@@ X@@ OR@@ c = 20 , a@@ AND@@ c = 10 , b@@ X@@ OR@@ c = 10 , b@@ AND@@ c = 20 ; find@@ Numbers ( a@@ X@@ OR@@ b , a@@ AND@@ b , a@@ X@@ OR@@ c , a@@ AND@@ c , b@@ X@@ OR@@ c , b@@ AND@@ c ) ; } }
import java . util . * ; class GF@@ G { static int find@@ Number ( int N ) { return N & ( N + 1 ) ; } public static void main ( String [ ] args ) { int N = 39 ; System . out . print ( find@@ Number ( N ) ) ; } }
class GF@@ G { static int find@@ Bit@@ wise@@ OR@@ Given@@ X@@ OR@@ AND ( int X , int Y ) { return X + Y ; } public static void main ( String [ ] args ) { int X = 5 , Y = 2 ; System . out . print ( find@@ Bit@@ wise@@ OR@@ Given@@ X@@ OR@@ AND ( X , Y ) ) ; } }
import java . util . * ; class GF@@ G { static void min@@ Operation ( int X [ ] , int Y [ ] , int n ) { int C = 0 ; int count = 0 ; for ( int i = 1 ; i < n ; i = i + 2 ) { if ( X [ i ] != Y [ i ] ) { count ++ ; } else { if ( count != 0 ) C ++ ; count = 0 ; } } if ( count != 0 ) C ++ ; count = 0 ; for ( int i = 0 ; i < n ; i = i + 2 ) { if ( X [ i ] != Y [ i ] ) { count ++ ; } else { if ( count != 0 ) C ++ ; count = 0 ; } } if ( count != 0 ) C ++ ; System . out . print ( C ) ; } public static void main ( String [ ] args ) { int X [ ] = { 1 , 0 , 0 , 0 , 0 , 1 } ; int Y [ ] = { 1 , 1 , 0 , 1 , 1 , 1 } ; int N = X . length ; min@@ Operation ( X , Y , N ) ; } }
class GF@@ G { static void Remo@@ ve_@@ one_@@ element ( int arr [ ] , int n ) { int post_@@ odd = 0 , post_@@ even = 0 ; int curr_@@ odd = 0 , curr_@@ even = 0 ; int res = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( i % 2 != 0 ) post_@@ odd ^= arr [ i ] ; else post_@@ even ^= arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 != 0 ) post_@@ odd ^= arr [ i ] ; else post_@@ even ^= arr [ i ] ; int X = curr_@@ odd ^ post_@@ even ; int Y = curr_@@ even ^ post_@@ odd ; if ( X == Y ) res ++ ; if ( i % 2 != 0 ) curr_@@ odd ^= arr [ i ] ; else curr_@@ even ^= arr [ i ] ; } System . out . println ( res ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 0 , 1 , 0 , 1 } ; int N = arr . length ; Remo@@ ve_@@ one_@@ element ( arr , N ) ; } }
import java . io . * ; class GF@@ G { public void min@@ Cost ( int [ ] arr ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } System . out . print ( Math . min ( even , odd ) ) ; } public static void main ( String [ ] args ) { GF@@ G obj = new GF@@ G ( ) ; int arr [ ] = { 1 , 2 , 3 } ; obj . min@@ Cost ( arr ) ; } }
import java . util . * ; class solution { static int GC@@ D ( int a , int b ) { if ( b == 0 ) return a ; return GC@@ D ( b , a % b ) ; } static int find@@ Partition ( int nums [ ] , int N ) { int [ ] prefix = new int [ N ] ; int [ ] suffix = new int [ N ] ; int i , k ; prefix [ 0 ] = nums [ 0 ] ; for ( i = 1 ; i < N ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] * nums [ i ] ; } suffix [ N - 1 ] = nums [ N - 1 ] ; for ( i = N - 2 ; i >= 0 ; i -- ) { suffix [ i ] = suffix [ i + 1 ] * nums [ i ] ; } for ( k = 0 ; k < N - 1 ; k ++ ) { if ( GC@@ D ( prefix [ k ] , suffix [ k + 1 ] ) == 1 ) { return k ; } } return - 1 ; } public static void main ( String args [ ] ) { int arr [ ] = { 2 , 3 , 4 , 5 } ; int N = arr . length ; System . out . println ( find@@ Partition ( arr , N ) ) ; } }
import java . util . * ; class GF@@ G { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static void pal@@ ind@@ ro@@ me@@ Matrix ( int N , int M , int [ ] [ ] arr ) { int ans = 0 ; for ( int i = 0 ; i < ( N + 1 ) / 2 ; i ++ ) { for ( int j = 0 ; j < ( M + 1 ) / 2 ; j ++ ) { HashSet < pair > s = new HashSet < > ( ) ; s . add ( new pair ( i , j ) ) ; s . add ( new pair ( i , M - j - 1 ) ) ; s . add ( new pair ( N - i - 1 , j ) ) ; s . add ( new pair ( N - i - 1 , M - j - 1 ) ) ; Vector < Integer > values = new Vector < > ( ) ; for ( pair p : s ) { values . add ( arr [ p . first ] [ p . second ] ) ; } int max = Collections . max ( values ) ; for ( int k = 1 ; k < values . size ( ) ; k ++ ) { ans += max - values . get ( k ) ; } } } System . out . print ( ans ) ; } public static void main ( String [ ] args ) { int N = 3 , M = 3 ; int [ ] [ ] arr = { { 1 , 2 , 1 } , { 3 , 4 , 1 } , { 1 , 2 , 1 } } ; pal@@ ind@@ ro@@ me@@ Matrix ( N , M , arr ) ; } }
import java . io . * ; import java . util . * ; class GF@@ G { static ArrayList < Integer > re@@ arrange@@ Array ( ArrayList < Integer > A , ArrayList < Integer > B , int N ) { HashMap < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ; int xor_@@ value = 0 ; for ( int i = 0 ; i < N ; i ++ ) { xor_@@ value ^= A . get ( i ) ; xor_@@ value ^= B . get ( i ) ; m . put ( B . get ( i ) , m . getOr@@ Default ( B . get ( i ) + 1 , 0 ) ) ; } for ( int i = 0 ; i < N ; i ++ ) { B . set ( i , A . get ( i ) ^ xor_@@ value ) ; if ( m . getOr@@ Default ( B . get ( i ) , - 1 ) != - 1 ) { m . put ( B . get ( i ) , m . getOr@@ Default ( B . get ( i ) , 0 ) - 1 ) ; } else return ( new ArrayList < Integer > ( ) ) ; } return B ; } static void re@@ arrange@@ ArrayUtil ( ArrayList < Integer > A , ArrayList < Integer > B , int N ) { ArrayList < Integer > ans = re@@ arrange@@ Array ( A , B , N ) ; if ( ans . size ( ) != 0 ) { for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { System . out . print ( ans . get ( i ) + " ▁ " ) ; } } else { System . out . println ( " - 1" ) ; } } public static void main ( String [ ] args ) { ArrayList < Integer > A = new ArrayList < Integer > ( Arrays . asList ( 13 , 21 , 33 , 49 , 53 ) ) ; ArrayList < Integer > B = new ArrayList < Integer > ( Arrays . asList ( 54 , 50 , 34 , 22 , 14 ) ) ; int N = ( int ) A . size ( ) ; re@@ arrange@@ ArrayUtil ( A , B , N ) ; } }
import java . util . * ; class GF@@ G { static void count@@ Of@@ Sub@@ array ( int arr [ ] , int N ) { Map < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; int answer = 0 ; int sum = 0 ; if ( mp . get ( 1 ) != null ) mp . put ( 1 , mp . get ( 1 ) + 1 ) ; else mp . put ( 1 , 1 ) ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; if ( mp . get ( sum - i ) != null ) answer += mp . get ( sum - i ) ; if ( mp . get ( sum - i ) != null ) mp . put ( sum - i , mp . get ( sum - i ) + 1 ) ; else mp . put ( sum - i , 1 ) ; } System . out . print ( answer ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 0 , 2 , 1 , 2 , - 2 , 2 , 4 } ; int N = arr . length ; count@@ Of@@ Sub@@ array ( arr , N ) ; } }
import java . io . * ; class GF@@ G { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static void count@@ Inverse ( int [ ] arr , int N , int M ) { int XOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int g@@ cd@@ Of@@ Man@@ de@@ lement = gcd ( M , arr [ i ] ) ; if ( g@@ cd@@ Of@@ Man@@ de@@ lement == 1 ) { XOR ^= arr [ i ] ; } } System . out . println ( XOR ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 } ; int M = 4 ; int N = arr . length ; count@@ Inverse ( arr , N , M ) ; } }
class GF@@ G { public static int Total@@ Xor@@ Pair ( int arr [ ] , int N ) { int total@@ XOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { total@@ XOR ^= arr [ i ] ^ arr [ j ] ; } } return total@@ XOR ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int N = arr . length ; System . out . print ( Total@@ Xor@@ Pair ( arr , N ) ) ; } }
import java . util . * ; class GF@@ G { static void possible@@ Ac@@ y@@ clic@@ Graph ( int N ) { System . out . print ( ( int ) Math . pow ( 2 , N - 1 ) ) ; return ; } public static void main ( String [ ] args ) { int N = 4 ; possible@@ Ac@@ y@@ clic@@ Graph ( N ) ; } }
import java . io . * ; class GF@@ G { static boolean is@@ Composite ( int N ) { for ( int i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { return true ; } } return false ; } static int composite@@ Pair ( int arr [ ] , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { int prod = arr [ i ] * arr [ j ] ; if ( is@@ Composite ( prod ) ) { res ++ ; } } } return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 2 , 2 , 8 } ; int N = arr . length ; System . out . println ( composite@@ Pair ( arr , N ) ) ; } }
import java . util . * ; class GF@@ G { static int find_@@ next ( int n , int k ) { int M = n + 1 ; while ( true ) { if ( ( M & ( 1L << k ) ) > 0 ) break ; M ++ ; } return M ; } public static void main ( String [ ] args ) { int N = 15 , K = 2 ; System . out . print ( find_@@ next ( N , K ) ) ; } }
import java . util . * ; class GF@@ G { static int maximum@@ Sub@@ arrays ( int arr [ ] , int N , int target ) { int ans = 0 ; int avail@@ Idx = - 1 ; int cur_@@ sum = 0 ; HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; mp . put ( 0 , 1 ) ; for ( int i = 0 ; i < N ; i ++ ) { cur_@@ sum += arr [ i ] ; if ( mp . containsKey ( cur_@@ sum - target ) && mp . get ( cur_@@ sum - target ) >= avail@@ Idx ) { ans ++ ; avail@@ Idx = i ; } mp . put ( cur_@@ sum , i ) ; } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , - 1 , 4 , 3 , 6 , 4 , 5 , 1 } ; int N = arr . length ; int target = 6 ; System . out . print ( maximum@@ Sub@@ arrays ( arr , N , target ) ) ; } }
import java . util . * ; class GF@@ G { static int getCount ( int N , int M ) { int total_@@ count = 0 ; total_@@ count += ( N / 10 ) ; int x = ( N / 10 ) * 10 ; if ( ( N - x ) >= M ) { total_@@ count = total_@@ count + 1 ; } return total_@@ count ; } public static void main ( String [ ] args ) { int N = 100 , M = 1 ; System . out . print ( getCount ( N , M ) ) ; } }
import java . util . * ; class GF@@ G { static int digit@@ s@@ Of ( int num ) { return Integer . toString ( num ) . length ( ) ; } static int count ( int a , int tn ) { int diff = ( int ) Math . pow ( 10 , digit@@ s@@ Of ( a ) ) ; return ( ( tn - a ) / diff ) + 1 ; } public static void main ( String [ ] args ) { int n = 25 , m = 45@@ 00 ; System . out . println ( count ( n , m ) ) ; } }
import java . util . * ; class GF@@ G { static int min@@ Operations ( int a [ ] , int N ) { int num_@@ of_@@ op@@ s1 , num_@@ of_@@ op@@ s2 , sum ; num_@@ of_@@ op@@ s1 = num_@@ of_@@ op@@ s2 = sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += a [ i ] ; if ( i % 2 == 0 && sum >= 0 ) { num_@@ of_@@ op@@ s1 += ( 1 + Math . abs ( sum ) ) ; sum = - 1 ; } else if ( i % 2 == 1 && sum <= 0 ) { num_@@ of_@@ op@@ s1 += ( 1 + Math . abs ( sum ) ) ; sum = 1 ; } } sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += a [ i ] ; if ( i % 2 == 1 && sum >= 0 ) { num_@@ of_@@ op@@ s2 += ( 1 + Math . abs ( sum ) ) ; sum = - 1 ; } else if ( i % 2 == 0 && sum <= 0 ) { num_@@ of_@@ op@@ s2 += ( 1 + Math . abs ( sum ) ) ; sum = 1 ; } } return Math . min ( num_@@ of_@@ op@@ s1 , num_@@ of_@@ op@@ s2 ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , - 4 , 5 , 0 , 1 } ; int N = arr . length ; System . out . print ( min@@ Operations ( arr , N ) ) ; } }
class GF@@ G { static int count@@ Set@@ Bits ( int L , int R ) { int count = 0 ; for ( int i = L ; i <= R ; i ++ ) { count += Integer . bit@@ Count ( i ) ; } return count ; } public static void main ( String [ ] args ) { int L = 3 , R = 5 ; System . out . print ( " Total ▁ set ▁ bit ▁ count ▁ is ▁ " + count@@ Set@@ Bits ( L , R ) ) ; } }
import java . util . * ; class GF@@ G { static int count@@ Sw@@ aps ( int A [ ] , int n ) { Arrays . sort ( A ) ; int ind = 1 , res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( ind < n && A [ ind ] == A [ i ] ) ind ++ ; if ( ind < n && A [ ind ] > A [ i ] ) { res ++ ; ind ++ ; } if ( ind >= n ) break ; } return res ; } public static void main ( String [ ] args ) { int A [ ] = { 4 , 3 , 3 , 2 , 5 } ; System . out . print ( count@@ Sw@@ aps ( A , 5 ) ) ; } }
import java . io . * ; class GF@@ G { public static int numberOf@@ Pairs ( int n ) { if ( n % 2 == 0 ) return n / 2 - 1 ; else return n / 2 ; } public static void main ( String [ ] args ) { int n = 8 ; System . out . println ( numberOf@@ Pairs ( n ) ) ; } }
import java . util . * ; class GF@@ G { static int N = 100000 ; static int can@@ Take ; static int best ; static int [ ] dp = new int [ N ] ; static boolean [ ] vis = new boolean [ N ] ; static boolean dfs ( Vector < Integer > [ ] g , int [ ] cost , int u , int pre ) { vis [ u ] = true ; dp [ u ] = cost [ u ] ; boolean check = true ; int cur = cost [ u ] ; for ( int x : g [ u ] ) { if ( vis [ x ] && x != pre ) { check = false ; } else if ( ! vis [ x ] ) { check = dfs ( g , cost , x , u ) ? false : true ; cur = Math . max ( cur , cost [ u ] + dp [ x ] ) ; } } dp [ u ] = cur ; if ( ! check ) { can@@ Take += cost [ u ] ; } else { best = Math . max ( best , dp [ u ] ) ; } return check ; } static void Find@@ Max@@ Cost ( Vector < Integer > [ ] g , int [ ] cost , int source ) { dfs ( g , cost , source , - 1 ) ; System . out . print ( can@@ Take + best ) ; } public static void main ( String [ ] args ) { int n = 5 , m = 5 ; int cost [ ] = { 2 , 2 , 8 , 6 , 9 } ; @ SuppressWarnings ( " unchecked " ) Vector < Integer > [ ] g = new Vector [ n ] ; for ( int i = 0 ; i < g . length ; i ++ ) g [ i ] = new Vector < Integer > ( ) ; g [ 0 ] . add ( 1 ) ; g [ 1 ] . add ( 0 ) ; g [ 0 ] . add ( 2 ) ; g [ 2 ] . add ( 0 ) ; g [ 0 ] . add ( 3 ) ; g [ 3 ] . add ( 0 ) ; g [ 1 ] . add ( 2 ) ; g [ 2 ] . add ( 1 ) ; g [ 1 ] . add ( 4 ) ; g [ 4 ] . add ( 1 ) ; int source = 1 ; Find@@ Max@@ Cost ( g , cost , source ) ; } }
class GF@@ G { static int min@@ Points ( int n , int m ) { int ans = 0 ; if ( ( n % 2 != 0 ) && ( m % 2 != 0 ) ) { ans = ( ( n * m ) / 2 ) + 1 ; } else { ans = ( n * m ) / 2 ; } return ans ; } public static void main ( String [ ] args ) { int N = 5 , M = 7 ; System . out . print ( min@@ Points ( N , M ) ) ; } }
class GF@@ G { static void create@@ Array ( int n , int s ) { if ( 2 * n <= s ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { System . out . print ( 2 + " ▁ " ) ; s -= 2 ; } System . out . println ( s ) ; System . out . println ( 1 ) ; } else System . out . print ( " - 1" ) ; } public static void main ( String [ ] args ) { int N = 1 ; int S = 4 ; create@@ Array ( N , S ) ; } }
import java . util . * ; class GF@@ G { static void maximum@@ Sum@@ Sub@@ array ( int arr [ ] , int n ) { Map < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= 0 ) mp . put ( arr [ i ] , 1 ) ; } int first = 0 ; int last = 0 ; int ans = 0 ; int INF = ( int ) 1e6 ; for ( Map . Entry < Integer , Integer > i : mp . entrySet ( ) ) { int mx = i . getKey ( ) ; int curr = 0 ; int curr_@@ start = - 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( curr == 0 ) curr_@@ start = j ; int val = arr [ j ] > mx ? - INF : arr [ j ] ; curr += val ; if ( curr < 0 ) curr = 0 ; if ( curr > ans ) { ans = curr ; first = curr_@@ start ; last = j ; } } } System . out . print ( ( first + 1 ) + " ▁ " + ( last + 1 ) ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , - 2 , 10 , - 1 , 4 } ; int size = arr . length ; maximum@@ Sum@@ Sub@@ array ( arr , size ) ; } }
import java . util . * ; class GF@@ G { static void min@@ Flip ( String s , int n , int k , char a [ ] , int p ) { boolean allowed [ ] = new boolean [ 26 ] ; for ( int i = 0 ; i < p ; i ++ ) { allowed [ a [ i ] - ' a ' ] = true ; } char [ ] [ ] freq = new char [ k ] [ 26 ] ; for ( int i = 0 ; i < k ; i ++ ) for ( int j = 0 ; j < 26 ; j ++ ) freq [ i ] [ j ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq [ i % k ] [ s . charAt ( i ) - ' a ' ] += 1 ; } int ans = 0 ; int total@@ positions = n / k ; for ( int i = 0 ; i < k ; i ++ ) { int max@@ frequency = 0 ; for ( int j = 0 ; j < 26 ; j ++ ) { if ( freq [ i ] [ j ] > max@@ frequency && allowed [ j ] == true ) max@@ frequency = freq [ i ] [ j ] ; } ans += ( total@@ positions - max@@ frequency + ( ( i % k < n % k ) ? 1 : 0 ) ) ; } System . out . print ( ans + "@@ NEW_@@ LINE@@ "@@ )@@ ; } public static void main ( String [ ] args ) { String S = " ni@@ h@@ si@@ ak@@ yt " ; int n = S . length ( ) ; int K = 3 ; char [ ] A = { ' n ' , ' i ' , ' p ' , ' s ' , ' q ' } ; int p = A . length ; min@@ Flip ( S , n , K , A , p ) ; } }
import java . lang . Math ; class GF@@ G { public static void Min@@ Diff ( int n ) { int val = ( int ) Math . pow ( 2 , n ) ; int sep = n / 2 ; int gr@@ p1 = 0 ; int gr@@ p2 = 0 ; gr@@ p1 = gr@@ p1 + val ; for ( int i = 1 ; i < sep ; i ++ ) gr@@ p1 = gr@@ p1 + ( int ) Math . pow ( 2 , i ) ; for ( int i = sep ; i < n ; i ++ ) gr@@ p2 = gr@@ p2 + ( int ) Math . pow ( 2 , i ) ; System . out . println ( Math . abs ( gr@@ p1 - gr@@ p2 ) ) ; } public static void main ( String args [ ] ) { int n = 4 ; Min@@ Diff ( n ) ; } }
import java . io . * ; import java . util . Arrays ; class GF@@ G { static int Minimum@@ Value ( int a [ ] , int n ) { int answer = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { answer = Math . min ( answer , ( ( a [ i ] & a [ j ] ) ^ ( a [ i ] a [ j ] ) ) ) ; } } return answer ; } public static void main ( String [ ] args ) { int N = 6 ; int [ ] A = new int [ ] { 12 , 3 , 14 , 5 , 9 , 8 } ; System . out . print ( Minimum@@ Value ( A , N ) ) ; } }
import java . util . * ; class GF@@ G { static int count@@ Of@@ Sub@@ Strings ( String s ) { int n = s . length ( ) ; int [ ] prefix_@@ sum = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '1' ) prefix_@@ sum [ i ] = 1 ; } for ( int i = 1 ; i < n ; i ++ ) prefix_@@ sum [ i ] += prefix_@@ sum [ i - 1 ] ; int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int count@@ Of@@ Ones = prefix_@@ sum [ j ] - ( i - 1 >= 0 ? prefix_@@ sum [ i - 1 ] : 0 ) ; int length = j - i + 1 ; if ( count@@ Of@@ Ones > 0 && length % count@@ Of@@ Ones == 0 ) answer ++ ; } } return answer ; } public static void main ( String [ ] args ) { String S = "@@ 1111@@ 10000@@ 0" ; System . out . print ( count@@ Of@@ Sub@@ Strings ( S ) ) ; } }
import java . util . * ; class GF@@ G { static int dig@@ it_@@ xor ( int x ) { int xor@@ r = 0 ; while ( x > 0 ) { xor@@ r ^= x % 10 ; x = x / 10 ; } return xor@@ r ; } static int find_@@ count ( int n ) { HashMap < Integer , Integer > mp@@ p = new HashMap < Integer , Integer > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( mp@@ p . containsKey ( dig@@ it_@@ xor ( i ) ) ) mp@@ p . put ( dig@@ it_@@ xor ( i ) , mp@@ p . get ( dig@@ it_@@ xor ( i ) ) + 1 ) ; else mp@@ p . put ( dig@@ it_@@ xor ( i ) , 1 ) ; } int max@@ m = 0 ; for ( Map . Entry < Integer , Integer > x : mp@@ p . entrySet ( ) ) { if ( x . getValue ( ) > max@@ m ) max@@ m = x . getValue ( ) ; } return max@@ m ; } public static void main ( String [ ] args ) { int N = 13 ; System . out . print ( find_@@ count ( N ) ) ; } }
import java . util . * ; class GF@@ G { static int min_@@ val = Integer . MAX_VALUE ; static int min_@@ steps = 0 ; static int sum@@ Of@@ Digits ( int n ) { String s = String . valueOf ( n ) ; int sum = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { sum += ( s . charAt ( i ) - '0' ) ; } return sum ; } static void Transform ( int n , int d , int steps ) { if ( n < min_@@ val ) { min_@@ val = n ; min_@@ steps = steps ; } else if ( n == min_@@ val ) { min_@@ steps = Math . min ( min_@@ steps , steps ) ; } if ( steps < 15 ) { Transform ( sum@@ Of@@ Digits ( n ) , d , steps + 1 ) ; Transform ( n + d , d , steps + 1 ) ; } } public static void main ( String [ ] args ) { int N = 9 , D = 3 ; Transform ( N , D , 0 ) ; System . out . print ( min_@@ val + " ▁ " + min_@@ steps ) ; } }
import java . util . * ; class GF@@ G { static int sum@@ Di@@ visi@@ bles ( int A , int B , int M ) { int sum = 0 ; for ( int i = A ; i <= B ; i ++ ) if ( i % M == 0 ) sum += i ; return sum ; } public static void main ( String [ ] args ) { int A = 6 , B = 15 , M = 3 ; System . out . print ( sum@@ Di@@ visi@@ bles ( A , B , M ) + "@@ NEW_@@ LINE@@ "@@ )@@ ; } }
import java . util . * ; class GF@@ G { static int count@@ Pairs ( int arr [ ] , int n ) { HashMap < Integer , Integer > frequency = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( frequency . containsKey ( arr [ i ] ) ) { frequency . put ( arr [ i ] , frequency . get ( arr [ i ] ) + 1 ) ; } else { frequency . put ( arr [ i ] , 1 ) ; } } int count = 0 ; for ( Map . Entry < Integer , Integer > x : frequency . entrySet ( ) ) { int f = x . getValue ( ) ; count += f * ( f - 1 ) / 2 ; } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 1 } ; int n = arr . length ; System . out . print ( count@@ Pairs ( arr , n ) ) ; } }
class GF@@ G { static void dec@@ Binary ( int arr [ ] , int n ) { int k = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ; while ( n > 0 ) { arr [ k -- ] = n % 2 ; n /= 2 ; } } static int binary@@ Dec ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += arr [ i ] << ( n - i - 1 ) ; return ans ; } static int max@@ Num ( int n , int k ) { int l = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) + 1 ; int a [ ] = new int [ l ] ; dec@@ Binary ( a , n ) ; int cn = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( a [ i ] == 0 && cn < k ) { a [ i ] = 1 ; cn ++ ; } } return binary@@ Dec ( a , l ) ; } public static void main ( String [ ] args ) { int n = 4 , k = 1 ; System . out . println ( max@@ Num ( n , k ) ) ; } }
class GF@@ G { static int MAX = 26 ; static char max@@ Alpha ( String str , int len ) { int [ ] first = new int [ MAX ] ; int [ ] last = new int [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { first [ i ] = - 1 ; last [ i ] = - 1 ; } for ( int i = 0 ; i < len ; i ++ ) { int index = ( str . charAt ( i ) - ' a ' ) ; if ( first [ index ] == - 1 ) first [ index ] = i ; last [ index ] = i ; } int ans = - 1 , maxVal = - 1 ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( first [ i ] == - 1 ) continue ; if ( ( last [ i ] - first [ i ] ) > maxVal ) { maxVal = last [ i ] - first [ i ] ; ans = i ; } } return ( char ) ( ans + ' a ' ) ; } public static void main ( String [ ] args ) { String str = " ab@@ bb@@ a " ; int len = str . length ( ) ; System . out . print ( max@@ Alpha ( str , len ) ) ; } }
class GF@@ G { static boolean is@@ Vo@@ wel ( char ch ) { switch ( ch ) { case ' a ' : case ' e ' : case ' i ' : case ' o ' : case ' u ' : return true ; default : return false ; } } static int vo@@ wel@@ Pairs ( String s , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( is@@ Vo@@ wel ( s . charAt ( i ) ) && is@@ Vo@@ wel ( s . charAt ( i + 1 ) ) ) cnt ++ ; } return cnt ; } public static void main ( String args [ ] ) { String s = " ab@@ a@@ eb@@ io " ; int n = s . length ( ) ; System . out . print ( vo@@ wel@@ Pairs ( s , n ) ) ; } }
class GF@@ G { static int min_@@ elimin@@ ation ( int n , int [ ] arr ) { int count = 0 ; int prev_@@ val = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { int curr_@@ val = arr [ i ] ; if ( curr_@@ val % 2 == prev_@@ val % 2 ) count ++ ; prev_@@ val = curr_@@ val ; } return count ; } public static void main ( String [ ] args ) { int [ ] arr = new int [ ] { 1 , 2 , 3 , 7 , 9 } ; int n = arr . length ; System . out . println ( min_@@ elimin@@ ation ( n , arr ) ) ; } }
import java . io . * ; class GF@@ G { static boolean check@@ If@@ Overlap ( String str ) { int len = str . length ( ) ; int [ ] visited = new int [ len + 1 ] ; for ( int i = 0 ; i < len ; i ++ ) { if ( str . charAt ( i ) == ' . ' ) continue ; for ( int j = Math . max ( 0 , i - str . charAt ( i ) ) ; j <= Math . min ( len , i + str . charAt ( i ) ) ; j ++ ) visited [ j ] ++ ; } for ( int i = 0 ; i < len ; i ++ ) { if ( visited [ i ] > 1 ) { return true ; } } return false ; } public static void main ( String [ ] args ) { String str = " . 2 . . 2 . " ; if ( check@@ If@@ Overlap ( str ) ) System . out . println ( " YES " ) ; else System . out . print ( " NO " ) ; } }
import java . io . * ; class GF@@ G { static boolean is@@ Correct@@ Order ( int n ) { boolean flag = true ; int prev = - 1 ; int type = - 1 ; while ( n != 0 ) { if ( type == - 1 ) { if ( prev == - 1 ) { prev = n % 10 ; n = n / 10 ; continue ; } if ( prev == n % 10 ) { flag = false ; break ; } if ( prev > n % 10 ) { type = 1 ; prev = n % 10 ; n = n / 10 ; continue ; } prev = n % 10 ; n = n / 10 ; } else { if ( prev == n % 10 ) { flag = false ; break ; } if ( prev < n % 10 ) { flag = false ; break ; } prev = n % 10 ; n = n / 10 ; } } return flag ; } public static void main ( String [ ] args ) { int n = 12345@@ 432@@ 1 ; if ( is@@ Correct@@ Order ( n ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
import java . util . * ; class GF@@ G { static int V = 5 ; static int INT_MAX = Integer . MAX_VALUE ; static boolean isValid@@ Edge ( int u , int v , boolean [ ] in@@ M@@ ST ) { if ( u == v ) return false ; if ( in@@ M@@ ST [ u ] == false && in@@ M@@ ST [ v ] == false ) return false ; else if ( in@@ M@@ ST [ u ] == true && in@@ M@@ ST [ v ] == true ) return false ; return true ; } static void prim@@ M@@ ST ( int cost [ ] [ ] ) { boolean [ ] in@@ M@@ ST = new boolean [ V ] ; in@@ M@@ ST [ 0 ] = true ; int edge@@ _count = 0 , min@@ cost = 0 ; while ( edge@@ _count < V - 1 ) { int min = INT_MAX , a = - 1 , b = - 1 ; for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { if ( cost [ i ] [ j ] < min ) { if ( isValid@@ Edge ( i , j , in@@ M@@ ST ) ) { min = cost [ i ] [ j ] ; a = i ; b = j ; } } } } if ( a != - 1 && b != - 1 ) { System . out . printf ( "@@ Edge %@@ d@@ :@@ (@@ %@@ d@@ , %@@ d@@ ) cost@@ : %@@ d NEW_@@ LINE@@ "@@ , edge_@@ count@@ ++@@ , a@@ , b@@ , min@@ )@@ ; min@@ cost = min@@ cost + min ; in@@ M@@ ST [ b ] = in@@ M@@ ST [ a ] = true ; } } System . out . printf ( " Minimum cost = % d "@@ , min@@ cost@@ )@@ ; } public static void main ( String [ ] args ) { int cost [ ] [ ] = { { INT_MAX , 2 , INT_MAX , 6 , INT_MAX } , { 2 , INT_MAX , 3 , 8 , 5 } , { INT_MAX , 3 , INT_MAX , INT_MAX , 7 } , { 6 , 8 , INT_MAX , INT_MAX , 9 } , { INT_MAX , 5 , 7 , 9 , INT_MAX } } ; prim@@ M@@ ST ( cost ) ; } }
import java . util . * ; class GF@@ G { static class pair { double first , second ; public pair ( double first , double second ) { this . first = first ; this . second = second ; } } static void construct ( int n , pair an@@ s_@@ pair ) { if ( an@@ s_@@ pair . first == - 1 ) { System . out . print ( " Not ▁ possible " ) ; return ; } double a1 = an@@ s_@@ pair . first ; double a2 = an@@ s_@@ pair . second ; double r = a2 / a1 ; System . out . print ( "@@ The result@@ ant sequence is@@ :@@ NEW_@@ LINE@@ "@@ )@@ ; for ( int i = 1 ; i <= n ; i ++ ) { int ai = ( int ) ( a1 * Math . pow ( r , i - 1 ) ) ; System . out . print ( ai + " ▁ " ) ; } } static void find@@ Minimum@@ Operations ( double [ ] a , int n ) { int ans = Integer . MAX_VALUE ; int c [ ] = { - 1 , 0 , 1 } ; int possi@@ bilities = 3 ; int pos1 = - 1 , pos2 = - 1 ; for ( int i = 0 ; i < possi@@ bilities ; i ++ ) { for ( int j = 0 ; j < possi@@ bilities ; j ++ ) { double a1 = a [ 1 ] + c [ i ] ; double a2 = a [ 2 ] + c [ j ] ; int temp = ( int ) ( Math . abs ( a1 - a [ 1 ] ) + Math . abs ( a2 - a [ 2 ] ) ) ; if ( a1 == 0 a2 == 0 ) continue ; double r = a2 / a1 ; for ( int pos = 3 ; pos <= n ; pos ++ ) { double ai = a1 * Math . pow ( r , pos - 1 ) ; if ( a [ pos ] == ai ) { continue ; } else if ( a [ pos ] + 1 == ai a [ pos ] - 1 == ai ) { temp ++ ; } else { temp = Integer . MAX_VALUE ; break ; } } if ( temp < ans ) { ans = temp ; pos1 = ( int ) a1 ; pos2 = ( int ) a2 ; } } } if ( ans == - 1 ) { System . out . print ( " - 1" ) ; return ; } System . out . print ( " Minimum ▁ Number ▁ of ▁ Operations ▁ are ▁ " + ans + "@@ NEW_@@ LINE@@ "@@ )@@ ; pair an@@ s_@@ pair = new pair ( pos1 , pos2 ) ; construct ( n , an@@ s_@@ pair ) ; } public static void main ( String [ ] args ) { double a [ ] = { 0 , 7 , 20 , 49 , 125 } ; int n = a . length ; find@@ Minimum@@ Operations ( a , n - 1 ) ; } }
import java . util . * ; class solution { static int find@@ Minimum@@ Adjac@@ ent@@ Sw@@ aps ( int arr [ ] , int N ) { boolean [ ] visited = new boolean [ N + 1 ] ; int minimum@@ Sw@@ aps = 0 ; Arrays . fill ( visited , false ) ; for ( int i = 0 ; i < 2 * N ; i ++ ) { if ( visited [ arr [ i ] ] == false ) { visited [ arr [ i ] ] = true ; int count = 0 ; for ( int j = i + 1 ; j < 2 * N ; j ++ ) { if ( visited [ arr [ j ] ] == false ) count ++ ; else if ( arr [ i ] == arr [ j ] ) minimum@@ Sw@@ aps += count ; } } } return minimum@@ Sw@@ aps ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 3 , 3 , 1 , 2 } ; int N = arr . length ; N /= 2 ; System . out . println ( find@@ Minimum@@ Adjac@@ ent@@ Sw@@ aps ( arr , N ) ) ; } }
import java . io . * ; class GF@@ G { static int Min@@ Operation ( int a [ ] , int n , int k ) { int result = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( a [ i ] != 1 && a [ i ] > k ) { result = result + Math . min ( a [ i ] % k , k - a [ i ] % k ) ; } else { result = result + k - a [ i ] ; } } return result ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 5 , 6 } ; int n = arr . length ; int k = 5 ; System . out . println ( Min@@ Operation ( arr , n , k ) ) ; } }
import java . io . * ; import java . util . * ; class GF@@ G { static void print@@ Vector ( Vector < Integer > v ) { System . out . println ( v . size ( ) ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) System . out . print ( v . get ( i ) + " ▁ " ) ; System . out . println ( ) ; } static void find@@ Two@@ Group ( int n ) { int sum = n * ( n + 1 ) / 2 ; int group@@ 1@@ Sum = sum / 2 ; Vector < Integer > group1 = new Vector < Integer > ( ) ; Vector < Integer > group2 = new Vector < Integer > ( ) ; for ( int i = n ; i > 0 ; i -- ) { if ( group@@ 1@@ Sum - i >= 0 ) { group1 . add ( i ) ; group@@ 1@@ Sum -= i ; } else { group2 . add ( i ) ; } } print@@ Vector ( group1 ) ; print@@ Vector ( group2 ) ; } public static void main ( String [ ] args ) { int n = 5 ; find@@ Two@@ Group ( n ) ; } }
import java . util . * ; class GF@@ G { public static long swap@@ Count ( String s ) { Vector < Integer > pos = new Vector < Integer > ( ) ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) if ( s . charAt ( i ) == ' [ ' ) pos . add ( i ) ; int count = 0 ; int p = 0 ; long sum = 0 ; char [ ] S = s . toCharArray ( ) ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { if ( S [ i ] == ' [ ' ) { ++ count ; ++ p ; } else if ( S [ i ] == ' ] ' ) -- count ; if ( count < 0 ) { sum += pos . get ( p ) - i ; char temp = S [ i ] ; S [ i ] = S [ pos . get ( p ) ] ; S [ pos . get ( p ) ] = temp ; ++ p ; count = 1 ; } } return sum ; } public static void main ( String [ ] args ) { String s = " [ ] ] [ ] [ " ; System . out . println ( swap@@ Count ( s ) ) ; s = " [ [ ] [ ] ] " ; System . out . println ( swap@@ Count ( s ) ) ; } }
import java . lang . * ; import java . util . * ; class GF@@ G { static int mod = 100000000@@ 7 ; static void count@@ Of@@ Numbers ( int N ) { int ans = 1 ; for ( int index = 1 ; index <= N ; ++ index ) { int choices = 0 ; for ( int digit = 1 ; digit <= 9 ; ++ digit ) { if ( index % digit == 0 ) { ++ choices ; } } ans = ( ans * choices ) % mod ; } System . out . println ( ans ) ; } public static void main ( String [ ] args ) { int N = 5 ; count@@ Of@@ Numbers ( N ) ; } }
import java . io . * ; import java . util . * ; class GF@@ G { public static int dfs ( int [ ] arr , int left , int K ) { int q = 0 ; if ( left == 0 ) { for ( int i = 1 ; i < K ; ++ i ) { if ( arr [ i ] > 0 ) { arr [ i ] -- ; q = Math . max ( q , 1 + dfs ( arr , K - i , K ) ) ; arr [ i ] ++ ; } } } else { for ( int i = 1 ; i < K ; ++ i ) { if ( arr [ i ] > 0 ) { arr [ i ] -- ; int n@@ left = ( i <= left ? left - i : K + left - i ) ; q = Math . max ( q , dfs ( arr , n@@ left , K ) ) ; arr [ i ] ++ ; } } } return q ; } public static int max@@ Groups ( int K , int [ ] arr ) { int V [ ] = new int [ K ] ; for ( int x : arr ) V [ x % K ] ++ ; int ans = V [ 0 ] + dfs ( V , 0 , K ) ; return ans ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 , 6 } ; int K = 3 ; System . out . println ( max@@ Groups ( K , arr ) ) ; } }
import java . lang . * ; import java . util . * ; class GF@@ G { static void lon@@ gest@@ Sub@@ sequence ( int [ ] arr , int N ) { int dp [ ] [ ] = new int [ N ] [ N + 1 ] ; for ( int i = 0 ; i < N ; ++ i ) { for ( int j = 0 ; j < N + 1 ; ++ j ) { dp [ i ] [ j ] = - 1 ; } } for ( int i = 0 ; i < N ; ++ i ) { dp [ i ] [ 0 ] = 0 ; } dp [ 0 ] [ 1 ] = ( arr [ 0 ] >= 0 ? arr [ 0 ] : - 1 ) ; for ( int i = 1 ; i < N ; ++ i ) { for ( int j = 1 ; j <= ( i + 1 ) ; ++ j ) { if ( dp [ i - 1 ] [ j ] != - 1 ) { dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j ] ) ; } if ( dp [ i - 1 ] [ j - 1 ] >= 0 && dp [ i - 1 ] [ j - 1 ] + arr [ i ] >= 0 ) { dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j - 1 ] + arr [ i ] ) ; } } } int ans = 0 ; for ( int j = 0 ; j <= N ; ++ j ) { if ( dp [ N - 1 ] [ j ] >= 0 ) { ans = j ; } } System . out . println ( ans ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , - 4 , 1 , - 3 , 1 , - 3 } ; int N = arr . length ; lon@@ gest@@ Sub@@ sequence ( arr , N ) ; } }
class GF@@ G { static int K@@ visible@@ From@@ Left ( int N , int K ) { if ( N == K ) return 1 ; if ( K == 1 ) { int ans = 1 ; for ( int i = 1 ; i < N ; i ++ ) ans *= i ; return ans ; } return K@@ visible@@ From@@ Left ( N - 1 , K - 1 ) + ( N - 1 ) * K@@ visible@@ From@@ Left ( N - 1 , K ) ; } public static void main ( String [ ] args ) { int N = 5 , K = 2 ; System . out . println ( K@@ visible@@ From@@ Left ( N , K ) ) ; } }
import java . io . * ; import java . lang . * ; import java . util . * ; class GF@@ G { static int numOf@@ W@@ ays ( int a [ ] [ ] , int n , int i , HashSet < Integer > blue ) { if ( i == n ) return 1 ; int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( a [ i ] [ j ] == 1 && ! blue . contains ( j ) ) { blue . add ( j ) ; count += numOf@@ W@@ ays ( a , n , i + 1 , blue ) ; blue . remove ( j ) ; } } return count ; } public static void main ( String [ ] args ) { int n = 3 ; int mat [ ] [ ] = { { 0 , 1 , 1 } , { 1 , 0 , 1 } , { 1 , 1 , 1 } } ; HashSet < Integer > mp@@ p = new HashSet < > ( ) ; System . out . println ( ( numOf@@ W@@ ays ( mat , n , 0 , mp@@ p ) ) ) ; } }
import java . util . * ; class GF@@ G { static int total@@ Arrays ( int N , int M ) { int [ ] end_@@ with_@@ one = new int [ N + 1 ] ; int [ ] end_@@ not_@@ with_@@ one = new int [ N + 1 ] ; end_@@ with_@@ one [ 0 ] = 1 ; end_@@ not_@@ with_@@ one [ 0 ] = 0 ; end_@@ with_@@ one [ 1 ] = 0 ; end_@@ not_@@ with_@@ one [ 1 ] = M - 1 ; for ( int i = 2 ; i < N ; i ++ ) { end_@@ with_@@ one [ i ] = end_@@ not_@@ with_@@ one [ i - 1 ] ; end_@@ not_@@ with_@@ one [ i ] = end_@@ with_@@ one [ i - 1 ] * ( M - 1 ) + end_@@ not_@@ with_@@ one [ i - 1 ] * ( M - 2 ) ; } return end_@@ with_@@ one [ N - 1 ] ; } public static void main ( String [ ] args ) { int N = 3 , M = 3 ; int temp = total@@ Arrays ( N , M ) ; int ans = M * temp ; System . out . print ( ans + "@@ NEW_@@ LINE@@ "@@ )@@ ; } }
import java . util . * ; class GF@@ G { static int M = 100000000@@ 7 ; static int power ( int X , int Y ) { int res = 1 ; X = X % M ; if ( X == 0 ) return 0 ; while ( Y > 0 ) { if ( ( Y & 1 ) != 0 ) { res = ( res * X ) % M ; } Y = Y >> 1 ; X = ( X * X ) % M ; } return res ; } static int find@@ Value ( int n ) { int X = 0 ; int pow_@@ 10 = 1 ; while ( n != 0 ) { if ( ( n & 1 ) != 0 ) { X += pow_@@ 10 ; } pow_@@ 10 *= 10 ; n /= 2 ; } X = ( X * 2 ) % M ; int res = power ( 2 , X ) ; return res ; } public static void main ( String [ ] args ) { int n = 2 ; System . out . println ( find@@ Value ( n ) ) ; } }
class GF@@ G { static void count@@ Way@@ sTo@@ Tile@@ Board ( int N ) { int dp [ ] = new int [ N + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 2 ; for ( int i = 2 ; i <= N ; i ++ ) { dp [ i ] = ( 2 * dp [ i - 1 ] + dp [ i - 2 ] ) ; } System . out . print ( dp [ N ] ) ; } public static void main ( String [ ] args ) { int N = 2 ; count@@ Way@@ sTo@@ Tile@@ Board ( N ) ; } }
import java . util . * ; class GF@@ G { static int remove@@ S@@ malle@@ st@@ Sub@@ array ( int arr [ ] , int S , int n , int k ) { int target_@@ remainder = S % k ; HashMap < Integer , Integer > map1 = new HashMap < > ( ) ; map1 . put ( 0 , - 1 ) ; int curr_@@ remainder = 0 ; int res = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { curr_@@ remainder = ( curr_@@ remainder + arr [ i ] + k ) % k ; map1 . put ( curr_@@ remainder , i ) ; int mod = ( curr_@@ remainder - target_@@ remainder + k ) % k ; if ( map1 . containsKey ( mod ) ) { res = Math . min ( res , i - map1 . get ( mod ) ) ; } } if ( res == Integer . MAX_VALUE res == n ) { res = - 1 ; } return res ; } static int sm@@ st@@ Sub@@ mat@@ Deleted ( int [ ] [ ] mat , int N , int M , int K ) { int S = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) S += mat [ i ] [ j ] ; } int min_@@ area = N * M ; int left = 0 ; int right = 0 ; int width ; int area ; int [ ] prefix@@ Row@@ Sum = new int [ N ] ; for ( left = 0 ; left < M ; left ++ ) { Arrays . fill ( prefix@@ Row@@ Sum , 0 ) ; for ( right = left ; right < M ; right ++ ) { for ( int i = 0 ; i < N ; i ++ ) { prefix@@ Row@@ Sum [ i ] += mat [ i ] [ right ] ; } width = remove@@ S@@ malle@@ st@@ Sub@@ array ( prefix@@ Row@@ Sum , S , N , K ) ; if ( width != - 1 ) { area = ( right - left + 1 ) * ( width ) ; if ( area < min_@@ area ) { min_@@ area = area ; } } } } return min_@@ area ; } public static void main ( String [ ] args ) { int [ ] [ ] mat = { { 6 , 2 , 6 } , { 3 , 2 , 8 } , { 2 , 5 , 3 } } ; int K = 3 ; int N = mat . length ; int M = mat [ 0 ] . length ; System . out . print ( sm@@ st@@ Sub@@ mat@@ Deleted ( mat , N , M , K ) ) ; } }
import java . util . * ; public class Main { static int count@@ strings ( int n , int start ) { if ( n == 0 ) { return 1 ; } int cnt = 0 ; for ( int i = start ; i < 5 ; i ++ ) { cnt += count@@ strings ( n - 1 , i ) ; } return cnt ; } static int count@@ Vo@@ wel@@ Strings ( int n ) { return count@@ strings ( n , 0 ) ; } public static void main ( String [ ] args ) { int n = 2 ; System . out . print ( count@@ Vo@@ wel@@ Strings ( n ) ) ; } }
import java . util . * ; class GF@@ G { static int find@@ NumberOf@@ Strings ( int n ) { return ( n + 1 ) * ( n + 2 ) * ( n + 3 ) * ( n + 4 ) / 24 ; } public static void main ( String [ ] args ) { int N = 2 ; System . out . print ( find@@ NumberOf@@ Strings ( N ) ) ; } }
import java . io . * ; import java . util . * ; class GF@@ G { static int mod = ( int ) 1e@@ 9 + 7 ; static int find@@ Total@@ Path ( int X , int n , ArrayList < Integer > dp ) { if ( X == 0 ) { return 1 ; } int ans = 0 ; if ( dp . get ( X ) != - 1 ) { return dp . get ( X ) ; } for ( int i = 1 ; i <= Math . min ( X , n ) ; ++ i ) { ans += find@@ Total@@ Path ( X - i , n , dp ) % mod ; ans %= mod ; } dp . set ( X , ans ) ; return ans ; } public static void main ( String [ ] args ) { int n = 3 , X = 2 ; ArrayList < Integer > dp = new ArrayList < Integer > ( Collections . n@@ Copies ( X + 1 , - 1 ) ) ; System . out . print ( find@@ Total@@ Path ( X , n , dp ) ) ; } }
import java . util . * ; class GF@@ G { static int MAX = 10000@@ 5 ; static Vector < Integer > Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( ) { boolean [ ] se@@ ive = new boolean [ MAX ] ; Arrays . fill ( se@@ ive , true ) ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( se@@ ive [ p ] == true ) { for ( int i = p * p ; i < MAX ; i += p ) { se@@ ive [ i ] = false ; } } } Vector < Integer > v = new Vector < Integer > ( ) ; for ( int p = 2 ; p < MAX ; p ++ ) { if ( se@@ ive [ p ] ) { v . add ( p ) ; } } return v ; } static void build ( int dp [ ] , int arr [ ] , int N ) { dp [ 0 ] = 0 ; dp [ 1 ] = 0 ; Vector < Integer > prime = Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( ) ; int [ ] pref = new int [ N + 1 ] ; pref [ 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { pref [ i ] = pref [ i - 1 ] + arr [ i - 1 ] ; } for ( int i = 2 ; i <= N ; i ++ ) { dp [ i ] = dp [ i - 1 ] ; for ( int j = 0 ; j <= prime . size ( ) ; j ++ ) { int r = i - 1 ; int l = r - prime . get ( j ) + 1 ; if ( l < 0 ) break ; int temp = 0 ; temp = pref [ r + 1 ] - pref [ l ] ; if ( l - 2 >= 0 ) temp += dp [ l - 2 + 1 ] ; dp [ i ] = Math . max ( dp [ i ] , temp ) ; } } } static void max@@ Sum@@ Sub@@ seq ( int arr [ ] , int N ) { int [ ] dp = new int [ N + 1 ] ; build ( dp , arr , N ) ; System . out . print ( dp [ N ] ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 10 , 10 , 7 , 10 , 10 , 10 } ; int N = arr . length ; max@@ Sum@@ Sub@@ seq ( arr , N ) ; } }
import java . io . * ; class GF@@ G { static int bin@@ Co@@ ff ( int N , int R ) { int res = 1 ; if ( R > ( N - R ) ) { R = ( N - R ) ; } for ( int i = 0 ; i < R ; i ++ ) { res *= ( N - i ) ; res /= ( i + 1 ) ; } return res ; } static int cnt@@ Permutation ( int N ) { int cnt@@ Perm ; int C_@@ 2@@ N_@@ N = bin@@ Co@@ ff ( 2 * N , N ) ; cnt@@ Perm = C_@@ 2@@ N_@@ N / ( N + 1 ) ; return cnt@@ Perm ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int N = arr . length ; System . out . println ( cnt@@ Permutation ( N / 2 ) ) ; } }
class GF@@ G { static int check@@ Equal@@ Sum@@ Util ( int arr [ ] , int N , int sm@@ 1 , int sm@@ 2 , int sm@@ 3 , int j ) { if ( j == N ) { if ( sm@@ 1 == sm@@ 2 && sm@@ 2 == sm@@ 3 ) return 1 ; else return 0 ; } else { int l = check@@ Equal@@ Sum@@ Util ( arr , N , sm@@ 1 + arr [ j ] , sm@@ 2 , sm@@ 3 , j + 1 ) ; int m = check@@ Equal@@ Sum@@ Util ( arr , N , sm@@ 1 , sm@@ 2 + arr [ j ] , sm@@ 3 , j + 1 ) ; int r = check@@ Equal@@ Sum@@ Util ( arr , N , sm@@ 1 , sm@@ 2 , sm@@ 3 + arr [ j ] , j + 1 ) ; return Math . max ( Math . max ( l , m ) , r ) ; } } static void check@@ Equal@@ Sum ( int arr [ ] , int N ) { int sum@@ 1 , sum@@ 2 , sum@@ 3 ; sum@@ 1 = sum@@ 2 = sum@@ 3 = 0 ; if ( check@@ Equal@@ Sum@@ Util ( arr , N , sum@@ 1 , sum@@ 2 , sum@@ 3 , 0 ) == 1 ) { System . out . print ( " Yes " ) ; } else { System . out . print ( " No " ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 17 , 34 , 59 , 23 , 17 , 67 , 57 , 2 , 18 , 59 , 1 } ; int N = arr . length ; check@@ Equal@@ Sum ( arr , N ) ; } }
import java . util . * ; class GF@@ G { static void Sub@@ array@@ With@@ Max@@ Sum ( Vector < Integer > nums ) { int endIndex = 0 , curr@@ Max = nums . get ( 0 ) ; int global@@ Max = nums . get ( 0 ) ; for ( int i = 1 ; i < nums . size ( ) ; ++ i ) { curr@@ Max = Math . max ( nums . get ( i ) , nums . get ( i ) + curr@@ Max ) ; if ( curr@@ Max > global@@ Max ) { global@@ Max = curr@@ Max ; endIndex = i ; } } int startIndex = endIndex ; while ( startIndex >= 0 ) { global@@ Max -= nums . get ( startIndex ) ; if ( global@@ Max == 0 ) break ; startIndex -- ; } for ( int i = startIndex ; i <= endIndex ; ++ i ) { System . out . print ( nums . get ( i ) + " ▁ " ) ; } } public static void main ( String [ ] args ) { Vector < Integer > arr = new Vector < Integer > ( ) ; arr . add ( - 2 ) ; arr . add ( - 5 ) ; arr . add ( 6 ) ; arr . add ( - 2 ) ; arr . add ( - 3 ) ; arr . add ( 1 ) ; arr . add ( 5 ) ; arr . add ( - 6 ) ; Sub@@ array@@ With@@ Max@@ Sum ( arr ) ; } }
import java . io . * ; class GF@@ G { public static int maxim@@ ize@@ Sum ( int [ ] arr ) { int n = arr . length ; int sum = 0 ; for ( int i = 0 ; i < n ; i = i + 2 ) sum += arr [ i ] ; int left@@ DP [ ] = new int [ n / 2 ] ; int right@@ DP [ ] = new int [ n / 2 ] ; int c = 0 ; for ( int i = 1 ; i < n ; i = i + 2 ) { int left@@ Diff = arr [ i ] - arr [ i - 1 ] ; if ( c - 1 < 0 ) left@@ DP = left@@ Diff ; else { if ( left@@ DP > 0 ) left@@ DP = left@@ Diff + left@@ DP ; else left@@ DP [ i ] = left@@ Diff ; } int right@@ Diff ; if ( i + 1 >= arr . length ) right@@ Diff = 0 ; else right@@ Diff = arr [ i ] - arr [ i + 1 ] ; if ( c - 1 < 0 ) right@@ DP = right@@ Diff ; else { if ( right@@ DP > 0 ) right@@ DP = right@@ Diff + right@@ DP ; else right@@ DP = right@@ Diff ; } c ++ ; } int max = 0 ; for ( int i = 0 ; i < n / 2 ; i ++ ) { max = Math . max ( max , Math . max ( left@@ DP [ i ] , right@@ DP [ i ] ) ) ; } return max + sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 7 , 8 , 4 , 5 , 7 , 6 , 8 , 9 , 7 , 3 } ; int ans = maxim@@ ize@@ Sum ( arr ) ; System . out . println ( ans ) ; } }
import java . util . * ; import java . io . * ; class GF@@ G { static int valid@@ sub@@ sequences ( int arr [ ] , int n ) { long dp [ ] [ ] = new long [ n + 1 ] [ 2 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { dp [ i ] [ 0 ] = 0 ; dp [ i ] [ 1 ] = 0 ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( arr [ i - 1 ] % 2 != 0 ) { dp [ i ] [ 1 ] += 1 ; dp [ i ] [ 1 ] += dp [ i - 1 ] [ 0 ] ; dp [ i ] [ 1 ] += dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 0 ] += dp [ i - 1 ] [ 0 ] ; } else { dp [ i ] [ 0 ] += 1 ; dp [ i ] [ 0 ] += dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 0 ] += dp [ i - 1 ] [ 0 ] ; dp [ i ] [ 1 ] += dp [ i - 1 ] [ 1 ] ; } } return ( int ) ( dp [ n ] [ 0 ] + dp [ n ] [ 1 ] ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 6 , 9 , 7 } ; int n = arr . length ; System . out . print ( valid@@ sub@@ sequences ( arr , n ) ) ; } }
import java . util . * ; class GF@@ G { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static void O@@ dd@@ Di@@ visor@@ sCount ( int n , int q , int a [ ] , pair [ ] Query ) { int DP [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = ( int ) Math . sqrt ( a [ i ] ) ; if ( x * x == a [ i ] ) DP [ i ] = 1 ; } for ( int i = 1 ; i < n ; i ++ ) { DP [ i ] = DP [ i - 1 ] + DP [ i ] ; } int l , r ; for ( int i = 0 ; i < q ; i ++ ) { l = Query [ i ] . first ; r = Query [ i ] . second ; if ( l == 0 ) { System . out . print ( DP [ r ] + "@@ NEW_@@ LINE@@ "@@ )@@ ; } else { System . out . print ( DP [ r ] - DP [ l - 1 ] + "@@ NEW_@@ LINE@@ "@@ )@@ ; } } } public static void main ( String [ ] args ) { int N = 5 ; int Q = 3 ; int arr [ ] = { 2 , 4 , 5 , 6 , 9 } ; pair [ ] Query = { new pair ( 0 , 2 ) , new pair ( 1 , 3 ) , new pair ( 1 , 4 ) } ; O@@ dd@@ Di@@ visor@@ sCount ( N , Q , arr , Query ) ; } }
import java . io . * ; class GF@@ G { static int count@@ Stable@@ Num ( String str , int N ) { int count@@ 1 [ ] [ ] = new int [ N ] [ 10 ] ; int count2 [ ] [ ] = new int [ N ] [ 10 ] ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < 10 ; j ++ ) count@@ 1 [ i ] [ j ] = count2 [ i ] [ j ] = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i != 0 ) { for ( int j = 0 ; j < 10 ; j ++ ) { count@@ 1 [ i ] [ j ] += count@@ 1 [ i - 1 ] [ j ] ; } } count@@ 1 [ i ] [ str . charAt ( i ) - '0' ] ++ ; } for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( i != N - 1 ) { for ( int j = 0 ; j < 10 ; j ++ ) { count2 [ i ] [ j ] += count2 [ i + 1 ] [ j ] ; } } count2 [ i ] [ str . charAt ( i ) - '0' ] ++ ; } int ans = 0 ; for ( int i = 1 ; i < N - 1 ; i ++ ) { if ( str . charAt ( i ) == '9' ) continue ; int c1 = count@@ 1 [ i - 1 ] [ str . charAt ( i ) - '0' ] ; int c2 = count2 [ i + 1 ] [ str . charAt ( i ) - '0' + 1 ] ; if ( c2 == 0 ) continue ; ans = ( ans + ( c1 * ( ( c2 * ( c2 - 1 ) / 2 ) ) ) ) ; } return ans ; } public static void main ( String [ ] args ) { String str = "@@ 224@@ 35@@ 3" ; int N = str . length ( ) ; System . out . println ( count@@ Stable@@ Num ( str , N ) ) ; } }
import java . lang . * ; import java . util . * ; class GF@@ G { static final long MAX = ( long ) 1e@@ 18 ; static long n , m ; static List < List < Long > > v = new ArrayList < > ( 151 ) ; static long [ ] [ ] dp = new long [ 151 ] [ 151 ] ; static long min_@@ operation ( long i , long j , long val , long x ) { if ( i == n - 1 && j == m - 1 ) { if ( val > v . get ( ( int ) i ) . get ( ( int ) j ) ) { return dp [ ( int ) i ] [ ( int ) j ] = MAX ; } else { return dp [ ( int ) i ] [ ( int ) j ] = v . get ( ( int ) i ) . get ( ( int ) j ) - val ; } } if ( i == n j == m ) { return dp [ ( int ) i ] [ ( int ) j ] = MAX ; } if ( dp [ ( int ) i ] [ ( int ) j ] != - 1 ) { return dp [ ( int ) i ] [ ( int ) j ] ; } if ( val > v . get ( ( int ) i ) . get ( ( int ) j ) ) { return dp [ ( int ) i ] [ ( int ) j ] = MAX ; } long tmp = v . get ( ( int ) i ) . get ( ( int ) j ) - val ; tmp += Math . min ( min_@@ operation ( i + 1 , j , val + x , x ) , min_@@ operation ( i , j + 1 , val + x , x ) ) ; return dp [ ( int ) i ] [ ( int ) j ] = tmp ; } static long solve ( long x ) { long ans = Long . MAX_VALUE ; for ( long i = 0 ; i < n ; i ++ ) { for ( long j = 0 ; j < m ; j ++ ) { long val = v . get ( ( int ) i ) . get ( ( int ) j ) - x * ( i + j ) ; for ( int k = 0 ; k < dp . length ; k ++ ) for ( int l = 0 ; l < dp [ k ] . length ; l ++ ) dp [ k ] [ l ] = - 1 ; val = min_@@ operation ( 0l , 0l , val , x ) ; ans = Math . min ( ans , val ) ; } } return ans ; } public static void main ( String [ ] args ) { n = 2 ; m = 2 ; long x = 3 ; v . add ( Arrays . asList ( 15@@ l , 15@@ 3@@ l ) ) ; v . add ( Arrays . asList ( 135@@ l , 17@@ l ) ) ; System . out . println ( solve ( x ) ) ; } }
import java . util . * ; class GF@@ G { static int K ; static int N ; static Vector < Integer > v = new Vector < > ( ) ; static int [ ] [ ] [ ] [ ] [ ] dp = new int [ 20 ] [ 1000 ] [ 10 ] [ 2 ] [ 2 ] ; static void init ( int x ) { for ( int i = 0 ; i < 20 ; i ++ ) for ( int j = 0 ; j < 1000 ; j ++ ) for ( int k = 0 ; k < 10 ; k ++ ) for ( int l = 0 ; l < 2 ; l ++ ) for ( int m = 0 ; m < 2 ; m ++ ) dp [ i ] [ j ] [ k ] [ l ] [ m ] = - 1 ; v . clear ( ) ; while ( x > 0 ) { v . add ( x % 10 ) ; x /= 10 ; } Collections . reverse ( v ) ; N = v . size ( ) ; } static int fun ( int pos , int sum , int st , int check , int f ) { if ( pos == N ) { return ( sum == 0 && check == 1 ) ? 1 : 0 ; } if ( dp [ pos ] [ sum ] [ st ] [ check ] [ f ] != - 1 ) return dp [ pos ] [ sum ] [ st ] [ check ] [ f ] ; int l@@ mt = 9 ; if ( f == 0 ) l@@ mt = v . get ( pos ) ; int ans = 0 ; for ( int digit = 0 ; digit <= l@@ mt ; digit ++ ) { int nf = f ; int new_@@ sum = ( sum + digit ) % K ; int new_@@ check = check ; int new_@@ st = st ; if ( f == 0 && digit < l@@ mt ) nf = 1 ; if ( check == 0 && digit != 0 ) { new_@@ st = digit ; new_@@ check = 1 ; } if ( pos == N - 1 && new_@@ st == digit ) continue ; ans += fun ( pos + 1 , new_@@ sum , new_@@ st , new_@@ check , nf ) ; } return dp [ pos ] [ sum ] [ st ] [ check ] [ f ] = ans ; } static void find@@ Count ( int L , int R , int K ) { init ( R ) ; int r_@@ ans = fun ( 0 , 0 , 0 , 0 , 0 ) ; init ( L - 1 ) ; int l_@@ ans = fun ( 0 , 0 , 0 , 0 , 0 ) ; System . out . print ( r_@@ ans - l_@@ ans ) ; } public static void main ( String [ ] args ) { int L = 10 ; int R = 20 ; K = 2 ; find@@ Count ( L , R , K ) ; } }
import java . util . * ; class GF@@ G { static boolean is@@ Per@@ fec@@ t@@ Square ( double x ) { double sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; } static int find@@ Sub@@ array@@ Sum ( int arr [ ] , int n , int K ) { Map < Integer , Integer > prev@@ Sum = new HashMap < > ( ) ; int res = 0 ; int curr@@ sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr@@ sum += arr [ i ] ; if ( curr@@ sum == K ) { res ++ ; } if ( prev@@ Sum . containsKey ( curr@@ sum - K ) ) res += ( prev@@ Sum . get ( curr@@ sum - K ) ) ; prev@@ Sum . put ( curr@@ sum , prev@@ Sum . getOr@@ Default ( curr@@ sum , 0 ) + 1 ) ; } return res ; } static void count@@ Sub@@ array ( int arr [ ] , int n , int K ) { for ( int i = 0 ; i < n ; i ++ ) { if ( is@@ Per@@ fec@@ t@@ Square ( arr [ i ] ) ) { arr [ i ] = 1 ; } else { arr [ i ] = 0 ; } } System . out . println ( find@@ Sub@@ array@@ Sum ( arr , n , K ) ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 9 , 2 } ; int K = 2 ; int N = arr . length ; count@@ Sub@@ array ( arr , N , K ) ; } }
import java . util . * ; class GF@@ G { static final int dim = 5 ; static void createTable ( int m@@ trx [ ] [ ] , int k , int p , int dp [ ] [ ] ) { dp [ 0 ] [ 0 ] = m@@ trx [ 0 ] [ 0 ] ; for ( int j = 1 ; j < dim ; j ++ ) { dp [ 0 ] [ j ] = m@@ trx [ 0 ] [ j ] + dp [ 0 ] [ j - 1 ] ; } for ( int i = 1 ; i < dim ; i ++ ) { dp [ i ] [ 0 ] = m@@ trx [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] ; } for ( int i = 1 ; i < dim ; i ++ ) { for ( int j = 1 ; j < dim ; j ++ ) { dp [ i ] [ j ] = m@@ trx [ i ] [ j ] + dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] - dp [ i - 1 ] [ j - 1 ] ; } } } static int count@@ Sub@@ Matrix@@ Util ( int dp [ ] [ ] , int k , int p ) { int count = 0 ; int sub@@ Mat@@ Sum = 0 ; for ( int i = k - 1 ; i < dim ; i ++ ) { for ( int j = k - 1 ; j < dim ; j ++ ) { if ( i == ( k - 1 ) || j == ( k - 1 ) ) { if ( i == ( k - 1 ) && j == ( k - 1 ) ) { sub@@ Mat@@ Sum = dp [ i ] [ j ] ; } else if ( i == ( k - 1 ) ) { sub@@ Mat@@ Sum = dp [ i ] [ j ] - dp [ i ] [ j - k ] ; } else { sub@@ Mat@@ Sum = dp [ i ] [ j ] - dp [ i - k ] [ j ] ; } } else { sub@@ Mat@@ Sum = dp [ i ] [ j ] - dp [ i - k ] [ j ] - dp [ i ] [ j - k ] + dp [ i - k ] [ j - k ] ; } if ( sub@@ Mat@@ Sum >= p ) { count ++ ; } } } return count ; } static int count@@ Sub@@ Matrix ( int m@@ trx [ ] [ ] , int k , int p ) { int [ ] [ ] dp = new int [ dim ] [ dim ] ; for ( int i = 0 ; i < dim ; i ++ ) { for ( int j = 0 ; j < dim ; j ++ ) { dp [ i ] [ j ] = 0 ; } } createTable ( m@@ trx , k , p , dp ) ; return count@@ Sub@@ Matrix@@ Util ( dp , k , p ) ; } public static void main ( String [ ] args ) { int m@@ trx [ ] [ ] = { { 1 , 7 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 , 2 } , { 3 , 9 , 6 , 7 , 3 } , { 4 , 3 , 2 , 4 , 5 } , { 5 , 1 , 5 , 3 , 1 } } ; int k = 3 ; int p = 35 ; System . out . print ( count@@ Sub@@ Matrix ( m@@ trx , k , p ) ) ; } }
import java . util . * ; class GF@@ G { static int count@@ W@@ ays ( int n , int m ) { int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { dp [ 1 ] [ i ] = 1 ; if ( i != 0 ) { dp [ 1 ] [ i ] += dp [ 1 ] [ i - 1 ] ; } } for ( int i = 2 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( j == 0 ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } else { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; if ( i == m && j == n ) { return dp [ i ] [ j ] ; } dp [ i ] [ j ] += dp [ i ] [ j - 1 ] ; } } } return Integer . MIN_VALUE ; } public static void main ( String [ ] args ) { int N = 2 , K = 3 ; System . out . print ( count@@ W@@ ays ( N , K ) ) ; } }
import java . util . * ; class GF@@ G { static boolean check ( Vector < Integer > v ) { HashSet < Integer > digits = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { HashSet < Integer > d = new HashSet < Integer > ( ) ; while ( v . get ( i ) > 0 ) { d . add ( v . get ( i ) % 10 ) ; v . set ( i , v . get ( i ) / 10 ) ; } for ( int it : d ) { if ( digits . contains ( it ) ) return false ; } for ( int it : d ) digits . add ( it ) ; } return true ; } static int numberOf@@ Sub@@ arrays ( int a [ ] , int n ) { int answer = 0 ; for ( int i = 1 ; i < ( 1 << n ) ; i ++ ) { Vector < Integer > temp = new Vector < Integer > ( ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( i & ( 1 << j ) ) > 0 ) temp . add ( a [ j ] ) ; } if ( check ( temp ) ) answer ++ ; } return answer ; } public static void main ( String [ ] args ) { int N = 4 ; int A [ ] = { 1 , 12 , 23 , 34 } ; System . out . print ( numberOf@@ Sub@@ arrays ( A , N ) ) ; } }
import java . util . * ; class GF@@ G { static int maximum@@ Occurren@@ ce ( String s ) { int n = s . length ( ) ; HashMap < String , Integer > freq = new HashMap < String , Integer > ( ) ; int i , j ; for ( i = 0 ; i < n ; i ++ ) { String temp = " " ; temp += s . charAt ( i ) ; if ( freq . containsKey ( temp ) ) { freq . put ( temp , freq . get ( temp ) + 1 ) ; } else { freq . put ( temp , 1 ) ; } } for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { String temp = " " ; temp += s . charAt ( i ) ; temp += s . charAt ( j ) ; if ( freq . containsKey ( temp ) ) freq . put ( temp , freq . get ( temp ) + 1 ) ; else freq . put ( temp , 1 ) ; } } int answer = Integer . MIN_VALUE ; for ( int it : freq . values ( ) ) answer = Math . max ( answer , it ) ; return answer ; } public static void main ( String [ ] args ) { String s = " xx@@ xy@@ y " ; System . out . print ( maximum@@ Occurren@@ ce ( s ) ) ; } }
class GF@@ G { static int maxLength ( int [ ] a , int n ) { int maximum = 1 ; int left [ ] = new int [ n ] ; int right [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { left [ i ] = 1 ; right [ i ] = 1 ; } for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( a [ i ] > a [ i + 1 ] ) { right [ i ] = right [ i + 1 ] + 1 ; } maximum = Math . max ( maximum , right [ i ] ) ; } for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] < a [ i - 1 ] ) { left [ i ] = left [ i - 1 ] + 1 ; } } if ( n > 2 ) { for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( a [ i - 1 ] > a [ i + 1 ] ) { maximum = Math . max ( maximum , left [ i - 1 ] + right [ i + 1 ] ) ; } } } return maximum ; } public static void main ( String [ ] args ) { int arr [ ] = { 8 , 7 , 3 , 5 , 2 , 9 } ; int n = arr . length ; System . out . println ( maxLength ( arr , n ) ) ; } }
import java . util . * ; class GF@@ G { static Map < String , Integer > dp = new HashMap < > ( ) ; static Integer solve ( char [ ] s , char c ) { if ( s . length == 1 ) return 0 ; if ( s . length == 2 ) { if ( s [ 0 ] == s [ 1 ] && s [ 0 ] == c ) return 1 ; else return 0 ; } if ( dp . containsKey ( String . valueOf ( s ) + " ▁ " + c ) ) return dp . get ( String . valueOf ( s ) + " ▁ " + c ) ; Integer ans = 0 ; if ( s [ 0 ] == s [ s . length - 1 ] && s [ 0 ] == c ) { for ( char c1 = ' a ' ; c1 <= ' z ' ; c1 ++ ) if ( c1 != c ) ans = Math . max ( ans , 1 + solve ( Arrays . copy@@ Of@@ Range ( s , 1 , s . length - 1 ) , c1 ) ) ; } else { for ( Integer i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == c ) { for ( Integer j = s . length - 1 ; j > i ; j -- ) if ( s [ j ] == c ) { if ( j == i ) break ; ans = solve ( Arrays . copy@@ Of@@ Range ( s , i , j + 1 ) , c ) ; break ; } break ; } } } dp . put ( String . valueOf ( s ) + " ▁ " + c , ans ) ; return dp . get ( String . valueOf ( s ) + " ▁ " + c ) ; } public static void main ( String [ ] args ) { String s = " ab@@ sc@@ rc@@ db@@ a " ; Integer ma = 0 ; for ( char c1 = ' a ' ; c1 <= ' z ' ; c1 ++ ) ma = Math . max ( ma , solve ( s . toCharArray ( ) , c1 ) * 2 ) ; System . out . print ( ma + "@@ NEW_@@ LINE@@ "@@ )@@ ; } }
class GF@@ G { static int max@@ Inc@@ Sub@@ arr ( int a [ ] , int n ) { int pre [ ] = new int [ n ] ; int pos [ ] = new int [ n ] ; pre [ 0 ] = 1 ; pos [ n - 1 ] = 1 ; int l = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] > a [ i - 1 ] ) pre [ i ] = pre [ i - 1 ] + 1 ; else pre [ i ] = 1 ; } l = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( a [ i ] < a [ i + 1 ] ) pos [ i ] = pos [ i + 1 ] + 1 ; else pos [ i ] = 1 ; } int ans = 0 ; l = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] > a [ i - 1 ] ) l ++ ; else l = 1 ; ans = Math . max ( ans , l ) ; } for ( int i = 1 ; i <= n - 2 ; i ++ ) { if ( a [ i - 1 ] < a [ i + 1 ] ) ans = Math . max ( pre [ i - 1 ] + pos [ i + 1 ] , ans ) ; } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 } ; int n = arr . length ; System . out . println ( max@@ Inc@@ Sub@@ arr ( arr , n ) ) ; } }
class GF@@ G { static int max@@ N = 20 ; static int max@@ M = 64 ; static int [ ] [ ] dp = new int [ max@@ N ] [ max@@ M ] ; static boolean [ ] [ ] v = new boolean [ max@@ N ] [ max@@ M ] ; static int find@@ Len ( int [ ] arr , int i , int curr , int n , int m ) { if ( i == n ) { if ( curr == m ) return 0 ; else return - 1 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = true ; int l = find@@ Len ( arr , i + 1 , curr , n , m ) ; int r = find@@ Len ( arr , i + 1 , curr arr [ i ] , n , m ) ; dp [ i ] [ curr ] = l ; if ( r != - 1 ) dp [ i ] [ curr ] = Math . max ( dp [ i ] [ curr ] , r + 1 ) ; return dp [ i ] [ curr ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 7 , 2 , 3 } ; int n = arr . length ; int m = 3 ; int ans = find@@ Len ( arr , 0 , 0 , n , m ) ; if ( ans == - 1 ) System . out . println ( 0 ) ; else System . out . println ( ans ) ; } }
class GF@@ G { static int max@@ N = 20 ; static int max@@ M = 64 ; static int [ ] [ ] dp = new int [ max@@ N ] [ max@@ M ] ; static boolean [ ] [ ] v = new boolean [ max@@ N ] [ max@@ M ] ; static int find@@ Len ( int [ ] arr , int i , int curr , int n , int m ) { if ( i == n ) { if ( curr == 0 ) return 0 ; else return - 1 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = true ; int l = find@@ Len ( arr , i + 1 , curr , n , m ) ; int r = find@@ Len ( arr , i + 1 , ( curr + arr [ i ] ) % m , n , m ) ; dp [ i ] [ curr ] = l ; if ( r != - 1 ) dp [ i ] [ curr ] = Math . max ( dp [ i ] [ curr ] , r + 1 ) ; return dp [ i ] [ curr ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 2 , 2 , 1 } ; int n = arr . length ; int m = 3 ; System . out . println ( find@@ Len ( arr , 0 , 0 , n , m ) ) ; } }
class GF@@ G { static int divi@@ de@@ Array ( int arr [ ] , int n , int k ) { int dp [ ] [ ] = new int [ 500 ] [ 500 ] ; int i , j ; for ( i = 0 ; i < 500 ; i ++ ) for ( j = 0 ; j < 500 ; j ++ ) dp [ i ] [ j ] = 0 ; k -= 1 ; for ( i = n - 1 ; i >= 0 ; i -- ) { for ( j = 0 ; j <= k ; j ++ ) { dp [ i ] [ j ] = Integer . MAX_VALUE ; int max@@ _ = - 1 , sum = 0 ; for ( int l = i ; l < n ; l ++ ) { max@@ _ = Math . max ( max@@ _ , arr [ l ] ) ; sum += arr [ l ] ; int diff = ( l - i + 1 ) * max@@ _ - sum ; if ( j > 0 ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , diff + dp [ l + 1 ] [ j - 1 ] ) ; else dp [ i ] [ j ] = diff ; } } } return dp [ 0 ] [ k ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 9 , 5 , 4 , 8 , 3 , 6 } ; int n = arr . length ; int k = 2 ; System . out . println ( divi@@ de@@ Array ( arr , n , k ) ) ; } }
class GF@@ G { static int max@@ Happ@@ iness ( int A , int N , String [ ] v ) { String str ; int [ ] val = new int [ N ] ; int [ ] wt = new int [ N ] ; int c = 0 ; for ( int i = 0 ; i < N ; i ++ ) { str = v [ i ] ; c = 0 ; for ( int j = 0 ; j < str . length ( ) ; j ++ ) { if ( str . charAt ( j ) == ' c ' ) c += 4 ; else if ( str . charAt ( j ) == ' w ' ) c += 3 ; else if ( str . charAt ( j ) == ' m ' ) c += 2 ; else c ++ ; } c *= str . length ( ) ; val [ i ] = c ; wt [ i ] = str . length ( ) ; } int [ ] [ ] k = new int [ N + 1 ] [ A + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) { for ( int w = 0 ; w <= A ; w ++ ) { if ( i == 0 w == 0 ) k [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) { k [ i ] [ w ] = Math . max ( val [ i - 1 ] + k [ i - 1 ] [ w - wt [ i - 1 ] ] , k [ i - 1 ] [ w ] ) ; } else { k [ i ] [ w ] = k [ i - 1 ] [ w ] ; } } } return k [ N ] [ A ] ; } public static void main ( String [ ] args ) { int A = 5 ; String [ ] v = { " mmo " , " oo " , " cm@@ w " , " cc " , " c " } ; int N = v . length ; System . out . println ( max@@ Happ@@ iness ( A , N , v ) ) ; } }
class GF@@ G { static int N = 10000@@ 5 ; static int LI@@ S ( int a [ ] , int n ) { int dp [ ] = new int [ N ] , d [ ] = new int [ N ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { dp [ a [ i ] ] = 1 ; for ( int j = 2 ; j * j <= a [ i ] ; j ++ ) { if ( a [ i ] % j == 0 ) { dp [ a [ i ] ] = Math . max ( dp [ a [ i ] ] , dp [ d [ j ] ] + 1 ) ; dp [ a [ i ] ] = Math . max ( dp [ a [ i ] ] , dp [ d [ a [ i ] / j ] ] + 1 ) ; d [ j ] = a [ i ] ; d [ a [ i ] / j ] = a [ i ] ; } } ans = Math . max ( ans , dp [ a [ i ] ] ) ; d [ a [ i ] ] = a [ i ] ; } return ans ; } public static void main ( String args [ ] ) { int a [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = a . length ; System . out . print ( LI@@ S ( a , n ) ) ; } }
import java . lang . Math ; class Gf@@ G { static boolean check@@ Combin@@ ations ( int a [ ] , int n ) { int pow_@@ set_size = ( int ) Math . pow ( 2 , n ) ; int counter , j ; for ( counter = 0 ; counter < pow_@@ set_size ; counter ++ ) { int sum = 0 ; for ( j = 0 ; j < n ; j ++ ) { if ( ( counter & ( 1 << j ) ) != 0 ) else } if ( sum % ( 24 * 60 ) == 0 ) return true ; } return false ; } public static void main ( String [ ] args ) { int a [ ] = { 60 , 60 , 120 } ; int n = a . length ; if ( check@@ Combin@@ ations ( a , n ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
import java . util . * ; class GF@@ G { static int GC@@ D ( int a , int b ) { if ( b == 0 ) return a ; return GC@@ D ( b , a % b ) ; } static void make@@ Pairs ( Vector < Integer > pairs , int a , int b ) { for ( int i = a ; i <= b ; i ++ ) { int sum@@ Of@@ Digits = 0 , k = i ; while ( k > 0 ) { sum@@ Of@@ Digits += k % 10 ; k /= 10 ; } if ( sum@@ Of@@ Digits <= 162 ) pairs . add ( sum@@ Of@@ Digits ) ; } } static int count@@ Co@@ Prime ( int a , int b ) { Vector < Integer > pairs = new Vector < Integer > ( ) ; make@@ Pairs ( pairs , a , b ) ; int count = 0 ; for ( int i = 0 ; i < pairs . size ( ) ; i ++ ) for ( int j = i + 1 ; j < pairs . size ( ) ; j ++ ) if ( GC@@ D ( pairs . get ( i ) , pairs . get ( j ) ) == 1 ) count ++ ; return count ; } public static void main ( String args [ ] ) { int a = 12 , b = 15 ; System . out . println ( count@@ Co@@ Prime ( a , b ) ) ; } }
import java . util . Arrays ; class GF@@ G { static int MAX = 100 ; static int dp [ ] [ ] = new int [ MAX ] [ MAX ] ; static int count@@ Remo@@ vals ( int a [ ] , int i , int j , int k ) { if ( i >= j ) return 0 ; else if ( ( a [ j ] - a [ i ] ) <= k ) return 0 ; else if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ; else if ( ( a [ j ] - a [ i ] ) > k ) { dp [ i ] [ j ] = 1 + Math . min ( count@@ Remo@@ vals ( a , i + 1 , j , k ) , count@@ Remo@@ vals ( a , i , j - 1 , k ) ) ; } return dp [ i ] [ j ] ; } static int remo@@ vals ( int a [ ] , int n , int k ) { Arrays . sort ( a ) ; for ( int [ ] rows : dp ) Arrays . fill ( rows , - 1 ) ; if ( n == 1 ) return 0 ; else return count@@ Remo@@ vals ( a , 0 , n - 1 , k ) ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 3 , 4 , 9 , 10 , 11 , 12 , 17 , 20 } ; int n = a . length ; int k = 4 ; System . out . print ( remo@@ vals ( a , n , k ) ) ; } }
import java . lang . * ; import java . util . * ; public class Gf@@ G { public static int find@@ Step ( int n ) { if ( n == 1 n == 0 ) return 1 ; else if ( n == 2 ) return 2 ; else return find@@ Step ( n - 3 ) + find@@ Step ( n - 2 ) + find@@ Step ( n - 1 ) ; } public static void main ( String argc [ ] ) { int n = 4 ; System . out . println ( find@@ Step ( n ) ) ; } }
import java . util . * ; import java . lang . * ; public class Gf@@ G { public static int de@@ al@@ n@@ no@@ y ( int n , int m ) { if ( m == 0 n == 0 ) return 1 ; return de@@ al@@ n@@ no@@ y ( m - 1 , n ) + de@@ al@@ n@@ no@@ y ( m - 1 , n - 1 ) + de@@ al@@ n@@ no@@ y ( m , n - 1 ) ; } public static void main ( String args [ ] ) { int n = 3 , m = 4 ; System . out . println ( de@@ al@@ n@@ no@@ y ( n , m ) ) ; } }
import java . util . Arrays ; class GF@@ G { static final int MAX = 100 ; static boolean all@@ ones ( String s , int n ) { int co = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( s . charAt ( i ) == '1' ) co += 1 ; return ( co == n ) ; } static int find@@ length ( int arr [ ] , String s , int n , int ind , int st , int dp [ ] [ ] ) { if ( ind >= n ) return 0 ; if ( dp [ ind ] [ st ] != - 1 ) return dp [ ind ] [ st ] ; if ( st == 0 ) return dp [ ind ] [ st ] = Math . max ( arr [ ind ] + find@@ length ( arr , s , n , ind + 1 , 1 , dp ) , find@@ length ( arr , s , n , ind + 1 , 0 , dp ) ) ; else return dp [ ind ] [ st ] = Math . max ( arr [ ind ] + find@@ length ( arr , s , n , ind + 1 , 1 , dp ) , 0 ) ; } static int maxLen ( String s , int n ) { if ( all@@ ones ( s , n ) ) return - 1 ; int arr [ ] = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = ( s . charAt ( i ) == '0' ? 1 : - 1 ) ; int dp [ ] [ ] = new int [ MAX ] [ 3 ] ; for ( int [ ] row : dp ) Arrays . fill ( row , - 1 ) ; return find@@ length ( arr , s , n , 0 , 0 , dp ) ; } public static void main ( String [ ] args ) { String s = "11@@ 0000@@ 100@@ 01" ; int n = 11 ; System . out . println ( maxLen ( s , n ) ) ; } }
class GF@@ G { static boolean is@@ Safe ( int x , int y ) { return ( x < 4 && y < 3 ) ; } static int min@@ Jump ( int height [ ] [ ] , int x , int y ) { if ( x == 4 - 1 && y == 3 - 1 ) return 0 ; int diag = Integer . MAX_VALUE ; if ( is@@ Safe ( x + 1 , y + 1 ) ) diag = min@@ Jump ( height , x + 1 , y + 1 ) + Math . abs ( height [ x ] [ y ] - height [ x + 1 ] [ y + 1 ] ) ; int down = Integer . MAX_VALUE ; if ( is@@ Safe ( x + 1 , y ) ) down = min@@ Jump ( height , x + 1 , y ) + Math . abs ( height [ x ] [ y ] - height [ x + 1 ] [ y ] ) ; int right = Integer . MAX_VALUE ; if ( is@@ Safe ( x , y + 1 ) ) right = min@@ Jump ( height , x , y + 1 ) + Math . abs ( height [ x ] [ y ] - height [ x ] [ y + 1 ] ) ; return Math . min ( down , Math . min ( right , diag ) ) ; } public static void main ( String [ ] args ) { int height [ ] [ ] = { { 5 , 4 , 2 } , { 9 , 2 , 1 } , { 2 , 5 , 9 } , { 1 , 3 , 11 } } ; System . out . println ( min@@ Jump ( height , 0 , 0 ) ) ; } }
public class GF@@ G { static long count@@ W@@ ays ( int n ) { long dp [ ] [ ] = new long [ 2 ] [ n + 1 ] ; dp [ 0 ] [ 1 ] = 1 ; dp [ 1 ] [ 1 ] = 2 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] ; dp [ 1 ] [ i ] = dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] ; } return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . print ( " Total ▁ no ▁ of ▁ ways ▁ with ▁ n ▁ = ▁ " + n + " ▁ are : ▁ " + count@@ W@@ ays ( n ) ) ; } }
import java . util . Arrays ; class GF@@ G { static void count@@ Way@@ sTo@@ Jump ( int arr [ ] , int n ) { int count_@@ jump [ ] = new int [ n ] ; Arrays . fill ( count_@@ jump , 0 ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] >= n - i - 1 ) count_@@ jump [ i ] ++ ; for ( int j = i + 1 ; j < n - 1 && j <= arr [ i ] + i ; j ++ ) if ( count_@@ jump [ j ] != - 1 ) count_@@ jump [ i ] += count_@@ jump [ j ] ; if ( count_@@ jump [ i ] == 0 ) count_@@ jump [ i ] = - 1 ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( count_@@ jump [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 5 , 8 , 9 , 1 , 0 , 7 , 6 , 8 , 9 } ; int n = arr . length ; count@@ Way@@ sTo@@ Jump ( arr , n ) ; } }
class GF@@ G { static final int N = 4 ; static int max@@ Decimal@@ Value ( int mat [ ] [ ] , int i , int j , int p ) { if ( i >= N j >= N ) { return 0 ; } int result = Math . max ( max@@ Decimal@@ Value ( mat , i , j + 1 , p + 1 ) , max@@ Decimal@@ Value ( mat , i + 1 , j , p + 1 ) ) ; if ( mat [ i ] [ j ] == 1 ) { return ( int ) ( Math . pow ( 2 , p ) + result ) ; } else { return result ; } } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 1 , 0 , 1 } , { 0 , 1 , 1 , 0 } , { 1 , 0 , 0 , 1 } , { 1 , 0 , 1 , 1 } , } ; System . out . println ( max@@ Decimal@@ Value ( mat , 0 , 0 , 0 ) ) ; } }
public class GF@@ G { final static int N = 4 ; static int Maximum@@ Decimal@@ Value ( int mat [ ] [ ] , int n ) { int dp [ ] [ ] = new int [ n ] [ n ] ; if ( mat [ 0 ] [ 0 ] == 1 ) { } for ( int i = 1 ; i < n ; i ++ ) { if ( mat [ 0 ] [ i ] == 1 ) { dp [ 0 ] [ i ] = ( int ) ( dp [ 0 ] [ i - 1 ] + Math . pow ( 2 , i ) ) ; else { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] ; } } for ( int i = 1 ; i < n ; i ++ ) { if ( mat [ i ] [ 0 ] == 1 ) { dp [ i ] [ 0 ] = ( int ) ( dp [ i - 1 ] [ 0 ] + Math . pow ( 2 , i ) ) ; else { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ; } } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) { dp [ i ] [ j ] = ( int ) ( Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + Math . pow ( 2 , i + j ) ) ; } else { dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; } } } return dp [ n - 1 ] [ n - 1 ] ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 1 , 0 , 1 } , { 0 , 1 , 1 , 0 } , { 1 , 0 , 0 , 1 } , { 1 , 0 , 1 , 1 } , } ; System . out . println ( Maximum@@ Decimal@@ Value ( mat , 4 ) ) ; } }
import java . io . * ; import java . util . * ; class GF@@ G { static int max@@ Sum@@ Pair@@ With@@ Difference@@ LessThan@@ K ( int arr [ ] , int N , int K ) { Arrays . sort ( arr ) ; int dp [ ] = new int [ N ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i < N ; i ++ ) { dp [ i ] = dp [ i - 1 ] ; if ( arr [ i ] - arr [ i - 1 ] < K ) { if ( i >= 2 ) dp [ i ] = Math . max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ) ; else dp [ i ] = Math . max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] ) ; } } return dp [ N - 1 ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 5 , 10 , 15 , 17 , 12 , 9 } ; int N = arr . length ; int K = 4 ; System . out . println ( max@@ Sum@@ Pair@@ With@@ Difference@@ LessThan@@ K ( arr , N , K ) ) ; } }
class GF@@ G { static int max@@ Sum@@ IS ( int arr [ ] , int n ) { int i , j , max = 0 ; int m@@ sis [ ] = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) m@@ sis [ i ] = arr [ i ] ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && m@@ sis [ i ] < m@@ sis [ j ] + arr [ i ] ) m@@ sis [ i ] = m@@ sis [ j ] + arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( max < m@@ sis [ i ] ) max = m@@ sis [ i ] ; return max ; } public static void main ( String args [ ] ) { int arr [ ] = new int [ ] { 1 , 101 , 2 , 3 , 100 , 4 , 5 } ; int n = arr . length ; System . out . println ( " Sum ▁ of ▁ maximum ▁ sum ▁ " + " increasing ▁ sub@@ sequence ▁ is ▁ " + max@@ Sum@@ IS ( arr , n ) ) ; } }
class Matrix@@ Chain@@ Multiplic@@ ation { static int Matrix@@ Chain@@ Order ( int p [ ] , int i , int j ) { if ( i == j ) return 0 ; int min = Integer . MAX_VALUE ; for ( int k = i ; k < j ; k ++ ) { int count = Matrix@@ Chain@@ Order ( p , i , k ) + Matrix@@ Chain@@ Order ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( count < min ) min = count ; } return min ; } public static void main ( String args [ ] ) { int arr [ ] = new int [ ] { 1 , 2 , 3 , 4 , 3 } ; int n = arr . length ; System . out . println ( " Minimum ▁ number ▁ of ▁ multiplic@@ ations ▁ is ▁ " + Matrix@@ Chain@@ Order ( arr , 1 , n - 1 ) ) ; } }
import java . io . * ; class GF@@ G { static void encode@@ String ( String str ) { String res = " " ; int small [ ] = new int [ 26 ] ; int capital [ ] = new int [ 26 ] ; int num [ ] = new int [ 10 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { small [ i ] = 0 ; capital [ i ] = 0 ; } for ( int i = 0 ; i < 10 ; i ++ ) { num [ i ] = 0 ; } int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) >= '0' && str . charAt ( i ) <= '9' ) { num [ str . charAt ( i ) - 48 ] = i ; } else if ( str . charAt ( i ) >= ' a ' && str . charAt ( i ) <= ' z ' ) { small [ str . charAt ( i ) - 97 ] = i ; } else if ( str . charAt ( i ) >= ' A ' && str . charAt ( i ) <= ' Z ' ) { capital [ str . charAt ( i ) - 65 ] = i ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( ( str . charAt ( i ) >= ' a ' && str . charAt ( i ) <= ' z ' ) && small [ str . charAt ( i ) - 97 ] == i ) { int oc@@ c = str . charAt ( i ) - 96 ; while ( oc@@ c -- > 0 ) { res += str . charAt ( i ) ; } } else if ( ( str . charAt ( i ) >= ' A ' && str . charAt ( i ) <= ' Z ' ) && capital [ str . charAt ( i ) - 65 ] == i ) { int oc@@ c = str . charAt ( i ) - 64 ; while ( oc@@ c -- > 0 ) { res = res + str . charAt ( i ) ; } } else if ( ( str . charAt ( i ) >= '0' && str . charAt ( i ) <= '9' ) && num [ str . charAt ( i ) - 48 ] == i ) { int oc@@ c = str . charAt ( i ) - 48 ; while ( oc@@ c -- > 0 ) { res = res + str . charAt ( i ) ; } } else { res = res + str . charAt ( i ) ; } } System . out . print ( res ) ; } public static void main ( String [ ] args ) { String str = " E@@ a2 , ▁ 0 , ▁ E " ; encode@@ String ( str ) ; } }
import java . io . * ; class GF@@ G { public static void create@@ Grid ( char [ ] [ ] grid , boolean is@@ 1 , int N , int M ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( is@@ 1 ) { grid [ i ] [ j ] = '0' ; is@@ 1 = false ; } else { grid [ i ] [ j ] = '1' ; is@@ 1 = true ; } } if ( M % 2 == 0 ) is@@ 1 = ! is@@ 1 ; } } public static boolean test@@ Grid ( char [ ] [ ] test@@ Grid , char [ ] [ ] Grid , int N , int M ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( Grid [ i ] [ j ] != ' * ' ) { if ( Grid [ i ] [ j ] != test@@ Grid [ i ] [ j ] ) { return false ; } } } } return true ; } public static void print@@ Grid ( char [ ] [ ] grid , int N , int M ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { System . out . print ( grid [ i ] [ j ] + " ▁ " ) ; } System . out . println ( ) ; } } public static void find@@ Possible@@ Grid ( int N , int M , char [ ] [ ] grid ) { char [ ] [ ] grid@@ Test1 = new char [ N ] [ 1001 ] ; char [ ] [ ] grid@@ Test2 = new char [ N ] [ 1001 ] ; create@@ Grid ( grid@@ Test1 , true , N , M ) ; create@@ Grid ( grid@@ Test2 , false , N , M ) ; if ( test@@ Grid ( grid@@ Test1 , grid , N , M ) ) { System . out . println ( " Yes " ) ; print@@ Grid ( grid@@ Test1 , N , M ) ; } else if ( test@@ Grid ( grid@@ Test2 , grid , N , M ) ) { System . out . println ( " Yes " ) ; print@@ Grid ( grid@@ Test2 , N , M ) ; } else { System . out . println ( " No " ) ; } } public static void main ( String [ ] args ) { int N = 4 , M = 4 ; char [ ] [ ] grid = { { ' * ' , ' * ' , '1' , '0' } , { ' * ' , ' * ' , ' * ' , ' * ' } , { ' * ' , ' * ' , ' * ' , ' * ' } , { ' * ' , ' * ' , '0' , '1' } } ; find@@ Possible@@ Grid ( N , M , grid ) ; } }
import java . io . * ; import java . util . * ; class GF@@ G { static int find@@ Min@@ Moves ( int [ ] arr , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; if ( sum % N != 0 ) return - 1 ; int avg = sum / N ; int total = 0 ; int need@@ Count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { need@@ Count += ( arr [ i ] - avg ) ; total = Math . max ( Math . max ( Math . abs ( need@@ Count ) , arr [ i ] - avg ) , total ) ; } return total ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 0 , 5 } ; int N = arr . length ; System . out . println ( find@@ Min@@ Moves ( arr , N ) ) ; } }
import java . util . * ; class GF@@ G { static void getZ@@ arr ( String str , int Z [ ] ) { int n = str . length ( ) ; int k ; int L = 0 ; int R = 0 ; for ( int i = 1 ; i < n ; ++ i ) { if ( i > R ) { L = R = i ; while ( R < n && str . charAt ( R - L ) == str . charAt ( R ) ) { R ++ ; } Z [ i ] = R - L ; R -- ; } else { k = i - L ; if ( Z [ k ] < R - i + 1 ) { Z [ i ] = Z [ k ] ; } else { L = i ; while ( R < n && str . charAt ( R - L ) == str . charAt ( R ) ) { R ++ ; } Z [ i ] = R - L ; R -- ; } } } } static String good@@ Str ( String str , String word ) { String concat = word + " $ " + str ; int l = concat . length ( ) ; int [ ] Z = new int [ l ] ; getZ@@ arr ( concat , Z ) ; String res = " " ; int p@@ Size = word . length ( ) ; for ( int i = 0 ; i < l ; ++ i ) { if ( i + p@@ Size < l - 1 && Z [ i + p@@ Size + 1 ] == p@@ Size ) { i += p@@ Size - 1 ; } else if ( i < str . length ( ) ) { res += str . charAt ( i ) ; } } return res ; } public static void main ( String [ ] args ) { String str = " Z - k@@ mal@@ gorith@@ mk@@ mis@@ k@@ mk@@ mk@@ m@@ help@@ ful@@ k@@ min@@ km@@ searching " ; String word = " km " ; System . out . print ( good@@ Str ( str , word ) ) ; } }
import java . io . * ; class GF@@ G { static void sum@@ Of@@ Sub@@ array@@ Prod ( int arr [ ] , int n ) { int ans = 0 ; int res = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int incr = arr [ i ] * ( 1 + res ) ; ans += incr ; res = incr ; } System . out . println ( ans ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 } ; int N = arr . length ; sum@@ Of@@ Sub@@ array@@ Prod ( arr , N ) ; } }
import java . util . * ; class GF@@ G { static int phi ( int n ) { int result = 1 ; for ( int p = 2 ; p < n ; p ++ ) { if ( __@@ gcd ( p , n ) == 1 ) { result ++ ; } } return result ; } static boolean same@@ Euler@@ To@@ ti@@ ent ( int n ) { return phi ( n ) == phi ( 2 * n ) ; } static int __@@ gcd ( int a , int b ) { return b == 0 ? a : __@@ gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { int N = 13 ; if ( same@@ Euler@@ To@@ ti@@ ent ( N ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
class GF@@ G { static int print@@ O@@ dd@@ Factor@@ Number ( int n , int m ) { for ( int i = n ; i <= m ; i ++ ) { if ( ( i > 0 ) && ( ( i & ( i - 1 ) ) != 0 ) ) System . out . print ( i + " ▁ " ) ; } return 0 ; } public static void main ( String [ ] args ) { int N = 2 , M = 10 ; print@@ O@@ dd@@ Factor@@ Number ( N , M ) ; } }
class GF@@ G { static void print@@ Series ( int n ) { int k = 2 ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( k * ( 2 * k - 1 ) + " ▁ " ) ; k += 2 ; } System . out . println ( ) ; } public static void main ( String args [ ] ) { int N = 12 ; print@@ Series ( N ) ; } }
import java . util . * ; class GF@@ G { static void print@@ Sin@@ X ( int N ) { int Xi = 0 ; int num = 1 ; while ( N -- > 0 ) { System . out . print ( " X " + num + " ▁ = ▁ " + Xi ) ; System . out . print ( " ▁ sin ( X " + num + " ) ▁ = ▁ " ) ; System . out . printf ( " % .@@ 6f " , Math . sin ( Xi ) ) ; System . out . println ( ) ; num += 1 ; Xi += 7@@ 10 ; } } public static void main ( String [ ] args ) { int N = 5 ; print@@ Sin@@ X ( N ) ; } }
import java . util . * ; class GF@@ G { static void sum@@ Between@@ Zero ( int arr [ ] , int N ) { int i = 0 ; Vector < Integer > A = new Vector < Integer > ( ) ; int sum = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) { i ++ ; break ; } } for ( ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) { A . add ( sum ) ; sum = 0 ; } else { sum += arr [ i ] ; } } for ( int j = 0 ; j < A . size ( ) ; j ++ ) { System . out . print ( A . get ( j ) + " ▁ " ) ; } if ( A . size ( ) == 0 ) System . out . print ( " - 1" ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 0 , 3 , 4 , 0 , 4 , 4 , 0 , 2 , 1 , 4 , 0 , 3 } ; int N = arr . length ; sum@@ Between@@ Zero ( arr , N ) ; } }
import java . util . * ; class GF@@ G { static int count@@ Characters ( List < String > strings , String chars ) { int res = 0 ; Map < Character , Integer > freq = new HashMap < > ( ) ; for ( int i = 0 ; i < chars . length ( ) ; i ++ ) { freq . put ( chars . charAt ( i ) , freq . getOr@@ Default ( chars . charAt ( i ) , 0 ) + 1 ) ; } for ( String st : strings ) { boolean flag = true ; for ( char c : st . toCharArray ( ) ) { if ( ! freq . containsKey ( c ) ) { flag = false ; break ; } } if ( flag ) res += st . length ( ) ; } return res ; } public static void main ( String [ ] args ) { List < String > strings = Arrays . asList ( " hi " , " data " , " ge@@ ek@@ s@@ forge@@ e@@ ks " ) ; String chars = " ti@@ ad@@ h@@ ae " ; System . out . println ( count@@ Characters ( strings , chars ) ) ; } }
class GF@@ G { static void find@@ Numbers ( int n ) { int i = 1 ; while ( i <= n ) { System . out . print ( ( 3 * i * ( i - 1 ) + 1 ) + " ▁ " ) ; i ++ ; } } public static void main ( String [ ] args ) { int n = 4 ; find@@ Numbers ( n ) ; } }
class GF@@ G { static int getEnd@@ ing@@ Index ( String str , int n , int i ) { i ++ ; while ( i < n ) { char curr = str . charAt ( i ) ; char prev = str . charAt ( i - 1 ) ; if ( ( curr == ' a ' && prev == ' z ' ) || ( curr - prev == 1 ) ) i ++ ; else break ; } return i - 1 ; } static int lar@@ gest@@ Sub@@ Str ( String str , int n ) { int len = 0 ; int i = 0 ; while ( i < n ) { int end = getEnd@@ ing@@ Index ( str , n , i ) ; len = Math . max ( end - i + 1 , len ) ; i = end + 1 ; } return len ; } public static void main ( String args [ ] ) { String str = " abc@@ abcde@@ fab@@ c " ; int n = str . length ( ) ; System . out . print ( lar@@ gest@@ Sub@@ Str ( str , n ) ) ; } }
import java . util . HashMap ; class GF@@ G { static String smalle@@ st@@ Freq ( String S1 , String S2 ) { HashMap < String , Integer > banned = new HashMap < > ( ) ; for ( int i = 0 ; i < S2 . length ( ) ; i ++ ) { String s = " " ; while ( i < S2 . length ( ) && S2 . charAt ( i ) != ' ▁ ' ) s += S2 . charAt ( i ++ ) ; banned . put ( s , banned . get ( s ) == null ? 1 : banned . get ( s ) + 1 ) ; } HashMap < String , Integer > result = new HashMap < > ( ) ; String ans = " " ; int freq = 0 ; for ( int i = 0 ; i < S1 . length ( ) ; i ++ ) { String s = " " ; while ( i < S1 . length ( ) && S1 . charAt ( i ) != ' ▁ ' ) s += S1 . charAt ( i ++ ) ; if ( banned . get ( s ) == null ) { result . put ( s , result . get ( s ) == null ? 1 : result . get ( s ) + 1 ) ; if ( result . get ( s ) > freq || ( result . get ( s ) == freq && s . compareTo ( ans ) < 0 ) ) { ans = s ; freq = result . get ( s ) ; } } } return ans ; } public static void main ( String [ ] args ) { String S1 = " ge@@ e@@ ks ▁ for ▁ ge@@ e@@ ks ▁ is ▁ best ▁ place ▁ to ▁ learn " ; String S2 = " bad ▁ place " ; System . out . println ( smalle@@ st@@ Freq ( S1 , S2 ) ) ; } }
class GF@@ G { static int isSub@@ string ( String s1 , String s2 ) { int M = s1 . length ( ) ; int N = s2 . length ( ) ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( s2 . charAt ( i + j ) != s1 . charAt ( j ) ) break ; if ( j == M ) return i ; } return - 1 ; } public static void main ( String args [ ] ) { String s1 = " for " ; String s2 = " ge@@ ek@@ s@@ forge@@ e@@ ks " ; int res = isSub@@ string ( s1 , s2 ) ; if ( res == - 1 ) System . out . println ( " Not ▁ present " ) ; else System . out . println ( " Present ▁ at ▁ index ▁ " + res ) ; } }
import java . io . * ; class GF@@ G { static int pattern@@ Count ( String str ) { char last = str . charAt ( 0 ) ; int i = 1 , counter = 0 ; while ( i < str . length ( ) ) { if ( str . charAt ( i ) == '0' && last == '1' ) { while ( str . charAt ( i ) == '0' ) i ++ ; if ( str . charAt ( i ) == '1' ) counter ++ ; } last = str . charAt ( i ) ; i ++ ; } return counter ; } public static void main ( String [ ] args ) { String str = "100@@ 1@@ ab@@ 01@@ 0@@ abc@@ 0100@@ 1" ; System . out . println ( pattern@@ Count ( str ) ) ; } }
import java . io . * ; import java . util . * ; public class index { static int max = 0 ; static String ans@@ 1 = " " ; static void calculate ( String ans ) { int dp [ ] = new int [ 26 ] ; for ( int i = 0 ; i < ans . length ( ) ; ++ i ) { dp [ ans . charAt ( i ) - ' A ' ] ++ ; } for ( int i = 0 ; i < dp . length ; ++ i ) { if ( dp [ i ] % 2 == 1 ) { return ; } } if ( max < ans . length ( ) ) { max = ans . length ( ) ; ans@@ 1 = ans ; } } static void lon@@ gest@@ String ( List < String > arr , int index , String str ) { if ( index == arr . size ( ) ) { return ; } lon@@ gest@@ String ( arr , index + 1 , str ) ; str += arr . get ( index ) ; calculate ( str ) ; lon@@ gest@@ String ( arr , index + 1 , str ) ; } public static void main ( String [ ] args ) { ArrayList < String > A = new ArrayList < > ( ) ; A . add ( " AB@@ AB " ) ; A . add ( " AB@@ F " ) ; A . add ( " CD@@ A " ) ; A . add ( " AD " ) ; A . add ( " CC@@ C " ) ; lon@@ gest@@ String ( A , 0 , " " ) ; System . out . println ( ans@@ 1 + " ▁ " + ans@@ 1 . length ( ) ) ; } }
class GF@@ G { static void find@@ Sub@@ sequence ( String str ) { int n = str . length ( ) ; char [ ] res = new char [ n ] ; for ( int i = 0 ; i < n ; i ++ ) res [ i ] = 0 ; for ( int pos = 0 ; pos <= 9 ; pos ++ ) { char lst@@ 1 = '0' ; boolean flag = true ; char lst@@ 2 = ( char ) ( pos + '0' ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( lst@@ 2 <= str . charAt ( i ) ) { res [ i ] = '2' ; lst@@ 2 = str . charAt ( i ) ; } else if ( lst@@ 1 <= str . charAt ( i ) ) { res [ i ] = '1' ; lst@@ 1 = str . charAt ( i ) ; } else flag = false ; } if ( lst@@ 1 > pos + '0' ) flag = false ; if ( flag ) { String S1 = " " ; String S2 = " " ; for ( int i = 0 ; i < n ; i ++ ) { if ( res [ i ] == '1' ) { S1 += str . charAt ( i ) ; } else { S2 += str . charAt ( i ) ; } } System . out . print ( S1 + " ▁ " + S2 + "@@ NEW_@@ LINE@@ "@@ )@@ ; return ; } } System . out . print ( " - 1" ) ; } public static void main ( String [ ] args ) { String S = "@@ 04@@ 04@@ 255@@ 24@@ 64@@ 4" ; find@@ Sub@@ sequence ( S ) ; S = "123456789@@ " ; find@@ Sub@@ sequence ( S ) ; } }
import java . util . * ; class GF@@ G { static String ans , s ; static int K ; static void getString ( int cur@@ len , int N , int [ ] prod ) { if ( cur@@ len == N ) { K -- ; if ( K == 0 ) ans = s ; return ; } char ch ; int ok , t , i ; for ( ch = '2' ; ch <= '9' ; ch ++ ) { s += ch ; ok = 1 ; t = 1 ; for ( i = cur@@ len ; i >= 0 && s . length ( ) > i ; i -- ) { t *= s . charAt ( i ) - 48 ; if ( prod [ t ] != 0 ) ok = 0 ; prod [ t ] ++ ; } if ( ok != 0 ) getString ( cur@@ len + 1 , N , prod ) ; t = 1 ; for ( i = cur@@ len ; i >= 0 && s . length ( ) > i ; i -- ) { t *= s . charAt ( i ) - 48 ; prod [ t ] -- ; } if ( s . length ( ) > 0 ) s = s . substring ( 0 , s . length ( ) - 1 ) ; } } static String k@@ th@@ Valid@@ String ( int N ) { if ( N > 10 ) { return " - 1" ; } if ( N == 1 ) { if ( K > 10 ) { return " - 1" ; } String s = " " ; K -- ; s += ( K + '0' ) ; return s ; } ans = " - 1" ; s = " " ; int [ ] prod = new int [ 100@@ 05 ] ; getString ( 0 , N , prod ) ; return ans ; } public static void main ( String [ ] args ) { int N = 3 ; K = 4 ; System . out . print ( k@@ th@@ Valid@@ String ( N ) ) ; } }
public class GF@@ G { static String check@@ If@@ Possible ( int N , String [ ] arr , String T ) { int [ ] freq@@ S = new int [ 256 ] ; int [ ] freq@@ T = new int [ 256 ] ; for ( char ch : T . toCharArray ( ) ) { freq@@ T [ ch - ' a ' ] ++ ; } for ( int i = 0 ; i < N ; i ++ ) { for ( char ch : arr [ i ] . toCharArray ( ) ) { freq@@ S [ ch - ' a ' ] ++ ; } } for ( int i = 0 ; i < 256 ; i ++ ) { if ( freq@@ T [ i ] == 0 && freq@@ S [ i ] != 0 ) { return " No " ; } else if ( freq@@ S [ i ] == 0 && freq@@ T [ i ] != 0 ) { return " No " ; } else if ( freq@@ T [ i ] != 0 && freq@@ S [ i ] != ( freq@@ T [ i ] * N ) ) { return " No " ; } } return " Yes " ; } public static void main ( String [ ] args ) { String [ ] arr = { " abc " , " abb " , " acc " } ; String T = " abc " ; int N = arr . length ; System . out . println ( check@@ If@@ Possible ( N , arr , T ) ) ; } }
import java . util . Stack ; class GF@@ G { static int group@@ sOf@@ Ones ( String S , int N ) { int count = 0 ; Stack < Integer > st = new Stack < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( S . charAt ( i ) == '1' ) st . push ( 1 ) ; else { if ( ! st . empty ( ) ) { count ++ ; while ( ! st . empty ( ) ) { st . pop ( ) ; } } } } if ( ! st . empty ( ) ) count ++ ; return count ; } public static void main ( String [ ] args ) { String S = "100@@ 1101@@ 11" ; int N = S . length ( ) ; System . out . println ( group@@ sOf@@ Ones ( S , N ) ) ; } }
import java . io . * ; import java . lang . * ; import java . util . * ; class GF@@ G { static void find@@ Minimum@@ Cost ( String s , int N ) { int count_@@ 1 = 0 , count_@@ 0 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( s . charAt ( i ) == '1' ) count_@@ 1 ++ ; else count_@@ 0 ++ ; } int k = Math . abs ( count_@@ 0 - count_@@ 1 ) ; if ( count_@@ 1 == N count_@@ 0 == N ) System . out . println ( - 1 ) ; else System . out . println ( k / 2 ) ; } public static void main ( String [ ] args ) { String S = "11@@ 01@@ 10" ; int N = S . length ( ) ; find@@ Minimum@@ Cost ( S , N ) ; } }
import java . io . * ; import java . lang . * ; import java . util . * ; public class GF@@ G { static int minLength ( String S ) { Stack < Character > st = new Stack < > ( ) ; for ( char ch : S . toCharArray ( ) ) { if ( st . isEmpty ( ) ) st . push ( ch ) ; else { char top = st . peek ( ) ; if ( Math . abs ( ch - top ) == 1 ) st . pop ( ) ; else { st . push ( ch ) ; } } } return st . size ( ) ; } public static void main ( String [ ] args ) { String S = "12@@ 213@@ " ; System . out . println ( minLength ( S ) ) ; } }
import java . util . * ; class GF@@ G { static int minimum@@ Dele@@ tions ( String s ) { int right_@@ 0 = ( int ) ( s . chars ( ) . filter ( ch -> ch == '0' ) . count ( ) ) ; int left_@@ 1 = 0 ; int n = s . length ( ) ; int res = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '0' ) { right_@@ 0 -= 1 ; } else { left_@@ 1 += 1 ; } res = Math . min ( res , right_@@ 0 + left_@@ 1 ) ; } return res ; } public static void main ( String [ ] args ) { String s = "00@@ 11@@ 01" ; int count = minimum@@ Dele@@ tions ( s ) ; System . out . print ( count ) ; } }
import java . io . * ; class GF@@ G { static void cnt@@ Bal@@ anced@@ Parenthe@@ sis ( String s , int N ) { int cnt@@ Pairs = 0 ; int cnt@@ Cur@@ ly = 0 ; int cnt@@ S@@ ml = 0 ; int cnt@@ Sqr = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( s . charAt ( i ) == ' { ' ) { cnt@@ Cur@@ ly ++ ; } else if ( s . charAt ( i ) == ' ( ' ) { cnt@@ S@@ ml ++ ; } else if ( s . charAt ( i ) == ' [ ' ) { cnt@@ Sqr ++ ; } else if ( s . charAt ( i ) == ' } ' && cnt@@ Cur@@ ly > 0 ) { cnt@@ Cur@@ ly -- ; cnt@@ Pairs ++ ; } else if ( s . charAt ( i ) == ' ) ' && cnt@@ S@@ ml > 0 ) { cnt@@ S@@ ml -- ; cnt@@ Pairs ++ ; } else if ( s . charAt ( i ) == ' ] ' && cnt@@ Sqr > 0 ) { cnt@@ Sqr -- ; cnt@@ Pairs ++ ; } } System . out . println ( cnt@@ Pairs ) ; } public static void main ( String [ ] args ) { String s = " { ( } ) " ; int N = s . length ( ) ; cnt@@ Bal@@ anced@@ Parenthe@@ sis ( s , N ) ; } }
import java . util . * ; class GF@@ G { static boolean canBe@@ Bal@@ anced ( String sequence ) { if ( sequence . length ( ) % 2 == 1 ) return false ; Stack < Character > stack@@ _ = new Stack < Character > ( ) ; Stack < Character > stack@@ 2_ = new Stack < Character > ( ) ; int count@@ Open = 0 , count@@ Closed = 0 ; int count@@ Symbol = 0 ; for ( int i = 0 ; i < sequence . length ( ) ; i ++ ) { if ( sequence . charAt ( i ) == ' ) ' ) { count@@ Closed ++ ; if ( stack@@ _ . isEmpty ( ) ) { return false ; } else { stack@@ _ . pop ( ) ; } } else { if ( sequence . charAt ( i ) == ' $ ' ) { count@@ Symbol ++ ; } else { count@@ Open ++ ; } stack@@ _ . add ( sequence . charAt ( i ) ) ; } } for ( int i = sequence . length ( ) - 1 ; i >= 0 ; i -- ) { if ( sequence . charAt ( i ) == ' ( ' ) { if ( stack@@ 2_ . isEmpty ( ) ) { return false ; } else { stack@@ 2_ . pop ( ) ; } } else { stack@@ 2_ . add ( sequence . charAt ( i ) ) ; } } int extra = Math . abs ( count@@ Closed - count@@ Open ) ; if ( count@@ Symbol < extra ) { return false ; } else { count@@ Symbol -= extra ; if ( count@@ Symbol % 2 == 0 ) { return true ; } } return false ; } public static void main ( String [ ] args ) { String S = " ( ) ( $ " ; if ( canBe@@ Bal@@ anced ( S ) ) { System . out . print ( " Yes " ) ; } else { System . out . print ( " No " ) ; } } }
import java . util . * ; class GF@@ G { static void max@@ Diff@@ Freq ( int [ ] [ ] queries , String S ) { int N = S . length ( ) ; int Q = queries . length ; for ( int i = 0 ; i < Q ; ++ i ) { int l = queries [ i ] [ 0 ] - 1 ; int r = queries [ i ] [ 1 ] - 1 ; int freq [ ] = new int [ 26 ] ; for ( int j = l ; j <= r ; j ++ ) { freq [ S . charAt ( j ) - ' a ' ] ++ ; } int mx = 0 ; int mn = 9999@@ 9999 ; for ( int j = 0 ; j < 26 ; j ++ ) { mx = Math . max ( mx , freq [ j ] ) ; if ( freq [ j ] > 0 ) mn = Math . min ( mn , freq [ j ] ) ; } System . out . print ( mx - mn + "@@ NEW_@@ LINE@@ "@@ )@@ ; } } public static void main ( String [ ] args ) { String S = " ab@@ a@@ ab@@ ac " ; int [ ] [ ] queries = { { 2 , 6 } , { 1 , 7 } } ; max@@ Diff@@ Freq ( queries , S ) ; } }
class GF@@ G { static boolean is@@ Equal@@ Strings ( String [ ] arr , int N ) { int M = arr [ 0 ] . length ( ) ; int [ ] cnt@@ Freq = new int [ 256 ] ; for ( int i = 0 ; i < N ; i ++ ) { cnt@@ Freq [ i ] = 0 ; } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { cnt@@ Freq [ arr [ i ] . charAt ( j ) - ' a ' ] += 1 ; } } for ( int i = 0 ; i < 256 ; i ++ ) { if ( cnt@@ Freq [ i ] % N != 0 ) { return false ; } } return true ; } public static void main ( String [ ] args ) { String [ ] arr = { " aa@@ b " , " bb@@ c " , " cc@@ a " } ; int N = arr . length ; if ( is@@ Equal@@ Strings ( arr , N ) ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
import java . util . * ; public class GF@@ G { public static void find@@ Freq ( String str , int N ) { int [ ] freq = new int [ 256 ] ; int max = 0 ; char char@@ Max = '0' ; for ( int i = 0 ; i < N ; i ++ ) { char ch = str . charAt ( i ) ; freq [ ch ] ++ ; if ( freq [ ch ] >= max ) { max = freq [ ch ] ; char@@ Max = ch ; } System . out . println ( char@@ Max + " ▁ - > ▁ " + max ) ; } } public static void main ( String [ ] args ) { String str = " ab@@ bc " ; int N = str . length ( ) ; find@@ Freq ( str , N ) ; } }
class GF@@ G { static int count@@ Of@@ Sub@@ string@@ With@@ Only@@ Ones ( String s ) { int res = 0 , count = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { count = s . charAt ( i ) == '1' ? count + 1 : 0 ; res = ( res + count ) ; } return res ; } public static void main ( String [ ] args ) { String s = "01@@ 101@@ 11" ; System . out . println ( count@@ Of@@ Sub@@ string@@ With@@ Only@@ Ones ( s ) ) ; } }
import java . util . * ; class GF@@ G { static int N = 1000000 + 5 ; static int [ ] prefix = new int [ N ] ; static int [ ] sum = new int [ N ] ; static int is@@ Special ( char c , char [ ] special ) { for ( char i : special ) if ( i == c ) return 1 ; return 0 ; } static double count@@ Ratio ( char [ ] s , char [ ] special ) { int n = s . length ; for ( int i = 0 ; i < n ; i ++ ) { prefix [ i ] = ( is@@ Special ( s [ i ] , special ) ) ; if ( i > 0 ) prefix [ i ] += prefix [ i - 1 ] ; } for ( int i = 0 ; i < n ; i ++ ) { sum [ i ] = prefix [ i ] ; if ( i > 0 ) sum [ i ] += sum [ i - 1 ] ; } double ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int count = sum [ n - 1 ] - ( i > 1 ? sum [ i - 2 ] : 0 ) ; count -= ( i < n ? sum [ n - i - 1 ] : 0 ) ; ans += ( double ) count / ( double ) i ; } return ans ; } public static void main ( String [ ] args ) { String s = " abcd " ; char [ ] special = { ' b ' , ' c ' } ; double ans = count@@ Ratio ( s . toCharArray ( ) , special ) ; System . out . format ( " % .@@ 6f " , ans ) ; } }
class GF@@ G { public static boolean is@@ Pal@@ ind@@ ro@@ me ( String str ) { int l = 0 ; int h = str . length ( ) - 1 ; while ( h > l ) { if ( str . charAt ( l ) != str . charAt ( h ) ) { return false ; } l ++ ; h -- ; } return true ; } public static String make@@ O@@ dd@@ String ( String str ) { String odd = " " ; for ( int i = 1 ; i < str . length ( ) ; i += 2 ) { odd += str . charAt ( i ) ; } return odd ; } public static void check@@ O@@ dd@@ ly@@ Pal@@ ind@@ ro@@ me ( String str ) { String odd = make@@ O@@ dd@@ String ( str ) ; if ( is@@ Pal@@ ind@@ ro@@ me ( odd ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } public static void main ( String [ ] args ) { String str = " d@@ dw@@ fe@@ fw@@ de " ; check@@ O@@ dd@@ ly@@ Pal@@ ind@@ ro@@ me ( str ) ; } }
class GF@@ G { public static boolean check@@ Suffix ( int A , int B ) { String s1 = String . valueOf ( A ) ; String s2 = String . valueOf ( B ) ; int n1 = s1 . length ( ) ; int n2 = s2 . length ( ) ; if ( n1 < n2 ) { return false ; } for ( int i = 0 ; i < n2 ; i ++ ) { if ( s1 . charAt ( n1 - i - 1 ) != s2 . charAt ( n2 - i - 1 ) ) { return false ; } } return true ; } public static void main ( String [ ] args ) { int A = 12345 , B = 45 ; boolean result = check@@ Suffix ( A , B ) ; if ( result ) { System . out . print ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
import java . util . * ; class GF@@ G { static boolean is@@ Prime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } static boolean is@@ Possible@@ Sum ( int N ) { if ( is@@ Prime ( N ) && is@@ Prime ( N - 2 ) ) { return true ; } else { return false ; } } static boolean check@@ Semi@@ prime ( int num ) { int cnt = 0 ; for ( int i = 2 ; cnt < 2 && i * i <= num ; ++ i ) { while ( num % i == 0 ) { num /= i ; ++ cnt ; } } if ( num > 1 ) { ++ cnt ; } return cnt == 2 ; } static void make@@ C@@ yp@@ her@@ String ( int N ) { String semi@@ Prime = " " ; String sum@@ Of@@ Prime = " " ; String str = String . valueOf ( N ) ; if ( check@@ Semi@@ prime ( N ) ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( i % 2 == 1 ) { semi@@ Prime += str . charAt ( i ) ; } else { semi@@ Prime += ( char ) ( str . charAt ( i ) - '0' + 65 ) ; } } } if ( is@@ Possible@@ Sum ( N ) ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( i % 2 == 1 ) { sum@@ Of@@ Prime += ( char ) ( str . charAt ( i ) - '0' + 65 ) ; } else { sum@@ Of@@ Prime += str . charAt ( i ) ; } } } if ( semi@@ Prime + sum@@ Of@@ Prime == " " ) { System . out . print ( " - 1" ) ; } else { System . out . print ( semi@@ Prime + sum@@ Of@@ Prime ) ; } } public static void main ( String [ ] args ) { int N = 101@@ 12@@ 43 ; make@@ C@@ yp@@ her@@ String ( N ) ; } }
class GF@@ G { static void k@@ th_@@ String ( int n , int k ) { for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( k <= ( n - i - 1 ) ) { for ( int j = 0 ; j < n ; j ++ ) { if ( j == i j == n - k ) System . out . print ( ' Y ' ) ; else System . out . print ( ' X ' ) ; } break ; } k -= ( n - i - 1 ) ; } } public static void main ( String [ ] args ) { int n = 5 , k = 7 ; k@@ th_@@ String ( n , k ) ; } }
import java . util . * ; class GF@@ G { static String remove@@ Duplicates ( String str ) { int n = str . length ( ) ; String res = " " ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = i + 1 ; j < n ; j ++ ) if ( str . charAt ( i ) == str . charAt ( j ) ) break ; if ( j == n ) res = res + str . charAt ( i ) ; } return res ; } public static void main ( String [ ] args ) { String str = " ge@@ ek@@ s@@ forge@@ e@@ ks " ; System . out . print ( remove@@ Duplicates ( str ) ) ; } }
class GF@@ G { static int value ( char x ) { return ( int ) ( x - ' a ' ) ; } static String maximum@@ Product ( String str , int n ) { String answer = " " , curr = " " ; long max@@ Product = 0 , product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { product *= 1L * value ( str . charAt ( i ) ) ; curr += str . charAt ( i ) ; if ( product >= max@@ Product ) { max@@ Product = product ; answer = curr ; } if ( product == 0 ) { product = 1 ; curr = " " ; } } return answer ; } public static void main ( String [ ] args ) { String str = " sd@@ t@@ fa@@ k@@ dh@@ da@@ hd@@ zz " ; int n = str . length ( ) ; System . out . print ( maximum@@ Product ( str , n ) + "@@ NEW_@@ LINE@@ "@@ )@@ ; } }
class GF@@ G { static void k@@ th@@ String ( int n , int k ) { int total = 0 ; int i = 1 ; while ( total < k ) { total = total + n - i ; i ++ ; } int first_@@ y_@@ position = i - 1 ; int second_@@ y_@@ position = k - ( total - n + first_@@ y_@@ position ) ; for ( int j = 1 ; j < first_@@ y_@@ position ; j ++ ) System . out . print ( " x " ) ; System . out . print ( " y " ) ; int j = first_@@ y_@@ position + 1 ; while ( second_@@ y_@@ position > 1 ) { System . out . print ( " x " ) ; second_@@ y_@@ position -- ; j ++ ; } System . out . print ( " y " ) ; while ( j < n ) { System . out . print ( " x " ) ; j ++ ; } } public static void main ( String [ ] args ) { int n = 5 ; int k = 7 ; k@@ th@@ String ( n , k ) ; } }
class GF@@ G { static int Xor@@ Ascii ( String str , int len ) { int ans = ( str . charAt ( 0 ) ) ; for ( int i = 1 ; i < len ; i ++ ) { ans = ( ans ^ ( ( str . charAt ( i ) ) ) ) ; } return ans ; } public static void main ( String [ ] args ) { String str = " ge@@ ek@@ s@@ forge@@ e@@ ks " ; int len = str . length ( ) ; System . out . print ( Xor@@ Ascii ( str , len ) + "@@ NEW_@@ LINE@@ "@@ )@@ ; str = " Gf@@ G " ; len = str . length ( ) ; System . out . print ( Xor@@ Ascii ( str , len ) ) ; } }
class GF@@ G { static int i ; static int product@@ At@@ K@@ th@@ Level ( String tree , int k , int level ) { if ( tree . charAt ( i ++ ) == ' ( ' ) { if ( tree . charAt ( i ) == ' ) ' ) return 1 ; int product = 1 ; if ( level == k ) product = tree . charAt ( i ) - '0' ; ++ i ; int left@@ product = product@@ At@@ K@@ th@@ Level ( tree , k , level + 1 ) ; ++ i ; int right@@ product = product@@ At@@ K@@ th@@ Level ( tree , k , level + 1 ) ; ++ i ; return product * left@@ product * right@@ product ; } return Integer . MIN_VALUE ; } public static void main ( String [ ] args ) { String tree = " ( 0@@ (@@ 5@@ (@@ 6 ( ) ( ) ) ( 4 ( ) " + " ( 9 ( ) ( ) ) ) ) ( 7@@ (1 ( ) ( ) ) ( 3 ( ) ( ) ) ) ) " ; int k = 2 ; i = 0 ; System . out . print ( product@@ At@@ K@@ th@@ Level ( tree , k , 0 ) ) ; } }
import java . util . * ; class GF@@ G { static String CHARS = " q@@ wer@@ ty@@ ui@@ op@@ as@@ df@@ gh@@ jkl@@ zx@@ cv@@ bn@@ m " ; static int MAX = 26 ; static String getString ( char [ ] str , int n ) { Map < Character , Character > u@@ Map = new HashMap < > ( ) ; for ( int i = 0 ; i < MAX ; i ++ ) { u@@ Map . put ( CHARS . charAt ( i ) , CHARS . charAt ( ( i + 1 ) % MAX ) ) ; } for ( int i = 0 ; i < n ; i ++ ) { str [ i ] = u@@ Map . get ( str [ i ] ) ; } return String . valueOf ( str ) ; } public static void main ( String [ ] args ) { String str = " ge@@ e@@ ks " ; int n = str . length ( ) ; System . out . println ( getString ( str . toCharArray ( ) , n ) ) ; } }
class GF@@ G { final static int MOD = 100000000@@ 7 ; static long count@@ Strings ( int N ) { int i , j ; int dp [ ] [ ] = new int [ N + 1 ] [ 3 ] ; for ( i = 0 ; i < N + 1 ; i ++ ) { for ( j = 9 ; j < 3 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 1 ] [ 0 ] = 1 ; dp [ 1 ] [ 1 ] = 1 ; dp [ 1 ] [ 2 ] = 0 ; for ( i = 2 ; i <= N ; i ++ ) { dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] + dp [ i - 1 ] [ 2 ] ) % MOD ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] % MOD ; dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] % MOD ; } int ans = ( dp [ N ] [ 0 ] + dp [ N ] [ 1 ] + dp [ N ] [ 2 ] ) % MOD ; return ans ; } public static void main ( String [ ] args ) { int N = 3 ; System . out . println ( count@@ Strings ( N ) ) ; } }
import java . util . * ; class GF@@ G { static String max@@ Number ( String str , int n ) { int [ ] freq = new int [ 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == ' z ' ) freq [ 0 ] ++ ; else if ( str . charAt ( i ) == ' n ' ) freq [ 1 ] ++ ; } String num = " " ; for ( int i = 0 ; i < freq [ 1 ] ; i ++ ) num += '1' ; for ( int i = 0 ; i < freq [ 0 ] ; i ++ ) num += '0' ; return num ; } public static void main ( String [ ] args ) { String str = " ro@@ en@@ en@@ zoo@@ e " ; int n = str . length ( ) ; System . out . println ( max@@ Number ( str , n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { String string = " { [ ( ) ] } [ ] " ; char [ ] lst@@ 1 = { ' { ' , ' ( ' , ' [ ' } ; char [ ] lst@@ 2 = { ' } ' , ' ) ' , ' ] ' } ; Vector < Character > lst = new Vector < Character > ( ) ; HashMap < Character , Character > Dict = new HashMap < > ( ) ; Dict . put ( ' ) ' , ' ( ' ) ; Dict . put ( ' } ' , ' { ' ) ; Dict . put ( ' ] ' , ' [ ' ) ; int a = 0 , b = 0 , c = 0 ; if ( Arrays . asList ( lst@@ 2 ) . contains ( string . charAt ( 0 ) ) ) { System . out . println ( 1 ) ; } else { int k = 0 ; for ( int i = 0 ; i < string . length ( ) ; i ++ ) { if ( Arrays . asList ( lst@@ 1 ) . contains ( string . charAt ( i ) ) ) { lst . add ( string . charAt ( i ) ) ; k = i + 2 ; } else { if ( lst . size ( ) == 0 && Arrays . asList ( lst@@ 2 ) . contains ( string . charAt ( i ) ) ) { System . out . println ( ( i + 1 ) ) ; c = 1 ; break ; } else { if ( lst . size ( ) > 0 && Dict . get ( string . charAt ( i ) ) == lst . get ( lst . size ( ) - 1 ) ) { lst . remove ( lst . size ( ) - 1 ) ; } else { a = 1 ; break ; } } } } if ( lst . size ( ) == 0 && c == 0 ) { System . out . println ( 0 ) ; b = 1 ; } if ( a == 0 && b == 0 && c == 0 ) { System . out . println ( k ) ; } } } }
public class GF@@ G { static final int MAX = 26 ; static String encrypt@@ Str ( String str , int n , int x ) { x = x % MAX ; char arr [ ] = str . toCharArray ( ) ; int freq [ ] = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ arr [ i ] - ' a ' ] % 2 == 0 ) { int pos = ( arr [ i ] - ' a ' + x ) % MAX ; arr [ i ] = ( char ) ( pos + ' a ' ) ; } else { int pos = ( arr [ i ] - ' a ' - x ) ; if ( pos < 0 ) pos += MAX ; arr [ i ] = ( char ) ( pos + ' a ' ) ; } } return String . valueOf ( arr ) ; } public static void main ( String [ ] args ) { String s = " abc@@ da " ; int n = s . length ( ) ; int x = 3 ; System . out . println ( encrypt@@ Str ( s , n , x ) ) ; } }
import java . util . * ; class GF@@ G { static int count@@ Occurren@@ ce ( String s , int position ) { int [ ] alpha = new int [ 26 ] ; int [ ] b = new int [ s . length ( ) ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { b [ i ] = alpha [ ( int ) s . charAt ( i ) - 97 ] ; alpha [ ( int ) s . charAt ( i ) - 97 ] ++ ; } return b [ position - 1 ] ; } public static void main ( String [ ] args ) { String s = " abab@@ abab@@ ab " ; int p = 9 ; System . out . println ( count@@ Occurren@@ ce ( s , p ) ) ; } }
import java . util . * ; class GF@@ G { static boolean is@@ Possible ( char [ ] str ) { Map < Character , Integer > freq = new HashMap < > ( ) ; int max_@@ freq = 0 ; for ( int j = 0 ; j < ( str . length ) ; j ++ ) { if ( freq . containsKey ( str [ j ] ) ) { freq . put ( str [ j ] , freq . get ( str [ j ] ) + 1 ) ; if ( freq . get ( str [ j ] ) > max_@@ freq ) max_@@ freq = freq . get ( str [ j ] ) ; } else { freq . put ( str [ j ] , 1 ) ; if ( freq . get ( str [ j ] ) > max_@@ freq ) max_@@ freq = freq . get ( str [ j ] ) ; } } if ( max_@@ freq <= ( str . length - max_@@ freq + 1 ) ) return true ; return false ; } public static void main ( String [ ] args ) { String str = " ge@@ ek@@ s@@ forge@@ e@@ ks " ; if ( is@@ Possible ( str . toCharArray ( ) ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GF@@ G { static void print@@ Un@@ common ( String str1 , String str2 ) { int a1 = 0 , a2 = 0 ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) { int ch = ( str1 . charAt ( i ) ) - ' a ' ; a1 = a1 | ( 1 << ch ) ; } for ( int i = 0 ; i < str2 . length ( ) ; i ++ ) { int ch = ( str2 . charAt ( i ) ) - ' a ' ; a2 = a2 | ( 1 << ch ) ; } int ans = a1 ^ a2 ; int i = 0 ; while ( i < 26 ) { if ( ans % 2 == 1 ) { System . out . print ( ( char ) ( ' a ' + i ) ) ; } ans = ans / 2 ; i ++ ; } } public static void main ( String [ ] args ) { String str1 = " ge@@ ek@@ s@@ forge@@ e@@ ks " ; String str2 = " ge@@ ek@@ s@@ qui@@ z " ; print@@ Un@@ common ( str1 , str2 ) ; } }
import java . util . * ; class GF@@ G { static int cnt = 0 ; static Vector < Integer > [ ] graph = new Vector [ 100 ] ; static String [ ] weight = new String [ 100 ] ; static boolean unique@@ Chars ( char [ ] arr ) { HashMap < Character , Integer > mp = new HashMap < Character , Integer > ( ) ; int n = arr . length ; for ( int i = 0 ; i < n ; i ++ ) if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } if ( mp . size ( ) == arr . length ) return true ; else return false ; } static void dfs ( int node , int parent ) { if ( unique@@ Chars ( weight [ node ] . toCharArray ( ) ) ) cnt += 1 ; for ( int to : graph [ node ] ) { if ( to == parent ) continue ; dfs ( to , node ) ; } } public static void main ( String [ ] args ) { for ( int i = 0 ; i < 100 ; i ++ ) graph [ i ] = new Vector < Integer > ( ) ; weight [ 1 ] = " abc " ; weight [ 2 ] = " aba " ; weight [ 3 ] = " b@@ cb " ; weight [ 4 ] = " mo@@ h " ; weight [ 5 ] = " aa " ; graph [ 1 ] . add ( 2 ) ; graph [ 2 ] . add ( 3 ) ; graph [ 2 ] . add ( 4 ) ; graph [ 1 ] . add ( 5 ) ; dfs ( 1 , 1 ) ; System . out . print ( cnt ) ; } }
import java . util . * ; class GF@@ G { static boolean check ( String s , int l ) { Vector < Integer > pos = new Vector < Integer > ( ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( s . charAt ( i ) == '1' ) pos . add ( i ) ; } int t = pos . size ( ) ; for ( int i = 1 ; i < t ; i ++ ) { if ( ( pos . get ( i ) - pos . get ( i - 1 ) ) != ( pos . get ( 1 ) - pos . get ( 0 ) ) ) return false ; } return true ; } public static void main ( String args [ ] ) { String s = "100@@ 0100@@ 0100@@ 0" ; int l = s . length ( ) ; if ( check ( s , l ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
class GF@@ G { static boolean is@@ Prefix ( String str , int len , int i , int k ) { if ( i + k > len ) return false ; for ( int j = 0 ; j < k ; j ++ ) { if ( str . charAt ( i ) != str . charAt ( j ) ) return false ; i ++ ; } return true ; } static boolean is@@ K@@ Periodic ( String str , int len , int k ) { for ( int i = k ; i < len ; i += k ) if ( ! is@@ Prefix ( str , len , i , k ) ) return false ; return true ; } public static void main ( String [ ] args ) { String str = " ge@@ ek@@ s@@ ge@@ e@@ ks " ; int len = str . length ( ) ; int k = 5 ; if ( is@@ K@@ Periodic ( str , len , k ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
class GF@@ G { static int p@@ ang@@ ram@@ Cost ( int arr [ ] , String str ) { int cost = 0 ; boolean [ ] occurred = new boolean [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) occurred [ i ] = false ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) occurred [ str . charAt ( i ) - ' a ' ] = true ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( occurred [ i ] == false ) cost += arr [ i ] ; } return cost ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 } ; String str = " abcdefghijkl@@ mo@@ pq@@ rstu@@ v@@ w@@ z " ; System . out . println ( p@@ ang@@ ram@@ Cost ( arr , str ) ) ; } }
public class GF@@ G { static int check ( String s ) { int i , j ; int fr [ ] = new int [ 26 ] ; int n = s . length ( ) ; for ( i = 0 ; i < n ; i ++ ) { char x = s . charAt ( i ) ; fr [ x - ' a ' ] += 1 ; } int minimum = Integer . MAX_VALUE ; for ( i = 0 ; i < 26 ; i ++ ) { for ( j = i + 1 ; j < 26 ; j ++ ) { int z = fr [ i ] + fr [ j ] ; minimum = Math . min ( minimum , n - z ) ; } } return minimum ; } public static void main ( String [ ] args ) { String s = " ge@@ ek@@ s@@ forge@@ e@@ ks " ; System . out . println ( check ( s ) ) ; } }
import java . util . * ; class Solution { static String separ@@ ate@@ Char ( String str ) { int n = str . length ( ) , digit@@ Sum = 0 ; int alphab@@ et@@ Sum = 0 , j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) >= '0' && str . charAt ( i ) <= '9' ) { digit@@ Sum += ( int ) ( str . charAt ( i ) - '0' ) ; } else { alphab@@ et@@ Sum += str . charAt ( i ) - ' a ' + 1 ; alphab@@ et@@ Sum %= 26 ; } } String sum@@ Str = " " + ( digit@@ Sum ) ; char alphab@@ et@@ Str = ( char ) ( alphab@@ et@@ Sum + ' a ' - 1 ) ; sum@@ Str += alphab@@ et@@ Str ; return sum@@ Str ; } public static void main ( String args [ ] ) { String str = "@@ 365@@ 2@@ ad@@ yz@@ 34@@ 23" ; System . out . println ( separ@@ ate@@ Char ( str ) ) ; } }
class solution { static int count@@ Words ( String str ) { int count = 1 ; for ( int i = 1 ; i < str . length ( ) - 1 ; i ++ ) { if ( str . charAt ( i ) >= 65 && str . charAt ( i ) <= 90 ) count ++ ; } return count ; } public static void main ( String args [ ] ) { String str = " ge@@ ek@@ sFor@@ Ge@@ e@@ ks " ; System . out . print ( count@@ Words ( str ) ) ; } }
public class g@@ fg { int find ( String s ) { int max = 0 , i , j = 0 , count@@ k = 0 , coun@@ tr = 0 ; int table [ ] [ ] = new int [ s . length ( ) ] [ 2 ] ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == ' R ' ) coun@@ tr ++ ; else table [ j ++ ] [ 0 ] = coun@@ tr ; } j -- ; for ( i = s . length ( ) - 1 ; i >= 0 ; i -- ) { if ( s . charAt ( i ) == ' K ' ) { count@@ k ++ ; table [ j -- ] [ 1 ] = count@@ k ; } if ( Math . min ( table [ j + 1 ] [ 0 ] , table [ j + 1 ] [ 1 ] ) > max ) max = Math . min ( table [ j + 1 ] [ 0 ] , table [ j + 1 ] [ 1 ] ) ; } return max ; } public static void main ( String sr@@ gs [ ] ) { String s = " R@@ K@@ RR@@ R@@ KK@@ RR@@ KK@@ KK@@ RR " ; g@@ fg ob = new g@@ fg ( ) ; int n = ob . find ( s ) ; System . out . println ( n ) ; } }
import java . util . ArrayList ; public class string_@@ sort { public static int power@@ Of@@ Jump ( String s ) { int count = 1 ; int max_@@ so@@ _f@@ ar = Integer . MIN_VALUE ; char ch = s . charAt ( s . length ( ) - 1 ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == ch ) { if ( count > max_@@ so@@ _f@@ ar ) { max_@@ so@@ _f@@ ar = count ; } count = 1 ; } else count ++ ; } return max_@@ so@@ _f@@ ar ; } public static void main ( String [ ] args ) { String st = "@@ 101@@ 01@@ 01" ; System . out . println ( power@@ Of@@ Jump ( st ) ) ; } }
class GF@@ G { public static String multiply ( String num1 , String num2 ) { int n1 = num1 . length ( ) ; int n2 = num2 . length ( ) ; if ( n1 == 0 n2 == 0 ) return "0" ; int [ ] result = new int [ n1 + n2 ] ; int i_@@ n1 = 0 ; int i_@@ n2 = 0 ; for ( int i = n1 - 1 ; i >= 0 ; i -- ) { int carry = 0 ; int n_@@ 1 = num1 . charAt ( i ) - '0' ; i_@@ n2 = 0 ; for ( int j = n2 - 1 ; j >= 0 ; j -- ) { int n_@@ 2 = num2 . charAt ( j ) - '0' ; int sum = n_@@ 1 * n_@@ 2 + result [ i_@@ n1 + i_@@ n2 ] + carry ; carry = sum / 10 ; result [ i_@@ n1 + i_@@ n2 ] = sum % 10 ; i_@@ n2 ++ ; } if ( carry > 0 ) result [ i_@@ n1 + i_@@ n2 ] += carry ; i_@@ n1 ++ ; } int i = result . length - 1 ; while ( i >= 0 && result [ i ] == 0 ) i -- ; if ( i == - 1 ) return "0" ; String s = " " ; while ( i >= 0 ) s += Integer . toString ( result [ i -- ] ) ; return s ; } public static void main ( String [ ] args ) { String str1 = "@@ 45@@ 45@@ 45@@ 45@@ 45@@ 45@@ 45@@ 45@@ 45@@ " ; System . out . println ( multiply ( str1 , str1 ) ) ; } }
import java . util . * ; class GF@@ G { static boolean match_@@ words ( String dictionary [ ] , String sentence [ ] , int n , int m ) { Map < String , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( dictionary [ i ] ) ) { mp . put ( dictionary [ i ] , mp . get ( dictionary [ i ] ) + 1 ) ; } else { mp . put ( dictionary [ i ] , 1 ) ; } } for ( int i = 0 ; i < m ; i ++ ) { if ( mp . containsKey ( sentence [ i ] ) ) mp . put ( sentence [ i ] , mp . get ( sentence [ i ] ) - 1 ) ; else return false ; } return true ; } public static void main ( String [ ] args ) { String dictionary [ ] = { " find " , " a " , " ge@@ e@@ ks " , " all " , " for " , " on " , " ge@@ e@@ ks " , " answers " , " inter " } ; int n = dictionary . length ; String sentence [ ] = { " find " , " all " , " answers " , " on " , " ge@@ e@@ ks " , " for " , " ge@@ e@@ ks " } ; int m = sentence . length ; if ( match_@@ words ( dictionary , sentence , n , m ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
class GF@@ G { static int find_@@ sub ( String s , int k ) { int len = s . length ( ) ; int lp = 0 , rp = 0 ; int ans = 0 ; int [ ] hash_@@ char = new int [ 26 ] ; for ( ; rp < len ; rp ++ ) { hash_@@ char [ s . charAt ( rp ) - ' a ' ] ++ ; while ( hash_@@ char [ s . charAt ( rp ) - ' a ' ] > k ) { hash_@@ char [ s . charAt ( lp ) - ' a ' ] -- ; lp ++ ; } ans += rp - lp + 1 ; } return ans ; } public static void main ( String [ ] args ) { String S = " aa@@ abb " ; int k = 2 ; System . out . println ( find_@@ sub ( S , k ) ) ; } }
import java . io . * ; public class GF@@ G { static boolean transform@@ String ( StringBuilder s ) { char ch = ' a ' ; if ( s . length ( ) < 26 ) return false ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ( int ) ch > ( int ) ' z ' ) break ; if ( s . charAt ( i ) <= ch ) { s . set@@ Char@@ At ( i , ch ) ; ch = ( char ) ( ( int ) ch + 1 ) ; } } if ( ch <= ' z ' ) return false ; return true ; } public static void main ( String args [ ] ) { StringBuilder str = new StringBuilder ( " aaaaaaaaaaaaaaaa@@ aaaaaaaa@@ aa " ) ; if ( transform@@ String ( str ) ) System . out . println ( str . toString ( ) ) ; else System . out . println ( " Not ▁ Possible " ) ; } }
class GF@@ G { static boolean is@@ Pal@@ ind@@ ro@@ me ( String str ) { int i = 0 , j = str . length ( ) - 1 ; while ( i < j ) { if ( str . charAt ( i ++ ) != str . charAt ( j -- ) ) return false ; } return true ; } static String remove@@ Pal@@ in@@ Words ( String str ) { String final_@@ str = " " , word = " " ; str = str + " ▁ " ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) != ' ▁ ' ) word = word + str . charAt ( i ) ; else { if ( ! ( is@@ Pal@@ ind@@ ro@@ me ( word ) ) ) final_@@ str += word + " ▁ " ; word = " " ; } } return final_@@ str ; } public static void main ( String [ ] args ) { String str = " Text ▁ contains ▁ mal@@ ay@@ al@@ am ▁ and ▁ level ▁ words " ; System . out . print ( remove@@ Pal@@ in@@ Words ( str ) ) ; } }
import java . util . * ; import java . lang . * ; class Ge@@ ek@@ s@@ for@@ Ge@@ e@@ ks { static void ASCI@@ IS@@ ent@@ ence ( String str ) { int l = str . length ( ) ; int convert ; for ( int i = 0 ; i < l ; i ++ ) { convert = str . charAt ( i ) ; System . out . print ( convert ) ; } } public static void main ( String args [ ] ) { String str = " Ge@@ ek@@ s@@ for@@ Ge@@ e@@ ks " ; System . out . println ( " ASCII ▁ Sentence : " ) ; ASCI@@ IS@@ ent@@ ence ( str ) ; } }
import java . io . * ; class GF@@ G { static void convert ( String str ) { int n = str . length ( ) ; String str1 = " " ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == ' ▁ ' ) str1 = str1 + ' _ ' ; else str1 = str1 + Character . toLowerCase ( str . charAt ( i ) ) ; } System . out . print ( str1 ) ; } public static void main ( String args [ ] ) { String str = " I ▁ got ▁ intern ▁ at ▁ ge@@ ek@@ s@@ forge@@ e@@ ks " ; convert ( str ) ; } }
public class GF@@ G { static void find@@ Next@@ Word ( char [ ] s , int m ) { m += 97 ; int n = s . length ; int i = s . length - 1 ; s [ i ] ++ ; while ( i >= 0 && i <= n - 1 ) { if ( s [ i ] >= m ) { s [ i ] = ' a ' ; s [ -- i ] ++ ; } else if ( s [ i ] == s [ i - 1 ] s [ i ] == s [ i - 2 ] ) { s [ i ] ++ ; } else { i ++ ; } } if ( i <= - 1 ) { System . out . println ( " - 1" ) ; } else { System . out . println ( s ) ; } } public static void main ( String [ ] args ) { char [ ] str = " abcd " . toCharArray ( ) ; int k = 4 ; find@@ Next@@ Word ( str , k ) ; } }
import java . util . * ; class GF@@ G { public static String next@@ Word ( String str ) { if ( str == " " ) return " a " ; int i = str . length ( ) - 1 ; while ( str . charAt ( i ) == ' z ' && i >= 0 ) i -- ; if ( i == - 1 ) str = str + ' a ' ; else str = str . substring ( 0 , i ) + ( char ) ( ( int ) ( str . charAt ( i ) ) + 1 ) + str . substring ( i + 1 ) ; return str ; } public static void main ( String [ ] args ) { String str = " same@@ z " ; System . out . print ( next@@ Word ( str ) ) ; } }
import java . io . * ; public class GF@@ G { static int MAX_@@ CHAR = 26 ; static int least@@ Count ( String s1 , String s2 , int n ) { int [ ] count@@ 1 = new int [ MAX_@@ CHAR ] ; int [ ] count2 = new int [ MAX_@@ CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) { count@@ 1 [ s1 . charAt ( i ) - ' a ' ] += 1 ; count2 [ s2 . charAt ( i ) - ' a ' ] += 1 ; } int res = 0 ; for ( int i = 0 ; i < MAX_@@ CHAR ; i ++ ) { if ( count@@ 1 [ i ] != 0 ) { res += Math . abs ( count@@ 1 [ i ] - count2 [ i ] ) ; } } return res ; } static public void main ( String [ ] args ) { String s1 = " abc " ; String s2 = " c@@ dd " ; int len = s1 . length ( ) ; int res = least@@ Count ( s1 , s2 , len ) ; System . out . println ( res ) ; } }
public class L@@ onge@@ st_@@ common_@@ substr { static void print@@ LC@@ Sub@@ Str ( String X , String Y , int m , int n ) { int [ ] [ ] LC@@ Su@@ ff = new int [ m + 1 ] [ n + 1 ] ; int len = 0 ; int row = 0 , col = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) LC@@ Su@@ ff [ i ] [ j ] = 0 ; else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) { LC@@ Su@@ ff [ i ] [ j ] = LC@@ Su@@ ff [ i - 1 ] [ j - 1 ] + 1 ; if ( len < LC@@ Su@@ ff [ i ] [ j ] ) { len = LC@@ Su@@ ff [ i ] [ j ] ; row = i ; col = j ; } } else LC@@ Su@@ ff [ i ] [ j ] = 0 ; } } if ( len == 0 ) { System . out . println ( " No ▁ Common ▁ Sub@@ string " ) ; return ; } String result@@ Str = " " ; while ( LC@@ Su@@ ff [ row ] [ col ] != 0 ) { -- len ; row -- ; col -- ; } System . out . println ( result@@ Str ) ; } public static void main ( String args [ ] ) { String X = " Old@@ Site : Ge@@ ek@@ s@@ for@@ Ge@@ e@@ ks . org " ; String Y = " New@@ Site : Ge@@ ek@@ s@@ Qu@@ iz . com " ; int m = X . length ( ) ; int n = Y . length ( ) ; print@@ LC@@ Sub@@ Str ( X , Y , m , n ) ; } }
class GF@@ G { static void sub@@ string@@ Conversions ( String str , int k , int b ) { for ( int i = 0 ; i + k <= str . length ( ) ; i ++ ) { String sub = str . substring ( i , i + k ) ; int sum = 0 , counter = 0 ; for ( int j = sub . length ( ) - 1 ; j >= 0 ; j -- ) { sum = ( int ) ( sum + ( ( sub . charAt ( j ) - '0' ) * Math . pow ( b , counter ) ) ) ; counter ++ ; } System . out . print ( sum + " ▁ " ) ; } } public static void main ( String [ ] args ) { String str = "12@@ 2@@ 12" ; int b = 3 , k = 3 ; sub@@ string@@ Conversions ( str , b , k ) ; } }
public class GF@@ G { static final int MAX_@@ CHAR = 26 ; static boolean check@@ Correct@@ Or@@ Not ( String s ) { int [ ] count@@ 1 = new int [ MAX_@@ CHAR ] ; int [ ] count2 = new int [ MAX_@@ CHAR ] ; int n = s . length ( ) ; if ( n == 1 ) return true ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { count@@ 1 [ s . charAt ( i ) - ' a ' ] ++ ; count2 [ s . charAt ( j ) - ' a ' ] ++ ; } for ( int i = 0 ; i < MAX_@@ CHAR ; i ++ ) if ( count@@ 1 [ i ] != count2 [ i ] ) return false ; return true ; } public static void main ( String args [ ] ) { String s = " ab@@ ab " ; if ( check@@ Correct@@ Or@@ Not ( s ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GF@@ G { static int remain@@ der@@ With@@ 7 ( String num ) { int series [ ] = { 1 , 3 , 2 , - 1 , - 3 , - 2 } ; int series_@@ index = 0 ; int result = 0 ; for ( int i = num . length ( ) - 1 ; i >= 0 ; i -- ) { int digit = num . charAt ( i ) - '0' ; result += digit * series [ series_@@ index ] ; series_@@ index = ( series_@@ index + 1 ) % 6 ; result %= 7 ; } if ( result < 0 ) result = ( result + 7 ) % 7 ; return result ; } public static void main ( String [ ] args ) { String str = "12345" ; System . out . print ( " Remain@@ der ▁ with ▁ 7 ▁ is ▁ " + remain@@ der@@ With@@ 7 ( str ) ) ; } }
public class GF@@ G { static int CHARS = 26 ; static boolean isValid@@ String ( String str ) { int freq [ ] = new int [ CHARS ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { freq [ str . charAt ( i ) - ' a ' ] ++ ; } int i , fre@@ q1 = 0 , count_@@ fre@@ q1 = 0 ; for ( i = 0 ; i < CHARS ; i ++ ) { if ( freq [ i ] != 0 ) { fre@@ q1 = freq [ i ] ; count_@@ fre@@ q1 = 1 ; break ; } } int j , fre@@ q2 = 0 , count_@@ fre@@ q2 = 0 ; for ( j = i + 1 ; j < CHARS ; j ++ ) { if ( freq [ j ] != 0 ) { if ( freq [ j ] == fre@@ q1 ) { count_@@ fre@@ q1 ++ ; } else { count_@@ fre@@ q2 = 1 ; fre@@ q2 = freq [ j ] ; break ; } } } for ( int k = j + 1 ; k < CHARS ; k ++ ) { if ( freq [ k ] != 0 ) { if ( freq [ k ] == fre@@ q1 ) { count_@@ fre@@ q1 ++ ; } if ( freq [ k ] == fre@@ q2 ) { count_@@ fre@@ q2 ++ ; { return false ; } } if ( count_@@ fre@@ q1 > 1 && count_@@ fre@@ q2 > 1 ) { return false ; } } return true ; } public static void main ( String [ ] args ) { String str = " ab@@ cbc " ; if ( isValid@@ String ( str ) ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
import java . io . * ; class GF@@ G { static boolean is@@ Rever@@ sible ( String str ) { int i = 0 , j = str . length ( ) - 1 ; while ( i < j ) { if ( str . charAt ( i ) != str . charAt ( j ) ) return false ; i ++ ; j -- ; } return true ; } public static void main ( String [ ] args ) { String str = " aba " ; if ( is@@ Rever@@ sible ( str ) ) System . out . print ( " YES " ) ; else System . out . print ( " NO " ) ; } }
import java . io . * ; import java . util . * ; class GF@@ G { static String encode@@ String ( String str ) { HashMap < Character , Integer > map = new HashMap < > ( ) ; String res = " " ; int i = 0 ; char ch ; for ( int j = 0 ; j < str . length ( ) ; j ++ ) { ch = str . charAt ( j ) ; if ( ! map . containsKey ( ch ) ) map . put ( ch , i ++ ) ; res += map . get ( ch ) ; } return res ; } static void find@@ Matched@@ Words ( String [ ] dict , String pattern ) { int len = pattern . length ( ) ; String hash = encode@@ String ( pattern ) ; for ( String word : dict ) { if ( word . length ( ) == len && encode@@ String ( word ) . equals ( hash ) ) System . out . print ( word + " ▁ " ) ; } } public static void main ( String args [ ] ) { String [ ] dict = { " abb " , " abc " , " xyz " , " xy@@ y " } ; String pattern = " foo " ; find@@ Matched@@ Words ( dict , pattern ) ; } }
import java . util . * ; class GF@@ G { static boolean check ( String pattern , String word ) { if ( pattern . length ( ) != word . length ( ) ) return false ; int [ ] ch = new int [ 128 ] ; int Len = word . length ( ) ; for ( int i = 0 ; i < Len ; i ++ ) { if ( ch [ ( int ) pattern . charAt ( i ) ] == 0 ) { ch [ ( int ) pattern . charAt ( i ) ] = word . charAt ( i ) ; } else if ( ch [ ( int ) pattern . charAt ( i ) ] != word . charAt ( i ) ) { return false ; } } return true ; } static void find@@ Matched@@ Words ( HashSet < String > dict , String pattern ) { int Len = pattern . length ( ) ; String result = " ▁ " ; for ( String word : dict ) { if ( check ( pattern , word ) ) { result = word + " ▁ " + result ; } } System . out . print ( result ) ; } public static void main ( String [ ] args ) { HashSet < String > dict = new HashSet < String > ( ) ; dict . add ( " abb " ) ; dict . add ( " abc " ) ; dict . add ( " xyz " ) ; dict . add ( " xy@@ y " ) ; String pattern = " foo " ; find@@ Matched@@ Words ( dict , pattern ) ; } }
class GF@@ G { static String int@@ To@@ Roman ( int num ) { String m [ ] = { " " , " M " , " MM " , " MMM " } ; String c [ ] = { " " , " C " , " CC " , " CC@@ C " , " CD " , " D " , " DC " , " D@@ CC " , " D@@ CC@@ C " , " CM " } ; String x [ ] = { " " , " X " , " XX " , " XXX " , " X@@ L " , " L " , " L@@ X " , " L@@ XX " , " L@@ XXX " , " X@@ C " } ; String i [ ] = { " " , " I " , " II " , " III " , " IV " , " V " , " VI " , " VI@@ I " , " VI@@ II " , " IX " } ; String thous@@ ands = m [ num / 1000 ] ; String hun@@ dere@@ ds = c [ ( num % 1000 ) / 100 ] ; String ten@@ s = x [ ( num % 100 ) / 10 ] ; String ones = i [ num % 10 ] ; String ans = thous@@ ands + hun@@ dere@@ ds + ten@@ s + ones ; return ans ; } public static void main ( String [ ] args ) { int number = 35@@ 49 ; System . out . println ( int@@ To@@ Roman ( number ) ) ; } }
import java . lang . * ; class Solution { private static String zig@@ Z@@ ag@@ Concat ( String s , int n ) { if ( n <= 1 ) { return s ; } StringBuilder result = new StringBuilder ( ) ; for ( int row@@ Num = 0 ; row@@ Num < n ; row@@ Num ++ ) { int i = row@@ Num ; boolean up = true ; while ( i < s . length ( ) ) { result = result . append ( s . charAt ( i ) ) ; if ( row@@ Num == 0 row@@ Num == n - 1 ) { i += ( 2 * n - 2 ) ; } else { if ( up ) { i += ( 2 * ( n - row@@ Num ) - 2 ) ; } else { i += row@@ Num * 2 ; } up ^= true ; } } } return result . toString ( ) ; } public static void main ( String [ ] args ) { String str = " GE@@ EK@@ S@@ FOR@@ GE@@ E@@ KS " ; int n = 3 ; System . out . println ( zig@@ Z@@ ag@@ Concat ( str , n ) ) ; } }
import java . io . * ; import java . lang . * ; import java . util . * ; class GF@@ G { static int maximum@@ XOR ( int arr [ ] , int n , int K ) { K ++ ; int max@@ Xor = Integer . MIN_VALUE ; for ( int i = 0 ; i < ( 1 << n ) ; i ++ ) { if ( Integer . bit@@ Count ( i ) == K ) { int cur_@@ xor = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( i & ( 1 << j ) ) != 0 ) cur_@@ xor = cur_@@ xor ^ arr [ j ] ; } max@@ Xor = Math . max ( max@@ Xor , cur_@@ xor ) ; } } return max@@ Xor ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int N = arr . length ; int M = 2 ; System . out . println ( maximum@@ XOR ( arr , N , M ) ) ; } }
class GF@@ G { static void Tower@@ Of@@ H@@ ano@@ i ( int N ) { for ( int x = 1 ; x <= Math . pow ( 2 , N ) - 1 ; x ++ ) { System . out . print ( " Move ▁ from ▁ Ro@@ d ▁ " + ( ( x & x - 1 ) % 3 + 1 ) + " ▁ to ▁ Ro@@ d ▁ " + ( ( ( x x - 1 ) + 1 ) % 3 + 1 ) + "@@ NEW_@@ LINE@@ "@@ )@@ ; } } public static void main ( String [ ] args ) { int N = 3 ; Tower@@ Of@@ H@@ ano@@ i ( N ) ; } }
import java . util . * ; class GF@@ G { static boolean isValid ( int [ ] [ ] board , int i , int j , int K ) { if ( board [ i ] [ j ] <= K ) { return true ; } return false ; } static boolean find@@ Path ( int [ ] [ ] board , int X , int Y , int M , int N , int K ) { if ( X < 0 X == M Y < 0 Y == N ) { return true ; } if ( isValid ( board , X , Y , K ) ) { int board_@@ XY = board [ X ] [ Y ] ; board [ X ] [ Y ] = Integer . MAX_VALUE ; if ( find@@ Path ( board , X + 1 , Y , M , N , K - board_@@ XY ) || find@@ Path ( board , X - 1 , Y , M , N , K - board_@@ XY ) || find@@ Path ( board , X , Y + 1 , M , N , K - board_@@ XY ) || find@@ Path ( board , X , Y - 1 , M , N , K - board_@@ XY ) ) { return true ; } board [ X ] [ Y ] = board_@@ XY ; } return false ; } public static void main ( String [ ] args ) { int [ ] [ ] grid = { { 25 , 5 , 25 , 25 , 25 , 25 } , { 25 , 1 , 1 , 5 , 12 , 25 } , { 25 , 1 , 12 , 0 , 15 , 25 } , { 22 , 1 , 11 , 2 , 19 , 15 } , { 25 , 2 , 2 , 1 , 12 , 15 } , { 25 , 9 , 10 , 1 , 11 , 25 } , { 25 , 25 , 25 , 25 , 25 , 25 } } ; int K = 17 ; int M = grid . length ; int N = grid [ 0 ] . length ; int X = 2 , Y = 3 ; if ( find@@ Path ( grid , X , Y , M , N , K ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; import java . lang . * ; public class GF@@ G { static void solve ( int N , int P1 , int P2 , int X , int Move , boolean Quit@@ P1 , boolean Quit@@ P2 ) { if ( N == 0 || ( Quit@@ P1 && Quit@@ P2 ) ) { System . out . println ( " Number ▁ of ▁ p@@ ens ▁ remaining " + " ▁ in ▁ the ▁ box : ▁ " + N ) ; System . out . println ( " Number ▁ of ▁ p@@ ens ▁ collected " + " ▁ by ▁ P1 : ▁ " + P1 ) ; System . out . println ( " Number ▁ of ▁ p@@ ens ▁ collected " + " ▁ by ▁ P2 : ▁ " + P2 ) ; return ; } if ( Move == 0 && Quit@@ P1 == false ) { int req_@@ P1 = ( int ) ( Math . pow ( 2 , X ) ) ; if ( req_@@ P1 <= N ) { P1 += req_@@ P1 ; N -= req_@@ P1 ; } else { Quit@@ P1 = true ; } } else if ( Move == 1 && Quit@@ P2 == false ) { int req_@@ P2 = ( int ) ( Math . pow ( 3 , X ) ) ; if ( req_@@ P2 <= N ) { P2 += req_@@ P2 ; N -= req_@@ P2 ; } else { Quit@@ P2 = true ; } } X ++ ; Move = ( ( Move == 1 ) ? 0 : 1 ) ; solve ( N , P1 , P2 , X , Move , Quit@@ P1 , Quit@@ P2 ) ; } static void Pen@@ Game ( int N ) { int P1 = 0 ; int P2 = 0 ; int X = 0 ; int Move = 0 ; boolean Quit@@ P1 = false ; boolean Quit@@ P2 = false ; solve ( N , P1 , P2 , X , Move , Quit@@ P1 , Quit@@ P2 ) ; } public static void main ( String [ ] args ) { int N = 22 ; Pen@@ Game ( N ) ; } }
import java . util . * ; class GF@@ G { static boolean can@@ Place ( int a [ ] , int n , int p , int sep ) { int pri@@ son@@ er@@ s_@@ placed = 1 ; int last_@@ pri@@ son@@ er_@@ placed = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { int current_@@ cell = a [ i ] ; if ( current_@@ cell - last_@@ pri@@ son@@ er_@@ placed >= sep ) { pri@@ son@@ er@@ s_@@ placed ++ ; last_@@ pri@@ son@@ er_@@ placed = current_@@ cell ; if ( pri@@ son@@ er@@ s_@@ placed == p ) { return true ; } } } return false ; } static int max@@ Distance ( int cell [ ] , int n , int p ) { Arrays . sort ( cell ) ; int start = 0 ; int end = cell [ n - 1 ] - cell [ 0 ] ; int ans = 0 ; while ( start <= end ) { int mid = start + ( ( end - start ) / 2 ) ; if ( can@@ Place ( cell , n , p , mid ) ) { ans = mid ; start = mid + 1 ; } else { end = mid - 1 ; } } return ans ; } public static void main ( String [ ] args ) { int cell [ ] = { 1 , 2 , 8 , 4 , 9 } ; int n = cell . length ; int p = 3 ; System . out . println ( max@@ Distance ( cell , n , p ) ) ; } }
class GF@@ G { static int maxLen = 30 ; static int [ ] seg = new int [ 3 * maxLen ] ; static int build ( int l , int r , int in , int [ ] arr ) { if ( l == r ) return seg [ in ] = arr [ l ] ; int mid = ( l + r ) / 2 ; return seg [ in ] = __@@ gcd ( build ( l , mid , 2 * in + 1 , arr ) , build ( mid + 1 , r , 2 * in + 2 , arr ) ) ; } static int query ( int l , int r , int l1 , int r1 , int in ) { if ( l1 <= l && r <= r1 ) return seg [ in ] ; if ( l > r1 r < l1 ) return 0 ; int mid = ( l + r ) / 2 ; return __@@ gcd ( query ( l , mid , l1 , r1 , 2 * in + 1 ) , query ( mid + 1 , r , l1 , r1 , 2 * in + 2 ) ) ; } static int find@@ Len ( int [ ] arr , int n ) { build ( 0 , n - 1 , 0 , arr ) ; int i = 0 , j = 0 ; int ans = Integer . MAX_VALUE ; while ( i < n ) { while ( j < n && query ( 0 , n - 1 , i , j , 0 ) != 1 ) j ++ ; if ( j == n ) break ; ans = Math . min ( ( j - i + 1 ) , ans ) ; i ++ ; j = Math . max ( j , i ) ; } if ( ans == Integer . MAX_VALUE ) return - 1 ; else return ans ; } static int __@@ gcd ( int a , int b ) { return b == 0 ? a : __@@ gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 2 , 2 } ; int n = arr . length ; System . out . println ( find@@ Len ( arr , n ) ) ; } }
import java . util . * ; class GF@@ G { static void find@@ Area ( double a , double b , double c ) { double area = 4 * 3.1415@@ 9265@@ 3 * Math . pow ( ( Math . pow ( a * b , 1.6 ) + Math . pow ( a * c , 1.6 ) + Math . pow ( b * c , 1.6 ) ) / 3 , 1 / 1.6 ) ; System . out . print ( String . format ( " % .2f " , area ) ) ; } public static void main ( String [ ] args ) { double A = 11 , B = 12 , C = 13 ; find@@ Area ( A , B , C ) ; } }
import java . io . * ; class GF@@ G { static double find@@ Radius ( double r1 , double r2 , double r3 ) { double r4 = ( r1 * r2 * r3 ) / ( r1 * r2 + r2 * r3 + r1 * r3 + 2.0 * Math . sqrt ( r1 * r2 * r3 * ( r1 + r2 + r3 ) ) ) ; return r4 ; } public static void main ( String [ ] args ) { double r1 = 1 ; double r2 = 1 ; double r3 = 1 ; double r4 = find@@ Radius ( r1 , r2 , r3 ) ; System . out . println ( " The ▁ radius ▁ of ▁ fourth ▁ circle : ▁ " + r4 ) ; } }
import java . io . * ; import java . util . Arrays ; class GF@@ G { public static int minimum@@ Rectangle@@ Area ( int A [ ] , int N ) { int ans ; Arrays . sort ( A ) ; ans = ( A [ N - 1 ] - A [ 0 ] ) * ( A [ 2 * N - 1 ] - A [ N ] ) ; for ( int i = 1 ; i < N ; i ++ ) ans = Math . min ( ans , ( A [ 2 * N - 1 ] - A [ 0 ] ) * ( A [ i + N - 1 ] - A [ i ] ) ) ; return ans ; } public static void main ( String [ ] args ) { int A [ ] = { 2 , 4 , 1 , 5 , 3 , 6 , 7 , 8 } ; int N = A . length ; N = ( int ) N / 2 ; System . out . println ( minimum@@ Rectangle@@ Area ( A , N ) ) ; } }
import java . util . * ; class GF@@ G { static double ec@@ c@@ Hyper@@ bo@@ la ( double A , double B ) { double r = ( double ) B * B / A * A ; r += 1 ; return Math . sqrt ( r ) ; } public static void main ( String [ ] args ) { double A = 3.0 , B = 2.0 ; System . out . print ( ec@@ c@@ Hyper@@ bo@@ la ( A , B ) ) ; } }
import java . io . * ; class GF@@ G { static float calculate@@ Area ( float A , float B , float C , float D ) { float S = ( A + B + C + D ) / 2 ; float area = ( float ) Math . sqrt ( ( S - A ) * ( S - B ) * ( S - C ) * ( S - D ) ) ; return area ; } public static void main ( String [ ] args ) { float A = 10 ; float B = 15 ; float C = 20 ; float D = 25 ; System . out . println ( calculate@@ Area ( A , B , C , D ) ) ; } }
import java . io . * ; import java . util . * ; class GF@@ G { static int total@@ Cir@@ cles ( int L , int B ) { if ( L > B ) { int temp = L ; L = B ; B = temp ; } return B / L ; } public static void main ( String [ ] args ) { int L = 3 ; int B = 8 ; System . out . print ( total@@ Cir@@ cles ( L , B ) ) ; } }
import java . util . * ; class GF@@ G { static double find@@ Radius ( double r1 , double r2 ) { double a1 , a2 , a3 , r3 ; a1 = 3.14 * r1 * r1 ; a2 = 3.14 * r2 * r2 ; a3 = a1 + a2 ; r3 = Math . sqrt ( a3 / 3.14 ) ; return r3 ; } public static void main ( String [ ] args ) { double r1 = 8 , r2 = 6 ; System . out . println ( ( int ) find@@ Radius ( r1 , r2 ) ) ; } }
import java . util . * ; class GF@@ G { static int find_@@ l@@ cm ( int a , int b , int c ) { int g = __@@ gcd ( a , b ) ; int L@@ CM@@ 1 = ( a * b ) / g ; g = __@@ gcd ( L@@ CM@@ 1 , c ) ; int LC@@ M = ( L@@ CM@@ 1 * c ) / g ; return LC@@ M ; } static void minimum@@ Cu@@ bo@@ ids ( int L , int B , int H ) { int l@@ cm = find_@@ l@@ cm ( L , B , H ) ; int volume_@@ cube = l@@ cm * l@@ cm * l@@ cm ; int volume_@@ cu@@ bo@@ id = L * B * H ; System . out . print ( ( volume_@@ cube / volume_@@ cu@@ bo@@ id ) ) ; } static int __@@ gcd ( int a , int b ) { return b == 0 ? a : __@@ gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { int L = 1 , B = 1 , H = 2 ; minimum@@ Cu@@ bo@@ ids ( L , B , H ) ; } }
class GF@@ G { static int Cross@@ Product ( int A [ ] [ ] ) { int X1 = ( A [ 1 ] [ 0 ] - A [ 0 ] [ 0 ] ) ; int Y1 = ( A [ 1 ] [ 1 ] - A [ 0 ] [ 1 ] ) ; int X2 = ( A [ 2 ] [ 0 ] - A [ 0 ] [ 0 ] ) ; int Y2 = ( A [ 2 ] [ 1 ] - A [ 0 ] [ 1 ] ) ; return ( X1 * Y2 - Y1 * X2 ) ; } static boolean is@@ Con@@ vex ( int points [ ] [ ] ) { int N = points . length ; int prev = 0 ; int curr = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int temp [ ] [ ] = { points [ i ] , points [ ( i + 1 ) % N ] , points [ ( i + 2 ) % N ] } ; curr = Cross@@ Product ( temp ) ; if ( curr != 0 ) { if ( curr * prev < 0 ) { return false ; } else { prev = curr ; } } } return true ; } public static void main ( String [ ] args ) { int points [ ] [ ] = { { 0 , 0 } , { 0 , 1 } , { 1 , 1 } , { 1 , 0 } } ; if ( is@@ Con@@ vex ( points ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
import java . util . * ; class GF@@ G { static double distance ( int r , int R ) { double d = Math . sqrt ( Math . pow ( R , 2 ) - ( 2 * r * R ) ) ; return d ; } public static void main ( String [ ] args ) { int r = 2 ; int R = 5 ; System . out . println ( Math . round ( distance ( r , R ) * 100.0 ) / 100.0 ) ; } }
import java . io . * ; class GF@@ G { static double min@@ An@@ gl@@ Rot ( int N ) { double res ; res = 360 / ( double ) N ; return res ; } public static void main ( String [ ] args ) { int N = 4 ; System . out . println ( " Angle ▁ of ▁ Rot@@ ational ▁ Sym@@ metry : ▁ " + min@@ An@@ gl@@ Rot ( N ) ) ; } }
class GF@@ G { static double Area@@ _@@ of_@@ Triangle ( int a , int b , int c ) { int s = ( a + b + c ) / 2 ; int x = s * ( s - a ) ; x = x * ( s - b ) ; x = x * ( s - c ) ; double area = ( 4 / ( double ) 3 ) * Math . sqrt ( x ) ; return area ; } public static void main ( String [ ] args ) { int a = 9 ; int b = 12 ; int c = 15 ; double ans = Area@@ _@@ of_@@ Triangle ( a , b , c ) ; System . out . println ( ans ) ; } }
class GF@@ G { static boolean is@@ Tri@@ dec@@ ag@@ on ( int N ) { float n = ( float ) ( ( 9 + Math . sqrt ( 88 * N + 81 ) ) / 22 ) ; return ( n - ( int ) n ) == 0 ; } public static void main ( String [ ] args ) { int i = 13 ; if ( is@@ Tri@@ dec@@ ag@@ on ( i ) ) { System . out . print ( " Yes " ) ; } else { System . out . print ( " No " ) ; } } }
class GF@@ G { static boolean check@@ Overlap ( int R , int X@@ c , int Y@@ c , int X1 , int Y1 , int X2 , int Y2 ) { int X@@ n = Math . max ( X1 , Math . min ( X@@ c , X2 ) ) ; int Y@@ n = Math . max ( Y1 , Math . min ( Y@@ c , Y2 ) ) ; int D@@ x = X@@ n - X@@ c ; int D@@ y = Y@@ n - Y@@ c ; return ( D@@ x * D@@ x + D@@ y * D@@ y ) <= R * R ; } public static void main ( String [ ] args ) { int R = 1 ; int X@@ c = 0 , Y@@ c = 0 ; int X1 = 1 , Y1 = - 1 ; int X2 = 3 , Y2 = 1 ; if ( check@@ Overlap ( R , X@@ c , Y@@ c , X1 , Y1 , X2 , Y2 ) ) { System . out . print ( " True " + "@@ NEW_@@ LINE@@ "@@ )@@ ; } else { System . out . print ( " False " ) ; } } }
class GF@@ G { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static int check@@ Intersection ( pair p1 , pair p2 , pair p ) { int val ; if ( p1 . second == p2 . second && p1 . second == p . second ) { if ( p . first <= Math . max ( p1 . first , p2 . first ) && ( p . first >= Math . min ( p1 . first , p2 . first ) ) ) return 1 ; } if ( p1 . first == p2 . first && p1 . first == p . first ) { if ( p . second <= Math . max ( p1 . second , p2 . second ) && ( p . second >= Math . min ( p1 . second , p2 . second ) ) ) return 1 ; } else { val = ( p . second - p1 . second ) * ( p2 . first - p1 . first ) - ( p . first - p1 . first ) * ( p2 . second - p1 . second ) ; if ( val == 0 ) if ( ( p . first <= Math . max ( p1 . first , p2 . first ) && ( p . first >= Math . min ( p1 . first , p2 . first ) ) ) && ( p . second <= Math . max ( p1 . second , p2 . second ) && ( p . second >= Math . min ( p1 . second , p2 . second ) ) ) ) return 1 ; } return 0 ; } static void to@@ wer@@ OfS@@ ight ( pair a , pair b , pair c , pair d ) { int flag = 0 ; if ( check@@ Intersection ( a , c , b ) == 1 ) flag = 1 ; else if ( check@@ Intersection ( a , c , d ) == 1 ) flag = 1 ; else if ( check@@ Intersection ( b , d , a ) == 1 ) flag = 1 ; else if ( check@@ Intersection ( b , d , c ) == 1 ) flag = 1 ; System . out . print ( flag == 1 ? "@@ Yes " : " No "@@ )@@ ; } public static void main ( String [ ] args ) { pair a = new pair ( 0 , 0 ) ; pair b = new pair ( 0 , - 2 ) ; pair c = new pair ( 2 , 0 ) ; pair d = new pair ( 0 , 2 ) ; to@@ wer@@ OfS@@ ight ( a , b , c , d ) ; } }
class GF@@ G { static double area ( int R ) { double base = 1.7@@ 32 * R ; double height = ( 1.5 ) * R ; double area = 0.5 * base * height ; return area ; } public static void main ( String [ ] args ) { int R = 7 ; System . out . println ( area ( R ) ) ; } }
class GF@@ G { static int count@@ Pairs ( int [ ] P , int [ ] Q , int N , int M ) { int [ ] A = new int [ 2 ] , B = new int [ 2 ] ; for ( int i = 0 ; i < N ; i ++ ) A [ P [ i ] % 2 ] ++ ; for ( int i = 0 ; i < M ; i ++ ) B [ Q [ i ] % 2 ] ++ ; return ( A [ 0 ] * B [ 0 ] + A [ 1 ] * B [ 1 ] ) ; } public static void main ( String [ ] args ) { int [ ] P = { 1 , 3 , 2 } ; int [ ] Q = { 3 , 0 } ; int N = P . length ; int M = Q . length ; System . out . print ( count@@ Pairs ( P , Q , N , M ) ) ; } }
class GF@@ G { static void new_@@ vol ( double x ) { if ( x > 0 ) { System . out . print ( " % ▁ change ▁ in ▁ the ▁ " + " volume ▁ of ▁ the ▁ he@@ mi@@ sphere : ▁ " + ( Math . pow ( x , 3 ) / 10000 + 3 * x + ( 3 * Math . pow ( x , 2 ) ) / 100 ) + " % " + " increase@@ NEW_@@ LINE@@ "@@ )@@ ; } else if ( x < 0 ) { System . out . print ( " % ▁ change ▁ in ▁ the ▁ " + " volume ▁ of ▁ the ▁ he@@ mi@@ sphere : ▁ " + ( Math . pow ( x , 3 ) / 10000 + 3 * x + ( 3 * Math . pow ( x , 2 ) ) / 100 ) + "@@ % dec@@ rease@@ NEW_@@ LINE@@ "@@ )@@ ; } else { System . out . print ( " Volume ▁ remains ▁ the ▁ same . " ) ; } } public static void main ( String [ ] args ) { double x = - 10.0 ; new_@@ vol ( x ) ; } }
class GF@@ G { static int count@@ Intersections ( int n ) { return n * ( n - 1 ) / 2 ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( count@@ Intersections ( n ) ) ; } }
class GF@@ G { static float Area ( int d , int h1 , int h2 ) { float area ; area = ( float ) 0.5 * d * ( h1 + h2 ) ; return area ; } public static void main ( String [ ] args ) { int d = 6 , h1 = 4 , h2 = 3 ; System . out . println ( " Area ▁ of ▁ Quad@@ ri@@ later@@ al ▁ = ▁ " + Area ( d , h1 , h2 ) ) ; } }
import java . io . * ; class GF@@ G { static void angle@@ ext@@ cy@@ c@@ quad ( int z ) { System . out . print ( " The ▁ exter@@ ior ▁ angle ▁ of ▁ the " + " ▁ cyclic ▁ quad@@ ri@@ later@@ al ▁ is ▁ " + z + " ▁ degrees " ) ; } public static void main ( String [ ] args ) { int z = 48 ; angle@@ ext@@ cy@@ c@@ quad ( z ) ; } }
import java . io . * ; import java . util . * ; class GF@@ G { static boolean is@@ Perf@@ ect ( int N ) { int sum@@ Of@@ Di@@ visors = 1 ; for ( int i = 2 ; i <= N / 2 ; ++ i ) { if ( N % i == 0 ) { sum@@ Of@@ Di@@ visors += i ; } } if ( sum@@ Of@@ Di@@ visors == N ) { return true ; } else return false ; } static int sum@@ Of@@ Digits ( int N ) { int sum = 0 ; while ( N != 0 ) { sum += ( N % 10 ) ; N = N / 10 ; } return sum ; } static void count@@ Per@@ fec@@ t@@ Numbers ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; ++ i ) { if ( is@@ Perf@@ ect ( arr [ i ] ) ) { int sum = sum@@ Of@@ Digits ( arr [ i ] ) ; if ( is@@ Perf@@ ect ( sum ) ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } } } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 8 , 12 , 28 , 6 } ; int N = arr . length ; count@@ Per@@ fec@@ t@@ Numbers ( arr , N ) ; } }
import java . util . * ; class GF@@ G { static void fi@@ zz@@ Bu@@ zz ( int N ) { int count@@ 3 = 0 ; int count@@ 5 = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { count@@ 3 ++ ; count@@ 5 ++ ; boolean flag = false ; if ( count@@ 3 == 3 ) { System . out . print ( " Fi@@ zz " ) ; count@@ 3 = 0 ; flag = true ; } if ( count@@ 5 == 5 ) { System . out . print ( " Bu@@ zz " ) ; count@@ 5 = 0 ; flag = true ; } if ( ! flag ) { System . out . print ( i ) ; } System . out . print ( " ▁ " ) ; } } public static void main ( String [ ] args ) { int N = 15 ; fi@@ zz@@ Bu@@ zz ( N ) ; } }
import java . util . * ; class GF@@ G { static int count@@ Pairs ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( a [ j ] != 0 && a [ i ] % a [ j ] == 0 ) { if ( ( a [ i ] + a [ j ] ) == ( a [ i ] / a [ j ] ) ) count ++ ; } } } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { - 4 , - 3 , 0 , 2 , 1 } ; int N = arr . length ; System . out . print ( count@@ Pairs ( arr , N ) ) ; } }
import java . io . * ; class GF@@ G { static int numberOf@@ Tiles ( int n , int m ) { if ( n % 2 == 1 ) { return - 1 ; } return ( m * n ) / 2 ; } public static void main ( String [ ] args ) { int n = 2 , m = 4 ; System . out . println ( numberOf@@ Tiles ( n , m ) ) ; } }
import java . util . * ; class GF@@ G { static void check@@ Same@@ Position ( int [ ] arr , int n ) { Map < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int temp = ( ( i + arr [ i ] ) % n + n ) % n ; if ( mp . get ( temp ) == null ) { System . out . println ( " Yes " ) ; return ; } mp . get ( temp + 1 ) ; } System . out . println ( " No " ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 5 , 4 , 3 } ; int N = arr . length ; check@@ Same@@ Position ( arr , N ) ; } }
import java . util . * ; class GF@@ G { static void convertTo@@ ASCII ( int N ) { String num = Integer . toString ( N ) ; for ( char ch : num . toCharArray ( ) ) { System . out . print ( ch + " ▁ ( " + ( int ) ch + "@@ )@@ NEW_@@ LINE@@ "@@ )@@ ; } } public static void main ( String [ ] args ) { int N = 36 ; convertTo@@ ASCII ( N ) ; } }
import java . util . * ; class GF@@ G { static void check@@ Possible ( int [ ] arr , int n ) { for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { System . out . print ( "@@ No@@ NEW_@@ LINE@@ "@@ )@@ ; return ; } else { arr [ i ] -= arr [ i - 1 ] ; arr [ i - 1 ] = 0 ; } } if ( arr [ n - 1 ] == 0 ) { System . out . print ( "@@ Yes@@ NEW_@@ LINE@@ "@@ )@@ ; } else { System . out . print ( "@@ No@@ NEW_@@ LINE@@ "@@ )@@ ; } } public static void main ( String args [ ] ) { int arr [ ] = { 2 , 3 , 3 , 4 , 2 } ; int N = arr . length ; check@@ Possible ( arr , N ) ; } }
class GF@@ G { static void single@@ Digit@@ Sub@@ array@@ Count ( int arr [ ] , int N ) { int res = 0 ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] <= 9 ) { count ++ ; res += count ; } else { count = 0 ; } } System . out . print ( res ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 0 , 1 , 14 , 2 , 5 } ; int N = arr . length ; single@@ Digit@@ Sub@@ array@@ Count ( arr , N ) ; } }
import java . io . * ; class GF@@ G { static int Fact ( int N ) { int result = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { result = ( result * i ) ; } return result ; } static void numberOf@@ W@@ ays ( int M , int [ ] arr , int N ) { int [ ] B = new int [ M ] ; int [ ] counter = new int [ M + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] != 0 ) { if ( B [ i % M ] == 0 ) { B [ i % M ] = arr [ i ] ; counter [ arr [ i ] ] ++ ; if ( counter [ arr [ i ] ] > 1 ) { System . out . println ( 0 ) ; return ; } } else if ( B [ i % M ] != arr [ i ] ) { System . out . println ( 0 ) ; return ; } } } int cnt = 0 ; for ( int i = 0 ; i < M ; i ++ ) { if ( B [ i ] == 0 ) { cnt ++ ; } } System . out . println ( Fact ( cnt ) ) ; } public static void main ( String [ ] args ) { int M = 4 ; int [ ] arr = new int [ ] { 1 , 0 , 3 , 0 , 0 } ; int N = arr . length ; numberOf@@ W@@ ays ( M , arr , N ) ; } }
class GF@@ G { static void noOf@@ Array@@ s@@ Possible ( int N , int M ) { int ans = 1 ; for ( int i = 0 ; i < N ; ++ i ) { ans = ans * ( M - i ) ; } System . out . print ( ans ) ; } public static void main ( String [ ] args ) { int N = 2 , M = 3 ; noOf@@ Array@@ s@@ Possible ( N , M ) ; } }
class GF@@ G { static int Minimum@@ Operation@@ Req ( int N ) { int cnt@@ Dec@@ r = 0 ; int temp = N ; while ( temp > 0 ) { int X = ( int ) Math . sqrt ( temp ) ; if ( X * X == temp ) { break ; } temp = temp - 2 ; cnt@@ Dec@@ r += 1 ; } int cnt@@ In@@ cr = 0 ; while ( true ) { int X = ( int ) Math . sqrt ( N ) ; if ( X * X == N ) { break ; } N = N + 2 ; cnt@@ In@@ cr += 1 ; } return Math . min ( cnt@@ In@@ cr , cnt@@ Dec@@ r ) ; } public static void main ( String args [ ] ) { int N = 15 ; System . out . print ( Minimum@@ Operation@@ Req ( N ) ) ; } }
import java . util . * ; class GF@@ G { static int max@@ Disconnected ( int N , int E ) { int curr = 1 ; int rem = E ; while ( rem > 0 ) { rem = rem - Math . min ( curr , rem ) ; curr ++ ; } if ( curr > 1 ) { return N - curr ; } else { return N ; } } public static void main ( String [ ] args ) { int N = 5 , E = 1 ; System . out . print ( max@@ Disconnected ( N , E ) ) ; } }
import java . util . * ; class GF@@ G { static boolean is@@ Prime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static String delete@@ I@@ th ( String str , int i ) { str = str . substring ( 0 , i ) + str . substring ( i + 1 ) ; return str ; } static boolean is@@ Prime@@ Possible ( int N ) { String s = String . valueOf ( N ) ; int l = s . length ( ) ; if ( l < 2 ) return false ; for ( int i = 0 ; i < l ; i ++ ) { String str = delete@@ I@@ th ( s , i ) ; int num = Integer . valueOf ( str ) ; if ( is@@ Prime ( num ) ) return true ; } return false ; } public static void main ( String [ ] args ) { int N = 6@@ 10 ; if ( is@@ Prime@@ Possible ( N ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
import java . util . * ; class GF@@ G { static int Fin@@ d_@@ min ( HashSet < Integer > diff_@@ mod , HashMap < Integer , Integer > count_@@ mod , int k ) { int min_@@ op@@ rn = Integer . MAX_VALUE ; int op@@ rn = 0 ; for ( int x = 0 ; x < k ; x ++ ) { op@@ rn = 0 ; for ( int w : diff_@@ mod ) { if ( w != x ) { if ( w == 0 ) { op@@ rn += Math . min ( x , k - x ) * count_@@ mod . get ( w ) ; } else { op@@ rn += Math . min ( Math . abs ( x - w ) , k + x - w ) * count_@@ mod . get ( w ) ; } } } if ( op@@ rn < min_@@ op@@ rn ) min_@@ op@@ rn = op@@ rn ; } return min_@@ op@@ rn ; } static int C@@ al_@@ min ( int arr [ ] , int n , int k ) { HashSet < Integer > diff_@@ mod = new HashSet < > ( ) ; HashMap < Integer , Integer > count_@@ mod = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { diff_@@ mod . add ( arr [ i ] % k ) ; count_@@ mod . put ( arr [ i ] % k , count_@@ mod . getOr@@ Default ( arr [ i ] % k , 0 ) + 1 ) ; } return Fin@@ d_@@ min ( diff_@@ mod , count_@@ mod , k ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 35 , 48 , 23 , 52 } ; int n = arr . length ; int k = 3 ; System . out . print ( C@@ al_@@ min ( arr , n , k ) ) ; } }
import java . util . * ; class GF@@ G { static void inverse@@ Equal ( int arr [ ] , int n ) { int [ ] br@@ r = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int present_@@ index = arr [ i ] - 1 ; br@@ r [ present_@@ index ] = i + 1 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != br@@ r [ i ] ) { System . out . println ( " No " ) ; return ; } } System . out . println ( " Yes " ) ; } public static void main ( String [ ] args ) { int n = 4 ; int [ ] arr = { 1 , 4 , 3 , 2 } ; inverse@@ Equal ( arr , n ) ; } }
class GF@@ G { public static int Square@@ Root ( int num ) { int count = 0 ; for ( int n = 1 ; n <= num ; n += 2 ) { num = num - n ; count += 1 ; if ( num == 0 ) break ; } return count ; } public static void main ( String [ ] args ) { int N = 81 ; System . out . println ( Square@@ Root ( N ) ) ; } }
import java . util . * ; class GF@@ G { public static void find@@ Win@@ ner ( int n , int k ) { int cnt = 0 ; if ( n == 1 ) System . out . println ( " No " ) ; else if ( ( n & 1 ) != 0 n == 2 ) System . out . println ( " Yes " ) ; else { int tmp = n ; int val = 1 ; while ( tmp > k && tmp % 2 == 0 ) { tmp /= 2 ; val *= 2 ; } for ( int i = 3 ; i <= Math . sqrt ( tmp ) ; i ++ ) { while ( tmp % i == 0 ) { cnt ++ ; tmp /= i ; } } if ( tmp > 1 ) cnt ++ ; if ( val == n ) System . out . println ( " No " ) ; else if ( n / tmp == 2 && cnt == 1 ) System . out . println ( " No " ) ; else System . out . println ( " Yes " ) ; } } public static void main ( String [ ] args ) { int n = 1 , k = 1 ; find@@ Win@@ ner ( n , k ) ; } }
class GF@@ G { static int count_@@ cra@@ z@@ y_@@ primes ( int L , int R ) { int prime [ ] = new int [ R + 1 ] ; int count@@ Prime [ ] = new int [ R + 1 ] ; int freq@@ Prime [ ] = new int [ R + 1 ] ; prime [ 0 ] = 1 ; prime [ 1 ] = 1 ; for ( int p = 2 ; p * p <= R ; p ++ ) { if ( prime [ p ] == 0 ) { for ( int i = p * p ; i <= R ; i += p ) prime [ i ] = 1 ; } } for ( int i = 1 ; i <= R ; i ++ ) { count@@ Prime [ i ] = count@@ Prime [ i - 1 ] ; if ( prime [ i ] != 0 ) { count@@ Prime [ i ] ++ ; } } for ( int i = 1 ; i <= R ; i ++ ) { freq@@ Prime [ i ] = freq@@ Prime [ i - 1 ] ; if ( prime [ count@@ Prime [ i ] ] != 0 ) { freq@@ Prime [ i ] ++ ; } } return ( freq@@ Prime [ R ] - freq@@ Prime [ L - 1 ] ) ; } public static void main ( String [ ] args ) { int L = 4 , R = 12 ; System . out . println ( count_@@ cra@@ z@@ y_@@ primes ( L , R ) ) ; } }
import java . util . * ; class GF@@ G { static void compute ( int a [ ] , int N , int K ) { Map < Long , Long > eq@@ Val = new HashMap < Long , Long > ( ) ; long maxX = 0 ; for ( int i = 0 ; i < N ; i ++ ) { long val = a [ i ] % K ; val = ( val == 0 ? 0 : K - val ) ; if ( val == 0 ) continue ; if ( eq@@ Val . containsKey ( val ) ) { long num@@ Val = eq@@ Val . get ( val ) ; maxX = Math . max ( maxX , val + ( K * num@@ Val ) ) ; eq@@ Val . put ( val , eq@@ Val . getOr@@ Default ( val , 0l ) + 1l ) ; } else { eq@@ Val . put ( val , 1l ) ; maxX = Math . max ( maxX , val ) ; } } System . out . println ( maxX == 0 ? 0 : maxX + 1 ) ; } public static void main ( String [ ] args ) { int K = 3 ; int a [ ] = { 1 , 2 , 2 , 18 } ; int N = a . length ; compute ( a , N , K ) ; } }
class GF@@ G { static int getS@@ um ( int n ) { int sum = 0 ; while ( n != 0 ) { sum = sum + n % 10 ; n = n / 10 ; } return sum ; } static boolean is@@ Self@@ Num ( int n ) { for ( int m = 1 ; m <= n ; m ++ ) { if ( m + getS@@ um ( m ) == n ) return false ; } return true ; } public static void main ( String [ ] args ) { int n = 20 ; if ( is@@ Self@@ Num ( n ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
class GF@@ G { static int series@@ Sum@@ Util ( int k , int n , int prev@@ Sum , int multi , int add ) { if ( k == n + 1 ) { return prev@@ Sum ; } multi = multi * k ; add = add + k ; prev@@ Sum = prev@@ Sum + multi - add ; return series@@ Sum@@ Util ( k + 1 , n , prev@@ Sum , multi , add ) ; } static int series@@ Sum ( int n ) { if ( n == 1 ) return 0 ; int prev@@ Sum = 0 ; int multi = 1 ; int add = 1 ; return series@@ Sum@@ Util ( 2 , n , prev@@ Sum , multi , add ) ; } public static void main ( String [ ] args ) { int N = 5 ; System . out . println ( series@@ Sum ( N ) ) ; } }
class GF@@ G { static int getS@@ um ( int n ) { int sum = 0 ; while ( n != 0 ) { sum = sum + n % 10 ; n = n / 10 ; } return sum ; } static void smalle@@ st@@ Number ( int N ) { int i = 1 ; while ( 1 != 0 ) { if ( getS@@ um ( i ) == N ) { System . out . print ( i ) ; break ; } i ++ ; } } public static void main ( String [ ] args ) { int N = 10 ; smalle@@ st@@ Number ( N ) ; } }
class GF@@ G { static boolean is@@ zy@@ go@@ dro@@ me@@ Num ( int N ) { String s = Integer . toString ( N ) ; s = ' ▁ ' + s + ' ▁ ' ; for ( int i = 1 ; i < s . length ( ) - 1 ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( i - 1 ) && s . charAt ( i ) != s . charAt ( i + 1 ) ) { return false ; } } return true ; } public static void main ( String [ ] args ) { int n = 112@@ 2 ; if ( is@@ zy@@ go@@ dro@@ me@@ Num ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
public class ge@@ e@@ ks { public static int can@@ Replace ( int [ ] array ) { int i = 0 , count = 0 ; while ( i < array . length ) { if ( array [ i ] == 0 && ( i == 0 array [ i - 1 ] == 0 ) && ( i == array . length - 1 array [ i + 1 ] == 0 ) ) { array [ i ] = 1 ; count ++ ; } i ++ ; } return count ; } public static void main ( String [ ] args ) { int [ ] array = { 1 , 0 , 0 , 0 , 1 } ; System . out . println ( can@@ Replace ( array ) ) ; } }
class GF@@ G { static int Me@@ g@@ ag@@ on@@ Num ( int n ) { return ( 9999@@ 98 * n * n - 9999@@ 96 * n ) / 2 ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . print ( Me@@ g@@ ag@@ on@@ Num ( n ) ) ; } }
class GF@@ G { static int Te@@ trac@@ on@@ ta@@ oct@@ ag@@ onal@@ Num ( int n ) { return ( 46 * n * n - 44 * n ) / 2 ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . print ( Te@@ trac@@ on@@ ta@@ oct@@ ag@@ onal@@ Num ( n ) ) ; } }
class GF@@ G { static double find@@ Index ( int n ) { double x = Math . sqrt ( 2 * Math . pow ( 10 , ( n - 1 ) ) ) ; return Math . round ( x ) ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . print ( find@@ Index ( n ) ) ; } }
import java . util . * ; class GF@@ G { static void smalle@@ st@@ Number ( int N ) { System . out . print ( N * Math . floor ( ( Math . pow ( 10 , N ) - 1 ) / N ) ) ; } public static void main ( String args [ ] ) { int N = 2 ; smalle@@ st@@ Number ( N ) ; } }
class GF@@ G { static int ico@@ si@@ kai@@ he@@ p@@ tag@@ onal@@ Num ( int n ) { return ( 25 * n * n - 23 * n ) / 2 ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . print ( "3@@ rd ▁ ico@@ si@@ kai@@ he@@ p@@ tag@@ onal ▁ Number ▁ is ▁ " + ico@@ si@@ kai@@ he@@ p@@ tag@@ onal@@ Num ( n ) ) ; } }
class GF@@ G { static boolean ist@@ ri@@ ac@@ ont@@ ag@@ onal ( int N ) { float n = ( float ) ( ( 26 + Math . sqrt ( 224 * N + 67@@ 6 ) ) / 56 ) ; return ( n - ( int ) n ) == 0 ; } public static void main ( String [ ] args ) { int N = 30 ; if ( ist@@ ri@@ ac@@ ont@@ ag@@ onal ( N ) ) { System . out . print ( " Yes " ) ; } else { System . out . print ( " No " ) ; } } }
import java . util . * ; class GF@@ G { static void Max@@ length ( int arr [ ] , int N ) { Vector < Integer > zero@@ index = new Vector < Integer > ( ) ; int maxlen ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) zero@@ index . add ( i ) ; } if ( zero@@ index . size ( ) == 0 ) { maxlen = N ; } else { maxlen = ( int ) zero@@ index . get ( 0 ) ; for ( int i = 0 ; i < zero@@ index . size ( ) - 1 ; i ++ ) { if ( ( int ) zero@@ index . get ( i + 1 ) - ( int ) zero@@ index . get ( i ) - 1 > maxlen ) { maxlen = ( int ) zero@@ index . get ( i + 1 ) - ( int ) zero@@ index . get ( i ) - 1 ; } } if ( N - ( int ) zero@@ index . get ( zero@@ index . size ( ) - 1 ) - 1 > maxlen ) { maxlen = N - ( int ) zero@@ index . get ( zero@@ index . size ( ) - 1 ) - 1 ; } } System . out . println ( maxlen ) ; } public static void main ( String args [ ] ) { int N = 9 ; int arr [ ] = { 7 , 1 , 0 , 1 , 2 , 0 , 9 , 2 , 1 } ; Max@@ length ( arr , N ) ; } }
import java . util . * ; class GF@@ G { static void solve ( int n ) { for ( int x = 1 ; x <= Math . sqrt ( n ) ; x ++ ) { if ( n % x == 0 ) { int small = x ; int big = n / x ; if ( small % 2 == big % 2 ) { int a = ( small + big ) / 2 ; int b = ( big - small ) / 2 ; System . out . print ( a + " ▁ " + b ) ; return ; } } } System . out . print ( - 1 ) ; } public static void main ( String args [ ] ) { int n = 7 ; solve ( n ) ; } }
import java . util . * ; class GF@@ G { static int inv ( int a , int m ) { int m0 = m , t , q ; int x0 = 0 , x1 = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { q = a / m ; t = m ; m = a % m ; a = t ; t = x0 ; x0 = x1 - q * x0 ; x1 = t ; } if ( x1 < 0 ) x1 += m0 ; return x1 ; } static int derivative ( int x ) { return 3 * x * x ; } static int Image ( int x , int k ) { return x * x * x - k ; } static int next_@@ power ( int a@@ _t , int t , int a1 , int prime , int k ) { int power_@@ p = ( int ) Math . pow ( prime , t + 1 ) ; int next_@@ a = ( a@@ _t - Image ( a@@ _t , k ) * inv ( derivative ( a1 ) , prime ) ) % power_@@ p ; if ( next_@@ a < 0 ) return next_@@ a += power_@@ p ; return next_@@ a ; } static int power@@ Of@@ Prime ( int prime , int power , int k , int a1 ) { if ( derivative ( a1 ) != 0 ) { int a@@ _t = a1 ; for ( int p = 1 ; p < power ; p ++ ) { a@@ _t = next_@@ power ( a@@ _t , p , a1 , prime , k ) ; } return a@@ _t ; } return - 1 ; } public static void main ( String [ ] args ) { int prime = 7 , a1 = 3 ; int power = 2 , k = 3 ; System . out . print ( power@@ Of@@ Prime ( prime , power , k , a1 ) ) ; } }
import java . util . * ; class GF@@ G { static final int mod = 100000000@@ 7 ; static int product@@ Pairs ( int arr [ ] , int n ) { int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { product *= ( arr [ i ] % mod * arr [ j ] % mod ) % mod ; product = product % mod ; } } return product % mod ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 } ; int n = arr . length ; System . out . print ( product@@ Pairs ( arr , n ) ) ; } }
class GF@@ G { static int getMin@@ Steps ( int n , int jump ) { int quotient = n / jump ; int remainder = n % jump ; int steps = quotient + remainder ; return steps ; } public static void main ( String [ ] args ) { int N = 6 , K = 3 ; System . out . print ( getMin@@ Steps ( N , K ) ) ; } }
class GF@@ G { static boolean is@@ C@@ en@@ tered@@ non@@ a@@ dec@@ ag@@ onal ( int N ) { float n = ( float ) ( ( 19 + Math . sqrt ( 152 * N + 209 ) ) / 38 ) ; return ( n - ( int ) n ) == 0 ; } public static void main ( String [ ] args ) { int n = 20 ; if ( is@@ C@@ en@@ tered@@ non@@ a@@ dec@@ ag@@ onal ( n ) ) { System . out . print ( " Yes " ) ; } else { System . out . print ( " No " ) ; } } }
public class Main { public static void cnt@@ Array ( int A [ ] , int N ) { int result = 0 ; int [ ] frequency = new int [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { frequency [ A [ i ] ] ++ ; } for ( int i = 1 ; i <= N ; i ++ ) { int frequ@@ ency_@@ of_@@ i = frequency [ i ] ; result += ( ( frequ@@ ency_@@ of_@@ i ) * ( frequ@@ ency_@@ of_@@ i + 1 ) ) / 2 ; } System . out . println ( result ) ; } public static void main ( String [ ] args ) { int [ ] A = { 1 , 5 , 6 , 1 , 9 , 5 , 8 , 10 , 8 , 9 } ; int N = A . length ; cnt@@ Array ( A , N ) ; } }
import java . util . * ; class GF@@ G { static int sub@@ array ( int arr [ ] , int n ) { int ans = 1 , temp = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) { ++ temp ; } else { ans = Math . max ( ans , temp ) ; temp = 1 ; } } ans = Math . max ( ans , temp ) ; return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 2 , 1 , 1 , 2 , 2 , 2 , 3 , 3 } ; int n = arr . length ; System . out . print ( sub@@ array ( arr , n ) ) ; } }
import java . io . * ; import java . util . * ; class GF@@ G { static void find@@ Max@@ Min@@ Sub@@ Array ( int arr [ ] , int K , int n ) { int min = n ; int max = 0 ; int left ; int right ; int tmp ; for ( int i = 0 ; i < n ; i ++ ) { tmp = 1 ; left = i ; while ( left - 1 >= 0 && Math . abs ( arr [ left ] - arr [ left - 1 ] ) <= K ) { left -- ; tmp ++ ; } right = i ; while ( right + 1 <= n - 1 && Math . abs ( arr [ right ] - arr [ right + 1 ] ) <= K ) { right ++ ; tmp ++ ; } if ( min > tmp ) min = tmp ; if ( max < tmp ) max = tmp ; } System . out . print ( min ) ; System . out . print ( " , ▁ " ) ; System . out . print ( max ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 5 , 6 , 7 } ; int K = 2 ; int n = arr . length ; find@@ Max@@ Min@@ Sub@@ Array ( arr , K , n ) ; } }
class GF@@ G { static int minimum@@ Steps ( int a , int b , int c ) { if ( a < 1 b < 1 ) return - 1 ; if ( a == 1 && b == 1 ) return c ; if ( a < b ) { a = a + b ; b = a - b ; a = a - b ; } return minimum@@ Steps ( a - b , b , c + 1 ) ; } public static void main ( String [ ] args ) { int a = 75 ; int b = 17 ; System . out . println ( minimum@@ Steps ( a , b , 0 ) ) ; } }
class GF@@ G { static boolean is@@ Per@@ fec@@ t@@ Square ( double x ) { double sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; } static int count@@ Squ@@ ares ( int n ) { int cnt = 0 ; for ( int i = ( int ) Math . pow ( 10 , ( n - 1 ) ) ; i < Math . pow ( 10 , n ) ; i ++ ) { if ( i != 0 && is@@ Per@@ fec@@ t@@ Square ( i ) ) cnt ++ ; } return cnt ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . print ( count@@ Squ@@ ares ( n ) ) ; } }
import java . util . * ; class GF@@ G { static void print@@ Arr ( int n ) { if ( n % 4 == 0 ) { for ( int i = 1 ; i <= n / 2 ; i ++ ) System . out . print ( i * 2 + " ▁ " ) ; for ( int i = 1 ; i < n / 2 ; i ++ ) System . out . print ( i * 2 - 1 + " ▁ " ) ; System . out . println ( n + n / 2 - 1 ) ; } else System . out . print ( " - 1" ) ; } public static void main ( String [ ] args ) { int n = 22 ; print@@ Arr ( n ) ; } }
import java . util . Scanner ; class C@@ GP@@ A { public static double Cg@@ pa@@ Calc ( double [ ] marks , int n ) { double grade [ ] = new double [ n ] ; double c@@ gp@@ a , sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { grade [ i ] = ( marks [ i ] / 10 ) ; } for ( int i = 0 ; i < n ; i ++ ) { sum += grade [ i ] ; } c@@ gp@@ a = sum / n ; return c@@ gp@@ a ; } public static void main ( String args [ ] ) { int n = 5 ; double [ ] marks = { 90 , 80 , 70 , 80 , 90 } ; double c@@ gp@@ a = Cg@@ pa@@ Calc ( marks , n ) ; System . out . println ( " C@@ GP@@ A ▁ = ▁ " + c@@ gp@@ a ) ; System . out . println ( " C@@ GP@@ A ▁ Percentage ▁ = ▁ " + String . format ( " % .2f " , c@@ gp@@ a * 9.@@ 5 ) ) ; } }
class GF@@ G { public static Boolean check@@ Gold@@ en@@ Ratio ( float a , float b ) { if ( a <= b ) { float temp = a ; a = b ; b = temp ; } String rati@@ o1 = String . format ( " % .3f " , a / b ) ; String rati@@ o2 = String . format ( " % .3f " , ( a + b ) / a ) ; if ( rati@@ o1 . equals ( rati@@ o2 ) && rati@@ o1 . equals ( "1.@@ 618@@ " ) ) { System . out . println ( " Yes " ) ; return true ; } else { System . out . println ( " No " ) ; return false ; } } public static void main ( String [ ] args ) { float a = ( float ) 0.6@@ 18 ; float b = 1 ; check@@ Gold@@ en@@ Ratio ( a , b ) ; } }
class GF@@ G { static int min@@ Num ( int n , int k ) { int x = ( int ) ( Math . log ( n ) / Math . log ( k ) ) + 1 ; int mn = ( int ) ( Math . pow ( k , x ) - n ) ; return mn ; } public static void main ( String [ ] args ) { int n = 20 , k = 5 ; System . out . print ( min@@ Num ( n , k ) ) ; } }
import java . util . * ; class GF@@ G { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static int Cnt@@ cont@@ Sub@@ s ( int a [ ] , int n ) { int prod = 1 ; Vector < pair > vect = new Vector < pair > ( ) ; vect . add ( new pair ( 0 , 2 ) ) ; Vector < Integer > two = new Vector < Integer > ( ) ; Vector < Integer > zero = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = a [ i ] % 4 ; if ( a [ i ] < 0 ) a [ i ] = a [ i ] + 4 ; if ( a [ i ] == 2 ) two . add ( i + 1 ) ; if ( a [ i ] == 0 ) zero . add ( i + 1 ) ; if ( a [ i ] == 0 a [ i ] == 2 ) vect . add ( new pair ( i + 1 , a [ i ] ) ) ; } vect . add ( new pair ( n + 1 , 2 ) ) ; int total = ( n * ( n + 1 ) ) / 2 ; if ( two . isEmpty ( ) ) return total ; else { int sum = 0 ; int pos1 = - 1 , pos2 = - 1 , pos@@ 3 = - 1 ; int sz = vect . size ( ) ; for ( int i = 1 ; i + 1 < sz ; i ++ ) { if ( vect . get ( i ) . second == 2 ) { sum += ( vect . get ( i ) . first - vect . get ( i - 1 ) . first ) * ( vect . get ( i + 1 ) . first - vect . get ( i ) . first ) - 1 ; } } return total - sum - two . size ( ) ; } } public static void main ( String [ ] args ) { int a [ ] = { 5 , 4 , 2 , 9 , 8 } ; int n = a . length ; System . out . print ( Cnt@@ cont@@ Sub@@ s ( a , n ) ) ; } }
import java . util . * ; class GF@@ G { static int mod = 100000000@@ 7 ; static int count@@ Sub@@ sets ( int a [ ] , int n ) { int answer = 0 ; int [ ] power@@ Of@@ Two = new int [ 10000@@ 5 ] ; power@@ Of@@ Two [ 0 ] = 1 ; for ( int i = 1 ; i < 10000@@ 5 ; i ++ ) power@@ Of@@ Two [ i ] = ( power@@ Of@@ Two [ i - 1 ] * 2 ) % mod ; HashMap < Integer , Integer > frequency = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( frequency . containsKey ( a [ i ] ) ) { frequency . put ( a [ i ] , frequency . get ( a [ i ] ) + 1 ) ; } else { frequency . put ( a [ i ] , 1 ) ; } for ( Map . Entry < Integer , Integer > el : frequency . entrySet ( ) ) { if ( el . getKey ( ) != 0 ) answer = ( answer % mod + power@@ Of@@ Two [ el . getValue ( ) - 1 ] ) % mod ; else answer = ( answer % mod + power@@ Of@@ Two [ el . getValue ( ) ] - 1 + mod ) % mod ; } return answer ; } public static void main ( String [ ] args ) { int N = 6 ; int A [ ] = { 1 , 3 , 2 , 1 , 2 , 1 } ; System . out . print ( count@@ Sub@@ sets ( A , N ) ) ; } }
class GF@@ G { static long product ( int [ ] [ ] mat , int n ) { long d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { d1 += mat [ i ] [ i ] ; d2 += mat [ i ] [ n - i - 1 ] ; } return 1L * d1 * d2 ; } public static void main ( String [ ] args ) { int [ ] [ ] mat = { { 5 , 8 , 1 } , { 5 , 10 , 3 } , { - 6 , 17 , - 9 } } ; int n = mat . length ; System . out . print ( product ( mat , n ) ) ; } }
class GF@@ G { static int find@@ Sum ( int [ ] arr , int n , int left , int right ) { int k = right - left ; int d = arr [ 1 ] - arr [ 0 ] ; int ans = arr [ left - 1 ] * ( k + 1 ) ; ans = ans + ( d * ( k * ( k + 1 ) ) ) / 2 ; return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 6 , 8 , 10 , 12 , 14 , 16 } ; int queries = 3 ; int q [ ] [ ] = { { 2 , 4 } , { 2 , 6 } , { 5 , 6 } } ; int n = arr . length ; for ( int i = 0 ; i < queries ; i ++ ) System . out . print ( find@@ Sum ( arr , n , q [ i ] [ 0 ] , q [ i ] [ 1 ] ) + "@@ NEW_@@ LINE@@ "@@ )@@ ; } }
import java . util . * ; class GF@@ G { static boolean sub@@ array@@ Possible ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum <= 0 ) return true ; } sum = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { sum += arr [ i ] ; if ( sum <= 0 ) return true ; } return false ; } public static void main ( String args [ ] ) { int arr [ ] = { 10 , 5 , - 12 , 7 , - 10 , 20 , 30 , - 10 , 50 , 60 } ; int size = arr . length ; if ( sub@@ array@@ Possible ( arr , size ) ) System . out . print ( " Yes " + "@@ NEW_@@ LINE@@ "@@ )@@ ; else System . out . print ( " No " + "@@ NEW_@@ LINE@@ "@@ )@@ ; } }
class GF@@ G { static final int limit = 10000000 ; static int [ ] position = new int [ limit + 1 ] ; static void si@@ eve ( ) { position [ 0 ] = - 1 ; position [ 1 ] = - 1 ; int pos = 0 ; for ( int i = 2 ; i <= limit ; i ++ ) { if ( position [ i ] == 0 ) { position [ i ] = ++ pos ; for ( int j = i * 2 ; j <= limit ; j += i ) position [ j ] = - 1 ; } } } public static void main ( String [ ] args ) { si@@ eve ( ) ; int n = 11 ; System . out . print ( position [ n ] ) ; } }
class GF@@ G { static double max@@ Sub@@ Array@@ Sum ( double a [ ] , int size ) { double max_@@ so@@ _f@@ ar = Integer . MIN_VALUE , max_@@ ending_@@ here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_@@ ending_@@ here = max_@@ ending_@@ here + a [ i ] ; if ( max_@@ so@@ _f@@ ar < max_@@ ending_@@ here ) max_@@ so@@ _f@@ ar = max_@@ ending_@@ here ; if ( max_@@ ending_@@ here < 0 ) max_@@ ending_@@ here = 0 ; } return max_@@ so@@ _f@@ ar ; } static void min@@ Possible@@ Sum ( double a [ ] , int n , double x ) { double mx@@ Sum = max@@ Sub@@ Array@@ Sum ( a , n ) ; double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } sum = sum - mx@@ Sum + mx@@ Sum / x ; System . out . print ( sum + "@@ NEW_@@ LINE@@ "@@ )@@ ; } public static void main ( String [ ] args ) { int N = 3 ; double X = 2 ; double A [ ] = { 1 , - 2 , 3 } ; min@@ Possible@@ Sum ( A , N , X ) ; } }
import java . util . * ; class GF@@ G { public static int reverse ( int num ) { int rev_@@ num = 0 ; while ( num > 0 ) { rev_@@ num = rev_@@ num * 10 + num % 10 ; num = num / 10 ; } return rev_@@ num ; } public static int count@@ Reverse ( int arr [ ] , int n ) { HashMap < Integer , Integer > freq = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( freq . containsKey ( arr [ i ] ) ) { freq . replace ( arr [ i ] , freq . get ( arr [ i ] ) + 1 ) ; } else { freq . put ( arr [ i ] , 1 ) ; } } int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq . containsKey ( arr [ i ] ) ) { freq . replace ( arr [ i ] , freq . get ( arr [ i ] ) - 1 ) ; } else { freq . put ( arr [ i ] , - 1 ) ; } if ( freq . containsKey ( reverse ( arr [ i ] ) ) ) { res += freq . get ( reverse ( arr [ i ] ) ) ; } } return res ; } public static void main ( String [ ] args ) { int a [ ] = { 16 , 61 , 12 , 21 , 25 } ; int n = a . length ; System . out . println ( count@@ Reverse ( a , n ) ) ; } }
import java . util . * ; class GF@@ G { static void is@@ Possible ( int [ ] A , int n , int k ) { int count@@ Of@@ Two = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] % 2 == 0 ) { count@@ Of@@ Two ++ ; } } if ( k == 0 && count@@ Of@@ Two == n ) System . out . print ( " NO " ) ; else if ( count@@ Of@@ Two >= k ) { System . out . print ( " YES " ) ; } else System . out . print ( " No " ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 4 , 5 } ; int K = 2 ; int n = arr . length ; is@@ Possible ( arr , n , K ) ; } }
public class GF@@ G { final static int size = 100@@ 01 ; static int prime [ ] = new int [ size ] ; static int freq [ ] = new int [ size ] ; static void si@@ eve ( int a , int b ) { prime [ 1 ] = 1 ; for ( int i = 2 ; i * i < size ; i ++ ) { if ( prime [ i ] == 0 ) { for ( int j = i * 2 ; j < size ; j += i ) prime [ j ] = 1 ; } } for ( int p = 1 ; p < size ; p ++ ) { for ( int q = 1 ; q < size ; q ++ ) { if ( prime [ p ] == 0 && prime [ q ] == 0 && a * p + b * q < size ) { freq [ a * p + b * q ] ++ ; } } } } public static void main ( String [ ] args ) { int queries = 2 , a = 1 , b = 2 ; si@@ eve ( a , b ) ; int arr [ ] = { 15 , 25 } ; for ( int i = 0 ; i < queries ; i ++ ) { System . out . print ( freq [ arr [ i ] ] + " ▁ " ) ; } } }
class GF@@ G { static void print@@ Modul@@ us ( int X , int Y ) { int n = Math . max ( X , Y ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( X % i == Y % i ) System . out . print ( i + " ▁ " ) ; } } public static void main ( String [ ] args ) { int X , Y ; X = 10 ; Y = 20 ; print@@ Modul@@ us ( X , Y ) ; } }
import java . util . * ; class GF@@ G { static String check ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & 1 ) != 0 ) count ++ ; } if ( ( count & 1 ) != 0 ) return " Odd " ; else return " Even " ; } public static void main ( String args [ ] ) { int [ ] arr = { 3 , 9 , 12 , 13 , 15 } ; int n = arr . length ; System . out . println ( check ( arr , n ) ) ; } }
import java . util . * ; class GF@@ G { static boolean is@@ Di@@ visible ( int n ) { int d ; while ( ( n / 100 ) > 0 ) { d = n % 10 ; n /= 10 ; n = Math . abs ( n - ( d * 14 ) ) ; } return ( n % 47 == 0 ) ; } public static void main ( String [ ] args ) { int N = 59@@ 173 ; if ( is@@ Di@@ visible ( N ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
class GF@@ G { static int proper@@ Di@@ visor@@ Sum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j * j <= i ; ++ j ) { if ( i % j == 0 ) { if ( i / j == j ) sum += j ; else sum += j + i / j ; } } sum = sum - i ; } return sum ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( proper@@ Di@@ visor@@ Sum ( n ) ) ; n = 5 ; System . out . println ( proper@@ Di@@ visor@@ Sum ( n ) ) ; } }
class GF@@ G { static int proper@@ Di@@ visor@@ Sum ( int n ) { int sum = 0 ; int i ; for ( i = 1 ; i <= n ; ++ i ) sum += ( n / i ) * i ; return sum - n * ( n + 1 ) / 2 ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( proper@@ Di@@ visor@@ Sum ( n ) ) ; n = 5 ; System . out . println ( proper@@ Di@@ visor@@ Sum ( n ) ) ; } }
class GF@@ G { static int sz = ( int ) 1e@@ 5 ; static boolean [ ] is@@ Prime = new boolean [ sz + 1 ] ; static void generate@@ Prime ( ) { int i , j ; for ( i = 2 ; i <= sz ; i ++ ) is@@ Prime [ i ] = true ; for ( i = 2 ; i * i <= sz ; i ++ ) { if ( is@@ Prime [ i ] ) { for ( j = i * i ; j < sz ; j += i ) { is@@ Prime [ j ] = false ; } } } } static void Pai@@ r_@@ of_@@ Prime@@ Xor ( int A [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( is@@ Prime [ ( A [ i ] ^ A [ j ] ) ] ) { System . out . print ( " ( " + A [ i ] + " , ▁ " + A [ j ] + " ) ▁ " ) ; } } } } public static void main ( String [ ] args ) { int A [ ] = { 1 , 3 , 6 , 11 } ; int n = A . length ; generate@@ Prime ( ) ; Pai@@ r_@@ of_@@ Prime@@ Xor ( A , n ) ; } }
class GF@@ G { static boolean is@@ Prime ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { return false ; } } return true ; } static void print@@ Min@@ Count@@ Prime ( int N ) { int min@@ Count ; if ( is@@ Prime ( N ) ) { min@@ Count = 1 ; } else if ( N % 2 == 0 ) { min@@ Count = 2 ; } else { if ( is@@ Prime ( N - 2 ) ) { min@@ Count = 2 ; } else { min@@ Count = 3 ; } } System . out . print ( min@@ Count + "@@ NEW_@@ LINE@@ "@@ )@@ ; } public static void main ( String [ ] args ) { int N = 100 ; print@@ Min@@ Count@@ Prime ( N ) ; } }
class GF@@ G { static int count@@ Steps ( int n ) { int steps = 0 ; while ( n > 0 ) { int largest = ( int ) Math . c@@ br@@ t ( n ) ; n -= ( largest * largest * largest ) ; steps ++ ; } return steps ; } public static void main ( String [ ] args ) { int n = 150 ; System . out . print ( count@@ Steps ( n ) ) ; } }
class GF@@ G { static void rad ( double d , double h ) { System . out . println ( " The ▁ radius ▁ of ▁ the ▁ circle ▁ is ▁ " + ( ( d * d ) / ( 8 * h ) + h / 2 ) ) ; } public static void main ( String [ ] args ) { double d = 4 , h = 1 ; rad ( d , h ) ; } }
import java . lang . Math ; class GF@@ G { static float Area ( float r ) { if ( r < 0 ) return - 1 ; float x = ( 2 * r ) / ( float ) ( Math . sqrt ( 5 ) ) ; float A = 0.7@@ 04@@ 77@@ f * ( float ) ( Math . pow ( x , 2 ) ) ; return A ; } public static void main ( String [ ] args ) { float r = 5 ; System . out . println ( Area ( r ) ) ; } }
class GF@@ G { static float poly@@ diagonal ( float n , float a ) { if ( a < 0 && n < 0 ) { return - 1 ; } return ( float ) ( 2 * a * Math . sin ( ( ( ( n - 2 ) * 180 ) / ( 2 * n ) ) * 3.14@@ 159 / 180 ) ) ; } public static void main ( String [ ] args ) { float a = 9 , n = 10 ; System . out . printf ( " % .3f " , poly@@ diagonal ( n , a ) ) ; } }
import java . lang . * ; class GF@@ G { static double PI = 3.14@@ 159@@ 265 ; public static double area@@ _c@@ ic@@ um@@ scri@@ bed ( double c ) { return ( c * c * ( PI / 4 ) ) ; } public static void main ( String [ ] args ) { double c = 8.0 ; System . out . println ( area@@ _c@@ ic@@ um@@ scri@@ bed ( c ) ) ; } }
import java . io . * ; class GF@@ G { static int max@@ Area ( float per@@ imeter ) { int length = ( int ) Math . ceil ( per@@ imeter / 4 ) ; int bread@@ th = ( int ) Math . floor ( per@@ imeter / 4 ) ; return length * bread@@ th ; } public static void main ( String [ ] args ) { float n = 38 ; System . out . println ( " Maximum ▁ Area ▁ = ▁ " + max@@ Area ( n ) ) ; } }
class GF@@ G { static double Per@@ imeter ( double s , int n ) { double per@@ imeter = 1 ; per@@ imeter = n * s ; return per@@ imeter ; } public static void main ( String [ ] args ) { int n = 5 ; double s = 2.5 , per@@ i ; per@@ i = Per@@ imeter ( s , n ) ; System . out . println ( " Per@@ imeter ▁ of ▁ Regular ▁ Polygon " + " ▁ with ▁ " + n + " ▁ sides ▁ of ▁ length ▁ " + s + " ▁ = ▁ " + per@@ i ) ; } }
import java . io . * ; class GF@@ G { static float hexa@@ diagonal ( float a ) { if ( a < 0 ) return - 1 ; return 2 * a ; } public static void main ( String [ ] args ) { float a = 4 ; System . out . print ( hexa@@ diagonal ( a ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class GF@@ G { static float find@@ Radius@@ Of@@ circum@@ circle ( float l , float b ) { if ( l < 0 b < 0 ) return - 1 ; float radius = ( float ) Math . sqrt ( Math . pow ( l , 2 ) + Math . pow ( b , 2 ) ) / 2 ; return radius ; } public static void main ( String args [ ] ) { float l = 4 , b = 3 ; System . out . println ( find@@ Radius@@ Of@@ circum@@ circle ( l , b ) ) ; } }
import java . io . * ; class GF@@ G { static void half@@ square ( int n , int x , int y ) { int half = n / 2 ; if ( ( half == x half == x - 1 ) && ( half == y half == y - 1 ) ) System . out . println ( " NO " ) ; else System . out . println ( " YES " ) ; } public static void main ( String [ ] args ) { int n = 100 ; int x = 51 , y = 100 ; half@@ square ( n , x , y ) ; } }
class GF@@ G { static boolean Find@@ Point ( int x1 , int y1 , int x2 , int y2 , int x , int y ) { if ( x > x1 && x < x2 && y > y1 && y < y2 ) return true ; return false ; } public static void main ( String [ ] args ) { int x1 = 0 , y1 = 0 , x2 = 10 , y2 = 8 ; int x = 1 , y = 5 ; if ( Find@@ Point ( x1 , y1 , x2 , y2 , x , y ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GF@@ G { static void shor@@ test_@@ distance ( float x1 , float y1 , float z1 , float a , float b , float c , float d ) { d = Math . abs ( ( a * x1 + b * y1 + c * z1 + d ) ) ; float e = ( float ) Math . sqrt ( a * a + b * b + c * c ) ; System . out . println ( " Per@@ pendic@@ ular ▁ distance ▁ " + " is ▁ " + d / e ) ; } public static void main ( String [ ] args ) { float x1 = 4 ; float y1 = - 4 ; float z1 = 3 ; float a = 2 ; float b = - 2 ; float c = 5 ; float d = 8 ; shor@@ test_@@ distance ( x1 , y1 , z1 , a , b , c , d ) ; } }
import java . io . * ; class GF@@ G { static int pent@@ ag@@ on_@@ pyram@@ id@@ al ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int p = ( 3 * i * i - i ) / 2 ; sum = sum + p ; } return sum ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( pent@@ ag@@ on_@@ pyram@@ id@@ al ( n ) ) ; } }
class GF@@ G { static boolean is@@ Rectangle ( int a , int b , int c , int d ) { if ( a == b && a == c && a == d && c == d && b == c && b == d ) return true ; else if ( a == b && c == d ) return true ; else if ( a == d && c == b ) return true ; else if ( a == c && d == b ) return true ; else return false ; } public static void main ( String [ ] args ) { int a = 1 , b = 2 , c = 3 , d = 4 ; if ( is@@ Rectangle ( a , b , c , d ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GF@@ G { static double max@@ Area ( double a , double b , double c , double d ) { double semi@@ per@@ imeter = ( a + b + c + d ) / 2 ; return Math . sqrt ( ( semi@@ per@@ imeter - a ) * ( semi@@ per@@ imeter - b ) * ( semi@@ per@@ imeter - c ) * ( semi@@ per@@ imeter - d ) ) ; } public static void main ( String [ ] args ) { double a = 1 , b = 2 , c = 1 , d = 2 ; System . out . println ( max@@ Area ( a , b , c , d ) ) ; } }
import java . io . * ; class GF@@ G { static void check@@ Collision ( int a , int b , int c , int x , int y , int radius ) { double dist = ( Math . abs ( a * x + b * y + c ) ) / Math . sqrt ( a * a + b * b ) ; if ( radius == dist ) System . out . println ( " Touch " ) ; else if ( radius > dist ) System . out . println ( " Intersect " ) ; else System . out . println ( " Outside " ) ; } public static void main ( String [ ] args ) { int radius = 5 ; int x = 0 , y = 0 ; int a = 3 , b = 4 , c = 25 ; check@@ Collision ( a , b , c , x , y , radius ) ; } }
import java . io . * ; class GF@@ G { static int circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int dist@@ Sq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; int rad@@ Sum@@ Sq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( dist@@ Sq == rad@@ Sum@@ Sq ) return 1 ; else if ( dist@@ Sq > rad@@ Sum@@ Sq ) return - 1 ; else return 0 ; } public static void main ( String [ ] args ) { int x1 = - 10 , y1 = 8 ; int x2 = 14 , y2 = - 24 ; int r1 = 30 , r2 = 10 ; int t = circle ( x1 , y1 , x2 , y2 , r1 , r2 ) ; if ( t == 1 ) System . out . println ( " Circle ▁ touch ▁ to " + " ▁ each ▁ other . " ) ; else if ( t < 0 ) System . out . println ( " Circle ▁ not ▁ touch " + " ▁ to ▁ each ▁ other . " ) ; else System . out . println ( " Circle ▁ intersect " + " ▁ to ▁ each ▁ other . " ) ; } }
class GF@@ G { public static int minimum@@ Cost ( int arr [ ] , int N , int X , int Y ) { int ev@@ en_@@ count = 0 , od@@ d_@@ count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] & 1 ) > 0 && ( i % 2 == 0 ) ) { od@@ d_@@ count ++ ; } if ( ( arr [ i ] % 2 ) == 0 && ( i & 1 ) > 0 ) { ev@@ en_@@ count ++ ; } } int cost@@ 1 = X * Math . min ( od@@ d_@@ count , ev@@ en_@@ count ) ; int cost@@ 2 = Y * ( Math . max ( od@@ d_@@ count , ev@@ en_@@ count ) - Math . min ( od@@ d_@@ count , ev@@ en_@@ count ) ) ; int cost@@ 3 = ( od@@ d_@@ count + ev@@ en_@@ count ) * Y ; return Math . min ( cost@@ 1 + cost@@ 2 , cost@@ 3 ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 5 , 3 , 7 , 2 , 1 } , X = 10 , Y = 2 ; int N = arr . length ; System . out . println ( minimum@@ Cost ( arr , N , X , Y ) ) ; } }
import java . util . * ; class GF@@ G { static int maxim@@ ize@@ Subset ( int N , int [ ] arr , int M , int x ) { if ( x == M ) { return 0 ; } int ans = 0 ; for ( int i = x ; i < M ; i ++ ) { if ( N % arr [ i ] == 0 ) { ans = Math . max ( ans , maxim@@ ize@@ Subset ( N / arr [ i ] , arr , M , x + 1 ) + 1 ) ; } } return ans ; } public static void main ( String [ ] args ) { int N = 64 ; int [ ] arr = { 1 , 2 , 4 , 8 , 16 , 32 } ; int M = arr . length ; System . out . println ( maxim@@ ize@@ Subset ( N , arr , M , 0 ) ) ; } }
class GF@@ G { public static int get@@ Product ( int n ) { int product = 1 ; while ( n != 0 ) { product = product * ( n % 10 ) ; n = n / 10 ; } return product ; } public static int count@@ Pairs ( int L , int R ) { int cnt@@ Pair = 0 ; for ( int a = L ; a <= R ; a ++ ) { for ( int b = a + 1 ; b <= R ; b ++ ) { int x = get@@ Product ( a ) ; int y = get@@ Product ( b ) ; if ( x != 0 && y != 0 && ( a * y ) == ( b * x ) ) { cnt@@ Pair ++ ; } } } return cnt@@ Pair ; } public static void main ( String args [ ] ) { int L = 1 ; int R = 100 ; System . out . println ( count@@ Pairs ( L , R ) ) ; } }
import java . util . * ; class GF@@ G { static int max@@ Sum ( int [ ] [ ] matrix ) { int r = matrix . length ; int c = matrix [ 0 ] . length ; int sum = 0 ; int mini = Integer . MAX_VALUE ; int count = 0 ; for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) { int k = matrix [ i ] [ j ] ; mini = Math . min ( mini , Math . abs ( k ) ) ; if ( k < 0 ) count ++ ; sum += Math . abs ( k ) ; } } if ( count % 2 == 0 ) { return sum ; } else { return ( sum - 2 * mini ) ; } } public static void main ( String [ ] args ) { int [ ] [ ] matrix = { { 2 , - 2 } , { - 2 , 2 } } ; System . out . print ( max@@ Sum ( matrix ) ) ; } }
import java . io . * ; class GF@@ G { static int count@@ Sub@@ sequences ( int arr [ ] , int N ) { int odd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] & 1 ) % 2 == 1 ) odd ++ ; } return ( 1 << odd ) - 1 ; } public static void main ( String [ ] args ) { int N = 3 ; int arr [ ] = { 1 , 3 , 3 } ; System . out . println ( count@@ Sub@@ sequences ( arr , N ) ) ; } }
import java . util . * ; class GF@@ G { static void update@@ Array ( int [ ] arr , int K ) { int sum = 0 ; ArrayList < Integer > res = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] < K ) { sum += arr [ i ] ; } else { if ( sum != 0 ) { res . add ( sum ) ; } sum = 0 ; res . add ( arr [ i ] ) ; } } if ( sum != 0 ) res . add ( sum ) ; for ( int i = 0 ; i < res . size ( ) ; i ++ ) System . out . print ( res . get ( i ) + " ▁ " ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 200 , 6 , 36 , 6@@ 12 , 121 , 66 , 63 , 39 , 66@@ 8 , 108 } ; int K = 100 ; update@@ Array ( arr , K ) ; } }
import java . util . * ; class GF@@ G { static int count@@ Quad@@ rup@@ les ( int A [ ] , int N ) { int ans = 0 ; HashMap < Integer , Integer > freq = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( freq . containsKey ( A [ i ] ) ) ans += freq . get ( A [ i ] ) ; for ( int j = 0 ; j < i ; j ++ ) { for ( int k = 0 ; k < j ; k ++ ) { if ( freq . containsKey ( A [ i ] * A [ j ] * A [ k ] ) ) { freq . put ( A [ i ] * A [ j ] * A [ k ] , freq . get ( A [ i ] * A [ j ] * A [ k ] ) + 1 ) ; } else { freq . put ( A [ i ] * A [ j ] * A [ k ] , 1 ) ; } } } } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 2 , 2 , 7 , 40 , 160 } ; int N = arr . length ; System . out . print ( count@@ Quad@@ rup@@ les ( arr , N ) ) ; } }
class GF@@ G { public static long count@@ Cells ( int n , int m , int s ) { int m@@ x1 = - 1 ; int cont@@ 1 = 0 ; for ( int i = 0 ; i < s && i < n ; ++ i ) { int aux = ( n - ( i + 1 ) ) / s + 1 ; if ( aux > m@@ x1 ) { m@@ x1 = cont@@ 1 = aux ; } else if ( aux == m@@ x1 ) cont@@ 1 += aux ; } int m@@ x2 = - 1 ; int cont@@ 2 = 0 ; for ( int i = 0 ; i < s && i < m ; ++ i ) { int aux = ( m - ( i + 1 ) ) / s + 1 ; if ( aux > m@@ x2 ) m@@ x2 = cont@@ 2 = aux ; else if ( aux == m@@ x2 ) cont@@ 2 += aux ; } return ( long ) ( cont@@ 1 * cont@@ 2 ) ; } public static void main ( String args [ ] ) { int N = 5 , M = 5 , K = 2 ; System . out . println ( count@@ Cells ( N , M , K ) ) ; } }
import java . util . Arrays ; class GF@@ G { public static int minimum@@ Sub@@ array ( int [ ] arr , int n , int m ) { int [ ] map@@ u = new int [ m + 1 ] ; Arrays . fill ( map@@ u , 0 ) ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { map@@ u [ arr [ i ] ] ++ ; if ( map@@ u [ arr [ i ] ] == ( n / m ) + 1 ) c ++ ; } if ( c == 0 ) return 0 ; int ans = n ; int l = 0 , r = 0 ; while ( r < n ) { if ( -- map@@ u [ arr [ r ] ] == ( n / m ) ) c -- ; if ( c == 0 ) { while ( l <= r && c == 0 ) { ans = Math . min ( ans , r - l + 1 ) ; if ( ++ map@@ u [ arr [ l ] ] > ( n / m ) ) c ++ ; l ++ ; } } r ++ ; } return ans ; } public static void main ( String args [ ] ) { int [ ] arr = { 1 , 1 , 2 , 1 , 1 , 2 } ; int M = 2 ; int N = arr . length ; System . out . println ( minimum@@ Sub@@ array ( arr , N , M ) ) ; } }
import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . Map ; class GF@@ G { static int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { res = res * i ; } return res ; } static int n@@ Cr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; } static void count@@ W@@ ays ( String s , String t ) { int n = s . length ( ) ; int sum@@ 1 = 0 , sum@@ 2 = 0 , K = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '1' ) { sum@@ 1 ++ ; } else sum@@ 1 -- ; } int m = t . length ( ) ; for ( int i = 0 ; i < m ; i ++ ) { if ( t . charAt ( i ) == '1' ) { sum@@ 2 ++ ; } else if ( t . charAt ( i ) == '0' ) { sum@@ 2 -- ; } else K ++ ; } int P = Math . abs ( sum@@ 1 - sum@@ 2 ) ; if ( ( P > K ) || ( K - P ) % 2 == 1 ) { System . out . println ( 0 ) ; return ; } System . out . println ( n@@ Cr ( K , ( P + K ) / 2 ) ) ; } public static void main ( String [ ] args ) { String S1 = "@@ 101@@ 0" ; String S2 = "@@ 10 ? ? " ; count@@ W@@ ays ( S1 , S2 ) ; } }
import java . io . * ; class GF@@ G { static long ABS ( long x ) { return Math . max ( x , - x ) ; } static void find@@ Fraction ( long x , long y , long n ) { long A = - 1 , B = - 1 ; for ( long i = 1 ; i <= n ; i ++ ) { long d = ( i * x ) / y ; if ( d >= 0 && ( A == - 1 || ABS ( B * x - y * A ) * ABS ( i * y ) > ABS ( i * x - y * d ) * ABS ( B * y ) ) ) A = d ; B = i ; d ++ ; if ( d >= 0 && ( A == - 1 || ABS ( B * x - y * A ) * ABS ( i * y ) > ABS ( i * x - y * d ) * ABS ( B * y ) ) ) A = d ; B = i ; } A -- ; B -- ; System . out . println ( A + " / " + B ) ; } public static void main ( String [ ] args ) { long x = 3 ; long y = 7 ; long n = 6 ; find@@ Fraction ( x , y , n ) ; } }
import java . util . Vector ; public class GF@@ G { static Vector < String > Fraction@@ Split ( long n , long d ) { Vector < String > Unit@@ Fac@@ tions = new Vector < > ( ) ; while ( n > 0 ) { long x = ( d + n - 1 ) / n ; String s = "1 / " + String . valueOf ( x ) ; Unit@@ Fac@@ tions . add ( s ) ; n = n * x - d ; d = d * x ; } return Unit@@ Fac@@ tions ; } public static void main ( String [ ] args ) { long n = 13 , d = 18 ; Vector < String > res = Fraction@@ Split ( n , d ) ; for ( String s : res ) System . out . print ( s + " , ▁ " ) ; } }
import java . io . * ; class GF@@ G { public static void minimum@@ Distance ( int arr [ ] , int N ) { int ind = 0 ; int prev = arr [ ind ] ; int s = arr . length ; for ( int i = 0 ; i < N ; i ++ ) { int distance = Integer . MAX_VALUE ; if ( i < arr [ 0 ] ) { distance = arr [ 0 ] - i ; } else if ( i >= prev && ind + 1 < s && i <= arr [ ind + 1 ] ) { distance = Math . min ( i - prev , arr [ ind + 1 ] - i ) ; if ( i == arr [ ind + 1 ] ) { distance = 0 ; prev = arr [ ind + 1 ] ; ind ++ ; } } else { distance = i - prev ; } System . out . print ( distance + " ▁ " ) ; } } public static void main ( String [ ] args ) { int N = 5 ; int arr [ ] = { 0 , 4 } ; minimum@@ Distance ( arr , N ) ; } }
import java . util . * ; class GF@@ G { static int count@@ Of@@ Pairs ( int [ ] arr , int N , int X ) { int count = 0 ; HashMap < Integer , Integer > M = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( M . containsKey ( arr [ i ] & X ) ) M . put ( ( arr [ i ] & X ) , M . get ( arr [ i ] & X ) + 1 ) ; else M . put ( arr [ i ] & X , 1 ) ; } for ( Integer entry : M . keySet ( ) ) { int p = M . get ( entry ) ; count += p * ( p - 1 ) / 2 ; } return count ; } public static void main ( String [ ] args ) { int [ ] arr = { 3 , 2 , 5 , 4 , 6 , 7 } ; int X = 6 ; int N = arr . length ; System . out . print ( count@@ Of@@ Pairs ( arr , N , X ) ) ; } }
import java . util . * ; import java . util . HashMap ; class GF@@ G { static void prime@@ Factor@@ ization ( int N ) { int [ ] si@@ eve = new int [ N / 2 + 1 ] ; for ( int i = 0 ; i <= N / 2 ; i ++ ) { si@@ eve [ i ] = 0 ; } for ( int i = 2 ; i <= N / 2 ; i ++ ) { if ( si@@ eve [ i ] == 0 ) { for ( int j = i * i ; j <= N / 2 ; j += i ) { si@@ eve [ j ] = 1 ; } } } ArrayList < Integer > prime = new ArrayList < Integer > ( ) ; for ( int i = 3 ; i <= N / 2 ; i ++ ) if ( si@@ eve [ i ] == 0 ) prime . add ( i ) ; int x = prime . size ( ) ; System . out . println ( "2 - > " + x ) ; for ( int i : prime ) System . out . println ( i + " - > 1" ) ; } public static void main ( String args [ ] ) { int N = 18 ; prime@@ Factor@@ ization ( N ) ; } }
import java . util . * ; class GF@@ G { static int noOf@@ W@@ ays ( int N , int K ) { String S = String . valueOf ( N ) ; int ans = 1 ; for ( int i = 1 ; i < S . length ( ) ; i ++ ) { int count = 1 ; while ( i < S . length ( ) && ( int ) S . charAt ( i ) - 48 + ( int ) S . charAt ( i - 1 ) - 48 == K ) { count ++ ; i ++ ; } if ( count % 2 == 1 ) ans *= ( count + 1 ) / 2 ; } return ans ; } public static void main ( String [ ] args ) { int N = 14@@ 547@@ 81 ; int K = 9 ; System . out . print ( noOf@@ W@@ ays ( N , K ) ) ; } }
import java . util . * ; class GF@@ G { static int gcd ( int a , int b ) { return b == 0 ? a : gcd ( b , a % b ) ; } static void print@@ Unit@@ ary@@ Di@@ visors ( int n ) { for ( int i = 1 ; i <= ( int ) Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i && gcd ( i , n / i ) == 1 ) { System . out . print ( i + " ▁ " ) ; } else { if ( gcd ( i , n / i ) == 1 ) { System . out . print ( i + " ▁ " + n / i + " ▁ " ) ; } } } } } public static void main ( String [ ] args ) { int N = 12 ; print@@ Unit@@ ary@@ Di@@ visors ( N ) ; } }
import java . util . * ; class GF@@ G { static void get@@ Permutation ( int N ) { if ( N <= 3 ) { System . out . print ( - 1 ) ; return ; } int i = N ; if ( N % 2 == 0 ) i -- ; while ( i >= 1 ) { System . out . print ( i + " ▁ " ) ; i -= 2 ; } System . out . print ( 4 + " ▁ " + 2 + " ▁ " ) ; i = 6 ; while ( i <= N ) { System . out . print ( i + " ▁ " ) ; i += 2 ; } } public static void main ( String [ ] args ) { int N = 9 ; get@@ Permutation ( N ) ; } }
import java . io . * ; class GF@@ G { static void max@@ Score@@ Sub@@ Array ( int [ ] a , int [ ] b , int n ) { int res = 0 ; for ( int mid = 0 ; mid < n ; mid ++ ) { int straight@@ Score = a [ mid ] * b [ mid ] , reverse@@ Score = a [ mid ] * a [ mid ] ; int prev = mid - 1 , next = mid + 1 ; res = Math . max ( res , Math . max ( straight@@ Score , reverse@@ Score ) ) ; while ( prev >= 0 && next < n ) { straight@@ Score += ( a [ prev ] * b [ prev ] + a [ next ] * b [ next ] ) ; reverse@@ Score += ( a [ prev ] * b [ next ] + a [ next ] * b [ prev ] ) ; res = Math . max ( res , Math . max ( straight@@ Score , reverse@@ Score ) ) ; prev -- ; next ++ ; } straight@@ Score = 0 ; reverse@@ Score = 0 ; prev = mid - 1 ; next = mid ; while ( prev >= 0 && next < n ) { straight@@ Score += ( a [ prev ] * b [ prev ] + a [ next ] * b [ next ] ) ; reverse@@ Score += ( a [ prev ] * b [ next ] + a [ next ] * b [ prev ] ) ; res = Math . max ( res , Math . max ( straight@@ Score , reverse@@ Score ) ) ; prev -- ; next ++ ; } } System . out . println ( res ) ; } public static void main ( String [ ] args ) { int A [ ] = { 13 , 4 , 5 } ; int B [ ] = { 10 , 22 , 2 } ; int N = A . length ; max@@ Score@@ Sub@@ Array ( A , B , N ) ; } }
public class MyClass { static void count@@ Values ( int A , int B , int C ) { if ( B >= A ) { System . out . println ( 0 ) ; return ; } if ( B == 0 ) { System . out . println ( C / A ) ; return ; } int ans = C / A ; if ( ans * A + B <= C ) { ans ++ ; } System . out . println ( ans ) ; } public static void main ( String args [ ] ) { int A = 6 , B = 3 , N = 15 ; count@@ Values ( A , B , N ) ; } }
import java . util . Arrays ; class GF@@ G { static void max@@ Frequency ( int arr [ ] , int N , int K ) { Arrays . sort ( arr ) ; int start = 0 , end = 0 ; int sum = 0 , res = 0 ; for ( end = 0 ; end < N ; end ++ ) { sum += arr [ end ] ; while ( ( end - start + 1 ) * arr [ end ] - sum > K ) { sum -= arr [ start ] ; start ++ ; } res = Math . max ( res , end - start + 1 ) ; } System . out . println ( res ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 4 , 8 , 13 } ; int N = 4 ; int K = 5 ; max@@ Frequency ( arr , N , K ) ; } }
import java . io . * ; import java . lang . * ; import java . util . * ; class GF@@ G { static void count@@ Pairs ( int arr [ ] , int n , int x ) { int count = 0 ; HashMap < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { mp . put ( arr [ i ] - x * i , mp . getOr@@ Default ( arr [ i ] - x * i , 0 ) + 1 ) ; } for ( int v : mp . values ( ) ) { count += ( v * ( v - 1 ) ) / 2 ; } System . out . println ( count ) ; } public static void main ( String [ ] args ) { int n = 6 , x = 3 ; int arr [ ] = { 5 , 4 , 8 , 11 , 13 , 16 } ; count@@ Pairs ( arr , n , x ) ; } }
public class GF@@ G { static int sum@@ Of@@ Di@@ visors ( int N ) { return N ; } public static void main ( String [ ] args ) { int N = 5 ; System . out . println ( sum@@ Of@@ Di@@ visors ( N ) ) ; } }
import java . io . * ; import java . lang . * ; import java . util . * ; class GF@@ G { static int find@@ X@@ ORS ( int ar@@ r1 [ ] , int ar@@ r2 [ ] , int N , int M ) { int X@@ OR@@ S1 = 0 ; int X@@ OR@@ S2 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { X@@ OR@@ S1 ^= ar@@ r1 [ i ] ; } for ( int i = 0 ; i < M ; i ++ ) { X@@ OR@@ S2 ^= ar@@ r2 [ i ] ; } return ( X@@ OR@@ S1 & X@@ OR@@ S2 ) ; } public static void main ( String [ ] args ) { int ar@@ r1 [ ] = { 1 , 2 , 3 } ; int ar@@ r2 [ ] = { 6 , 5 } ; int N = ar@@ r1 . length ; int M = ar@@ r2 . length ; System . out . println ( find@@ X@@ ORS ( ar@@ r1 , ar@@ r2 , N , M ) ) ; } }
public class GF@@ G { static int ceil@@ Difference ( int arr [ ] , int n , int x ) { int total@@ Sum = 0 ; int per@@ Element@@ Sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { total@@ Sum += arr [ i ] ; per@@ Element@@ Sum += Math . ceil ( ( double ) ( arr [ i ] ) / ( double ) ( x ) ) ; } int total@@ Ceil@@ Sum = ( int ) Math . ceil ( ( double ) ( total@@ Sum ) / ( double ) ( x ) ) ; return Math . abs ( per@@ Element@@ Sum - total@@ Ceil@@ Sum ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int K = 4 ; int N = arr . length ; System . out . println ( ceil@@ Difference ( arr , N , K ) ) ; } }
import java . util . * ; class GF@@ G { static int count@@ Trip@@ lets ( int N ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= N ; j ++ ) { if ( i * j > N ) break ; ans += N / ( i * j ) ; } } return ans ; } public static void main ( String [ ] args ) { int N = 10 ; System . out . print ( count@@ Trip@@ lets ( N ) ) ; } }
import java . util . * ; class GF@@ G { static int min@@ Step@@ K ( int arr [ ] , int N , int K ) { int E = 0 ; int S = 0 ; for ( int i = 0 ; i < N ; i ++ ) { S += arr [ i ] ; if ( arr [ i ] % 2 == 0 ) E += 1 ; } if ( S >= K ) return 0 ; else if ( S + E < K ) return - 1 ; else return K - S ; } public static void main ( String [ ] args ) { int arr [ ] = { 0 , 1 , 1 , 0 , 1 } ; int N = arr . length ; int K = 4 ; System . out . println ( min@@ Step@@ K ( arr , N , K ) ) ; } }
class GF@@ G { static void Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( int n , boolean prime [ ] ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) { prime [ i ] = false ; } } } } static void count@@ Prime ( int n ) { boolean prime [ ] = new boolean [ n + 1 ] ; for ( int i = 0 ; i < prime . length ; i ++ ) { prime [ i ] = true ; } Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( n , prime ) ; int dp [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = 0 ; } dp [ 1 ] = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i ] += dp [ i - 1 ] ; if ( prime [ i ] == true && prime [ i - 2 ] == true ) { dp [ i ] ++ ; } } System . out . print ( dp [ n ] ) ; } public static void main ( String [ ] args ) { int N = 6 ; count@@ Prime ( N ) ; } }
class GF@@ G { static void sum@@ Of@@ Square@@ d@@ Differen@@ ces ( int arr [ ] , int N ) { int ans = 0 ; int sum@@ A = 0 , sum@@ B = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum@@ A += ( arr [ i ] * arr [ i ] ) ; sum@@ B += arr [ i ] ; } sum@@ A = N * sum@@ A ; sum@@ B = ( sum@@ B * sum@@ B ) ; ans = sum@@ A - sum@@ B ; System . out . println ( ans ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 8 , 4 } ; int N = arr . length ; sum@@ Of@@ Square@@ d@@ Differen@@ ces ( arr , N ) ; } }
import java . io . * ; class GF@@ G { static int count@@ AP@@ s ( int S , int D ) { S = S * 2 ; int answer = 0 ; for ( int i = 1 ; i <= Math . sqrt ( S ) ; i ++ ) { if ( S % i == 0 ) { if ( ( ( S / i ) - D * i + D ) % 2 == 0 ) answer ++ ; if ( ( D * i - ( S / i ) + D ) % 2 == 0 ) answer ++ ; } } return answer ; } public static void main ( String [ ] args ) { int S = 12 , D = 1 ; System . out . println ( count@@ AP@@ s ( S , D ) ) ; } }
import java . util . * ; class GF@@ G { static int distinct ( int arr [ ] , int N ) { Set < Integer > set = new HashSet < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { set . add ( arr [ i ] ) ; } return set . size ( ) ; } static int max@@ Sub@@ array@@ Sum@@ Util ( int arr [ ] , int N , int K , int total@@ Distin@@ ct ) { if ( K > N ) return 0 ; int max = 0 ; int sum = 0 ; Map < Integer , Integer > map = new HashMap < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { map . put ( arr [ i ] , map . getOr@@ Default ( arr [ i ] , 0 ) + 1 ) ; sum += arr [ i ] ; if ( i >= K ) { map . put ( arr [ i - K ] , map . get ( arr [ i - K ] ) - 1 ) ; sum -= arr [ i - K ] ; if ( map . get ( arr [ i - K ] ) == 0 ) map . remove ( arr [ i - K ] ) ; } if ( map . size ( ) == total@@ Distin@@ ct ) max = Math . max ( max , sum ) ; } return max ; } static void max@@ Sub@@ array@@ Sum ( int arr [ ] , int K ) { int N = arr . length ; int total@@ Distin@@ ct = distinct ( arr , N ) ; System . out . println ( max@@ Sub@@ array@@ Sum@@ Util ( arr , N , K , total@@ Distin@@ ct ) ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 7 , 7 , 2 , 4 , 2 , 7 , 4 , 6 , 6 , 6 } ; int K = 6 ; max@@ Sub@@ array@@ Sum ( arr , K ) ; } }
import java . util . * ; class GF@@ G { static int process@@ Diagonal ( ArrayList < Integer > arr ) { int ans = 0 ; int get@@ Bit = 1 ; for ( int i = 0 ; i < 32 ; i ++ ) { int S = 0 ; int NS = 0 ; for ( int j : arr ) { if ( ( get@@ Bit & j ) != 0 ) S += 1 ; else NS += 1 ; } if ( S > NS ) ans += Math . pow ( 2 , i ) ; get@@ Bit <<= 1 ; } return ans ; } static int find@@ Sum ( int [ ] [ ] mat ) { int i = 0 ; int j = 0 ; ArrayList < Integer > pri@@ Diag = new ArrayList < Integer > ( ) ; while ( i < mat . length ) { pri@@ Diag . add ( mat [ i ] [ j ] ) ; i += 1 ; j += 1 ; } i = 0 ; j = mat . length - 1 ; ArrayList < Integer > sec@@ Diag = new ArrayList < Integer > ( ) ; while ( i < mat . length ) { sec@@ Diag . add ( mat [ i ] [ j ] ) ; i += 1 ; j -= 1 ; } return ( process@@ Diagonal ( pri@@ Diag ) + process@@ Diagonal ( sec@@ Diag ) ) ; } public static void main ( String [ ] args ) { int [ ] [ ] mat = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; System . out . print ( find@@ Sum ( mat ) ) ; } }
class GF@@ G { static boolean isp@@ al@@ in ( int num ) { String s = Integer . toString ( num ) ; int st = 0 , ed = s . length ( ) - 1 ; while ( st <= ed ) { if ( s . charAt ( st ) != s . charAt ( ed ) ) return false ; st ++ ; ed -- ; } return true ; } static void Calculate@@ X@@ OR@@ and@@ OR ( int n ) { int Calculate@@ XOR = 0 ; int Calculate@@ OR = 0 ; int start = ( int ) Math . pow ( 10 , n - 1 ) ; int end = ( int ) Math . pow ( 10 , n ) - 1 ; for ( int i = start ; i <= end ; i ++ ) { if ( isp@@ al@@ in ( i ) ) { Calculate@@ XOR = Calculate@@ XOR ^ i ; Calculate@@ OR = Calculate@@ OR | i ; } } System . out . print ( " XOR ▁ = ▁ " + Calculate@@ XOR ) ; System . out . println ( " ▁ OR ▁ = ▁ " + Calculate@@ OR ) ; } public static void main ( String [ ] args ) { int n = 4 ; Calculate@@ X@@ OR@@ and@@ OR ( n ) ; } }
class GF@@ G { static int pow@@ Of@@ Positive ( int n ) { int pos = ( int ) Math . floor ( ( Math . log ( n ) / Math . log ( 2 ) ) ) ; return ( int ) Math . pow ( 2 , pos ) ; } static int pow@@ Of@@ Negative ( int n ) { int pos = ( int ) Math . ceil ( ( Math . log ( n ) / Math . log ( 2 ) ) ) ; return ( int ) ( - 1 * Math . pow ( 2 , pos ) ) ; } static void highest@@ PowerOf@@ 2 ( int n ) { if ( n > 0 ) { System . out . println ( pow@@ Of@@ Positive ( n ) ) ; } else { n = - n ; System . out . println ( pow@@ Of@@ Negative ( n ) ) ; } } public static void main ( String [ ] args ) { int n = - 24 ; highest@@ PowerOf@@ 2 ( n ) ; } }
class GF@@ G { static int summ@@ ation ( int n ) { int abs_@@ sum = n * ( n + 1 ) / 2 ; int sign = n + 1 % 2 == 0 ? 1 : - 1 ; int result_@@ sum = sign * abs_@@ sum ; return result_@@ sum ; } public static void main ( String [ ] args ) { int N = 2 ; System . out . println ( summ@@ ation ( N ) ) ; } }
class GF@@ G { static boolean is@@ Power ( int x , int y ) { int res1 = ( int ) ( Math . log ( y ) / Math . log ( x ) ) ; double res2 = Math . log ( y ) / Math . log ( x ) ; return ( res1 == res2 ) ; } static int count@@ Power ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( is@@ Power ( arr [ i ] , arr [ j ] ) || is@@ Power ( arr [ j ] , arr [ i ] ) ) res ++ ; return res ; } public static void main ( String [ ] args ) { int a [ ] = { 16 , 2 , 3 , 9 } ; int n = a . length ; System . out . println ( count@@ Power ( a , n ) ) ; } }
import java . lang . * ; class GF@@ G { public static int noOf@@ Cards ( int n ) { return n * ( 3 * n + 1 ) / 2 ; } public static void main ( String args [ ] ) { int n = 3 ; System . out . print ( noOf@@ Cards ( n ) ) ; } }
class GF@@ G { static int pair@@ Count ( int n , int m ) { int cnt = 0 , b , a ; for ( b = 0 ; b <= Math . sqrt ( m ) ; b ++ ) { a = m - b * b ; if ( a * a + b == n ) { cnt ++ ; } } return cnt ; } public static void main ( String [ ] args ) { int n = 9 , m = 3 ; System . out . print ( pair@@ Count ( n , m ) + "@@ NEW_@@ LINE@@ "@@ )@@ ; } }
class GF@@ G { static int bin@@ omi@@ al@@ Coeff ( int n , int k ) { int [ ] C = new int [ k + 1 ] ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; } static int count_@@ of_@@ sub@@ arrays ( int N ) { int count = bin@@ omi@@ al@@ Coeff ( 2 * N - 1 , N ) ; return count ; } public static void main ( String [ ] args ) { int N = 3 ; System . out . print ( count_@@ of_@@ sub@@ arrays ( N ) + "@@ NEW_@@ LINE@@ "@@ )@@ ; } }
import java . io . * ; import java . lang . Math ; class GF@@ G { static int max@@ GC@@ D ( int N , int K ) { int min@@ Sum = ( K * ( K + 1 ) ) / 2 ; if ( N < min@@ Sum ) return - 1 ; int i = ( int ) Math . sqrt ( N ) ; int res = 1 ; while ( i >= 1 ) { if ( N % i == 0 ) { if ( i >= min@@ Sum ) res = Math . max ( res , N / i ) ; if ( N / i >= min@@ Sum ) res = Math . max ( res , i ) ; } i -- ; } return res ; } public static void main ( String [ ] args ) { int N = 18 , K = 3 ; System . out . println ( max@@ GC@@ D ( N , K ) ) ; } }
class GF@@ G { static double getS@@ um ( int n ) { double sum = 0 ; if ( n == 1 ) { sum = 45@@ .0 ; } else { sum = ( 99@@ .0 / 2.0 ) * Math . pow ( 10 , n - 1 ) * Math . pow ( 10 , ( n - 1 ) / 2 ) ; } return sum ; } public static void main ( String [ ] args ) { int n = 3 ; double ans = getS@@ um ( n ) ; System . out . print ( ans ) ; } }
class GF@@ G { static int find@@ Min ( int arr [ ] , int n ) { int m = 0 ; for ( int i = 0 ; i < n ; i ++ ) m = Math . max ( m , arr [ i ] ) ; int freq [ ] = new int [ m + 2 ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; for ( int i = 1 ; i <= m + 1 ; i ++ ) { int j = i ; int cnt = 0 ; while ( j <= m ) { cnt += freq [ j ] ; j += i ; } if ( cnt == 0 ) return i ; } return m + 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 12 , 6 } ; int n = arr . length ; System . out . println ( find@@ Min ( arr , n ) ) ; } }
class GF@@ G { static int find@@ Min@@ Del ( int [ ] arr , int n ) { int min_@@ num = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) min_@@ num = Math . min ( arr [ i ] , min_@@ num ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == min_@@ num ) cnt ++ ; return n - cnt ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 3 , 2 } ; int n = arr . length ; System . out . print ( find@@ Min@@ Del ( arr , n ) ) ; } }
class GF@@ G { static int count@@ Digits ( int n ) { int cnt = 0 ; while ( n > 0 ) { cnt ++ ; n /= 10 ; } return cnt ; } static int digit@@ Pow@@ Sum ( int n ) { int sum = 0 ; int pw = count@@ Digits ( n ) ; while ( n > 0 ) { int d = n % 10 ; sum += Math . pow ( d , pw ) ; pw -- ; n /= 10 ; } return sum ; } static int count@@ Num ( int n ) { int count = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i == digit@@ Pow@@ Sum ( i ) ) { count ++ ; } } return count ; } public static void main ( String [ ] args ) { int n = 200 ; System . out . println ( count@@ Num ( n ) ) ; } }
import java . io . * ; class GF@@ G { static void perfec@@ t@@ Squ@@ ares ( int l , int r ) { for ( int i = l ; i <= r ; i ++ ) { if ( Math . sqrt ( i ) == ( int ) Math . sqrt ( i ) ) System . out . print ( i + " ▁ " ) ; } } public static void main ( String [ ] args ) { int l = 2 , r = 24 ; perfec@@ t@@ Squ@@ ares ( l , r ) ; } }
class GF@@ G { static void find@@ Win@@ ner ( int n ) { if ( ( n - 1 ) % 6 == 0 ) { System . out . println ( " Second ▁ Player ▁ wins ▁ the ▁ game " ) ; } else { System . out . println ( " First ▁ Player ▁ wins ▁ the ▁ game " ) ; } } public static void main ( String [ ] args ) { int n = 7 ; find@@ Win@@ ner ( n ) ; } }
class GF@@ G { static int l@@ cm ( int a , int b ) { int GC@@ D = __@@ gcd ( a , b ) ; return ( a * b ) / GC@@ D ; } static int Min@@ LC@@ M ( int a [ ] , int n ) { int [ ] Prefix = new int [ n + 2 ] ; int [ ] Suffix = new int [ n + 2 ] ; Prefix [ 1 ] = a [ 0 ] ; for ( int i = 2 ; i <= n ; i += 1 ) { Prefix [ i ] = l@@ cm ( Prefix [ i - 1 ] , a [ i - 1 ] ) ; } Suffix [ n ] = a [ n - 1 ] ; for ( int i = n - 1 ; i >= 1 ; i -= 1 ) { Suffix [ i ] = l@@ cm ( Suffix [ i + 1 ] , a [ i - 1 ] ) ; } int ans = Math . min ( Suffix [ 2 ] , Prefix [ n - 1 ] ) ; for ( int i = 2 ; i < n ; i += 1 ) { ans = Math . min ( ans , l@@ cm ( Prefix [ i - 1 ] , Suffix [ i + 1 ] ) ) ; } return ans ; } static int __@@ gcd ( int a , int b ) { return b == 0 ? a : __@@ gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { int a [ ] = { 5 , 15 , 9 , 36 } ; int n = a . length ; System . out . println ( Min@@ LC@@ M ( a , n ) ) ; } }
import java . util . * ; class GF@@ G { static int MOD = 100000000@@ 7 ; static int fact@@ Mod ( int n ) { long fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { fact *= ( i % MOD ) ; fact %= MOD ; } return ( int ) fact ; } static int count@@ W@@ ays ( int n , int m ) { return fact@@ Mod ( m ) ; } public static void main ( String args [ ] ) { int n = 2 , m = 2 ; System . out . print ( count@@ W@@ ays ( n , m ) ) ; } }
class GF@@ G { static boolean is@@ Composite ( int n ) { for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) return true ; } return false ; } static int Power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) { res = ( res * x ) % p ; } x = ( x * x ) % p ; } return res ; } static boolean is@@ Euler@@ P@@ se@@ ud@@ op@@ ri@@ me ( int N , int A ) { if ( A <= 0 ) return false ; if ( N % 2 == 0 || ! is@@ Composite ( N ) ) return false ; if ( __@@ gcd ( A , N ) != 1 ) return false ; int mod = Power ( A , ( N - 1 ) / 2 , N ) ; if ( mod != 1 && mod != N - 1 ) return false ; return true ; } static int __@@ gcd ( int a , int b ) { if ( b == 0 ) return a ; return __@@ gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { int N = 121 , A = 3 ; if ( is@@ Euler@@ P@@ se@@ ud@@ op@@ ri@@ me ( N , A ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GF@@ G { static int geo@@ metric@@ Mean ( int n ) { return ( int ) Math . sqrt ( n ) ; } public static void main ( String [ ] args ) { int n = 16 ; System . out . println ( geo@@ metric@@ Mean ( n ) ) ; } }
class GF@@ G { static int find_@@ k ( int a , int b ) { if ( ( a + b ) % 2 == 0 ) return ( ( a + b ) / 2 ) ; return - 1 ; } public static void main ( String [ ] args ) { int a = 2 , b = 16 ; System . out . println ( find_@@ k ( a , b ) ) ; } }
import java . util . * ; class GF@@ G { static int cnt@@ Sub@@ Sets ( int arr [ ] , int n ) { int maxVal = Arrays . stream ( arr ) . max ( ) . getAs@@ Int ( ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == maxVal ) cnt ++ ; } return ( int ) ( Math . pow ( 2 , cnt ) - 1 ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 1 , 2 } ; int n = arr . length ; System . out . println ( cnt@@ Sub@@ Sets ( arr , n ) ) ; } }
class GF@@ G { static int getS@@ um ( int n ) { return ( ( n - 1 ) + ( int ) Math . pow ( n , 2 ) ) ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( getS@@ um ( n ) ) ; } }
class GF@@ G { static int cnt@@ Edges ( int n ) { int edges = ( int ) Math . pow ( 2 , n ) - 2 ; return edges ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( cnt@@ Edges ( n ) ) ; } }
class GF@@ G { static int count ( int n ) { return ( int ) ( 15 * Math . pow ( 16 , n - 1 ) ) ; } public static void main ( String args [ ] ) { int n = 2 ; System . out . println ( count ( n ) ) ; } }
import java . util . * ; class GF@@ G { static float find@@ Prob ( int arr [ ] , int n ) { long max@@ Sum = Integer . MIN_VALUE , maxCount = 0 , total@@ Pairs = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int sum = arr [ i ] + arr [ j ] ; if ( sum == max@@ Sum ) { maxCount ++ ; } else if ( sum > max@@ Sum ) { max@@ Sum = sum ; maxCount = 1 ; } total@@ Pairs ++ ; } } float prob = ( float ) maxCount / ( float ) total@@ Pairs ; return prob ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 1 , 1 , 2 , 2 , 2 } ; int n = arr . length ; System . out . println ( find@@ Prob ( arr , n ) ) ; } }
import java . io . * ; class GF@@ G { static int previous@@ Fi@@ bon@@ ac@@ ci ( int n ) { double a = n / ( ( 1 + Math . sqrt ( 5 ) ) / 2.0 ) ; return ( int ) Math . round ( a ) ; } public static void main ( String [ ] args ) { int n = 8 ; System . out . println ( previous@@ Fi@@ bon@@ ac@@ ci ( n ) ) ; } }
class GF@@ G { static int count ( int n ) { return 3 * n * ( n - 1 ) + 1 ; } public static void main ( String args [ ] ) { int n = 3 ; System . out . println ( count ( n ) ) ; } }
class GF@@ G { static int ways ( int n ) { return n / 2 ; } public static void main ( String args [ ] ) { int n = 2 ; System . out . println ( ways ( n ) ) ; } }
class GF@@ G { static int find@@ Min@@ Value ( int arr [ ] , int n ) { long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return ( ( int ) ( sum / n ) + 1 ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 4 , 2 , 1 , 10 , 6 } ; int n = arr . length ; System . out . print ( find@@ Min@@ Value ( arr , n ) ) ; } }
import java . util . * ; class GF@@ G { static int sum@@ Pairs ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ( arr [ i ] * ( 2 * n ) ) ; } return sum ; } static public void main ( String [ ] arg ) { int arr [ ] = { 1 , 2 , 3 } ; int n = arr . length ; System . out . println ( sum@@ Pairs ( arr , n ) ) ; } }
import java . util . * ; class GF@@ G { static int min@@ Sum ( Integer arr [ ] , int n ) { int sum = 0 ; Arrays . sort ( arr , Collections . reverse@@ Order ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 4 < 2 ) sum = sum + arr [ i ] ; } return sum ; } public static void main ( String [ ] args ) { Integer [ ] arr = { 1 , 1 , 10 , 2 , 2 , 2 , 1 } ; int n = arr . length ; System . out . println ( min@@ Sum ( arr , n ) ) ; } }
import java . util . * ; class GF@@ G { static long getCount ( int A , int B2 , int C ) { long count = 0 ; for ( int i = 1 ; i <= A ; i ++ ) { long j = ( B2 / i ) + 1 ; if ( C >= j ) count = ( count + C - j + 1 ) ; if ( A >= j && C >= i ) count = ( count + ( C - i + 1 ) * ( A - j + 1 ) ) ; if ( A >= j ) A = ( int ) ( j - 1 ) ; } return count ; } static long count@@ Trip@@ lets ( int A , int B , int C ) { long ans = 0 ; for ( int i = 1 ; i <= B ; i ++ ) { ans = ( ans + getCount ( A , i * i , C ) ) ; } return ans ; } public static void main ( String [ ] args ) { int A , B , C ; A = 3 ; B = 2 ; C = 2 ; System . out . println ( count@@ Trip@@ lets ( A , B , C ) ) ; } }
class GF@@ G { static int sum ( int n ) { int sum = ( n * ( n + 1 ) ) / 2 ; return sum ; } static int repeated@@ Sum ( int n , int k ) { for ( int i = 0 ; i < k ; i ++ ) { n = sum ( n ) ; } return n ; } public static void main ( String [ ] args ) { int n = 2 , k = 2 ; System . out . println ( repeated@@ Sum ( n , k ) ) ; } }
import java . util . * ; class GF@@ G { static int MAX = 100000 ; static boolean [ ] prime = new boolean [ MAX + 1 ] ; static void Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( ) { for ( int i = 0 ; i < MAX + 1 ; i ++ ) { prime [ i ] = true ; } for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= MAX ; i += p ) prime [ i ] = false ; } } } static int smalle@@ st@@ Prime ( int d ) { int l = ( int ) Math . pow ( 10 , d - 1 ) ; int r = ( int ) Math . pow ( 10 , d ) - 1 ; for ( int i = l ; i <= r ; i ++ ) { if ( prime [ i ] ) { return i ; } } return - 1 ; } static int lar@@ gest@@ Prime ( int d ) { int l = ( int ) Math . pow ( 10 , d - 1 ) ; int r = ( int ) Math . pow ( 10 , d ) - 1 ; for ( int i = r ; i >= l ; i -- ) { if ( prime [ i ] ) { return i ; } } return - 1 ; } public static void main ( String [ ] args ) { Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( ) ; int queries [ ] = { 2 , 5 } ; int q = queries . length ; for ( int i = 0 ; i < q ; i ++ ) { System . out . println ( smalle@@ st@@ Prime ( queries [ i ] ) + " ▁ " + lar@@ gest@@ Prime ( queries [ i ] ) ) ; } } }
import java . math . * ; class GF@@ G { public static boolean possible ( int n ) { if ( n > 3 ) { int sum = ( n * ( n + 1 ) ) / 2 ; if ( sum % 3 == 0 ) { return true ; } } return false ; } public static void main ( String [ ] args ) { int n = 5 ; if ( possible ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . math . * ; class GF@@ G { public static void check@@ Type ( int arr [ ] , int n ) { if ( arr [ 0 ] <= arr [ 1 ] && arr [ n - 2 ] <= arr [ n - 1 ] ) System . out . println ( " Incre@@ asing " ) ; else if ( arr [ 0 ] >= arr [ 1 ] && arr [ n - 2 ] >= arr [ n - 1 ] ) System . out . println ( " Decre@@ asing " ) ; else if ( arr [ 0 ] <= arr [ 1 ] && arr [ n - 2 ] >= arr [ n - 1 ] ) System . out . println ( " Incre@@ asing ▁ then ▁ decre@@ asing " ) ; else System . out . println ( " Decre@@ asing ▁ then ▁ increasing " ) ; } public static void main ( String [ ] args ) { int [ ] arr = new int [ ] { 1 , 2 , 3 , 4 } ; int n = arr . length ; check@@ Type ( arr , n ) ; } }
class GF@@ G { static double sum ( double a , double b , double c , double d , double x ) { double ans = ( x * ( a + b ) * ( c - d ) ) / ( ( a * d ) - ( b * c ) ) ; return ans ; } public static void main ( String [ ] args ) { double a = 1 , b = 2 , c = 9 , d = 13 , x = 5 ; System . out . println ( sum ( a , b , c , d , x ) ) ; } }
class GF@@ G { static void print@@ Roots ( long a , long b , long c ) { System . out . println ( 1 + " , ▁ " + c / ( a * 1.0 ) ) ; } public static void main ( String [ ] args ) { long a = 2 ; long b = 3 ; long c = - 5 ; print@@ Roots ( a , b , c ) ; } }
import java . io . * ; class GF@@ G { static int Ma@@ x_@@ sum ( int a [ ] , int n ) { int pos = 0 , neg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > 0 ) pos = 1 ; else if ( a [ i ] < 0 ) neg = 1 ; if ( ( pos == 1 ) && ( neg == 1 ) ) break ; } int sum = 0 ; if ( ( pos == 1 ) && ( neg == 1 ) ) { for ( int i = 0 ; i < n ; i ++ ) sum += Math . abs ( a [ i ] ) ; } else if ( pos == 1 ) { int mini = a [ 0 ] ; sum = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { mini = Math . min ( mini , a [ i ] ) ; sum += a [ i ] ; } sum -= 2 * mini ; } else if ( neg == 1 ) { for ( int i = 0 ; i < n ; i ++ ) a [ i ] = Math . abs ( a [ i ] ) ; int mini = a [ 0 ] ; sum = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { mini = Math . min ( mini , a [ i ] ) ; sum += a [ i ] ; } sum -= 2 * mini ; } return sum ; } public static void main ( String [ ] args ) { int [ ] a = { 1 , 3 , 5 , - 2 , - 6 } ; int n = a . length ; System . out . println ( Ma@@ x_@@ sum ( a , n ) ) ; } }
import java . io . * ; class GF@@ G { static void decimal@@ To@@ Binary ( int n ) { if ( n == 0 ) { System . out . print ( "0" ) ; return ; } decimal@@ To@@ Binary ( n / 2 ) ; System . out . print ( n % 2 ) ; } public static void main ( String [ ] args ) { int n = 13 ; decimal@@ To@@ Binary ( n ) ; } }
class GF@@ G { static void Vertices ( int x , int y ) { int val = Math . abs ( x ) + Math . abs ( y ) ; System . out . print ( val * ( x < 0 ? - 1 : 1 ) + " ▁ 0 ▁ " ) ; System . out . print ( "0 ▁ " + val * ( y < 0 ? - 1 : 1 ) ) ; } public static void main ( String [ ] args ) { int x = 3 , y = 3 ; Vertices ( x , y ) ; } }
import java . util . * ; class GF@@ G { static int MAX = 32 ; static int count@@ Set@@ Bits ( int n ) { int count = 0 ; while ( n > 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; } static int pairs ( int arr [ ] , int n , int k ) { int count = 0 ; int [ ] f = new int [ MAX + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) f [ count@@ Set@@ Bits ( arr [ i ] ) ] ++ ; for ( int i = 0 ; i <= MAX ; i ++ ) { for ( int j = i ; j <= MAX ; j ++ ) { if ( i + j == k ) { if ( i == j ) count += ( ( f [ i ] * ( f [ i ] - 1 ) ) / 2 ) ; else count += ( f [ i ] * f [ j ] ) ; } } } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = arr . length ; int k = 4 ; System . out . println ( pairs ( arr , n , k ) ) ; } }
import java . io . * ; class GF@@ G { static int cn@@ t_@@ neg ; static boolean exist@@ s_@@ zero ; static void pre@@ Process ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 0 ) cn@@ t_@@ neg ++ ; if ( arr [ i ] == 0 ) exist@@ s_@@ zero = true ; } } static boolean is@@ Possible ( int k ) { if ( ! exist@@ s_@@ zero ) { if ( k >= cn@@ t_@@ neg && ( k - cn@@ t_@@ neg ) % 2 == 0 ) return true ; else return false ; } else { if ( k >= cn@@ t_@@ neg ) return true ; else return false ; } } public static void main ( String [ ] args ) { int arr [ ] = { - 1 , 2 , - 3 , 4 , 5 } ; int n = arr . length ; pre@@ Process ( arr , n ) ; int queries [ ] = { 1 , 2 , 3 , 4 } ; int q = arr . length ; for ( int i = 0 ; i < q ; i ++ ) { if ( is@@ Possible ( queries [ i ] ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } } }
import java . io . * ; class GF@@ G { static int MAX = 1000000 ; static int [ ] prime = new int [ MAX + 1 ] ; static void update@@ Pri@@ mes ( ) { for ( int i = 2 ; i <= MAX ; i ++ ) { prime [ i ] = 1 ; } prime [ 0 ] = prime [ 1 ] = 0 ; for ( int i = 2 ; i * i <= MAX ; i ++ ) { if ( prime [ i ] == 1 ) { for ( int j = i * i ; j <= MAX ; j += i ) { prime [ j ] = 0 ; } } } for ( int i = 1 ; i <= MAX ; i ++ ) { prime [ i ] += prime [ i - 1 ] ; } } static int get@@ Difference ( int l , int r ) { int total = r - l + 1 ; int primes = prime [ r ] - prime [ l - 1 ] ; int composi@@ tes = total - primes ; return ( Math . abs ( primes - composi@@ tes ) ) ; } public static void main ( String [ ] args ) { int queries [ ] [ ] = { { 1 , 10 } , { 5 , 30 } } ; int q = queries . length ; update@@ Pri@@ mes ( ) ; for ( int i = 0 ; i < q ; i ++ ) System . out . println ( get@@ Difference ( queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) ) ; } }
import java . io . * ; class GF@@ G { static int find@@ Index ( int [ ] a , int n , int k ) { int index = - 1 , max_@@ ceil = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = ( a [ i ] + k - 1 ) / k ; } for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= max_@@ ceil ) { max_@@ ceil = a [ i ] ; index = i ; } } return index ; } static public void main ( String [ ] args ) { int [ ] arr = { 31 , 12 , 25 , 27 , 32 , 19 } ; int K = 5 ; int N = arr . length ; System . out . print ( find@@ Index ( arr , N , K ) ) ; } }
import java . util . * ; class GF@@ G { static int Count_@@ Segment ( int p [ ] , int n ) { int count = 0 ; int [ ] upto = new int [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) upto [ i ] = 0 ; int j = 0 , curr = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( p [ i ] > p [ i - 1 ] && p [ i ] > p [ i + 1 ] ) { curr = p [ i ] ; j = i - 1 ; while ( j >= 0 && p [ j ] < curr ) { upto [ p [ j ] ] = curr ; j -= 1 ; } j = i + 1 ; while ( j < n && p [ j ] < curr ) { if ( upto [ curr - p [ j ] ] == curr ) count += 1 ; j += 1 ; } } } return count ; } public static void main ( String [ ] args ) { int p [ ] = { 3 , 4 , 1 , 5 , 2 } ; int n = p . length ; System . out . println ( Count_@@ Segment ( p , n ) ) ; } }
class GF@@ G { static int valid@@ Position ( int arr [ ] , int N , int K ) { int count = 0 , sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] + K ) > ( sum - arr [ i ] ) ) count ++ ; } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 1 , 6 , 7 } , K = 4 ; int N = arr . length ; System . out . println ( valid@@ Position ( arr , N , K ) ) ; } }
class GF@@ G { static int N = 1000 ; static int count@@ Pairs ( int arr [ ] , int n ) { int size = ( 2 * N ) + 1 ; int freq [ ] = new int [ size ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] ; freq [ x + N ] ++ ; } int ans = 0 ; for ( int i = 0 ; i < size ; i ++ ) { if ( freq [ i ] > 0 ) { ans += ( ( freq [ i ] ) * ( freq [ i ] - 1 ) ) / 2 ; for ( int j = i + 2 ; j < 2001 ; j += 2 ) { if ( freq [ j ] > 0 && ( freq [ ( i + j ) / 2 ] > 0 ) ) { ans += ( freq [ i ] * freq [ j ] ) ; } } } } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 2 , 5 , 1 , 3 , 5 } ; int n = arr . length ; System . out . println ( count@@ Pairs ( arr , n ) ) ; } }
class GF@@ G { static int highest@@ Power ( String str , int len ) { int ans = 0 ; for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( str . charAt ( i ) == '0' ) ans ++ ; else break ; } return ans ; } public static void main ( String [ ] args ) { String str = "100@@ 100" ; int len = str . length ( ) ; System . out . println ( highest@@ Power ( str , len ) ) ; } }
class GF@@ G { static boolean is@@ Possible ( int n ) { int fac [ ] = new int [ 10 ] ; fac [ 0 ] = fac [ 1 ] = 1 ; for ( int i = 2 ; i < 10 ; i ++ ) fac [ i ] = fac [ i - 1 ] * i ; int sum = 0 ; int x = n ; while ( x != 0 ) { sum += fac [ x % 10 ] ; x /= 10 ; } if ( sum % n == 0 ) return true ; return false ; } public static void main ( String [ ] args ) { int n = 19 ; if ( is@@ Possible ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; class GF@@ G { static boolean is@@ Per@@ fec@@ t@@ Square ( int [ ] arr , int n ) { HashMap < Integer , Integer > u@@ map = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( u@@ map . containsKey ( arr [ i ] ) ) u@@ map . put ( arr [ i ] , u@@ map . get ( arr [ i ] ) + 1 ) ; else u@@ map . put ( arr [ i ] , 1 ) ; } Iterator < Map . Entry < Integer , Integer > > iterator = u@@ map . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry < Integer , Integer > entry = iterator . next ( ) ; if ( entry . getValue ( ) % 2 == 1 ) return false ; } return true ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 2 , 7 , 7 } ; int n = arr . length ; if ( is@@ Per@@ fec@@ t@@ Square ( arr , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; class GF@@ G { static void print@@ Max@@ Val@@ Pair ( Vector < Long > v , int n ) { Collections . sort ( v ) ; long N = v . get ( ( int ) n - 1 ) ; if ( N % 2 == 1 ) { long first_@@ maxim@@ a = N / 2 ; long second_@@ maxim@@ a = first_@@ maxim@@ a + 1 ; long ans@@ 1 = ( long ) 3e@@ 18 , ans@@ 2 = ( long ) 3e@@ 18 ; long from_@@ left = - 1 , from_@@ right = - 1 ; long from = - 1 ; for ( long i = 0 ; i < n ; ++ i ) { if ( v . get ( ( int ) i ) > first_@@ maxim@@ a ) { from = i ; break ; } else { long diff = first_@@ maxim@@ a - v . get ( ( int ) i ) ; if ( diff < ans@@ 1 ) { ans@@ 1 = diff ; from_@@ left = v . get ( ( int ) i ) ; } } } from_@@ right = v . get ( ( int ) from ) ; long diff@@ 1 = first_@@ maxim@@ a - from_@@ left ; long diff@@ 2 = from_@@ right - second_@@ maxim@@ a ; if ( diff@@ 1 < diff@@ 2 ) System . out . println ( N + " ▁ " + from_@@ left ) ; else System . out . println ( N + " ▁ " + from_@@ right ) ; } else { long maxim@@ a = N / 2 ; long ans@@ 1 = ( int ) 3e@@ 18 ; long R = - 1 ; for ( long i = 0 ; i < n - 1 ; ++ i ) { long diff = Math . abs ( v . get ( ( int ) i ) - maxim@@ a ) ; if ( diff < ans@@ 1 ) { ans@@ 1 = diff ; R = v . get ( ( int ) i ) ; } } System . out . println ( N + " ▁ " + R ) ; } } public static void main ( String args [ ] ) { long arr [ ] = { 1 , 1 , 2 , 3 , 6 , 1 } ; Vector < Long > v = new Vector < Long > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) v . add ( arr [ i ] ) ; int n = v . size ( ) ; print@@ Max@@ Val@@ Pair ( v , n ) ; } }
import java . util . * ; class GF@@ G { static int count@@ Quad@@ rup@@ les ( int a [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( mp . containsKey ( a [ i ] ) ) { mp . put ( a [ i ] , mp . get ( a [ i ] ) + 1 ) ; } else { mp . put ( a [ i ] , 1 ) ; } int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( j == k ) continue ; mp . put ( a [ j ] , mp . get ( a [ j ] ) - 1 ) ; mp . put ( a [ k ] , mp . get ( a [ k ] ) - 1 ) ; int first = a [ j ] - ( a [ k ] - a [ j ] ) ; int fourth = ( a [ k ] * a [ k ] ) / a [ j ] ; if ( ( a [ k ] * a [ k ] ) % a [ j ] == 0 ) { if ( a [ j ] != a [ k ] ) { if ( mp . containsKey ( first ) && mp . containsKey ( fourth ) ) count += mp . get ( first ) * mp . get ( fourth ) ; } else if ( mp . containsKey ( first ) && mp . containsKey ( fourth ) ) count += mp . get ( first ) * ( mp . get ( fourth ) - 1 ) ; } if ( mp . containsKey ( a [ j ] ) ) { mp . put ( a [ j ] , mp . get ( a [ j ] ) + 1 ) ; } else { mp . put ( a [ j ] , 1 ) ; } if ( mp . containsKey ( a [ k ] ) ) { mp . put ( a [ k ] , mp . get ( a [ k ] ) + 1 ) ; } else { mp . put ( a [ k ] , 1 ) ; } } } return count ; } public static void main ( String [ ] args ) { int a [ ] = { 2 , 6 , 4 , 9 , 2 } ; int n = a . length ; System . out . print ( count@@ Quad@@ rup@@ les ( a , n ) ) ; } }
class So@@ l { static int getPosition ( int n , int m ) { if ( m > ( n / 2 ) ) return ( m - ( n / 2 ) ) ; return ( m + ( n / 2 ) ) ; } public static void main ( String args [ ] ) { int n = 8 , m = 5 ; System . out . println ( getPosition ( n , m ) ) ; } }
class GF@@ G { static int parity ( int a ) { return a % 3 ; } static int solve ( int [ ] array , int size ) { int operations = 0 ; for ( int i = 0 ; i < size - 1 ; i ++ ) { if ( parity ( array [ i ] ) == parity ( array [ i + 1 ] ) ) { operations ++ ; if ( i + 2 < size ) { int par@@ i1 = parity ( array [ i ] ) ; int par@@ i2 = parity ( array [ i + 2 ] ) ; if ( par@@ i1 == par@@ i2 ) { if ( par@@ i1 == 0 ) array [ i + 1 ] = 1 ; else if ( par@@ i1 == 1 ) array [ i + 1 ] = 0 ; else array [ i + 1 ] = 1 ; } else { if ( ( par@@ i1 == 0 && par@@ i2 == 1 ) || ( par@@ i1 == 1 && par@@ i2 == 0 ) ) array [ i + 1 ] = 2 ; if ( ( par@@ i1 == 1 && par@@ i2 == 2 ) || ( par@@ i1 == 2 && par@@ i2 == 1 ) ) array [ i + 1 ] = 0 ; if ( ( par@@ i1 == 2 && par@@ i2 == 0 ) || ( par@@ i1 == 0 && par@@ i2 == 2 ) ) array [ i + 1 ] = 1 ; } } } } return operations ; } public static void main ( String arg [ ] ) { int [ ] array = { 2 , 1 , 3 , 0 } ; int size = array . length ; System . out . println ( solve ( array , size ) ) ; } }
class GF@@ G { static int check@@ Array ( int [ ] arr , int n ) { return ( ( arr [ 0 ] % 2 ) > 0 && ( arr [ n - 1 ] % 2 ) > 0 && ( n % 2 ) > 0 ) ? 1 : 0 ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 } ; int n = arr . length ; System . out . println ( check@@ Array ( arr , n ) ) ; } }
import java . util . * ; class GF@@ G { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static int count@@ Trip@@ lets ( int n , Vector < pair > points ) { Set < pair > pts = new HashSet < pair > ( ) ; int ct = 0 ; for ( int i = 0 ; i < n ; i ++ ) pts . add ( points . get ( i ) ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) { int x = points . get ( i ) . first + points . get ( j ) . first ; int y = points . get ( i ) . second + points . get ( j ) . second ; if ( x % 2 == 0 && y % 2 == 0 ) if ( ! pts . contains ( new pair ( x / 2 , y / 2 ) ) ) ct ++ ; } return ct ; } public static void main ( String args [ ] ) { Vector < pair > points = new Vector < > ( ) ; points . add ( new pair ( 1 , 1 ) ) ; points . add ( new pair ( 2 , 2 ) ) ; points . add ( new pair ( 3 , 3 ) ) ; int n = points . size ( ) ; System . out . println ( count@@ Trip@@ lets ( n , points ) ) ; } }
import java . util . * ; class GF@@ G { static int gcd ( int a , int b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; } static int l@@ cm@@ Of@@ Array ( int arr [ ] , int n ) { if ( n < 1 ) return 0 ; int l@@ cm = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) l@@ cm = ( l@@ cm * arr [ i ] ) / gcd ( l@@ cm , arr [ i ] ) ; return l@@ cm ; } static int min@@ Per@@ fec@@ t@@ Cube ( int arr [ ] , int n ) { int min@@ Per@@ fec@@ t@@ Cube ; int l@@ cm = l@@ cm@@ Of@@ Array ( arr , n ) ; min@@ Per@@ fec@@ t@@ Cube = l@@ cm ; int cnt = 0 ; while ( l@@ cm > 1 && l@@ cm % 2 == 0 ) { cnt ++ ; l@@ cm /= 2 ; } if ( cnt % 3 == 2 ) min@@ Per@@ fec@@ t@@ Cube *= 2 ; else if ( cnt % 3 == 1 ) min@@ Per@@ fec@@ t@@ Cube *= 4 ; int i = 3 ; while ( l@@ cm > 1 ) { cnt = 0 ; while ( l@@ cm % i == 0 ) { cnt ++ ; l@@ cm /= i ; } if ( cnt % 3 == 1 ) min@@ Per@@ fec@@ t@@ Cube *= i * i ; else if ( cnt % 3 == 2 ) min@@ Per@@ fec@@ t@@ Cube *= i ; i += 2 ; } return min@@ Per@@ fec@@ t@@ Cube ; } public static void main ( String args [ ] ) { int arr [ ] = { 10 , 125 , 14 , 42 , 100 } ; int n = arr . length ; System . out . println ( min@@ Per@@ fec@@ t@@ Cube ( arr , n ) ) ; } }
import java . util . * ; class Solution { static int max@@ GC@@ D ( int N , int P ) { int ans = 1 ; Map < Integer , Integer > pri@@ me_@@ factors = new HashMap < Integer , Integer > ( ) ; for ( int i = 2 ; i * i <= P ; i ++ ) { while ( P % i == 0 ) { if ( pri@@ me_@@ factors . get ( i ) == null ) pri@@ me_@@ factors . put ( i , 1 ) ; else pri@@ me_@@ factors . put ( i , ( pri@@ me_@@ factors . get ( i ) + 1 ) ) ; P /= i ; } } if ( P != 1 ) if ( pri@@ me_@@ factors . get ( P ) == null ) pri@@ me_@@ factors . put ( P , 1 ) ; else pri@@ me_@@ factors . put ( P , ( pri@@ me_@@ factors . get ( P ) + 1 ) ) ; Set < Map . Entry < Integer , Integer > > st = pri@@ me_@@ factors . entrySet ( ) ; for ( Map . Entry < Integer , Integer > me : st ) { ans *= Math . pow ( me . getKey ( ) , me . getValue ( ) / N ) ; } return ans ; } public static void main ( String args [ ] ) { int N = 3 , P = 24 ; System . out . println ( max@@ GC@@ D ( N , P ) ) ; } }
import java . util . * ; public class GF@@ G { public static ArrayList < Integer > get@@ Per@@ fec@@ t@@ Squ@@ ares ( int n ) { ArrayList < Integer > perfec@@ t@@ Squ@@ ares = new ArrayList < > ( ) ; int current = 1 , i = 1 ; while ( current <= n ) { perfec@@ t@@ Squ@@ ares . add ( current ) ; current = ( int ) Math . pow ( ++ i , 2 ) ; } return perfec@@ t@@ Squ@@ ares ; } public static int count@@ Trip@@ lets ( int n ) { ArrayList < Integer > perfec@@ t@@ Squ@@ ares = get@@ Per@@ fec@@ t@@ Squ@@ ares ( ( int ) Math . pow ( n , 2 ) ) ; int count = 0 ; for ( int a = 1 ; a <= n ; a ++ ) { int a@@ Square = ( int ) Math . pow ( a , 2 ) ; for ( int i = 0 ; i < perfec@@ t@@ Squ@@ ares . size ( ) ; i ++ ) { int c@@ Square = perfec@@ t@@ Squ@@ ares . get ( i ) ; int b@@ Square = c@@ Square - a@@ Square ; int b = ( int ) Math . sqrt ( b@@ Square ) ; int c = ( int ) Math . sqrt ( c@@ Square ) ; if ( c < a || ! perfec@@ t@@ Squ@@ ares . contains ( b@@ Square ) ) continue ; if ( ( b >= a ) && ( b <= c ) && ( a@@ Square + b@@ Square == c@@ Square ) ) count ++ ; } } return count ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( count@@ Trip@@ lets ( n ) ) ; } }
import java . io . * ; class GF@@ G { static void Min@@ Steps ( int Source@@ X , int Source@@ Y , int Dest@@ X , int Dest@@ Y ) { System . out . println ( Math . max ( Math . abs ( Source@@ X - Dest@@ X ) , Math . abs ( Source@@ Y - Dest@@ Y ) ) ) ; while ( ( Source@@ X != Dest@@ X ) || ( Source@@ Y != Dest@@ Y ) ) { if ( Source@@ X < Dest@@ X ) { System . out . print ( ' U ' ) ; Source@@ X ++ ; } if ( Source@@ X > Dest@@ X ) { System . out . println ( ' D ' ) ; Source@@ X -- ; } if ( Source@@ Y > Dest@@ Y ) { System . out . print ( ' L ' ) ; Source@@ Y -- ; } if ( Source@@ Y < Dest@@ Y ) { System . out . print ( ' R ' ) ; Source@@ Y ++ ; } System . out . println ( ) ; } } public static void main ( String [ ] args ) { int source@@ X = 4 , source@@ Y = 4 ; int destination@@ X = 7 , destination@@ Y = 0 ; Min@@ Steps ( source@@ X , source@@ Y , destination@@ X , destination@@ Y ) ; } }
class GF@@ G { static boolean is@@ Pal@@ ind@@ ro@@ me ( int num ) { int reverse_@@ num = 0 , remainder , temp ; temp = num ; while ( temp != 0 ) { remainder = temp % 10 ; reverse_@@ num = reverse_@@ num * 10 + remainder ; temp /= 10 ; } if ( reverse_@@ num == num ) { return true ; } return false ; } static boolean is@@ O@@ dd@@ Length ( int num ) { int count = 0 ; while ( num > 0 ) { num /= 10 ; count ++ ; } if ( count % 2 != 0 ) { return true ; } return false ; } static long sum@@ Of@@ All@@ Pal@@ ind@@ ro@@ me ( int L , int R ) { long sum = 0 ; if ( L <= R ) for ( int i = L ; i <= R ; i ++ ) { if ( is@@ Pal@@ ind@@ ro@@ me ( i ) && is@@ O@@ dd@@ Length ( i ) ) { sum += i ; } } return sum ; } public static void main ( String [ ] args ) { int L = 110 , R = 11@@ 30 ; System . out . println ( sum@@ Of@@ All@@ Pal@@ ind@@ ro@@ me ( L , R ) ) ; } }
class GF@@ G { static boolean product@@ Sum@@ Di@@ visible ( int n , int size ) { int sum = 0 , product = 1 ; while ( n > 0 ) { if ( size % 2 == 0 ) { product *= n % 10 ; } else { sum += n % 10 ; } n = n / 10 ; size -- ; } if ( product % sum == 0 ) { return true ; } return false ; } public static void main ( String [ ] args ) { int n = 1234 ; int len = 4 ; if ( product@@ Sum@@ Di@@ visible ( n , len ) ) { System . out . println ( " TRUE " ) ; } else { System . out . println ( " FALSE " ) ; } } }
import java . lang . * ; import java . util . * ; class GF@@ G { static void count@@ Digit ( int n ) { int temp = n , sum = 0 , product = 1 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 ) { sum += d ; product *= d ; } } System . out . print ( " Sum ▁ = ▁ " + sum ) ; System . out . print ( " Product = " + product@@ )@@ ; } public static void main ( String args [ ] ) { int n = 101@@ 2 ; count@@ Digit ( n ) ; } }
class GF@@ G { static int MAX = 1000000 ; static boolean [ ] prime = new boolean [ MAX + 1 ] ; static void Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( ) { prime [ 1 ] = true ; prime [ 0 ] = true ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == false ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = true ; } } } static void product@@ Of@@ K@@ th@@ Pri@@ mes ( int arr [ ] , int n , int k ) { int c = 0 ; int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! prime [ arr [ i ] ] ) { c ++ ; if ( c % k == 0 ) { product *= arr [ i ] ; c = 0 ; } } } System . out . println ( product ) ; } public static void main ( String [ ] args ) { Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( ) ; int n = 5 , k = 2 ; int [ ] arr = new int [ ] { 2 , 3 , 5 , 7 , 11 } ; product@@ Of@@ K@@ th@@ Pri@@ mes ( arr , n , k ) ; } }
class GF@@ G { static long n@@ th@@ Ky@@ ne@@ a@@ Number ( int n ) { return ( ( 1 << ( 2 * n ) ) + ( 1 << ( n + 1 ) ) - 1 ) ; } public static void main ( String [ ] args ) { int n = 2 ; System . out . println ( n@@ th@@ Ky@@ ne@@ a@@ Number ( n ) ) ; } }
import java . io . * ; class GF@@ G { static int fn@@ Mod ( int n ) { int rem = n % 4 ; if ( rem == 0 rem == 3 ) return 0 ; else if ( rem == 1 rem == 2 ) return 1 ; return 0 ; } public static void main ( String [ ] args ) { int n = 6 ; System . out . print ( fn@@ Mod ( n ) ) ; } }
import java . io . * ; import java . util . * ; import java . lang . * ; class GF@@ G { static int mod@@ Exp ( int a , int b ) { int result = 1 ; while ( b > 0 ) { if ( b == 1 ) result = result * a ; a = a * a ; b /= 2 ; } return result ; } static int check ( int num ) { if ( num == 1 num < 3 ) return - 1 ; else if ( num % 4 == 0 ) return mod@@ Exp ( num / 4 , 4 ) ; else if ( num % 6 == 0 ) return mod@@ Exp ( num / 3 , 2 ) * mod@@ Exp ( num / 6 , 2 ) ; else if ( num % 10 == 0 ) return mod@@ Exp ( num / 5 , 2 ) * ( num / 10 ) * ( num / 2 ) ; else return - 1 ; } public static void main ( String [ ] args ) { int num = 10 ; System . out . print ( check ( num ) ) ; } }
public class GF@@ G { static int Race ( int B , int C ) { int result = 0 ; result = ( ( C * 100 ) / B ) ; return 100 - result ; } public static void main ( String [ ] args ) { int B = 10 ; int C = 28 ; B = 100 - B ; C = 100 - C ; System . out . println ( Race ( B , C ) + " ▁ meters " ) ; } }
import java . io . * ; class GF@@ G { static long bin@@ omi@@ al@@ Coeff ( long n , long k ) { long res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } static long catal@@ an ( long n ) { long c = bin@@ omi@@ al@@ Coeff ( 2 * n , n ) ; return c / ( n + 1 ) ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( catal@@ an ( n ) ) ; } }
import java . io . * ; import java . lang . Math ; class GF@@ G { static void distance ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 ) { double d = Math . pow ( ( Math . pow ( x2 - x1 , 2 ) + Math . pow ( y2 - y1 , 2 ) + Math . pow ( z2 - z1 , 2 ) * 1.0 ) , 0.5 ) ; System . out . println ( " Distance ▁ is ▁ " + d ) ; return ; } public static void main ( String [ ] args ) { float x1 = 2 ; float y1 = - 5 ; float z1 = 7 ; float x2 = 3 ; float y2 = 4 ; float z2 = 5 ; distance ( x1 , y1 , z1 , x2 , y2 , z2 ) ; } }
import java . io . * ; class GF@@ G { static void find@@ Greater ( int a , int b , int n ) { if ( ! ( ( n & 1 ) > 0 ) ) { a = Math . abs ( a ) ; b = Math . abs ( b ) ; } if ( a == b ) System . out . println ( " a ^ n ▁ is ▁ " + " equal ▁ to ▁ b ^ n " ) ; else if ( a > b ) System . out . println ( " a ^ n ▁ is ▁ greater ▁ " + " than ▁ b ^ n " ) ; else System . out . println ( " b ^ n ▁ is ▁ greater ▁ " + " than ▁ a ^ n " ) ; } public static void main ( String [ ] args ) { int a = 12 , b = 24 , n = 5 ; find@@ Greater ( a , b , n ) ; } }
import java . io . * ; class GF@@ G { static int subtr@@ act@@ One ( int x ) { int m = 1 ; while ( ! ( ( x & m ) > 0 ) ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; } public static void main ( String [ ] args ) { System . out . println ( subtr@@ act@@ One ( 13 ) ) ; } }
import java . lang . Math . * ; class GF@@ G { static final double PI = 3.14@@ 2 ; static double cos@@ X@@ Ser@@ ties@@ Sum ( double x , int n ) { x = x * ( PI / 180.0 ) ; double res = 1 ; double sign = 1 , fact = 1 , pow = 1 ; for ( int i = 1 ; i < 5 ; i ++ ) { sign = sign * - 1 ; fact = fact * ( 2 * i - 1 ) * ( 2 * i ) ; pow = pow * x * x ; res = res + sign * pow / fact ; } return res ; } public static void main ( String [ ] args ) { float x = 50 ; int n = 5 ; System . out . println ( ( float ) ( cos@@ X@@ Ser@@ ties@@ Sum ( x , 5 ) * 1000000 ) / 1000000@@ .@@ 00 ) ; } }
import java . lang . System . * ; class GF@@ G { static int find@@ Bucket@@ No ( int p ) { return ( int ) Math . ceil ( ( Math . sqrt ( 8 * p + 1 ) - 1 ) / 2 ) ; } public static void main ( String [ ] args ) { int p = 10 ; System . out . println ( find@@ Bucket@@ No ( p ) ) ; } }
import java . util . * ; class GF@@ G { static int MAX = 500@@ 02 ; static ArrayList < Integer > primes = new ArrayList < Integer > ( ) ; public static void si@@ eve ( ) { boolean is@@ Prime [ ] = new boolean [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) is@@ Prime [ i ] = true ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( is@@ Prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) is@@ Prime [ i ] = false ; } } for ( int p = 2 ; p < MAX ; p ++ ) if ( is@@ Prime [ p ] == true ) primes . add ( p ) ; } public static int power ( int x , int y ) { int count = 0 ; int z = y ; while ( x >= z ) { count += ( x / z ) ; z *= y ; } return count ; } public static int mod@@ Mult ( int a , int b , int mod ) { int res = 0 ; a = a % mod ; while ( b > 0 ) { if ( b % 2 == 1 ) res = ( res + a ) % mod ; a = ( a * 2 ) % mod ; b /= 2 ; } return res % mod ; } public static int count@@ W@@ ays ( int n , int m ) { int ans = 1 ; for ( int i = 1 ; i < primes . size ( ) ; i ++ ) { int powers = power ( n , primes . get ( i ) ) ; if ( powers == 0 ) break ; ans = mod@@ Mult ( ans , powers + 1 , m ) % m ; } if ( ( ( ans - 1 ) % m ) < 0 ) return ( ans - 1 + m ) % m ; else return ( ans - 1 ) % m ; } public static void main ( String [ ] args ) { si@@ eve ( ) ; int n = 4 , m = 7 ; System . out . println ( count@@ W@@ ays ( n , m ) ) ; } }
class GF@@ G { static void py@@ th@@ ag@@ ore@@ an@@ Trip@@ let ( int n ) { for ( int i = 1 ; i <= n / 3 ; i ++ ) { for ( int j = i + 1 ; j <= n / 2 ; j ++ ) { int k = n - i - j ; if ( i * i + j * j == k * k ) { System . out . print ( i + " , ▁ " + j + " , ▁ " + k ) ; return ; } } } System . out . print ( " No ▁ Trip@@ let " ) ; } public static void main ( String arg [ ] ) { int n = 12 ; py@@ th@@ ag@@ ore@@ an@@ Trip@@ let ( n ) ; } }
class GF@@ G { static int dig@@ Sum ( int n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; } static int repeated@@ Number@@ Sum ( int n , int x ) { int sum = x * dig@@ Sum ( n ) ; return dig@@ Sum ( sum ) ; } public static void main ( String [ ] args ) { int n = 24 , x = 3 ; System . out . println ( repeated@@ Number@@ Sum ( n , x ) ) ; } }
class GF@@ G { static final int MAX = 100000 ; static int multiply ( int x , int res [ ] , int res@@ _size ) { int carry = 0 ; for ( int i = 0 ; i < res@@ _size ; i ++ ) { int prod = res [ i ] * x + carry ; res [ i ] = prod % 10 ; carry = prod / 10 ; } while ( carry > 0 ) { res [ res@@ _size ] = carry % 10 ; carry = carry / 10 ; res@@ _size ++ ; } return res@@ _size ; } static void power ( int x , int n ) { if ( n == 0 ) { System . out . print ( "1" ) ; return ; } int res [ ] = new int [ MAX ] ; int res@@ _size = 0 ; int temp = x ; while ( temp != 0 ) { res [ res@@ _size ++ ] = temp % 10 ; temp = temp / 10 ; } for ( int i = 2 ; i <= n ; i ++ ) res@@ _size = multiply ( x , res , res@@ _size ) ; System . out . print ( x + " ^ " + n + " ▁ = ▁ " ) ; for ( int i = res@@ _size - 1 ; i >= 0 ; i -- ) System . out . print ( res [ i ] ) ; } public static void main ( String [ ] args ) { int exponent = 100 ; int base = 2 ; power ( base , exponent ) ; } }
class GF@@ G { static double find@@ Area ( double d ) { return ( d * d ) / 2 ; } public static void main ( String [ ] args ) { double d = 10 ; System . out . println ( find@@ Area ( d ) ) ; } }
import java . io . * ; class GF@@ G { static void find@@ Numbers ( int n , int d ) { for ( int i = 0 ; i < n - 2 ; i ++ ) System . out . print ( "1" + " ▁ " ) ; System . out . print ( "2" + " ▁ " ) ; System . out . println ( n + d ) ; } public static void main ( String args [ ] ) { int N = 3 , D = 5 ; find@@ Numbers ( N , D ) ; } }
import java . io . * ; public class GF@@ G { static float Av@@ go@@ f@@ Square@@ N ( int n ) { float sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum / n ; } static public void main ( String [ ] args ) { int n = 2 ; System . out . println ( Av@@ go@@ f@@ Square@@ N ( n ) ) ; } }
import java . util . * ; class GF@@ G { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static int LC@@ M ( int a , int b ) { return ( a * b ) / ( __@@ gcd ( a , b ) ) ; } static int __@@ gcd ( int a , int b ) { return b == 0 ? a : __@@ gcd ( b , a % b ) ; } static int l@@ cm@@ Of@@ Numer@@ ator ( Vector < pair > vect ) { int l@@ cm = vect . get ( 0 ) . first ; for ( int i = 1 ; i < vect . size ( ) ; i ++ ) l@@ cm = LC@@ M ( vect . get ( i ) . first , l@@ cm ) ; return l@@ cm ; } static int g@@ cd@@ Of@@ De@@ mon@@ in@@ ators ( Vector < pair > vect ) { int gcd = vect . get ( 0 ) . second ; for ( int i = 1 ; i < vect . size ( ) ; i ++ ) gcd = __@@ gcd ( vect . get ( i ) . second , gcd ) ; return gcd ; } static void l@@ cm@@ Of@@ R@@ ation@@ als ( Vector < pair > vect ) { System . out . print ( l@@ cm@@ Of@@ Numer@@ ator ( vect ) + " / " + g@@ cd@@ Of@@ De@@ mon@@ in@@ ators ( vect ) ) ; } public static void main ( String [ ] args ) { Vector < pair > vect = new Vector < pair > ( ) ; vect . add ( new pair ( 2 , 7 ) ) ; vect . add ( new pair ( 3 , 14 ) ) ; vect . add ( new pair ( 5 , 3 ) ) ; l@@ cm@@ Of@@ R@@ ation@@ als ( vect ) ; } }
import java . io . * ; class GF@@ G { static int su@@ mo@@ f@@ N@@ term ( int a , int d , int b , int r , int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( ( a + ( i - 1 ) * d ) * ( b * Math . pow ( r , i - 1 ) ) ) ; return sum ; } public static void main ( String args [ ] ) { int a = 1 , d = 1 , b = 2 , r = 2 , n = 3 ; System . out . println ( su@@ mo@@ f@@ N@@ term ( a , d , b , r , n ) ) ; } }
import java . util . * ; import java . lang . * ; public class Gf@@ G { public static int first ( int a , int b , int c ) { a %= b ; for ( int i = 1 ; i <= b ; i ++ ) { a = a * 10 ; if ( a / b == c ) return i ; a %= b ; } return - 1 ; } public static void main ( String argc [ ] ) { int a = 1 , b = 4 , c = 5 ; System . out . println ( first ( a , b , c ) ) ; } }
import java . util . * ; class GF@@ G { static boolean is@@ Prime ( int n ) { int i = 2 ; while ( i * i <= n ) { if ( n % i == 0 ) return false ; i ++ ; } return true ; } static int minimum@@ Sum ( int n ) { if ( is@@ Prime ( n ) ) return 1 ; if ( n % 2 == 0 ) return 2 ; if ( is@@ Prime ( n - 2 ) ) return 2 ; return 3 ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( minimum@@ Sum ( n ) ) ; } }
import java . io . * ; class GF@@ G { static int term ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans += i ; return ans ; } public static void main ( String args [ ] ) { int n = 4 ; System . out . println ( term ( n ) ) ; } }
class GF@@ G { static double sum ( int x , int n ) { double i , total = 1.0 , multi = x ; for ( i = 1 ; i <= n ; i ++ ) { total = total + multi / i ; multi = multi * x ; } return total ; } public static void main ( String [ ] args ) { int x = 2 ; int n = 5 ; System . out . printf ( " % .2f " , sum ( x , n ) ) ; } }
import java . io . * ; class GF@@ G { static double gcd ( double a , double b ) { if ( a < b ) return gcd ( b , a ) ; if ( Math . abs ( b ) < 0.001 ) return a ; else return ( gcd ( b , a - Math . floor ( a / b ) * b ) ) ; } public static void main ( String args [ ] ) { double a = 1.@@ 20 , b = 2@@ 2.5 ; System . out . printf ( " % .1f " , gcd ( a , b ) ) ; } }
class GF@@ G { static void g@@ cd@@ Max ( int [ ] a , int [ ] b , int n , int N ) { int [ ] cnt = new int [ N ] ; int [ ] first = new int [ N ] ; int [ ] second = new int [ N ] ; for ( int i = 0 ; i < n ; ++ i ) cnt [ a [ i ] ] = 1 ; for ( int i = 1 ; i < N ; ++ i ) for ( int j = i ; j < N ; j += i ) if ( cnt [ j ] > 0 ) first [ i ] = Math . max ( first [ i ] , j ) ; cnt = new int [ N ] ; for ( int i = 0 ; i < n ; ++ i ) cnt [ b [ i ] ] = 1 ; for ( int i = 1 ; i < N ; ++ i ) for ( int j = i ; j < N ; j += i ) if ( cnt [ j ] > 0 ) second [ i ] = Math . max ( second [ i ] , j ) ; int x ; for ( x = N - 1 ; x >= 0 ; x -- ) if ( first [ x ] > 0 && second [ x ] > 0 ) break ; System . out . println ( first [ x ] + " ▁ " + second [ x ] ) ; } public static void main ( String [ ] args ) { int [ ] a = { 3 , 1 , 4 , 2 , 8 } ; int [ ] b = { 5 , 2 , 12 , 8 , 3 } ; int n = a . length ; int N = 20 ; g@@ cd@@ Max ( a , b , n , N ) ; } }
class Sub@@ array { static int calculate ( int a [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int r = i + 1 ; for ( int j = r ; j < n ; j ++ ) { if ( a [ i ] == a [ j ] ) r += 1 ; else break ; } int d = r - i ; ans += ( d * ( d + 1 ) / 2 ) ; i = r - 1 ; } return ans ; } public static void main ( String [ ] args ) { int a [ ] = { 2 , 4 , 5 , 3 , 3 , 3 } ; System . out . println ( calculate ( a , a . length ) ) ; } }
import java . io . * ; class GF@@ G { static int sum ( int n ) { int rem = 0 ; int sum_@@ of_@@ digits = 0 ; while ( n > 0 ) { rem = n % 10 ; sum_@@ of_@@ digits += rem ; n = n / 10 ; } return sum_@@ of_@@ digits ; } static int count ( int n ) { int c = 0 ; for ( int i = n - 97 ; i <= n ; i ++ ) { int a = sum ( i ) ; int b = sum ( a ) ; if ( ( i + a + b ) == n ) { c += 1 ; } } return c ; } public static void main ( String [ ] args ) { int n = 99@@ 39 ; System . out . println ( count ( n ) ) ; } }
import java . util . * ; import java . lang . Math ; class GF@@ G { static ArrayList < Integer > Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( int n ) { boolean [ ] prime = new boolean [ n + 1 ] ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == false ) for ( int i = p * 2 ; i < n + 1 ; i += p ) prime [ i ] = true ; } ArrayList < Integer > lis = new ArrayList < Integer > ( ) ; for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] == false ) lis . add ( p ) ; return lis ; } static int set@@ Bits ( int n ) { return Integer . bit@@ Count ( n ) ; } public static int log2 ( int x ) { return ( int ) ( Math . log ( x ) / Math . log ( 2 ) + 1e-@@ 10 ) ; } public static void main ( String [ ] args ) { int x = 4 , y = 8 ; int count = 0 ; ArrayList < Integer > prime@@ Arr = new ArrayList < Integer > ( ) ; prime@@ Arr = Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( ( int ) Math . ceil ( log2 ( y ) ) ) ; for ( int i = x ; i < y + 1 ; i ++ ) { int temp = set@@ Bits ( i ) ; if ( prime@@ Arr . contains ( temp ) ) count += 1 ; } System . out . println ( count ) ; } }
import java . io . * ; class GF@@ G { public static int count@@ Trailing@@ Zero@@ es ( int N ) { int res = N ^ ( N - 1 ) ; return ( int ) ( Math . log ( temp ) / Math . log ( 2 ) ) ; } public static void main ( String [ ] args ) { int N = 12 ; System . out . println ( count@@ Trailing@@ Zero@@ es ( N ) ) ; } }
import java . io . * ; import java . util . * ; class GF@@ G { public static int formed_@@ no ( int N , int K ) { if ( K == 1 ) { return N ; } int answer = N ; while ( K != 0 ) { int a_@@ current = prod_@@ of_@@ max_@@ min ( answer ) ; if ( a_@@ current == 0 ) break ; answer += a_@@ current ; } return answer ; } static int prod_@@ of_@@ max_@@ min ( int n ) { int largest = 0 ; int smallest = 10 ; while ( n != 0 ) { int r = n % 10 ; largest = Math . max ( r , largest ) ; smallest = Math . min ( r , smallest ) ; n = n / 10 ; } return largest * smallest ; } public static void main ( String [ ] args ) { int N = 48@@ 7 , K = 1@@ 00000000 ; System . out . println ( formed_@@ no ( N , K ) ) ; } }
import java . util . * ; class GF@@ G { static int sub@@ set@@ Sum ( int arr [ ] , int n , int sum , int s , int count ) { if ( n == 0 ) { if ( sum == s ) { count ++ ; } return count ; } count = sub@@ set@@ Sum ( arr , n - 1 , sum , s , count ) ; count = sub@@ set@@ Sum ( arr , n - 1 , sum , s + arr [ n - 1 ] , count ) ; return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int sum = 10 ; int n = arr . length ; System . out . print ( sub@@ set@@ Sum ( arr , n , sum , s , 0 ) ) ; } }
class GF@@ G { static boolean does@@ Contain@@ B ( int a , int b , int c ) { if ( a == b ) { return true ; } if ( ( b - a ) * c > 0 && ( b - a ) % c == 0 ) { return true ; } return false ; } public static void main ( String [ ] args ) { int a = 1 , b = 7 , c = 3 ; if ( does@@ Contain@@ B ( a , b , c ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
class GF@@ G { static int subtr@@ act@@ One ( int x ) { return ( ( x << 1 ) + ( ~ x ) ) ; } public static void main ( String [ ] args ) { System . out . printf ( " % d " , subtr@@ act@@ One ( 13 ) ) ; } }
import java . io . * ; class GF@@ G { static int digit@@ Sum ( long n ) { int dig@@ Sum = 0 ; while ( n > 0 ) { dig@@ Sum += n % 10 ; n /= 10 ; } return dig@@ Sum ; } public static long count@@ Integer ( long n , long s ) { if ( n < s ) return 0 ; for ( long i = s ; i <= Math . min ( n , s + 163 ) ; i ++ ) if ( ( i - digit@@ Sum ( i ) ) > s ) return ( n - i + 1 ) ; return 0 ; } public static void main ( String args [ ] ) { long n = 1000 , s = 100 ; System . out . println ( count@@ Integer ( n , s ) ) ; } }
import java . util . * ; class GF@@ G { static double sum@@ Of@@ Series ( int n ) { return 0.02@@ 46 * ( Math . pow ( 10 , n ) - 1 - ( 9 * n ) ) ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( sum@@ Of@@ Series ( n ) ) ; } }
import java . io . * ; class GF@@ G { static void print_@@ sequence ( int n , int k ) { int b = n / ( k * ( k + 1 ) / 2 ) ; if ( b == 0 ) { System . out . println ( " - 1" ) ; } else { int r = 1 ; for ( int x = 1 ; x * x <= n ; x ++ ) { if ( n % x != 0 ) continue ; if ( x <= b && x > r ) r = x ; if ( n / x <= b && n / x > r ) r = n / x ; } for ( int i = 1 ; i < k ; i ++ ) System . out . print ( r * i + " ▁ " ) ; int res = n - ( r * ( k * ( k - 1 ) / 2 ) ) ; System . out . println ( res ) ; } } public static void main ( String [ ] args ) { int n = 24 ; int k = 4 ; print_@@ sequence ( n , k ) ; n = 24 ; k = 5 ; print_@@ sequence ( n , k ) ; n = 6 ; k = 4 ; print_@@ sequence ( n , k ) ; } }
import java . util . * ; class GF@@ G { static int count@@ Digit ( long n ) { if ( n / 10 == 0 ) return 1 ; return 1 + count@@ Digit ( n / 10 ) ; } public static void main ( String [ ] args ) { long n = 345@@ 289@@ 46@@ 7 ; System . out . print ( " Number ▁ of ▁ digits ▁ : ▁ " + count@@ Digit ( n ) ) ; } }
import java . io . * ; class GF@@ G { static String dec@@ To@@ Bin ( int n ) { if ( n == 0 ) return "0" ; String bin = " " ; while ( n > 0 ) { bin = ( ( n & 1 ) == 0 ? '0' : '1' ) + bin ; n >>= 1 ; } return bin ; } public static void main ( String [ ] args ) { int n = 38 ; System . out . println ( dec@@ To@@ Bin ( n ) ) ; } }
class GF@@ G { static boolean find@@ No@@ Is@@ Di@@ visible@@ Or@@ Not ( int a [ ] , int n ) { for ( int i = 0 ; i < a . length ; i ++ ) { if ( a [ i ] % n != 0 ) return false ; } return true ; } public static void main ( String [ ] args ) { int a [ ] = { 14 , 12 , 4 , 18 } ; int n = 2 ; if ( find@@ No@@ Is@@ Di@@ visible@@ Or@@ Not ( a , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GF@@ G { static int getTotal@@ Xor@@ Of@@ Sub@@ array@@ X@@ ors ( int arr [ ] , int N ) { if ( N % 2 == 0 ) return 0 ; int res = 0 ; for ( int i = 0 ; i < N ; i += 2 ) res ^= arr [ i ] ; return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 5 , 2 , 4 , 6 } ; int N = arr . length ; System . out . println ( getTotal@@ Xor@@ Of@@ Sub@@ array@@ X@@ ors ( arr , N ) ) ; } }
import java . util . * ; class GF@@ G { static int find@@ N@@ th@@ Even@@ Digit@@ Number ( int n ) { if ( n == 1 ) { return 0 ; } Vector < Integer > v = new Vector < > ( ) ; n = n - 1 ; while ( n > 0 ) { v . add ( n % 5 ) ; n = n / 5 ; } int result = 0 ; for ( int i = v . size ( ) - 1 ; i >= 0 ; i -- ) { result = result * 10 ; result = result + v . get ( i ) ; } return 2 * result ; } public static void main ( String [ ] args ) { System . out . println ( find@@ N@@ th@@ Even@@ Digit@@ Number ( 2 ) ) ; System . out . println ( find@@ N@@ th@@ Even@@ Digit@@ Number ( 10 ) ) ; } }
class GF@@ G { static long modu@@ lo@@ Multiplic@@ ation ( long a , long b , long mod ) { long res = 0 ; a %= mod ; while ( b > 0 ) { if ( ( b & 1 ) > 0 ) { res = ( res + a ) % mod ; } a = ( 2 * a ) % mod ; } return res ; } public static void main ( String [ ] args ) { long a = 101@@ 234@@ 65@@ 234@@ 87@@ 899@@ 8L ; long b = 657@@ 46@@ 3@@ 115@@ 45@@ 6464@@ 3@@ 1L ; long m = 100@@ 05@@ 412@@ 33@@ 65@@ 48@@ 79@@ 4L ; System . out . print ( modu@@ lo@@ Multiplic@@ ation ( a , b , m ) ) ; } }
import java . util . * ; class GF@@ G { static void k@@ Factors ( int n , int k ) { ArrayList < Integer > P = new ArrayList < Integer > ( ) ; while ( n % 2 == 0 ) { P . add ( 2 ) ; n /= 2 ; } for ( int i = 3 ; i * i <= n ; i = i + 2 ) { while ( n % i == 0 ) { n = n / i ; P . add ( i ) ; } } if ( n > 2 ) P . add ( n ) ; if ( P . size ( ) < k ) { System . out . println ( " - 1" ) ; return ; } for ( int i = 0 ; i < k - 1 ; i ++ ) System . out . print ( P . get ( i ) + " , ▁ " ) ; int product = 1 ; for ( int i = k - 1 ; i < P . size ( ) ; i ++ ) product = product * P . get ( i ) ; System . out . println ( product ) ; } public static void main ( String [ ] args ) { int n = 54 , k = 3 ; k@@ Factors ( n , k ) ; } }
class GF@@ G { static int MAX = 10000@@ 1 ; static int [ ] perfec@@ t@@ Div = new int [ MAX ] ; static void pre@@ compute@@ Counts ( ) { for ( int i = 1 ; i * i < MAX ; ++ i ) { for ( int j = i * i ; j < MAX ; j += i * i ) ++ perfec@@ t@@ Div [ j ] ; } } static int count@@ Per@@ fec@@ t@@ Di@@ visors ( int n ) { return perfec@@ t@@ Div [ n ] ; } public static void main ( String [ ] args ) { pre@@ compute@@ Counts ( ) ; int n = 16 ; System . out . println ( " Total ▁ perfect ▁ di@@ visors ▁ of ▁ " + n + " ▁ = ▁ " + count@@ Per@@ fec@@ t@@ Di@@ visors ( n ) ) ; n = 12 ; System . out . println ( " Total ▁ perfect ▁ di@@ visors ▁ of ▁ " + n + " ▁ = ▁ " + count@@ Per@@ fec@@ t@@ Di@@ visors ( n ) ) ; } }
class GF@@ G { static int find@@ Min@@ Number ( int n ) { int count = 0 , ans = 1 ; while ( n % 2 == 0 ) { count ++ ; n /= 2 ; } if ( count % 2 == 1 ) ans *= 2 ; for ( int i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { count = 0 ; while ( n % i == 0 ) { count ++ ; n /= i ; } if ( count % 2 == 1 ) ans *= i ; } if ( n > 2 ) ans *= n ; return ans ; } public static void main ( String [ ] args ) { int n = 72 ; System . out . println ( find@@ Min@@ Number ( n ) ) ; } }
import java . io . * ; class GF@@ G { static void Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( int n , boolean prime [ ] ) { for ( int i = 0 ; i <= n ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } } static void mer@@ sen@@ ne@@ Pri@@ mes ( int n ) { boolean prime [ ] = new boolean [ n + 1 ] ; Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( n , prime ) ; for ( int k = 2 ; ( ( 1 << k ) - 1 ) <= n ; k ++ ) { long num = ( 1 << k ) - 1 ; if ( prime [ ( int ) ( num ) ] ) System . out . print ( num + " ▁ " ) ; } } public static void main ( String args [ ] ) { int n = 31 ; System . out . println ( " Mer@@ sen@@ ne ▁ prime " + " numbers ▁ smaller ▁ than " + " or ▁ equal ▁ to ▁ " + n ) ; mer@@ sen@@ ne@@ Pri@@ mes ( n ) ; } }
import java . io . * ; import java . math . * ; class GF@@ G { static boolean is@@ Perf@@ ect ( int n ) { int s = ( int ) ( Math . sqrt ( n ) ) ; return ( s * s == n ) ; } static int di@@ visor@@ sCount ( int n ) { int count = 0 ; for ( int i = 1 ; i <= Math . sqrt ( n ) + 1 ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) count += 1 ; else count += 2 ; } } return count ; } static int k@@ Di@@ visors ( int a , int b , int k ) { int count = 0 ; for ( int i = a ; i <= b ; i ++ ) { if ( is@@ Perf@@ ect ( i ) ) if ( di@@ visor@@ sCount ( i ) == k ) count ++ ; } return count ; } public static void main ( String args [ ] ) { int a = 21 , b = 149 , k = 333 ; System . out . println ( k@@ Di@@ visors ( a , b , k ) ) ; } }
import java . io . * ; class GF@@ G { static int find@@ Count@@ Of@@ Solutions ( int n , int p ) { int ans = 0 ; for ( int x = 1 ; x < p ; x ++ ) { if ( ( x * x ) % p == 1 ) { int last = x + p * ( n / p ) ; if ( last > n ) last -= p ; ans += ( ( last - x ) / p + 1 ) ; } } return ans ; } public static void main ( String [ ] args ) { int n = 10 ; int p = 5 ; System . out . println ( find@@ Count@@ Of@@ Solutions ( n , p ) ) ; } }
import java . util . Arrays ; class GF@@ G { static int k@@ ap@@ re@@ kar@@ Rec ( int n , int prev ) { if ( n == 0 ) return 0 ; prev = n ; int [ ] digits = new int [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { digits [ i ] = n % 10 ; n = n / 10 ; } Arrays . sort ( digits ) ; int asc = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) asc = asc * 10 + digits [ i ] ; Arrays . sort ( digits ) ; int desc = 0 ; for ( int i = 3 ; i >= 0 ; i -- ) desc = desc * 10 + digits [ i ] ; int diff = Math . abs ( asc - desc ) ; if ( diff == prev ) return diff ; return k@@ ap@@ re@@ kar@@ Rec ( diff , prev ) ; } static int k@@ ap@@ re@@ k@@ ar ( int n ) { int prev = 0 ; return k@@ ap@@ re@@ kar@@ Rec ( n , prev ) ; } public static void main ( String [ ] args ) { System . out . println ( k@@ ap@@ re@@ k@@ ar ( 1000 ) ) ; System . out . println ( k@@ ap@@ re@@ k@@ ar ( 11@@ 12 ) ) ; System . out . println ( k@@ ap@@ re@@ k@@ ar ( 98@@ 12 ) ) ; } }
import java . io . * ; class code_@@ conversion { char xor_@@ c ( char a , char b ) { return ( a == b ) ? '0' : '1' ; } char flip ( char c ) { return ( c == '0' ) ? '1' : '0' ; } String binary@@ to@@ Gray ( String binary ) { String gray = " " ; gray += binary . charAt ( 0 ) ; for ( int i = 1 ; i < binary . length ( ) ; i ++ ) { gray += xor_@@ c ( binary . charAt ( i - 1 ) , binary . charAt ( i ) ) ; } return gray ; } String gray@@ to@@ Binary ( String gray ) { String binary = " " ; binary += gray . charAt ( 0 ) ; for ( int i = 1 ; i < gray . length ( ) ; i ++ ) { if ( gray . charAt ( i ) == '0' ) binary += binary . charAt ( i - 1 ) ; else binary += flip ( binary . charAt ( i - 1 ) ) ; } return binary ; } public static void main ( String args [ ] ) throws IOException { code_@@ conversion ob = new code_@@ conversion ( ) ; String binary = "@@ 0100@@ 1" ; System . out . println ( " Gray ▁ code ▁ of ▁ " + binary + " ▁ is ▁ " + ob . binary@@ to@@ Gray ( binary ) ) ; String gray = "01@@ 101@@ " ; System . out . println ( " Binary ▁ code ▁ of ▁ " + gray + " ▁ is ▁ " + ob . gray@@ to@@ Binary ( gray ) ) ; } }
import java . util . * ; class GF@@ G { static int getS@@ um ( int BIT@@ ree [ ] , int index ) { int sum = 0 ; while ( index > 0 ) { sum += BIT@@ ree [ index ] ; index -= index & ( - index ) ; } return sum ; } static void update@@ BIT ( int BIT@@ ree [ ] , int n , int index , int val ) { while ( index <= n ) { BIT@@ ree [ index ] += val ; index += index & ( - index ) ; } } static void convert ( int arr [ ] , int n ) { int [ ] temp = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) temp [ i ] = arr [ i ] ; Arrays . sort ( temp ) ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = lower_bound ( temp , 0 , n , arr [ i ] ) + 1 ; } } static int lower_bound ( int [ ] a , int low , int high , int element ) { while ( low < high ) { int middle = low + ( high - low ) / 2 ; if ( element > a [ middle ] ) low = middle + 1 ; else high = middle ; } return low ; } static int getIn@@ v@@ Count ( int arr [ ] , int n ) { int inv@@ count = 0 ; convert ( arr , n ) ; int [ ] BIT = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) BIT [ i ] = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { inv@@ count += getS@@ um ( BIT , arr [ i ] - 1 ) ; update@@ BIT ( BIT , n , arr [ i ] , 1 ) ; } return inv@@ count ; } public static void main ( String [ ] args ) { int arr [ ] = { 8 , 4 , 2 , 1 } ; int n = arr . length ; System . out . print ( " Number ▁ of ▁ in@@ versions ▁ are ▁ : ▁ " + getIn@@ v@@ Count ( arr , n ) ) ; } }
import java . io . * ; class GF@@ G { static int mod ( String num , int a ) { int res = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) res = ( res * 10 + ( int ) num . charAt ( i ) - '0' ) % a ; return res ; } public static void main ( String [ ] args ) { String num = "12@@ 316@@ 767@@ 67@@ 867@@ 8" ; System . out . println ( mod ( num , 10 ) ) ; } }
import java . io . * ; class GF@@ G { static int phi ( int n ) { float result = n ; for ( int p = 2 ; p * p <= n ; ++ p ) { if ( n % p == 0 ) { while ( n % p == 0 ) n /= p ; result *= ( 1.0 - ( 1.0 / ( float ) p ) ) ; } } if ( n > 1 ) result *= ( 1.0 - ( 1.0 / ( float ) n ) ) ; return ( int ) result ; } public static void main ( String args [ ] ) { int n ; for ( n = 1 ; n <= 10 ; n ++ ) System . out . println ( " phi ( " + n + " ) ▁ = ▁ " + phi ( n ) ) ; } }
import java . io . * ; class GF@@ G { static int Largest@@ power ( int n , int p ) { int ans = 0 ; while ( n > 0 ) { n /= p ; ans += n ; } return ans ; } public static void main ( String [ ] args ) { int n = 10 ; int p = 3 ; System . out . println ( " ▁ The ▁ largest ▁ power ▁ of ▁ " + p + " ▁ that ▁ divi@@ des ▁ " + n + " ! ▁ is ▁ " + Largest@@ power ( n , p ) ) ; } }
import java . io . * ; class GF@@ G { static void print@@ Squ@@ ares ( int n ) { int square = 0 , odd = 1 ; for ( int x = 0 ; x < n ; x ++ ) { System . out . print ( square + " ▁ " ) ; square = square + odd ; odd = odd + 2 ; } } public static void main ( String [ ] args ) { int n = 5 ; print@@ Squ@@ ares ( n ) ; } }
class Fac@@ tori@@ al { int factorial ( int n ) { return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; } public static void main ( String args [ ] ) { Fac@@ tori@@ al obj = new Fac@@ tori@@ al ( ) ; int num = 5 ; System . out . println ( " Fac@@ tori@@ al ▁ of ▁ " + num + " ▁ is ▁ " + obj . factorial ( num ) ) ; } }
import java . util . * ; class GF@@ G { static void Or@@ _@@ of_@@ And@@ s_for_@@ each@@ _@@ query ( int arr [ ] , int n , int queries [ ] [ ] , int q ) { int bits [ ] = new int [ 32 ] ; Arrays . fill ( bits , 0 ) ; for ( int i = 0 ; i < 32 ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( ( 1 << i ) & arr [ j ] ) != 0 ) { bits [ i ] ++ ; } } } for ( int p = 0 ; p < q ; p ++ ) { for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( ( 1 << i ) & arr [ queries [ p ] [ 0 ] ] ) != 0 ) { bits [ i ] -- ; } if ( ( queries [ p ] [ 1 ] & ( 1 << i ) ) != 0 ) { bits [ i ] ++ ; } } arr [ queries [ p ] [ 0 ] ] = queries [ p ] [ 1 ] ; int ans = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { if ( bits [ i ] != 0 ) { ans |= ( 1 << i ) ; } } System . out . println ( ans ) ; } } public static void main ( String [ ] args ) { int n = 3 , q = 2 ; int arr [ ] = { 3 , 5 , 7 } ; int queries [ ] [ ] = { { 1 , 2 } , { 2 , 1 } } ; Or@@ _@@ of_@@ And@@ s_for_@@ each@@ _@@ query ( arr , n , queries , q ) ; } }
import java . util . * ; class GF@@ G { static int find@@ max ( int arr [ ] , int n , int k ) { int tra@@ v , i ; int c = 0 , maximum = 0 ; for ( i = 0 ; i < n - k + 1 ; i ++ ) { tra@@ v = i - 1 ; c = 0 ; while ( tra@@ v >= 0 && arr [ tra@@ v ] == 1 ) { tra@@ v -- ; c ++ ; } tra@@ v = i + k ; while ( tra@@ v < n && arr [ tra@@ v ] == 1 ) { tra@@ v ++ ; c ++ ; } c += k ; if ( c > maximum ) maximum = c ; } return maximum ; } public static void main ( String args [ ] ) { int k = 3 ; int arr [ ] = { 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 } ; int n = arr . length ; int ans = find@@ max ( arr , n , k ) ; System . out . println ( ans ) ; } }
import java . io . * ; import java . util . Arrays ; class GF@@ G { static int max@@ And@@ Xor ( int arr [ ] , int n ) { int ans = Integer . MAX_VALUE ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { ans = Math . min ( ans , arr [ i ] ^ arr [ i + 1 ] ) ; } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = new int [ ] { 1 , 2 , 3 , 4 , 5 } ; int N = arr . length ; System . out . println ( max@@ And@@ Xor ( arr , N ) ) ; } }
import java . util . * ; class GF@@ G { static int count@@ Sub@@ array ( int [ ] arr , int K , int N ) { if ( K % 2 != 0 ) return 0 ; if ( N < K ) return 0 ; int start = 0 ; int i = 0 ; int count = 0 ; int curr@@ Xor = arr [ i ++ ] ; while ( i < K ) { curr@@ Xor ^= arr [ i ] ; i ++ ; } if ( curr@@ Xor == 0 ) count ++ ; curr@@ Xor ^= arr [ start ++ ] ; while ( i < N ) { curr@@ Xor ^= arr [ i ] ; i ++ ; if ( curr@@ Xor == 0 ) count ++ ; curr@@ Xor ^= arr [ start ++ ] ; } return count ; } public static void main ( String [ ] args ) { int [ ] arr = { 2 , 4 , 4 , 2 , 2 , 4 } ; int K = 4 ; int N = arr . length ; System . out . println ( count@@ Sub@@ array ( arr , K , N ) ) ; } }
import java . util . * ; class GF@@ G { static int minimum@@ Fli@@ ps ( int X , int Y , int Z ) { int res = 0 ; while ( X > 0 Y > 0 Z > 0 ) { if ( ( ( X % 2 == 1 ) || ( Y % 2 == 1 ) ) && ( Z % 2 == 1 ) ) { X = X >> 1 ; Y = Y >> 1 ; Z = Z >> 1 ; continue ; } else if ( ! ( X % 2 == 1 ) && ! ( Y % 2 == 1 ) && ( Z % 2 == 1 ) ) { res ++ ; } else if ( ( X % 2 == 1 ) || ( Y % 2 == 1 ) ) { if ( ( X % 2 == 1 ) && ( Y % 2 == 1 ) && ! ( Z % 2 == 1 ) ) { res += 2 ; } else if ( ( ( X % 2 == 1 ) || ( Y % 2 == 1 ) ) && ! ( Z % 2 == 1 ) ) { res ++ ; } } X = X >> 1 ; Y = Y >> 1 ; Z = Z >> 1 ; } return res ; } public static void main ( String [ ] args ) { int X = 5 , Y = 8 , Z = 6 ; System . out . print ( minimum@@ Fli@@ ps ( X , Y , Z ) ) ; } }
import java . util . * ; class GF@@ G { static void Flip@@ Bits ( int n ) { for ( int bit = 0 ; bit < 32 ; bit ++ ) { if ( ( n >> bit ) % 2 > 0 ) { n = n ^ ( 1 << bit ) ; break ; } } System . out . print ( " The ▁ number ▁ after ▁ un@@ setting ▁ the " ) ; System . out . print ( " ▁ right@@ most ▁ set ▁ bit ▁ " + n ) ; } public static void main ( String [ ] args ) { int N = 12 ; Flip@@ Bits ( N ) ; } }
class GF@@ G { static int bit@@ wise@@ And@@ Odd ( int n ) { int result = 1 ; for ( int i = 3 ; i <= n ; i = i + 2 ) { result = ( result & i ) ; } return result ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( bit@@ wise@@ And@@ Odd ( n ) ) ; } }
class GF@@ G { static long multiply@@ By@@ Fi@@ f@@ te@@ en ( long n ) { long prod = ( n << 3 ) ; prod += ( n << 2 ) ; prod += ( n << 1 ) ; prod += n ; return prod ; } public static void main ( String [ ] args ) { long n = 7 ; System . out . print ( multiply@@ By@@ Fi@@ f@@ te@@ en ( n ) ) ; } }
public class GF@@ G { static int count@@ X ( int n ) { String binary = Integer . to@@ Binary@@ String ( n ) ; int count = 0 ; for ( int i = 0 ; i < binary . length ( ) ; i ++ ) { if ( binary . charAt ( i ) == '1' ) count ++ ; } int answer = ( int ) Math . pow ( 2 , count ) ; return answer ; } public static void main ( String args [ ] ) { int n = 5 ; int answer = count@@ X ( n ) ; System . out . println ( answer ) ; } }
class GF@@ G { static int alternate ( int a , int b , int x ) { return x = a ^ b ^ x ; } public static void main ( String [ ] args ) { int a = - 10 ; int b = 15 ; int x = a ; System . out . print ( " x ▁ is ▁ : ▁ " + x ) ; x = alternate ( a , b , x ) ; System . out . print ( " After exchange "@@ )@@ ; System . out . print ( " x is : " + x@@ )@@ ; } }
import java . io . * ; class GF@@ G { static void solve ( int A , int B ) { int count = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( ( A >> i ) & 1 ) != ( ( B >> i ) & 1 ) ) { count ++ ; } } System . out . println ( " Number ▁ of ▁ different ▁ bits ▁ : ▁ " + count ) ; } public static void main ( String [ ] args ) { int A = 12 , B = 15 ; solve ( A , B ) ; } }
import java . util . * ; class GF@@ G { static class Node { int data ; Node left , right ; } ; static Node newNode ( int data ) { Node node = new Node ( ) ; node . data = data ; node . left = node . right = null ; return ( node ) ; } static void print@@ Set@@ Bit ( Node root ) { if ( root == null ) return ; System . out . print ( " Set ▁ bits ▁ in ▁ Node ▁ " + root . data + " ▁ = ▁ " + Integer . bit@@ Count ( root . data ) + "@@ NEW_@@ LINE@@ "@@ )@@ ; print@@ Set@@ Bit ( root . left ) ; print@@ Set@@ Bit ( root . right ) ; } public static void main ( String [ ] args ) { Node root = newNode ( 16 ) ; root . left = newNode ( 13 ) ; root . left . left = newNode ( 14 ) ; root . left . right = newNode ( 12 ) ; root . right = newNode ( 11 ) ; root . right . left = newNode ( 10 ) ; root . right . right = newNode ( 16 ) ; print@@ Set@@ Bit ( root ) ; } }
import java . util . * ; class solution { static void Make@@ Pre@@ Sum ( int [ ] arr , int [ ] pres@@ um , int n ) { pres@@ um [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) pres@@ um [ i ] = pres@@ um [ i - 1 ] + arr [ i ] ; } static int Binary@@ Li@@ ft@@ ing ( int [ ] pres@@ um , int n , int x ) { int pos = 0 ; int LOG@@ N = ( int ) Math . log ( n ) ; if ( x <= pres@@ um [ 0 ] ) return 0 ; for ( int i = LOG@@ N ; i >= 0 ; i -- ) { if ( pos + ( 1 << i ) < n && pres@@ um [ pos + ( 1 << i ) ] < x ) { pos += ( 1 << i ) ; } } return pos + 1 ; } public static void main ( String args [ ] ) { int [ ] arr = { 2 , 5 , 7 , 1 , 6 , 9 , 12 , 4 , 6 } ; int x = 8 ; int n = arr . length ; int [ ] pres@@ um = new int [ n ] ; Arrays . fill ( pres@@ um , 0 ) ; Make@@ Pre@@ Sum ( arr , pres@@ um , n ) ; System . out . println ( Binary@@ Li@@ ft@@ ing ( pres@@ um , n , x ) ) ; } }
class GF@@ G { static boolean all@@ Bits@@ SetIn@@ The@@ Given@@ Range ( int n , int l , int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; int new_@@ num = n & num ; if ( new_@@ num == 0 ) return true ; return false ; } public static void main ( String [ ] args ) { int n = 17 ; int l = 2 , r = 4 ; if ( all@@ Bits@@ SetIn@@ The@@ Given@@ Range ( n , l , r ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GF@@ G { static boolean only@@ First@@ And@@ Last@@ Are@@ Set ( int n ) { if ( n == 1 ) return true ; if ( n == 2 ) return false ; return ( ( ( n - 1 ) & ( n - 2 ) ) == 0 ) ; } public static void main ( String [ ] args ) { int n = 9 ; if ( only@@ First@@ And@@ Last@@ Are@@ Set ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GF@@ G { public static int _pop@@ cnt@@ 32 ( long number ) { int count = 0 ; while ( number > 0 ) { count += number & 1L ; number >>= 1L ; } return count ; } static long minimize ( long a ) { int n = _pop@@ cnt@@ 32 ( a ) ; return ( ( long ) Math . pow ( 2 , n ) - 1 ) ; } public static void main ( String args [ ] ) { long a = 11 ; System . out . print ( minimize ( a ) ) ; } }
class GF@@ G { static int getM@@ id ( int s , int e ) { return s + ( e - s ) / 2 ; } static void construct@@ ST@@ Util ( int arr [ ] , int ss , int se , int st [ ] , int si , boolean operation ) { if ( ss == se ) { st [ si ] = arr [ ss ] ; return ; } int mid = getM@@ id ( ss , se ) ; construct@@ ST@@ Util ( arr , ss , mid , st , si * 2 + 1 , ! operation ) ; construct@@ ST@@ Util ( arr , mid + 1 , se , st , si * 2 + 2 , ! operation ) ; if ( operation ) { st [ si ] = ( st [ 2 * si + 1 ] st [ 2 * si + 2 ] ) ; } else { st [ si ] = ( st [ 2 * si + 1 ] ^ st [ 2 * si + 2 ] ) ; } } static int [ ] construct@@ ST ( int arr [ ] , int n ) { int x = ( int ) ( Math . ceil ( Math . log ( n ) / Math . log ( 2 ) ) ) ; int max_size = 2 * ( int ) Math . pow ( 2 , x ) - 1 ; int [ ] st = new int [ max_size ] ; boolean operation@@ At@@ Root = ! ( x % 2 == 0 ) ; construct@@ ST@@ Util ( arr , 0 , n - 1 , st , 0 , operation@@ At@@ Root ) ; return st ; } public static void main ( String [ ] args ) { int leaves [ ] = { 1 , 6 , 3 , 7 , 5 , 9 , 10 , 4 } ; int n = leaves . length ; int [ ] segment@@ Tree = construct@@ ST ( leaves , n ) ; int root@@ Index = 0 ; System . out . println ( " Value ▁ at ▁ Root ▁ Node ▁ = ▁ " + segment@@ Tree [ root@@ Index ] ) ; } }
class GF@@ G { static boolean is@@ Fi@@ b@@ binary@@ Num ( int n ) { if ( ( n & ( n >> 1 ) ) == 0 ) return true ; return false ; } public static void main ( String [ ] args ) { int n = 10 ; if ( is@@ Fi@@ b@@ binary@@ Num ( n ) == true ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; import java . util . * ; class GF@@ G { public static long divide ( long dividend , long divisor ) { long sign = ( ( dividend < 0 ) ^ ( divisor < 0 ) ) ? - 1 : 1 ; dividend = Math . abs ( dividend ) ; divisor = Math . abs ( divisor ) ; long quotient = 0 , temp = 0 ; for ( int i = 31 ; i >= 0 ; -- i ) { if ( temp + ( divisor << i ) <= dividend ) { temp += divisor << i ; quotient |= 1L << i ; } } if ( sign == - 1 ) quotient = - quotient ; return quotient ; } public static void main ( String args [ ] ) { int a = 10 , b = 3 ; System . out . println ( divide ( a , b ) ) ; int a1 = 43 , b1 = - 8 ; System . out . println ( divide ( a1 , b1 ) ) ; } }
import java . util . * ; import java . lang . * ; public class Gf@@ G { static int max@@ AND ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) res = res > ( arr [ i ] & arr [ j ] ) ? res : ( arr [ i ] & arr [ j ] ) ; return res ; } public static void main ( String argc [ ] ) { int arr [ ] = { 4 , 8 , 6 , 2 } ; int n = arr . length ; System . out . println ( " Maximum ▁ AND ▁ Value ▁ = ▁ " + max@@ AND ( arr , n ) ) ; } }
class GF@@ G { static int set@@ All@@ Bits@@ After@@ MSB ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return n ; } static int toggle ( int n ) { n = n ^ set@@ All@@ Bits@@ After@@ MSB ( n ) ; return n ; } public static void main ( String arg [ ] ) { int n = 10 ; n = toggle ( n ) ; System . out . print ( n ) ; } }
class GF@@ G { static int INT_@@ SIZE = 32 ; static int construct@@ N@@ th@@ Number ( int group_@@ no , int aux_@@ num , int op ) { int a [ ] = new int [ INT_@@ SIZE ] ; int num = 0 , len_@@ f ; int i = 0 ; if ( op == 2 ) { len_@@ f = 2 * group_@@ no ; a [ len_@@ f - 1 ] = a [ 0 ] = 1 ; while ( aux_@@ num > 0 ) { a [ group_@@ no + i ] = a [ group_@@ no - 1 - i ] = aux_@@ num & 1 ; aux_@@ num = aux_@@ num >> 1 ; i ++ ; } } else if ( op == 0 ) { len_@@ f = 2 * group_@@ no + 1 ; a [ len_@@ f - 1 ] = a [ 0 ] = 1 ; a [ group_@@ no ] = 0 ; while ( aux_@@ num > 0 ) { a [ group_@@ no + 1 + i ] = a [ group_@@ no - 1 - i ] = aux_@@ num & 1 ; aux_@@ num = aux_@@ num >> 1 ; i ++ ; } } { len_@@ f = 2 * group_@@ no + 1 ; a [ len_@@ f - 1 ] = a [ 0 ] = 1 ; a [ group_@@ no ] = 1 ; while ( aux_@@ num > 0 ) { a [ group_@@ no + 1 + i ] = a [ group_@@ no - 1 - i ] = aux_@@ num & 1 ; aux_@@ num = aux_@@ num >> 1 ; i ++ ; } } for ( i = 0 ; i < len_@@ f ; i ++ ) num += ( 1 << i ) * a [ i ] ; return num ; } static int getN@@ th@@ Number ( int n ) { int group_@@ no = 0 , group_@@ offset ; int count_@@ up@@ to_@@ group = 0 , count_@@ temp = 1 ; int op , aux_@@ num ; while ( count_@@ temp < n ) { group_@@ no ++ ; count_@@ up@@ to_@@ group = count_@@ temp ; count_@@ temp += 3 * ( 1 << ( group_@@ no - 1 ) ) ; } group_@@ offset = n - count_@@ up@@ to_@@ group - 1 ; if ( ( group_@@ offset + 1 ) <= ( 1 << ( group_@@ no - 1 ) ) ) { aux_@@ num = group_@@ offset ; } else { if ( ( ( group_@@ offset + 1 ) - ( 1 << ( group_@@ no - 1 ) ) ) % 2 == 1 ) else aux_@@ num = ( ( group_@@ offset ) - ( 1 << ( group_@@ no - 1 ) ) ) / 2 ; } return construct@@ N@@ th@@ Number ( group_@@ no , aux_@@ num , op ) ; } public static void main ( String [ ] args ) { int n = 9 ; System . out . printf ( " % d " , getN@@ th@@ Number ( n ) ) ; } }
import java . util . * ; import java . lang . * ; public class Gf@@ G { public static int toggle@@ Last@@ MB@@ its ( int n , int m ) { int num = ( 1 << m ) - 1 ; return ( n ^ num ) ; } public static void main ( String argc [ ] ) { int n = 107 ; int m = 4 ; n = toggle@@ Last@@ MB@@ its ( n , m ) ; System . out . println ( n ) ; } }
import java . util . * ; class GF@@ G { static int xor@@ Pair@@ Count ( int arr [ ] , int n , int x ) { Map < Integer , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int curr_@@ xor = x ^ arr [ i ] ; if ( m . containsKey ( curr_@@ xor ) ) result += m . get ( curr_@@ xor ) ; if ( m . containsKey ( arr [ i ] ) ) { m . put ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ; } else { m . put ( arr [ i ] , 1 ) ; } } return result ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 5 , 2 } ; int n = arr . length ; int x = 0 ; System . out . println ( " Count ▁ of ▁ pairs ▁ with ▁ given ▁ XOR ▁ = ▁ " + xor@@ Pair@@ Count ( arr , n , x ) ) ; } }
class GF@@ G { static int maxLength ( int arr [ ] , int n ) { int maxLen = 0 ; int i = 0 ; int j = i + 1 ; while ( j < n ) { if ( arr [ i ] != arr [ j ] ) { maxLen = Math . max ( maxLen , 2 ) ; int l = i - 1 ; int r = j + 1 ; while ( l >= 0 && r < n && arr [ l ] == arr [ i ] && arr [ r ] == arr [ j ] ) { l -- ; r ++ ; } maxLen = Math . max ( maxLen , 2 * ( r - j ) ) ; } i ++ ; j = i + 1 ; } return maxLen ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 1 , 0 , 0 , 1 , 1 } ; int n = arr . length ; System . out . println ( maxLength ( arr , n ) ) ; } }
import java . util . * ; import java . io . * ; class GF@@ G { static int min@@ Digits ( int N , int K ) { int digits_@@ num = ( int ) Math . floor ( Math . log ( N ) + 1 ) ; int temp_@@ sum = 0 ; int temp = digits_@@ num ; int result = 0 ; int X , var ; int sum = 0 ; int num2 = N ; while ( num2 != 0 ) { sum += num2 % 10 ; num2 /= 10 ; } if ( sum <= K ) { X = 0 ; } else { while ( temp > 0 ) { var = ( N / ( ( int ) Math . pow ( 10 , temp - 1 ) ) ) ; temp_@@ sum += var % 10 ; if ( temp_@@ sum >= K ) { var /= 10 ; var ++ ; result = var * ( int ) Math . pow ( 10 , temp ) ; break ; } temp -- ; } X = result - N ; return X ; } return - 1 ; } public static void main ( String args [ ] ) { int N = 11 ; int K = 1 ; System . out . println ( min@@ Digits ( N , K ) ) ; } }
import java . util . * ; class GF@@ G { static int upperBound ( int arr [ ] , int N , int K ) { int l = 0 ; int r = N ; while ( l < r ) { int mid = ( l + r ) / 2 ; if ( arr [ mid ] <= K ) { l = mid + 1 ; } else { r = mid ; } } return l ; } static void N@@ Div@@ K@@ With@@ Freq ( int arr [ ] , int N , int K ) { Arrays . sort ( arr ) ; int i = 0 ; while ( i < N ) { int X = upperBound ( arr , N , arr [ i ] ) ; if ( ( X - i ) > N / 4 ) { System . out . print ( arr [ i ] + " ▁ " ) ; } i = X ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 2 , 6 , 6 , 6 , 6 , 7 , 10 } ; int N = arr . length ; int K = 4 ; N@@ Div@@ K@@ With@@ Freq ( arr , N , K ) ; } }
import java . util . * ; class GF@@ G { static double getMax@@ Medi@@ an ( int [ ] arr , int n , int k ) { int size = n + k ; Arrays . sort ( arr ) ; if ( size % 2 == 0 ) { double median = ( double ) ( arr [ ( size / 2 ) - 1 ] + arr [ size / 2 ] ) / 2 ; return median ; } double medi@@ an@@ 1 = arr [ size / 2 ] ; return medi@@ an@@ 1 ; } public static void main ( String [ ] args ) { int [ ] arr = { 3 , 2 , 3 , 4 , 2 } ; int n = arr . length ; int k = 2 ; System . out . print ( ( int ) getMax@@ Medi@@ an ( arr , n , k ) ) ; } }
import java . util . * ; import java . lang . * ; class Ge@@ ek@@ s@@ for@@ Ge@@ e@@ ks { final static int MAX = 26 ; static boolean function ( String str ) { int l = str . length ( ) ; int counter [ ] = new int [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) counter [ i ] = 0 ; for ( int i = 0 ; i < l / 2 ; i ++ ) counter [ str . charAt ( i ) - ' a ' ] ++ ; for ( int i = l / 2 ; i < l ; i ++ ) counter [ str . charAt ( i ) - ' a ' ] -- ; for ( int i = 0 ; i < MAX ; i ++ ) if ( counter [ i ] != 0 ) return true ; return false ; } public static void main ( String args [ ] ) { String str = " abc@@ as@@ ds@@ ab@@ ca@@ e " ; if ( function ( str ) ) System . out . print ( " Yes , ▁ both ▁ hal@@ ves " + " ▁ differ ▁ by ▁ at ▁ least ▁ one ▁ character " ) ; else System . out . print ( " No , ▁ both ▁ hal@@ ves " + " ▁ do ▁ not ▁ differ ▁ at ▁ all " ) ; } }
class GF@@ G { static void print@@ Sorted ( int a , int b , int c ) { int get_@@ max = Math . max ( a , Math . max ( b , c ) ) ; int get_@@ min = - Math . max ( - a , Math . max ( - b , - c ) ) ; int get_@@ mid = ( a + b + c ) - ( get_@@ max + get_@@ min ) ; System . out . print ( get_@@ min + " ▁ " + get_@@ mid + " ▁ " + get_@@ max ) ; } public static void main ( String [ ] args ) { int a = 4 , b = 1 , c = 9 ; print@@ Sorted ( a , b , c ) ; } }
class Insertion@@ Sort { void sort ( int arr [ ] ) { int n = arr . length ; for ( int i = 1 ; i < n ; ++ i ) { int key = arr [ i ] ; int j = i - 1 ; while ( j >= 0 && arr [ j ] > key ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } arr [ j + 1 ] = key ; } } static void print@@ Array ( int arr [ ] ) { int n = arr . length ; for ( int i = 0 ; i < n ; ++ i ) System . out . print ( arr [ i ] + " ▁ " ) ; System . out . println ( ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 12 , 11 , 13 , 5 , 6 } ; Insertion@@ Sort ob = new Insertion@@ Sort ( ) ; ob . sort ( arr ) ; print@@ Array ( arr ) ; } }
import java . util . * ; class GF@@ G { public static void main ( String [ ] args ) { String S = " ge@@ ek@@ s@@ for@@ g " ; System . out . println ( maxNum@@ Pal@@ ind@@ ro@@ me ( S ) ) ; } static int maxNum@@ Pal@@ ind@@ ro@@ me ( String S ) { int i = 0 ; int [ ] freq = new int [ 26 ] ; int freq@@ Pair = 0 ; int len = S . length ( ) / 3 ; while ( i < S . length ( ) ) { freq [ S . charAt ( i ) - ' a ' ] ++ ; i ++ ; } for ( i = 0 ; i < 26 ; i ++ ) { freq@@ Pair += ( freq [ i ] / 2 ) ; } return Math . min ( freq@@ Pair , len ) ; } }
import java . util . * ; class GF@@ G { static int height ( int s , Vector < Integer > adj [ ] , int [ ] visited ) { visited [ s ] = 1 ; int h = 0 ; for ( int child : adj [ s ] ) { if ( visited [ child ] == 0 ) { h = Math . max ( h , 1 + height ( child , adj , visited ) ) ; } } return h ; } static int minimum@@ Groups ( Vector < Integer > adj [ ] , int N ) { int [ ] visited = new int [ N + 1 ] ; int groups = Integer . MIN_VALUE ; for ( int i = 1 ; i <= N ; i ++ ) { if ( visited [ i ] == 0 ) { int com@@ Height ; com@@ Height = height ( i , adj , visited ) ; groups = Math . max ( groups , com@@ Height ) ; } } return groups ; } static void addEdge ( Vector < Integer > adj [ ] , int u , int v ) { adj [ u ] . add ( v ) ; adj [ v ] . add ( u ) ; } public static void main ( String [ ] args ) { int N = 5 ; Vector < Integer > [ ] adj = new Vector [ N + 1 ] ; for ( int i = 0 ; i < N + 1 ; i ++ ) adj [ i ] = new Vector < Integer > ( ) ; addEdge ( adj , 1 , 2 ) ; addEdge ( adj , 3 , 2 ) ; addEdge ( adj , 4 , 3 ) ; System . out . print ( minimum@@ Groups ( adj , N ) ) ; } }
import java . io . * ; class GF@@ G { static int find_@@ sum ( int n , int k ) { int total_@@ sum = ( n * ( n + 1 ) ) / 2 ; int power = k ; while ( power <= n ) { total_@@ sum -= power ; power *= k ; } return total_@@ sum ; } public static void main ( String [ ] args ) { int n = 11 , k = 2 ; System . out . println ( find_@@ sum ( n , k ) ) ; } }
public class GF@@ G { static int min ( int x , int y , int z ) { if ( x < y ) return ( x < z ) ? x : z ; else return ( y < z ) ? y : z ; } static int min@@ Cost ( int cost [ ] [ ] , int m , int n ) { if ( n < 0 m < 0 ) return Integer . MAX_VALUE ; else if ( m == 0 && n == 0 ) return cost [ m ] [ n ] ; else return cost [ m ] [ n ] + min ( min@@ Cost ( cost , m - 1 , n - 1 ) , min@@ Cost ( cost , m - 1 , n ) , min@@ Cost ( cost , m , n - 1 ) ) ; } public static void main ( String args [ ] ) { int cost [ ] [ ] = { { 1 , 2 , 3 } , { 4 , 8 , 2 } , { 1 , 5 , 3 } } ; System . out . print ( min@@ Cost ( cost , 2 , 2 ) ) ; } }
class GF@@ G { static void count@@ S@@ mal@@ ler ( String str ) { int n = str . length ( ) ; int arr [ ] = new int [ 26 ] ; int ans [ ] = new int [ n ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { arr [ str . charAt ( i ) - ' a ' ] ++ ; int ct = 0 ; for ( int j = 0 ; j < str . charAt ( i ) - ' a ' ; j ++ ) { ct += arr [ j ] ; } ans [ i ] = ct ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( ans [ i ] + " ▁ " ) ; } } public static void main ( String [ ] args ) { String str = " ed@@ c@@ ba@@ a " ; count@@ S@@ mal@@ ler ( str ) ; } }
class GF@@ G { private static StringBuilder char@@ Buffer = new StringBuilder ( ) ; public static String process@@ Words ( String input ) { String s [ ] = input . split ( " ( \\ s ) + " ) ; for ( String values : s ) { char@@ Buffer . append ( values . charAt ( 0 ) ) ; } return char@@ Buffer . toString ( ) ; } public static void main ( String [ ] args ) { String input = " ge@@ e@@ ks ▁ for TABSYMBOL ge@@ e@@ ks ▁ ge@@ e@@ ks TABSYMBOL for ▁ ge@@ e@@ ks " ; System . out . println ( process@@ Words ( input ) ) ; } }
import java . util . * ; class Gf@@ G { static void generate@@ Gray@@ arr ( int n ) { if ( n <= 0 ) return ; ArrayList < String > arr = new ArrayList < String > ( ) ; arr . add ( "0" ) ; arr . add ( "1" ) ; int i , j ; for ( i = 2 ; i < ( 1 << n ) ; i = i << 1 ) { for ( j = i - 1 ; j >= 0 ; j -- ) arr . add ( arr . get ( j ) ) ; for ( j = 0 ; j < i ; j ++ ) arr . set ( j , "0" + arr . get ( j ) ) ; for ( j = i ; j < 2 * i ; j ++ ) arr . set ( j , "1" + arr . get ( j ) ) ; } for ( i = 0 ; i < arr . size ( ) ; i ++ ) System . out . println ( arr . get ( i ) ) ; } public static void main ( String [ ] args ) { generate@@ Gray@@ arr ( 3 ) ; } }
import java . util . * ; class GF@@ G { static Vector < String > possible@@ Paths = new Vector < > ( ) ; static String path = " " ; static final int MAX = 5 ; static boolean is@@ Safe ( int row , int col , int m [ ] [ ] , int n , boolean visited [ ] [ ] ) { if ( row == - 1 row == n col == - 1 col == n visited [ row ] [ col ] m [ row ] [ col ] == 0 ) return false ; return true ; } static void print@@ Path@@ Util ( int row , int col , int m [ ] [ ] , int n , boolean visited [ ] [ ] ) { if ( row == - 1 row == n col == - 1 col == n visited [ row ] [ col ] m [ row ] [ col ] == 0 ) return ; if ( row == n - 1 && col == n - 1 ) { possible@@ Paths . add ( path ) ; return ; } visited [ row ] [ col ] = true ; if ( is@@ Safe ( row + 1 , col , m , n , visited ) ) { path += ' D ' ; print@@ Path@@ Util ( row + 1 , col , m , n , visited ) ; path = path . substring ( 0 , path . length ( ) - 1 ) ; } if ( is@@ Safe ( row , col - 1 , m , n , visited ) ) { path += ' L ' ; print@@ Path@@ Util ( row , col - 1 , m , n , visited ) ; path = path . substring ( 0 , path . length ( ) - 1 ) ; } if ( is@@ Safe ( row , col + 1 , m , n , visited ) ) { path += ' R ' ; print@@ Path@@ Util ( row , col + 1 , m , n , visited ) ; path = path . substring ( 0 , path . length ( ) - 1 ) ; } if ( is@@ Safe ( row - 1 , col , m , n , visited ) ) { path += ' U ' ; print@@ Path@@ Util ( row - 1 , col , m , n , visited ) ; path = path . substring ( 0 , path . length ( ) - 1 ) ; } visited [ row ] [ col ] = false ; } static void print@@ Path ( int m [ ] [ ] , int n ) { boolean [ ] [ ] visited = new boolean [ n ] [ MAX ] ; print@@ Path@@ Util ( 0 , 0 , m , n , visited ) ; for ( int i = 0 ; i < possible@@ Paths . size ( ) ; i ++ ) System . out . print ( possible@@ Paths . get ( i ) + " ▁ " ) ; } public static void main ( String [ ] args ) { int m [ ] [ ] = { { 1 , 0 , 0 , 0 , 0 } , { 1 , 1 , 1 , 1 , 1 } , { 1 , 1 , 1 , 0 , 1 } , { 0 , 0 , 0 , 0 , 1 } , { 0 , 0 , 0 , 0 , 1 } } ; int n = m . length ; print@@ Path ( m , n ) ; } }
import java . io . * ; class GF@@ G { static int count@@ Direct@@ Path ( int N ) { return N + ( N * ( N - 3 ) ) / 2 ; } public static void main ( String [ ] args ) { int N = 5 ; System . out . print ( count@@ Direct@@ Path ( N ) ) ; } }
import java . util . * ; class solution { static int checkpoint ( int h , int k , int x , int y , int a , int b ) { int p = ( ( int ) Math . pow ( ( x - h ) , 2 ) / ( int ) Math . pow ( a , 2 ) ) + ( ( int ) Math . pow ( ( y - k ) , 2 ) / ( int ) Math . pow ( b , 2 ) ) ; return p ; } public static void main ( String arr [ ] ) { int h = 0 , k = 0 , x = 2 , y = 1 , a = 4 , b = 5 ; if ( checkpoint ( h , k , x , y , a , b ) > 1 ) System . out . println ( " Outside " ) ; else if ( checkpoint ( h , k , x , y , a , b ) == 1 ) System . out . println ( " On ▁ the ▁ ellipse " ) ; else System . out . println ( " Inside " ) ; } }
class GF@@ G { static void center ( int x1 , int x2 , int y1 , int y2 ) { System . out . print ( ( float ) ( x1 + x2 ) / 2 + " , ▁ " + ( float ) ( y1 + y2 ) / 2 ) ; } public static void main ( String arg [ ] ) { int x1 = - 9 , y1 = 3 , x2 = 5 , y2 = - 7 ; center ( x1 , x2 , y1 , y2 ) ; } }
import java . io . * ; class GF@@ G { static double Area ( int b1 , int b2 , int h ) { return ( ( b1 + b2 ) / 2 ) * h ; } public static void main ( String [ ] args ) { int base@@ 1 = 8 , base@@ 2 = 10 , height = 6 ; double area = Area ( base@@ 1 , base@@ 2 , height ) ; System . out . println ( " Area ▁ is : ▁ " + area ) ; } }
class GF@@ G { static double area@@ Cube ( double a ) { return ( a * a * a ) ; } static double surface@@ Cube ( double a ) { return ( 6 * a * a ) ; } public static void main ( String [ ] args ) { double a = 5 ; System . out . println ( " Area ▁ = ▁ " + area@@ Cube ( a ) ) ; System . out . println ( " Total ▁ surface ▁ area ▁ = ▁ " + surface@@ Cube ( a ) ) ; } }
class GF@@ G { static class pair { double first , second ; public pair ( double first , double second ) { this . first = first ; this . second = second ; } } static pair mirror@@ Image ( double a , double b , double c , double x1 , double y1 ) { double temp = - 2 * ( a * x1 + b * y1 + c ) / ( a * a + b * b ) ; double x = temp * a + x1 ; double y = temp * b + y1 ; return new pair ( x , y ) ; } public static void main ( String [ ] args ) { double a = - 1.0 ; double b = 1.0 ; double c = 0.0 ; double x1 = 1.0 ; double y1 = 0.0 ; pair image = mirror@@ Image ( a , b , c , x1 , y1 ) ; System . out . print ( " Image ▁ of ▁ point ▁ ( " + x1 + " , ▁ " + y1 + " ) ▁ " ) ; System . out . print ( " by ▁ mirror ▁ ( " + a + " ) x ▁ + ▁ ( " + b + " ) y ▁ + ▁ ( " + c + " ) ▁ = ▁ 0 , ▁ is ▁ : " ) ; System . out . println ( " ( " + image . first + " , ▁ " + image . second + " ) " ) ; } }
import java . util . * ; class GF@@ G { static int fact ( int n ) { if ( n == 1 n == 0 ) return 1 ; else return n * fact ( n - 1 ) ; } static int find@@ Value ( int n , int r , int a ) { int k = ( a - 1 ) / fact ( n ) ; int answer = k ; for ( int i = 1 ; i < n + 1 ; i ++ ) answer = answer * ( n + r - i ) ; answer = answer + 1 ; return answer ; } public static void main ( String args [ ] ) { int N = 1 ; int A = 2 ; int R = 3 ; System . out . print ( find@@ Value ( N , R , A ) ) ; } }
import java . io . * ; class GF@@ G { static void count@@ No ( int A , int N , int L , int R ) { int ans = L - 1 + N + ( int ) Math . floor ( ( N - 1 ) / ( A - 1 ) ) ; if ( ans % A == 0 ) { ans = ans + 1 ; } System . out . println ( ans ) ; } public static void main ( String [ ] args ) { int A = 5 , N = 10 , L = 4 , R = 20 ; count@@ No ( A , N , L , R ) ; } }
import java . util . * ; class GF@@ G { static int MAX = 1000000 ; static boolean [ ] prime = new boolean [ MAX ] ; static void Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( ) { for ( int i = 0 ; i < MAX ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * p ; i < MAX ; i += p ) prime [ i ] = false ; } } } static int sum@@ Prime ( int k ) { Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( ) ; Vector < Integer > v = new Vector < > ( ) ; for ( int i = 2 ; i < MAX ; i ++ ) { if ( prime [ i ] ) v . add ( i ) ; } int sum = 0 ; int skip = ( k * ( k - 1 ) ) / 2 ; while ( k > 0 ) { sum += v . get ( skip ) ; skip ++ ; k -- ; } return sum ; } public static void main ( String [ ] args ) { int k = 3 ; System . out . println ( sum@@ Prime ( k ) ) ; } }
import java . util . * ; class GF@@ G { static int next@@ Occurren@@ ce ( String str , int n , int start , char ch ) { for ( int i = start ; i < n ; i ++ ) { if ( str . charAt ( i ) == ch ) return i ; } return - 1 ; } static int count@@ Sub@@ Str ( String str , int n , char ch ) { int cnt = 0 ; int j = next@@ Occurren@@ ce ( str , n , 0 , ch ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( j != - 1 && j < i ) { j = next@@ Occurren@@ ce ( str , n , j + 1 , ch ) ; } if ( j == - 1 ) break ; cnt += ( n - j ) ; } return cnt ; } static public void main ( String [ ] arg ) { String str = " ge@@ ek@@ s@@ forge@@ e@@ ks " ; int n = str . length ( ) ; char ch = ' k ' ; System . out . println ( count@@ Sub@@ Str ( str , n , ch ) ) ; } }
class GF@@ G { static int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) { res = ( res * x ) % p ; } x = ( x * x ) % p ; } return res ; } public static void main ( String [ ] args ) { int L = 2 ; int P = ( int ) Math . pow ( 10 , 9 ) ; int ans = power ( 325 , L , P ) ; System . out . println ( ans ) ; } }
import java . util . * ; class GF@@ G { public static void reve@@ re@@ se@@ Array ( int [ ] arr , int n ) { int [ ] rev = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) rev [ n - i - 1 ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = rev [ i ] ; } public static void print@@ Array ( int [ ] arr , int size ) { for ( int i = 0 ; i < size ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; System . out . println ( " " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = arr . length ; print@@ Array ( arr , n ) ; reve@@ re@@ se@@ Array ( arr , n ) ; System . out . println ( " Reversed ▁ array ▁ is " ) ; print@@ Array ( arr , n ) ; } }
import java . io . * ; import static java . lang . Math . min ; import java . lang . * ; class GF@@ G { public static void find@@ String ( String str , int M ) { int N = str . length ( ) ; M = Math . min ( M , N ) ; String s1 = " " ; while ( M != 0 ) { s1 = " " ; for ( int i = 0 ; i < N ; i ++ ) { if ( str . charAt ( i ) == '0' ) { if ( ( str . charAt ( i ) == '1' && str . charAt ( i ) != '1' ) || ( str . charAt ( i ) == '1' && str . charAt ( i ) == '1' ) ) s1 += '1' ; else s1 += '0' ; } else s1 += '1' ; } if ( str == s1 ) break ; str = s1 ; M -- ; } System . out . print ( s1 ) ; } public static void main ( String [ ] args ) { String str = "01@@ 101@@ 00" ; int M = 3 ; find@@ String ( str , M ) ; } }
import java . io . * ; import java . util . * ; class GF@@ G { static void indi@@ visible@@ Digits ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( arr [ i ] + " : ▁ " ) ; for ( int j = 2 ; j < 10 ; j ++ ) { int temp = arr [ i ] ; boolean flag = true ; while ( temp > 0 ) { if ( ( temp % 10 ) != 0 && ( temp % 10 ) % j == 0 ) { flag = false ; break ; } temp /= 10 ; } if ( flag ) { System . out . print ( j + " ▁ " ) ; } } System . out . println ( ) ; } } public static void main ( String [ ] args ) { int [ ] arr = { 4@@ 162 , 11@@ 52 , 99@@ 8@@ 42 } ; int N = arr . length ; indi@@ visible@@ Digits ( arr , N ) ; } }
import java . util . * ; class GF@@ G { static void check ( String s1 , String s2 ) { int s@@ 1_0 = 0 , s@@ 2_0 = 0 ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { if ( s1 . charAt ( i ) == '0' ) { s@@ 1_0 ++ ; } if ( s2 . charAt ( i ) == '0' ) { s@@ 2_0 ++ ; } } if ( s@@ 1_0 != s@@ 2_0 ) { System . out . println ( " NO " ) ; return ; } else { int Coun@@ t1 = 0 , Count@@ 2 = 0 ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { if ( s1 . charAt ( i ) == '0' ) { Coun@@ t1 ++ ; } if ( s2 . charAt ( i ) == '0' ) { Count@@ 2 ++ ; } if ( Coun@@ t1 < Count@@ 2 ) { System . out . println ( " NO " ) ; return ; } } System . out . println ( " YES " ) ; } } public static void main ( String [ ] args ) { String s1 = "100@@ 11@@ 1" ; String s2 = "11@@ 101@@ 0" ; check ( s1 , s2 ) ; s1 = "11@@ 0100@@ " ; s2 = "@@ 0101@@ 01" ; check ( s1 , s2 ) ; } }
import java . util . * ; class GF@@ G { static int max@@ Even@@ Inte@@ gers ( int arr [ ] , int N , int M ) { int ans = 0 ; for ( int i = 0 ; i <= N - M ; i ++ ) { int cnt = 0 ; for ( int j = 0 ; j < M ; j ++ ) { if ( arr [ i + j ] % 2 == 0 ) cnt ++ ; } ans = Math . max ( ans , cnt ) ; } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 5 , 4 , 7 , 6 } ; int K = 3 ; int N = arr . length ; System . out . print ( max@@ Even@@ Inte@@ gers ( arr , N , K ) + "@@ NEW_@@ LINE@@ "@@ )@@ ; } }
import java . util . * ; import java . lang . * ; class GF@@ G { static String check ( int arr [ ] , int n ) { Map < Integer , Integer > hm = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { hm . put ( arr [ i ] , 1 ) ; for ( int j = i + 1 ; j < n ; j ++ ) { hm . put ( arr [ j ] , hm . getOr@@ Default ( arr [ j ] , 0 ) + 1 ) ; boolean flag = false ; for ( Integer k : hm . values ( ) ) { if ( k == 1 ) { flag = true ; break ; } } if ( ! flag ) return " No " ; } hm . clear ( ) ; } return " Yes " ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 1 } ; int N = arr . length ; System . out . println ( check ( arr , N ) ) ; } }
import java . io . * ; class GF@@ G { static int find_@@ index ( int [ ] arr , int n , int K ) { int start = 0 ; int end = n - 1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( arr [ mid ] == K ) return mid ; else if ( arr [ mid ] < K ) start = mid + 1 ; else end = mid - 1 ; } return end + 1 ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 3 , 5 , 6 } ; int n = arr . length ; int K = 2 ; System . out . println ( find_@@ index ( arr , n , K ) ) ; } }
import java . io . * ; import java . util . * ; class GF@@ G { static boolean is@@ Pal@@ ind@@ ro@@ me ( String str ) { int i = 0 , j = str . length ( ) - 1 ; while ( i < j ) { if ( str . charAt ( i ) != str . charAt ( j ) ) return false ; i ++ ; j -- ; } return true ; } static void form@@ Pal@@ ind@@ ro@@ me ( String a , String b , int n ) { char aa [ ] = new char [ n + 2 ] ; char bb [ ] = new char [ n + 2 ] ; Arrays . fill ( aa , ' ▁ ' ) ; Arrays . fill ( bb , ' ▁ ' ) ; for ( int i = 1 ; i <= n ; i ++ ) { aa [ i ] = a . charAt ( i - 1 ) ; bb [ i ] = b . charAt ( i - 1 ) ; } boolean ok = false ; for ( int i = 0 ; i <= n + 1 ; i ++ ) { StringBuilder la = new StringBuilder ( ) ; StringBuilder ra = new StringBuilder ( ) ; StringBuilder lb = new StringBuilder ( ) ; StringBuilder rb = new StringBuilder ( ) ; for ( int j = 1 ; j <= i - 1 ; j ++ ) { la . append ( ( aa [ j ] == ' ▁ ' ) ? " " : aa [ j ] ) ; lb . append ( ( bb [ j ] == ' ▁ ' ) ? " " : bb [ j ] ) ; } for ( int j = i ; j <= n + 1 ; j ++ ) { ra . append ( ( aa [ j ] == ' ▁ ' ) ? " " : aa [ j ] ) ; rb . append ( ( bb [ j ] == ' ▁ ' ) ? " " : bb [ j ] ) ; } if ( is@@ Pal@@ ind@@ ro@@ me ( la . toString ( ) + rb . toString ( ) ) || is@@ Pal@@ ind@@ ro@@ me ( lb . toString ( ) + ra . toString ( ) ) ) { ok = true ; break ; } } if ( ok ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } public static void main ( String [ ] args ) { String A = " b@@ de@@ a " ; String B = " ab@@ bb " ; int N = 4 ; form@@ Pal@@ ind@@ ro@@ me ( A , B , N ) ; } }
import java . awt . Point ; import java . util . HashSet ; class GF@@ G { static void is@@ Cro@@ ssed ( String path ) { if ( path . length ( ) == 0 ) return ; boolean ans = false ; HashSet < Point > set = new HashSet < Point > ( ) ; int x = 0 , y = 0 ; set . add ( new Point ( x , y ) ) ; for ( int i = 0 ; i < path . length ( ) ; i ++ ) { if ( path . charAt ( i ) == ' N ' ) set . add ( new Point ( x , y ++ ) ) ; if ( path . charAt ( i ) == ' S ' ) set . add ( new Point ( x , y -- ) ) ; if ( path . charAt ( i ) == ' E ' ) set . add ( new Point ( x ++ , y ) ) ; if ( path . charAt ( i ) == ' W ' ) set . add ( new Point ( x -- , y ) ) ; if ( set . contains ( new Point ( x , y ) ) ) { ans = true ; break ; } } if ( ans ) System . out . print ( " Cro@@ ssed " ) ; else System . out . print ( " Not ▁ Cro@@ ssed " ) ; } public static void main ( String [ ] args ) { String path = " NE@@ SW " ; is@@ Cro@@ ssed ( path ) ; } }
import java . io . * ; import java . util . * ; class GF@@ G { static int l@@ eng@@ ht@@ Of@@ Lon@@ gest@@ AP ( int A [ ] , int n ) { Map < Integer , Map < Integer , Integer > > dp = new HashMap < Integer , Map < Integer , Integer > > ( ) ; int res = 2 ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { int d = A [ j ] - A [ i ] ; Map < Integer , Integer > temp ; if ( dp . containsKey ( d ) ) { temp = dp . get ( d ) ; if ( temp . containsKey ( i ) ) temp . put ( j , temp . get ( i ) + 1 ) ; else temp . put ( j , 2 ) ; } else { temp = new HashMap < Integer , Integer > ( ) ; temp . put ( j , 2 ) ; } dp . put ( d , temp ) ; res = Math . max ( res , temp . get ( j ) ) ; } } return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 20 , 1 , 15 , 3 , 10 , 5 , 8 } ; int N = arr . length ; System . out . println ( l@@ eng@@ ht@@ Of@@ Lon@@ gest@@ AP ( arr , N ) ) ; } }
import java . util . * ; import java . lang . * ; class GF@@ G { static void check@@ Sum@@ Of@@ Natur@@ al ( int n ) { int i = 1 ; boolean flag = false ; while ( i * ( i + 1 ) < n * 2 ) { int X = i * ( i + 1 ) ; int t = n * 2 - X ; int k = ( int ) Math . sqrt ( t ) ; if ( k * ( k + 1 ) == t ) { flag = true ; break ; } i += 1 ; } if ( flag ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } public static void main ( String [ ] args ) { int n = 25 ; check@@ Sum@@ Of@@ Natur@@ al ( n ) ; } }
class GF@@ G { static class pair { int first , second ; } static boolean is@@ Per@@ fec@@ t@@ Square ( int n ) { double sr = Math . sqrt ( n ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; } static void Sub@@ array@@ H@@ av@@ ing@@ Per@@ fec@@ t@@ Square ( int [ ] arr , int k ) { pair ans = new pair ( ) ; int sum = 0 , i ; for ( i = 0 ; i < k ; i ++ ) { sum += arr [ i ] ; } boolean found = false ; if ( is@@ Per@@ fec@@ t@@ Square ( sum ) ) { ans . first = 0 ; ans . second = i - 1 ; } else { for ( int j = i ; j < arr . length ; j ++ ) { sum = sum + arr [ j ] - arr [ j - k ] ; if ( is@@ Per@@ fec@@ t@@ Square ( sum ) ) { found = true ; ans . first = j - k + 1 ; ans . second = j ; } } for ( int k1 = ans . first ; k1 <= ans . second ; k1 ++ ) { System . out . print ( arr [ k1 ] + " ▁ " ) ; } } if ( found == false ) { System . out . print ( " - 1" ) ; } } public static void main ( String [ ] args ) { int [ ] arr = { 20 , 34 , 51 , 10 , 99 , 87 , 23 , 45 } ; int K = 3 ; Sub@@ array@@ H@@ av@@ ing@@ Per@@ fec@@ t@@ Square ( arr , K ) ; } }
import java . util . * ; class GF@@ G { static void mirror@@ Matrix ( int mat@@ 1 [ ] [ ] , int mat2 [ ] [ ] , int N ) { int row = 0 ; int col = 0 ; boolean is@@ Mirror@@ Image = true ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = N - 1 ; j >= 0 ; j -- ) { if ( mat2 [ row ] [ col ] != mat@@ 1 [ i ] [ j ] ) { is@@ Mirror@@ Image = false ; } col ++ ; } col = 0 ; row ++ ; } if ( is@@ Mirror@@ Image ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } public static void main ( String [ ] args ) { int N = 4 ; int mat@@ 1 [ ] [ ] = { { 1 , 2 , 3 , 4 } , { 0 , 6 , 7 , 8 } , { 9 , 10 , 11 , 12 } , { 13 , 14 , 15 , 16 } } ; int mat2 [ ] [ ] = { { 4 , 3 , 2 , 1 } , { 8 , 7 , 6 , 0 } , { 12 , 11 , 10 , 9 } , { 16 , 15 , 14 , 13 } } ; mirror@@ Matrix ( mat@@ 1 , mat2 , N ) ; } }
import java . util . * ; class GF@@ G { static int split@@ string ( String s ) { int n = s . length ( ) ; int zeros = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( s . charAt ( i ) == '0' ) zeros ++ ; if ( zeros % 3 != 0 ) return 0 ; if ( zeros == 0 ) return ( ( n - 1 ) * ( n - 2 ) ) / 2 ; int zer@@ os@@ In@@ Each@@ Sub@@ string = zeros / 3 ; int ways@@ Of@@ First@@ Cut = 0 ; int ways@@ Of@@ Second@@ Cut = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '0' ) count ++ ; if ( count == zer@@ os@@ In@@ Each@@ Sub@@ string ) ways@@ Of@@ First@@ Cut ++ ; else if ( count == 2 * zer@@ os@@ In@@ Each@@ Sub@@ string ) ways@@ Of@@ Second@@ Cut ++ ; } return ways@@ Of@@ First@@ Cut * ways@@ Of@@ Second@@ Cut ; } public static void main ( String args [ ] ) { String s = "@@ 0101@@ 0" ; System . out . println ( " The ▁ number ▁ of ▁ " + " ways ▁ to ▁ split ▁ is ▁ " + split@@ string ( s ) ) ; } }
import java . util . * ; class GF@@ G { static boolean can@@ Transform ( String str1 , String str2 ) { String s1 = " " ; String s2 = " " ; for ( char c : str1 . toCharArray ( ) ) { if ( c != ' C ' ) { s1 += c ; } } for ( char c : str2 . toCharArray ( ) ) { if ( c != ' C ' ) { s2 += c ; } } if ( ! s1 . equals ( s2 ) ) return false ; int i = 0 ; int j = 0 ; int n = str1 . length ( ) ; while ( i < n && j < n ) { if ( str1 . charAt ( i ) == ' C ' ) { i ++ ; } else if ( str2 . charAt ( j ) == ' C ' ) { j ++ ; } else { if ( ( str1 . charAt ( i ) == ' A ' && i < j ) || ( str1 . charAt ( i ) == ' B ' && i > j ) ) { return false ; } i ++ ; j ++ ; } } return true ; } public static void main ( String [ ] args ) { String str1 = " B@@ CC@@ AB@@ CB@@ CA " ; String str2 = " C@@ BAC@@ C@@ BB@@ AC " ; if ( can@@ Transform ( str1 , str2 ) ) { System . out . print ( " Yes " ) ; } else { System . out . print ( " No " ) ; } } }
import java . util . * ; class GF@@ G { static int X = 1 ; static int diameter = 0 ; static HashMap < Integer , Boolean > mp = new HashMap < > ( ) ; static void dfs ( int current_@@ node , int prev_@@ node , int len , boolean add_to_@@ map , Vector < Integer > [ ] adj ) { if ( len > diameter ) { diameter = len ; X = current_@@ node ; } if ( add_to_@@ map && len == diameter ) { mp . put ( current_@@ node , true ) ; } for ( int it : adj [ current_@@ node ] ) { if ( it != prev_@@ node ) dfs ( it , current_@@ node , len + 1 , add_to_@@ map , adj ) ; } } static void dfs@@ Utility ( Vector < Integer > [ ] adj ) { dfs ( 1 , - 1 , 0 , false , adj ) ; int far@@ the@@ st_@@ node = X ; dfs ( far@@ the@@ st_@@ node , - 1 , 0 , false , adj ) ; dfs ( far@@ the@@ st_@@ node , - 1 , 0 , true , adj ) ; dfs ( X , - 1 , 0 , true , adj ) ; } static void print@@ Di@@ am@@ eters ( Vector < Integer > [ ] adj ) { dfs@@ Utility ( adj ) ; for ( int i = 1 ; i <= 6 ; i ++ ) { if ( mp . containsKey ( i ) && mp . get ( i ) == true ) System . out . print ( diameter + 1 + " , ▁ " ) ; else System . out . print ( diameter + " , ▁ " ) ; } } public static void main ( String [ ] args ) { Vector < Integer > [ ] adj = new Vector [ 7 ] ; for ( int i = 0 ; i < adj . length ; i ++ ) adj [ i ] = new Vector < Integer > ( ) ; adj [ 1 ] . add ( 2 ) ; adj [ 2 ] . add ( 1 ) ; adj [ 1 ] . add ( 3 ) ; adj [ 3 ] . add ( 1 ) ; adj [ 2 ] . add ( 4 ) ; adj [ 4 ] . add ( 2 ) ; adj [ 2 ] . add ( 5 ) ; adj [ 5 ] . add ( 2 ) ; adj [ 2 ] . add ( 6 ) ; adj [ 6 ] . add ( 2 ) ; print@@ Di@@ am@@ eters ( adj ) ; } }
import java . io . * ; class GF@@ G { static int kn@@ ap@@ S@@ ack ( int [ ] nums , int S ) { int sum = 0 ; for ( int i : nums ) sum += i ; if ( sum < S || - sum > - S || ( S + sum ) % 2 == 1 ) return 0 ; int [ ] dp = new int [ ( S + sum ) / 2 + 1 ] ; dp [ 0 ] = 1 ; for ( int num : nums ) { for ( int i = dp . length - 1 ; i >= num ; i -- ) { dp [ i ] += dp [ i - num ] ; } } return dp [ dp . length - 1 ] ; } public static void main ( String [ ] args ) { int S = 3 ; int [ ] arr = new int [ ] { 1 , 2 , 3 , 4 , 5 } ; int answer = kn@@ ap@@ S@@ ack ( arr , S ) ; System . out . println ( answer ) ; } }
import java . util . * ; class GF@@ G { static int no_@@ of_@@ sub@@ String ( String s , int N ) { int fr@@ e [ ] = new int [ 26 ] ; int str_@@ len ; str_@@ len = ( int ) s . length ( ) ; int count = 0 ; for ( int i = 0 ; i < str_@@ len ; i ++ ) { Arrays . fill ( fr@@ e , 0 ) ; int max_@@ index = 0 ; int dist = 0 ; for ( int j = i ; j < str_@@ len ; j ++ ) { int x = s . charAt ( j ) - ' a ' ; if ( fr@@ e [ x ] == 0 ) dist ++ ; fr@@ e [ x ] ++ ; max_@@ index = Math . max ( max_@@ index , fr@@ e [ x ] ) ; if ( dist >= N && ( ( max_@@ index * dist ) == ( j - i + 1 ) ) ) count ++ ; } } return count ; } public static void main ( String [ ] args ) { String s = " ab@@ h@@ ay " ; int N = 3 ; System . out . print ( no_@@ of_@@ sub@@ String ( s , N ) ) ; } }
import java . util . * ; class GF@@ G { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static int [ ] [ ] mat = new int [ 1001 ] [ 1001 ] ; static int r , c , x , y ; static int dx [ ] = { 0 , - 1 , - 1 , - 1 , 0 , 1 , 1 , 1 } ; static int dy [ ] = { 1 , 1 , 0 , - 1 , - 1 , - 1 , 0 , 1 } ; static void Find@@ Minimum@@ Distance ( ) { Queue < pair > q = new LinkedList < > ( ) ; q . add ( new pair ( x , y ) ) ; mat [ x ] [ y ] = 0 ; while ( ! q . isEmpty ( ) ) { x = q . peek ( ) . first ; y = q . peek ( ) . second ; q . remove ( ) ; for ( int i = 0 ; i < 8 ; i ++ ) { int a = x + dx [ i ] ; int b = y + dy [ i ] ; if ( a < 0 a >= r b >= c b < 0 ) continue ; if ( mat [ a ] [ b ] == 0 ) { mat [ a ] [ b ] = mat [ x ] [ y ] + 1 ; q . add ( new pair ( a , b ) ) ; } } } } public static void main ( String [ ] args ) { r = 5 ; c = 5 ; x = 1 ; y = 1 ; int t = x ; int l = y ; mat [ x ] [ y ] = 0 ; Find@@ Minimum@@ Distance ( ) ; mat [ t ] [ l ] = 0 ; for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) { System . out . print ( mat [ i ] [ j ] + " ▁ " ) ; } System . out . println ( ) ; } } }
class GF@@ G { static boolean is@@ Vo@@ wel ( char c ) { if ( c == ' a ' c == ' e ' c == ' i ' c == ' o ' c == ' u ' ) return true ; return false ; } static void count@@ Sub@@ strings ( String s , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = i ; j < n ; j ++ ) { if ( is@@ Vo@@ wel ( s . charAt ( j ) ) ) { count ++ ; } if ( count % 2 == 0 ) result ++ ; } } System . out . println ( result ) ; } public static void main ( String [ ] args ) { int n = 5 ; String s = " abcde " ; count@@ Sub@@ strings ( s , n ) ; } }
public class Main { public static void check@@ Pal@@ ind@@ ro@@ me ( String S ) { int N = S . length ( ) ; boolean first_@@ half = true ; boolean second_@@ half = true ; int cnt = ( N / 2 ) - 1 ; for ( int i = 0 ; i < ( N / 2 ) ; i ++ ) { if ( S . charAt ( i ) != S . charAt ( cnt ) ) { first_@@ half = false ; break ; } if ( S . charAt ( N / 2 + i ) != S . charAt ( N / 2 + cnt ) ) { second_@@ half = false ; break ; } cnt -- ; } if ( first_@@ half && second_@@ half ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } public static void main ( String [ ] args ) { String S = " mo@@ md@@ ad " ; check@@ Pal@@ ind@@ ro@@ me ( S ) ; } }
import java . util . * ; class GF@@ G { static int lon@@ gest@@ Sub@@ array ( int arr [ ] , int n , int k ) { int i , j , Max = 1 ; HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( i = 0 ; i < n - 1 ; i ++ ) { s . add ( arr [ i ] ) ; for ( j = i + 1 ; j < n ; j ++ ) { if ( Math . abs ( arr [ i ] - arr [ j ] ) == 0 || Math . abs ( arr [ i ] - arr [ j ] ) == k ) { if ( ! s . contains ( arr [ j ] ) ) { if ( s . size ( ) == 2 ) break ; else s . add ( arr [ j ] ) ; } } else break ; } if ( s . size ( ) == 2 ) { Max = Math . max ( Max , j - i ) ; s . clear ( ) ; } else s . clear ( ) ; } return Max ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 0 , 2 , 2 , 5 , 5 , 5 } ; int N = arr . length ; int K = 1 ; int length = lon@@ gest@@ Sub@@ array ( arr , N , K ) ; if ( length == 1 ) System . out . print ( - 1 ) ; else System . out . print ( length ) ; } }
class GF@@ G { static int [ ] [ ] prefix_@@ 2D = new int [ 2005 ] [ 2005 ] ; static int sub@@ Matrix@@ Sum ( int i , int j , int len ) { return prefix_@@ 2D [ i ] [ j ] - prefix_@@ 2D [ i ] [ j - len ] - prefix_@@ 2D [ i - len ] [ j ] + prefix_@@ 2D [ i - len ] [ j - len ] ; } static int numberOf@@ W@@ ays ( int a [ ] , int b [ ] , int n , int m , int k ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( a [ i - 1 ] == b [ j - 1 ] ) prefix_@@ 2D [ i ] [ j ] = 1 ; else prefix_@@ 2D [ i ] [ j ] = 0 ; } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { prefix_@@ 2D [ i ] [ j ] += prefix_@@ 2D [ i ] [ j - 1 ] ; } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { prefix_@@ 2D [ i ] [ j ] += prefix_@@ 2D [ i - 1 ] [ j ] ; } } int answer = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { int low = 1 ; int high = Math . min ( i , j ) ; while ( low < high ) { int mid = ( low + high ) >> 1 ; if ( sub@@ Matrix@@ Sum ( i , j , mid ) >= k ) { high = mid ; } else { low = mid + 1 ; } } if ( sub@@ Matrix@@ Sum ( i , j , low ) >= k ) { answer += ( Math . min ( i , j ) - low + 1 ) ; } } } return answer ; } public static void main ( String [ ] args ) { int N = 2 , M = 3 ; int A [ ] = { 1 , 2 } ; int B [ ] = { 1 , 2 , 3 } ; int K = 1 ; System . out . print ( numberOf@@ W@@ ays ( A , B , N , M , K ) ) ; } }
import java . util . * ; class GF@@ G { static int NO_@@ OF_@@ CHARS = 256 ; static int first@@ Repe@@ ating ( String str ) { boolean [ ] visited = new boolean [ NO_@@ OF_@@ CHARS ] ; for ( int i = 0 ; i < NO_@@ OF_@@ CHARS ; i ++ ) visited [ i ] = false ; int res = - 1 ; for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) { if ( visited [ str . charAt ( i ) ] == false ) visited [ str . charAt ( i ) ] = true ; else res = i ; } return res ; } public static void main ( String [ ] args ) { String str = " ge@@ ek@@ s@@ forge@@ e@@ ks " ; int index = first@@ Repe@@ ating ( str ) ; if ( index == - 1 ) System . out . printf ( " Either ▁ all ▁ characters ▁ are ▁ " + " distinct ▁ or ▁ string ▁ is ▁ empty " ) ; else System . out . printf ( " First ▁ Repe@@ ating ▁ character " + " ▁ is ▁ % c " , str . charAt ( index ) ) ; } }
import java . util . * ; class GF@@ G { static void find@@ Sum@@ Pairs ( int a [ ] , int n ) { Map < Integer , Integer > mp@@ p = new HashMap < > ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { mp@@ p . put ( a [ i ] + a [ j ] , mp@@ p . get ( a [ i ] + a [ j ] ) == null ? 1 : mp@@ p . get ( a [ i ] + a [ j ] ) + 1 ) ; } } int occur = 0 ; for ( Map . Entry < Integer , Integer > entry : mp@@ p . entrySet ( ) ) { if ( entry . getValue ( ) > occur ) { occur = entry . getValue ( ) ; } } for ( Map . Entry < Integer , Integer > entry : mp@@ p . entrySet ( ) ) { if ( entry . getValue ( ) == occur ) System . out . println ( entry . getKey ( ) ) ; } } public static void main ( String args [ ] ) { int a [ ] = { 1 , 8 , 3 , 11 , 4 , 9 , 2 , 7 } ; int n = a . length ; find@@ Sum@@ Pairs ( a , n ) ; } }
import java . util . * ; class GF@@ G { static int find@@ S@@ malle@@ st@@ After@@ Del ( int arr [ ] , int m , int del [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( mp . containsKey ( del [ i ] ) ) { mp . put ( del [ i ] , mp . get ( del [ i ] ) + 1 ) ; } else { mp . put ( del [ i ] , 1 ) ; } } int smalle@@ st@@ Element = Integer . MAX_VALUE ; for ( int i = 0 ; i < m ; ++ i ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) - 1 ) ; if ( mp . get ( arr [ i ] ) == 0 ) mp . remove ( arr [ i ] ) ; } else smalle@@ st@@ Element = Math . min ( smalle@@ st@@ Element , arr [ i ] ) ; } return smalle@@ st@@ Element ; } public static void main ( String [ ] args ) { int array [ ] = { 5 , 12 , 33 , 4 , 56 , 12 , 20 } ; int m = array . length ; int del [ ] = { 12 , 4 , 56 , 5 } ; int n = del . length ; System . out . println ( find@@ S@@ malle@@ st@@ After@@ Del ( array , m , del , n ) ) ; } }
import java . util . * ; class GF@@ G { static int find@@ lar@@ gest@@ After@@ Del ( int arr [ ] , int m , int del [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( mp . containsKey ( del [ i ] ) ) { mp . put ( del [ i ] , mp . get ( del [ i ] ) + 1 ) ; } else { mp . put ( del [ i ] , 1 ) ; } } int lar@@ gest@@ Element = Integer . MIN_VALUE ; for ( int i = 0 ; i < m ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) - 1 ) ; if ( mp . get ( arr [ i ] ) == 0 ) mp . remove ( arr [ i ] ) ; } else lar@@ gest@@ Element = Math . max ( lar@@ gest@@ Element , arr [ i ] ) ; } return lar@@ gest@@ Element ; } public static void main ( String [ ] args ) { int array [ ] = { 5 , 12 , 33 , 4 , 56 , 12 , 20 } ; int m = array . length ; int del [ ] = { 12 , 33 , 56 , 5 } ; int n = del . length ; System . out . println ( find@@ lar@@ gest@@ After@@ Del ( array , m , del , n ) ) ; } }
import java . io . * ; class GF@@ G { static int solve ( int a [ ] , int n ) { int min@@ 1 = a [ 0 ] ; int max@@ 1 = a [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > max@@ 1 ) max@@ 1 = a [ i ] ; if ( a [ i ] < min@@ 1 ) min@@ 1 = a [ i ] ; } return Math . abs ( min@@ 1 - max@@ 1 ) ; } public static void main ( String [ ] args ) { int [ ] arr = { - 1 , 2 , 3 , 4 , - 10 } ; int size = arr . length ; System . out . println ( " Lar@@ gest ▁ gap ▁ is ▁ : ▁ " + solve ( arr , size ) ) ; } }
import java . io . * ; import java . util . * ; class GF@@ G { static void getMinimum@@ Sum ( int arr [ ] , int n ) { ArrayList < Integer > res = new ArrayList < Integer > ( ) ; ArrayList < Integer > pos = new ArrayList < Integer > ( ) ; ArrayList < Integer > neg = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) pos . add ( i ) ; else if ( arr [ i ] < 0 ) neg . add ( i ) ; } if ( pos . size ( ) >= 2 && neg . size ( ) >= 2 ) { int pos@@ Max = Integer . MIN_VALUE , pos@@ Max@@ Idx = - 1 ; int pos@@ Min = Integer . MAX_VALUE , pos@@ Min@@ Idx = - 1 ; int neg@@ Max = Integer . MIN_VALUE , neg@@ Max@@ Idx = - 1 ; int neg@@ Min = Integer . MAX_VALUE , neg@@ Min@@ Idx = - 1 ; for ( int i = 0 ; i < pos . size ( ) ; i ++ ) { if ( arr [ pos . get ( i ) ] > pos@@ Max ) { pos@@ Max@@ Idx = pos . get ( i ) ; pos@@ Max = arr [ pos@@ Max@@ Idx ] ; } } for ( int i = 0 ; i < pos . size ( ) ; i ++ ) { if ( arr [ pos . get ( i ) ] < pos@@ Min && pos . get ( i ) != pos@@ Max@@ Idx ) { pos@@ Min@@ Idx = pos . get ( i ) ; pos@@ Min = arr [ pos@@ Min@@ Idx ] ; } } for ( int i = 0 ; i < neg . size ( ) ; i ++ ) { if ( Math . abs ( arr [ neg . get ( i ) ] ) > neg@@ Max ) { neg@@ Max@@ Idx = neg . get ( i ) ; neg@@ Max = Math . abs ( arr [ neg@@ Max@@ Idx ] ) ; } } for ( int i = 0 ; i < neg . size ( ) ; i ++ ) { if ( Math . abs ( arr [ neg . get ( i ) ] ) < neg@@ Min && neg . get ( i ) != neg@@ Max@@ Idx ) { neg@@ Min@@ Idx = neg . get ( i ) ; neg@@ Min = Math . abs ( arr [ neg@@ Min@@ Idx ] ) ; } } double pos@@ Val = - 1.0 * ( double ) pos@@ Max / ( double ) pos@@ Min ; double neg@@ Val = - 1.0 * ( double ) neg@@ Max / ( double ) neg@@ Min ; if ( pos@@ Val < neg@@ Val ) { res . add ( arr [ pos@@ Min@@ Idx ] ) ; res . add ( arr [ pos@@ Max@@ Idx ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i != pos@@ Min@@ Idx && i != pos@@ Max@@ Idx ) { res . add ( arr [ i ] ) ; } } } else { res . add ( arr [ neg@@ Min@@ Idx ] ) ; res . add ( arr [ neg@@ Max@@ Idx ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i != neg@@ Min@@ Idx && i != neg@@ Max@@ Idx ) { res . add ( arr [ i ] ) ; } } } for ( int i = 0 ; i < res . size ( ) ; i ++ ) { System . out . print ( res . get ( i ) + " ▁ " ) ; } System . out . println ( ) ; } else if ( pos . size ( ) >= 2 ) { int pos@@ Max = Integer . MIN_VALUE , pos@@ Max@@ Idx = - 1 ; int pos@@ Min = Integer . MAX_VALUE , pos@@ Min@@ Idx = - 1 ; for ( int i = 0 ; i < pos . size ( ) ; i ++ ) { if ( arr [ pos . get ( i ) ] > pos@@ Max ) { pos@@ Max@@ Idx = pos . get ( i ) ; pos@@ Max = arr [ pos@@ Max@@ Idx ] ; } } for ( int i = 0 ; i < pos . size ( ) ; i ++ ) { if ( arr [ pos . get ( i ) ] < pos@@ Min && pos . get ( i ) != pos@@ Max@@ Idx ) { pos@@ Min@@ Idx = pos . get ( i ) ; pos@@ Min = arr [ pos@@ Min@@ Idx ] ; } } res . add ( arr [ pos@@ Min@@ Idx ] ) ; res . add ( arr [ pos@@ Max@@ Idx ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i != pos@@ Min@@ Idx && i != pos@@ Max@@ Idx ) { res . add ( arr [ i ] ) ; } } for ( int i = 0 ; i < res . size ( ) ; i ++ ) { System . out . print ( res . get ( i ) + " ▁ " ) ; } System . out . println ( ) ; } else if ( neg . size ( ) >= 2 ) { int neg@@ Max = Integer . MIN_VALUE , neg@@ Max@@ Idx = - 1 ; int neg@@ Min = Integer . MAX_VALUE , neg@@ Min@@ Idx = - 1 ; for ( int i = 0 ; i < neg . size ( ) ; i ++ ) { if ( Math . abs ( arr [ neg . get ( i ) ] ) > neg@@ Max ) { neg@@ Max@@ Idx = neg . get ( i ) ; neg@@ Max = Math . abs ( arr [ neg@@ Max@@ Idx ] ) ; } } for ( int i = 0 ; i < neg . size ( ) ; i ++ ) { if ( Math . abs ( arr [ neg . get ( i ) ] ) < neg@@ Min && neg . get ( i ) != neg@@ Max@@ Idx ) { neg@@ Min@@ Idx = neg . get ( i ) ; neg@@ Min = Math . abs ( arr [ neg@@ Min@@ Idx ] ) ; } } res . add ( arr [ neg@@ Min@@ Idx ] ) ; res . add ( arr [ neg@@ Max@@ Idx ] ) ; for ( int i = 0 ; i < n ; i ++ ) if ( i != neg@@ Min@@ Idx && i != neg@@ Max@@ Idx ) res . add ( arr [ i ] ) ; for ( int i = 0 ; i < res . size ( ) ; i ++ ) System . out . println ( res . get ( i ) + " ▁ " ) ; System . out . println ( ) ; } else { System . out . println ( " No ▁ swap ▁ required " ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { - 4 , 1 , 6 , - 3 , - 2 , - 1 } ; int n = arr . length ; getMinimum@@ Sum ( arr , n ) ; } }
import java . io . * ; import java . util . * ; class GF@@ G { static int missing@@ Num ( int arr [ ] , int n ) { List < Integer > list = new ArrayList < > ( arr . length ) ; for ( int i : arr ) { list . add ( Integer . valueOf ( i ) ) ; } int min@@ value = Collections . min ( list ) ; ; int xor@@ num = 0 ; for ( int i = 0 ; i < n ; i ++ ) { xor@@ num ^= ( min@@ value ) ^ arr [ i ] ; min@@ value ++ ; } return xor@@ num ^ min@@ value ; } public static void main ( String [ ] args ) { int arr [ ] = { 13 , 12 , 11 , 15 } ; int n = arr . length ; System . out . println ( missing@@ Num ( arr , n ) ) ; } }
import java . util . Arrays ; class GF@@ G { static void maximum@@ Me@@ x ( int arr [ ] , int N ) { int ans [ ] = new int [ 2 * N ] ; Arrays . sort ( ans ) ; int j = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == 0 arr [ i ] != arr [ i - 1 ] ) { j += 1 ; ans [ j ] = arr [ i ] ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( i > 0 && arr [ i ] == arr [ i - 1 ] ) { j += 1 ; ans [ j ] = arr [ i ] ; } } for ( int i = 0 ; i < N ; i ++ ) System . out . print ( ans [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 0 , 0 } ; int N = arr . length ; maximum@@ Me@@ x ( arr , N ) ; } }
import java . io . * ; import java . lang . * ; import java . util . * ; class GF@@ G { static ArrayList < Integer > bu@@ bb@@ le_@@ sort ( ArrayList < Integer > ar ) { if ( ar . size ( ) <= 1 ) return ar ; if ( ar . size ( ) == 2 ) { if ( ar . get ( 0 ) < ar . get ( 1 ) ) return ar ; else return new ArrayList < Integer > ( Arrays . asList ( ar . get ( 1 ) , ar . get ( 0 ) ) ) ; } int a = ar . get ( 0 ) ; int b = ar . get ( 1 ) ; ArrayList < Integer > bs = new ArrayList < > ( ) ; for ( int i = 2 ; i < ar . size ( ) ; i ++ ) bs . add ( ar . get ( i ) ) ; ArrayList < Integer > res = new ArrayList < > ( ) ; if ( a < b ) { ArrayList < Integer > temp1 = new ArrayList < > ( ) ; temp1 . add ( b ) ; for ( int i = 0 ; i < bs . size ( ) ; i ++ ) temp1 . add ( bs . get ( i ) ) ; ArrayList < Integer > v = bu@@ bb@@ le_@@ sort ( temp1 ) ; v . add ( 0 , a ) ; res = v ; } else { ArrayList < Integer > temp1 = new ArrayList < > ( ) ; temp1 . add ( a ) ; for ( int i = 0 ; i < bs . size ( ) ; i ++ ) temp1 . add ( bs . get ( i ) ) ; ArrayList < Integer > v = bu@@ bb@@ le_@@ sort ( temp1 ) ; v . add ( 0 , b ) ; res = v ; } ArrayList < Integer > pass = new ArrayList < > ( ) ; for ( int i = 0 ; i < res . size ( ) - 1 ; i ++ ) pass . add ( res . get ( i ) ) ; ArrayList < Integer > ans = bu@@ bb@@ le_@@ sort ( pass ) ; ans . add ( res . get ( res . size ( ) - 1 ) ) ; return ans ; } public static void main ( String [ ] args ) { ArrayList < Integer > arr = new ArrayList < Integer > ( Arrays . asList ( 1 , 3 , 4 , 5 , 6 , 2 ) ) ; ArrayList < Integer > res = bu@@ bb@@ le_@@ sort ( arr ) ; for ( int i = 0 ; i < res . size ( ) ; i ++ ) System . out . print ( res . get ( i ) + " ▁ " ) ; } }
import java . util . * ; class GF@@ G { public static int solution ( int A , int B , int C ) { int arr [ ] = new int [ 3 ] ; arr [ 0 ] = A ; arr [ 1 ] = B ; arr [ 2 ] = C ; Arrays . sort ( arr ) ; if ( arr [ 2 ] < arr [ 0 ] + arr [ 1 ] ) return ( ( arr [ 0 ] + arr [ 1 ] + arr [ 2 ] ) / 2 ) ; else return ( arr [ 0 ] + arr [ 1 ] ) ; } public static void main ( String [ ] args ) { int A = 8 , B = 1 , C = 5 ; System . out . println ( solution ( A , B , C ) ) ; } }
import java . util . * ; class GF@@ G { static int max_length = 0 ; static Vector < Integer > store = new Vector < Integer > ( ) ; static Vector < Integer > ans = new Vector < Integer > ( ) ; static void find_@@ max_length ( int [ ] arr , int index , int sum , int k ) { sum = sum + arr [ index ] ; store . add ( arr [ index ] ) ; if ( sum == k ) { if ( max_length < store . size ( ) ) { max_length = store . size ( ) ; ans = store ; } } for ( int i = index + 1 ; i < arr . length ; i ++ ) { if ( sum + arr [ i ] <= k ) { find_@@ max_length ( arr , i , sum , k ) ; store . remove ( store . size ( ) - 1 ) ; } else return ; } return ; } static int lon@@ gest@@ Sub@@ sequence ( int [ ] arr , int n , int k ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( max_length >= n - i ) break ; store . clear ( ) ; find_@@ max_length ( arr , i , 0 , k ) ; } return max_length ; } public static void main ( String [ ] args ) { int [ ] arr = { - 3 , 0 , 1 , 1 , 2 } ; int n = arr . length ; int k = 1 ; System . out . print ( lon@@ gest@@ Sub@@ sequence ( arr , n , k ) ) ; } }
import java . io . * ; class GF@@ G { static int getNumber ( int n , int k ) { int pos ; if ( ( n % 2 ) == 0 ) { pos = n / 2 ; } else { pos = ( n / 2 ) + 1 ; } if ( k <= pos ) { return ( k * 2 - 1 ) ; } else return ( ( k - pos ) * 2 ) ; } public static void main ( String [ ] args ) { int n = 8 , k = 5 ; System . out . println ( getNumber ( n , k ) ) ; } }
import java . util . Arrays ; import java . io . * ; class GF@@ G { static int count@@ Sequences ( int arr [ ] , int n ) { int count = 1 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] + 1 != arr [ i + 1 ] ) count ++ ; return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 7 , 3 , 5 , 10 } ; int n = arr . length ; System . out . println ( count@@ Sequences ( arr , n ) ) ; } }
import java . io . * ; import java . util . * ; import java . lang . * ; class GF@@ G { static boolean check@@ Fit@@ ting@@ Arrays ( int [ ] A , int [ ] B , int N ) { Arrays . sort ( A ) ; Arrays . sort ( B ) ; for ( int i = 0 ; i < N ; i ++ ) if ( A [ i ] > B [ i ] ) return false ; return true ; } public static void main ( String [ ] args ) { int A [ ] = { 7 , 5 , 3 , 2 } ; int B [ ] = { 5 , 4 , 8 , 7 } ; int N = A . length ; if ( check@@ Fit@@ ting@@ Arrays ( A , B , N ) ) System . out . print ( " YES " ) ; else System . out . print ( " NO " ) ; } }
class GF@@ G { static void stable@@ Selection@@ Sort ( int [ ] a , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { int min = i ; for ( int j = i + 1 ; j < n ; j ++ ) if ( a [ min ] > a [ j ] ) min = j ; int key = a [ min ] ; while ( min > i ) { a [ min ] = a [ min - 1 ] ; min -- ; } a [ i ] = key ; } } static void print@@ Array ( int [ ] a , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; System . out . println ( ) ; } public static void main ( String [ ] args ) { int [ ] a = { 4 , 5 , 3 , 2 , 4 , 1 } ; int n = a . length ; stable@@ Selection@@ Sort ( a , n ) ; print@@ Array ( a , n ) ; } }
import java . io . * ; class Pan@@ ca@@ ke@@ Sort { static void flip ( int arr [ ] , int i ) { int temp , start = 0 ; while ( start < i ) { temp = arr [ start ] ; arr [ start ] = arr [ i ] ; arr [ i ] = temp ; start ++ ; i -- ; } } static int find@@ Max ( int arr [ ] , int n ) { int mi , i ; for ( mi = 0 , i = 0 ; i < n ; ++ i ) if ( arr [ i ] > arr [ mi ] ) mi = i ; return mi ; } static int pan@@ ca@@ ke@@ Sort ( int arr [ ] , int n ) { for ( int curr_@@ size = n ; curr_@@ size > 1 ; -- curr_@@ size ) { int mi = find@@ Max ( arr , curr_@@ size ) ; if ( mi != curr_@@ size - 1 ) { flip ( arr , mi ) ; flip ( arr , curr_@@ size - 1 ) ; } } return 0 ; } static void print@@ Array ( int arr [ ] , int arr_@@ size ) { for ( int i = 0 ; i < arr_@@ size ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; System . out . println ( " " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 23 , 10 , 20 , 11 , 12 , 6 , 7 } ; int n = arr . length ; pan@@ ca@@ ke@@ Sort ( arr , n ) ; System . out . println ( " Sorted ▁ Array : ▁ " ) ; print@@ Array ( arr , n ) ; } }
import java . io . * ; class GF@@ G { static void find@@ Array@@ With@@ Max@@ Product ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) if ( arr [ i ] >= 0 ) { arr [ i ] = - arr [ i ] - 1 ; } if ( N % 2 == 1 ) { int max_@@ element = - 1 ; int index = - 1 ; for ( int i = 0 ; i < N ; i ++ ) if ( Math . abs ( arr [ i ] ) > max_@@ element ) { max_@@ element = Math . abs ( arr [ i ] ) ; index = i ; } arr [ index ] = - arr [ index ] - 1 ; } for ( int i = 0 ; i < N ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { - 3 , 0 , 1 } ; int N = arr . length ; find@@ Array@@ With@@ Max@@ Product ( arr , N ) ; } }
import java . lang . * ; import java . io . * ; import java . util . * ; class GF@@ G { static int N = 100000 + 5 ; static int visited [ ] = new int [ N ] ; static void construct_@@ tree ( int weights [ ] , int n ) { int minimum = Arrays . stream ( weights ) . min ( ) . getAs@@ Int ( ) ; int maximum = Arrays . stream ( weights ) . max ( ) . getAs@@ Int ( ) ; if ( minimum == maximum ) { System . out . println ( " No " ) ; return ; } else { System . out . println ( " Yes " ) ; } int root = weights [ 0 ] ; visited [ 1 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( weights [ i ] != root && visited [ i + 1 ] == 0 ) { System . out . println ( 1 + " ▁ " + ( i + 1 ) + " ▁ " ) ; visited [ i + 1 ] = 1 ; } } int not@@ root = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( weights [ i ] != root ) { not@@ root = i + 1 ; break ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( weights [ i ] == root && visited [ i + 1 ] == 0 ) { System . out . println ( not@@ root + " ▁ " + ( i + 1 ) ) ; visited [ i + 1 ] = 1 ; } } } public static void main ( String [ ] args ) { int weights [ ] = { 1 , 2 , 1 , 2 , 5 } ; int N = weights . length ; construct_@@ tree ( weights , N ) ; } }
import java . util . * ; class GF@@ G { static void addEdge ( Vector < Integer > adj [ ] , int u , int v ) { adj [ u ] . add ( v ) ; adj [ v ] . add ( u ) ; } static int cnt = 0 ; static boolean [ ] visited ; static void DFS ( int u , Vector < Integer > adj [ ] , int fr@@ e [ ] , String S ) { visited [ u ] = true ; cnt ++ ; fr@@ e [ S . charAt ( u ) - ' a ' ] ++ ; for ( int i = 0 ; i < adj [ u ] . size ( ) ; i ++ ) { if ( ! visited [ adj [ u ] . get ( i ) ] ) { DFS ( adj [ u ] . get ( i ) , adj , fr@@ e , S ) ; } } } static void minimum@@ Operations ( String S , int m ) { int V = 100 ; @ SuppressWarnings ( " unchecked " ) Vector < Integer > [ ] adj = new Vector [ V ] ; int total = 0 , N = S . length ( ) ; for ( int i = 0 ; i < adj . length ; i ++ ) adj [ i ] = new Vector < Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { addEdge ( adj , i , N - i - 1 ) ; addEdge ( adj , N - i - 1 , i ) ; } for ( int i = 0 ; i < N - m ; i ++ ) { addEdge ( adj , i , i + m ) ; addEdge ( adj , i + m , i ) ; } visited = new boolean [ V ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( ! visited [ i ] ) { int fr@@ e [ ] = new int [ 26 ] ; cnt = 0 ; int maxx = - 1 ; DFS ( i , adj , fr@@ e , S ) ; for ( int j = 0 ; j < 26 ; j ++ ) maxx = Math . max ( maxx , fr@@ e [ j ] ) ; total += cnt - maxx ; } } System . out . print ( total ) ; } public static void main ( String [ ] args ) { String S = " ab@@ a@@ aba " ; int K = 2 ; minimum@@ Operations ( S , K ) ; } }
import java . util . * ; class GF@@ G { static int clear@@ Last@@ Bit ( int N , int K ) { int mask = ( - 1 << K + 1 ) ; return N = N & mask ; } public static void main ( String [ ] args ) { int N = 7@@ 30 , K = 3 ; System . out . print ( clear@@ Last@@ Bit ( N , K ) ) ; } }
import java . util . * ; class GF@@ G { static boolean is@@ Possible ( int r , int b , int g ) { r = r % 3 ; b = b % 3 ; g = g % 3 ; if ( r == b b == g g == r ) { return true ; } else { return false ; } } public static void main ( String [ ] args ) { int R = 1 , B = 3 , G = 6 ; if ( is@@ Possible ( R , B , G ) ) { System . out . print ( " Yes " + "@@ NEW_@@ LINE@@ "@@ )@@ ; } else { System . out . print ( " No " + "@@ NEW_@@ LINE@@ "@@ )@@ ; } } }
class GF@@ G { static int count@@ Set@@ Bits@@ Util ( int x ) { if ( x <= 0 ) return 0 ; return ( ( x % 2 == 0 ? 0 : 1 ) + count@@ Set@@ Bits@@ Util ( x / 2 ) ) ; } static int count@@ Set@@ Bits ( int L , int R ) { int bit@@ Count = 0 ; for ( int i = L ; i <= R ; i ++ ) { bit@@ Count += count@@ Set@@ Bits@@ Util ( i ) ; } return bit@@ Count ; } public static void main ( String [ ] args ) { int L = 3 , R = 5 ; System . out . printf ( " Total ▁ set ▁ bit ▁ count ▁ is ▁ % d " , count@@ Set@@ Bits ( L , R ) ) ; } }
class GF@@ G { static int getMin@@ Cost ( int [ ] A , int [ ] B , int N ) { int mini = Integer . MAX_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { mini = Math . min ( mini , Math . min ( A [ i ] , B [ i ] ) ) ; } return mini * ( 2 * N - 1 ) ; } public static void main ( String [ ] args ) { int N = 3 ; int [ ] A = { 1 , 4 , 2 } ; int [ ] B = { 10 , 6 , 12 } ; System . out . print ( getMin@@ Cost ( A , B , N ) ) ; } }
class GF@@ G { static int find@@ M ( int N ) { int M = 0 ; int MSB = ( int ) Math . log ( N ) ; for ( int i = 0 ; i < MSB ; i ++ ) { if ( ( N & ( 1 << i ) ) == 0 ) M += ( 1 << i ) ; } return M ; } public static void main ( String [ ] args ) { int N = 6 ; System . out . print ( find@@ M ( N ) ) ; } }
import java . io . * ; class GF@@ G { static int max@@ Modu@@ lo@@ sum ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } return sum - n ; } public static void main ( String [ ] args ) { int a [ ] = new int [ ] { 3 , 4 , 6 } ; int n = a . length ; System . out . println ( max@@ Modu@@ lo@@ sum ( a , n ) ) ; } }
import java . util . * ; class GF@@ G { static void make@@ Zero ( int x , int y , int a , int b ) { if ( x > y ) { int temp = x ; x = y ; y = temp ; } int tot_@@ cost = ( y - x ) * a ; int cost@@ 1 = 2 * x * a ; int cost@@ 2 = x * b ; tot_@@ cost += Math . min ( cost@@ 1 , cost@@ 2 ) ; System . out . print ( tot_@@ cost ) ; } public static void main ( String args [ ] ) { int X = 1 , Y = 3 ; int cost@@ 1 = 39@@ 1 , cost@@ 2 = 555 ; make@@ Zero ( X , Y , cost@@ 1 , cost@@ 2 ) ; } }
import java . util . Scanner ; class Solution { public static void split@@ Fraction ( int n , int d ) { long ar [ ] = new long [ n ] ; long first = d + n - 1 ; ar [ 0 ] = first ; for ( int i = 1 ; i < n ; i ++ ) { ar [ i ] = first * ( -- first ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( ar [ i ] % n == 0 ) { System . out . print ( "1 / " + ar [ i ] / n + " , ▁ " ) ; } else { System . out . print ( n + " / " + ar [ i ] + " , ▁ " ) ; } } } public static void main ( String [ ] args ) throws Exception { int N = 4 ; int D = 2 ; split@@ Fraction ( N , D ) ; } }
class GF@@ G { static int find@@ Minimum@@ Sub@@ sequences ( String A , String B ) { int numberOf@@ Sub@@ sequences = 1 ; int sizeOf@@ B = B . length ( ) ; int sizeOf@@ A = A . length ( ) ; int inf = 1000000 ; int [ ] [ ] next = new int [ 26 ] [ sizeOf@@ B ] ; for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 0 ; j < sizeOf@@ B ; j ++ ) { next [ i ] [ j ] = inf ; } } for ( int i = 0 ; i < sizeOf@@ B ; i ++ ) { next [ B . charAt ( i ) - ' a ' ] [ i ] = i ; } for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = sizeOf@@ B - 2 ; j >= 0 ; j -- ) { if ( next [ i ] [ j ] == inf ) { next [ i ] [ j ] = next [ i ] [ j + 1 ] ; } } } int pos = 0 ; int i = 0 ; while ( i < sizeOf@@ A ) { if ( pos == 0 && next [ A . charAt ( i ) - ' a ' ] [ pos ] == inf ) { numberOf@@ Sub@@ sequences = - 1 ; break ; } else if ( pos < sizeOf@@ B && next [ A . charAt ( i ) - ' a ' ] [ pos ] < inf ) { int nextIndex = next [ A . charAt ( i ) - ' a ' ] [ pos ] + 1 ; pos = nextIndex ; i ++ ; } else { numberOf@@ Sub@@ sequences ++ ; pos = 0 ; } } return numberOf@@ Sub@@ sequences ; } public static void main ( String [ ] args ) { String A = " a@@ ac@@ be " ; String B = " ace@@ ab " ; System . out . print ( find@@ Minimum@@ Sub@@ sequences ( A , B ) ) ; } }
import java . util . * ; class GF@@ G { public static int count_@@ minimum_@@ operations ( int n ) { if ( n == 2 ) { return 1 ; } else if ( n == 1 ) { return 0 ; } if ( n % 3 == 0 ) { return 1 + count_@@ minimum_@@ operations ( n / 3 ) ; } else if ( n % 3 == 1 ) { return 1 + count_@@ minimum_@@ operations ( n - 1 ) ; } else { return 1 + count_@@ minimum_@@ operations ( n + 1 ) ; } } public static void main ( String [ ] args ) { int n = 4 ; int ans = count_@@ minimum_@@ operations ( n ) ; System . out . println ( ans ) ; } }
class G@@ fg { public static int problem@@ s@@ Left ( int K , int P , int N ) { if ( K <= P ) return 0 ; else return ( ( K - P ) * N ) ; } public static void main ( String args [ ] ) { int K , P , N ; K = 4 ; P = 1 ; N = 10 ; System . out . println ( problem@@ s@@ Left ( K , P , N ) ) ; } }
import java . util . * ; class GF@@ G { static int V = 5 ; static int [ ] parent = new int [ V ] ; static int INF = Integer . MAX_VALUE ; static int find ( int i ) { while ( parent [ i ] != i ) i = parent [ i ] ; return i ; } static void union@@ 1 ( int i , int j ) { int a = find ( i ) ; int b = find ( j ) ; parent [ a ] = b ; } static void kr@@ us@@ kal@@ M@@ ST ( int cost [ ] [ ] ) { for ( int i = 0 ; i < V ; i ++ ) parent [ i ] = i ; int edge@@ _count = 0 ; while ( edge@@ _count < V - 1 ) { int min = INF , a = - 1 , b = - 1 ; for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { if ( find ( i ) != find ( j ) && cost [ i ] [ j ] < min ) { min = cost [ i ] [ j ] ; a = i ; b = j ; } } } union@@ 1 ( a , b ) ; System . out . printf ( "@@ Edge %@@ d@@ :@@ (@@ %@@ d@@ , %@@ d@@ ) cost@@ :@@ %@@ d NEW_@@ LINE@@ "@@ , edge_@@ count@@ ++@@ , a@@ , b@@ , min@@ )@@ ; min@@ cost += min ; } System . out . printf ( " Minimum cost = % d "@@ , min@@ cost@@ )@@ ; } public static void main ( String [ ] args ) { int cost [ ] [ ] = { { INF , 2 , INF , 6 , INF } , { 2 , INF , 3 , 8 , 5 } , { INF , 3 , INF , INF , 7 } , { 6 , 8 , INF , INF , 9 } , { INF , 5 , 7 , 9 , INF } , } ; kr@@ us@@ kal@@ M@@ ST ( cost ) ; } }
class GF@@ G { static int find@@ Min@@ Cost ( int [ ] [ ] arr , int X , int n , int i ) { if ( X <= 0 ) return 0 ; if ( i >= n ) return Integer . MAX_VALUE ; int inc = find@@ Min@@ Cost ( arr , X - arr [ i ] [ 0 ] , n , i + 1 ) ; if ( inc != Integer . MAX_VALUE ) inc += arr [ i ] [ 1 ] ; int exc = find@@ Min@@ Cost ( arr , X , n , i + 1 ) ; return Math . min ( inc , exc ) ; } public static void main ( String [ ] args ) { int [ ] [ ] arr = { { 4 , 3 } , { 3 , 2 } , { 2 , 4 } , { 1 , 3 } , { 4 , 2 } } ; int X = 7 ; int n = arr . length ; int ans = find@@ Min@@ Cost ( arr , X , n , 0 ) ; if ( ans != Integer . MAX_VALUE ) System . out . println ( ans ) ; else System . out . println ( - 1 ) ; } }
import java . util . * ; class GF@@ G { static Map < String , Integer > dp = new HashMap < > ( ) ; static int max@@ Score ( String s , int [ ] a ) { if ( dp . containsKey ( s ) ) return dp . get ( s ) ; int n = s . length ( ) ; if ( n == 0 ) return 0 ; if ( n == 1 ) return a [ 0 ] ; int head = 0 ; int mx = - 1 ; while ( head < n ) { int tail = head ; while ( tail < n ) { if ( s . charAt ( tail ) != s . charAt ( head ) ) { head = tail ; break ; } String sub = s . substring ( head , tail + 1 ) ; mx = Math . max ( mx , a [ sub . length ( ) - 1 ] + max@@ Score ( s . substring ( 0 , head ) + s . substring ( tail + 1 , s . length ( ) ) , a ) ) ; tail += 1 ; } if ( tail == n ) break ; } dp . put ( s , mx ) ; return mx ; } public static void main ( String [ ] args ) { String s = " abb " ; int [ ] a = { 1 , 3 , 1 } ; System . out . println ( ( max@@ Score ( s , a ) ) ) ; } }
import java . util . * ; class GF@@ G { static int k@@ ad@@ ane ( Vector < Integer > v ) { int curr@@ Sum = 0 ; int max@@ Sum = Integer . MIN_VALUE ; for ( int i = 0 ; i < ( int ) v . size ( ) ; i ++ ) { curr@@ Sum += v . get ( i ) ; if ( curr@@ Sum > max@@ Sum ) { max@@ Sum = curr@@ Sum ; } if ( curr@@ Sum < 0 ) { curr@@ Sum = 0 ; } } return max@@ Sum ; } static void max@@ Sub@@ matrix@@ Sum ( int [ ] [ ] A ) { int r = A . length ; int c = A [ 0 ] . length ; int [ ] [ ] prefix = new int [ r ] [ ] ; for ( int i = 0 ; i < r ; i ++ ) { prefix [ i ] = new int ; for ( int j = 0 ; j < c ; j ++ ) { prefix [ i ] [ j ] = 0 ; } } for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) { if ( j == 0 ) prefix [ i ] [ j ] = A [ i ] [ j ] ; else prefix [ i ] [ j ] = A [ i ] [ j ] + prefix [ i ] [ j - 1 ] ; } } int max@@ Sum = Integer . MIN_VALUE ; for ( int i = 0 ; i < c ; i ++ ) { for ( int j = i ; j < c ; j ++ ) { Vector < Integer > v = new Vector < Integer > ( ) ; for ( int k = 0 ; k < r ; k ++ ) { int el = 0 ; if ( i == 0 ) el = prefix [ k ] [ j ] ; else el = prefix [ k ] [ j ] - prefix [ k ] [ i - 1 ] ; v . add ( el ) ; } max@@ Sum = Math . max ( max@@ Sum , k@@ ad@@ ane ( v ) ) ; } } System . out . print ( max@@ Sum + "@@ NEW_@@ LINE@@ "@@ )@@ ; } public static void main ( String [ ] args ) { int [ ] [ ] matrix = { { 0 , - 2 , - 7 , 0 } , { 9 , 2 , - 6 , 2 } , { - 4 , 1 , - 4 , 1 } , { - 1 , 8 , 0 , - 2 } } ; max@@ Sub@@ matrix@@ Sum ( matrix ) ; } }
import java . io . * ; class GF@@ G { static void number@@ of@@ pairs ( int [ ] [ ] v , int k ) { int n = v . length ; if ( n % 2 == 1 ) { System . out . println ( 0 ) ; return ; } int ans = 0 ; int dp [ ] [ ] = new int [ k ] [ 2 ] ; for ( int i = 0 ; i < k ; i ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( i + j ) % 2 == 0 ) dp [ v [ i ] [ j ] - 1 ] [ 0 ] ++ ; else dp [ v [ i ] [ j ] - 1 ] [ 1 ] ++ ; } } for ( int i = 0 ; i < k ; i ++ ) { for ( int j = i + 1 ; j < k ; j ++ ) { ans += dp [ i ] [ 0 ] * dp [ j ] [ 1 ] ; ans += dp [ i ] [ 1 ] * dp [ j ] [ 0 ] ; } } System . out . println ( ans ) ; } public static void main ( String [ ] args ) { int [ ] [ ] mat = { { 1 , 2 } , { 3 , 4 } } ; int K = 4 ; number@@ of@@ pairs ( mat , K ) ; } }
import java . util . * ; class GF@@ G { static int __@@ gcd ( int a , int b ) { return b == 0 ? a : __@@ gcd ( b , a % b ) ; } static int find@@ Max@@ GC@@ D ( int arr [ ] , int N ) { int high = 0 ; for ( int i = 0 ; i < N ; i ++ ) { high = Math . max ( high , arr [ i ] ) ; } int [ ] count = new int [ high + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { count [ arr [ i ] ] += 1 ; } int counter = 0 ; for ( int i = high ; i > 0 ; i -- ) { int j = i ; while ( j <= high ) { if ( count [ j ] > 0 ) counter += count [ j ] ; j += i ; if ( counter == 2 ) return i ; } counter = 0 ; } return 0 ; } static int maxlen ( int i , int j , int arr [ ] , int ar@@ r1 [ ] , int N , int max@@ gcd ) { int a = 1 ; if ( i >= N j >= N ) return 0 ; if ( __@@ gcd ( arr [ i ] , ar@@ r1 [ j ] ) == max@@ gcd && arr [ i ] != ar@@ r1 [ j ] ) { a = Math . max ( a , 1 + maxlen ( i , j + 1 , arr , ar@@ r1 , N , max@@ gcd ) ) ; return a ; } return Math . max ( maxlen ( i + 1 , j , arr , ar@@ r1 , N , max@@ gcd ) , maxlen ( i , j + 1 , arr , ar@@ r1 , N , max@@ gcd ) ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 8 , 5 , 6 } ; int ar@@ r1 [ ] = { 1 , 2 , 8 , 5 , 6 } ; int n = arr . length ; Arrays . sort ( arr ) ; int max@@ gcd = find@@ Max@@ GC@@ D ( arr , n ) ; System . out . print ( maxlen ( 0 , 0 , arr , ar@@ r1 , n , max@@ gcd ) ) ; } }
import java . util . * ; class GF@@ G { static int find@@ W@@ ays ( int N , int dp [ ] ) { if ( N == 0 ) { return 1 ; } if ( dp [ N ] != - 1 ) { return dp [ N ] ; } int cnt = 0 ; for ( int i = 1 ; i <= 6 ; i ++ ) { if ( N - i >= 0 ) { cnt = cnt + find@@ W@@ ays ( N - i , dp ) ; } } return dp [ N ] = cnt ; } public static void main ( String [ ] args ) { int N = 4 ; int [ ] dp = new int [ N + 1 ] ; for ( int i = 0 ; i < dp . length ; i ++ ) dp [ i ] = - 1 ; System . out . print ( find@@ W@@ ays ( N , dp ) ) ; } }
class GF@@ G { static int min@@ Days ( int n ) { if ( n < 1 ) return n ; int cnt = 1 + Math . min ( n % 2 + min@@ Days ( n / 2 ) , n % 3 + min@@ Days ( n / 3 ) ) ; return cnt ; } public static void main ( String [ ] args ) { int N = 6 ; System . out . print ( min@@ Days ( N ) ) ; } }
class GF@@ G { public static void count@@ Num@@ s ( int N ) { int dp [ ] [ ] = new int [ N ] [ 16 ] ; for ( int i = 1 ; i <= 9 ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { for ( int k = 0 ; k < 16 ; k ++ ) { int xor = j ^ k ; dp [ i ] [ xor ] += dp [ i - 1 ] [ k ] ; } } } int count = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) count += dp [ N - 1 ] [ i ] ; System . out . println ( count ) ; } public static void main ( String [ ] args ) { int N = 1 ; count@@ Num@@ s ( N ) ; } }
class GF@@ G { static int count ( int a [ ] , int M , int N ) { int cnt = 0 ; for ( int i = 1 ; i <= M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( i % a [ j ] == 0 ) { cnt ++ ; break ; } } } return cnt ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 5 , 7 } ; int m = 100 ; int n = arr . length ; System . out . print ( count ( arr , m , n ) ) ; } }
