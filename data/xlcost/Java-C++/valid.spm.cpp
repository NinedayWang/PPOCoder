▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁calculate Span ▁( ▁int ▁price ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁S ▁[ ▁] ▁) ▁{ ▁S ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁S ▁[ ▁i ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁- ▁1 ▁; ▁( ▁j ▁>= ▁0 ▁) ▁&& ▁( ▁price ▁[ ▁i ▁] ▁>= ▁price ▁[ ▁j ▁] ▁) ▁; ▁j ▁-- ▁) ▁S ▁[ ▁i ▁] ▁++ ▁; ▁} ▁} ▁void ▁print Array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁price ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁4 ▁, ▁5 ▁, ▁90 ▁, ▁120 ▁, ▁80 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁price ▁) ▁/ ▁sizeof ▁( ▁price ▁[ ▁0 ▁] ▁) ▁; ▁int ▁S ▁[ ▁n ▁] ▁; ▁calculate Span ▁( ▁price ▁, ▁n ▁, ▁S ▁) ▁; ▁print Array ▁( ▁S ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print NG E ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁next ▁, ▁i ▁, ▁j ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁next ▁= ▁-1 ▁; ▁for ▁( ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁arr ▁[ ▁j ▁] ▁) ▁{ ▁next ▁= ▁arr ▁[ ▁j ▁] ▁; ▁break ▁; ▁} ▁} ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁<< ▁" ▁- ▁- ▁" ▁<< ▁next ▁<< ▁end l ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁11 ▁, ▁13 ▁, ▁21 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁print NG E ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁Print Min Number For Pattern ▁( ▁string ▁seq ▁) ▁{ ▁string ▁result ▁; ▁stack ▁< ▁int ▁> ▁st k ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁seq ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁st k ▁. ▁push ▁( ▁i ▁+ ▁1 ▁) ▁; ▁if ▁( ▁i ▁== ▁seq ▁. ▁length ▁( ▁) ▁seq ▁[ ▁i ▁] ▁== ▁' ▁I ▁' ▁) ▁{ ▁while ▁( ▁! ▁st k ▁. ▁empty ▁( ▁) ▁) ▁{ ▁result ▁+= ▁to _ string ▁( ▁st k ▁. ▁top ▁( ▁) ▁) ▁; ▁result ▁+= ▁" ▁" ▁; ▁st k ▁. ▁pop ▁( ▁) ▁; ▁} ▁} ▁} ▁c out ▁<< ▁result ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁Print Min Number For Pattern ▁( ▁" ▁ID ID ▁" ▁) ▁; ▁Print Min Number For Pattern ▁( ▁" ▁I ▁" ▁) ▁; ▁Print Min Number For Pattern ▁( ▁" ▁DD ▁" ▁) ▁; ▁Print Min Number For Pattern ▁( ▁" ▁II ▁" ▁) ▁; ▁Print Min Number For Pattern ▁( ▁" ▁D ID I ▁" ▁) ▁; ▁Print Min Number For Pattern ▁( ▁" ▁I ID DD ▁" ▁) ▁; ▁Print Min Number For Pattern ▁( ▁" ▁DD ID DI ID ▁" ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁most F requ ent ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁unordered _ map ▁< ▁int ▁, ▁int ▁> ▁hash ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁hash ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁++ ▁; ▁int ▁max _ count ▁= ▁0 ▁, ▁res ▁= ▁-1 ▁; ▁for ▁( ▁auto ▁i ▁: ▁hash ▁) ▁{ ▁if ▁( ▁max _ count ▁< ▁i ▁. ▁second ▁) ▁{ ▁res ▁= ▁i ▁. ▁first ▁; ▁max _ count ▁= ▁i ▁. ▁second ▁; ▁} ▁} ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁5 ▁, ▁2 ▁, ▁1 ▁, ▁3 ▁, ▁2 ▁, ▁1 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁most F requ ent ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find Missing ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁b ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁unordered _ set ▁< ▁int ▁> ▁s ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁m ▁; ▁i ▁++ ▁) ▁s ▁. ▁insert ▁( ▁b ▁[ ▁i ▁] ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁s ▁. ▁find ▁( ▁a ▁[ ▁i ▁] ▁) ▁== ▁s ▁. ▁end ▁( ▁) ▁) ▁c out ▁<< ▁a ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁6 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁b ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁4 ▁, ▁3 ▁, ▁1 ▁, ▁0 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁int ▁m ▁= ▁sizeof ▁( ▁b ▁) ▁/ ▁sizeof ▁( ▁b ▁[ ▁1 ▁] ▁) ▁; ▁find Missing ▁( ▁a ▁, ▁b ▁, ▁n ▁, ▁m ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁subset ▁( ▁int ▁ar ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁res ▁= ▁0 ▁; ▁sort ▁( ▁ar ▁, ▁ar ▁+ ▁n ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁count ▁= ▁1 ▁; ▁for ▁( ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁ar ▁[ ▁i ▁] ▁== ▁ar ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁count ▁++ ▁; ▁else ▁break ▁; ▁} ▁res ▁= ▁max ▁( ▁res ▁, ▁count ▁) ▁; ▁} ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁6 ▁, ▁9 ▁, ▁3 ▁, ▁4 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁subset ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁make Perm utation ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁unordered _ map ▁< ▁int ▁, ▁int ▁> ▁count ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁count ▁[ ▁a ▁[ ▁i ▁] ▁] ▁++ ▁; ▁int ▁next _ missing ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁count ▁[ ▁a ▁[ ▁i ▁] ▁] ▁!= ▁1 ▁a ▁[ ▁i ▁] ▁> ▁n ▁a ▁[ ▁i ▁] ▁< ▁1 ▁) ▁{ ▁count ▁[ ▁a ▁[ ▁i ▁] ▁] ▁-- ▁; ▁while ▁( ▁count ▁. ▁find ▁( ▁next _ missing ▁) ▁!= ▁count ▁. ▁end ▁( ▁) ▁) ▁next _ missing ▁++ ▁; ▁a ▁[ ▁i ▁] ▁= ▁next _ missing ▁; ▁count ▁[ ▁next _ missing ▁] ▁= ▁1 ▁; ▁} ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁2 ▁, ▁3 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁A ▁) ▁/ ▁sizeof ▁( ▁A ▁[ ▁0 ▁] ▁) ▁; ▁make Perm utation ▁( ▁A ▁, ▁n ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁A ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁2 ▁, ▁-2 ▁, ▁- 20 ▁, ▁10 ▁} ▁; ▁int ▁k ▁= ▁-10 ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁res ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁sum ▁+= ▁arr ▁[ ▁j ▁] ▁; ▁if ▁( ▁sum ▁== ▁k ▁) ▁res ▁++ ▁; ▁} ▁} ▁c out ▁<< ▁( ▁res ▁) ▁<< ▁end l ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find Pairs ▁( ▁int ▁arr 1 ▁[ ▁] ▁, ▁int ▁arr 2 ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁m ▁, ▁int ▁x ▁) ▁{ ▁unordered _ set ▁< ▁int ▁> ▁s ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁s ▁. ▁insert ▁( ▁arr 1 ▁[ ▁i ▁] ▁) ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁m ▁; ▁j ▁++ ▁) ▁if ▁( ▁s ▁. ▁find ▁( ▁x ▁- ▁arr 2 ▁[ ▁j ▁] ▁) ▁!= ▁s ▁. ▁end ▁( ▁) ▁) ▁c out ▁<< ▁x ▁- ▁arr 2 ▁[ ▁j ▁] ▁<< ▁" ▁" ▁<< ▁arr 2 ▁[ ▁j ▁] ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr 1 ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁0 ▁, ▁-4 ▁, ▁7 ▁, ▁6 ▁, ▁4 ▁} ▁; ▁int ▁arr 2 ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁2 ▁, ▁4 ▁, ▁-3 ▁, ▁2 ▁, ▁1 ▁} ▁; ▁int ▁x ▁= ▁8 ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr 1 ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁int ▁m ▁= ▁sizeof ▁( ▁arr 2 ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁find Pairs ▁( ▁arr 1 ▁, ▁arr 2 ▁, ▁n ▁, ▁m ▁, ▁x ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁find Tri plet ▁( ▁int ▁a 1 ▁[ ▁] ▁, ▁int ▁a 2 ▁[ ▁] ▁, ▁int ▁a 3 ▁[ ▁] ▁, ▁int ▁n 1 ▁, ▁int ▁n 2 ▁, ▁int ▁n 3 ▁, ▁int ▁sum ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n 1 ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n 2 ▁; ▁j ▁++ ▁) ▁for ▁( ▁int ▁k ▁= ▁0 ▁; ▁k ▁< ▁n 3 ▁; ▁k ▁++ ▁) ▁if ▁( ▁a 1 ▁[ ▁i ▁] ▁+ ▁a 2 ▁[ ▁j ▁] ▁+ ▁a 3 ▁[ ▁k ▁] ▁== ▁sum ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a 1 ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁a 2 ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁6 ▁, ▁1 ▁, ▁2 ▁} ▁; ▁int ▁a 3 ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁2 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁int ▁sum ▁= ▁9 ▁; ▁int ▁n 1 ▁= ▁sizeof ▁( ▁a 1 ▁) ▁/ ▁sizeof ▁( ▁a 1 ▁[ ▁0 ▁] ▁) ▁; ▁int ▁n 2 ▁= ▁sizeof ▁( ▁a 2 ▁) ▁/ ▁sizeof ▁( ▁a 2 ▁[ ▁0 ▁] ▁) ▁; ▁int ▁n 3 ▁= ▁sizeof ▁( ▁a 3 ▁) ▁/ ▁sizeof ▁( ▁a 3 ▁[ ▁0 ▁] ▁) ▁; ▁find Tri plet ▁( ▁a 1 ▁, ▁a 2 ▁, ▁a 3 ▁, ▁n 1 ▁, ▁n 2 ▁, ▁n 3 ▁, ▁sum ▁) ▁? ▁c out ▁<< ▁" ▁Yes ▁" ▁: ▁c out ▁<< ▁" ▁No ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁longest ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁unordered _ map ▁< ▁int ▁, ▁int ▁> ▁freq ▁; ▁int ▁start ▁= ▁0 ▁, ▁end ▁= ▁0 ▁, ▁now ▁= ▁0 ▁, ▁l ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁freq ▁[ ▁a ▁[ ▁i ▁] ▁] ▁++ ▁; ▁if ▁( ▁freq ▁[ ▁a ▁[ ▁i ▁] ▁] ▁== ▁1 ▁) ▁now ▁++ ▁; ▁while ▁( ▁now ▁> ▁k ▁) ▁{ ▁freq ▁[ ▁a ▁[ ▁l ▁] ▁] ▁-- ▁; ▁if ▁( ▁freq ▁[ ▁a ▁[ ▁l ▁] ▁] ▁== ▁0 ▁) ▁now ▁-- ▁; ▁l ▁++ ▁; ▁} ▁if ▁( ▁i ▁- ▁l ▁+ ▁1 ▁>= ▁end ▁- ▁start ▁+ ▁1 ▁) ▁end ▁= ▁i ▁, ▁start ▁= ▁l ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁start ▁; ▁i ▁<= ▁end ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁a ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁6 ▁, ▁5 ▁, ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁2 ▁, ▁1 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁int ▁k ▁= ▁3 ▁; ▁longest ▁( ▁a ▁, ▁n ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Sub Array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁int ▁maxsize ▁= ▁-1 ▁, ▁start index ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁= ▁( ▁arr ▁[ ▁i ▁] ▁== ▁0 ▁) ▁? ▁-1 ▁: ▁1 ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁( ▁arr ▁[ ▁j ▁] ▁== ▁0 ▁) ▁? ▁( ▁sum ▁+= ▁-1 ▁) ▁: ▁( ▁sum ▁+= ▁1 ▁) ▁; ▁if ▁( ▁sum ▁== ▁0 ▁&& ▁maxsize ▁< ▁j ▁- ▁i ▁+ ▁1 ▁) ▁{ ▁maxsize ▁= ▁j ▁- ▁i ▁+ ▁1 ▁; ▁start index ▁= ▁i ▁; ▁} ▁} ▁} ▁if ▁( ▁maxsize ▁== ▁-1 ▁) ▁c out ▁<< ▁" ▁No ▁such ▁sub array ▁" ▁; ▁else ▁c out ▁<< ▁start index ▁<< ▁" ▁to ▁" ▁<< ▁start index ▁+ ▁maxsize ▁- ▁1 ▁; ▁return ▁maxsize ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁} ▁; ▁int ▁size ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁find Sub Array ▁( ▁arr ▁, ▁size ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print All AP Tri pl ets ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁- ▁1 ▁, ▁k ▁= ▁i ▁+ ▁1 ▁; ▁j ▁>= ▁0 ▁&& ▁k ▁< ▁n ▁; ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁j ▁] ▁+ ▁arr ▁[ ▁k ▁] ▁== ▁2 ▁* ▁arr ▁[ ▁i ▁] ▁) ▁{ ▁c out ▁<< ▁arr ▁[ ▁j ▁] ▁<< ▁" ▁" ▁<< ▁arr ▁[ ▁i ▁] ▁<< ▁" ▁" ▁<< ▁arr ▁[ ▁k ▁] ▁<< ▁end l ▁; ▁k ▁++ ▁; ▁j ▁-- ▁; ▁} ▁else ▁if ▁( ▁arr ▁[ ▁j ▁] ▁+ ▁arr ▁[ ▁k ▁] ▁< ▁2 ▁* ▁arr ▁[ ▁i ▁] ▁) ▁k ▁++ ▁; ▁else ▁j ▁-- ▁; ▁} ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁6 ▁, ▁9 ▁, ▁12 ▁, ▁17 ▁, ▁22 ▁, ▁31 ▁, ▁32 ▁, ▁35 ▁, ▁42 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁print All AP Tri pl ets ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find Tri pl ets ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁sum ▁) ▁{ ▁int ▁i ▁; ▁sort ▁( ▁a ▁, ▁a ▁+ ▁n ▁) ▁; ▁bool ▁flag ▁= ▁false ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁== ▁0 ▁a ▁[ ▁i ▁] ▁> ▁a ▁[ ▁i ▁- ▁1 ▁] ▁) ▁{ ▁int ▁start ▁= ▁i ▁+ ▁1 ▁; ▁int ▁end ▁= ▁n ▁- ▁1 ▁; ▁int ▁target ▁= ▁sum ▁- ▁a ▁[ ▁i ▁] ▁; ▁while ▁( ▁start ▁< ▁end ▁) ▁{ ▁if ▁( ▁start ▁> ▁i ▁+ ▁1 ▁&& ▁a ▁[ ▁start ▁] ▁== ▁a ▁[ ▁start ▁- ▁1 ▁] ▁) ▁{ ▁start ▁++ ▁; ▁continue ▁; ▁} ▁if ▁( ▁end ▁< ▁n ▁- ▁1 ▁&& ▁a ▁[ ▁end ▁] ▁== ▁a ▁[ ▁end ▁+ ▁1 ▁] ▁) ▁{ ▁end ▁-- ▁; ▁continue ▁; ▁} ▁if ▁( ▁target ▁== ▁a ▁[ ▁start ▁] ▁+ ▁a ▁[ ▁end ▁] ▁) ▁{ ▁c out ▁<< ▁" ▁[ ▁" ▁<< ▁a ▁[ ▁i ▁] ▁<< ▁" ▁, ▁" ▁<< ▁a ▁[ ▁start ▁] ▁<< ▁" ▁, ▁" ▁<< ▁a ▁[ ▁end ▁] ▁<< ▁" ▁] ▁" ▁; ▁flag ▁= ▁true ▁; ▁start ▁++ ▁; ▁end ▁-- ▁; ▁} ▁else ▁if ▁( ▁target ▁> ▁( ▁a ▁[ ▁start ▁] ▁+ ▁a ▁[ ▁end ▁] ▁) ▁) ▁{ ▁start ▁++ ▁; ▁} ▁else ▁{ ▁end ▁-- ▁; ▁} ▁} ▁} ▁} ▁if ▁( ▁flag ▁== ▁false ▁) ▁{ ▁c out ▁<< ▁" ▁No ▁Such ▁Tri pl ets ▁Ex ist ▁" ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁12 ▁, ▁3 ▁, ▁6 ▁, ▁1 ▁, ▁6 ▁, ▁9 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁int ▁sum ▁= ▁24 ▁; ▁find Tri pl ets ▁( ▁a ▁, ▁n ▁, ▁sum ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Tri pl ets ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁2 ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁- ▁1 ▁; ▁j ▁++ ▁) ▁for ▁( ▁int ▁k ▁= ▁j ▁+ ▁1 ▁; ▁k ▁< ▁n ▁; ▁k ▁++ ▁) ▁if ▁( ▁arr ▁[ ▁i ▁] ▁* ▁arr ▁[ ▁j ▁] ▁* ▁arr ▁[ ▁k ▁] ▁== ▁m ▁) ▁count ▁++ ▁; ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁4 ▁, ▁6 ▁, ▁2 ▁, ▁3 ▁, ▁8 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁m ▁= ▁24 ▁; ▁c out ▁<< ▁count Tri pl ets ▁( ▁arr ▁, ▁n ▁, ▁m ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁sum of length ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁unordered _ set ▁< ▁int ▁> ▁s ▁; ▁int ▁j ▁= ▁0 ▁, ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁while ▁( ▁j ▁< ▁n ▁&& ▁s ▁. ▁find ▁( ▁arr ▁[ ▁j ▁] ▁) ▁== ▁s ▁. ▁end ▁( ▁) ▁) ▁{ ▁s ▁. ▁insert ▁( ▁arr ▁[ ▁j ▁] ▁) ▁; ▁j ▁++ ▁; ▁} ▁ans ▁+= ▁( ▁( ▁j ▁- ▁i ▁) ▁* ▁( ▁j ▁- ▁i ▁+ ▁1 ▁) ▁) ▁/ ▁2 ▁; ▁s ▁. ▁erase ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁sum of length ▁( ▁arr ▁, ▁n ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁left Rotate by One ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁temp ▁= ▁arr ▁[ ▁0 ▁] ▁, ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁arr ▁[ ▁i ▁] ▁= ▁arr ▁[ ▁i ▁+ ▁1 ▁] ▁; ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁= ▁temp ▁; ▁} ▁void ▁left Rotate ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁d ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁d ▁; ▁i ▁++ ▁) ▁left Rotate by One ▁( ▁arr ▁, ▁n ▁) ▁; ▁} ▁void ▁print Array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁, ▁7 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁left Rotate ▁( ▁arr ▁, ▁2 ▁, ▁n ▁) ▁; ▁print Array ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁search ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁l ▁, ▁int ▁h ▁, ▁int ▁key ▁) ▁{ ▁if ▁( ▁l ▁> ▁h ▁) ▁return ▁-1 ▁; ▁int ▁mid ▁= ▁( ▁l ▁+ ▁h ▁) ▁/ ▁2 ▁; ▁if ▁( ▁arr ▁[ ▁mid ▁] ▁== ▁key ▁) ▁return ▁mid ▁; ▁if ▁( ▁arr ▁[ ▁l ▁] ▁<= ▁arr ▁[ ▁mid ▁] ▁) ▁{ ▁if ▁( ▁key ▁>= ▁arr ▁[ ▁l ▁] ▁&& ▁key ▁<= ▁arr ▁[ ▁mid ▁] ▁) ▁return ▁search ▁( ▁arr ▁, ▁l ▁, ▁mid ▁- ▁1 ▁, ▁key ▁) ▁; ▁return ▁search ▁( ▁arr ▁, ▁mid ▁+ ▁1 ▁, ▁h ▁, ▁key ▁) ▁; ▁} ▁if ▁( ▁key ▁>= ▁arr ▁[ ▁mid ▁] ▁&& ▁key ▁<= ▁arr ▁[ ▁h ▁] ▁) ▁return ▁search ▁( ▁arr ▁, ▁mid ▁+ ▁1 ▁, ▁h ▁, ▁key ▁) ▁; ▁return ▁search ▁( ▁arr ▁, ▁l ▁, ▁mid ▁- ▁1 ▁, ▁key ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁5 ▁, ▁6 ▁, ▁7 ▁, ▁8 ▁, ▁9 ▁, ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁key ▁= ▁6 ▁; ▁int ▁i ▁= ▁search ▁( ▁arr ▁, ▁0 ▁, ▁n ▁- ▁1 ▁, ▁key ▁) ▁; ▁if ▁( ▁i ▁!= ▁-1 ▁) ▁c out ▁<< ▁" ▁Index ▁: ▁" ▁<< ▁i ▁<< ▁end l ▁; ▁else ▁c out ▁<< ▁" ▁Key ▁not ▁found ▁" ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁pair In Sorted Rot ated ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁x ▁) ▁{ ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁arr ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁break ▁; ▁int ▁l ▁= ▁( ▁i ▁+ ▁1 ▁) ▁% ▁n ▁; ▁int ▁r ▁= ▁i ▁; ▁while ▁( ▁l ▁!= ▁r ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁l ▁] ▁+ ▁arr ▁[ ▁r ▁] ▁== ▁x ▁) ▁return ▁true ▁; ▁if ▁( ▁arr ▁[ ▁l ▁] ▁+ ▁arr ▁[ ▁r ▁] ▁< ▁x ▁) ▁l ▁= ▁( ▁l ▁+ ▁1 ▁) ▁% ▁n ▁; ▁else ▁r ▁= ▁( ▁n ▁+ ▁r ▁- ▁1 ▁) ▁% ▁n ▁; ▁} ▁return ▁false ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁11 ▁, ▁15 ▁, ▁6 ▁, ▁8 ▁, ▁9 ▁, ▁10 ▁} ▁; ▁int ▁sum ▁= ▁16 ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁if ▁( ▁pair In Sorted Rot ated ▁( ▁arr ▁, ▁n ▁, ▁sum ▁) ▁) ▁c out ▁<< ▁" ▁Array ▁has ▁two ▁elements ▁with ▁sum ▁16 " ▁; ▁else ▁c out ▁<< ▁" ▁Array ▁doesn ▁' ▁t ▁have ▁two ▁elements ▁with ▁sum ▁16 ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁left Rotate ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁k ▁; ▁i ▁< ▁k ▁+ ▁n ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁arr ▁[ ▁i ▁% ▁n ▁] ▁<< ▁" ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁5 ▁, ▁7 ▁, ▁9 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁k ▁= ▁2 ▁; ▁left Rotate ▁( ▁arr ▁, ▁n ▁, ▁k ▁) ▁; ▁c out ▁<< ▁end l ▁; ▁k ▁= ▁3 ▁; ▁left Rotate ▁( ▁arr ▁, ▁n ▁, ▁k ▁) ▁; ▁c out ▁<< ▁end l ▁; ▁k ▁= ▁4 ▁; ▁left Rotate ▁( ▁arr ▁, ▁n ▁, ▁k ▁) ▁; ▁c out ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Min ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁low ▁, ▁int ▁high ▁) ▁{ ▁if ▁( ▁high ▁< ▁low ▁) ▁return ▁arr ▁[ ▁0 ▁] ▁; ▁if ▁( ▁high ▁== ▁low ▁) ▁return ▁arr ▁[ ▁low ▁] ▁; ▁int ▁mid ▁= ▁low ▁+ ▁( ▁high ▁- ▁low ▁) ▁/ ▁2 ▁; ▁if ▁( ▁mid ▁< ▁high ▁&& ▁arr ▁[ ▁mid ▁+ ▁1 ▁] ▁< ▁arr ▁[ ▁mid ▁] ▁) ▁return ▁arr ▁[ ▁mid ▁+ ▁1 ▁] ▁; ▁if ▁( ▁mid ▁> ▁low ▁&& ▁arr ▁[ ▁mid ▁] ▁< ▁arr ▁[ ▁mid ▁- ▁1 ▁] ▁) ▁return ▁arr ▁[ ▁mid ▁] ▁; ▁if ▁( ▁arr ▁[ ▁high ▁] ▁> ▁arr ▁[ ▁mid ▁] ▁) ▁return ▁find Min ▁( ▁arr ▁, ▁low ▁, ▁mid ▁- ▁1 ▁) ▁; ▁return ▁find Min ▁( ▁arr ▁, ▁mid ▁+ ▁1 ▁, ▁high ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr 1 ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁6 ▁, ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁n 1 ▁= ▁sizeof ▁( ▁arr 1 ▁) ▁/ ▁sizeof ▁( ▁arr 1 ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁The ▁minimum ▁element ▁is ▁" ▁<< ▁find Min ▁( ▁arr 1 ▁, ▁0 ▁, ▁n 1 ▁- ▁1 ▁) ▁<< ▁end l ▁; ▁int ▁arr 2 ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁n 2 ▁= ▁sizeof ▁( ▁arr 2 ▁) ▁/ ▁sizeof ▁( ▁arr 2 ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁The ▁minimum ▁element ▁is ▁" ▁<< ▁find Min ▁( ▁arr 2 ▁, ▁0 ▁, ▁n 2 ▁- ▁1 ▁) ▁<< ▁end l ▁; ▁int ▁arr 3 ▁[ ▁] ▁= ▁{ ▁1 ▁} ▁; ▁int ▁n 3 ▁= ▁sizeof ▁( ▁arr 3 ▁) ▁/ ▁sizeof ▁( ▁arr 3 ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁The ▁minimum ▁element ▁is ▁" ▁<< ▁find Min ▁( ▁arr 3 ▁, ▁0 ▁, ▁n 3 ▁- ▁1 ▁) ▁<< ▁end l ▁; ▁int ▁arr 4 ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁} ▁; ▁int ▁n 4 ▁= ▁sizeof ▁( ▁arr 4 ▁) ▁/ ▁sizeof ▁( ▁arr 4 ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁The ▁minimum ▁element ▁is ▁" ▁<< ▁find Min ▁( ▁arr 4 ▁, ▁0 ▁, ▁n 4 ▁-
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁split Arr ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁length ▁, ▁int ▁rotation ▁) ▁{ ▁int ▁tmp ▁[ ▁length ▁* ▁2 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁length ▁; ▁i ▁++ ▁) ▁{ ▁tmp ▁[ ▁i ▁] ▁= ▁arr ▁[ ▁i ▁] ▁; ▁tmp ▁[ ▁i ▁+ ▁length ▁] ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁rotation ▁; ▁i ▁< ▁rotation ▁+ ▁length ▁; ▁i ▁++ ▁) ▁{ ▁arr ▁[ ▁i ▁- ▁rotation ▁] ▁= ▁tmp ▁[ ▁i ▁] ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁12 ▁, ▁10 ▁, ▁5 ▁, ▁6 ▁, ▁52 ▁, ▁36 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁position ▁= ▁2 ▁; ▁split Arr ▁( ▁arr ▁, ▁n ▁, ▁position ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁printf ▁( ▁" ▁% ▁d ▁" ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print Array ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁size ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁A ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁c out ▁<< ▁end l ▁; ▁} ▁void ▁reverse ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁l ▁, ▁int ▁r ▁) ▁{ ▁if ▁( ▁l ▁< ▁r ▁) ▁{ ▁swap ▁( ▁arr ▁[ ▁l ▁] ▁, ▁arr ▁[ ▁r ▁] ▁) ▁; ▁reverse ▁( ▁arr ▁, ▁++ ▁l ▁, ▁-- ▁r ▁) ▁; ▁} ▁} ▁void ▁merge ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁l ▁, ▁int ▁m ▁, ▁int ▁r ▁) ▁{ ▁int ▁i ▁= ▁l ▁; ▁int ▁j ▁= ▁m ▁+ ▁1 ▁; ▁while ▁( ▁i ▁<= ▁m ▁&& ▁arr ▁[ ▁i ▁] ▁< ▁0 ▁) ▁i ▁++ ▁; ▁while ▁( ▁j ▁<= ▁r ▁&& ▁arr ▁[ ▁j ▁] ▁< ▁0 ▁) ▁j ▁++ ▁; ▁reverse ▁( ▁arr ▁, ▁i ▁, ▁m ▁) ▁; ▁reverse ▁( ▁arr ▁, ▁m ▁+ ▁1 ▁, ▁j ▁- ▁1 ▁) ▁; ▁reverse ▁( ▁arr ▁, ▁i ▁, ▁j ▁- ▁1 ▁) ▁; ▁} ▁void ▁R ear range Pos Neg ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁l ▁, ▁int ▁r ▁) ▁{ ▁if ▁( ▁l ▁< ▁r ▁) ▁{ ▁int ▁m ▁= ▁l ▁+ ▁( ▁r ▁- ▁l ▁) ▁/ ▁2 ▁; ▁R ear range Pos Neg ▁( ▁arr ▁, ▁l ▁, ▁m ▁) ▁; ▁R ear range Pos Neg ▁( ▁arr ▁, ▁m ▁+ ▁1 ▁, ▁r ▁) ▁; ▁merge ▁( ▁arr ▁, ▁l ▁, ▁m ▁, ▁r ▁) ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁-12 ▁, ▁11 ▁, ▁- 13 ▁, ▁-5 ▁, ▁6 ▁, ▁- 7 ▁, ▁5 ▁, ▁-3 ▁, ▁- 6 ▁} ▁; ▁int ▁arr _ size ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁R ear range Pos Neg ▁( ▁arr ▁, ▁0 ▁, ▁arr _ size ▁- ▁1 ▁) ▁; ▁print Array ▁( ▁arr ▁, ▁arr _ size ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁re arrange ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁temp ▁[ ▁n ▁] ▁; ▁int ▁small ▁= ▁0 ▁, ▁large ▁= ▁n ▁- ▁1 ▁; ▁int ▁flag ▁= ▁true ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁flag ▁) ▁temp ▁[ ▁i ▁] ▁= ▁arr ▁[ ▁large ▁-- ▁] ▁; ▁else ▁temp ▁[ ▁i ▁] ▁= ▁arr ▁[ ▁small ▁++ ▁] ▁; ▁flag ▁= ▁! ▁flag ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁arr ▁[ ▁i ▁] ▁= ▁temp ▁[ ▁i ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁Original ▁Array ▁STRNEWLINE ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁re arrange ▁( ▁arr ▁, ▁n ▁) ▁; ▁c out ▁<< ▁" ▁Modified ▁Array ▁" ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁re arrange ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁max _ ele ▁= ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁; ▁int ▁min _ ele ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁arr ▁[ ▁i ▁] ▁= ▁max _ ele ▁; ▁max _ ele ▁-= ▁1 ▁; ▁} ▁else ▁{ ▁arr ▁[ ▁i ▁] ▁= ▁min _ ele ▁; ▁min _ ele ▁+= ▁1 ▁; ▁} ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁, ▁7 ▁, ▁8 ▁, ▁9 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁Original ▁Array ▁STRNEWLINE ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁re arrange ▁( ▁arr ▁, ▁n ▁) ▁; ▁c out ▁<< ▁" ▁Modified ▁Array ▁" ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁struct ▁Node ▁{ ▁int ▁key ▁; ▁struct ▁Node ▁* ▁left ▁, ▁* ▁right ▁; ▁} ▁; ▁Node ▁* ▁newNode ▁( ▁char ▁k ▁) ▁{ ▁Node ▁* ▁node ▁= ▁new ▁Node ▁; ▁node ▁-> ▁key ▁= ▁k ▁; ▁node ▁-> ▁right ▁= ▁node ▁-> ▁left ▁= ▁NULL ▁; ▁return ▁node ▁; ▁} ▁bool ▁is Leaf ▁( ▁Node ▁* ▁node ▁) ▁{ ▁if ▁( ▁node ▁== ▁NULL ▁) ▁return ▁false ▁; ▁if ▁( ▁node ▁-> ▁left ▁== ▁NULL ▁&& ▁node ▁-> ▁right ▁== ▁NULL ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁int ▁left Le aves Sum ▁( ▁Node ▁* ▁root ▁) ▁{ ▁int ▁res ▁= ▁0 ▁; ▁if ▁( ▁root ▁!= ▁NULL ▁) ▁{ ▁if ▁( ▁is Leaf ▁( ▁root ▁-> ▁left ▁) ▁) ▁res ▁+= ▁root ▁-> ▁left ▁-> ▁key ▁; ▁else ▁res ▁+= ▁left Le aves Sum ▁( ▁root ▁-> ▁left ▁) ▁; ▁res ▁+= ▁left Le aves Sum ▁( ▁root ▁-> ▁right ▁) ▁; ▁} ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁struct ▁Node ▁* ▁root ▁= ▁newNode ▁( ▁20 ▁) ▁; ▁root ▁-> ▁left ▁= ▁newNode ▁( ▁9 ▁) ▁; ▁root ▁-> ▁right ▁= ▁newNode ▁( ▁49 ▁) ▁; ▁root ▁-> ▁right ▁-> ▁left ▁= ▁newNode ▁( ▁23 ▁) ▁; ▁root ▁-> ▁right ▁-> ▁right ▁= ▁newNode ▁( ▁52 ▁) ▁; ▁root ▁-> ▁right ▁-> ▁right ▁-> ▁left ▁= ▁newNode ▁( ▁50 ▁) ▁; ▁root ▁-> ▁left ▁-> ▁left ▁= ▁newNode ▁( ▁5 ▁) ▁; ▁root ▁-> ▁left ▁-> ▁right ▁= ▁newNode ▁( ▁12 ▁) ▁; ▁root ▁-> ▁left ▁-> ▁right ▁-> ▁right ▁= ▁newNode ▁( ▁12 ▁) ▁; ▁c out ▁<< ▁" ▁Sum ▁of ▁left ▁leaves ▁is ▁" ▁<< ▁left Le aves Sum ▁( ▁root ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁seg reg ate Elements ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁temp ▁[ ▁n ▁] ▁; ▁int ▁j ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁arr ▁[ ▁i ▁] ▁>= ▁0 ▁) ▁temp ▁[ ▁j ▁++ ▁] ▁= ▁arr ▁[ ▁i ▁] ▁; ▁if ▁( ▁j ▁== ▁n ▁j ▁== ▁0 ▁) ▁return ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁0 ▁) ▁temp ▁[ ▁j ▁++ ▁] ▁= ▁arr ▁[ ▁i ▁] ▁; ▁mem c py ▁( ▁arr ▁, ▁temp ▁, ▁sizeof ▁( ▁temp ▁) ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁-1 ▁, ▁-3 ▁, ▁-2 ▁, ▁7 ▁, ▁5 ▁, ▁11 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁seg reg ate Elements ▁( ▁arr ▁, ▁n ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁swap ▁( ▁int ▁* ▁a ▁, ▁int ▁i ▁, ▁int ▁j ▁) ▁{ ▁int ▁temp ▁= ▁a ▁[ ▁i ▁] ▁; ▁a ▁[ ▁i ▁] ▁= ▁a ▁[ ▁j ▁] ▁; ▁a ▁[ ▁j ▁] ▁= ▁temp ▁; ▁return ▁; ▁} ▁void ▁print Array ▁( ▁int ▁* ▁a ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁a ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁c out ▁<< ▁end l ▁; ▁return ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁-3 ▁, ▁5 ▁, ▁6 ▁, ▁-3 ▁, ▁6 ▁, ▁7 ▁, ▁-4 ▁, ▁9 ▁, ▁10 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁print Array ▁( ▁arr ▁, ▁n ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁>= ▁0 ▁&& ▁i ▁% ▁2 ▁== ▁1 ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁j ▁] ▁< ▁0 ▁&& ▁j ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁swap ▁( ▁arr ▁, ▁i ▁, ▁j ▁) ▁; ▁break ▁; ▁} ▁} ▁} ▁else ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁0 ▁&& ▁i ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁j ▁] ▁>= ▁0 ▁&& ▁j ▁% ▁2 ▁== ▁1 ▁) ▁{ ▁swap ▁( ▁arr ▁, ▁i ▁, ▁j ▁) ▁; ▁break ▁; ▁} ▁} ▁} ▁} ▁print Array ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁largest ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁return ▁* ▁max _ element ▁( ▁arr ▁, ▁arr ▁+ ▁n ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁3 24 ▁, ▁45 ▁, ▁90 ▁, ▁9 808 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁largest ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁double ▁find Mean ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁sum ▁+= ▁a ▁[ ▁i ▁] ▁; ▁return ▁( ▁double ▁) ▁sum ▁/ ▁( ▁double ▁) ▁n ▁; ▁} ▁double ▁find Medi an ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁sort ▁( ▁a ▁, ▁a ▁+ ▁n ▁) ▁; ▁if ▁( ▁n ▁% ▁2 ▁!= ▁0 ▁) ▁return ▁( ▁double ▁) ▁a ▁[ ▁n ▁/ ▁2 ▁] ▁; ▁return ▁( ▁double ▁) ▁( ▁a ▁[ ▁( ▁n ▁- ▁1 ▁) ▁/ ▁2 ▁] ▁+ ▁a ▁[ ▁n ▁/ ▁2 ▁] ▁) ▁/ ▁2.0 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁4 ▁, ▁2 ▁, ▁7 ▁, ▁5 ▁, ▁8 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁Mean ▁= ▁" ▁<< ▁find Mean ▁( ▁a ▁, ▁n ▁) ▁<< ▁end l ▁; ▁c out ▁<< ▁" ▁Medi an ▁= ▁" ▁<< ▁find Medi an ▁( ▁a ▁, ▁n ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print 2 l argest ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁arr _ size ▁) ▁{ ▁int ▁i ▁, ▁first ▁, ▁second ▁; ▁if ▁( ▁arr _ size ▁< ▁2 ▁) ▁{ ▁printf ▁( ▁" ▁Invalid ▁Input ▁" ▁) ▁; ▁return ▁; ▁} ▁int ▁largest ▁= ▁second ▁= ▁INT _ MIN ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁arr _ size ▁; ▁i ▁++ ▁) ▁{ ▁largest ▁= ▁max ▁( ▁largest ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁arr _ size ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁!= ▁largest ▁) ▁second ▁= ▁max ▁( ▁second ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁if ▁( ▁second ▁== ▁INT _ MIN ▁) ▁printf ▁( ▁" ▁There ▁is ▁no ▁second ▁largest ▁element ▁STRNEWLINE ▁" ▁) ▁; ▁else ▁printf ▁( ▁" ▁The ▁second ▁largest ▁element ▁is ▁% ▁d ▁STRNEWLINE ▁" ▁, ▁second ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁12 ▁, ▁35 ▁, ▁1 ▁, ▁10 ▁, ▁34 ▁, ▁1 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁print 2 l argest ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print 2 l argest ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁arr _ size ▁) ▁{ ▁int ▁i ▁, ▁first ▁, ▁second ▁; ▁if ▁( ▁arr _ size ▁< ▁2 ▁) ▁{ ▁c out ▁<< ▁" ▁Invalid ▁Input ▁" ▁; ▁return ▁; ▁} ▁first ▁= ▁second ▁= ▁INT _ MIN ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁arr _ size ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁first ▁) ▁{ ▁second ▁= ▁first ▁; ▁first ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁else ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁second ▁&& ▁arr ▁[ ▁i ▁] ▁!= ▁first ▁) ▁{ ▁second ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁} ▁if ▁( ▁second ▁== ▁INT _ MIN ▁) ▁c out ▁<< ▁" ▁There ▁is ▁no ▁second ▁largest ▁" ▁" ▁element ▁STRNEWLINE ▁" ▁; ▁else ▁c out ▁<< ▁" ▁The ▁second ▁largest ▁element ▁is ▁" ▁<< ▁second ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁12 ▁, ▁35 ▁, ▁1 ▁, ▁10 ▁, ▁34 ▁, ▁1 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁print 2 l argest ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁Find Max Sum ▁( ▁vector ▁< ▁int ▁> ▁arr ▁, ▁int ▁n ▁) ▁{ ▁int ▁incl ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁int ▁ex cl ▁= ▁0 ▁; ▁int ▁ex cl _ new ▁; ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁ex cl _ new ▁= ▁( ▁incl ▁> ▁ex cl ▁) ▁? ▁incl ▁: ▁ex cl ▁; ▁incl ▁= ▁ex cl ▁+ ▁arr ▁[ ▁i ▁] ▁; ▁ex cl ▁= ▁ex cl _ new ▁; ▁} ▁return ▁( ▁( ▁incl ▁> ▁ex cl ▁) ▁? ▁incl ▁: ▁ex cl ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁int ▁> ▁arr ▁= ▁{ ▁5 ▁, ▁5 ▁, ▁10 ▁, ▁100 ▁, ▁10 ▁, ▁5 ▁} ▁; ▁c out ▁<< ▁Find Max Sum ▁( ▁arr ▁, ▁arr ▁. ▁size ▁( ▁) ▁) ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max Sub Array Sum ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁size ▁) ▁{ ▁int ▁max _ so _ far ▁= ▁a ▁[ ▁0 ▁] ▁; ▁int ▁curr _ max ▁= ▁a ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁{ ▁curr _ max ▁= ▁max ▁( ▁a ▁[ ▁i ▁] ▁, ▁curr _ max ▁+ ▁a ▁[ ▁i ▁] ▁) ▁; ▁max _ so _ far ▁= ▁max ▁( ▁max _ so _ far ▁, ▁curr _ max ▁) ▁; ▁} ▁return ▁max _ so _ far ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁-2 ▁, ▁-3 ▁, ▁4 ▁, ▁-1 ▁, ▁-2 ▁, ▁1 ▁, ▁5 ▁, ▁-3 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁int ▁max _ sum ▁= ▁max Sub Array Sum ▁( ▁a ▁, ▁n ▁) ▁; ▁c out ▁<< ▁" ▁Maximum ▁contiguous ▁sum ▁is ▁" ▁<< ▁max _ sum ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁min J umps ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁1 ▁) ▁return ▁0 ▁; ▁int ▁res ▁= ▁INT _ MAX ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁2 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁i ▁+ ▁arr ▁[ ▁i ▁] ▁>= ▁n ▁- ▁1 ▁) ▁{ ▁int ▁sub _ res ▁= ▁min J umps ▁( ▁arr ▁, ▁i ▁+ ▁1 ▁) ▁; ▁if ▁( ▁sub _ res ▁!= ▁INT _ MAX ▁) ▁res ▁= ▁min ▁( ▁res ▁, ▁sub _ res ▁+ ▁1 ▁) ▁; ▁} ▁} ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁6 ▁, ▁3 ▁, ▁2 ▁, ▁3 ▁, ▁6 ▁, ▁8 ▁, ▁9 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁Minimum ▁number ▁of ▁jumps ▁to ▁" ▁; ▁c out ▁<< ▁" ▁reach ▁the ▁end ▁is ▁" ▁<< ▁min J umps ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max Sub Array Sum ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁size ▁) ▁{ ▁int ▁max _ so _ far ▁= ▁INT _ MIN ▁, ▁max _ ending _ here ▁= ▁0 ▁, ▁start ▁= ▁0 ▁, ▁end ▁= ▁0 ▁, ▁s ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁{ ▁max _ ending _ here ▁+= ▁a ▁[ ▁i ▁] ▁; ▁if ▁( ▁max _ so _ far ▁< ▁max _ ending _ here ▁) ▁{ ▁max _ so _ far ▁= ▁max _ ending _ here ▁; ▁start ▁= ▁s ▁; ▁end ▁= ▁i ▁; ▁} ▁if ▁( ▁max _ ending _ here ▁< ▁0 ▁) ▁{ ▁max _ ending _ here ▁= ▁0 ▁; ▁s ▁= ▁i ▁+ ▁1 ▁; ▁} ▁} ▁return ▁( ▁end ▁- ▁start ▁+ ▁1 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁-2 ▁, ▁-3 ▁, ▁4 ▁, ▁-1 ▁, ▁-2 ▁, ▁1 ▁, ▁5 ▁, ▁-3 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁max Sub Array Sum ▁( ▁a ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁sorted After Swap ▁( ▁int ▁A ▁[ ▁] ▁, ▁bool ▁B ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁i ▁, ▁j ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁B ▁[ ▁i ▁] ▁) ▁{ ▁j ▁= ▁i ▁; ▁while ▁( ▁B ▁[ ▁j ▁] ▁) ▁j ▁++ ▁; ▁sort ▁( ▁A ▁+ ▁i ▁, ▁A ▁+ ▁1 ▁+ ▁j ▁) ▁; ▁i ▁= ▁j ▁; ▁} ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁A ▁[ ▁i ▁] ▁!= ▁i ▁+ ▁1 ▁) ▁return ▁false ▁; ▁} ▁return ▁true ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁5 ▁, ▁3 ▁, ▁4 ▁, ▁6 ▁} ▁; ▁bool ▁B ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁0 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁A ▁) ▁/ ▁sizeof ▁( ▁A ▁[ ▁0 ▁] ▁) ▁; ▁if ▁( ▁sorted After Swap ▁( ▁A ▁, ▁B ▁, ▁n ▁) ▁) ▁c out ▁<< ▁" ▁A ▁can ▁be ▁sorted ▁STRNEWLINE ▁" ▁; ▁else ▁c out ▁<< ▁" ▁A ▁can ▁not ▁be ▁sorted ▁STRNEWLINE ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find NumberOf Tri angles ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁for ▁( ▁int ▁k ▁= ▁j ▁+ ▁1 ▁; ▁k ▁< ▁n ▁; ▁k ▁++ ▁) ▁if ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁arr ▁[ ▁j ▁] ▁> ▁arr ▁[ ▁k ▁] ▁&& ▁arr ▁[ ▁i ▁] ▁+ ▁arr ▁[ ▁k ▁] ▁> ▁arr ▁[ ▁j ▁] ▁&& ▁arr ▁[ ▁k ▁] ▁+ ▁arr ▁[ ▁j ▁] ▁> ▁arr ▁[ ▁i ▁] ▁) ▁count ▁++ ▁; ▁} ▁} ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁21 ▁, ▁22 ▁, ▁100 ▁, ▁101 ▁, ▁200 ▁, ▁300 ▁} ▁; ▁int ▁size ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁Total ▁number ▁of ▁triangles ▁possible ▁is ▁" ▁<< ▁find NumberOf Tri angles ▁( ▁arr ▁, ▁size ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁comp ▁( ▁const ▁void ▁* ▁a ▁, ▁const ▁void ▁* ▁b ▁) ▁{ ▁return ▁* ▁( ▁int ▁* ▁) ▁a ▁> ▁* ▁( ▁int ▁* ▁) ▁b ▁; ▁} ▁int ▁find NumberOf Tri angles ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁q sort ▁( ▁arr ▁, ▁n ▁, ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁, ▁comp ▁) ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁2 ▁; ▁++ ▁i ▁) ▁{ ▁int ▁k ▁= ▁i ▁+ ▁2 ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁++ ▁j ▁) ▁{ ▁while ▁( ▁k ▁< ▁n ▁&& ▁arr ▁[ ▁i ▁] ▁+ ▁arr ▁[ ▁j ▁] ▁> ▁arr ▁[ ▁k ▁] ▁) ▁++ ▁k ▁; ▁if ▁( ▁k ▁> ▁j ▁) ▁count ▁+= ▁k ▁- ▁j ▁- ▁1 ▁; ▁} ▁} ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁21 ▁, ▁22 ▁, ▁100 ▁, ▁101 ▁, ▁200 ▁, ▁300 ▁} ▁; ▁int ▁size ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁Total ▁number ▁of ▁triangles ▁possible ▁is ▁" ▁<< ▁find NumberOf Tri angles ▁( ▁arr ▁, ▁size ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁equ il ib ri um ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁i ▁, ▁j ▁; ▁int ▁left sum ▁, ▁right sum ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁{ ▁left sum ▁= ▁0 ▁; ▁right sum ▁= ▁0 ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁i ▁; ▁j ▁++ ▁) ▁left sum ▁+= ▁arr ▁[ ▁j ▁] ▁; ▁for ▁( ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁right sum ▁+= ▁arr ▁[ ▁j ▁] ▁; ▁if ▁( ▁left sum ▁== ▁right sum ▁) ▁return ▁i ▁; ▁} ▁return ▁-1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁- 7 ▁, ▁1 ▁, ▁5 ▁, ▁2 ▁, ▁-4 ▁, ▁3 ▁, ▁0 ▁} ▁; ▁int ▁arr _ size ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁equ il ib ri um ▁( ▁arr ▁, ▁arr _ size ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁ceil Search ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁low ▁, ▁int ▁high ▁, ▁int ▁x ▁) ▁{ ▁int ▁i ▁; ▁if ▁( ▁x ▁<= ▁arr ▁[ ▁low ▁] ▁) ▁return ▁low ▁; ▁for ▁( ▁i ▁= ▁low ▁; ▁i ▁< ▁high ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁x ▁) ▁return ▁i ▁; ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁x ▁&& ▁arr ▁[ ▁i ▁+ ▁1 ▁] ▁>= ▁x ▁) ▁return ▁i ▁+ ▁1 ▁; ▁} ▁return ▁-1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁8 ▁, ▁10 ▁, ▁10 ▁, ▁12 ▁, ▁19 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁x ▁= ▁3 ▁; ▁int ▁index ▁= ▁ceil Search ▁( ▁arr ▁, ▁0 ▁, ▁n ▁- ▁1 ▁, ▁x ▁) ▁; ▁if ▁( ▁index ▁== ▁-1 ▁) ▁c out ▁<< ▁" ▁C e iling ▁of ▁" ▁<< ▁x ▁<< ▁" ▁doesn ▁' ▁t ▁exist ▁in ▁array ▁" ▁; ▁else ▁c out ▁<< ▁" ▁ceiling ▁of ▁" ▁<< ▁x ▁<< ▁" ▁is ▁" ▁<< ▁arr ▁[ ▁index ▁] ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Candidate ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁size ▁) ▁{ ▁int ▁ma j _ index ▁= ▁0 ▁, ▁count ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁ma j _ index ▁] ▁== ▁a ▁[ ▁i ▁] ▁) ▁count ▁++ ▁; ▁else ▁count ▁-- ▁; ▁if ▁( ▁count ▁== ▁0 ▁) ▁{ ▁ma j _ index ▁= ▁i ▁; ▁count ▁= ▁1 ▁; ▁} ▁} ▁return ▁a ▁[ ▁ma j _ index ▁] ▁; ▁} ▁bool ▁is Major ity ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁size ▁, ▁int ▁cand ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁if ▁( ▁a ▁[ ▁i ▁] ▁== ▁cand ▁) ▁count ▁++ ▁; ▁if ▁( ▁count ▁> ▁size ▁/ ▁2 ▁) ▁return ▁1 ▁; ▁else ▁return ▁0 ▁; ▁} ▁void ▁print Major ity ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁size ▁) ▁{ ▁int ▁cand ▁= ▁find Candidate ▁( ▁a ▁, ▁size ▁) ▁; ▁if ▁( ▁is Major ity ▁( ▁a ▁, ▁size ▁, ▁cand ▁) ▁) ▁c out ▁<< ▁" ▁" ▁<< ▁cand ▁<< ▁" ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁M ajor ity ▁Element ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁3 ▁, ▁1 ▁, ▁2 ▁} ▁; ▁int ▁size ▁= ▁( ▁sizeof ▁( ▁a ▁) ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁print Major ity ▁( ▁a ▁, ▁size ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Root ▁( ▁pair ▁< ▁int ▁, ▁int ▁> ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁root ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁root ▁+= ▁( ▁arr ▁[ ▁i ▁] ▁. ▁first ▁- ▁arr ▁[ ▁i ▁] ▁. ▁second ▁) ▁; ▁return ▁root ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁pair ▁< ▁int ▁, ▁int ▁> ▁arr ▁[ ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁5 ▁} ▁, ▁{ ▁2 ▁, ▁0 ▁} ▁, ▁{ ▁3 ▁, ▁0 ▁} ▁, ▁{ ▁4 ▁, ▁0 ▁} ▁, ▁{ ▁5 ▁, ▁5 ▁} ▁, ▁{ ▁6 ▁, ▁5 ▁} ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁printf ▁( ▁" ▁% ▁d ▁STRNEWLINE ▁" ▁, ▁find Root ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁fill Depth ▁( ▁int ▁parent ▁[ ▁] ▁, ▁int ▁i ▁, ▁int ▁depth ▁[ ▁] ▁) ▁{ ▁if ▁( ▁depth ▁[ ▁i ▁] ▁) ▁return ▁; ▁if ▁( ▁parent ▁[ ▁i ▁] ▁== ▁-1 ▁) ▁{ ▁depth ▁[ ▁i ▁] ▁= ▁1 ▁; ▁return ▁; ▁} ▁if ▁( ▁depth ▁[ ▁parent ▁[ ▁i ▁] ▁] ▁== ▁0 ▁) ▁fill Depth ▁( ▁parent ▁, ▁parent ▁[ ▁i ▁] ▁, ▁depth ▁) ▁; ▁depth ▁[ ▁i ▁] ▁= ▁depth ▁[ ▁parent ▁[ ▁i ▁] ▁] ▁+ ▁1 ▁; ▁} ▁int ▁find Height ▁( ▁int ▁parent ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁depth ▁[ ▁n ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁depth ▁[ ▁i ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁fill Depth ▁( ▁parent ▁, ▁i ▁, ▁depth ▁) ▁; ▁int ▁ht ▁= ▁depth ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁ht ▁< ▁depth ▁[ ▁i ▁] ▁) ▁ht ▁= ▁depth ▁[ ▁i ▁] ▁; ▁return ▁ht ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁parent ▁[ ▁] ▁= ▁{ ▁-1 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁3 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁parent ▁) ▁/ ▁sizeof ▁( ▁parent ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁Height ▁is ▁" ▁<< ▁find Height ▁( ▁parent ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁getPost Order B ST ▁( ▁int ▁pre ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁pivot Point ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁pre ▁[ ▁0 ▁] ▁<= ▁pre ▁[ ▁i ▁] ▁) ▁{ ▁pivot Point ▁= ▁i ▁; ▁break ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁pivot Point ▁- ▁1 ▁; ▁i ▁> ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁c out ▁<< ▁pre ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁N ▁- ▁1 ▁; ▁i ▁>= ▁pivot Point ▁; ▁i ▁-- ▁) ▁{ ▁c out ▁<< ▁pre ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁} ▁c out ▁<< ▁pre ▁[ ▁0 ▁] ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁struct ▁Node ▁{ ▁int ▁data ▁; ▁struct ▁Node ▁* ▁left ▁, ▁* ▁right ▁; ▁} ▁; ▁int ▁min Depth ▁( ▁Node ▁* ▁root ▁) ▁{ ▁if ▁( ▁root ▁== ▁NULL ▁) ▁return ▁0 ▁; ▁if ▁( ▁root ▁-> ▁left ▁== ▁NULL ▁&& ▁root ▁-> ▁right ▁== ▁NULL ▁) ▁return ▁1 ▁; ▁int ▁l ▁= ▁INT _ MAX ▁, ▁r ▁= ▁INT _ MAX ▁; ▁if ▁( ▁root ▁-> ▁left ▁) ▁l ▁= ▁min Depth ▁( ▁root ▁-> ▁left ▁) ▁; ▁if ▁( ▁root ▁-> ▁right ▁) ▁r ▁= ▁min Depth ▁( ▁root ▁-> ▁right ▁) ▁; ▁return ▁min ▁( ▁l ▁, ▁r ▁) ▁+ ▁1 ▁; ▁} ▁Node ▁* ▁newNode ▁( ▁int ▁data ▁) ▁{ ▁Node ▁* ▁temp ▁= ▁new ▁Node ▁; ▁temp ▁-> ▁data ▁= ▁data ▁; ▁temp ▁-> ▁left ▁= ▁temp ▁-> ▁right ▁= ▁NULL ▁; ▁return ▁( ▁temp ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁Node ▁* ▁root ▁= ▁newNode ▁( ▁1 ▁) ▁; ▁root ▁-> ▁left ▁= ▁newNode ▁( ▁2 ▁) ▁; ▁root ▁-> ▁right ▁= ▁newNode ▁( ▁3 ▁) ▁; ▁root ▁-> ▁left ▁-> ▁left ▁= ▁newNode ▁( ▁4 ▁) ▁; ▁root ▁-> ▁left ▁-> ▁right ▁= ▁newNode ▁( ▁5 ▁) ▁; ▁c out ▁<< ▁" ▁The ▁minimum ▁depth ▁of ▁binary ▁tree ▁is ▁: ▁" ▁<< ▁min Depth ▁( ▁root ▁) ▁; ▁return ▁0 ▁; ▁}
▁if ▁( ▁in M ST ▁[ ▁v ▁] ▁== ▁false ▁&& ▁key ▁[ ▁v ▁] ▁> ▁weight ▁) ▁{ ▁key ▁[ ▁v ▁] ▁= ▁weight ▁; ▁pq ▁. ▁push ▁( ▁make _ pair ▁( ▁key ▁[ ▁v ▁] ▁, ▁v ▁) ▁) ▁; ▁parent ▁[ ▁v ▁] ▁= ▁u ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁size ▁4 ▁NEW _ LINE ▁bool ▁check Star ▁( ▁int ▁mat ▁[ ▁] ▁[ ▁size ▁] ▁) ▁{ ▁int ▁vertex D 1 ▁= ▁0 ▁, ▁vertex Dn _1 ▁= ▁0 ▁; ▁if ▁( ▁size ▁== ▁1 ▁) ▁return ▁( ▁mat ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁== ▁0 ▁) ▁; ▁if ▁( ▁size ▁== ▁2 ▁) ▁return ▁( ▁mat ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁== ▁0 ▁&& ▁mat ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁== ▁1 ▁&& ▁mat ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁== ▁1 ▁&& ▁mat ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁== ▁0 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁{ ▁int ▁degree I ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁size ▁; ▁j ▁++ ▁) ▁if ▁( ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁degree I ▁++ ▁; ▁if ▁( ▁degree I ▁== ▁1 ▁) ▁vertex D 1 ▁++ ▁; ▁else ▁if ▁( ▁degree I ▁== ▁size ▁- ▁1 ▁) ▁vertex Dn _1 ▁++ ▁; ▁} ▁return ▁( ▁vertex D 1 ▁== ▁( ▁size ▁- ▁1 ▁) ▁&& ▁vertex Dn _1 ▁== ▁1 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁mat ▁[ ▁size ▁] ▁[ ▁size ▁] ▁= ▁{ ▁{ ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁} ▁} ▁; ▁check Star ▁( ▁mat ▁) ▁? ▁c out ▁<< ▁" ▁Star ▁Graph ▁" ▁: ▁c out ▁<< ▁" ▁Not ▁a ▁Star ▁Graph ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁struct ▁Node ▁{ ▁int ▁data ▁; ▁struct ▁Node ▁* ▁left ▁, ▁* ▁right ▁; ▁} ▁; ▁Node ▁* ▁newNode ▁( ▁int ▁data ▁) ▁{ ▁Node ▁* ▁temp ▁= ▁new ▁Node ▁; ▁temp ▁-> ▁data ▁= ▁data ▁; ▁temp ▁-> ▁right ▁= ▁temp ▁-> ▁left ▁= ▁NULL ▁; ▁return ▁temp ▁; ▁} ▁Node ▁* ▁K th L argest Using M or ris Traversal ▁( ▁Node ▁* ▁root ▁, ▁int ▁k ▁) ▁{ ▁Node ▁* ▁curr ▁= ▁root ▁; ▁Node ▁* ▁K l argest ▁= ▁NULL ▁; ▁int ▁count ▁= ▁0 ▁; ▁while ▁( ▁curr ▁!= ▁NULL ▁) ▁{ ▁if ▁( ▁curr ▁-> ▁right ▁== ▁NULL ▁) ▁{ ▁if ▁( ▁++ ▁count ▁== ▁k ▁) ▁K l argest ▁= ▁curr ▁; ▁curr ▁= ▁curr ▁-> ▁left ▁; ▁} ▁else ▁{ ▁Node ▁* ▁succ ▁= ▁curr ▁-> ▁right ▁; ▁while ▁( ▁succ ▁-> ▁left ▁!= ▁NULL ▁&& ▁succ ▁-> ▁left ▁!= ▁curr ▁) ▁succ ▁= ▁succ ▁-> ▁left ▁; ▁if ▁( ▁succ ▁-> ▁left ▁== ▁NULL ▁) ▁{ ▁succ ▁-> ▁left ▁= ▁curr ▁; ▁curr ▁= ▁curr ▁-> ▁right ▁; ▁} ▁else ▁{ ▁succ ▁-> ▁left ▁= ▁NULL ▁; ▁if ▁( ▁++ ▁count ▁== ▁k ▁) ▁K l argest ▁= ▁curr ▁; ▁curr ▁= ▁curr ▁-> ▁left ▁; ▁} ▁} ▁} ▁return ▁K l argest ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁Node ▁* ▁root ▁= ▁newNode ▁( ▁4 ▁) ▁; ▁root ▁-> ▁left ▁= ▁newNode ▁( ▁2 ▁) ▁; ▁root ▁-> ▁right ▁= ▁newNode ▁( ▁7 ▁) ▁; ▁root ▁-> ▁left ▁-> ▁left ▁= ▁newNode ▁( ▁1 ▁) ▁; ▁root ▁-> ▁left ▁-> ▁right ▁= ▁newNode ▁( ▁3 ▁) ▁; ▁root ▁-> ▁right ▁-> ▁left ▁= ▁newNode ▁( ▁6 ▁) ▁; ▁root ▁-> ▁right ▁-> ▁right ▁= ▁newNode ▁( ▁10 ▁) ▁; ▁c out ▁<< ▁" ▁Finding ▁K ▁- ▁th ▁largest ▁Node ▁in ▁B ST ▁: ▁" ▁<< ▁K th L argest Using M or ris Traversal ▁( ▁root ▁, ▁2 ▁) ▁-> ▁data ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁class ▁TreeNode ▁{ ▁public ▁: ▁int ▁val ▁; ▁TreeNode ▁* ▁left ▁; ▁TreeNode ▁* ▁right ▁; ▁TreeNode ▁( ▁int ▁x ▁) ▁{ ▁val ▁= ▁x ▁; ▁} ▁} ▁; ▁set ▁< ▁TreeNode ▁* ▁> ▁s ▁; ▁stack ▁< ▁TreeNode ▁* ▁> ▁st ▁; ▁TreeNode ▁* ▁build Tree ▁( ▁int ▁pre order ▁[ ▁] ▁, ▁int ▁in order ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁TreeNode ▁* ▁root ▁= ▁NULL ▁; ▁for ▁( ▁int ▁pre ▁= ▁0 ▁, ▁in ▁= ▁0 ▁; ▁pre ▁< ▁n ▁; ▁) ▁{ ▁TreeNode ▁* ▁node ▁= ▁NULL ▁; ▁do ▁{ ▁node ▁= ▁new ▁TreeNode ▁( ▁pre order ▁[ ▁pre ▁] ▁) ▁; ▁if ▁( ▁root ▁== ▁NULL ▁) ▁{ ▁root ▁= ▁node ▁; ▁} ▁if ▁( ▁st ▁. ▁size ▁( ▁) ▁> ▁0 ▁) ▁{ ▁if ▁( ▁s ▁. ▁find ▁( ▁st ▁. ▁top ▁( ▁) ▁) ▁!= ▁s ▁. ▁end ▁( ▁) ▁) ▁{ ▁s ▁. ▁erase ▁( ▁st ▁. ▁top ▁( ▁) ▁) ▁; ▁st ▁. ▁top ▁( ▁) ▁-> ▁right ▁= ▁node ▁; ▁st ▁. ▁pop ▁( ▁) ▁; ▁} ▁else ▁{ ▁st ▁. ▁top ▁( ▁) ▁-> ▁left ▁= ▁node ▁; ▁} ▁} ▁st ▁. ▁push ▁( ▁node ▁) ▁; ▁} ▁while ▁( ▁pre order ▁[ ▁pre ▁++ ▁] ▁!= ▁in order ▁[ ▁in ▁] ▁&& ▁pre ▁< ▁n ▁) ▁; ▁node ▁= ▁NULL ▁; ▁while ▁( ▁st ▁. ▁size ▁( ▁) ▁> ▁0 ▁&& ▁in ▁< ▁n ▁&& ▁st ▁. ▁top ▁( ▁) ▁-> ▁val ▁== ▁in order ▁[ ▁in ▁] ▁) ▁{ ▁node ▁= ▁st ▁. ▁top ▁( ▁) ▁; ▁st ▁. ▁pop ▁( ▁) ▁; ▁in ▁++ ▁; ▁} ▁if ▁( ▁node ▁!= ▁NULL ▁) ▁{ ▁s ▁. ▁insert ▁( ▁node ▁) ▁; ▁st ▁. ▁push ▁( ▁node ▁) ▁; ▁} ▁} ▁return ▁root ▁; ▁} ▁void ▁print In order ▁( ▁TreeNode ▁* ▁node ▁) ▁{ ▁if ▁( ▁node ▁== ▁NULL ▁) ▁return ▁; ▁print In order ▁( ▁node ▁-> ▁left ▁) ▁; ▁c out ▁<< ▁node ▁-> ▁val ▁<< ▁" ▁" ▁; ▁print In order ▁( ▁node ▁-> ▁right ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁in ▁[ ▁] ▁= ▁{ ▁9 ▁, ▁8 ▁, ▁4 ▁, ▁2 ▁, ▁10 ▁, ▁5 ▁, ▁10 ▁, ▁1 ▁, ▁6 ▁, ▁3 ▁, ▁13 ▁, ▁12 ▁, ▁7 ▁} ▁;
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁struct ▁Node ▁{ ▁struct ▁Node ▁* ▁left ▁, ▁* ▁right ▁; ▁int ▁data ▁; ▁} ▁; ▁Node ▁* ▁createNode ▁( ▁int ▁x ▁) ▁{ ▁Node ▁* ▁p ▁= ▁new ▁Node ▁; ▁p ▁-> ▁data ▁= ▁x ▁; ▁p ▁-> ▁left ▁= ▁p ▁-> ▁right ▁= ▁NULL ▁; ▁return ▁p ▁; ▁} ▁void ▁insert Node ▁( ▁struct ▁Node ▁* ▁root ▁, ▁int ▁x ▁) ▁{ ▁Node ▁* ▁p ▁= ▁root ▁, ▁* ▁q ▁= ▁NULL ▁; ▁while ▁( ▁p ▁!= ▁NULL ▁) ▁{ ▁q ▁= ▁p ▁; ▁if ▁( ▁p ▁-> ▁data ▁< ▁x ▁) ▁p ▁= ▁p ▁-> ▁right ▁; ▁else ▁p ▁= ▁p ▁-> ▁left ▁; ▁} ▁if ▁( ▁q ▁== ▁NULL ▁) ▁p ▁= ▁createNode ▁( ▁x ▁) ▁; ▁else ▁{ ▁if ▁( ▁q ▁-> ▁data ▁< ▁x ▁) ▁q ▁-> ▁right ▁= ▁createNode ▁( ▁x ▁) ▁; ▁else ▁q ▁-> ▁left ▁= ▁createNode ▁( ▁x ▁) ▁; ▁} ▁} ▁int ▁max el path ▁( ▁Node ▁* ▁q ▁, ▁int ▁x ▁) ▁{ ▁Node ▁* ▁p ▁= ▁q ▁; ▁int ▁mx ▁= ▁INT _ MIN ▁; ▁while ▁( ▁p ▁-> ▁data ▁!= ▁x ▁) ▁{ ▁if ▁( ▁p ▁-> ▁data ▁> ▁x ▁) ▁{ ▁mx ▁= ▁max ▁( ▁mx ▁, ▁p ▁-> ▁data ▁) ▁; ▁p ▁= ▁p ▁-> ▁left ▁; ▁} ▁else ▁{ ▁mx ▁= ▁max ▁( ▁mx ▁, ▁p ▁-> ▁data ▁) ▁; ▁p ▁= ▁p ▁-> ▁right ▁; ▁} ▁} ▁return ▁max ▁( ▁mx ▁, ▁x ▁) ▁; ▁} ▁int ▁maximum Element ▁( ▁struct ▁Node ▁* ▁root ▁, ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁Node ▁* ▁p ▁= ▁root ▁; ▁while ▁( ▁( ▁x ▁< ▁p ▁-> ▁data ▁&& ▁y ▁< ▁p ▁-> ▁data ▁) ▁|| ▁( ▁x ▁> ▁p ▁-> ▁data ▁&& ▁y ▁> ▁p ▁-> ▁data ▁) ▁) ▁{ ▁if ▁( ▁x ▁< ▁p ▁-> ▁data ▁&& ▁y ▁< ▁p ▁-> ▁data ▁) ▁p ▁= ▁p ▁-> ▁left ▁; ▁else ▁if ▁( ▁x ▁> ▁p ▁-> ▁data ▁&& ▁y ▁> ▁p ▁-> ▁data ▁) ▁p ▁= ▁p ▁-> ▁right ▁; ▁} ▁return ▁max ▁( ▁max el path ▁( ▁p ▁, ▁x ▁) ▁, ▁max el path ▁( ▁p ▁, ▁y ▁) ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁18 ▁, ▁36 ▁, ▁9 ▁, ▁6 ▁, ▁12 ▁,
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is Leaf ▁( ▁int ▁pre ▁[ ▁] ▁, ▁int ▁& ▁i ▁, ▁int ▁n ▁, ▁int ▁min ▁, ▁int ▁max ▁) ▁{ ▁if ▁( ▁i ▁>= ▁n ▁) ▁return ▁false ▁; ▁if ▁( ▁pre ▁[ ▁i ▁] ▁> ▁min ▁&& ▁pre ▁[ ▁i ▁] ▁< ▁max ▁) ▁{ ▁i ▁++ ▁; ▁bool ▁left ▁= ▁is Leaf ▁( ▁pre ▁, ▁i ▁, ▁n ▁, ▁min ▁, ▁pre ▁[ ▁i ▁- ▁1 ▁] ▁) ▁; ▁bool ▁right ▁= ▁is Leaf ▁( ▁pre ▁, ▁i ▁, ▁n ▁, ▁pre ▁[ ▁i ▁- ▁1 ▁] ▁, ▁max ▁) ▁; ▁if ▁( ▁! ▁left ▁&& ▁! ▁right ▁) ▁c out ▁<< ▁pre ▁[ ▁i ▁- ▁1 ▁] ▁<< ▁" ▁" ▁; ▁return ▁true ▁; ▁} ▁return ▁false ▁; ▁} ▁void ▁print Le aves ▁( ▁int ▁pre order ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁i ▁= ▁0 ▁; ▁is Leaf ▁( ▁pre order ▁, ▁i ▁, ▁n ▁, ▁INT _ MIN ▁, ▁INT _ MAX ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁pre order ▁[ ▁] ▁= ▁{ ▁8 90 ▁, ▁3 25 ▁, ▁2 90 ▁, ▁5 30 ▁, ▁9 65 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁pre order ▁) ▁/ ▁sizeof ▁( ▁pre order ▁[ ▁0 ▁] ▁) ▁; ▁print Le aves ▁( ▁pre order ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁n ▁4 ▁NEW _ LINE ▁void ▁inter change First Last ▁( ▁int ▁m ▁[ ▁] ▁[ ▁n ▁] ▁) ▁{ ▁int ▁rows ▁= ▁n ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁t ▁= ▁m ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁; ▁m ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁= ▁m ▁[ ▁rows ▁- ▁1 ▁] ▁[ ▁i ▁] ▁; ▁m ▁[ ▁rows ▁- ▁1 ▁] ▁[ ▁i ▁] ▁= ▁t ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁m ▁[ ▁n ▁] ▁[ ▁n ▁] ▁= ▁{ ▁{ ▁8 ▁, ▁9 ▁, ▁7 ▁, ▁6 ▁} ▁, ▁{ ▁4 ▁, ▁7 ▁, ▁6 ▁, ▁5 ▁} ▁, ▁{ ▁3 ▁, ▁2 ▁, ▁1 ▁, ▁8 ▁} ▁, ▁{ ▁9 ▁, ▁9 ▁, ▁7 ▁, ▁7 ▁} ▁} ▁; ▁inter change First Last ▁( ▁m ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁c out ▁<< ▁m ▁[ ▁i ▁] ▁[ ▁j ▁] ▁<< ▁" ▁" ▁; ▁c out ▁<< ▁end l ▁; ▁} ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁struct ▁Node ▁{ ▁int ▁data ▁; ▁Node ▁* ▁left ▁, ▁* ▁right ▁; ▁} ▁; ▁Node ▁* ▁newNode ▁( ▁int ▁data ▁) ▁; ▁int ▁search ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁str t ▁, ▁int ▁end ▁, ▁int ▁value ▁) ▁; ▁Node ▁* ▁build Util ▁( ▁int ▁in ▁[ ▁] ▁, ▁int ▁post ▁[ ▁] ▁, ▁int ▁in Str t ▁, ▁int ▁in End ▁, ▁int ▁* ▁p Index ▁) ▁{ ▁if ▁( ▁in Str t ▁> ▁in End ▁) ▁return ▁NULL ▁; ▁Node ▁* ▁node ▁= ▁newNode ▁( ▁post ▁[ ▁* ▁p Index ▁] ▁) ▁; ▁( ▁* ▁p Index ▁) ▁-- ▁; ▁if ▁( ▁in Str t ▁== ▁in End ▁) ▁return ▁node ▁; ▁int ▁i Index ▁= ▁search ▁( ▁in ▁, ▁in Str t ▁, ▁in End ▁, ▁node ▁-> ▁data ▁) ▁; ▁node ▁-> ▁right ▁= ▁build Util ▁( ▁in ▁, ▁post ▁, ▁i Index ▁+ ▁1 ▁, ▁in End ▁, ▁p Index ▁) ▁; ▁node ▁-> ▁left ▁= ▁build Util ▁( ▁in ▁, ▁post ▁, ▁in Str t ▁, ▁i Index ▁- ▁1 ▁, ▁p Index ▁) ▁; ▁return ▁node ▁; ▁} ▁Node ▁* ▁build Tree ▁( ▁int ▁in ▁[ ▁] ▁, ▁int ▁post ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁p Index ▁= ▁n ▁- ▁1 ▁; ▁return ▁build Util ▁( ▁in ▁, ▁post ▁, ▁0 ▁, ▁n ▁- ▁1 ▁, ▁& ▁p Index ▁) ▁; ▁} ▁int ▁search ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁str t ▁, ▁int ▁end ▁, ▁int ▁value ▁) ▁{ ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁str t ▁; ▁i ▁<= ▁end ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁value ▁) ▁break ▁; ▁} ▁return ▁i ▁; ▁} ▁Node ▁* ▁newNode ▁( ▁int ▁data ▁) ▁{ ▁Node ▁* ▁node ▁= ▁( ▁Node ▁* ▁) ▁m alloc ▁( ▁sizeof ▁( ▁Node ▁) ▁) ▁; ▁node ▁-> ▁data ▁= ▁data ▁; ▁node ▁-> ▁left ▁= ▁node ▁-> ▁right ▁= ▁NULL ▁; ▁return ▁( ▁node ▁) ▁; ▁} ▁void ▁pre Order ▁( ▁Node ▁* ▁node ▁) ▁{ ▁if ▁( ▁node ▁== ▁NULL ▁) ▁return ▁; ▁printf ▁( ▁" ▁% ▁d ▁" ▁, ▁node ▁-> ▁data ▁) ▁; ▁pre Order ▁( ▁node ▁-> ▁left ▁) ▁; ▁pre Order ▁( ▁node ▁-> ▁right ▁) ▁; ▁} ▁int ▁main
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁int ▁col a ▁= ▁2 ▁, ▁row a ▁= ▁3 ▁, ▁col b ▁= ▁3 ▁, ▁row b ▁= ▁2 ▁; ▁void ▁K r one cker product ▁( ▁int ▁A ▁[ ▁] ▁[ ▁col a ▁] ▁, ▁int ▁B ▁[ ▁] ▁[ ▁col b ▁] ▁) ▁{ ▁int ▁C ▁[ ▁row a ▁* ▁row b ▁] ▁[ ▁col a ▁* ▁col b ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁row a ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁k ▁= ▁0 ▁; ▁k ▁< ▁row b ▁; ▁k ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁col a ▁; ▁j ▁++ ▁) ▁{ ▁for ▁( ▁int ▁l ▁= ▁0 ▁; ▁l ▁< ▁col b ▁; ▁l ▁++ ▁) ▁{ ▁C ▁[ ▁i ▁+ ▁l ▁+ ▁1 ▁] ▁[ ▁j ▁+ ▁k ▁+ ▁1 ▁] ▁= ▁A ▁[ ▁i ▁] ▁[ ▁j ▁] ▁* ▁B ▁[ ▁k ▁] ▁[ ▁l ▁] ▁; ▁c out ▁<< ▁C ▁[ ▁i ▁+ ▁l ▁+ ▁1 ▁] ▁[ ▁j ▁+ ▁k ▁+ ▁1 ▁] ▁<< ▁" ▁" ▁; ▁} ▁} ▁c out ▁<< ▁end l ▁; ▁} ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁[ ▁3 ▁] ▁[ ▁2 ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁} ▁, ▁{ ▁3 ▁, ▁4 ▁} ▁, ▁{ ▁1 ▁, ▁0 ▁} ▁} ▁, ▁B ▁[ ▁2 ▁] ▁[ ▁3 ▁] ▁= ▁{ ▁{ ▁0 ▁, ▁5 ▁, ▁2 ▁} ▁, ▁{ ▁6 ▁, ▁7 ▁, ▁3 ▁} ▁} ▁; ▁K r one cker product ▁( ▁A ▁, ▁B ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁if ▁( ▁n ▁+ ▁1 ▁>= ▁k ▁) ▁return ▁( ▁k ▁- ▁1 ▁) ▁; ▁else ▁return ▁( ▁2 ▁* ▁n ▁+ ▁1 ▁- ▁k ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁4 ▁, ▁k ▁= ▁7 ▁; ▁int ▁freq ▁= ▁find ▁( ▁n ▁, ▁k ▁) ▁; ▁if ▁( ▁freq ▁< ▁0 ▁) ▁c out ▁<< ▁" ▁element ▁not ▁exist ▁STRNEWLINE ▁" ▁; ▁else ▁c out ▁<< ▁" ▁Frequency ▁of ▁" ▁<< ▁k ▁<< ▁" ▁is ▁" ▁<< ▁freq ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁Identity ▁( ▁int ▁num ▁) ▁{ ▁int ▁row ▁, ▁col ▁; ▁for ▁( ▁row ▁= ▁0 ▁; ▁row ▁< ▁num ▁; ▁row ▁++ ▁) ▁{ ▁for ▁( ▁col ▁= ▁0 ▁; ▁col ▁< ▁num ▁; ▁col ▁++ ▁) ▁{ ▁if ▁( ▁row ▁== ▁col ▁) ▁c out ▁<< ▁1 ▁<< ▁" ▁" ▁; ▁else ▁c out ▁<< ▁0 ▁<< ▁" ▁" ▁; ▁} ▁c out ▁<< ▁end l ▁; ▁} ▁return ▁0 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁size ▁= ▁5 ▁; ▁Identity ▁( ▁size ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁int ▁MAX ▁= ▁100 ▁; ▁void ▁image Swap ▁( ▁int ▁mat ▁[ ▁] ▁[ ▁MAX ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁row ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁stack ▁< ▁int ▁> ▁s ▁; ▁int ▁i ▁= ▁row ▁, ▁k ▁= ▁j ▁; ▁while ▁( ▁i ▁< ▁n ▁&& ▁k ▁>= ▁0 ▁) ▁s ▁. ▁push ▁( ▁mat ▁[ ▁i ▁++ ▁] ▁[ ▁k ▁-- ▁] ▁) ▁; ▁i ▁= ▁row ▁, ▁k ▁= ▁j ▁; ▁while ▁( ▁i ▁< ▁n ▁&& ▁k ▁>= ▁0 ▁) ▁{ ▁mat ▁[ ▁i ▁++ ▁] ▁[ ▁k ▁-- ▁] ▁= ▁s ▁. ▁top ▁( ▁) ▁; ▁s ▁. ▁pop ▁( ▁) ▁; ▁} ▁} ▁int ▁column ▁= ▁n ▁- ▁1 ▁; ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁stack ▁< ▁int ▁> ▁s ▁; ▁int ▁i ▁= ▁j ▁, ▁k ▁= ▁column ▁; ▁while ▁( ▁i ▁< ▁n ▁&& ▁k ▁>= ▁0 ▁) ▁s ▁. ▁push ▁( ▁mat ▁[ ▁i ▁++ ▁] ▁[ ▁k ▁-- ▁] ▁) ▁; ▁i ▁= ▁j ▁; ▁k ▁= ▁column ▁; ▁while ▁( ▁i ▁< ▁n ▁&& ▁k ▁>= ▁0 ▁) ▁{ ▁mat ▁[ ▁i ▁++ ▁] ▁[ ▁k ▁-- ▁] ▁= ▁s ▁. ▁top ▁( ▁) ▁; ▁s ▁. ▁pop ▁( ▁) ▁; ▁} ▁} ▁} ▁void ▁print Matrix ▁( ▁int ▁mat ▁[ ▁] ▁[ ▁MAX ▁] ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁c out ▁<< ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁<< ▁" ▁" ▁; ▁c out ▁<< ▁end l ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁mat ▁[ ▁] ▁[ ▁MAX ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁, ▁{ ▁5 ▁, ▁6 ▁, ▁7 ▁, ▁8 ▁} ▁, ▁{ ▁9 ▁, ▁10 ▁, ▁11 ▁, ▁12 ▁} ▁, ▁{ ▁13 ▁, ▁14 ▁, ▁15 ▁, ▁16 ▁} ▁} ▁; ▁int ▁n ▁= ▁4 ▁; ▁image Swap ▁( ▁mat ▁, ▁n ▁) ▁; ▁print Matrix ▁( ▁mat ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁R ▁4 ▁NEW _ LINE ▁# define ▁C ▁4 ▁NEW _ LINE ▁int ▁getTotal Coverage Of Matrix ▁( ▁int ▁mat ▁[ ▁R ▁] ▁[ ▁C ▁] ▁) ▁{ ▁int ▁res ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁R ▁; ▁i ▁++ ▁) ▁{ ▁bool ▁is One ▁= ▁false ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁C ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁== ▁1 ▁) ▁is One ▁= ▁true ▁; ▁else ▁if ▁( ▁is One ▁) ▁res ▁++ ▁; ▁} ▁is One ▁= ▁false ▁; ▁for ▁( ▁int ▁j ▁= ▁C ▁- ▁1 ▁; ▁j ▁>= ▁0 ▁; ▁j ▁-- ▁) ▁{ ▁if ▁( ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁== ▁1 ▁) ▁is One ▁= ▁true ▁; ▁else ▁if ▁( ▁is One ▁) ▁res ▁++ ▁; ▁} ▁} ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁C ▁; ▁j ▁++ ▁) ▁{ ▁bool ▁is One ▁= ▁false ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁R ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁== ▁1 ▁) ▁is One ▁= ▁true ▁; ▁else ▁if ▁( ▁is One ▁) ▁res ▁++ ▁; ▁} ▁is One ▁= ▁false ▁; ▁for ▁( ▁int ▁i ▁= ▁R ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁== ▁1 ▁) ▁is One ▁= ▁true ▁; ▁else ▁if ▁( ▁is One ▁) ▁res ▁++ ▁; ▁} ▁} ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁mat ▁[ ▁R ▁] ▁[ ▁C ▁] ▁= ▁{ ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁} ▁, ▁{ ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁0 ▁} ▁, ▁{ ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁0 ▁} ▁} ▁; ▁c out ▁<< ▁getTotal Coverage Of Matrix ▁( ▁mat ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁R ▁3 ▁NEW _ LINE ▁# define ▁C ▁6 ▁NEW _ LINE ▁void ▁sp ir al Print ▁( ▁int ▁m ▁, ▁int ▁n ▁, ▁int ▁a ▁[ ▁R ▁] ▁[ ▁C ▁] ▁, ▁int ▁c ▁) ▁{ ▁int ▁i ▁, ▁k ▁= ▁0 ▁, ▁l ▁= ▁0 ▁; ▁int ▁count ▁= ▁0 ▁; ▁while ▁( ▁k ▁< ▁m ▁&& ▁l ▁< ▁n ▁) ▁{ ▁for ▁( ▁i ▁= ▁l ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁{ ▁count ▁++ ▁; ▁if ▁( ▁count ▁== ▁c ▁) ▁c out ▁<< ▁a ▁[ ▁k ▁] ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁} ▁k ▁++ ▁; ▁for ▁( ▁i ▁= ▁k ▁; ▁i ▁< ▁m ▁; ▁++ ▁i ▁) ▁{ ▁count ▁++ ▁; ▁if ▁( ▁count ▁== ▁c ▁) ▁c out ▁<< ▁a ▁[ ▁i ▁] ▁[ ▁n ▁- ▁1 ▁] ▁<< ▁" ▁" ▁; ▁} ▁n ▁-- ▁; ▁if ▁( ▁k ▁< ▁m ▁) ▁{ ▁for ▁( ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁l ▁; ▁-- ▁i ▁) ▁{ ▁count ▁++ ▁; ▁if ▁( ▁count ▁== ▁c ▁) ▁c out ▁<< ▁a ▁[ ▁m ▁- ▁1 ▁] ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁} ▁m ▁-- ▁; ▁} ▁if ▁( ▁l ▁< ▁n ▁) ▁{ ▁for ▁( ▁i ▁= ▁m ▁- ▁1 ▁; ▁i ▁>= ▁k ▁; ▁-- ▁i ▁) ▁{ ▁count ▁++ ▁; ▁if ▁( ▁count ▁== ▁c ▁) ▁c out ▁<< ▁a ▁[ ▁i ▁] ▁[ ▁l ▁] ▁<< ▁" ▁" ▁; ▁} ▁l ▁++ ▁; ▁} ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁R ▁] ▁[ ▁C ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁} ▁, ▁{ ▁7 ▁, ▁8 ▁, ▁9 ▁, ▁10 ▁, ▁11 ▁, ▁12 ▁} ▁, ▁{ ▁13 ▁, ▁14 ▁, ▁15 ▁, ▁16 ▁, ▁17 ▁, ▁18 ▁} ▁} ▁, ▁k ▁= ▁17 ▁; ▁sp ir al Print ▁( ▁R ▁, ▁C ▁, ▁a ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Negative ▁( ▁int ▁M ▁[ ▁] ▁[ ▁4 ▁] ▁, ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁m ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁M ▁[ ▁i ▁] ▁[ ▁j ▁] ▁< ▁0 ▁) ▁count ▁+= ▁1 ▁; ▁else ▁break ▁; ▁} ▁} ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁M ▁[ ▁3 ▁] ▁[ ▁4 ▁] ▁= ▁{ ▁{ ▁-3 ▁, ▁-2 ▁, ▁-1 ▁, ▁1 ▁} ▁, ▁{ ▁-2 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁, ▁{ ▁4 ▁, ▁5 ▁, ▁7 ▁, ▁8 ▁} ▁} ▁; ▁c out ▁<< ▁count Negative ▁( ▁M ▁, ▁3 ▁, ▁4 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁N ▁10 ▁NEW _ LINE ▁int ▁find L argest Plus ▁( ▁int ▁mat ▁[ ▁N ▁] ▁[ ▁N ▁] ▁) ▁{ ▁int ▁left ▁[ ▁N ▁] ▁[ ▁N ▁] ▁, ▁right ▁[ ▁N ▁] ▁[ ▁N ▁] ▁, ▁top ▁[ ▁N ▁] ▁[ ▁N ▁] ▁, ▁bottom ▁[ ▁N ▁] ▁[ ▁N ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁top ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁= ▁mat ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁; ▁bottom ▁[ ▁N ▁- ▁1 ▁] ▁[ ▁i ▁] ▁= ▁mat ▁[ ▁N ▁- ▁1 ▁] ▁[ ▁i ▁] ▁; ▁left ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁= ▁mat ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁; ▁right ▁[ ▁i ▁] ▁[ ▁N ▁- ▁1 ▁] ▁= ▁mat ▁[ ▁i ▁] ▁[ ▁N ▁- ▁1 ▁] ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁== ▁1 ▁) ▁left ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁left ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁+ ▁1 ▁; ▁else ▁left ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁0 ▁; ▁if ▁( ▁mat ▁[ ▁j ▁] ▁[ ▁i ▁] ▁== ▁1 ▁) ▁top ▁[ ▁j ▁] ▁[ ▁i ▁] ▁= ▁top ▁[ ▁j ▁- ▁1 ▁] ▁[ ▁i ▁] ▁+ ▁1 ▁; ▁else ▁top ▁[ ▁j ▁] ▁[ ▁i ▁] ▁= ▁0 ▁; ▁j ▁= ▁N ▁- ▁1 ▁- ▁j ▁; ▁if ▁( ▁mat ▁[ ▁j ▁] ▁[ ▁i ▁] ▁== ▁1 ▁) ▁bottom ▁[ ▁j ▁] ▁[ ▁i ▁] ▁= ▁bottom ▁[ ▁j ▁+ ▁1 ▁] ▁[ ▁i ▁] ▁+ ▁1 ▁; ▁else ▁bottom ▁[ ▁j ▁] ▁[ ▁i ▁] ▁= ▁0 ▁; ▁if ▁( ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁== ▁1 ▁) ▁right ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁right ▁[ ▁i ▁] ▁[ ▁j ▁+ ▁1 ▁] ▁+ ▁1 ▁; ▁else ▁right ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁0 ▁; ▁j ▁= ▁N ▁- ▁1 ▁- ▁j ▁; ▁} ▁} ▁int ▁n ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁)
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁N ▁4 ▁NEW _ LINE ▁void ▁add ▁( ▁int ▁A ▁[ ▁] ▁[ ▁N ▁] ▁, ▁int ▁B ▁[ ▁] ▁[ ▁N ▁] ▁, ▁int ▁C ▁[ ▁] ▁[ ▁N ▁] ▁) ▁{ ▁int ▁i ▁, ▁j ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁C ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁A ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+ ▁B ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁[ ▁N ▁] ▁[ ▁N ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁} ▁, ▁{ ▁2 ▁, ▁2 ▁, ▁2 ▁, ▁2 ▁} ▁, ▁{ ▁3 ▁, ▁3 ▁, ▁3 ▁, ▁3 ▁} ▁, ▁{ ▁4 ▁, ▁4 ▁, ▁4 ▁, ▁4 ▁} ▁} ▁; ▁int ▁B ▁[ ▁N ▁] ▁[ ▁N ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁} ▁, ▁{ ▁2 ▁, ▁2 ▁, ▁2 ▁, ▁2 ▁} ▁, ▁{ ▁3 ▁, ▁3 ▁, ▁3 ▁, ▁3 ▁} ▁, ▁{ ▁4 ▁, ▁4 ▁, ▁4 ▁, ▁4 ▁} ▁} ▁; ▁int ▁C ▁[ ▁N ▁] ▁[ ▁N ▁] ▁; ▁int ▁i ▁, ▁j ▁; ▁add ▁( ▁A ▁, ▁B ▁, ▁C ▁) ▁; ▁c out ▁<< ▁" ▁Result ▁matrix ▁is ▁" ▁<< ▁end l ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁c out ▁<< ▁C ▁[ ▁i ▁] ▁[ ▁j ▁] ▁<< ▁" ▁" ▁; ▁c out ▁<< ▁end l ▁; ▁} ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁N ▁4 ▁NEW _ LINE ▁void ▁subtract ▁( ▁int ▁A ▁[ ▁] ▁[ ▁N ▁] ▁, ▁int ▁B ▁[ ▁] ▁[ ▁N ▁] ▁, ▁int ▁C ▁[ ▁] ▁[ ▁N ▁] ▁) ▁{ ▁int ▁i ▁, ▁j ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁C ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁A ▁[ ▁i ▁] ▁[ ▁j ▁] ▁- ▁B ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁[ ▁N ▁] ▁[ ▁N ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁} ▁, ▁{ ▁2 ▁, ▁2 ▁, ▁2 ▁, ▁2 ▁} ▁, ▁{ ▁3 ▁, ▁3 ▁, ▁3 ▁, ▁3 ▁} ▁, ▁{ ▁4 ▁, ▁4 ▁, ▁4 ▁, ▁4 ▁} ▁} ▁; ▁int ▁B ▁[ ▁N ▁] ▁[ ▁N ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁} ▁, ▁{ ▁2 ▁, ▁2 ▁, ▁2 ▁, ▁2 ▁} ▁, ▁{ ▁3 ▁, ▁3 ▁, ▁3 ▁, ▁3 ▁} ▁, ▁{ ▁4 ▁, ▁4 ▁, ▁4 ▁, ▁4 ▁} ▁} ▁; ▁int ▁C ▁[ ▁N ▁] ▁[ ▁N ▁] ▁; ▁int ▁i ▁, ▁j ▁; ▁subtract ▁( ▁A ▁, ▁B ▁, ▁C ▁) ▁; ▁c out ▁<< ▁" ▁Result ▁matrix ▁is ▁" ▁<< ▁end l ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁c out ▁<< ▁C ▁[ ▁i ▁] ▁[ ▁j ▁] ▁<< ▁" ▁" ▁; ▁c out ▁<< ▁end l ▁; ▁} ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Peak Util ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁low ▁, ▁int ▁high ▁, ▁int ▁n ▁) ▁{ ▁int ▁mid ▁= ▁low ▁+ ▁( ▁high ▁- ▁low ▁) ▁/ ▁2 ▁; ▁if ▁( ▁( ▁mid ▁== ▁0 ▁arr ▁[ ▁mid ▁- ▁1 ▁] ▁<= ▁arr ▁[ ▁mid ▁] ▁) ▁&& ▁( ▁mid ▁== ▁n ▁- ▁1 ▁arr ▁[ ▁mid ▁+ ▁1 ▁] ▁<= ▁arr ▁[ ▁mid ▁] ▁) ▁) ▁return ▁mid ▁; ▁else ▁if ▁( ▁mid ▁> ▁0 ▁&& ▁arr ▁[ ▁mid ▁- ▁1 ▁] ▁> ▁arr ▁[ ▁mid ▁] ▁) ▁return ▁find Peak Util ▁( ▁arr ▁, ▁low ▁, ▁( ▁mid ▁- ▁1 ▁) ▁, ▁n ▁) ▁; ▁else ▁return ▁find Peak Util ▁( ▁arr ▁, ▁( ▁mid ▁+ ▁1 ▁) ▁, ▁high ▁, ▁n ▁) ▁; ▁} ▁int ▁find Peak ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁return ▁find Peak Util ▁( ▁arr ▁, ▁0 ▁, ▁n ▁- ▁1 ▁, ▁n ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁20 ▁, ▁4 ▁, ▁1 ▁, ▁0 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁Index ▁of ▁a ▁peak ▁point ▁is ▁" ▁<< ▁find Peak ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print Repe ating ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁size ▁) ▁{ ▁int ▁i ▁, ▁j ▁; ▁printf ▁( ▁" ▁Re pe ating ▁elements ▁are ▁" ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁for ▁( ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁size ▁; ▁j ▁++ ▁) ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁arr ▁[ ▁j ▁] ▁) ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁2 ▁, ▁4 ▁, ▁5 ▁, ▁2 ▁, ▁3 ▁, ▁1 ▁} ▁; ▁int ▁arr _ size ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁print Repe ating ▁( ▁arr ▁, ▁arr _ size ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁fact ▁( ▁int ▁n ▁) ▁; ▁void ▁print Repe ating ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁size ▁) ▁{ ▁int ▁S ▁= ▁0 ▁; ▁int ▁P ▁= ▁1 ▁; ▁int ▁x ▁, ▁y ▁; ▁int ▁D ▁; ▁int ▁n ▁= ▁size ▁- ▁2 ▁, ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁{ ▁S ▁= ▁S ▁+ ▁arr ▁[ ▁i ▁] ▁; ▁P ▁= ▁P ▁* ▁arr ▁[ ▁i ▁] ▁; ▁} ▁S ▁= ▁S ▁- ▁n ▁* ▁( ▁n ▁+ ▁1 ▁) ▁/ ▁2 ▁; ▁P ▁= ▁P ▁/ ▁fact ▁( ▁n ▁) ▁; ▁D ▁= ▁sqrt ▁( ▁S ▁* ▁S ▁- ▁4 ▁* ▁P ▁) ▁; ▁x ▁= ▁( ▁D ▁+ ▁S ▁) ▁/ ▁2 ▁; ▁y ▁= ▁( ▁S ▁- ▁D ▁) ▁/ ▁2 ▁; ▁c out ▁<< ▁" ▁The ▁two ▁Re pe ating ▁elements ▁are ▁" ▁<< ▁x ▁<< ▁" ▁& ▁" ▁<< ▁y ▁; ▁} ▁int ▁fact ▁( ▁int ▁n ▁) ▁{ ▁return ▁( ▁n ▁== ▁0 ▁) ▁? ▁1 ▁: ▁n ▁* ▁fact ▁( ▁n ▁- ▁1 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁2 ▁, ▁4 ▁, ▁5 ▁, ▁2 ▁, ▁3 ▁, ▁1 ▁} ▁; ▁int ▁arr _ size ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁print Repe ating ▁( ▁arr ▁, ▁arr _ size ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print Repe ating ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁size ▁) ▁{ ▁int ▁X or ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁int ▁set _ bit _ no ▁; ▁int ▁i ▁; ▁int ▁n ▁= ▁size ▁- ▁2 ▁; ▁int ▁x ▁= ▁0 ▁, ▁y ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁X or ▁^= ▁arr ▁[ ▁i ▁] ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁X or ▁^= ▁i ▁; ▁set _ bit _ no ▁= ▁X or ▁& ▁~ ▁( ▁X or ▁- ▁1 ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁& ▁set _ bit _ no ▁) ▁x ▁= ▁x ▁^ ▁arr ▁[ ▁i ▁] ▁; ▁else ▁y ▁= ▁y ▁^ ▁arr ▁[ ▁i ▁] ▁; ▁} ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁& ▁set _ bit _ no ▁) ▁x ▁= ▁x ▁^ ▁i ▁; ▁else ▁y ▁= ▁y ▁^ ▁i ▁; ▁} ▁c out ▁<< ▁" ▁The ▁two ▁repeating ▁elements ▁are ▁" ▁<< ▁y ▁<< ▁" ▁" ▁<< ▁x ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁2 ▁, ▁4 ▁, ▁5 ▁, ▁2 ▁, ▁3 ▁, ▁1 ▁} ▁; ▁int ▁arr _ size ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁print Repe ating ▁( ▁arr ▁, ▁arr _ size ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁linear Search ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁i ▁) ▁return ▁i ▁; ▁} ▁return ▁-1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁-10 ▁, ▁-1 ▁, ▁0 ▁, ▁3 ▁, ▁10 ▁, ▁11 ▁, ▁30 ▁, ▁50 ▁, ▁100 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁Fixed ▁Point ▁is ▁" ▁<< ▁linear Search ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁sub Array Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁sum ▁) ▁{ ▁int ▁curr _ sum ▁= ▁arr ▁[ ▁0 ▁] ▁, ▁start ▁= ▁0 ▁, ▁i ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁while ▁( ▁curr _ sum ▁> ▁sum ▁&& ▁start ▁< ▁i ▁- ▁1 ▁) ▁{ ▁curr _ sum ▁= ▁curr _ sum ▁- ▁arr ▁[ ▁start ▁] ▁; ▁start ▁++ ▁; ▁} ▁if ▁( ▁curr _ sum ▁== ▁sum ▁) ▁{ ▁c out ▁<< ▁" ▁Sum ▁found ▁between ▁indexes ▁" ▁<< ▁start ▁<< ▁" ▁and ▁" ▁<< ▁i ▁- ▁1 ▁; ▁return ▁1 ▁; ▁} ▁if ▁( ▁i ▁< ▁n ▁) ▁curr _ sum ▁= ▁curr _ sum ▁+ ▁arr ▁[ ▁i ▁] ▁; ▁} ▁c out ▁<< ▁" ▁No ▁sub array ▁found ▁" ▁; ▁return ▁0 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁15 ▁, ▁2 ▁, ▁4 ▁, ▁8 ▁, ▁9 ▁, ▁5 ▁, ▁10 ▁, ▁23 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁sum ▁= ▁23 ▁; ▁sub Array Sum ▁( ▁arr ▁, ▁n ▁, ▁sum ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁maximum ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁int ▁c ▁) ▁{ ▁return ▁max ▁( ▁max ▁( ▁a ▁, ▁b ▁) ▁, ▁c ▁) ▁; ▁} ▁int ▁minimum ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁int ▁c ▁) ▁{ ▁return ▁min ▁( ▁min ▁( ▁a ▁, ▁b ▁) ▁, ▁c ▁) ▁; ▁} ▁void ▁smallest Difference Tri plet ▁( ▁int ▁arr 1 ▁[ ▁] ▁, ▁int ▁arr 2 ▁[ ▁] ▁, ▁int ▁arr 3 ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁sort ▁( ▁arr 1 ▁, ▁arr 1 ▁+ ▁n ▁) ▁; ▁sort ▁( ▁arr 2 ▁, ▁arr 2 ▁+ ▁n ▁) ▁; ▁sort ▁( ▁arr 3 ▁, ▁arr 3 ▁+ ▁n ▁) ▁; ▁int ▁res _ min ▁, ▁res _ max ▁, ▁res _ mid ▁; ▁int ▁i ▁= ▁0 ▁, ▁j ▁= ▁0 ▁, ▁k ▁= ▁0 ▁; ▁int ▁diff ▁= ▁INT _ MAX ▁; ▁while ▁( ▁i ▁< ▁n ▁&& ▁j ▁< ▁n ▁&& ▁k ▁< ▁n ▁) ▁{ ▁int ▁sum ▁= ▁arr 1 ▁[ ▁i ▁] ▁+ ▁arr 2 ▁[ ▁j ▁] ▁+ ▁arr 3 ▁[ ▁k ▁] ▁; ▁int ▁max ▁= ▁maximum ▁( ▁arr 1 ▁[ ▁i ▁] ▁, ▁arr 2 ▁[ ▁j ▁] ▁, ▁arr 3 ▁[ ▁k ▁] ▁) ▁; ▁int ▁min ▁= ▁minimum ▁( ▁arr 1 ▁[ ▁i ▁] ▁, ▁arr 2 ▁[ ▁j ▁] ▁, ▁arr 3 ▁[ ▁k ▁] ▁) ▁; ▁if ▁( ▁min ▁== ▁arr 1 ▁[ ▁i ▁] ▁) ▁i ▁++ ▁; ▁else ▁if ▁( ▁min ▁== ▁arr 2 ▁[ ▁j ▁] ▁) ▁j ▁++ ▁; ▁else ▁k ▁++ ▁; ▁if ▁( ▁diff ▁> ▁( ▁max ▁- ▁min ▁) ▁) ▁{ ▁diff ▁= ▁max ▁- ▁min ▁; ▁res _ max ▁= ▁max ▁; ▁res _ mid ▁= ▁sum ▁- ▁( ▁max ▁+ ▁min ▁) ▁; ▁res _ min ▁= ▁min ▁; ▁} ▁} ▁c out ▁<< ▁res _ max ▁<< ▁" ▁, ▁" ▁<< ▁res _ mid ▁<< ▁" ▁, ▁" ▁<< ▁res _ min ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr 1 ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁2 ▁, ▁8 ▁} ▁; ▁int ▁arr 2 ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁7 ▁, ▁12 ▁} ▁; ▁int ▁arr 3 ▁[ ▁] ▁= ▁{ ▁9 ▁, ▁14 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁find 3 Numbers ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁arr _ size ▁, ▁int ▁sum ▁) ▁{ ▁int ▁l ▁, ▁r ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁arr _ size ▁- ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁arr _ size ▁- ▁1 ▁; ▁j ▁++ ▁) ▁{ ▁for ▁( ▁int ▁k ▁= ▁j ▁+ ▁1 ▁; ▁k ▁< ▁arr _ size ▁; ▁k ▁++ ▁) ▁{ ▁if ▁( ▁A ▁[ ▁i ▁] ▁+ ▁A ▁[ ▁j ▁] ▁+ ▁A ▁[ ▁k ▁] ▁== ▁sum ▁) ▁{ ▁c out ▁<< ▁" ▁Tri plet ▁is ▁" ▁<< ▁A ▁[ ▁i ▁] ▁<< ▁" ▁, ▁" ▁<< ▁A ▁[ ▁j ▁] ▁<< ▁" ▁, ▁" ▁<< ▁A ▁[ ▁k ▁] ▁; ▁return ▁true ▁; ▁} ▁} ▁} ▁} ▁return ▁false ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁4 ▁, ▁45 ▁, ▁6 ▁, ▁10 ▁, ▁8 ▁} ▁; ▁int ▁sum ▁= ▁22 ▁; ▁int ▁arr _ size ▁= ▁sizeof ▁( ▁A ▁) ▁/ ▁sizeof ▁( ▁A ▁[ ▁0 ▁] ▁) ▁; ▁find 3 Numbers ▁( ▁A ▁, ▁arr _ size ▁, ▁sum ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁sub Array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁for ▁( ▁int ▁k ▁= ▁i ▁; ▁k ▁<= ▁j ▁; ▁k ▁++ ▁) ▁c out ▁<< ▁arr ▁[ ▁k ▁] ▁<< ▁" ▁" ▁; ▁c out ▁<< ▁end l ▁; ▁} ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁All ▁Non ▁- ▁empty ▁Sub arrays ▁STRNEWLINE ▁" ▁; ▁sub Array ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< std io . h > ▁NEW _ LINE ▁# include ▁< std lib . h > ▁NEW _ LINE ▁int ▁getMin ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁; ▁int ▁getMax ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁; ▁bool ▁are Con secutive ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁< ▁1 ▁) ▁return ▁false ▁; ▁int ▁min ▁= ▁getMin ▁( ▁arr ▁, ▁n ▁) ▁; ▁int ▁max ▁= ▁getMax ▁( ▁arr ▁, ▁n ▁) ▁; ▁if ▁( ▁max ▁- ▁min ▁+ ▁1 ▁== ▁n ▁) ▁{ ▁bool ▁* ▁visited ▁= ▁( ▁bool ▁* ▁) ▁cal loc ▁( ▁n ▁, ▁sizeof ▁( ▁bool ▁) ▁) ▁; ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁visited ▁[ ▁arr ▁[ ▁i ▁] ▁- ▁min ▁] ▁!= ▁false ▁) ▁return ▁false ▁; ▁visited ▁[ ▁arr ▁[ ▁i ▁] ▁- ▁min ▁] ▁= ▁true ▁; ▁} ▁return ▁true ▁; ▁} ▁return ▁false ▁; ▁} ▁int ▁getMin ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁min ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁min ▁) ▁min ▁= ▁arr ▁[ ▁i ▁] ▁; ▁return ▁min ▁; ▁} ▁int ▁getMax ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁max ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁max ▁) ▁max ▁= ▁arr ▁[ ▁i ▁] ▁; ▁return ▁max ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁4 ▁, ▁2 ▁, ▁3 ▁, ▁1 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁if ▁( ▁are Con secutive ▁( ▁arr ▁, ▁n ▁) ▁== ▁true ▁) ▁printf ▁( ▁" ▁Array ▁elements ▁are ▁consecutive ▁" ▁) ▁; ▁else ▁printf ▁( ▁" ▁Array ▁elements ▁are ▁not ▁consecutive ▁" ▁) ▁; ▁get char ▁( ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁search ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁x ▁) ▁{ ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁x ▁) ▁return ▁i ▁; ▁return ▁-1 ▁; ▁} ▁int ▁main ▁( ▁void ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁10 ▁, ▁40 ▁} ▁; ▁int ▁x ▁= ▁10 ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁result ▁= ▁search ▁( ▁arr ▁, ▁n ▁, ▁x ▁) ▁; ▁( ▁result ▁== ▁-1 ▁) ▁? ▁c out ▁<< ▁" ▁Element ▁is ▁not ▁present ▁in ▁array ▁" ▁: ▁c out ▁<< ▁" ▁Element ▁is ▁present ▁at ▁index ▁" ▁<< ▁result ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁binarySearch ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁l ▁, ▁int ▁r ▁, ▁int ▁x ▁) ▁{ ▁if ▁( ▁r ▁>= ▁l ▁) ▁{ ▁int ▁mid ▁= ▁l ▁+ ▁( ▁r ▁- ▁l ▁) ▁/ ▁2 ▁; ▁if ▁( ▁arr ▁[ ▁mid ▁] ▁== ▁x ▁) ▁return ▁mid ▁; ▁if ▁( ▁arr ▁[ ▁mid ▁] ▁> ▁x ▁) ▁return ▁binarySearch ▁( ▁arr ▁, ▁l ▁, ▁mid ▁- ▁1 ▁, ▁x ▁) ▁; ▁return ▁binarySearch ▁( ▁arr ▁, ▁mid ▁+ ▁1 ▁, ▁r ▁, ▁x ▁) ▁; ▁} ▁return ▁-1 ▁; ▁} ▁int ▁main ▁( ▁void ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁10 ▁, ▁40 ▁} ▁; ▁int ▁x ▁= ▁10 ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁result ▁= ▁binarySearch ▁( ▁arr ▁, ▁0 ▁, ▁n ▁- ▁1 ▁, ▁x ▁) ▁; ▁( ▁result ▁== ▁-1 ▁) ▁? ▁c out ▁<< ▁" ▁Element ▁is ▁not ▁present ▁in ▁array ▁" ▁: ▁c out ▁<< ▁" ▁Element ▁is ▁present ▁at ▁index ▁" ▁<< ▁result ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁# include ▁< string . h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁R ANGE ▁255 ▁NEW _ LINE ▁void ▁count Sort ▁( ▁char ▁arr ▁[ ▁] ▁) ▁{ ▁char ▁output ▁[ ▁str len ▁( ▁arr ▁) ▁] ▁; ▁int ▁count ▁[ ▁R ANGE ▁+ ▁1 ▁] ▁, ▁i ▁; ▁mem set ▁( ▁count ▁, ▁0 ▁, ▁sizeof ▁( ▁count ▁) ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁arr ▁[ ▁i ▁] ▁; ▁++ ▁i ▁) ▁++ ▁count ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁<= ▁R ANGE ▁; ▁++ ▁i ▁) ▁count ▁[ ▁i ▁] ▁+= ▁count ▁[ ▁i ▁- ▁1 ▁] ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁arr ▁[ ▁i ▁] ▁; ▁++ ▁i ▁) ▁{ ▁output ▁[ ▁count ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁- ▁1 ▁] ▁= ▁arr ▁[ ▁i ▁] ▁; ▁-- ▁count ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁arr ▁[ ▁i ▁] ▁; ▁++ ▁i ▁) ▁arr ▁[ ▁i ▁] ▁= ▁output ▁[ ▁i ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁char ▁arr ▁[ ▁] ▁= ▁" ▁g eek s forge ek s ▁" ▁; ▁count Sort ▁( ▁arr ▁) ▁; ▁c out ▁<< ▁" ▁Sorted ▁character ▁array ▁is ▁" ▁<< ▁arr ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< algorithm > ▁NEW _ LINE ▁# include ▁< i ost ream > ▁NEW _ LINE ▁# include ▁< vector > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁count Sort ▁( ▁vector ▁< ▁int ▁> ▁& ▁arr ▁) ▁{ ▁int ▁max ▁= ▁* ▁max _ element ▁( ▁arr ▁. ▁begin ▁( ▁) ▁, ▁arr ▁. ▁end ▁( ▁) ▁) ▁; ▁int ▁min ▁= ▁* ▁min _ element ▁( ▁arr ▁. ▁begin ▁( ▁) ▁, ▁arr ▁. ▁end ▁( ▁) ▁) ▁; ▁int ▁range ▁= ▁max ▁- ▁min ▁+ ▁1 ▁; ▁vector ▁< ▁int ▁> ▁count ▁( ▁range ▁) ▁, ▁output ▁( ▁arr ▁. ▁size ▁( ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁arr ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁count ▁[ ▁arr ▁[ ▁i ▁] ▁- ▁min ▁] ▁++ ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁count ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁count ▁[ ▁i ▁] ▁+= ▁count ▁[ ▁i ▁- ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁arr ▁. ▁size ▁( ▁) ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁output ▁[ ▁count ▁[ ▁arr ▁[ ▁i ▁] ▁- ▁min ▁] ▁- ▁1 ▁] ▁= ▁arr ▁[ ▁i ▁] ▁; ▁count ▁[ ▁arr ▁[ ▁i ▁] ▁- ▁min ▁] ▁-- ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁arr ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁arr ▁[ ▁i ▁] ▁= ▁output ▁[ ▁i ▁] ▁; ▁} ▁void ▁print Array ▁( ▁vector ▁< ▁int ▁> ▁& ▁arr ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁arr ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁c out ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁int ▁> ▁arr ▁= ▁{ ▁-5 ▁, ▁-10 ▁, ▁0 ▁, ▁-3 ▁, ▁8 ▁, ▁5 ▁, ▁-1 ▁, ▁10 ▁} ▁; ▁count Sort ▁( ▁arr ▁) ▁; ▁print Array ▁( ▁arr ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁cycle Sort ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁writes ▁= ▁0 ▁; ▁for ▁( ▁int ▁cycle _ start ▁= ▁0 ▁; ▁cycle _ start ▁<= ▁n ▁- ▁2 ▁; ▁cycle _ start ▁++ ▁) ▁{ ▁int ▁item ▁= ▁arr ▁[ ▁cycle _ start ▁] ▁; ▁int ▁pos ▁= ▁cycle _ start ▁; ▁for ▁( ▁int ▁i ▁= ▁cycle _ start ▁+ ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁item ▁) ▁pos ▁++ ▁; ▁if ▁( ▁pos ▁== ▁cycle _ start ▁) ▁continue ▁; ▁while ▁( ▁item ▁== ▁arr ▁[ ▁pos ▁] ▁) ▁pos ▁+= ▁1 ▁; ▁if ▁( ▁pos ▁!= ▁cycle _ start ▁) ▁{ ▁swap ▁( ▁item ▁, ▁arr ▁[ ▁pos ▁] ▁) ▁; ▁writes ▁++ ▁; ▁} ▁while ▁( ▁pos ▁!= ▁cycle _ start ▁) ▁{ ▁pos ▁= ▁cycle _ start ▁; ▁for ▁( ▁int ▁i ▁= ▁cycle _ start ▁+ ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁item ▁) ▁pos ▁+= ▁1 ▁; ▁while ▁( ▁item ▁== ▁arr ▁[ ▁pos ▁] ▁) ▁pos ▁+= ▁1 ▁; ▁if ▁( ▁item ▁!= ▁arr ▁[ ▁pos ▁] ▁) ▁{ ▁swap ▁( ▁item ▁, ▁arr ▁[ ▁pos ▁] ▁) ▁; ▁writes ▁++ ▁; ▁} ▁} ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁8 ▁, ▁3 ▁, ▁9 ▁, ▁10 ▁, ▁10 ▁, ▁2 ▁, ▁4 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁cycle Sort ▁( ▁arr ▁, ▁n ▁) ▁; ▁c out ▁<< ▁" ▁After ▁sort ▁: ▁" ▁<< ▁end l ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁# include ▁< cl imits > ▁NEW _ LINE ▁# include ▁< c std lib > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print Clo sest ▁( ▁int ▁ar 1 ▁[ ▁] ▁, ▁int ▁ar 2 ▁[ ▁] ▁, ▁int ▁m ▁, ▁int ▁n ▁, ▁int ▁x ▁) ▁{ ▁int ▁diff ▁= ▁INT _ MAX ▁; ▁int ▁res _ l ▁, ▁res _ r ▁; ▁int ▁l ▁= ▁0 ▁, ▁r ▁= ▁n ▁- ▁1 ▁; ▁while ▁( ▁l ▁< ▁m ▁&& ▁r ▁>= ▁0 ▁) ▁{ ▁if ▁( ▁abs ▁( ▁ar 1 ▁[ ▁l ▁] ▁+ ▁ar 2 ▁[ ▁r ▁] ▁- ▁x ▁) ▁< ▁diff ▁) ▁{ ▁res _ l ▁= ▁l ▁; ▁res _ r ▁= ▁r ▁; ▁diff ▁= ▁abs ▁( ▁ar 1 ▁[ ▁l ▁] ▁+ ▁ar 2 ▁[ ▁r ▁] ▁- ▁x ▁) ▁; ▁} ▁if ▁( ▁ar 1 ▁[ ▁l ▁] ▁+ ▁ar 2 ▁[ ▁r ▁] ▁> ▁x ▁) ▁r ▁-- ▁; ▁else ▁l ▁++ ▁; ▁} ▁c out ▁<< ▁" ▁The ▁closest ▁pair ▁is ▁[ ▁" ▁<< ▁ar 1 ▁[ ▁res _ l ▁] ▁<< ▁" ▁, ▁" ▁<< ▁ar 2 ▁[ ▁res _ r ▁] ▁<< ▁" ▁] ▁STRNEWLINE ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁ar 1 ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁4 ▁, ▁5 ▁, ▁7 ▁} ▁; ▁int ▁ar 2 ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁20 ▁, ▁30 ▁, ▁40 ▁} ▁; ▁int ▁m ▁= ▁sizeof ▁( ▁ar 1 ▁) ▁/ ▁sizeof ▁( ▁ar 1 ▁[ ▁0 ▁] ▁) ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁ar 2 ▁) ▁/ ▁sizeof ▁( ▁ar 2 ▁[ ▁0 ▁] ▁) ▁; ▁int ▁x ▁= ▁38 ▁; ▁print Clo sest ▁( ▁ar 1 ▁, ▁ar 2 ▁, ▁m ▁, ▁n ▁, ▁x ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print Max Activities ▁( ▁int ▁s ▁[ ▁] ▁, ▁int ▁f ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁i ▁, ▁j ▁; ▁c out ▁<< ▁" ▁Following ▁activities ▁are ▁selected ▁" ▁<< ▁end l ▁; ▁i ▁= ▁0 ▁; ▁c out ▁<< ▁" ▁" ▁<< ▁i ▁; ▁for ▁( ▁j ▁= ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁s ▁[ ▁j ▁] ▁>= ▁f ▁[ ▁i ▁] ▁) ▁{ ▁c out ▁<< ▁" ▁" ▁<< ▁j ▁; ▁i ▁= ▁j ▁; ▁} ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁s ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁0 ▁, ▁5 ▁, ▁8 ▁, ▁5 ▁} ▁; ▁int ▁f ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁4 ▁, ▁6 ▁, ▁7 ▁, ▁9 ▁, ▁9 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁s ▁) ▁/ ▁sizeof ▁( ▁s ▁[ ▁0 ▁] ▁) ▁; ▁print Max Activities ▁( ▁s ▁, ▁f ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁bin omial Co eff ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁if ▁( ▁k ▁> ▁n ▁) ▁return ▁0 ▁; ▁if ▁( ▁k ▁== ▁0 ▁k ▁== ▁n ▁) ▁return ▁1 ▁; ▁return ▁bin omial Co eff ▁( ▁n ▁- ▁1 ▁, ▁k ▁- ▁1 ▁) ▁+ ▁bin omial Co eff ▁( ▁n ▁- ▁1 ▁, ▁k ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁5 ▁, ▁k ▁= ▁2 ▁; ▁c out ▁<< ▁" ▁Value ▁of ▁C ▁( ▁" ▁<< ▁n ▁<< ▁" ▁, ▁" ▁<< ▁k ▁<< ▁" ▁) ▁is ▁" ▁<< ▁bin omial Co eff ▁( ▁n ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< std io . h > ▁NEW _ LINE ▁int ▁getCount ▁( ▁char ▁key pad ▁[ ▁] ▁[ ▁3 ▁] ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁key pad ▁== ▁NULL ▁n ▁<= ▁0 ▁) ▁return ▁0 ▁; ▁if ▁( ▁n ▁== ▁1 ▁) ▁return ▁10 ▁; ▁int ▁row ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁0 ▁, ▁-1 ▁, ▁0 ▁, ▁1 ▁} ▁; ▁int ▁col ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁-1 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁} ▁; ▁int ▁count ▁[ ▁10 ▁] ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁int ▁i ▁= ▁0 ▁, ▁j ▁= ▁0 ▁, ▁k ▁= ▁0 ▁, ▁move ▁= ▁0 ▁, ▁ro ▁= ▁0 ▁, ▁co ▁= ▁0 ▁, ▁num ▁= ▁0 ▁; ▁int ▁next Num ▁= ▁0 ▁, ▁totalCount ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁<= ▁9 ▁; ▁i ▁++ ▁) ▁{ ▁count ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁count ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁= ▁1 ▁; ▁} ▁for ▁( ▁k ▁= ▁2 ▁; ▁k ▁<= ▁n ▁; ▁k ▁++ ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁4 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁3 ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁key pad ▁[ ▁i ▁] ▁[ ▁j ▁] ▁!= ▁' ▁* ▁' ▁&& ▁key pad ▁[ ▁i ▁] ▁[ ▁j ▁] ▁!= ▁' ▁# ▁' ▁) ▁{ ▁num ▁= ▁key pad ▁[ ▁i ▁] ▁[ ▁j ▁] ▁- ▁'0' ▁; ▁count ▁[ ▁num ▁] ▁[ ▁k ▁] ▁= ▁0 ▁; ▁for ▁( ▁move ▁= ▁0 ▁; ▁move ▁< ▁5 ▁; ▁move ▁++ ▁) ▁{ ▁ro ▁= ▁i ▁+ ▁row ▁[ ▁move ▁] ▁; ▁co ▁= ▁j ▁+ ▁col ▁[ ▁move ▁] ▁; ▁if ▁( ▁ro ▁>= ▁0 ▁&& ▁ro ▁<= ▁3 ▁&& ▁co ▁>= ▁0 ▁&& ▁co ▁<= ▁2 ▁&& ▁key pad ▁[ ▁ro ▁] ▁[ ▁co ▁] ▁!= ▁' ▁* ▁' ▁&& ▁key pad ▁[ ▁ro ▁] ▁[ ▁co ▁] ▁!= ▁' ▁# ▁' ▁) ▁{ ▁next Num ▁= ▁key pad ▁[ ▁ro ▁] ▁[ ▁co ▁] ▁- ▁'0' ▁; ▁count ▁[ ▁num ▁] ▁[ ▁k ▁] ▁+= ▁count ▁[ ▁next Num ▁] ▁[ ▁k ▁- ▁1 ▁] ▁; ▁} ▁} ▁} ▁} ▁} ▁} ▁totalCount ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁<= ▁9 ▁; ▁i ▁++ ▁) ▁totalCount ▁+= ▁count ▁[ ▁i
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁unsigned ▁long ▁long ▁int ▁count Rec ▁( ▁int ▁n ▁, ▁int ▁sum ▁) ▁{ ▁if ▁( ▁n ▁== ▁0 ▁) ▁return ▁sum ▁== ▁0 ▁; ▁if ▁( ▁sum ▁== ▁0 ▁) ▁return ▁1 ▁; ▁unsigned ▁long ▁long ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁9 ▁; ▁i ▁++ ▁) ▁if ▁( ▁sum ▁- ▁i ▁>= ▁0 ▁) ▁ans ▁+= ▁count Rec ▁( ▁n ▁- ▁1 ▁, ▁sum ▁- ▁i ▁) ▁; ▁return ▁ans ▁; ▁} ▁unsigned ▁long ▁long ▁int ▁final Count ▁( ▁int ▁n ▁, ▁int ▁sum ▁) ▁{ ▁unsigned ▁long ▁long ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁9 ▁; ▁i ▁++ ▁) ▁if ▁( ▁sum ▁- ▁i ▁>= ▁0 ▁) ▁ans ▁+= ▁count Rec ▁( ▁n ▁- ▁1 ▁, ▁sum ▁- ▁i ▁) ▁; ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁2 ▁, ▁sum ▁= ▁5 ▁; ▁c out ▁<< ▁final Count ▁( ▁n ▁, ▁sum ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find Count ▁( ▁int ▁n ▁, ▁int ▁sum ▁) ▁{ ▁int ▁start ▁= ▁pow ▁( ▁10 ▁, ▁n ▁- ▁1 ▁) ▁; ▁int ▁end ▁= ▁pow ▁( ▁10 ▁, ▁n ▁) ▁- ▁1 ▁; ▁int ▁count ▁= ▁0 ▁; ▁int ▁i ▁= ▁start ▁; ▁while ▁( ▁i ▁<= ▁end ▁) ▁{ ▁int ▁cur ▁= ▁0 ▁; ▁int ▁temp ▁= ▁i ▁; ▁while ▁( ▁temp ▁!= ▁0 ▁) ▁{ ▁cur ▁+= ▁temp ▁% ▁10 ▁; ▁temp ▁= ▁temp ▁/ ▁10 ▁; ▁} ▁if ▁( ▁cur ▁== ▁sum ▁) ▁{ ▁count ▁++ ▁; ▁i ▁+= ▁9 ▁; ▁} ▁else ▁i ▁++ ▁; ▁} ▁c out ▁<< ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁3 ▁; ▁int ▁sum ▁= ▁5 ▁; ▁find Count ▁( ▁n ▁, ▁sum ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁getMin Square s ▁( ▁unsigned ▁int ▁n ▁) ▁{ ▁if ▁( ▁sqrt ▁( ▁n ▁) ▁- ▁floor ▁( ▁sqrt ▁( ▁n ▁) ▁) ▁== ▁0 ▁) ▁return ▁1 ▁; ▁if ▁( ▁n ▁<= ▁3 ▁) ▁return ▁n ▁; ▁int ▁res ▁= ▁n ▁; ▁for ▁( ▁int ▁x ▁= ▁1 ▁; ▁x ▁<= ▁n ▁; ▁x ▁++ ▁) ▁{ ▁int ▁temp ▁= ▁x ▁* ▁x ▁; ▁if ▁( ▁temp ▁> ▁n ▁) ▁break ▁; ▁else ▁res ▁= ▁min ▁( ▁res ▁, ▁1 ▁+ ▁getMin Square s ▁( ▁n ▁- ▁temp ▁) ▁) ▁; ▁} ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁c out ▁<< ▁getMin Square s ▁( ▁6 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁sum Of Digits From 1 To N Util ▁( ▁int ▁n ▁, ▁int ▁a ▁[ ▁] ▁) ▁{ ▁if ▁( ▁n ▁< ▁10 ▁) ▁return ▁( ▁n ▁* ▁( ▁n ▁+ ▁1 ▁) ▁/ ▁2 ▁) ▁; ▁int ▁d ▁= ▁( ▁int ▁) ▁( ▁log 10 ▁( ▁n ▁) ▁) ▁; ▁int ▁p ▁= ▁( ▁int ▁) ▁( ▁ceil ▁( ▁pow ▁( ▁10 ▁, ▁d ▁) ▁) ▁) ▁; ▁int ▁ms d ▁= ▁n ▁/ ▁p ▁; ▁return ▁( ▁ms d ▁* ▁a ▁[ ▁d ▁] ▁+ ▁( ▁ms d ▁* ▁( ▁ms d ▁- ▁1 ▁) ▁/ ▁2 ▁) ▁* ▁p ▁+ ▁ms d ▁* ▁( ▁1 ▁+ ▁n ▁% ▁p ▁) ▁+ ▁sum Of Digits From 1 To N Util ▁( ▁n ▁% ▁p ▁, ▁a ▁) ▁) ▁; ▁} ▁int ▁sum Of Digits From 1 To N ▁( ▁int ▁n ▁) ▁{ ▁int ▁d ▁= ▁( ▁int ▁) ▁( ▁log 10 ▁( ▁n ▁) ▁) ▁; ▁int ▁a ▁[ ▁d ▁+ ▁1 ▁] ▁; ▁a ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁a ▁[ ▁1 ▁] ▁= ▁45 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁d ▁; ▁i ▁++ ▁) ▁a ▁[ ▁i ▁] ▁= ▁a ▁[ ▁i ▁- ▁1 ▁] ▁* ▁10 ▁+ ▁45 ▁* ▁( ▁int ▁) ▁( ▁ceil ▁( ▁pow ▁( ▁10 ▁, ▁i ▁- ▁1 ▁) ▁) ▁) ▁; ▁return ▁sum Of Digits From 1 To N Util ▁( ▁n ▁, ▁a ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁3 28 ▁; ▁c out ▁<< ▁" ▁Sum ▁of ▁digits ▁in ▁numbers ▁from ▁1 ▁to ▁" ▁<< ▁n ▁<< ▁" ▁is ▁" ▁<< ▁sum Of Digits From 1 To N ▁( ▁n ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find opt imal ▁( ▁int ▁N ▁) ▁{ ▁if ▁( ▁N ▁<= ▁6 ▁) ▁return ▁N ▁; ▁int ▁max ▁= ▁0 ▁; ▁int ▁b ▁; ▁for ▁( ▁b ▁= ▁N ▁- ▁3 ▁; ▁b ▁>= ▁1 ▁; ▁b ▁-- ▁) ▁{ ▁int ▁curr ▁= ▁( ▁N ▁- ▁b ▁- ▁1 ▁) ▁* ▁find opt imal ▁( ▁b ▁) ▁; ▁if ▁( ▁curr ▁> ▁max ▁) ▁max ▁= ▁curr ▁; ▁} ▁return ▁max ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁; ▁for ▁( ▁N ▁= ▁1 ▁; ▁N ▁<= ▁20 ▁; ▁N ▁++ ▁) ▁c out ▁<< ▁" ▁Maximum ▁Number ▁of ▁A ▁' ▁s ▁with ▁" ▁<< ▁N ▁<< ▁" ▁key st rokes ▁is ▁" ▁<< ▁find opt imal ▁( ▁N ▁) ▁<< ▁end l ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁search ▁( ▁string ▁pat ▁, ▁string ▁txt ▁) ▁{ ▁int ▁M ▁= ▁pat ▁. ▁size ▁( ▁) ▁; ▁int ▁N ▁= ▁txt ▁. ▁size ▁( ▁) ▁; ▁int ▁i ▁= ▁0 ▁; ▁while ▁( ▁i ▁<= ▁N ▁- ▁M ▁) ▁{ ▁int ▁j ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁M ▁; ▁j ▁++ ▁) ▁if ▁( ▁txt ▁[ ▁i ▁+ ▁j ▁] ▁!= ▁pat ▁[ ▁j ▁] ▁) ▁break ▁; ▁if ▁( ▁j ▁== ▁M ▁) ▁{ ▁c out ▁<< ▁" ▁Pattern ▁found ▁at ▁index ▁" ▁<< ▁i ▁<< ▁end l ▁; ▁i ▁= ▁i ▁+ ▁M ▁; ▁} ▁else ▁if ▁( ▁j ▁== ▁0 ▁) ▁i ▁= ▁i ▁+ ▁1 ▁; ▁else ▁i ▁= ▁i ▁+ ▁j ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁txt ▁= ▁" ▁AB CE AB CD AB CE AB CD ▁" ▁; ▁string ▁pat ▁= ▁" ▁AB CD ▁" ▁; ▁search ▁( ▁pat ▁, ▁txt ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁float ▁power ▁( ▁float ▁x ▁, ▁int ▁y ▁) ▁{ ▁float ▁temp ▁; ▁if ▁( ▁y ▁== ▁0 ▁) ▁return ▁1 ▁; ▁temp ▁= ▁power ▁( ▁x ▁, ▁y ▁/ ▁2 ▁) ▁; ▁if ▁( ▁y ▁% ▁2 ▁== ▁0 ▁) ▁return ▁temp ▁* ▁temp ▁; ▁else ▁{ ▁if ▁( ▁y ▁> ▁0 ▁) ▁return ▁x ▁* ▁temp ▁* ▁temp ▁; ▁else ▁return ▁( ▁temp ▁* ▁temp ▁) ▁/ ▁x ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁float ▁x ▁= ▁2 ▁; ▁int ▁y ▁= ▁-3 ▁; ▁c out ▁<< ▁power ▁( ▁x ▁, ▁y ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁getM edi an ▁( ▁int ▁ar 1 ▁[ ▁] ▁, ▁int ▁ar 2 ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁i ▁= ▁0 ▁; ▁int ▁j ▁= ▁0 ▁; ▁int ▁count ▁; ▁int ▁m 1 ▁= ▁-1 ▁, ▁m 2 ▁= ▁-1 ▁; ▁for ▁( ▁count ▁= ▁0 ▁; ▁count ▁<= ▁n ▁; ▁count ▁++ ▁) ▁{ ▁if ▁( ▁i ▁== ▁n ▁) ▁{ ▁m 1 ▁= ▁m 2 ▁; ▁m 2 ▁= ▁ar 2 ▁[ ▁0 ▁] ▁; ▁break ▁; ▁} ▁else ▁if ▁( ▁j ▁== ▁n ▁) ▁{ ▁m 1 ▁= ▁m 2 ▁; ▁m 2 ▁= ▁ar 1 ▁[ ▁0 ▁] ▁; ▁break ▁; ▁} ▁if ▁( ▁ar 1 ▁[ ▁i ▁] ▁<= ▁ar 2 ▁[ ▁j ▁] ▁) ▁{ ▁m 1 ▁= ▁m 2 ▁; ▁m 2 ▁= ▁ar 1 ▁[ ▁i ▁] ▁; ▁i ▁++ ▁; ▁} ▁else ▁{ ▁m 1 ▁= ▁m 2 ▁; ▁m 2 ▁= ▁ar 2 ▁[ ▁j ▁] ▁; ▁j ▁++ ▁; ▁} ▁} ▁return ▁( ▁m 1 ▁+ ▁m 2 ▁) ▁/ ▁2 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁ar 1 ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁12 ▁, ▁15 ▁, ▁26 ▁, ▁38 ▁} ▁; ▁int ▁ar 2 ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁13 ▁, ▁17 ▁, ▁30 ▁, ▁45 ▁} ▁; ▁int ▁n 1 ▁= ▁sizeof ▁( ▁ar 1 ▁) ▁/ ▁sizeof ▁( ▁ar 1 ▁[ ▁0 ▁] ▁) ▁; ▁int ▁n 2 ▁= ▁sizeof ▁( ▁ar 2 ▁) ▁/ ▁sizeof ▁( ▁ar 2 ▁[ ▁0 ▁] ▁) ▁; ▁if ▁( ▁n 1 ▁== ▁n 2 ▁) ▁c out ▁<< ▁" ▁Medi an ▁is ▁" ▁<< ▁getM edi an ▁( ▁ar 1 ▁, ▁ar 2 ▁, ▁n 1 ▁) ▁; ▁else ▁c out ▁<< ▁" ▁Doesn ▁' ▁t ▁work ▁for ▁arrays ▁" ▁<< ▁" ▁of ▁un equal ▁size ▁" ▁; ▁get char ▁( ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁class ▁g fg ▁{ ▁public ▁: ▁float ▁square Root ▁( ▁float ▁n ▁) ▁{ ▁float ▁x ▁= ▁n ▁; ▁float ▁y ▁= ▁1 ▁; ▁float ▁e ▁= ▁0. 000001 ▁; ▁while ▁( ▁x ▁- ▁y ▁> ▁e ▁) ▁{ ▁x ▁= ▁( ▁x ▁+ ▁y ▁) ▁/ ▁2 ▁; ▁y ▁= ▁n ▁/ ▁x ▁; ▁} ▁return ▁x ▁; ▁} ▁} ▁; ▁int ▁main ▁( ▁) ▁{ ▁g fg ▁g ▁; ▁int ▁n ▁= ▁50 ▁; ▁c out ▁<< ▁" ▁Square ▁root ▁of ▁" ▁<< ▁n ▁<< ▁" ▁is ▁" ▁<< ▁g ▁. ▁square Root ▁( ▁n ▁) ▁; ▁get char ▁( ▁) ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁class ▁G F G ▁{ ▁public ▁: ▁int ▁multiply ▁( ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁if ▁( ▁y ▁== ▁0 ▁) ▁return ▁0 ▁; ▁if ▁( ▁y ▁> ▁0 ▁) ▁return ▁( ▁x ▁+ ▁multiply ▁( ▁x ▁, ▁y ▁- ▁1 ▁) ▁) ▁; ▁if ▁( ▁y ▁< ▁0 ▁) ▁return ▁- ▁multiply ▁( ▁x ▁, ▁- ▁y ▁) ▁; ▁} ▁} ▁; ▁int ▁main ▁( ▁) ▁{ ▁G F G ▁g ▁; ▁c out ▁<< ▁end l ▁<< ▁g ▁. ▁multiply ▁( ▁5 ▁, ▁- 11 ▁) ▁; ▁get char ▁( ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁pow ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁if ▁( ▁b ▁== ▁0 ▁) ▁return ▁1 ▁; ▁int ▁answer ▁= ▁a ▁; ▁int ▁increment ▁= ▁a ▁; ▁int ▁i ▁, ▁j ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁b ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁j ▁= ▁1 ▁; ▁j ▁< ▁a ▁; ▁j ▁++ ▁) ▁{ ▁answer ▁+= ▁increment ▁; ▁} ▁increment ▁= ▁answer ▁; ▁} ▁return ▁answer ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁c out ▁<< ▁pow ▁( ▁5 ▁, ▁3 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁multiply ▁( ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁if ▁( ▁y ▁) ▁return ▁( ▁x ▁+ ▁multiply ▁( ▁x ▁, ▁y ▁- ▁1 ▁) ▁) ▁; ▁else ▁return ▁0 ▁; ▁} ▁int ▁pow ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁if ▁( ▁b ▁) ▁return ▁multiply ▁( ▁a ▁, ▁pow ▁( ▁a ▁, ▁b ▁- ▁1 ▁) ▁) ▁; ▁else ▁return ▁1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁c out ▁<< ▁pow ▁( ▁5 ▁, ▁3 ▁) ▁; ▁get char ▁( ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁float ▁getAv g ▁( ▁int ▁x ▁) ▁{ ▁static ▁int ▁sum ▁, ▁n ▁; ▁sum ▁+= ▁x ▁; ▁return ▁( ▁( ▁( ▁float ▁) ▁sum ▁) ▁/ ▁++ ▁n ▁) ▁; ▁} ▁void ▁stream Avg ▁( ▁float ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁float ▁avg ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁avg ▁= ▁getAv g ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁c out ▁<< ▁" ▁Average ▁of ▁" ▁<< ▁i ▁+ ▁1 ▁<< ▁" ▁numbers ▁is ▁" ▁<< ▁fixed ▁<< ▁set precision ▁( ▁1 ▁) ▁<< ▁avg ▁<< ▁end l ▁; ▁} ▁return ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁float ▁arr ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁20 ▁, ▁30 ▁, ▁40 ▁, ▁50 ▁, ▁60 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁stream Avg ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁< ▁3 ▁) ▁return ▁n ▁; ▁if ▁( ▁n ▁>= ▁3 ▁&& ▁n ▁< ▁10 ▁) ▁return ▁n ▁- ▁1 ▁; ▁int ▁po ▁= ▁1 ▁; ▁while ▁( ▁n ▁/ ▁po ▁> ▁9 ▁) ▁po ▁= ▁po ▁* ▁10 ▁; ▁int ▁ms d ▁= ▁n ▁/ ▁po ▁; ▁if ▁( ▁ms d ▁!= ▁3 ▁) ▁return ▁count ▁( ▁ms d ▁) ▁* ▁count ▁( ▁po ▁- ▁1 ▁) ▁+ ▁count ▁( ▁ms d ▁) ▁+ ▁count ▁( ▁n ▁% ▁po ▁) ▁; ▁else ▁return ▁count ▁( ▁ms d ▁* ▁po ▁- ▁1 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁c out ▁<< ▁count ▁( ▁5 78 ▁) ▁<< ▁" ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print P as cal ▁( ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁line ▁= ▁1 ▁; ▁line ▁<= ▁n ▁; ▁line ▁++ ▁) ▁{ ▁int ▁C ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁line ▁; ▁i ▁++ ▁) ▁{ ▁c out ▁<< ▁C ▁<< ▁" ▁" ▁; ▁C ▁= ▁C ▁* ▁( ▁line ▁- ▁i ▁) ▁/ ▁i ▁; ▁} ▁c out ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁5 ▁; ▁print P as cal ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁combination Util ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁data ▁[ ▁] ▁, ▁int ▁start ▁, ▁int ▁end ▁, ▁int ▁index ▁, ▁int ▁r ▁) ▁; ▁void ▁print Comb ination ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁r ▁) ▁{ ▁int ▁data ▁[ ▁r ▁] ▁; ▁combination Util ▁( ▁arr ▁, ▁data ▁, ▁0 ▁, ▁n ▁- ▁1 ▁, ▁0 ▁, ▁r ▁) ▁; ▁} ▁void ▁combination Util ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁data ▁[ ▁] ▁, ▁int ▁start ▁, ▁int ▁end ▁, ▁int ▁index ▁, ▁int ▁r ▁) ▁{ ▁if ▁( ▁index ▁== ▁r ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁r ▁; ▁j ▁++ ▁) ▁c out ▁<< ▁data ▁[ ▁j ▁] ▁<< ▁" ▁" ▁; ▁c out ▁<< ▁end l ▁; ▁return ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁start ▁; ▁i ▁<= ▁end ▁&& ▁end ▁- ▁i ▁+ ▁1 ▁>= ▁r ▁- ▁index ▁; ▁i ▁++ ▁) ▁{ ▁data ▁[ ▁index ▁] ▁= ▁arr ▁[ ▁i ▁] ▁; ▁combination Util ▁( ▁arr ▁, ▁data ▁, ▁i ▁+ ▁1 ▁, ▁end ▁, ▁index ▁+ ▁1 ▁, ▁r ▁) ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁r ▁= ▁3 ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁print Comb ination ▁( ▁arr ▁, ▁n ▁, ▁r ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find groups ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁c ▁[ ▁3 ▁] ▁= ▁{ ▁0 ▁} ▁, ▁i ▁; ▁int ▁res ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁c ▁[ ▁arr ▁[ ▁i ▁] ▁% ▁3 ▁] ▁++ ▁; ▁res ▁+= ▁( ▁( ▁c ▁[ ▁0 ▁] ▁* ▁( ▁c ▁[ ▁0 ▁] ▁- ▁1 ▁) ▁) ▁>> ▁1 ▁) ▁; ▁res ▁+= ▁c ▁[ ▁1 ▁] ▁* ▁c ▁[ ▁2 ▁] ▁; ▁res ▁+= ▁( ▁c ▁[ ▁0 ▁] ▁* ▁( ▁c ▁[ ▁0 ▁] ▁- ▁1 ▁) ▁* ▁( ▁c ▁[ ▁0 ▁] ▁- ▁2 ▁) ▁) ▁/ ▁6 ▁; ▁res ▁+= ▁( ▁c ▁[ ▁1 ▁] ▁* ▁( ▁c ▁[ ▁1 ▁] ▁- ▁1 ▁) ▁* ▁( ▁c ▁[ ▁1 ▁] ▁- ▁2 ▁) ▁) ▁/ ▁6 ▁; ▁res ▁+= ▁( ▁( ▁c ▁[ ▁2 ▁] ▁* ▁( ▁c ▁[ ▁2 ▁] ▁- ▁1 ▁) ▁* ▁( ▁c ▁[ ▁2 ▁] ▁- ▁2 ▁) ▁) ▁/ ▁6 ▁) ▁; ▁res ▁+= ▁c ▁[ ▁0 ▁] ▁* ▁c ▁[ ▁1 ▁] ▁* ▁c ▁[ ▁2 ▁] ▁; ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁6 ▁, ▁7 ▁, ▁2 ▁, ▁9 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁Required ▁number ▁of ▁groups ▁are ▁" ▁<< ▁find groups ▁( ▁arr ▁, ▁n ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁min ▁( ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁return ▁( ▁x ▁< ▁y ▁) ▁? ▁x ▁: ▁y ▁; ▁} ▁int ▁calc Angle ▁( ▁double ▁h ▁, ▁double ▁m ▁) ▁{ ▁if ▁( ▁h ▁< ▁0 ▁m ▁< ▁0 ▁h ▁> ▁12 ▁m ▁> ▁60 ▁) ▁printf ▁( ▁" ▁Wrong ▁input ▁" ▁) ▁; ▁if ▁( ▁h ▁== ▁12 ▁) ▁h ▁= ▁0 ▁; ▁if ▁( ▁m ▁== ▁60 ▁) ▁{ ▁m ▁= ▁0 ▁; ▁h ▁+= ▁1 ▁; ▁if ▁( ▁h ▁> ▁12 ▁) ▁h ▁= ▁h ▁- ▁12 ▁; ▁} ▁float ▁hour _ angle ▁= ▁0.5 ▁* ▁( ▁h ▁* ▁60 ▁+ ▁m ▁) ▁; ▁float ▁minute _ angle ▁= ▁6 ▁* ▁m ▁; ▁float ▁angle ▁= ▁abs ▁( ▁hour _ angle ▁- ▁minute _ angle ▁) ▁; ▁angle ▁= ▁min ▁( ▁360 ▁- ▁angle ▁, ▁angle ▁) ▁; ▁return ▁angle ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁c out ▁<< ▁calc Angle ▁( ▁9 ▁, ▁60 ▁) ▁<< ▁end l ▁; ▁c out ▁<< ▁calc Angle ▁( ▁3 ▁, ▁30 ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< cm ath > ▁NEW _ LINE ▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find ▁( ▁double ▁p ▁) ▁{ ▁return ▁ceil ▁( ▁sqrt ▁( ▁2 ▁* ▁365 ▁* ▁log ▁( ▁1 ▁/ ▁( ▁1 ▁- ▁p ▁) ▁) ▁) ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁c out ▁<< ▁find ▁( ▁0. 70 ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁MAX _ ITER ▁1000000 ▁NEW _ LINE ▁double ▁func ▁( ▁double ▁x ▁) ▁{ ▁return ▁x ▁* ▁x ▁* ▁x ▁- ▁x ▁* ▁x ▁+ ▁2 ▁; ▁} ▁void ▁reg ula F al si ▁( ▁double ▁a ▁, ▁double ▁b ▁) ▁{ ▁if ▁( ▁func ▁( ▁a ▁) ▁* ▁func ▁( ▁b ▁) ▁>= ▁0 ▁) ▁{ ▁c out ▁<< ▁" ▁You ▁have ▁not ▁assumed ▁right ▁a ▁and ▁b ▁STRNEWLINE ▁" ▁; ▁return ▁; ▁} ▁double ▁c ▁= ▁a ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁MAX _ ITER ▁; ▁i ▁++ ▁) ▁{ ▁c ▁= ▁( ▁a ▁* ▁func ▁( ▁b ▁) ▁- ▁b ▁* ▁func ▁( ▁a ▁) ▁) ▁/ ▁( ▁func ▁( ▁b ▁) ▁- ▁func ▁( ▁a ▁) ▁) ▁; ▁if ▁( ▁func ▁( ▁c ▁) ▁== ▁0 ▁) ▁break ▁; ▁else ▁if ▁( ▁func ▁( ▁c ▁) ▁* ▁func ▁( ▁a ▁) ▁< ▁0 ▁) ▁b ▁= ▁c ▁; ▁else ▁a ▁= ▁c ▁; ▁} ▁c out ▁<< ▁" ▁The ▁value ▁of ▁root ▁is ▁: ▁" ▁<< ▁c ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁double ▁a ▁= ▁- 200 ▁, ▁b ▁= ▁300 ▁; ▁reg ula F al si ▁( ▁a ▁, ▁b ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁swap Bits ▁( ▁unsigned ▁int ▁x ▁, ▁unsigned ▁int ▁p 1 ▁, ▁unsigned ▁int ▁p 2 ▁, ▁unsigned ▁int ▁n ▁) ▁{ ▁unsigned ▁int ▁set 1 ▁= ▁( ▁x ▁>> ▁p 1 ▁) ▁& ▁( ▁( ▁1 U ▁<< ▁n ▁) ▁- ▁1 ▁) ▁; ▁unsigned ▁int ▁set 2 ▁= ▁( ▁x ▁>> ▁p 2 ▁) ▁& ▁( ▁( ▁1 U ▁<< ▁n ▁) ▁- ▁1 ▁) ▁; ▁unsigned ▁int ▁X or ▁= ▁( ▁set 1 ▁^ ▁set 2 ▁) ▁; ▁X or ▁= ▁( ▁X or ▁<< ▁p 1 ▁) ▁| ▁( ▁X or ▁<< ▁p 2 ▁) ▁; ▁unsigned ▁int ▁result ▁= ▁x ▁^ ▁X or ▁; ▁return ▁result ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁res ▁= ▁swap Bits ▁( ▁28 ▁, ▁0 ▁, ▁3 ▁, ▁2 ▁) ▁; ▁c out ▁<< ▁" ▁Result ▁= ▁" ▁<< ▁res ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁fun ▁( ▁unsigned ▁int ▁n ▁) ▁{ ▁return ▁n ▁& ▁( ▁n ▁- ▁1 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁7 ▁; ▁c out ▁<< ▁" ▁The ▁number ▁after ▁un setting ▁the ▁" ▁; ▁c out ▁<< ▁" ▁right most ▁set ▁bit ▁" ▁<< ▁fun ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is Power Of Four ▁( ▁unsigned ▁int ▁n ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁if ▁( ▁n ▁&& ▁! ▁( ▁n ▁& ▁( ▁n ▁- ▁1 ▁) ▁) ▁) ▁{ ▁while ▁( ▁n ▁> ▁1 ▁) ▁{ ▁n ▁>>= ▁1 ▁; ▁count ▁+= ▁1 ▁; ▁} ▁return ▁( ▁count ▁% ▁2 ▁== ▁0 ▁) ▁? ▁1 ▁: ▁0 ▁; ▁} ▁return ▁0 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁test _ no ▁= ▁64 ▁; ▁if ▁( ▁is Power Of Four ▁( ▁test _ no ▁) ▁) ▁c out ▁<< ▁test _ no ▁<< ▁" ▁is ▁a ▁power ▁of ▁4" ▁; ▁else ▁c out ▁<< ▁test _ no ▁<< ▁" ▁is ▁not ▁a ▁power ▁of ▁4" ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁class ▁g fg ▁{ ▁public ▁: ▁int ▁min ▁( ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁return ▁y ▁^ ▁( ▁( ▁x ▁^ ▁y ▁) ▁& ▁- ▁( ▁x ▁< ▁y ▁) ▁) ▁; ▁} ▁int ▁max ▁( ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁return ▁x ▁^ ▁( ▁( ▁x ▁^ ▁y ▁) ▁& ▁- ▁( ▁x ▁< ▁y ▁) ▁) ▁; ▁} ▁} ▁; ▁int ▁main ▁( ▁) ▁{ ▁g fg ▁g ▁; ▁int ▁x ▁= ▁15 ▁; ▁int ▁y ▁= ▁6 ▁; ▁c out ▁<< ▁" ▁Minimum ▁of ▁" ▁<< ▁x ▁<< ▁" ▁and ▁" ▁<< ▁y ▁<< ▁" ▁is ▁" ▁; ▁c out ▁<< ▁g ▁. ▁min ▁( ▁x ▁, ▁y ▁) ▁; ▁c out ▁<< ▁" ▁Maximum ▁of ▁" ▁< ▁< ▁x ▁< ▁< ▁STRNEWLINE ▁TABSYMBOL ▁TABSYMBOL ▁TABSYMBOL ▁TABSYMBOL ▁" ▁and ▁" ▁< ▁< ▁y ▁< ▁< ▁" ▁is ▁" ▁c out ▁<< ▁g ▁. ▁max ▁( ▁x ▁, ▁y ▁) ▁; ▁get char ▁( ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁getO dd Occurrence ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁size ▁) ▁{ ▁unordered _ map ▁< ▁int ▁, ▁int ▁> ▁hash ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁{ ▁hash ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁++ ▁; ▁} ▁for ▁( ▁auto ▁i ▁: ▁hash ▁) ▁{ ▁if ▁( ▁i ▁. ▁second ▁% ▁2 ▁!= ▁0 ▁) ▁{ ▁return ▁i ▁. ▁first ▁; ▁} ▁} ▁return ▁-1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁5 ▁, ▁4 ▁, ▁5 ▁, ▁2 ▁, ▁4 ▁, ▁3 ▁, ▁5 ▁, ▁2 ▁, ▁4 ▁, ▁4 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁getO dd Occurrence ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁num _ to _ bits ▁[ ▁16 ▁] ▁= ▁{ ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁2 ▁, ▁1 ▁, ▁2 ▁, ▁2 ▁, ▁3 ▁, ▁1 ▁, ▁2 ▁, ▁2 ▁, ▁3 ▁, ▁2 ▁, ▁3 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁unsigned ▁int ▁count Set Bits Rec ▁( ▁unsigned ▁int ▁num ▁) ▁{ ▁int ▁n ibble ▁= ▁0 ▁; ▁if ▁( ▁0 ▁== ▁num ▁) ▁return ▁num _ to _ bits ▁[ ▁0 ▁] ▁; ▁n ibble ▁= ▁num ▁& ▁0 xf ▁; ▁return ▁num _ to _ bits ▁[ ▁n ibble ▁] ▁+ ▁count Set Bits Rec ▁( ▁num ▁>> ▁4 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁num ▁= ▁31 ▁; ▁c out ▁<< ▁count Set Bits Rec ▁( ▁num ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁unsigned ▁int ▁next Power Of 2 ▁( ▁unsigned ▁int ▁n ▁) ▁{ ▁n ▁-- ▁; ▁n ▁|= ▁n ▁>> ▁1 ▁; ▁n ▁|= ▁n ▁>> ▁2 ▁; ▁n ▁|= ▁n ▁>> ▁4 ▁; ▁n ▁|= ▁n ▁>> ▁8 ▁; ▁n ▁|= ▁n ▁>> ▁16 ▁; ▁n ▁++ ▁; ▁return ▁n ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁unsigned ▁int ▁n ▁= ▁5 ▁; ▁c out ▁<< ▁next Power Of 2 ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is Power Of Two ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁0 ▁) ▁return ▁false ▁; ▁return ▁( ▁ceil ▁( ▁log 2 ▁( ▁n ▁) ▁) ▁== ▁floor ▁( ▁log 2 ▁( ▁n ▁) ▁) ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁is Power Of Two ▁( ▁31 ▁) ▁? ▁c out ▁<< ▁" ▁Yes ▁" ▁<< ▁end l ▁: ▁c out ▁<< ▁" ▁No ▁" ▁<< ▁end l ▁; ▁is Power Of Two ▁( ▁64 ▁) ▁? ▁c out ▁<< ▁" ▁Yes ▁" ▁<< ▁end l ▁: ▁c out ▁<< ▁" ▁No ▁" ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is Power Of Two ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁0 ▁) ▁return ▁0 ▁; ▁while ▁( ▁n ▁!= ▁1 ▁) ▁{ ▁if ▁( ▁n ▁% ▁2 ▁!= ▁0 ▁) ▁return ▁0 ▁; ▁n ▁= ▁n ▁/ ▁2 ▁; ▁} ▁return ▁1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁is Power Of Two ▁( ▁31 ▁) ▁? ▁c out ▁<< ▁" ▁Yes ▁STRNEWLINE ▁" ▁: ▁c out ▁<< ▁" ▁No ▁STRNEWLINE ▁" ▁; ▁is Power Of Two ▁( ▁64 ▁) ▁? ▁c out ▁<< ▁" ▁Yes ▁STRNEWLINE ▁" ▁: ▁c out ▁<< ▁" ▁No ▁STRNEWLINE ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁# include ▁< math . h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁class ▁g fg ▁{ ▁public ▁: ▁unsigned ▁int ▁getFirst Set Bit Pos ▁( ▁int ▁n ▁) ▁{ ▁return ▁log 2 ▁( ▁n ▁& ▁- ▁n ▁) ▁+ ▁1 ▁; ▁} ▁} ▁; ▁int ▁main ▁( ▁) ▁{ ▁g fg ▁g ▁; ▁int ▁n ▁= ▁12 ▁; ▁c out ▁<< ▁g ▁. ▁getFirst Set Bit Pos ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁unsigned ▁int ▁swap Bits ▁( ▁unsigned ▁int ▁x ▁) ▁{ ▁unsigned ▁int ▁even _ bits ▁= ▁x ▁& ▁0 x AAAAAAAA ▁; ▁unsigned ▁int ▁odd _ bits ▁= ▁x ▁& ▁0 x 5555 5555 ▁; ▁even _ bits ▁>>= ▁1 ▁; ▁odd _ bits ▁<<= ▁1 ▁; ▁return ▁( ▁even _ bits ▁odd _ bits ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁unsigned ▁int ▁x ▁= ▁23 ▁; ▁c out ▁<< ▁swap Bits ▁( ▁x ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁is Power Of Two ▁( ▁unsigned ▁n ▁) ▁{ ▁return ▁n ▁&& ▁( ▁! ▁( ▁n ▁& ▁( ▁n ▁- ▁1 ▁) ▁) ▁) ▁; ▁} ▁int ▁find Position ▁( ▁unsigned ▁n ▁) ▁{ ▁if ▁( ▁! ▁is Power Of Two ▁( ▁n ▁) ▁) ▁return ▁-1 ▁; ▁unsigned ▁count ▁= ▁0 ▁; ▁while ▁( ▁n ▁) ▁{ ▁n ▁= ▁n ▁>> ▁1 ▁; ▁++ ▁count ▁; ▁} ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁void ▁) ▁{ ▁int ▁n ▁= ▁0 ▁; ▁int ▁pos ▁= ▁find Position ▁( ▁n ▁) ▁; ▁( ▁pos ▁== ▁-1 ▁) ▁? ▁c out ▁<< ▁" ▁n ▁= ▁" ▁<< ▁n ▁<< ▁" ▁, ▁Invalid ▁number ▁STRNEWLINE ▁" ▁: ▁c out ▁<< ▁" ▁n ▁= ▁" ▁<< ▁n ▁<< ▁" ▁, ▁Position ▁" ▁<< ▁pos ▁<< ▁end l ▁; ▁n ▁= ▁12 ▁; ▁pos ▁= ▁find Position ▁( ▁n ▁) ▁; ▁( ▁pos ▁== ▁-1 ▁) ▁? ▁c out ▁<< ▁" ▁n ▁= ▁" ▁<< ▁n ▁<< ▁" ▁, ▁Invalid ▁number ▁STRNEWLINE ▁" ▁: ▁c out ▁<< ▁" ▁n ▁= ▁" ▁<< ▁n ▁<< ▁" ▁, ▁Position ▁" ▁<< ▁pos ▁<< ▁end l ▁; ▁n ▁= ▁128 ▁; ▁pos ▁= ▁find Position ▁( ▁n ▁) ▁; ▁( ▁pos ▁== ▁-1 ▁) ▁? ▁c out ▁<< ▁" ▁n ▁= ▁" ▁<< ▁n ▁<< ▁" ▁, ▁Invalid ▁number ▁STRNEWLINE ▁" ▁: ▁c out ▁<< ▁" ▁n ▁= ▁" ▁<< ▁n ▁<< ▁" ▁, ▁Position ▁" ▁<< ▁pos ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁next Gre at est ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁size ▁) ▁{ ▁int ▁max _ from _ right ▁= ▁arr ▁[ ▁size ▁- ▁1 ▁] ▁; ▁arr ▁[ ▁size ▁- ▁1 ▁] ▁= ▁-1 ▁; ▁for ▁( ▁int ▁i ▁= ▁size ▁- ▁2 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁int ▁temp ▁= ▁arr ▁[ ▁i ▁] ▁; ▁arr ▁[ ▁i ▁] ▁= ▁max _ from _ right ▁; ▁if ▁( ▁max _ from _ right ▁< ▁temp ▁) ▁max _ from _ right ▁= ▁temp ▁; ▁} ▁} ▁void ▁print Array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁size ▁) ▁{ ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁c out ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁16 ▁, ▁17 ▁, ▁4 ▁, ▁3 ▁, ▁5 ▁, ▁2 ▁} ▁; ▁int ▁size ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁next Gre at est ▁( ▁arr ▁, ▁size ▁) ▁; ▁c out ▁<< ▁" ▁The ▁modified ▁array ▁is ▁: ▁STRNEWLINE ▁" ▁; ▁print Array ▁( ▁arr ▁, ▁size ▁) ▁; ▁return ▁( ▁0 ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max C ircular Sum ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁1 ▁) ▁return ▁a ▁[ ▁0 ▁] ▁; ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁a ▁[ ▁i ▁] ▁; ▁} ▁int ▁curr _ max ▁= ▁a ▁[ ▁0 ▁] ▁, ▁max _ so _ far ▁= ▁a ▁[ ▁0 ▁] ▁, ▁curr _ min ▁= ▁a ▁[ ▁0 ▁] ▁, ▁min _ so _ far ▁= ▁a ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁curr _ max ▁= ▁max ▁( ▁curr _ max ▁+ ▁a ▁[ ▁i ▁] ▁, ▁a ▁[ ▁i ▁] ▁) ▁; ▁max _ so _ far ▁= ▁max ▁( ▁max _ so _ far ▁, ▁curr _ max ▁) ▁; ▁curr _ min ▁= ▁min ▁( ▁curr _ min ▁+ ▁a ▁[ ▁i ▁] ▁, ▁a ▁[ ▁i ▁] ▁) ▁; ▁min _ so _ far ▁= ▁min ▁( ▁min _ so _ far ▁, ▁curr _ min ▁) ▁; ▁} ▁if ▁( ▁min _ so _ far ▁== ▁sum ▁) ▁return ▁max _ so _ far ▁; ▁return ▁max ▁( ▁max _ so _ far ▁, ▁sum ▁- ▁min _ so _ far ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁11 ▁, ▁10 ▁, ▁- 20 ▁, ▁5 ▁, ▁-3 ▁, ▁-5 ▁, ▁8 ▁, ▁- 13 ▁, ▁10 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁Maximum ▁circular ▁sum ▁is ▁" ▁<< ▁max C ircular Sum ▁( ▁a ▁, ▁n ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max Diff ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁arr _ size ▁) ▁{ ▁int ▁max _ diff ▁= ▁arr ▁[ ▁1 ▁] ▁- ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁arr _ size ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁arr _ size ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁j ▁] ▁- ▁arr ▁[ ▁i ▁] ▁> ▁max _ diff ▁) ▁max _ diff ▁= ▁arr ▁[ ▁j ▁] ▁- ▁arr ▁[ ▁i ▁] ▁; ▁} ▁} ▁return ▁max _ diff ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁90 ▁, ▁10 ▁, ▁110 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁Maximum ▁difference ▁is ▁" ▁<< ▁max Diff ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Maximum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁low ▁, ▁int ▁high ▁) ▁{ ▁if ▁( ▁low ▁== ▁high ▁) ▁return ▁arr ▁[ ▁low ▁] ▁; ▁if ▁( ▁( ▁high ▁== ▁low ▁+ ▁1 ▁) ▁&& ▁arr ▁[ ▁low ▁] ▁>= ▁arr ▁[ ▁high ▁] ▁) ▁return ▁arr ▁[ ▁low ▁] ▁; ▁if ▁( ▁( ▁high ▁== ▁low ▁+ ▁1 ▁) ▁&& ▁arr ▁[ ▁low ▁] ▁< ▁arr ▁[ ▁high ▁] ▁) ▁return ▁arr ▁[ ▁high ▁] ▁; ▁int ▁mid ▁= ▁( ▁low ▁+ ▁high ▁) ▁/ ▁2 ▁; ▁if ▁( ▁arr ▁[ ▁mid ▁] ▁> ▁arr ▁[ ▁mid ▁+ ▁1 ▁] ▁&& ▁arr ▁[ ▁mid ▁] ▁> ▁arr ▁[ ▁mid ▁- ▁1 ▁] ▁) ▁return ▁arr ▁[ ▁mid ▁] ▁; ▁if ▁( ▁arr ▁[ ▁mid ▁] ▁> ▁arr ▁[ ▁mid ▁+ ▁1 ▁] ▁&& ▁arr ▁[ ▁mid ▁] ▁< ▁arr ▁[ ▁mid ▁- ▁1 ▁] ▁) ▁return ▁find Maximum ▁( ▁arr ▁, ▁low ▁, ▁mid ▁- ▁1 ▁) ▁; ▁else ▁return ▁find Maximum ▁( ▁arr ▁, ▁mid ▁+ ▁1 ▁, ▁high ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁50 ▁, ▁10 ▁, ▁9 ▁, ▁7 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁The ▁maximum ▁element ▁is ▁" ▁<< ▁find Maximum ▁( ▁arr ▁, ▁0 ▁, ▁n ▁- ▁1 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Min Sw aps ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁no Of Zero es ▁[ ▁n ▁] ▁; ▁mem set ▁( ▁no Of Zero es ▁, ▁0 ▁, ▁sizeof ▁( ▁no Of Zero es ▁) ▁) ▁; ▁int ▁i ▁, ▁count ▁= ▁0 ▁; ▁no Of Zero es ▁[ ▁n ▁- ▁1 ▁] ▁= ▁1 ▁- ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁; ▁for ▁( ▁i ▁= ▁n ▁- ▁2 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁no Of Zero es ▁[ ▁i ▁] ▁= ▁no Of Zero es ▁[ ▁i ▁+ ▁1 ▁] ▁; ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁0 ▁) ▁no Of Zero es ▁[ ▁i ▁] ▁++ ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁1 ▁) ▁count ▁+= ▁no Of Zero es ▁[ ▁i ▁] ▁; ▁} ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁find Min Sw aps ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁min Sw aps To Sort ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁pair ▁< ▁int ▁, ▁int ▁> ▁arr Pos ▁[ ▁n ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁arr Pos ▁[ ▁i ▁] ▁. ▁first ▁= ▁arr ▁[ ▁i ▁] ▁; ▁arr Pos ▁[ ▁i ▁] ▁. ▁second ▁= ▁i ▁; ▁} ▁sort ▁( ▁arr Pos ▁, ▁arr Pos ▁+ ▁n ▁) ▁; ▁vector ▁< ▁bool ▁> ▁vis ▁( ▁n ▁, ▁false ▁) ▁; ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁vis ▁[ ▁i ▁] ▁arr Pos ▁[ ▁i ▁] ▁. ▁second ▁== ▁i ▁) ▁continue ▁; ▁int ▁cycle _ size ▁= ▁0 ▁; ▁int ▁j ▁= ▁i ▁; ▁while ▁( ▁! ▁vis ▁[ ▁j ▁] ▁) ▁{ ▁vis ▁[ ▁j ▁] ▁= ▁1 ▁; ▁j ▁= ▁arr Pos ▁[ ▁j ▁] ▁. ▁second ▁; ▁cycle _ size ▁++ ▁; ▁} ▁ans ▁+= ▁( ▁cycle _ size ▁- ▁1 ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁min Swap To Make Array Same ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁b ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁map ▁< ▁int ▁, ▁int ▁> ▁mp ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁mp ▁[ ▁b ▁[ ▁i ▁] ▁] ▁= ▁i ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁b ▁[ ▁i ▁] ▁= ▁mp ▁[ ▁a ▁[ ▁i ▁] ▁] ▁; ▁return ▁min Sw aps To Sort ▁( ▁b ▁, ▁n ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁6 ▁, ▁4 ▁, ▁8 ▁} ▁; ▁int ▁b ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁6 ▁, ▁8 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁c out ▁<< ▁min Swap To Make Array Same ▁( ▁a ▁, ▁b ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Tri pl ets ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁sum ▁) ▁{ ▁sort ▁( ▁arr ▁, ▁arr ▁+ ▁n ▁) ▁; ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁int ▁j ▁= ▁i ▁+ ▁1 ▁, ▁k ▁= ▁n ▁- ▁1 ▁; ▁while ▁( ▁j ▁< ▁k ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁arr ▁[ ▁j ▁] ▁+ ▁arr ▁[ ▁k ▁] ▁>= ▁sum ▁) ▁k ▁-- ▁; ▁else ▁{ ▁ans ▁+= ▁( ▁k ▁- ▁j ▁) ▁; ▁j ▁++ ▁; ▁} ▁} ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁1 ▁, ▁3 ▁, ▁4 ▁, ▁7 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁arr ▁/ ▁sizeof ▁arr ▁[ ▁0 ▁] ▁; ▁int ▁sum ▁= ▁12 ▁; ▁c out ▁<< ▁count Tri pl ets ▁( ▁arr ▁, ▁n ▁, ▁sum ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print Two Elements ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁size ▁) ▁{ ▁int ▁i ▁; ▁c out ▁<< ▁" ▁The ▁repeating ▁element ▁is ▁" ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁abs ▁( ▁arr ▁[ ▁i ▁] ▁) ▁- ▁1 ▁] ▁> ▁0 ▁) ▁arr ▁[ ▁abs ▁( ▁arr ▁[ ▁i ▁] ▁) ▁- ▁1 ▁] ▁= ▁- ▁arr ▁[ ▁abs ▁( ▁arr ▁[ ▁i ▁] ▁) ▁- ▁1 ▁] ▁; ▁else ▁c out ▁<< ▁abs ▁( ▁arr ▁[ ▁i ▁] ▁) ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁} ▁c out ▁<< ▁" ▁and ▁the ▁missing ▁element ▁is ▁" ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁0 ▁) ▁c out ▁<< ▁( ▁i ▁+ ▁1 ▁) ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁7 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁5 ▁, ▁6 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁print Two Elements ▁( ▁arr ▁, ▁n ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print Two Odd ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁size ▁) ▁{ ▁int ▁xor 2 ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁int ▁set _ bit _ no ▁; ▁int ▁i ▁; ▁int ▁n ▁= ▁size ▁- ▁2 ▁; ▁int ▁x ▁= ▁0 ▁, ▁y ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁xor 2 ▁= ▁xor 2 ▁^ ▁arr ▁[ ▁i ▁] ▁; ▁set _ bit _ no ▁= ▁xor 2 ▁& ▁~ ▁( ▁xor 2 ▁- ▁1 ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁& ▁set _ bit _ no ▁) ▁x ▁= ▁x ▁^ ▁arr ▁[ ▁i ▁] ▁; ▁else ▁y ▁= ▁y ▁^ ▁arr ▁[ ▁i ▁] ▁; ▁} ▁c out ▁<< ▁" ▁The ▁two ▁O DD ▁elements ▁are ▁" ▁<< ▁x ▁<< ▁" ▁& ▁" ▁<< ▁y ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁2 ▁, ▁4 ▁, ▁5 ▁, ▁2 ▁, ▁3 ▁, ▁3 ▁, ▁1 ▁} ▁; ▁int ▁arr _ size ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁print Two Odd ▁( ▁arr ▁, ▁arr _ size ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁find Pair ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁size ▁, ▁int ▁n ▁) ▁{ ▁int ▁i ▁= ▁0 ▁; ▁int ▁j ▁= ▁1 ▁; ▁while ▁( ▁i ▁< ▁size ▁&& ▁j ▁< ▁size ▁) ▁{ ▁if ▁( ▁i ▁!= ▁j ▁&& ▁arr ▁[ ▁j ▁] ▁- ▁arr ▁[ ▁i ▁] ▁== ▁n ▁) ▁{ ▁c out ▁<< ▁" ▁Pair ▁Found ▁: ▁( ▁" ▁<< ▁arr ▁[ ▁i ▁] ▁<< ▁" ▁, ▁" ▁<< ▁arr ▁[ ▁j ▁] ▁<< ▁" ▁) ▁" ▁; ▁return ▁true ▁; ▁} ▁else ▁if ▁( ▁arr ▁[ ▁j ▁] ▁- ▁arr ▁[ ▁i ▁] ▁< ▁n ▁) ▁j ▁++ ▁; ▁else ▁i ▁++ ▁; ▁} ▁c out ▁<< ▁" ▁No ▁such ▁pair ▁" ▁; ▁return ▁false ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁8 ▁, ▁30 ▁, ▁40 ▁, ▁100 ▁} ▁; ▁int ▁size ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁n ▁= ▁60 ▁; ▁find Pair ▁( ▁arr ▁, ▁size ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁four Sum ▁( ▁int ▁X ▁, ▁int ▁arr ▁[ ▁] ▁, ▁map ▁< ▁int ▁, ▁pair ▁< ▁int ▁, ▁int ▁> ▁> ▁Map ▁, ▁int ▁N ▁) ▁{ ▁int ▁temp ▁[ ▁N ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁temp ▁[ ▁i ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁int ▁curr _ sum ▁= ▁arr ▁[ ▁i ▁] ▁+ ▁arr ▁[ ▁j ▁] ▁; ▁if ▁( ▁Map ▁. ▁find ▁( ▁X ▁- ▁curr _ sum ▁) ▁!= ▁Map ▁. ▁end ▁( ▁) ▁) ▁{ ▁pair ▁< ▁int ▁, ▁int ▁> ▁p ▁= ▁Map ▁[ ▁X ▁- ▁curr _ sum ▁] ▁; ▁if ▁( ▁p ▁. ▁first ▁!= ▁i ▁&& ▁p ▁. ▁second ▁!= ▁i ▁&& ▁p ▁. ▁first ▁!= ▁j ▁&& ▁p ▁. ▁second ▁!= ▁j ▁&& ▁temp ▁[ ▁p ▁. ▁first ▁] ▁== ▁0 ▁&& ▁temp ▁[ ▁p ▁. ▁second ▁] ▁== ▁0 ▁&& ▁temp ▁[ ▁i ▁] ▁== ▁0 ▁&& ▁temp ▁[ ▁j ▁] ▁== ▁0 ▁) ▁{ ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁<< ▁" ▁, ▁" ▁<< ▁arr ▁[ ▁j ▁] ▁<< ▁" ▁, ▁" ▁<< ▁arr ▁[ ▁p ▁. ▁first ▁] ▁<< ▁" ▁, ▁" ▁<< ▁arr ▁[ ▁p ▁. ▁second ▁] ▁; ▁temp ▁[ ▁p ▁. ▁second ▁] ▁= ▁1 ▁; ▁temp ▁[ ▁i ▁] ▁= ▁1 ▁; ▁temp ▁[ ▁j ▁] ▁= ▁1 ▁; ▁break ▁; ▁} ▁} ▁} ▁} ▁} ▁map ▁< ▁int ▁, ▁pair ▁< ▁int ▁, ▁int ▁> ▁> ▁two Sum ▁( ▁int ▁nums ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁map ▁< ▁int ▁, ▁pair ▁< ▁int ▁, ▁int ▁> ▁> ▁Map ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁Map ▁[ ▁nums ▁[ ▁i ▁] ▁+ ▁nums ▁[ ▁j ▁] ▁] ▁. ▁first ▁= ▁i ▁; ▁Map ▁[ ▁nums ▁[ ▁i ▁] ▁+ ▁nums ▁[ ▁j ▁] ▁] ▁. ▁second ▁= ▁j ▁; ▁} ▁} ▁return ▁Map ▁; ▁} ▁int ▁main ▁(
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁delete Element ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁x ▁) ▁{ ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁x ▁) ▁break ▁; ▁if ▁( ▁i ▁< ▁n ▁) ▁{ ▁n ▁= ▁n ▁- ▁1 ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁arr ▁[ ▁j ▁] ▁= ▁arr ▁[ ▁j ▁+ ▁1 ▁] ▁; ▁} ▁return ▁n ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁11 ▁, ▁15 ▁, ▁6 ▁, ▁8 ▁, ▁9 ▁, ▁10 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁x ▁= ▁6 ▁; ▁n ▁= ▁delete Element ▁( ▁arr ▁, ▁n ▁, ▁x ▁) ▁; ▁c out ▁<< ▁" ▁Modified ▁array ▁is ▁STRNEWLINE ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max Distance ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁max 1 ▁= ▁INT _ MIN ▁, ▁min 1 ▁= ▁INT _ MAX ▁; ▁int ▁max 2 ▁= ▁INT _ MIN ▁, ▁min 2 ▁= ▁INT _ MAX ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁max 1 ▁= ▁max ▁( ▁max 1 ▁, ▁arr ▁[ ▁i ▁] ▁+ ▁i ▁) ▁; ▁min 1 ▁= ▁min ▁( ▁min 1 ▁, ▁arr ▁[ ▁i ▁] ▁+ ▁i ▁) ▁; ▁max 2 ▁= ▁max ▁( ▁max 2 ▁, ▁arr ▁[ ▁i ▁] ▁- ▁i ▁) ▁; ▁min 2 ▁= ▁min ▁( ▁min 2 ▁, ▁arr ▁[ ▁i ▁] ▁- ▁i ▁) ▁; ▁} ▁return ▁max ▁( ▁max 1 ▁- ▁min 1 ▁, ▁max 2 ▁- ▁min 2 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁- 70 ▁, ▁- 64 ▁, ▁- 6 ▁, ▁- 56 ▁, ▁64 ▁, ▁61 ▁, ▁- 57 ▁, ▁16 ▁, ▁48 ▁, ▁- 98 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁max Distance ▁( ▁arr ▁, ▁n ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁getC lo sest ▁( ▁int ▁, ▁int ▁, ▁int ▁) ▁; ▁int ▁find Clo sest ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁target ▁) ▁{ ▁if ▁( ▁target ▁<= ▁arr ▁[ ▁0 ▁] ▁) ▁return ▁arr ▁[ ▁0 ▁] ▁; ▁if ▁( ▁target ▁>= ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁) ▁return ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁; ▁int ▁i ▁= ▁0 ▁, ▁j ▁= ▁n ▁, ▁mid ▁= ▁0 ▁; ▁while ▁( ▁i ▁< ▁j ▁) ▁{ ▁mid ▁= ▁( ▁i ▁+ ▁j ▁) ▁/ ▁2 ▁; ▁if ▁( ▁arr ▁[ ▁mid ▁] ▁== ▁target ▁) ▁return ▁arr ▁[ ▁mid ▁] ▁; ▁if ▁( ▁target ▁< ▁arr ▁[ ▁mid ▁] ▁) ▁{ ▁if ▁( ▁mid ▁> ▁0 ▁&& ▁target ▁> ▁arr ▁[ ▁mid ▁- ▁1 ▁] ▁) ▁return ▁getC lo sest ▁( ▁arr ▁[ ▁mid ▁- ▁1 ▁] ▁, ▁arr ▁[ ▁mid ▁] ▁, ▁target ▁) ▁; ▁j ▁= ▁mid ▁; ▁} ▁else ▁{ ▁if ▁( ▁mid ▁< ▁n ▁- ▁1 ▁&& ▁target ▁< ▁arr ▁[ ▁mid ▁+ ▁1 ▁] ▁) ▁return ▁getC lo sest ▁( ▁arr ▁[ ▁mid ▁] ▁, ▁arr ▁[ ▁mid ▁+ ▁1 ▁] ▁, ▁target ▁) ▁; ▁i ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁} ▁return ▁arr ▁[ ▁mid ▁] ▁; ▁} ▁int ▁getC lo sest ▁( ▁int ▁val 1 ▁, ▁int ▁val 2 ▁, ▁int ▁target ▁) ▁{ ▁if ▁( ▁target ▁- ▁val 1 ▁>= ▁val 2 ▁- ▁target ▁) ▁return ▁val 2 ▁; ▁else ▁return ▁val 1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁, ▁6 ▁, ▁8 ▁, ▁9 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁target ▁= ▁11 ▁; ▁c out ▁<< ▁( ▁find Clo sest ▁( ▁arr ▁, ▁n ▁, ▁target ▁) ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁struct ▁Node ▁{ ▁int ▁data ▁; ▁struct ▁Node ▁* ▁next ▁; ▁} ▁; ▁void ▁print List ▁( ▁struct ▁Node ▁* ▁node ▁) ▁{ ▁while ▁( ▁node ▁!= ▁NULL ▁) ▁{ ▁c out ▁<< ▁node ▁-> ▁data ▁<< ▁" ▁" ▁; ▁node ▁= ▁node ▁-> ▁next ▁; ▁} ▁c out ▁<< ▁end l ▁; ▁} ▁Node ▁* ▁newNode ▁( ▁int ▁key ▁) ▁{ ▁Node ▁* ▁temp ▁= ▁new ▁Node ▁; ▁temp ▁-> ▁data ▁= ▁key ▁; ▁temp ▁-> ▁next ▁= ▁NULL ▁; ▁return ▁temp ▁; ▁} ▁Node ▁* ▁insert B eg ▁( ▁Node ▁* ▁head ▁, ▁int ▁val ▁) ▁{ ▁Node ▁* ▁temp ▁= ▁newNode ▁( ▁val ▁) ▁; ▁temp ▁-> ▁next ▁= ▁head ▁; ▁head ▁= ▁temp ▁; ▁return ▁head ▁; ▁} ▁void ▁re arrange ▁( ▁Node ▁* ▁* ▁head ▁) ▁{ ▁Node ▁* ▁even ▁; ▁Node ▁* ▁temp ▁, ▁* ▁prev _ temp ▁; ▁Node ▁* ▁i ▁, ▁* ▁j ▁, ▁* ▁k ▁, ▁* ▁l ▁, ▁* ▁ptr ▁; ▁temp ▁= ▁( ▁* ▁head ▁) ▁-> ▁next ▁; ▁prev _ temp ▁= ▁* ▁head ▁; ▁while ▁( ▁temp ▁!= ▁null ptr ▁) ▁{ ▁Node ▁* ▁x ▁= ▁temp ▁-> ▁next ▁; ▁if ▁( ▁temp ▁-> ▁data ▁% ▁2 ▁!= ▁0 ▁) ▁{ ▁prev _ temp ▁-> ▁next ▁= ▁x ▁; ▁temp ▁-> ▁next ▁= ▁( ▁* ▁head ▁) ▁; ▁( ▁* ▁head ▁) ▁= ▁temp ▁; ▁} ▁else ▁{ ▁prev _ temp ▁= ▁temp ▁; ▁} ▁temp ▁= ▁x ▁; ▁} ▁temp ▁= ▁( ▁* ▁head ▁) ▁-> ▁next ▁; ▁prev _ temp ▁= ▁( ▁* ▁head ▁) ▁; ▁while ▁( ▁temp ▁!= ▁null ptr ▁&& ▁temp ▁-> ▁data ▁% ▁2 ▁!= ▁0 ▁) ▁{ ▁prev _ temp ▁= ▁temp ▁; ▁temp ▁= ▁temp ▁-> ▁next ▁; ▁} ▁even ▁= ▁temp ▁; ▁prev _ temp ▁-> ▁next ▁= ▁null ptr ▁; ▁i ▁= ▁* ▁head ▁; ▁j ▁= ▁even ▁; ▁while ▁( ▁j ▁!= ▁null ptr ▁&& ▁i ▁!= ▁null ptr ▁) ▁{ ▁k ▁= ▁i ▁-> ▁next ▁; ▁l ▁= ▁j ▁-> ▁next ▁; ▁i ▁-> ▁next ▁= ▁j ▁; ▁j ▁-> ▁next ▁= ▁k ▁; ▁ptr ▁= ▁j ▁; ▁i ▁= ▁k ▁; ▁j ▁= ▁l ▁; ▁} ▁if ▁( ▁i ▁== ▁null ptr ▁) ▁{ ▁ptr ▁-> ▁next ▁= ▁j ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁class ▁Node ▁{ ▁public ▁: ▁int ▁data ▁; ▁Node ▁* ▁next ▁; ▁} ▁; ▁void ▁rotate ▁( ▁Node ▁* ▁* ▁head _ ref ▁, ▁int ▁k ▁) ▁{ ▁if ▁( ▁k ▁== ▁0 ▁) ▁return ▁; ▁Node ▁* ▁current ▁= ▁* ▁head _ ref ▁; ▁while ▁( ▁current ▁-> ▁next ▁!= ▁NULL ▁) ▁current ▁= ▁current ▁-> ▁next ▁; ▁current ▁-> ▁next ▁= ▁* ▁head _ ref ▁; ▁current ▁= ▁* ▁head _ ref ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁k ▁- ▁1 ▁; ▁i ▁++ ▁) ▁current ▁= ▁current ▁-> ▁next ▁; ▁* ▁head _ ref ▁= ▁current ▁-> ▁next ▁; ▁current ▁-> ▁next ▁= ▁NULL ▁; ▁} ▁void ▁push ▁( ▁Node ▁* ▁* ▁head _ ref ▁, ▁int ▁new _ data ▁) ▁{ ▁Node ▁* ▁new _ node ▁= ▁new ▁Node ▁( ▁) ▁; ▁new _ node ▁-> ▁data ▁= ▁new _ data ▁; ▁new _ node ▁-> ▁next ▁= ▁( ▁* ▁head _ ref ▁) ▁; ▁( ▁* ▁head _ ref ▁) ▁= ▁new _ node ▁; ▁} ▁void ▁print List ▁( ▁Node ▁* ▁node ▁) ▁{ ▁while ▁( ▁node ▁!= ▁NULL ▁) ▁{ ▁c out ▁<< ▁node ▁-> ▁data ▁<< ▁" ▁" ▁; ▁node ▁= ▁node ▁-> ▁next ▁; ▁} ▁} ▁int ▁main ▁( ▁void ▁) ▁{ ▁Node ▁* ▁head ▁= ▁NULL ▁; ▁for ▁( ▁int ▁i ▁= ▁60 ▁; ▁i ▁> ▁0 ▁; ▁i ▁-= ▁10 ▁) ▁push ▁( ▁& ▁head ▁, ▁i ▁) ▁; ▁c out ▁<< ▁" ▁Given ▁linked ▁list ▁STRNEWLINE ▁" ▁; ▁print List ▁( ▁head ▁) ▁; ▁rotate ▁( ▁& ▁head ▁, ▁4 ▁) ▁; ▁c out ▁<< ▁" ▁Rot ated ▁Linked ▁list ▁" ▁; ▁print List ▁( ▁head ▁) ▁; ▁return ▁( ▁0 ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁int ▁> ▁list ▁; ▁list ▁. ▁push _ back ▁( ▁1 ▁) ▁; ▁list ▁. ▁push _ back ▁( ▁2 ▁) ▁; ▁list ▁. ▁push _ back ▁( ▁3 ▁) ▁; ▁for ▁( ▁vector ▁< ▁int ▁> ▁:: ▁iterator ▁it ▁= ▁list ▁. ▁begin ▁( ▁) ▁; ▁it ▁!= ▁list ▁. ▁end ▁( ▁) ▁; ▁++ ▁it ▁) ▁c out ▁<< ▁* ▁it ▁<< ▁" ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁struct ▁Node ▁{ ▁int ▁data ▁; ▁struct ▁Node ▁* ▁next ▁; ▁} ▁; ▁struct ▁Node ▁* ▁newNode ▁( ▁int ▁x ▁) ▁{ ▁Node ▁* ▁temp ▁= ▁new ▁Node ▁; ▁temp ▁-> ▁data ▁= ▁x ▁; ▁temp ▁-> ▁next ▁= ▁NULL ▁; ▁} ▁Node ▁* ▁key To End ▁( ▁Node ▁* ▁head ▁, ▁int ▁key ▁) ▁{ ▁Node ▁* ▁tail ▁= ▁head ▁; ▁if ▁( ▁head ▁== ▁NULL ▁) ▁{ ▁return ▁NULL ▁; ▁} ▁while ▁( ▁tail ▁-> ▁next ▁!= ▁NULL ▁) ▁{ ▁tail ▁= ▁tail ▁-> ▁next ▁; ▁} ▁Node ▁* ▁last ▁= ▁tail ▁; ▁Node ▁* ▁current ▁= ▁head ▁; ▁Node ▁* ▁prev ▁= ▁NULL ▁; ▁Node ▁* ▁prev 2 ▁= ▁NULL ▁; ▁while ▁( ▁current ▁!= ▁tail ▁) ▁{ ▁if ▁( ▁current ▁-> ▁data ▁== ▁key ▁&& ▁prev 2 ▁== ▁NULL ▁) ▁{ ▁prev ▁= ▁current ▁; ▁current ▁= ▁current ▁-> ▁next ▁; ▁head ▁= ▁current ▁; ▁last ▁-> ▁next ▁= ▁prev ▁; ▁last ▁= ▁last ▁-> ▁next ▁; ▁last ▁-> ▁next ▁= ▁NULL ▁; ▁prev ▁= ▁NULL ▁; ▁} ▁else ▁{ ▁if ▁( ▁current ▁-> ▁data ▁== ▁key ▁&& ▁prev 2 ▁!= ▁NULL ▁) ▁{ ▁prev ▁= ▁current ▁; ▁current ▁= ▁current ▁-> ▁next ▁; ▁prev 2 ▁-> ▁next ▁= ▁current ▁; ▁last ▁-> ▁next ▁= ▁prev ▁; ▁last ▁= ▁last ▁-> ▁next ▁; ▁last ▁-> ▁next ▁= ▁NULL ▁; ▁} ▁else ▁if ▁( ▁current ▁!= ▁tail ▁) ▁{ ▁prev 2 ▁= ▁current ▁; ▁current ▁= ▁current ▁-> ▁next ▁; ▁} ▁} ▁} ▁return ▁head ▁; ▁} ▁void ▁print List ▁( ▁Node ▁* ▁head ▁) ▁{ ▁struct ▁Node ▁* ▁temp ▁= ▁head ▁; ▁while ▁( ▁temp ▁!= ▁NULL ▁) ▁{ ▁printf ▁( ▁" ▁% ▁d ▁" ▁, ▁temp ▁-> ▁data ▁) ▁; ▁temp ▁= ▁temp ▁-> ▁next ▁; ▁} ▁printf ▁( ▁" ▁STRNEWLINE ▁" ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁Node ▁* ▁root ▁= ▁newNode ▁( ▁5 ▁) ▁; ▁root ▁-> ▁next ▁= ▁newNode ▁( ▁2 ▁) ▁; ▁root ▁-> ▁next ▁-> ▁next ▁= ▁newNode ▁( ▁2 ▁) ▁; ▁root ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁= ▁newNode ▁( ▁7 ▁) ▁; ▁root ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁= ▁newNode ▁( ▁2 ▁) ▁; ▁root ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁= ▁newNode ▁( ▁2 ▁) ▁; ▁root ▁-> ▁next ▁->
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁struct ▁Node ▁{ ▁int ▁data ▁; ▁struct ▁Node ▁* ▁next ▁; ▁} ▁; ▁void ▁push ▁( ▁struct ▁Node ▁* ▁* ▁head _ ref ▁, ▁int ▁new _ data ▁) ▁{ ▁struct ▁Node ▁* ▁new _ node ▁= ▁new ▁Node ▁; ▁new _ node ▁-> ▁data ▁= ▁new _ data ▁; ▁new _ node ▁-> ▁next ▁= ▁( ▁* ▁head _ ref ▁) ▁; ▁( ▁* ▁head _ ref ▁) ▁= ▁new _ node ▁; ▁} ▁int ▁sum Of Last N _ Nodes Util ▁( ▁struct ▁Node ▁* ▁head ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁<= ▁0 ▁) ▁return ▁0 ▁; ▁stack ▁< ▁int ▁> ▁st ▁; ▁int ▁sum ▁= ▁0 ▁; ▁while ▁( ▁head ▁!= ▁NULL ▁) ▁{ ▁st ▁. ▁push ▁( ▁head ▁-> ▁data ▁) ▁; ▁head ▁= ▁head ▁-> ▁next ▁; ▁} ▁while ▁( ▁n ▁-- ▁) ▁{ ▁sum ▁+= ▁st ▁. ▁top ▁( ▁) ▁; ▁st ▁. ▁pop ▁( ▁) ▁; ▁} ▁return ▁sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁struct ▁Node ▁* ▁head ▁= ▁NULL ▁; ▁push ▁( ▁& ▁head ▁, ▁12 ▁) ▁; ▁push ▁( ▁& ▁head ▁, ▁4 ▁) ▁; ▁push ▁( ▁& ▁head ▁, ▁8 ▁) ▁; ▁push ▁( ▁& ▁head ▁, ▁6 ▁) ▁; ▁push ▁( ▁& ▁head ▁, ▁10 ▁) ▁; ▁int ▁n ▁= ▁2 ▁; ▁c out ▁<< ▁" ▁Sum ▁of ▁last ▁" ▁<< ▁n ▁<< ▁" ▁nodes ▁= ▁" ▁<< ▁sum Of Last N _ Nodes Util ▁( ▁head ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁struct ▁Node ▁{ ▁int ▁data ▁; ▁struct ▁Node ▁* ▁next ▁; ▁} ▁; ▁void ▁push ▁( ▁struct ▁Node ▁* ▁* ▁head _ ref ▁, ▁int ▁new _ data ▁) ▁{ ▁struct ▁Node ▁* ▁new _ node ▁= ▁new ▁Node ▁; ▁new _ node ▁-> ▁data ▁= ▁new _ data ▁; ▁new _ node ▁-> ▁next ▁= ▁( ▁* ▁head _ ref ▁) ▁; ▁( ▁* ▁head _ ref ▁) ▁= ▁new _ node ▁; ▁} ▁void ▁reverse List ▁( ▁struct ▁Node ▁* ▁* ▁head _ ref ▁) ▁{ ▁struct ▁Node ▁* ▁current ▁, ▁* ▁prev ▁, ▁* ▁next ▁; ▁current ▁= ▁* ▁head _ ref ▁; ▁prev ▁= ▁NULL ▁; ▁while ▁( ▁current ▁!= ▁NULL ▁) ▁{ ▁next ▁= ▁current ▁-> ▁next ▁; ▁current ▁-> ▁next ▁= ▁prev ▁; ▁prev ▁= ▁current ▁; ▁current ▁= ▁next ▁; ▁} ▁* ▁head _ ref ▁= ▁prev ▁; ▁} ▁int ▁sum Of Last N _ Nodes Util ▁( ▁struct ▁Node ▁* ▁head ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁<= ▁0 ▁) ▁return ▁0 ▁; ▁reverse List ▁( ▁& ▁head ▁) ▁; ▁int ▁sum ▁= ▁0 ▁; ▁struct ▁Node ▁* ▁current ▁= ▁head ▁; ▁while ▁( ▁current ▁!= ▁NULL ▁&& ▁n ▁-- ▁) ▁{ ▁sum ▁+= ▁current ▁-> ▁data ▁; ▁current ▁= ▁current ▁-> ▁next ▁; ▁} ▁reverse List ▁( ▁& ▁head ▁) ▁; ▁return ▁sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁struct ▁Node ▁* ▁head ▁= ▁NULL ▁; ▁push ▁( ▁& ▁head ▁, ▁12 ▁) ▁; ▁push ▁( ▁& ▁head ▁, ▁4 ▁) ▁; ▁push ▁( ▁& ▁head ▁, ▁8 ▁) ▁; ▁push ▁( ▁& ▁head ▁, ▁6 ▁) ▁; ▁push ▁( ▁& ▁head ▁, ▁10 ▁) ▁; ▁int ▁n ▁= ▁2 ▁; ▁c out ▁<< ▁" ▁Sum ▁of ▁last ▁" ▁<< ▁n ▁<< ▁" ▁nodes ▁= ▁" ▁<< ▁sum Of Last N _ Nodes Util ▁( ▁head ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁struct ▁Node ▁{ ▁int ▁data ▁; ▁struct ▁Node ▁* ▁next ▁; ▁} ▁; ▁void ▁swap Nodes ▁( ▁struct ▁Node ▁* ▁* ▁head _ ref ▁, ▁struct ▁Node ▁* ▁curr X ▁, ▁struct ▁Node ▁* ▁curr Y ▁, ▁struct ▁Node ▁* ▁prev Y ▁) ▁{ ▁* ▁head _ ref ▁= ▁curr Y ▁; ▁prev Y ▁-> ▁next ▁= ▁curr X ▁; ▁struct ▁Node ▁* ▁temp ▁= ▁curr Y ▁-> ▁next ▁; ▁curr Y ▁-> ▁next ▁= ▁curr X ▁-> ▁next ▁; ▁curr X ▁-> ▁next ▁= ▁temp ▁; ▁} ▁struct ▁Node ▁* ▁rec ur Selection Sort ▁( ▁struct ▁Node ▁* ▁head ▁) ▁{ ▁if ▁( ▁head ▁-> ▁next ▁== ▁NULL ▁) ▁return ▁head ▁; ▁struct ▁Node ▁* ▁min ▁= ▁head ▁; ▁struct ▁Node ▁* ▁before Min ▁= ▁NULL ▁; ▁struct ▁Node ▁* ▁ptr ▁; ▁for ▁( ▁ptr ▁= ▁head ▁; ▁ptr ▁-> ▁next ▁!= ▁NULL ▁; ▁ptr ▁= ▁ptr ▁-> ▁next ▁) ▁{ ▁if ▁( ▁ptr ▁-> ▁next ▁-> ▁data ▁< ▁min ▁-> ▁data ▁) ▁{ ▁min ▁= ▁ptr ▁-> ▁next ▁; ▁before Min ▁= ▁ptr ▁; ▁} ▁} ▁if ▁( ▁min ▁!= ▁head ▁) ▁swap Nodes ▁( ▁& ▁head ▁, ▁head ▁, ▁min ▁, ▁before Min ▁) ▁; ▁head ▁-> ▁next ▁= ▁rec ur Selection Sort ▁( ▁head ▁-> ▁next ▁) ▁; ▁return ▁head ▁; ▁} ▁void ▁sort ▁( ▁struct ▁Node ▁* ▁* ▁head _ ref ▁) ▁{ ▁if ▁( ▁( ▁* ▁head _ ref ▁) ▁== ▁NULL ▁) ▁return ▁; ▁* ▁head _ ref ▁= ▁rec ur Selection Sort ▁( ▁* ▁head _ ref ▁) ▁; ▁} ▁void ▁push ▁( ▁struct ▁Node ▁* ▁* ▁head _ ref ▁, ▁int ▁new _ data ▁) ▁{ ▁struct ▁Node ▁* ▁new _ node ▁= ▁( ▁struct ▁Node ▁* ▁) ▁m alloc ▁( ▁sizeof ▁( ▁struct ▁Node ▁) ▁) ▁; ▁new _ node ▁-> ▁data ▁= ▁new _ data ▁; ▁new _ node ▁-> ▁next ▁= ▁( ▁* ▁head _ ref ▁) ▁; ▁( ▁* ▁head _ ref ▁) ▁= ▁new _ node ▁; ▁} ▁void ▁print List ▁( ▁struct ▁Node ▁* ▁head ▁) ▁{ ▁while ▁( ▁head ▁!= ▁NULL ▁) ▁{ ▁c out ▁<< ▁head ▁-> ▁data ▁<< ▁" ▁" ▁; ▁head ▁= ▁head ▁-> ▁next ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁struct ▁Node ▁* ▁head ▁= ▁NULL ▁; ▁push ▁( ▁& ▁head
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁struct ▁Node ▁{ ▁int ▁data ▁; ▁Node ▁* ▁next ▁, ▁* ▁prev ▁; ▁} ▁; ▁void ▁insert ▁( ▁Node ▁* ▁* ▁head _ ref ▁, ▁int ▁data ▁) ▁{ ▁Node ▁* ▁new _ node ▁= ▁new ▁Node ▁; ▁new _ node ▁-> ▁data ▁= ▁data ▁; ▁if ▁( ▁* ▁head _ ref ▁== ▁NULL ▁) ▁{ ▁new _ node ▁-> ▁next ▁= ▁new _ node ▁; ▁new _ node ▁-> ▁prev ▁= ▁new _ node ▁; ▁} ▁else ▁{ ▁Node ▁* ▁last ▁= ▁( ▁* ▁head _ ref ▁) ▁-> ▁prev ▁; ▁new _ node ▁-> ▁next ▁= ▁* ▁head _ ref ▁; ▁new _ node ▁-> ▁prev ▁= ▁last ▁; ▁last ▁-> ▁next ▁= ▁( ▁* ▁head _ ref ▁) ▁-> ▁prev ▁= ▁new _ node ▁; ▁} ▁* ▁head _ ref ▁= ▁new _ node ▁; ▁} ▁Node ▁* ▁merge ▁( ▁Node ▁* ▁first ▁, ▁Node ▁* ▁second ▁) ▁{ ▁if ▁( ▁! ▁first ▁) ▁return ▁second ▁; ▁if ▁( ▁! ▁second ▁) ▁return ▁first ▁; ▁if ▁( ▁first ▁-> ▁data ▁< ▁second ▁-> ▁data ▁) ▁{ ▁first ▁-> ▁next ▁= ▁merge ▁( ▁first ▁-> ▁next ▁, ▁second ▁) ▁; ▁first ▁-> ▁next ▁-> ▁prev ▁= ▁first ▁; ▁first ▁-> ▁prev ▁= ▁NULL ▁; ▁return ▁first ▁; ▁} ▁else ▁{ ▁second ▁-> ▁next ▁= ▁merge ▁( ▁first ▁, ▁second ▁-> ▁next ▁) ▁; ▁second ▁-> ▁next ▁-> ▁prev ▁= ▁second ▁; ▁second ▁-> ▁prev ▁= ▁NULL ▁; ▁return ▁second ▁; ▁} ▁} ▁Node ▁* ▁merge Util ▁( ▁Node ▁* ▁head 1 ▁, ▁Node ▁* ▁head 2 ▁) ▁{ ▁if ▁( ▁! ▁head 1 ▁) ▁return ▁head 2 ▁; ▁if ▁( ▁! ▁head 2 ▁) ▁return ▁head 1 ▁; ▁Node ▁* ▁last _ node ▁; ▁if ▁( ▁head 1 ▁-> ▁prev ▁-> ▁data ▁< ▁head 2 ▁-> ▁prev ▁-> ▁data ▁) ▁last _ node ▁= ▁head 2 ▁-> ▁prev ▁; ▁else ▁last _ node ▁= ▁head 1 ▁-> ▁prev ▁; ▁head 1 ▁-> ▁prev ▁-> ▁next ▁= ▁head 2 ▁-> ▁prev ▁-> ▁next ▁= ▁NULL ▁; ▁Node ▁* ▁final Head ▁= ▁merge ▁( ▁head 1 ▁, ▁head 2 ▁) ▁; ▁final Head ▁-> ▁prev ▁= ▁last _ node ▁; ▁last _ node ▁-> ▁next ▁= ▁final Head ▁; ▁return ▁final Head ▁; ▁} ▁void ▁print List ▁( ▁Node ▁* ▁head ▁) ▁{
▁# include ▁< i ost ream > ▁NEW _ LINE ▁# include ▁< algorithm > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁string ▁min Lex Rotation ▁( ▁string ▁str ▁) ▁{ ▁int ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁string ▁arr ▁[ ▁n ▁] ▁; ▁string ▁concat ▁= ▁str ▁+ ▁str ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁arr ▁[ ▁i ▁] ▁= ▁concat ▁. ▁substr ▁( ▁i ▁, ▁n ▁) ▁; ▁sort ▁( ▁arr ▁, ▁arr ▁+ ▁n ▁) ▁; ▁return ▁arr ▁[ ▁0 ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁c out ▁<< ▁min Lex Rotation ▁( ▁" ▁G EEK S FOR GE EK S ▁" ▁) ▁<< ▁end l ▁; ▁c out ▁<< ▁min Lex Rotation ▁( ▁" ▁G EEK S QUI Z ▁" ▁) ▁<< ▁end l ▁; ▁c out ▁<< ▁min Lex Rotation ▁( ▁" ▁BC AB D AD AB ▁" ▁) ▁<< ▁end l ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁MAX ▁1000 ▁NEW _ LINE ▁# define ▁log ▁10 ▁NEW _ LINE ▁int ▁level ▁[ ▁MAX ▁] ▁; ▁int ▁l ca ▁[ ▁MAX ▁] ▁[ ▁log ▁] ▁; ▁int ▁min Weight ▁[ ▁MAX ▁] ▁[ ▁log ▁] ▁; ▁int ▁max Weight ▁[ ▁MAX ▁] ▁[ ▁log ▁] ▁; ▁vector ▁< ▁int ▁> ▁graph ▁[ ▁MAX ▁] ▁; ▁int ▁weight ▁[ ▁MAX ▁] ▁; ▁void ▁addEdge ▁( ▁int ▁u ▁, ▁int ▁v ▁) ▁{ ▁graph ▁[ ▁u ▁] ▁. ▁push _ back ▁( ▁v ▁) ▁; ▁graph ▁[ ▁v ▁] ▁. ▁push _ back ▁( ▁u ▁) ▁; ▁} ▁void ▁dfs ▁( ▁int ▁node ▁, ▁int ▁parent ▁, ▁int ▁h ▁) ▁{ ▁l ca ▁[ ▁node ▁] ▁[ ▁0 ▁] ▁= ▁parent ▁; ▁level ▁[ ▁node ▁] ▁= ▁h ▁; ▁if ▁( ▁parent ▁!= ▁-1 ▁) ▁{ ▁min Weight ▁[ ▁node ▁] ▁[ ▁0 ▁] ▁= ▁min ▁( ▁weight ▁[ ▁node ▁] ▁, ▁weight ▁[ ▁parent ▁] ▁) ▁; ▁max Weight ▁[ ▁node ▁] ▁[ ▁0 ▁] ▁= ▁max ▁( ▁weight ▁[ ▁node ▁] ▁, ▁weight ▁[ ▁parent ▁] ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁log ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁l ca ▁[ ▁node ▁] ▁[ ▁i ▁- ▁1 ▁] ▁!= ▁-1 ▁) ▁{ ▁l ca ▁[ ▁node ▁] ▁[ ▁i ▁] ▁= ▁l ca ▁[ ▁l ca ▁[ ▁node ▁] ▁[ ▁i ▁- ▁1 ▁] ▁] ▁[ ▁i ▁- ▁1 ▁] ▁; ▁min Weight ▁[ ▁node ▁] ▁[ ▁i ▁] ▁= ▁min ▁( ▁min Weight ▁[ ▁node ▁] ▁[ ▁i ▁- ▁1 ▁] ▁, ▁min Weight ▁[ ▁l ca ▁[ ▁node ▁] ▁[ ▁i ▁- ▁1 ▁] ▁] ▁[ ▁i ▁- ▁1 ▁] ▁) ▁; ▁max Weight ▁[ ▁node ▁] ▁[ ▁i ▁] ▁= ▁max ▁( ▁max Weight ▁[ ▁node ▁] ▁[ ▁i ▁- ▁1 ▁] ▁, ▁max Weight ▁[ ▁l ca ▁[ ▁node ▁] ▁[ ▁i ▁- ▁1 ▁] ▁] ▁[ ▁i ▁- ▁1 ▁] ▁) ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁: ▁graph ▁[ ▁node ▁] ▁) ▁{ ▁if ▁( ▁i ▁== ▁parent ▁) ▁continue ▁; ▁dfs ▁( ▁i ▁, ▁node ▁, ▁h ▁+ ▁1 ▁) ▁; ▁} ▁} ▁void ▁find Min Max Weight ▁( ▁int ▁u ▁, ▁int ▁v ▁) ▁{ ▁int ▁min We i ▁= ▁INT _
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁int ▁MAX ▁= ▁1000 ▁; ▁int ▁find L CA ▁( ▁int ▁n 1 ▁, ▁int ▁n 2 ▁, ▁int ▁parent ▁[ ▁] ▁) ▁{ ▁vector ▁< ▁bool ▁> ▁visited ▁( ▁MAX ▁, ▁false ▁) ▁; ▁visited ▁[ ▁n 1 ▁] ▁= ▁true ▁; ▁while ▁( ▁parent ▁[ ▁n 1 ▁] ▁!= ▁-1 ▁) ▁{ ▁visited ▁[ ▁n 1 ▁] ▁= ▁true ▁; ▁n 1 ▁= ▁parent ▁[ ▁n 1 ▁] ▁; ▁} ▁visited ▁[ ▁n 1 ▁] ▁= ▁true ▁; ▁while ▁( ▁! ▁visited ▁[ ▁n 2 ▁] ▁) ▁n 2 ▁= ▁parent ▁[ ▁n 2 ▁] ▁; ▁return ▁n 2 ▁; ▁} ▁void ▁insert Adj ▁( ▁int ▁parent ▁[ ▁] ▁, ▁int ▁i ▁, ▁int ▁j ▁) ▁{ ▁parent ▁[ ▁i ▁] ▁= ▁j ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁parent ▁[ ▁MAX ▁] ▁; ▁parent ▁[ ▁20 ▁] ▁= ▁-1 ▁; ▁insert Adj ▁( ▁parent ▁, ▁8 ▁, ▁20 ▁) ▁; ▁insert Adj ▁( ▁parent ▁, ▁22 ▁, ▁20 ▁) ▁; ▁insert Adj ▁( ▁parent ▁, ▁4 ▁, ▁8 ▁) ▁; ▁insert Adj ▁( ▁parent ▁, ▁12 ▁, ▁8 ▁) ▁; ▁insert Adj ▁( ▁parent ▁, ▁10 ▁, ▁12 ▁) ▁; ▁insert Adj ▁( ▁parent ▁, ▁14 ▁, ▁12 ▁) ▁; ▁c out ▁<< ▁find L CA ▁( ▁10 ▁, ▁14 ▁, ▁parent ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁typedef ▁long ▁long ▁int ▁ll ▁; ▁void ▁solve ▁( ▁int ▁N ▁, ▁int ▁M ▁) ▁{ ▁ll ▁ans ▁= ▁( ▁N ▁) ▁* ▁( ▁M ▁/ ▁2 ▁) ▁; ▁if ▁( ▁M ▁% ▁2 ▁== ▁1 ▁) ▁{ ▁ans ▁+= ▁( ▁N ▁+ ▁1 ▁) ▁/ ▁2 ▁; ▁} ▁c out ▁<< ▁ans ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁, ▁M ▁; ▁N ▁= ▁5 ▁; ▁M ▁= ▁3 ▁; ▁solve ▁( ▁N ▁, ▁M ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁# define ▁max _ len ▁10000 5 ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁cnt ▁[ ▁max _ len ▁] ▁; ▁void ▁pre compute ▁( ▁string ▁s ▁, ▁string ▁K ▁) ▁{ ▁int ▁n ▁= ▁s ▁. ▁size ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁cnt ▁[ ▁i ▁+ ▁1 ▁] ▁= ▁cnt ▁[ ▁i ▁] ▁+ ▁( ▁s ▁. ▁substr ▁( ▁i ▁, ▁K ▁. ▁size ▁( ▁) ▁) ▁== ▁K ▁) ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁" ▁ABC ABC AB ABC ▁" ▁; ▁string ▁K ▁= ▁" ▁ABC ▁" ▁; ▁pre compute ▁( ▁s ▁, ▁K ▁) ▁; ▁vector ▁< ▁pair ▁< ▁int ▁, ▁int ▁> ▁> ▁Q ▁= ▁{ ▁{ ▁1 ▁, ▁6 ▁} ▁, ▁{ ▁5 ▁, ▁11 ▁} ▁} ▁; ▁for ▁( ▁auto ▁it ▁: ▁Q ▁) ▁{ ▁c out ▁<< ▁cnt ▁[ ▁it ▁. ▁second ▁- ▁1 ▁] ▁- ▁cnt ▁[ ▁it ▁. ▁first ▁- ▁1 ▁] ▁<< ▁end l ▁; ▁} ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁count Int gr al Points ▁( ▁int ▁x 1 ▁, ▁int ▁y 1 ▁, ▁int ▁x 2 ▁, ▁int ▁y 2 ▁) ▁{ ▁c out ▁<< ▁( ▁y 2 ▁- ▁y 1 ▁- ▁1 ▁) ▁* ▁( ▁x 2 ▁- ▁x 1 ▁- ▁1 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁x 1 ▁= ▁1 ▁, ▁y 1 ▁= ▁1 ▁; ▁int ▁x 2 ▁= ▁4 ▁, ▁y 2 ▁= ▁4 ▁; ▁count Int gr al Points ▁( ▁x 1 ▁, ▁y 1 ▁, ▁x 2 ▁, ▁y 2 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁min Sum ▁( ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁while ▁( ▁n ▁> ▁0 ▁) ▁{ ▁sum ▁+= ▁( ▁n ▁% ▁10 ▁) ▁; ▁n ▁/= ▁10 ▁; ▁} ▁if ▁( ▁sum ▁== ▁1 ▁) ▁return ▁10 ▁; ▁return ▁sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁18 84 ▁; ▁c out ▁<< ▁min Sum ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁repeating Element ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁M ▁= ▁0 ▁, ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁M ▁= ▁max ▁( ▁M ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁int ▁sum 1 ▁= ▁M ▁* ▁( ▁M ▁+ ▁1 ▁) ▁/ ▁2 ▁; ▁int ▁ans ▁= ▁( ▁sum ▁- ▁sum 1 ▁) ▁/ ▁( ▁N ▁- ▁M ▁) ▁; ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁6 ▁, ▁4 ▁, ▁3 ▁, ▁1 ▁, ▁5 ▁, ▁2 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁repeating Element ▁( ▁arr ▁, ▁N ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁calculate Max ▁( ▁int ▁N ▁, ▁int ▁M ▁, ▁int ▁K ▁) ▁{ ▁int ▁ans ▁= ▁-1 ▁; ▁int ▁low ▁= ▁0 ▁, ▁high ▁= ▁M ▁; ▁while ▁( ▁low ▁<= ▁high ▁) ▁{ ▁int ▁mid ▁= ▁( ▁low ▁+ ▁high ▁) ▁/ ▁2 ▁; ▁int ▁val ▁= ▁0 ▁; ▁int ▁L ▁= ▁K ▁- ▁1 ▁; ▁int ▁R ▁= ▁N ▁- ▁K ▁; ▁val ▁+= ▁mid ▁; ▁if ▁( ▁mid ▁>= ▁L ▁) ▁{ ▁val ▁+= ▁( ▁L ▁) ▁* ▁( ▁2 ▁* ▁mid ▁- ▁L ▁- ▁1 ▁) ▁/ ▁2 ▁; ▁} ▁else ▁{ ▁val ▁+= ▁mid ▁* ▁( ▁mid ▁- ▁1 ▁) ▁/ ▁2 ▁+ ▁( ▁L ▁- ▁mid ▁) ▁; ▁} ▁if ▁( ▁mid ▁>= ▁R ▁) ▁{ ▁val ▁+= ▁( ▁R ▁) ▁* ▁( ▁2 ▁* ▁mid ▁- ▁R ▁- ▁1 ▁) ▁/ ▁2 ▁; ▁} ▁else ▁{ ▁val ▁+= ▁mid ▁* ▁( ▁mid ▁- ▁1 ▁) ▁/ ▁2 ▁+ ▁( ▁R ▁- ▁mid ▁) ▁; ▁} ▁if ▁( ▁val ▁<= ▁M ▁) ▁{ ▁ans ▁= ▁max ▁( ▁ans ▁, ▁mid ▁) ▁; ▁low ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁else ▁high ▁= ▁mid ▁- ▁1 ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁7 ▁, ▁M ▁= ▁100 ▁, ▁K ▁= ▁6 ▁; ▁c out ▁<< ▁calculate Max ▁( ▁N ▁, ▁M ▁, ▁K ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find _ index ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁max _ value ▁= ▁INT _ MIN ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁max _ value ▁= ▁max ▁( ▁max _ value ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁map ▁< ▁int ▁, ▁int ▁> ▁store ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁max _ value ▁; ▁i ▁++ ▁) ▁{ ▁store ▁[ ▁i ▁] ▁++ ▁; ▁} ▁if ▁( ▁store ▁. ▁find ▁( ▁1 ▁) ▁!= ▁store ▁. ▁end ▁( ▁) ▁) ▁{ ▁store ▁. ▁erase ▁( ▁1 ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁sqrt ▁( ▁max _ value ▁) ▁; ▁i ▁++ ▁) ▁{ ▁int ▁multiple ▁= ▁2 ▁; ▁while ▁( ▁( ▁i ▁* ▁multiple ▁) ▁<= ▁max _ value ▁) ▁{ ▁if ▁( ▁store ▁. ▁find ▁( ▁i ▁* ▁multiple ▁) ▁!= ▁store ▁. ▁end ▁( ▁) ▁) ▁{ ▁store ▁. ▁erase ▁( ▁i ▁* ▁multiple ▁) ▁; ▁} ▁multiple ▁++ ▁; ▁} ▁} ▁int ▁prime _ sum _ from _ left ▁= ▁0 ▁; ▁int ▁first _ array ▁[ ▁N ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁first _ array ▁[ ▁i ▁] ▁= ▁prime _ sum _ from _ left ▁; ▁if ▁( ▁store ▁. ▁find ▁( ▁arr ▁[ ▁i ▁] ▁) ▁!= ▁store ▁. ▁end ▁( ▁) ▁) ▁{ ▁prime _ sum _ from _ left ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁} ▁int ▁prime _ sum _ from _ right ▁= ▁0 ▁; ▁int ▁second _ array ▁[ ▁N ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁N ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁second _ array ▁[ ▁i ▁] ▁= ▁prime _ sum _ from _ right ▁; ▁if ▁( ▁store ▁. ▁find ▁( ▁arr ▁[ ▁i ▁] ▁) ▁!= ▁store ▁. ▁end ▁( ▁) ▁) ▁{ ▁prime _ sum _ from _ right ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁first _ array ▁[ ▁i ▁] ▁== ▁second _ array ▁[ ▁i ▁] ▁) ▁{ ▁return
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Cost ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁total Cost ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁A ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁A ▁[ ▁i ▁] ▁= ▁1 ▁; ▁total Cost ▁+= ▁i ▁; ▁} ▁} ▁return ▁total Cost ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁find Cost ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is Greater Equal ▁( ▁int ▁N ▁, ▁int ▁K ▁, ▁int ▁X ▁) ▁{ ▁return ▁( ▁( ▁N ▁* ▁1 LL ▁* ▁( ▁N ▁+ ▁1 ▁) ▁/ ▁2 ▁) ▁- ▁( ▁( ▁K ▁- ▁1 ▁) ▁* ▁1 LL ▁* ▁K ▁/ ▁2 ▁) ▁) ▁>= ▁X ▁; ▁} ▁void ▁minimum Number ▁( ▁int ▁K ▁, ▁int ▁X ▁) ▁{ ▁if ▁( ▁K ▁> ▁X ▁) ▁{ ▁c out ▁<< ▁" ▁- ▁1" ▁; ▁return ▁; ▁} ▁int ▁low ▁= ▁K ▁, ▁high ▁= ▁X ▁, ▁res ▁= ▁-1 ▁; ▁while ▁( ▁low ▁<= ▁high ▁) ▁{ ▁int ▁mid ▁= ▁low ▁+ ▁( ▁high ▁- ▁low ▁) ▁/ ▁2 ▁; ▁if ▁( ▁is Greater Equal ▁( ▁mid ▁, ▁K ▁, ▁X ▁) ▁) ▁{ ▁res ▁= ▁mid ▁; ▁high ▁= ▁mid ▁- ▁1 ▁; ▁} ▁else ▁low ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁c out ▁<< ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁K ▁= ▁5 ▁, ▁X ▁= ▁13 ▁; ▁minimum Number ▁( ▁K ▁, ▁X ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁Get Diff ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁S uff Max Arr ▁[ ▁N ▁] ▁; ▁S uff Max Arr ▁[ ▁N ▁- ▁1 ▁] ▁= ▁A ▁[ ▁N ▁- ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁N ▁- ▁2 ▁; ▁i ▁>= ▁0 ▁; ▁-- ▁i ▁) ▁{ ▁S uff Max Arr ▁[ ▁i ▁] ▁= ▁max ▁( ▁S uff Max Arr ▁[ ▁i ▁+ ▁1 ▁] ▁, ▁A ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁; ▁} ▁int ▁Maximum Sum ▁= ▁INT _ MIN ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁A ▁[ ▁i ▁] ▁< ▁S uff Max Arr ▁[ ▁i ▁] ▁) ▁Maximum Sum ▁= ▁max ▁( ▁Maximum Sum ▁, ▁A ▁[ ▁i ▁] ▁+ ▁S uff Max Arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁int ▁Minimum Sum ▁= ▁INT _ MAX ▁; ▁int ▁S uff Min Arr ▁[ ▁N ▁] ▁; ▁S uff Min Arr ▁[ ▁N ▁- ▁1 ▁] ▁= ▁INT _ MAX ▁; ▁for ▁( ▁int ▁i ▁= ▁N ▁- ▁2 ▁; ▁i ▁>= ▁0 ▁; ▁-- ▁i ▁) ▁{ ▁S uff Min Arr ▁[ ▁i ▁] ▁= ▁min ▁( ▁S uff Min Arr ▁[ ▁i ▁+ ▁1 ▁] ▁, ▁A ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁A ▁[ ▁i ▁] ▁< ▁S uff Min Arr ▁[ ▁i ▁] ▁) ▁{ ▁Minimum Sum ▁= ▁min ▁( ▁Minimum Sum ▁, ▁A ▁[ ▁i ▁] ▁+ ▁S uff Min Arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁} ▁return ▁abs ▁( ▁Maximum Sum ▁- ▁Minimum Sum ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁4 ▁, ▁1 ▁, ▁3 ▁, ▁7 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁Get Diff ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁sum Of Digits ▁( ▁string ▁s ▁) ▁{ ▁int ▁curr ▁= ▁0 ▁; ▁int ▁ret ▁= ▁0 ▁; ▁for ▁( ▁auto ▁& ▁ch ▁: ▁s ▁) ▁{ ▁if ▁( ▁isdigit ▁( ▁ch ▁) ▁) ▁{ ▁curr ▁= ▁curr ▁* ▁10 ▁+ ▁ch ▁- ▁'0' ▁; ▁} ▁else ▁{ ▁ret ▁+= ▁curr ▁; ▁curr ▁= ▁0 ▁; ▁} ▁} ▁ret ▁+= ▁curr ▁; ▁return ▁ret ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁S ▁= ▁"11 aa 32 bbb 5" ▁; ▁c out ▁<< ▁sum Of Digits ▁( ▁S ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁minimum Operations ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁odd Cnt ▁= ▁0 ▁, ▁even Cnt ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁even Cnt ▁++ ▁; ▁} ▁else ▁{ ▁odd Cnt ▁++ ▁; ▁} ▁} ▁c out ▁<< ▁min ▁( ▁odd Cnt ▁, ▁even Cnt ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁1 ▁, ▁2 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁minimum Operations ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁check ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁bool ▁flag ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁> ▁a ▁[ ▁i ▁] ▁&& ▁a ▁[ ▁i ▁] ▁< ▁a ▁[ ▁i ▁- ▁1 ▁] ▁) ▁flag ▁= ▁1 ▁; ▁} ▁if ▁( ▁flag ▁) ▁return ▁false ▁; ▁else ▁return ▁true ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁5 ▁, ▁2 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁if ▁( ▁check ▁( ▁arr ▁, ▁N ▁) ▁) ▁c out ▁<< ▁" ▁YES ▁" ▁; ▁else ▁c out ▁<< ▁" ▁NO ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁min Operations ▁( ▁string ▁& ▁S ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁S ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁S ▁[ ▁i ▁] ▁!= ▁S ▁[ ▁i ▁- ▁1 ▁] ▁) ▁{ ▁count ▁+= ▁1 ▁; ▁} ▁} ▁c out ▁<< ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁S ▁= ▁" 0101 0101 01" ▁; ▁min Operations ▁( ▁S ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁numberOf Pairs ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁set _ bits ▁[ ▁31 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁int ▁x ▁= ▁arr ▁[ ▁i ▁] ▁; ▁int ▁bit pos ▁= ▁-1 ▁; ▁while ▁( ▁x ▁> ▁0 ▁) ▁{ ▁bit pos ▁++ ▁; ▁x ▁/= ▁2 ▁; ▁} ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁<= ▁bit pos ▁; ▁j ▁++ ▁) ▁{ ▁count ▁+= ▁set _ bits ▁[ ▁j ▁] ▁; ▁} ▁set _ bits ▁[ ▁bit pos ▁] ▁++ ▁; ▁} ▁c out ▁<< ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁16 ▁, ▁8 ▁, ▁64 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁numberOf Pairs ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Maximum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁Q ▁, ▁int ▁queries ▁[ ▁] ▁[ ▁2 ▁] ▁) ▁{ ▁int ▁prefix _ max ▁[ ▁N ▁+ ▁1 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁int ▁suffix _ max ▁[ ▁N ▁+ ▁1 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁prefix _ max ▁[ ▁0 ▁] ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁prefix _ max ▁[ ▁i ▁] ▁= ▁max ▁( ▁prefix _ max ▁[ ▁i ▁- ▁1 ▁] ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁suffix _ max ▁[ ▁N ▁- ▁1 ▁] ▁= ▁arr ▁[ ▁N ▁- ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁N ▁- ▁2 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁suffix _ max ▁[ ▁i ▁] ▁= ▁max ▁( ▁suffix _ max ▁[ ▁i ▁+ ▁1 ▁] ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁Q ▁; ▁i ▁++ ▁) ▁{ ▁int ▁l ▁= ▁queries ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁; ▁int ▁r ▁= ▁queries ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁; ▁if ▁( ▁l ▁== ▁0 ▁&& ▁r ▁== ▁( ▁N ▁- ▁1 ▁) ▁) ▁c out ▁<< ▁"0 ▁STRNEWLINE ▁" ▁; ▁else ▁if ▁( ▁l ▁== ▁0 ▁) ▁c out ▁<< ▁suffix _ max ▁[ ▁r ▁+ ▁1 ▁] ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁else ▁if ▁( ▁r ▁== ▁( ▁N ▁- ▁1 ▁) ▁) ▁c out ▁<< ▁prefix _ max ▁[ ▁l ▁- ▁1 ▁] ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁else ▁c out ▁<< ▁max ▁( ▁prefix _ max ▁[ ▁l ▁- ▁1 ▁] ▁, ▁suffix _ max ▁[ ▁r ▁+ ▁1 ▁] ▁) ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁6 ▁, ▁8 ▁, ▁10 ▁, ▁15 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁queries ▁[ ▁] ▁[ ▁2 ▁] ▁= ▁{ ▁{ ▁0 ▁, ▁1 ▁} ▁, ▁{ ▁0 ▁, ▁2 ▁} ▁, ▁{ ▁1 ▁, ▁4 ▁} ▁} ▁; ▁int ▁Q ▁= ▁sizeof ▁( ▁queries ▁) ▁/ ▁sizeof ▁( ▁queries ▁[ ▁0 ▁] ▁) ▁;
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁string ▁min Email ▁( ▁string ▁email ▁) ▁{ ▁string ▁ans ▁= ▁" ▁" ▁; ▁int ▁len ▁= ▁email ▁. ▁length ▁( ▁) ▁; ▁ans ▁+= ▁email ▁[ ▁0 ▁] ▁; ▁int ▁i ▁= ▁1 ▁; ▁bool ▁not At ▁= ▁true ▁; ▁while ▁( ▁i ▁< ▁len ▁) ▁{ ▁if ▁( ▁i ▁< ▁len ▁- ▁3 ▁&& ▁not At ▁&& ▁email ▁[ ▁i ▁] ▁== ▁' ▁a ▁' ▁&& ▁email ▁[ ▁i ▁+ ▁1 ▁] ▁== ▁' ▁t ▁' ▁) ▁{ ▁ans ▁+= ▁' ▁@ ▁' ▁; ▁i ▁+= ▁1 ▁; ▁not At ▁= ▁false ▁; ▁} ▁else ▁if ▁( ▁i ▁< ▁len ▁- ▁4 ▁&& ▁email ▁[ ▁i ▁] ▁== ▁' ▁d ▁' ▁&& ▁email ▁[ ▁i ▁+ ▁1 ▁] ▁== ▁' ▁o ▁' ▁&& ▁email ▁[ ▁i ▁+ ▁2 ▁] ▁== ▁' ▁t ▁' ▁) ▁{ ▁ans ▁+= ▁' ▁. ▁' ▁; ▁i ▁+= ▁2 ▁; ▁} ▁else ▁{ ▁ans ▁+= ▁email ▁[ ▁i ▁] ▁; ▁} ▁i ▁+= ▁1 ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁email ▁= ▁" ▁g eek s forge ek sat g ma ild ot com ▁" ▁; ▁c out ▁<< ▁( ▁min Email ▁( ▁email ▁) ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁count Remaining Elements ▁( ▁int ▁L 1 ▁[ ▁] ▁, ▁int ▁L 2 ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁one ▁= ▁0 ▁; ▁int ▁zero ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁L 1 ▁[ ▁i ▁] ▁== ▁1 ▁) ▁one ▁++ ▁; ▁else ▁zero ▁++ ▁; ▁} ▁int ▁ans ▁= ▁n ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁L 2 ▁[ ▁i ▁] ▁== ▁1 ▁) ▁{ ▁one ▁-- ▁; ▁if ▁( ▁one ▁< ▁0 ▁) ▁{ ▁ans ▁= ▁i ▁; ▁break ▁; ▁} ▁} ▁else ▁{ ▁zero ▁-- ▁; ▁if ▁( ▁zero ▁< ▁0 ▁) ▁{ ▁ans ▁= ▁i ▁; ▁break ▁; ▁} ▁} ▁} ▁c out ▁<< ▁n ▁- ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁L 1 ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁1 ▁, ▁0 ▁, ▁0 ▁} ▁; ▁int ▁L 2 ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁L 1 ▁) ▁/ ▁sizeof ▁( ▁L 1 ▁[ ▁0 ▁] ▁) ▁; ▁count Remaining Elements ▁( ▁L 1 ▁, ▁L 2 ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁" ▁bits ▁/ ▁std c ▁+ ▁+ ▁. ▁h ▁" ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁L CM ▁( ▁int ▁A ▁, ▁int ▁B ▁) ▁{ ▁return ▁( ▁A ▁* ▁B ▁/ ▁__ g cd ▁( ▁A ▁, ▁B ▁) ▁) ▁; ▁} ▁int ▁find Small est Number ▁( ▁int ▁X ▁) ▁{ ▁int ▁l cm ▁= ▁1 ▁; ▁int ▁temp ▁= ▁X ▁; ▁while ▁( ▁temp ▁) ▁{ ▁int ▁last ▁= ▁temp ▁% ▁10 ▁; ▁temp ▁/= ▁10 ▁; ▁if ▁( ▁! ▁last ▁) ▁continue ▁; ▁l cm ▁= ▁L CM ▁( ▁l cm ▁, ▁last ▁) ▁; ▁} ▁int ▁answer ▁= ▁( ▁( ▁X ▁+ ▁l cm ▁- ▁1 ▁) ▁/ ▁l cm ▁) ▁* ▁l cm ▁; ▁c out ▁<< ▁answer ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁X ▁= ▁2 80 ▁; ▁find Small est Number ▁( ▁X ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Non Multi ples ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁set ▁< ▁int ▁> ▁multiples ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁multiples ▁. ▁find ▁( ▁arr ▁[ ▁i ▁] ▁) ▁== ▁multiples ▁. ▁end ▁( ▁) ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁<= ▁k ▁/ ▁arr ▁[ ▁i ▁] ▁; ▁j ▁++ ▁) ▁{ ▁multiples ▁. ▁insert ▁( ▁arr ▁[ ▁i ▁] ▁* ▁j ▁) ▁; ▁} ▁} ▁} ▁return ▁k ▁- ▁multiples ▁. ▁size ▁( ▁) ▁; ▁} ▁int ▁count Values ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁L ▁, ▁int ▁R ▁) ▁{ ▁return ▁find Non Multi ples ▁( ▁arr ▁, ▁N ▁, ▁R ▁) ▁- ▁find Non Multi ples ▁( ▁arr ▁, ▁N ▁, ▁L ▁- ▁1 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁L ▁= ▁1 ▁, ▁R ▁= ▁20 ▁; ▁c out ▁<< ▁count Values ▁( ▁arr ▁, ▁N ▁, ▁L ▁, ▁R ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Cnt Tri plet ▁( ▁int ▁N ▁) ▁{ ▁int ▁cnt Tri plet ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁N ▁% ▁i ▁!= ▁0 ▁) ▁{ ▁cnt Tri plet ▁+= ▁N ▁/ ▁i ▁; ▁} ▁else ▁{ ▁cnt Tri plet ▁+= ▁( ▁N ▁/ ▁i ▁) ▁- ▁1 ▁; ▁} ▁} ▁return ▁cnt Tri plet ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁3 ▁; ▁c out ▁<< ▁find Cnt Tri plet ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁min Collect ing Speed ▁( ▁vector ▁< ▁int ▁> ▁& ▁p iles ▁, ▁int ▁H ▁) ▁{ ▁int ▁ans ▁= ▁-1 ▁; ▁int ▁low ▁= ▁1 ▁, ▁high ▁; ▁high ▁= ▁* ▁max _ element ▁( ▁p iles ▁. ▁begin ▁( ▁) ▁, ▁p iles ▁. ▁end ▁( ▁) ▁) ▁; ▁while ▁( ▁low ▁<= ▁high ▁) ▁{ ▁int ▁K ▁= ▁low ▁+ ▁( ▁high ▁- ▁low ▁) ▁/ ▁2 ▁; ▁int ▁time ▁= ▁0 ▁; ▁for ▁( ▁int ▁ai ▁: ▁p iles ▁) ▁{ ▁time ▁+= ▁( ▁ai ▁+ ▁K ▁- ▁1 ▁) ▁/ ▁K ▁; ▁} ▁if ▁( ▁time ▁<= ▁H ▁) ▁{ ▁ans ▁= ▁K ▁; ▁high ▁= ▁K ▁- ▁1 ▁; ▁} ▁else ▁{ ▁low ▁= ▁K ▁+ ▁1 ▁; ▁} ▁} ▁c out ▁<< ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁int ▁> ▁arr ▁= ▁{ ▁3 ▁, ▁6 ▁, ▁7 ▁, ▁11 ▁} ▁; ▁int ▁H ▁= ▁8 ▁; ▁min Collect ing Speed ▁( ▁arr ▁, ▁H ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Sub Array Sign Change ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁unordered _ map ▁< ▁int ▁, ▁int ▁> ▁prefix Count ▁; ▁unordered _ map ▁< ▁int ▁, ▁int ▁> ▁suffix Count ▁; ▁int ▁total ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁N ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁total ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁suffix Count ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁++ ▁; ▁} ▁int ▁prefix Sum ▁= ▁0 ▁; ▁int ▁suffix Sum ▁= ▁0 ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁prefix Sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁prefix Count ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁++ ▁; ▁suffix Sum ▁= ▁total ▁- ▁prefix Sum ▁; ▁suffix Count ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁-- ▁; ▁int ▁diff ▁= ▁prefix Sum ▁- ▁suffix Sum ▁; ▁if ▁( ▁diff ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁int ▁x ▁= ▁prefix Count ▁+ ▁suffix Count ▁[ ▁- ▁diff ▁/ ▁2 ▁] ▁; ▁count ▁= ▁count ▁+ ▁x ▁; ▁} ▁} ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁2 ▁, ▁-3 ▁, ▁3 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁count Sub Array Sign Change ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Common Char ▁( ▁int ▁ind ▁, ▁string ▁& ▁S ▁) ▁{ ▁int ▁cnt ▁= ▁0 ▁; ▁set ▁< ▁char ▁> ▁ls ▁; ▁set ▁< ▁char ▁> ▁rs ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁ind ▁; ▁++ ▁i ▁) ▁{ ▁ls ▁. ▁insert ▁( ▁S ▁[ ▁i ▁] ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁ind ▁; ▁i ▁< ▁S ▁. ▁length ▁( ▁) ▁; ▁++ ▁i ▁) ▁{ ▁rs ▁. ▁insert ▁( ▁S ▁[ ▁i ▁] ▁) ▁; ▁} ▁for ▁( ▁auto ▁v ▁: ▁ls ▁) ▁{ ▁if ▁( ▁rs ▁. ▁count ▁( ▁v ▁) ▁) ▁{ ▁++ ▁cnt ▁; ▁} ▁} ▁return ▁cnt ▁; ▁} ▁void ▁partition String With Max Com ▁( ▁string ▁& ▁S ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁S ▁. ▁length ▁( ▁) ▁; ▁++ ▁i ▁) ▁{ ▁ans ▁= ▁max ▁( ▁ans ▁, ▁count Common Char ▁( ▁i ▁, ▁S ▁) ▁) ▁; ▁} ▁c out ▁<< ▁ans ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁a abb ca ▁" ▁; ▁partition String With Max Com ▁( ▁str ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁string ▁Small est String ▁( ▁string ▁s ▁, ▁char ▁c ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁[ ▁i ▁] ▁> ▁c ▁) ▁{ ▁s ▁. ▁insert ▁( ▁i ▁, ▁1 ▁, ▁c ▁) ▁; ▁return ▁s ▁; ▁} ▁} ▁s ▁+= ▁c ▁; ▁return ▁s ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁S ▁= ▁" ▁ac d ▁" ▁; ▁char ▁C ▁= ▁' ▁b ▁' ▁; ▁c out ▁<< ▁Small est String ▁( ▁S ▁, ▁C ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁typedef ▁long ▁long ▁ll ▁; ▁ll ▁sum Of Path Nodes ▁( ▁ll ▁N ▁) ▁{ ▁if ▁( ▁N ▁== ▁1 ▁) ▁{ ▁return ▁1 ▁; ▁} ▁else ▁if ▁( ▁N ▁== ▁2 ▁N ▁== ▁3 ▁) ▁{ ▁return ▁N ▁+ ▁1 ▁; ▁} ▁vector ▁< ▁ll ▁> ▁arr ▁; ▁arr ▁. ▁push _ back ▁( ▁1 ▁) ▁; ▁ll ▁k ▁= ▁1 ▁; ▁bool ▁flag ▁= ▁true ▁; ▁while ▁( ▁k ▁< ▁N ▁) ▁{ ▁if ▁( ▁flag ▁== ▁true ▁) ▁{ ▁k ▁*= ▁2 ▁; ▁flag ▁= ▁false ▁; ▁} ▁else ▁{ ▁k ▁*= ▁4 ▁; ▁flag ▁= ▁true ▁; ▁} ▁if ▁( ▁k ▁> ▁N ▁) ▁{ ▁break ▁; ▁} ▁arr ▁. ▁push _ back ▁( ▁k ▁) ▁; ▁} ▁ll ▁len ▁= ▁arr ▁. ▁size ▁( ▁) ▁; ▁vector ▁< ▁ll ▁> ▁prefix ▁( ▁len ▁) ▁; ▁prefix ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁for ▁( ▁ll ▁i ▁= ▁1 ▁; ▁i ▁< ▁len ▁; ▁++ ▁i ▁) ▁{ ▁prefix ▁[ ▁i ▁] ▁= ▁arr ▁[ ▁i ▁] ▁+ ▁prefix ▁[ ▁i ▁- ▁1 ▁] ▁; ▁} ▁vector ▁< ▁ll ▁> ▁:: ▁iterator ▁it ▁= ▁lower _ bound ▁( ▁prefix ▁. ▁begin ▁( ▁) ▁, ▁prefix ▁. ▁end ▁( ▁) ▁, ▁N ▁) ▁; ▁ll ▁ind ▁= ▁it ▁- ▁prefix ▁. ▁begin ▁( ▁) ▁; ▁ll ▁final _ ans ▁= ▁0 ▁; ▁ll ▁temp ▁= ▁N ▁; ▁while ▁( ▁ind ▁> ▁1 ▁) ▁{ ▁ll ▁val ▁= ▁temp ▁- ▁prefix ▁[ ▁ind ▁- ▁1 ▁] ▁; ▁if ▁( ▁ind ▁% ▁2 ▁!= ▁0 ▁) ▁{ ▁temp ▁= ▁prefix ▁[ ▁ind ▁- ▁2 ▁] ▁+ ▁( ▁val ▁+ ▁1 ▁) ▁/ ▁2 ▁; ▁} ▁else ▁{ ▁temp ▁= ▁prefix ▁[ ▁ind ▁- ▁2 ▁] ▁+ ▁( ▁val ▁+ ▁3 ▁) ▁/ ▁4 ▁; ▁} ▁-- ▁ind ▁; ▁final _ ans ▁+= ▁temp ▁; ▁} ▁final _ ans ▁+= ▁( ▁N ▁+ ▁1 ▁) ▁; ▁return ▁final _ ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁ll ▁N ▁= ▁13 ▁; ▁c out ▁<< ▁sum Of Path Nodes ▁( ▁N ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁re arrange Array ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁a ▁[ ▁i ▁] ▁; ▁} ▁if ▁( ▁sum ▁== ▁0 ▁) ▁{ ▁c out ▁<< ▁" ▁- ▁1" ▁; ▁return ▁; ▁} ▁sum ▁= ▁0 ▁; ▁int ▁b ▁= ▁0 ▁; ▁sort ▁( ▁a ▁, ▁a ▁+ ▁N ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁a ▁[ ▁i ▁] ▁; ▁if ▁( ▁sum ▁== ▁0 ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁!= ▁a ▁[ ▁N ▁- ▁1 ▁] ▁) ▁{ ▁sum ▁-= ▁a ▁[ ▁i ▁] ▁; ▁swap ▁( ▁a ▁[ ▁i ▁] ▁, ▁a ▁[ ▁N ▁- ▁1 ▁] ▁) ▁; ▁sum ▁+= ▁a ▁[ ▁i ▁] ▁; ▁} ▁else ▁{ ▁b ▁= ▁1 ▁; ▁break ▁; ▁} ▁} ▁} ▁if ▁( ▁b ▁== ▁1 ▁) ▁{ ▁b ▁= ▁0 ▁; ▁sum ▁= ▁0 ▁; ▁sort ▁( ▁a ▁, ▁a ▁+ ▁N ▁, ▁greater ▁< ▁int ▁> ▁( ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁N ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁sum ▁+= ▁a ▁[ ▁i ▁] ▁; ▁if ▁( ▁sum ▁== ▁0 ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁!= ▁a ▁[ ▁0 ▁] ▁) ▁{ ▁sum ▁-= ▁a ▁[ ▁i ▁] ▁; ▁swap ▁( ▁a ▁[ ▁i ▁] ▁, ▁a ▁[ ▁0 ▁] ▁) ▁; ▁sum ▁+= ▁a ▁[ ▁i ▁] ▁; ▁} ▁else ▁{ ▁b ▁= ▁1 ▁; ▁break ▁; ▁} ▁} ▁} ▁} ▁if ▁( ▁b ▁== ▁1 ▁) ▁{ ▁c out ▁<< ▁" ▁- ▁1" ▁; ▁return ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁c out ▁<< ▁a ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁-1 ▁, ▁2 ▁, ▁4 ▁, ▁0 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁re arrange Array ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find Minimum Operations ▁( ▁string ▁a ▁, ▁string ▁b ▁) ▁{ ▁int ▁step ▁= ▁0 ▁; ▁int ▁last _ index ▁; ▁while ▁( ▁a ▁!= ▁b ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁a ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁!= ▁b ▁[ ▁i ▁] ▁) ▁{ ▁last _ index ▁= ▁i ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁last _ index ▁; ▁i ▁++ ▁) ▁{ ▁a ▁[ ▁i ▁] ▁= ▁( ▁a ▁[ ▁i ▁] ▁== ▁'0' ▁) ▁? ▁'1' ▁: ▁'0' ▁; ▁} ▁step ▁++ ▁; ▁} ▁c out ▁<< ▁step ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁A ▁= ▁"1 0101 0" ▁, ▁B ▁= ▁"11 00 11" ▁; ▁find Minimum Operations ▁( ▁A ▁, ▁B ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is Prime ▁( ▁int ▁num ▁) ▁{ ▁if ▁( ▁num ▁<= ▁1 ▁) ▁return ▁false ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁* ▁i ▁<= ▁num ▁; ▁i ▁++ ▁) ▁if ▁( ▁num ▁% ▁i ▁== ▁0 ▁) ▁return ▁false ▁; ▁return ▁true ▁; ▁} ▁bool ▁isF ul Prime ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁! ▁is Prime ▁( ▁n ▁) ▁) ▁return ▁false ▁; ▁else ▁{ ▁while ▁( ▁n ▁> ▁0 ▁) ▁{ ▁int ▁rem ▁= ▁n ▁% ▁10 ▁; ▁if ▁( ▁! ▁( ▁rem ▁== ▁2 ▁rem ▁== ▁3 ▁rem ▁== ▁5 ▁rem ▁== ▁7 ▁) ▁) ▁return ▁false ▁; ▁n ▁= ▁n ▁/ ▁10 ▁; ▁} ▁} ▁return ▁true ▁; ▁} ▁int ▁count F ul Prime ▁( ▁int ▁L ▁, ▁int ▁R ▁) ▁{ ▁int ▁cnt ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁L ▁; ▁i ▁<= ▁R ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁i ▁% ▁2 ▁) ▁!= ▁0 ▁&& ▁isF ul Prime ▁( ▁i ▁) ▁) ▁{ ▁cnt ▁++ ▁; ▁} ▁} ▁return ▁cnt ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁L ▁= ▁1 ▁, ▁R ▁= ▁100 ▁; ▁int ▁ans ▁= ▁0 ▁; ▁if ▁( ▁L ▁< ▁3 ▁) ▁ans ▁++ ▁; ▁c out ▁<< ▁ans ▁+ ▁count F ul Prime ▁( ▁L ▁, ▁R ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁" ▁bits ▁/ ▁std c ▁+ ▁+ ▁. ▁h ▁" ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is _ prime ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁<= ▁1 ▁) ▁return ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁* ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁return ▁0 ▁; ▁} ▁return ▁1 ▁; ▁} ▁void ▁count Small er Pr imes ▁( ▁int ▁ar ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁ar ▁[ ▁j ▁] ▁<= ▁ar ▁[ ▁i ▁] ▁&& ▁is _ prime ▁( ▁ar ▁[ ▁j ▁] ▁) ▁) ▁{ ▁count ▁++ ▁; ▁} ▁} ▁c out ▁<< ▁count ▁<< ▁" ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁ar ▁[ ▁] ▁= ▁{ ▁43 ▁, ▁3 ▁, ▁5 ▁, ▁7 ▁, ▁2 ▁, ▁41 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁ar ▁/ ▁sizeof ▁ar ▁[ ▁0 ▁] ▁; ▁count Small er Pr imes ▁( ▁ar ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁min Length ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁0 ▁] ▁!= ▁arr ▁[ ▁i ▁] ▁) ▁{ ▁return ▁1 ▁; ▁} ▁} ▁return ▁N ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁1 ▁, ▁3 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁min Length ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁num Special ▁( ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁& ▁mat ▁) ▁{ ▁int ▁m ▁= ▁mat ▁. ▁size ▁( ▁) ▁, ▁n ▁= ▁mat ▁[ ▁0 ▁] ▁. ▁size ▁( ▁) ▁; ▁int ▁rows ▁[ ▁m ▁] ▁; ▁int ▁cols ▁[ ▁n ▁] ▁; ▁int ▁i ▁, ▁j ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁m ▁; ▁i ▁++ ▁) ▁{ ▁rows ▁[ ▁i ▁] ▁= ▁0 ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁rows ▁[ ▁i ▁] ▁+= ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁cols ▁[ ▁i ▁] ▁= ▁0 ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁m ▁; ▁j ▁++ ▁) ▁cols ▁[ ▁i ▁] ▁+= ▁mat ▁[ ▁j ▁] ▁[ ▁i ▁] ▁; ▁} ▁int ▁cnt ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁m ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁== ▁1 ▁&& ▁rows ▁[ ▁i ▁] ▁== ▁1 ▁&& ▁cols ▁[ ▁j ▁] ▁== ▁1 ▁) ▁cnt ▁++ ▁; ▁} ▁} ▁return ▁cnt ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁mat ▁= ▁{ ▁{ ▁1 ▁, ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁0 ▁, ▁0 ▁, ▁1 ▁} ▁, ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁} ▁} ▁; ▁c out ▁<< ▁num Special ▁( ▁mat ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁vector ▁< ▁int ▁> ▁min max Numbers ▁( ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁& ▁matrix ▁, ▁vector ▁< ▁int ▁> ▁& ▁res ▁) ▁{ ▁unordered _ set ▁< ▁int ▁> ▁set ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁matrix ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁int ▁min r ▁= ▁INT _ MAX ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁matrix ▁[ ▁i ▁] ▁. ▁size ▁( ▁) ▁; ▁j ▁++ ▁) ▁{ ▁min r ▁= ▁min ▁( ▁min r ▁, ▁matrix ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁; ▁} ▁set ▁. ▁insert ▁( ▁min r ▁) ▁; ▁} ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁matrix ▁[ ▁0 ▁] ▁. ▁size ▁( ▁) ▁; ▁j ▁++ ▁) ▁{ ▁int ▁max c ▁= ▁INT _ MIN ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁matrix ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁max c ▁= ▁max ▁( ▁max c ▁, ▁matrix ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁; ▁} ▁if ▁( ▁set ▁. ▁find ▁( ▁max c ▁) ▁!= ▁set ▁. ▁end ▁( ▁) ▁) ▁{ ▁res ▁. ▁push _ back ▁( ▁max c ▁) ▁; ▁} ▁} ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁mat ▁= ▁{ ▁{ ▁1 ▁, ▁10 ▁, ▁4 ▁} ▁, ▁{ ▁9 ▁, ▁3 ▁, ▁8 ▁} ▁, ▁{ ▁15 ▁, ▁16 ▁, ▁17 ▁} ▁} ▁; ▁vector ▁< ▁int ▁> ▁ans ▁; ▁min max Numbers ▁( ▁mat ▁, ▁ans ▁) ▁; ▁if ▁( ▁ans ▁. ▁size ▁( ▁) ▁== ▁0 ▁) ▁c out ▁<< ▁" ▁- ▁1" ▁<< ▁end l ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁ans ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁ans ▁[ ▁i ▁] ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Prec ed ing K ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁K ▁) ▁{ ▁int ▁prefix ▁[ ▁n ▁] ▁; ▁prefix ▁[ ▁0 ▁] ▁= ▁a ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁prefix ▁[ ▁i ▁] ▁= ▁prefix ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁a ▁[ ▁i ▁] ▁; ▁} ▁int ▁ctr ▁= ▁0 ▁; ▁if ▁( ▁prefix ▁[ ▁K ▁- ▁1 ▁] ▁< ▁a ▁[ ▁K ▁] ▁) ▁ctr ▁++ ▁; ▁for ▁( ▁int ▁i ▁= ▁K ▁+ ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁prefix ▁[ ▁i ▁- ▁1 ▁] ▁- ▁prefix ▁[ ▁i ▁- ▁K ▁- ▁1 ▁] ▁< ▁a ▁[ ▁i ▁] ▁) ▁ctr ▁++ ▁; ▁} ▁return ▁ctr ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁8 ▁, ▁10 ▁, ▁-2 ▁, ▁7 ▁, ▁5 ▁, ▁5 ▁, ▁9 ▁, ▁15 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁K ▁= ▁2 ▁; ▁c out ▁<< ▁count Prec ed ing K ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁M ▁1000 ▁NEW _ LINE ▁int ▁count Num ▁( ▁int ▁N ▁, ▁int ▁sum ▁, ▁int ▁K ▁, ▁bool ▁st ▁, ▁int ▁dp ▁[ ▁M ▁] ▁[ ▁M ▁] ▁[ ▁2 ▁] ▁) ▁{ ▁if ▁( ▁N ▁== ▁0 ▁and ▁sum ▁== ▁0 ▁) ▁{ ▁return ▁1 ▁; ▁} ▁if ▁( ▁N ▁< ▁0 ▁) ▁{ ▁return ▁0 ▁; ▁} ▁if ▁( ▁dp ▁[ ▁N ▁] ▁[ ▁sum ▁] ▁[ ▁st ▁] ▁!= ▁-1 ▁) ▁{ ▁return ▁dp ▁[ ▁N ▁] ▁[ ▁sum ▁] ▁[ ▁st ▁] ▁; ▁} ▁int ▁res ▁= ▁0 ▁; ▁int ▁start ▁= ▁st ▁== ▁1 ▁? ▁0 ▁: ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁start ▁; ▁i ▁<= ▁9 ▁; ▁i ▁++ ▁) ▁{ ▁res ▁+= ▁count Num ▁( ▁N ▁- ▁1 ▁, ▁( ▁sum ▁+ ▁i ▁) ▁% ▁K ▁, ▁K ▁, ▁( ▁st ▁i ▁> ▁0 ▁) ▁, ▁dp ▁) ▁; ▁} ▁return ▁dp ▁[ ▁N ▁] ▁[ ▁sum ▁] ▁[ ▁st ▁] ▁= ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁2 ▁, ▁K ▁= ▁7 ▁; ▁int ▁dp ▁[ ▁M ▁] ▁[ ▁M ▁] ▁[ ▁2 ▁] ▁; ▁mem set ▁( ▁dp ▁, ▁-1 ▁, ▁sizeof ▁( ▁dp ▁) ▁) ▁; ▁c out ▁<< ▁count Num ▁( ▁N ▁, ▁0 ▁, ▁K ▁, ▁0 ▁, ▁dp ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁min Deletion ▁( ▁string ▁str ▁) ▁{ ▁int ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁int ▁first Idx 1 ▁= ▁-1 ▁; ▁int ▁last Idx 0 ▁= ▁-1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁str ▁[ ▁i ▁] ▁== ▁'1' ▁) ▁{ ▁first Idx 1 ▁= ▁i ▁; ▁break ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁str ▁[ ▁i ▁] ▁== ▁'0' ▁) ▁{ ▁last Idx 0 ▁= ▁i ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁first Idx 1 ▁== ▁-1 ▁last Idx 0 ▁== ▁-1 ▁) ▁return ▁0 ▁; ▁int ▁count 1 ▁= ▁0 ▁, ▁count 0 ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁last Idx 0 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁str ▁[ ▁i ▁] ▁== ▁'1' ▁) ▁{ ▁count 1 ▁++ ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁first Idx 1 ▁+ ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁str ▁[ ▁i ▁] ▁== ▁'1' ▁) ▁{ ▁count 0 ▁++ ▁; ▁} ▁} ▁return ▁min ▁( ▁count 0 ▁, ▁count 1 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁"100 01 01" ▁; ▁c out ▁<< ▁min Deletion ▁( ▁str ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print _ substring ▁( ▁string ▁s ▁) ▁{ ▁int ▁n ▁= ▁s ▁. ▁size ▁( ▁) ▁; ▁string ▁str ▁= ▁" ▁" ▁; ▁vector ▁< ▁int ▁> ▁ans ▁; ▁if ▁( ▁n ▁== ▁0 ▁) ▁{ ▁c out ▁<< ▁" ▁- ▁1" ▁; ▁return ▁; ▁} ▁vector ▁< ▁int ▁> ▁last _ pos ▁( ▁26 ▁, ▁-1 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁-- ▁i ▁) ▁{ ▁if ▁( ▁last _ pos ▁[ ▁s ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁] ▁== ▁-1 ▁) ▁{ ▁last _ pos ▁[ ▁s ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁] ▁= ▁i ▁; ▁} ▁} ▁int ▁min p ▁= ▁-1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁{ ▁int ▁lp ▁= ▁last _ pos ▁[ ▁s ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁] ▁; ▁min p ▁= ▁max ▁( ▁min p ▁, ▁lp ▁) ▁; ▁if ▁( ▁i ▁== ▁min p ▁) ▁{ ▁str ▁+= ▁s ▁[ ▁i ▁] ▁; ▁c out ▁<< ▁str ▁<< ▁' ▁' ▁; ▁min p ▁= ▁-1 ▁; ▁str ▁= ▁" ▁" ▁; ▁} ▁else ▁{ ▁str ▁+= ▁s ▁[ ▁i ▁] ▁; ▁} ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁S ▁= ▁" ▁ab ab cb ac ad ef eg de hi jh k li j ▁" ▁; ▁print _ substring ▁( ▁S ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁partition String ▁( ▁string ▁s ▁) ▁{ ▁int ▁n ▁= ▁s ▁. ▁size ▁( ▁) ▁; ▁vector ▁< ▁int ▁> ▁ans ▁; ▁if ▁( ▁n ▁== ▁0 ▁) ▁{ ▁c out ▁<< ▁" ▁- ▁1" ▁; ▁return ▁; ▁} ▁vector ▁< ▁int ▁> ▁last _ pos ▁( ▁26 ▁, ▁-1 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁-- ▁i ▁) ▁{ ▁if ▁( ▁last _ pos ▁[ ▁s ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁] ▁== ▁-1 ▁) ▁{ ▁last _ pos ▁[ ▁s ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁] ▁= ▁i ▁; ▁} ▁} ▁int ▁min p ▁= ▁-1 ▁, ▁pl en ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁{ ▁int ▁lp ▁= ▁last _ pos ▁[ ▁s ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁] ▁; ▁min p ▁= ▁max ▁( ▁min p ▁, ▁lp ▁) ▁; ▁++ ▁pl en ▁; ▁if ▁( ▁i ▁== ▁min p ▁) ▁{ ▁ans ▁. ▁push _ back ▁( ▁pl en ▁) ▁; ▁min p ▁= ▁-1 ▁; ▁pl en ▁= ▁0 ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁( ▁int ▁) ▁ans ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁c out ▁<< ▁ans ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁ac bb cc ▁" ▁; ▁partition String ▁( ▁str ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁check ▁( ▁string ▁& ▁s ▁, ▁int ▁k ▁) ▁{ ▁int ▁n ▁= ▁s ▁. ▁size ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁k ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁< ▁n ▁; ▁j ▁+= ▁k ▁) ▁{ ▁if ▁( ▁s ▁[ ▁i ▁] ▁!= ▁s ▁[ ▁j ▁] ▁) ▁return ▁false ▁; ▁} ▁} ▁int ▁c ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁k ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁[ ▁i ▁] ▁== ▁'0' ▁) ▁c ▁++ ▁; ▁else ▁c ▁-- ▁; ▁} ▁if ▁( ▁c ▁== ▁0 ▁) ▁return ▁true ▁; ▁else ▁return ▁false ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁"1 0101 0" ▁; ▁int ▁k ▁= ▁2 ▁; ▁if ▁( ▁check ▁( ▁s ▁, ▁k ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁<< ▁end l ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max G CD ▁( ▁int ▁n ▁) ▁{ ▁int ▁max H cf ▁= ▁INT _ MIN ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁<= ▁n ▁; ▁j ▁++ ▁) ▁{ ▁max H cf ▁= ▁max ▁( ▁max H cf ▁, ▁__ g cd ▁( ▁i ▁, ▁j ▁) ▁) ▁; ▁} ▁} ▁return ▁max H cf ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁4 ▁; ▁c out ▁<< ▁max G CD ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁eps ▁1 e -6 ▁NEW _ LINE ▁double ▁func ▁( ▁double ▁a ▁, ▁double ▁b ▁, ▁double ▁c ▁, ▁double ▁x ▁) ▁{ ▁return ▁a ▁* ▁x ▁* ▁x ▁+ ▁b ▁* ▁x ▁+ ▁c ▁; ▁} ▁double ▁find Root ▁( ▁double ▁a ▁, ▁double ▁b ▁, ▁double ▁c ▁, ▁double ▁low ▁, ▁double ▁high ▁) ▁{ ▁double ▁x ▁; ▁while ▁( ▁f abs ▁( ▁high ▁- ▁low ▁) ▁> ▁eps ▁) ▁{ ▁x ▁= ▁( ▁low ▁+ ▁high ▁) ▁/ ▁2 ▁; ▁if ▁( ▁func ▁( ▁a ▁, ▁b ▁, ▁c ▁, ▁low ▁) ▁* ▁func ▁( ▁a ▁, ▁b ▁, ▁c ▁, ▁x ▁) ▁<= ▁0 ▁) ▁{ ▁high ▁= ▁x ▁; ▁} ▁else ▁{ ▁low ▁= ▁x ▁; ▁} ▁} ▁return ▁x ▁; ▁} ▁void ▁solve ▁( ▁double ▁a ▁, ▁double ▁b ▁, ▁double ▁c ▁, ▁double ▁A ▁, ▁double ▁B ▁) ▁{ ▁if ▁( ▁func ▁( ▁a ▁, ▁b ▁, ▁c ▁, ▁A ▁) ▁* ▁func ▁( ▁a ▁, ▁b ▁, ▁c ▁, ▁B ▁) ▁> ▁0 ▁) ▁{ ▁c out ▁<< ▁" ▁No ▁solution ▁" ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁fixed ▁<< ▁set precision ▁( ▁4 ▁) ▁<< ▁find Root ▁( ▁a ▁, ▁b ▁, ▁c ▁, ▁A ▁, ▁B ▁) ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁double ▁a ▁= ▁2 ▁, ▁b ▁= ▁-3 ▁, ▁c ▁= ▁-2 ▁, ▁A ▁= ▁0 ▁, ▁B ▁= ▁3 ▁; ▁solve ▁( ▁a ▁, ▁b ▁, ▁c ▁, ▁A ▁, ▁B ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁vector ▁< ▁int ▁> ▁find Sub arrays ▁( ▁vector ▁< ▁int ▁> ▁& ▁a ▁) ▁{ ▁int ▁n ▁= ▁a ▁. ▁size ▁( ▁) ▁; ▁vector ▁< ▁int ▁> ▁freq ▁( ▁n ▁+ ▁1 ▁) ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁if ▁( ▁count ▁== ▁0 ▁) ▁continue ▁; ▁else ▁{ ▁int ▁value ▁= ▁count ▁; ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁<= ▁count ▁; ▁j ▁++ ▁) ▁{ ▁freq ▁[ ▁j ▁] ▁+= ▁value ▁; ▁value ▁-- ▁; ▁} ▁count ▁= ▁0 ▁; ▁} ▁} ▁else ▁count ▁++ ▁; ▁} ▁if ▁( ▁count ▁> ▁0 ▁) ▁{ ▁int ▁value ▁= ▁count ▁; ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁<= ▁count ▁; ▁j ▁++ ▁) ▁{ ▁freq ▁[ ▁j ▁] ▁+= ▁value ▁; ▁value ▁-- ▁; ▁} ▁} ▁return ▁freq ▁; ▁} ▁void ▁count Rect angles ▁( ▁vector ▁< ▁int ▁> ▁& ▁a ▁, ▁vector ▁< ▁int ▁> ▁& ▁b ▁, ▁int ▁K ▁) ▁{ ▁int ▁n ▁= ▁a ▁. ▁size ▁( ▁) ▁; ▁int ▁m ▁= ▁b ▁. ▁size ▁( ▁) ▁; ▁vector ▁< ▁int ▁> ▁sub A ▁= ▁find Sub arrays ▁( ▁a ▁) ▁; ▁vector ▁< ▁int ▁> ▁sub B ▁= ▁find Sub arrays ▁( ▁b ▁) ▁; ▁int ▁total ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁sub A ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁K ▁% ▁i ▁== ▁0 ▁and ▁( ▁K ▁/ ▁i ▁) ▁<= ▁m ▁) ▁{ ▁total ▁= ▁total ▁+ ▁sub A ▁[ ▁i ▁] ▁* ▁sub B ▁[ ▁K ▁/ ▁i ▁] ▁; ▁} ▁} ▁c out ▁<< ▁total ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁int ▁> ▁a ▁= ▁{ ▁0 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁} ▁; ▁vector ▁< ▁int ▁> ▁b ▁= ▁{ ▁1 ▁, ▁0 ▁, ▁1 ▁} ▁; ▁int ▁K ▁= ▁2 ▁; ▁count Rect angles ▁( ▁a ▁, ▁b ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print Res ▁( ▁vector ▁< ▁int ▁> ▁& ▁res ▁) ▁{ ▁int ▁n ▁= ▁res ▁. ▁size ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁c out ▁<< ▁res ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁} ▁} ▁void ▁print LB S ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁lis ▁[ ▁N ▁] ▁; ▁int ▁l ds ▁[ ▁N ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁lis ▁[ ▁i ▁] ▁= ▁l ds ▁[ ▁i ▁] ▁= ▁1 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁i ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁j ▁] ▁< ▁arr ▁[ ▁i ▁] ▁) ▁{ ▁if ▁( ▁lis ▁[ ▁i ▁] ▁< ▁lis ▁[ ▁j ▁] ▁+ ▁1 ▁) ▁lis ▁[ ▁i ▁] ▁= ▁lis ▁[ ▁j ▁] ▁+ ▁1 ▁; ▁} ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁N ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁N ▁- ▁1 ▁; ▁j ▁> ▁i ▁; ▁j ▁-- ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁j ▁] ▁< ▁arr ▁[ ▁i ▁] ▁) ▁{ ▁if ▁( ▁l ds ▁[ ▁i ▁] ▁< ▁l ds ▁[ ▁j ▁] ▁+ ▁1 ▁) ▁l ds ▁[ ▁i ▁] ▁= ▁l ds ▁[ ▁j ▁] ▁+ ▁1 ▁; ▁} ▁} ▁} ▁int ▁Max Val ▁= ▁arr ▁[ ▁0 ▁] ▁, ▁in x ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁Max Val ▁< ▁lis ▁[ ▁i ▁] ▁+ ▁l ds ▁[ ▁i ▁] ▁- ▁1 ▁) ▁{ ▁Max Val ▁= ▁lis ▁[ ▁i ▁] ▁+ ▁l ds ▁[ ▁i ▁] ▁- ▁1 ▁; ▁in x ▁= ▁i ▁; ▁} ▁} ▁int ▁ct 1 ▁= ▁lis ▁[ ▁in x ▁] ▁; ▁vector ▁< ▁int ▁> ▁res ▁; ▁for ▁( ▁int ▁i ▁= ▁in x ▁; ▁i ▁>= ▁0 ▁&& ▁ct 1 ▁> ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁lis ▁[ ▁i ▁] ▁== ▁ct 1 ▁) ▁{ ▁res ▁. ▁push _ back ▁( ▁arr
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁solve ▁( ▁int ▁n ▁, ▁int ▁arr ▁[ ▁] ▁) ▁{ ▁int ▁i ▁, ▁ans ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁left ▁= ▁max ▁( ▁i ▁- ▁1 ▁, ▁0 ▁) ▁; ▁int ▁right ▁= ▁min ▁( ▁n ▁- ▁1 ▁, ▁i ▁+ ▁1 ▁) ▁; ▁while ▁( ▁left ▁>= ▁0 ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁left ▁] ▁> ▁arr ▁[ ▁i ▁] ▁) ▁{ ▁left ▁++ ▁; ▁break ▁; ▁} ▁left ▁-- ▁; ▁} ▁if ▁( ▁left ▁< ▁0 ▁) ▁left ▁++ ▁; ▁while ▁( ▁right ▁< ▁n ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁right ▁] ▁> ▁arr ▁[ ▁i ▁] ▁) ▁{ ▁right ▁-- ▁; ▁break ▁; ▁} ▁right ▁++ ▁; ▁} ▁if ▁( ▁right ▁>= ▁n ▁) ▁right ▁-- ▁; ▁ans ▁= ▁1 ▁+ ▁right ▁- ▁left ▁; ▁c out ▁<< ▁ans ▁<< ▁" ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁2 ▁, ▁1 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁arr ▁/ ▁sizeof ▁arr ▁[ ▁0 ▁] ▁; ▁solve ▁( ▁n ▁, ▁arr ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁getSum ▁( ▁int ▁BIT ree ▁[ ▁] ▁, ▁int ▁index ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁index ▁+= ▁1 ▁; ▁while ▁( ▁index ▁> ▁0 ▁) ▁{ ▁ans ▁+= ▁BIT ree ▁[ ▁index ▁] ▁; ▁index ▁-= ▁index ▁& ▁( ▁- ▁index ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁static ▁void ▁update BIT ▁( ▁int ▁BIT ree ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁index ▁, ▁int ▁val ▁) ▁{ ▁index ▁= ▁index ▁+ ▁1 ▁; ▁while ▁( ▁index ▁<= ▁n ▁) ▁{ ▁BIT ree ▁[ ▁index ▁] ▁+= ▁val ▁; ▁index ▁+= ▁index ▁& ▁( ▁- ▁index ▁) ▁; ▁} ▁} ▁int ▁* ▁construct BIT ree ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁* ▁BIT ree ▁= ▁new ▁int ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁BIT ree ▁[ ▁i ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁update BIT ▁( ▁BIT ree ▁, ▁n ▁, ▁i ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁return ▁BIT ree ▁; ▁} ▁int ▁getL ower Bound ▁( ▁int ▁BIT ree ▁[ ▁] ▁, ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁lb ▁= ▁-1 ▁; ▁int ▁l ▁= ▁0 ▁, ▁r ▁= ▁n ▁- ▁1 ▁; ▁while ▁( ▁l ▁<= ▁r ▁) ▁{ ▁int ▁mid ▁= ▁l ▁+ ▁( ▁r ▁- ▁l ▁) ▁/ ▁2 ▁; ▁if ▁( ▁getSum ▁( ▁BIT ree ▁, ▁mid ▁) ▁>= ▁k ▁) ▁{ ▁r ▁= ▁mid ▁- ▁1 ▁; ▁lb ▁= ▁mid ▁; ▁} ▁else ▁l ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁return ▁lb ▁; ▁} ▁void ▁perform Queries ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁q ▁[ ▁] ▁[ ▁3 ▁] ▁) ▁{ ▁int ▁* ▁BIT ree ▁= ▁construct BIT ree ▁( ▁A ▁, ▁n ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁sizeof ▁( ▁q ▁[ ▁0 ▁] ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁i ▁++ ▁) ▁{ ▁int ▁id ▁= ▁q ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁; ▁if ▁( ▁id ▁== ▁1 ▁) ▁{ ▁int ▁idx ▁= ▁q ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁; ▁int ▁val ▁= ▁q ▁[ ▁i ▁] ▁[ ▁2
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁Contin uous Elements ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁1 ▁) ▁return ▁false ▁; ▁int ▁curr ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁!= ▁a ▁[ ▁i ▁- ▁1 ▁] ▁) ▁{ ▁if ▁( ▁curr ▁== ▁1 ▁) ▁return ▁false ▁; ▁else ▁curr ▁= ▁0 ▁; ▁} ▁curr ▁++ ▁; ▁} ▁if ▁( ▁curr ▁== ▁1 ▁) ▁return ▁false ▁; ▁return ▁true ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁1 ▁, ▁2 ▁, ▁2 ▁, ▁1 ▁, ▁3 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁if ▁( ▁Contin uous Elements ▁( ▁a ▁, ▁n ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁<< ▁end l ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁maximum Count ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁B ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁queue ▁< ▁int ▁> ▁q ▁; ▁unordered _ set ▁< ▁int ▁> ▁s ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁s ▁. ▁insert ▁( ▁B ▁[ ▁i ▁] ▁) ▁; ▁q ▁. ▁push ▁( ▁B ▁[ ▁i ▁] ▁) ▁; ▁} ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁. ▁find ▁( ▁A ▁[ ▁i ▁] ▁) ▁== ▁s ▁. ▁end ▁( ▁) ▁) ▁continue ▁; ▁while ▁( ▁! ▁q ▁. ▁empty ▁( ▁) ▁&& ▁q ▁. ▁front ▁( ▁) ▁!= ▁A ▁[ ▁i ▁] ▁) ▁{ ▁s ▁. ▁erase ▁( ▁q ▁. ▁front ▁( ▁) ▁) ▁; ▁q ▁. ▁pop ▁( ▁) ▁; ▁count ▁++ ▁; ▁} ▁if ▁( ▁A ▁[ ▁i ▁] ▁== ▁q ▁. ▁front ▁( ▁) ▁) ▁{ ▁q ▁. ▁pop ▁( ▁) ▁; ▁s ▁. ▁erase ▁( ▁A ▁[ ▁i ▁] ▁) ▁; ▁} ▁if ▁( ▁q ▁. ▁empty ▁( ▁) ▁) ▁break ▁; ▁} ▁c out ▁<< ▁count ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁4 ▁; ▁int ▁A ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁B ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁4 ▁, ▁3 ▁} ▁; ▁maximum Count ▁( ▁A ▁, ▁B ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count _ elements ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁count ▁= ▁1 ▁; ▁int ▁max ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁max ▁) ▁{ ▁count ▁+= ▁1 ▁; ▁max ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁} ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁1 ▁, ▁4 ▁, ▁6 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁( ▁count _ elements ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Subset ▁( ▁int ▁* ▁a ▁, ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁int ▁cnt ▁= ▁0 ▁; ▁vector ▁< ▁int ▁> ▁v ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁- ▁1 ▁] ▁- ▁i ▁<= ▁0 ▁) ▁{ ▁sum ▁+= ▁a ▁[ ▁i ▁- ▁1 ▁] ▁- ▁i ▁; ▁cnt ▁+= ▁1 ▁; ▁} ▁else ▁{ ▁v ▁. ▁push _ back ▁( ▁a ▁[ ▁i ▁- ▁1 ▁] ▁- ▁i ▁) ▁; ▁} ▁} ▁sort ▁( ▁v ▁. ▁begin ▁( ▁) ▁, ▁v ▁. ▁end ▁( ▁) ▁) ▁; ▁int ▁ptr ▁= ▁0 ▁; ▁while ▁( ▁ptr ▁< ▁v ▁. ▁size ▁( ▁) ▁&& ▁sum ▁+ ▁v ▁[ ▁ptr ▁] ▁<= ▁0 ▁) ▁{ ▁cnt ▁+= ▁1 ▁; ▁ptr ▁+= ▁1 ▁; ▁sum ▁+= ▁v ▁[ ▁ptr ▁] ▁; ▁} ▁return ▁cnt ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁1 ▁, ▁6 ▁, ▁7 ▁, ▁8 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁find Subset ▁( ▁arr ▁, ▁n ▁) ▁<< ▁end l ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁check Array ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁B ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁start ▁= ▁0 ▁; ▁int ▁end ▁= ▁N ▁- ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁A ▁[ ▁i ▁] ▁!= ▁B ▁[ ▁i ▁] ▁) ▁{ ▁start ▁= ▁i ▁; ▁break ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁N ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁A ▁[ ▁i ▁] ▁!= ▁B ▁[ ▁i ▁] ▁) ▁{ ▁end ▁= ▁i ▁; ▁break ▁; ▁} ▁} ▁reverse ▁( ▁A ▁+ ▁start ▁, ▁A ▁+ ▁end ▁+ ▁1 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁A ▁[ ▁i ▁] ▁!= ▁B ▁[ ▁i ▁] ▁) ▁{ ▁c out ▁<< ▁" ▁No ▁" ▁<< ▁end l ▁; ▁return ▁; ▁} ▁} ▁c out ▁<< ▁" ▁Yes ▁" ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁2 ▁, ▁4 ▁} ▁; ▁int ▁B ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁A ▁) ▁/ ▁sizeof ▁( ▁A ▁[ ▁0 ▁] ▁) ▁; ▁check Array ▁( ▁A ▁, ▁B ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁get _ subset _ count ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁K ▁, ▁int ▁N ▁) ▁{ ▁sort ▁( ▁arr ▁, ▁arr ▁+ ▁N ▁) ▁; ▁int ▁left ▁, ▁right ▁; ▁left ▁= ▁0 ▁; ▁right ▁= ▁N ▁- ▁1 ▁; ▁int ▁ans ▁= ▁0 ▁; ▁while ▁( ▁left ▁<= ▁right ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁left ▁] ▁+ ▁arr ▁[ ▁right ▁] ▁< ▁K ▁) ▁{ ▁ans ▁+= ▁1 ▁<< ▁( ▁right ▁- ▁left ▁) ▁; ▁left ▁++ ▁; ▁} ▁else ▁{ ▁right ▁-- ▁; ▁} ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁4 ▁, ▁5 ▁, ▁7 ▁} ▁; ▁int ▁K ▁= ▁8 ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁get _ subset _ count ▁( ▁arr ▁, ▁K ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁binary _ search ed _ find _ x ▁( ▁int ▁k ▁) ▁{ ▁int ▁l ▁= ▁0 ▁; ▁int ▁r ▁= ▁k ▁; ▁int ▁ans ▁= ▁0 ▁; ▁while ▁( ▁l ▁<= ▁r ▁) ▁{ ▁int ▁mid ▁= ▁l ▁+ ▁( ▁r ▁- ▁l ▁) ▁/ ▁2 ▁; ▁if ▁( ▁pow ▁( ▁( ▁( ▁mid ▁* ▁( ▁mid ▁+ ▁1 ▁) ▁) ▁/ ▁2 ▁) ▁, ▁2 ▁) ▁>= ▁k ▁) ▁{ ▁ans ▁= ▁mid ▁; ▁r ▁= ▁mid ▁- ▁1 ▁; ▁} ▁else ▁{ ▁l ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁100 ▁; ▁c out ▁<< ▁binary _ search ed _ find _ x ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁len Of Long Z ig Z ag Arr ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁max ▁= ▁1 ▁, ▁len ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁% ▁2 ▁== ▁0 ▁&& ▁( ▁a ▁[ ▁i ▁] ▁< ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁) ▁len ▁++ ▁; ▁else ▁if ▁( ▁i ▁% ▁2 ▁== ▁1 ▁&& ▁( ▁a ▁[ ▁i ▁] ▁> ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁) ▁len ▁++ ▁; ▁else ▁{ ▁if ▁( ▁max ▁< ▁len ▁) ▁max ▁= ▁len ▁; ▁len ▁= ▁1 ▁; ▁} ▁} ▁if ▁( ▁max ▁< ▁len ▁) ▁max ▁= ▁len ▁; ▁return ▁max ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁len Of Long Z ig Z ag Arr ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁check Perf ect Square ▁( ▁long ▁int ▁N ▁, ▁long ▁int ▁start ▁, ▁long ▁int ▁last ▁) ▁{ ▁long ▁int ▁mid ▁= ▁( ▁start ▁+ ▁last ▁) ▁/ ▁2 ▁; ▁if ▁( ▁start ▁> ▁last ▁) ▁{ ▁return ▁-1 ▁; ▁} ▁if ▁( ▁mid ▁* ▁mid ▁== ▁N ▁) ▁{ ▁return ▁mid ▁; ▁} ▁else ▁if ▁( ▁mid ▁* ▁mid ▁> ▁N ▁) ▁{ ▁return ▁check Perf ect Square ▁( ▁N ▁, ▁start ▁, ▁mid ▁- ▁1 ▁) ▁; ▁} ▁else ▁{ ▁return ▁check Perf ect Square ▁( ▁N ▁, ▁mid ▁+ ▁1 ▁, ▁last ▁) ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁long ▁int ▁N ▁= ▁65 ▁; ▁c out ▁<< ▁check Perf ect Square ▁( ▁N ▁, ▁1 ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find Sub Array ▁( ▁int ▁* ▁a ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁pref ▁[ ▁n ▁] ▁; ▁pref ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁++ ▁i ▁) ▁{ ▁pref ▁[ ▁i ▁] ▁= ▁pref ▁[ ▁i ▁- ▁1 ▁] ▁; ▁if ▁( ▁a ▁[ ▁i ▁] ▁> ▁a ▁[ ▁i ▁- ▁1 ▁] ▁&& ▁a ▁[ ▁i ▁] ▁> ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁pref ▁[ ▁i ▁] ▁++ ▁; ▁} ▁int ▁peak ▁= ▁0 ▁, ▁left ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁+ ▁k ▁- ▁1 ▁< ▁n ▁; ▁++ ▁i ▁) ▁if ▁( ▁pref ▁[ ▁i ▁+ ▁k ▁- ▁2 ▁] ▁- ▁pref ▁[ ▁i ▁] ▁> ▁peak ▁) ▁{ ▁peak ▁= ▁pref ▁[ ▁i ▁+ ▁k ▁- ▁2 ▁] ▁- ▁pref ▁[ ▁i ▁] ▁; ▁left ▁= ▁i ▁; ▁} ▁c out ▁<< ▁" ▁Left ▁= ▁" ▁<< ▁left ▁+ ▁1 ▁<< ▁end l ▁; ▁c out ▁<< ▁" ▁Right ▁= ▁" ▁<< ▁left ▁+ ▁k ▁<< ▁end l ▁; ▁c out ▁<< ▁" ▁P eak ▁= ▁" ▁<< ▁peak ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁2 ▁, ▁3 ▁, ▁2 ▁, ▁1 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁k ▁= ▁3 ▁; ▁find Sub Array ▁( ▁arr ▁, ▁n ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁Find Rank ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁length ▁) ▁{ ▁c out ▁<< ▁"1" ▁<< ▁" ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁length ▁; ▁i ▁++ ▁) ▁{ ▁int ▁rank ▁= ▁1 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁i ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁j ▁] ▁> ▁arr ▁[ ▁i ▁] ▁) ▁rank ▁++ ▁; ▁} ▁c out ▁<< ▁rank ▁<< ▁" ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁88 ▁, ▁14 ▁, ▁69 ▁, ▁30 ▁, ▁29 ▁, ▁89 ▁} ▁; ▁int ▁len ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁Find Rank ▁( ▁arr ▁, ▁len ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁int ▁MAX ▁= ▁100000 5 ▁; ▁int ▁fib U pto ▁[ ▁MAX ▁+ ▁1 ▁] ▁; ▁void ▁compute ▁( ▁int ▁sz ▁) ▁{ ▁bool ▁isF ib ▁[ ▁sz ▁+ ▁1 ▁] ▁; ▁mem set ▁( ▁isF ib ▁, ▁false ▁, ▁sizeof ▁( ▁isF ib ▁) ▁) ▁; ▁int ▁prev ▁= ▁0 ▁, ▁curr ▁= ▁1 ▁; ▁isF ib ▁[ ▁prev ▁] ▁= ▁isF ib ▁[ ▁curr ▁] ▁= ▁true ▁; ▁while ▁( ▁curr ▁<= ▁sz ▁) ▁{ ▁int ▁temp ▁= ▁curr ▁+ ▁prev ▁; ▁isF ib ▁[ ▁temp ▁] ▁= ▁true ▁; ▁prev ▁= ▁curr ▁; ▁curr ▁= ▁temp ▁; ▁} ▁fib U pto ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁sz ▁; ▁i ▁++ ▁) ▁{ ▁fib U pto ▁[ ▁i ▁] ▁= ▁fib U pto ▁[ ▁i ▁- ▁1 ▁] ▁; ▁if ▁( ▁isF ib ▁[ ▁i ▁] ▁) ▁fib U pto ▁[ ▁i ▁] ▁++ ▁; ▁} ▁} ▁int ▁count Of Numbers ▁( ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁compute ▁( ▁N ▁) ▁; ▁int ▁low ▁= ▁1 ▁, ▁high ▁= ▁N ▁, ▁ans ▁= ▁0 ▁; ▁while ▁( ▁low ▁<= ▁high ▁) ▁{ ▁int ▁mid ▁= ▁( ▁low ▁+ ▁high ▁) ▁>> ▁1 ▁; ▁if ▁( ▁mid ▁- ▁fib U pto ▁[ ▁mid ▁] ▁>= ▁K ▁) ▁{ ▁ans ▁= ▁mid ▁; ▁high ▁= ▁mid ▁- ▁1 ▁; ▁} ▁else ▁low ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁return ▁( ▁ans ▁? ▁N ▁- ▁ans ▁+ ▁1 ▁: ▁0 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁10 ▁, ▁K ▁= ▁3 ▁; ▁c out ▁<< ▁count Of Numbers ▁( ▁N ▁, ▁K ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁MAX ▁26 ▁NEW _ LINE ▁vector ▁< ▁int ▁> ▁find Count ▁( ▁string ▁a ▁[ ▁] ▁, ▁string ▁b ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁int ▁freq ▁[ ▁MAX ▁] ▁= ▁{ ▁0 ▁} ▁; ▁vector ▁< ▁int ▁> ▁smallest Freq ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁string ▁s ▁= ▁a ▁[ ▁i ▁] ▁; ▁mem set ▁( ▁freq ▁, ▁0 ▁, ▁sizeof ▁freq ▁) ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁s ▁. ▁size ▁( ▁) ▁; ▁j ▁++ ▁) ▁{ ▁freq ▁[ ▁s ▁[ ▁j ▁] ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁} ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁MAX ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁freq ▁[ ▁j ▁] ▁) ▁{ ▁smallest Freq ▁. ▁push _ back ▁( ▁freq ▁[ ▁j ▁] ▁) ▁; ▁break ▁; ▁} ▁} ▁} ▁sort ▁( ▁smallest Freq ▁. ▁begin ▁( ▁) ▁, ▁smallest Freq ▁. ▁end ▁( ▁) ▁) ▁; ▁vector ▁< ▁int ▁> ▁ans ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁m ▁; ▁i ▁++ ▁) ▁{ ▁string ▁s ▁= ▁b ▁[ ▁i ▁] ▁; ▁mem set ▁( ▁freq ▁, ▁0 ▁, ▁sizeof ▁freq ▁) ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁s ▁. ▁size ▁( ▁) ▁; ▁j ▁++ ▁) ▁{ ▁freq ▁[ ▁s ▁[ ▁j ▁] ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁} ▁int ▁frequency ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁MAX ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁freq ▁[ ▁j ▁] ▁) ▁{ ▁frequency ▁= ▁freq ▁[ ▁j ▁] ▁; ▁break ▁; ▁} ▁} ▁int ▁ind ▁= ▁lower _ bound ▁( ▁smallest Freq ▁. ▁begin ▁( ▁) ▁, ▁smallest Freq ▁. ▁end ▁( ▁) ▁, ▁frequency ▁) ▁- ▁smallest Freq ▁. ▁begin ▁( ▁) ▁; ▁ans ▁. ▁push _ back ▁( ▁ind ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁void ▁print Answer ▁( ▁string ▁a ▁[ ▁] ▁, ▁string ▁b ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁vector ▁< ▁int ▁> ▁ans ▁= ▁find Count ▁( ▁a ▁, ▁b ▁, ▁n ▁, ▁m ▁) ▁; ▁for ▁( ▁auto ▁it ▁: ▁ans ▁) ▁{ ▁c out ▁<< ▁it ▁<< ▁"
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count LessThan ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁key ▁) ▁{ ▁int ▁l ▁= ▁0 ▁, ▁r ▁= ▁n ▁- ▁1 ▁; ▁int ▁index ▁= ▁-1 ▁; ▁while ▁( ▁l ▁<= ▁r ▁) ▁{ ▁int ▁m ▁= ▁( ▁l ▁+ ▁r ▁) ▁/ ▁2 ▁; ▁if ▁( ▁arr ▁[ ▁m ▁] ▁< ▁key ▁) ▁{ ▁l ▁= ▁m ▁+ ▁1 ▁; ▁index ▁= ▁m ▁; ▁} ▁else ▁{ ▁r ▁= ▁m ▁- ▁1 ▁; ▁} ▁} ▁return ▁( ▁index ▁+ ▁1 ▁) ▁; ▁} ▁int ▁count GreaterThan ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁key ▁) ▁{ ▁int ▁l ▁= ▁0 ▁, ▁r ▁= ▁n ▁- ▁1 ▁; ▁int ▁index ▁= ▁-1 ▁; ▁while ▁( ▁l ▁<= ▁r ▁) ▁{ ▁int ▁m ▁= ▁( ▁l ▁+ ▁r ▁) ▁/ ▁2 ▁; ▁if ▁( ▁arr ▁[ ▁m ▁] ▁<= ▁key ▁) ▁{ ▁l ▁= ▁m ▁+ ▁1 ▁; ▁} ▁else ▁{ ▁r ▁= ▁m ▁- ▁1 ▁; ▁index ▁= ▁m ▁; ▁} ▁} ▁if ▁( ▁index ▁== ▁-1 ▁) ▁return ▁0 ▁; ▁return ▁( ▁n ▁- ▁index ▁) ▁; ▁} ▁int ▁count Tri pl ets ▁( ▁int ▁n ▁, ▁int ▁* ▁a ▁, ▁int ▁* ▁b ▁, ▁int ▁* ▁c ▁) ▁{ ▁sort ▁( ▁a ▁, ▁a ▁+ ▁n ▁) ▁; ▁sort ▁( ▁b ▁, ▁b ▁+ ▁n ▁) ▁; ▁sort ▁( ▁c ▁, ▁c ▁+ ▁n ▁) ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁{ ▁int ▁current ▁= ▁b ▁[ ▁i ▁] ▁; ▁int ▁a _ index ▁= ▁-1 ▁, ▁c _ index ▁= ▁-1 ▁; ▁int ▁low ▁= ▁count LessThan ▁( ▁a ▁, ▁n ▁, ▁current ▁) ▁; ▁int ▁high ▁= ▁count GreaterThan ▁( ▁c ▁, ▁n ▁, ▁current ▁) ▁; ▁count ▁+= ▁( ▁low ▁* ▁high ▁) ▁; ▁} ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁5 ▁} ▁; ▁int ▁b ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁4 ▁} ▁; ▁int ▁c ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁6 ▁} ▁; ▁int ▁size ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁count Tri pl ets ▁( ▁size ▁, ▁a ▁, ▁b
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁ll ▁long ▁long ▁int ▁NEW _ LINE ▁int ▁divisor count ▁( ▁int ▁elem ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁sqrt ▁( ▁elem ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁elem ▁% ▁i ▁== ▁0 ▁) ▁{ ▁if ▁( ▁i ▁* ▁i ▁== ▁elem ▁) ▁ans ▁++ ▁; ▁else ▁ans ▁+= ▁2 ▁; ▁} ▁} ▁return ▁ans ▁; ▁} ▁string ▁find w inner ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁B ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁M ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁A ▁[ ▁i ▁] ▁= ▁divisor count ▁( ▁A ▁[ ▁i ▁] ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁M ▁; ▁i ▁++ ▁) ▁{ ▁B ▁[ ▁i ▁] ▁= ▁divisor count ▁( ▁B ▁[ ▁i ▁] ▁) ▁; ▁} ▁sort ▁( ▁A ▁, ▁A ▁+ ▁N ▁) ▁; ▁sort ▁( ▁B ▁, ▁B ▁+ ▁M ▁) ▁; ▁int ▁win A ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁int ▁val ▁= ▁A ▁[ ▁i ▁] ▁; ▁int ▁start ▁= ▁0 ▁; ▁int ▁end ▁= ▁M ▁- ▁1 ▁; ▁int ▁index ▁= ▁-1 ▁; ▁while ▁( ▁start ▁<= ▁end ▁) ▁{ ▁int ▁mid ▁= ▁( ▁start ▁+ ▁end ▁) ▁/ ▁2 ▁; ▁if ▁( ▁B ▁[ ▁mid ▁] ▁<= ▁val ▁) ▁{ ▁index ▁= ▁mid ▁; ▁start ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁else ▁{ ▁end ▁= ▁mid ▁- ▁1 ▁; ▁} ▁} ▁win A ▁+= ▁( ▁index ▁+ ▁1 ▁) ▁; ▁} ▁int ▁win B ▁= ▁N ▁* ▁M ▁- ▁win A ▁; ▁if ▁( ▁win A ▁> ▁win B ▁) ▁{ ▁return ▁" ▁A ▁" ▁; ▁} ▁else ▁if ▁( ▁win B ▁> ▁win A ▁) ▁{ ▁return ▁" ▁B ▁" ▁; ▁} ▁return ▁" ▁Draw ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁12 ▁, ▁24 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁A ▁) ▁/ ▁sizeof ▁( ▁A ▁[ ▁0 ▁] ▁) ▁; ▁int ▁B ▁[ ▁] ▁= ▁{ ▁25 ▁, ▁28 ▁, ▁13 ▁, ▁45 ▁} ▁; ▁int ▁M ▁= ▁sizeof ▁( ▁B ▁) ▁/ ▁sizeof ▁(
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁isP ossible ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁dist ▁, ▁int ▁k ▁) ▁{ ▁int ▁req ▁= ▁0 ▁; ▁int ▁curr ▁= ▁0 ▁; ▁int ▁prev ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁while ▁( ▁curr ▁!= ▁n ▁&& ▁arr ▁[ ▁curr ▁] ▁- ▁arr ▁[ ▁prev ▁] ▁<= ▁dist ▁) ▁curr ▁++ ▁; ▁req ▁++ ▁; ▁if ▁( ▁curr ▁== ▁n ▁) ▁break ▁; ▁prev ▁= ▁curr ▁- ▁1 ▁; ▁} ▁if ▁( ▁curr ▁!= ▁n ▁) ▁return ▁false ▁; ▁if ▁( ▁req ▁<= ▁k ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁int ▁min Distance ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁l ▁= ▁0 ▁; ▁int ▁h ▁= ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁; ▁int ▁ans ▁= ▁0 ▁; ▁while ▁( ▁l ▁<= ▁h ▁) ▁{ ▁int ▁m ▁= ▁( ▁l ▁+ ▁h ▁) ▁/ ▁2 ▁; ▁if ▁( ▁isP ossible ▁( ▁arr ▁, ▁n ▁, ▁m ▁, ▁k ▁) ▁) ▁{ ▁ans ▁= ▁m ▁; ▁h ▁= ▁m ▁- ▁1 ▁; ▁} ▁else ▁l ▁= ▁m ▁+ ▁1 ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁15 ▁, ▁36 ▁, ▁43 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁int ▁k ▁= ▁2 ▁; ▁c out ▁<< ▁min Distance ▁( ▁arr ▁, ▁n ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Factor ▁( ▁int ▁P ▁, ▁int ▁X ▁) ▁{ ▁if ▁( ▁X ▁< ▁P ▁) ▁return ▁0 ▁; ▁return ▁( ▁X ▁/ ▁P ▁+ ▁count Factor ▁( ▁P ▁, ▁X ▁/ ▁P ▁) ▁) ▁; ▁} ▁int ▁find Small est X ▁( ▁int ▁Y ▁) ▁{ ▁int ▁low ▁= ▁0 ▁, ▁high ▁= ▁5 ▁* ▁Y ▁; ▁int ▁N ▁= ▁0 ▁; ▁while ▁( ▁low ▁<= ▁high ▁) ▁{ ▁int ▁mid ▁= ▁( ▁high ▁+ ▁low ▁) ▁/ ▁2 ▁; ▁if ▁( ▁count Factor ▁( ▁5 ▁, ▁mid ▁) ▁< ▁Y ▁) ▁{ ▁low ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁else ▁{ ▁N ▁= ▁mid ▁; ▁high ▁= ▁mid ▁- ▁1 ▁; ▁} ▁} ▁return ▁N ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁Y ▁= ▁10 ▁; ▁c out ▁<< ▁find Small est X ▁( ▁Y ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁prime ▁[ ▁1000000 ▁+ ▁5 ▁] ▁; ▁void ▁find Prime ▁( ▁) ▁{ ▁mem set ▁( ▁prime ▁, ▁true ▁, ▁sizeof ▁( ▁prime ▁) ▁) ▁; ▁prime ▁[ ▁1 ▁] ▁= ▁false ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁* ▁p ▁<= ▁1000000 ▁; ▁p ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁p ▁] ▁== ▁true ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁p ▁* ▁2 ▁; ▁i ▁<= ▁1000000 ▁; ▁i ▁+= ▁p ▁) ▁prime ▁[ ▁i ▁] ▁= ▁false ▁; ▁} ▁} ▁} ▁int ▁len Of Long Sub arr ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁unordered _ map ▁< ▁int ▁, ▁int ▁> ▁um ▁; ▁int ▁sum ▁= ▁0 ▁, ▁max Len ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁prime ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁== ▁0 ▁? ▁-1 ▁: ▁1 ▁; ▁if ▁( ▁sum ▁== ▁1 ▁) ▁max Len ▁= ▁i ▁+ ▁1 ▁; ▁else ▁if ▁( ▁um ▁. ▁find ▁( ▁sum ▁) ▁== ▁um ▁. ▁end ▁( ▁) ▁) ▁um ▁[ ▁sum ▁] ▁= ▁i ▁; ▁if ▁( ▁um ▁. ▁find ▁( ▁sum ▁- ▁1 ▁) ▁!= ▁um ▁. ▁end ▁( ▁) ▁) ▁{ ▁if ▁( ▁max Len ▁< ▁( ▁i ▁- ▁um ▁[ ▁sum ▁- ▁1 ▁] ▁) ▁) ▁max Len ▁= ▁i ▁- ▁um ▁[ ▁sum ▁- ▁1 ▁] ▁; ▁} ▁} ▁return ▁max Len ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁find Prime ▁( ▁) ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁9 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁, ▁7 ▁, ▁8 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁len Of Long Sub arr ▁( ▁arr ▁, ▁n ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁canBe Opt imal Value ▁( ▁int ▁K ▁, ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁B ▁, ▁int ▁& ▁value ▁) ▁{ ▁int ▁tmp ▁[ ▁N ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁tmp ▁[ ▁i ▁] ▁= ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁K ▁* ▁( ▁i ▁+ ▁1 ▁) ▁) ▁; ▁sort ▁( ▁tmp ▁, ▁tmp ▁+ ▁N ▁) ▁; ▁value ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁K ▁; ▁i ▁++ ▁) ▁value ▁+= ▁tmp ▁[ ▁i ▁] ▁; ▁return ▁value ▁<= ▁B ▁; ▁} ▁void ▁find No Of Elements and Value ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁B ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁int ▁cumulative Value ▁= ▁0 ▁; ▁while ▁( ▁start ▁<= ▁end ▁) ▁{ ▁int ▁mid ▁= ▁( ▁start ▁+ ▁end ▁) ▁/ ▁2 ▁; ▁if ▁( ▁canBe Opt imal Value ▁( ▁mid ▁, ▁arr ▁, ▁N ▁, ▁B ▁, ▁cumulative Value ▁) ▁) ▁{ ▁ans ▁= ▁mid ▁; ▁start ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁else ▁end ▁= ▁mid ▁- ▁1 ▁; ▁} ▁canBe Opt imal Value ▁( ▁ans ▁, ▁arr ▁, ▁N ▁, ▁B ▁, ▁cumulative Value ▁) ▁; ▁c out ▁<< ▁ans ▁<< ▁" ▁" ▁<< ▁cumulative Value ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁5 ▁, ▁6 ▁, ▁3 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁B ▁= ▁90 ▁; ▁find No Of Elements and Value ▁( ▁arr ▁, ▁N ▁, ▁B ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁lex i Middle Small est ▁( ▁int ▁K ▁, ▁int ▁N ▁) ▁{ ▁if ▁( ▁K ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁c out ▁<< ▁K ▁/ ▁2 ▁<< ▁" ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁- ▁1 ▁; ▁++ ▁i ▁) ▁{ ▁c out ▁<< ▁K ▁<< ▁" ▁" ▁; ▁} ▁c out ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁exit ▁( ▁0 ▁) ▁; ▁} ▁vector ▁< ▁int ▁> ▁a ▁( ▁N ▁, ▁( ▁K ▁+ ▁1 ▁) ▁/ ▁2 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁/ ▁2 ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁a ▁. ▁back ▁( ▁) ▁== ▁1 ▁) ▁{ ▁a ▁. ▁pop _ back ▁( ▁) ▁; ▁} ▁else ▁{ ▁-- ▁a ▁. ▁back ▁( ▁) ▁; ▁while ▁( ▁( ▁int ▁) ▁a ▁. ▁size ▁( ▁) ▁< ▁N ▁) ▁{ ▁a ▁. ▁push _ back ▁( ▁K ▁) ▁; ▁} ▁} ▁} ▁for ▁( ▁auto ▁i ▁: ▁a ▁) ▁{ ▁c out ▁<< ▁i ▁<< ▁" ▁" ▁; ▁} ▁c out ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁K ▁= ▁2 ▁, ▁N ▁= ▁4 ▁; ▁lex i Middle Small est ▁( ▁K ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find Pair ▁( ▁pair ▁< ▁int ▁, ▁int ▁> ▁* ▁arr ▁, ▁int ▁N ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁int ▁a ▁= ▁arr ▁[ ▁i ▁] ▁. ▁first ▁, ▁b ▁= ▁arr ▁[ ▁i ▁] ▁. ▁second ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁int ▁c ▁= ▁arr ▁[ ▁j ▁] ▁. ▁first ▁, ▁d ▁= ▁arr ▁[ ▁j ▁] ▁. ▁second ▁; ▁if ▁( ▁a ▁< ▁c ▁&& ▁b ▁> ▁d ▁) ▁{ ▁c out ▁<< ▁" ▁( ▁" ▁<< ▁a ▁<< ▁" ▁" ▁<< ▁b ▁<< ▁" ▁) ▁, ▁( ▁" ▁<< ▁c ▁<< ▁" ▁" ▁<< ▁d ▁<< ▁" ▁) ▁STRNEWLINE ▁" ▁; ▁return ▁; ▁} ▁} ▁} ▁c out ▁<< ▁" ▁NO ▁SU CH ▁PA IR ▁EX IST ▁STRNEWLINE ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁pair ▁< ▁int ▁, ▁int ▁> ▁arr ▁[ ▁] ▁= ▁{ ▁{ ▁3 ▁, ▁7 ▁} ▁, ▁{ ▁21 ▁, ▁23 ▁} ▁, ▁{ ▁4 ▁, ▁13 ▁} ▁, ▁{ ▁1 ▁, ▁2 ▁} ▁, ▁{ ▁7 ▁, ▁-1 ▁} ▁} ▁; ▁find Pair ▁( ▁arr ▁, ▁5 ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max Cost ToRemove ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁int ▁max Cost ▁= ▁0 ▁; ▁sort ▁( ▁arr ▁, ▁arr ▁+ ▁N ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁+= ▁K ▁) ▁{ ▁max Cost ▁+= ▁arr ▁[ ▁i ▁+ ▁1 ▁] ▁; ▁} ▁return ▁max Cost ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁4 ▁, ▁1 ▁, ▁5 ▁, ▁1 ▁, ▁5 ▁, ▁3 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁K ▁= ▁4 ▁; ▁c out ▁<< ▁max Cost ToRemove ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁checkIf Possible Merge ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁B ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁i ▁= ▁0 ▁; ▁int ▁j ▁= ▁0 ▁; ▁int ▁prev ▁= ▁-1 ▁; ▁int ▁flag ▁= ▁1 ▁; ▁while ▁( ▁i ▁< ▁N ▁&& ▁j ▁< ▁N ▁) ▁{ ▁if ▁( ▁A ▁[ ▁i ▁] ▁< ▁B ▁[ ▁j ▁] ▁&& ▁prev ▁!= ▁0 ▁) ▁{ ▁prev ▁= ▁0 ▁; ▁i ▁++ ▁; ▁} ▁else ▁if ▁( ▁B ▁[ ▁j ▁] ▁< ▁A ▁[ ▁i ▁] ▁&& ▁prev ▁!= ▁1 ▁) ▁{ ▁prev ▁= ▁1 ▁; ▁j ▁++ ▁; ▁} ▁else ▁if ▁( ▁A ▁[ ▁i ▁] ▁== ▁B ▁[ ▁j ▁] ▁) ▁{ ▁if ▁( ▁prev ▁!= ▁1 ▁) ▁{ ▁prev ▁= ▁1 ▁; ▁j ▁++ ▁; ▁} ▁else ▁{ ▁prev ▁= ▁0 ▁; ▁i ▁++ ▁; ▁} ▁} ▁else ▁{ ▁flag ▁= ▁0 ▁; ▁break ▁; ▁} ▁} ▁return ▁flag ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁[ ▁3 ▁] ▁= ▁{ ▁3 ▁, ▁5 ▁, ▁8 ▁} ▁; ▁int ▁B ▁[ ▁3 ▁] ▁= ▁{ ▁2 ▁, ▁4 ▁, ▁6 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁A ▁) ▁/ ▁sizeof ▁( ▁A ▁[ ▁0 ▁] ▁) ▁; ▁if ▁( ▁checkIf Possible Merge ▁( ▁A ▁, ▁B ▁, ▁N ▁) ▁) ▁{ ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁" ▁No ▁" ▁; ▁} ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max Sum ▁( ▁int ▁n ▁, ▁int ▁a ▁[ ▁] ▁, ▁int ▁l ▁[ ▁] ▁[ ▁2 ▁] ▁, ▁int ▁q ▁) ▁{ ▁vector ▁< ▁int ▁> ▁v ▁; ▁int ▁d ▁[ ▁n ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁q ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁x ▁= ▁l ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁; ▁x ▁<= ▁l ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁; ▁x ▁++ ▁) ▁{ ▁if ▁( ▁d ▁[ ▁x ▁] ▁== ▁0 ▁) ▁{ ▁d ▁[ ▁x ▁] ▁= ▁1 ▁; ▁} ▁} ▁} ▁set ▁< ▁int ▁> ▁st ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁d ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁v ▁. ▁push _ back ▁( ▁a ▁[ ▁i ▁] ▁) ▁; ▁st ▁. ▁insert ▁( ▁i ▁) ▁; ▁} ▁} ▁sort ▁( ▁v ▁. ▁begin ▁( ▁) ▁, ▁v ▁. ▁end ▁( ▁) ▁, ▁greater ▁< ▁int ▁> ▁( ▁) ▁) ▁; ▁int ▁c ▁= ▁0 ▁; ▁for ▁( ▁auto ▁it ▁: ▁st ▁) ▁{ ▁a ▁[ ▁it ▁] ▁= ▁v ▁; ▁c ▁++ ▁; ▁} ▁int ▁pref _ sum ▁= ▁0 ▁; ▁int ▁temp _ sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁temp _ sum ▁+= ▁a ▁[ ▁i ▁] ▁; ▁pref _ sum ▁+= ▁temp _ sum ▁; ▁} ▁return ▁pref _ sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁- 8 ▁, ▁4 ▁, ▁-2 ▁, ▁- 6 ▁, ▁4 ▁, ▁7 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁q ▁[ ▁] ▁[ ▁2 ▁] ▁= ▁{ ▁{ ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁4 ▁, ▁5 ▁} ▁} ▁; ▁int ▁queries ▁= ▁sizeof ▁( ▁q ▁) ▁/ ▁sizeof ▁( ▁q ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁max Sum ▁( ▁N ▁, ▁arr ▁, ▁q ▁, ▁queries ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁Max Re arr n ge Sum ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁B ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁sort ▁( ▁A ▁, ▁A ▁+ ▁N ▁) ▁; ▁sort ▁( ▁B ▁, ▁B ▁+ ▁N ▁, ▁greater ▁< ▁int ▁> ▁( ▁) ▁) ▁; ▁int ▁max Sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁max Sum ▁+= ▁abs ▁( ▁A ▁[ ▁i ▁] ▁- ▁B ▁[ ▁i ▁] ▁) ▁; ▁} ▁return ▁max Sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁2 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁B ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁5 ▁, ▁5 ▁, ▁6 ▁, ▁6 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁A ▁) ▁/ ▁sizeof ▁( ▁A ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁Max Re arr n ge Sum ▁( ▁A ▁, ▁B ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁min Heap ify ▁( ▁int ▁br r ▁[ ▁] ▁, ▁int ▁i ▁, ▁int ▁M ▁) ▁{ ▁int ▁left ▁= ▁2 ▁* ▁i ▁+ ▁1 ▁; ▁int ▁right ▁= ▁2 ▁* ▁i ▁+ ▁2 ▁; ▁int ▁smallest ▁= ▁i ▁; ▁if ▁( ▁left ▁< ▁M ▁&& ▁br r ▁[ ▁left ▁] ▁< ▁br r ▁[ ▁smallest ▁] ▁) ▁{ ▁smallest ▁= ▁left ▁; ▁} ▁if ▁( ▁right ▁< ▁M ▁&& ▁br r ▁[ ▁right ▁] ▁< ▁br r ▁[ ▁smallest ▁] ▁) ▁{ ▁smallest ▁= ▁right ▁; ▁} ▁if ▁( ▁smallest ▁!= ▁i ▁) ▁{ ▁swap ▁( ▁br r ▁[ ▁i ▁] ▁, ▁br r ▁[ ▁smallest ▁] ▁) ▁; ▁min Heap ify ▁( ▁br r ▁, ▁smallest ▁, ▁M ▁) ▁; ▁} ▁} ▁void ▁merge ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁br r ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁M ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁br r ▁[ ▁0 ▁] ▁) ▁{ ▁swap ▁( ▁arr ▁[ ▁i ▁] ▁, ▁br r ▁[ ▁0 ▁] ▁) ▁; ▁min Heap ify ▁( ▁br r ▁, ▁0 ▁, ▁M ▁) ▁; ▁} ▁} ▁sort ▁( ▁br r ▁, ▁br r ▁+ ▁M ▁) ▁; ▁} ▁void ▁print Array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁23 ▁, ▁35 ▁, ▁2 35 ▁, ▁2 335 ▁} ▁; ▁int ▁br r ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁5 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁M ▁= ▁sizeof ▁( ▁br r ▁) ▁/ ▁sizeof ▁( ▁br r ▁[ ▁0 ▁] ▁) ▁; ▁merge ▁( ▁arr ▁, ▁br r ▁, ▁N ▁, ▁M ▁) ▁; ▁print Array ▁( ▁arr ▁, ▁N ▁) ▁; ▁print Array ▁( ▁br r ▁, ▁M ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< algorithm > ▁NEW _ LINE ▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁max Area ▁( ▁int ▁point _ x ▁[ ▁] ▁, ▁int ▁point _ y ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁length ▁, ▁int ▁width ▁) ▁{ ▁sort ▁( ▁point _ x ▁, ▁point _ x ▁+ ▁n ▁) ▁; ▁sort ▁( ▁point _ y ▁, ▁point _ y ▁+ ▁n ▁) ▁; ▁int ▁dx ▁= ▁point _ x ▁[ ▁0 ▁] ▁; ▁int ▁dy ▁= ▁point _ y ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁dx ▁= ▁max ▁( ▁dx ▁, ▁point _ x ▁[ ▁i ▁] ▁- ▁point _ x ▁[ ▁i ▁- ▁1 ▁] ▁) ▁; ▁dy ▁= ▁max ▁( ▁dy ▁, ▁point _ y ▁[ ▁i ▁] ▁- ▁point _ y ▁[ ▁i ▁- ▁1 ▁] ▁) ▁; ▁} ▁dx ▁= ▁max ▁( ▁dx ▁, ▁( ▁length ▁+ ▁1 ▁) ▁- ▁point _ x ▁[ ▁n ▁- ▁1 ▁] ▁) ▁; ▁dy ▁= ▁max ▁( ▁dy ▁, ▁( ▁width ▁+ ▁1 ▁) ▁- ▁point _ y ▁[ ▁n ▁- ▁1 ▁] ▁) ▁; ▁c out ▁<< ▁( ▁dx ▁- ▁1 ▁) ▁* ▁( ▁dy ▁- ▁1 ▁) ▁; ▁c out ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁length ▁= ▁15 ▁, ▁width ▁= ▁8 ▁; ▁int ▁n ▁= ▁3 ▁; ▁int ▁point _ x ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁11 ▁, ▁8 ▁} ▁; ▁int ▁point _ y ▁[ ▁] ▁= ▁{ ▁8 ▁, ▁2 ▁, ▁6 ▁} ▁; ▁max Area ▁( ▁point _ x ▁, ▁point _ y ▁, ▁n ▁, ▁length ▁, ▁width ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁# define ▁ll ▁long ▁long ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁ll ▁find Max Value ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁sort ▁( ▁arr ▁, ▁arr ▁+ ▁n ▁) ▁; ▁ll ▁ans ▁= ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁; ▁ll ▁max Possible ▁= ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁2 ▁; ▁i ▁>= ▁0 ▁; ▁-- ▁i ▁) ▁{ ▁if ▁( ▁max Possible ▁> ▁0 ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁>= ▁max Possible ▁) ▁{ ▁ans ▁+= ▁( ▁max Possible ▁- ▁1 ▁) ▁; ▁max Possible ▁= ▁max Possible ▁- ▁1 ▁; ▁} ▁else ▁{ ▁max Possible ▁= ▁arr ▁[ ▁i ▁] ▁; ▁ans ▁+= ▁max Possible ▁; ▁} ▁} ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁4 ▁, ▁1 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁find Max Value ▁( ▁arr ▁, ▁n ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁lex Numbers ▁( ▁int ▁n ▁) ▁{ ▁vector ▁< ▁string ▁> ▁s ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁s ▁. ▁push _ back ▁( ▁to _ string ▁( ▁i ▁) ▁) ▁; ▁} ▁sort ▁( ▁s ▁. ▁begin ▁( ▁) ▁, ▁s ▁. ▁end ▁( ▁) ▁) ▁; ▁vector ▁< ▁int ▁> ▁ans ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁ans ▁. ▁push _ back ▁( ▁sto i ▁( ▁s ▁[ ▁i ▁] ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁ans ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁15 ▁; ▁lex Numbers ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁sorted Ad jacent D ifferences ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁ans ▁[ ▁n ▁] ▁; ▁sort ▁( ▁arr ▁+ ▁0 ▁, ▁arr ▁+ ▁n ▁) ▁; ▁int ▁l ▁= ▁0 ▁, ▁r ▁= ▁n ▁- ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁i ▁% ▁2 ▁) ▁{ ▁ans ▁[ ▁i ▁] ▁= ▁arr ▁[ ▁l ▁] ▁; ▁l ▁++ ▁; ▁} ▁else ▁{ ▁ans ▁[ ▁i ▁] ▁= ▁arr ▁[ ▁r ▁] ▁; ▁r ▁-- ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁c out ▁<< ▁ans ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁-2 ▁, ▁4 ▁, ▁8 ▁, ▁6 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁sorted Ad jacent D ifferences ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁check Is AP ▁( ▁double ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁1 ▁) ▁return ▁true ▁; ▁sort ▁( ▁arr ▁, ▁arr ▁+ ▁n ▁) ▁; ▁double ▁d ▁= ▁arr ▁[ ▁1 ▁] ▁- ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁- ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁!= ▁d ▁) ▁{ ▁return ▁false ▁; ▁} ▁} ▁return ▁true ▁; ▁} ▁bool ▁check Is GP ▁( ▁double ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁1 ▁) ▁return ▁true ▁; ▁sort ▁( ▁arr ▁, ▁arr ▁+ ▁n ▁) ▁; ▁double ▁r ▁= ▁arr ▁[ ▁1 ▁] ▁/ ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁/ ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁!= ▁r ▁) ▁return ▁false ▁; ▁} ▁return ▁true ▁; ▁} ▁bool ▁check Is HP ▁( ▁double ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁1 ▁) ▁{ ▁return ▁true ▁; ▁} ▁double ▁rec ▁[ ▁n ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁rec ▁[ ▁i ▁] ▁= ▁( ▁( ▁1 ▁/ ▁arr ▁[ ▁i ▁] ▁) ▁) ▁; ▁} ▁if ▁( ▁check Is AP ▁( ▁rec ▁, ▁n ▁) ▁) ▁return ▁true ▁; ▁else ▁return ▁false ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁double ▁arr ▁[ ▁] ▁= ▁{ ▁1.0 ▁/ ▁5.0 ▁, ▁1.0 ▁/ ▁10.0 ▁, ▁1.0 ▁/ ▁15.0 ▁, ▁1.0 ▁/ ▁20.0 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁flag ▁= ▁0 ▁; ▁if ▁( ▁check Is AP ▁( ▁arr ▁, ▁n ▁) ▁) ▁{ ▁c out ▁<< ▁" ▁Yes ▁, ▁An ▁AP ▁can ▁be ▁formed ▁" ▁<< ▁end l ▁; ▁flag ▁= ▁1 ▁; ▁} ▁if ▁( ▁check Is GP ▁( ▁arr ▁, ▁n ▁) ▁) ▁{ ▁c out ▁<< ▁" ▁Yes ▁, ▁A ▁GP ▁can ▁be ▁formed ▁" ▁<< ▁end l ▁; ▁flag ▁= ▁1 ▁; ▁} ▁if ▁( ▁check Is HP ▁( ▁arr ▁, ▁n ▁) ▁) ▁{ ▁c out ▁<< ▁"
▁# include ▁" ▁bits ▁/ ▁std c ▁+ ▁+ ▁. ▁h ▁" ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁sortBy Freq ▁( ▁int ▁* ▁arr ▁, ▁int ▁n ▁) ▁{ ▁int ▁max E ▁= ▁-1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁max E ▁= ▁max ▁( ▁max E ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁int ▁freq ▁[ ▁max E ▁+ ▁1 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁freq ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁++ ▁; ▁} ▁int ▁cnt ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁max E ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁freq ▁[ ▁i ▁] ▁> ▁0 ▁) ▁{ ▁int ▁value ▁= ▁100000 ▁- ▁i ▁; ▁arr ▁[ ▁cnt ▁] ▁= ▁100000 ▁* ▁freq ▁[ ▁i ▁] ▁+ ▁value ▁; ▁cnt ▁++ ▁; ▁} ▁} ▁return ▁cnt ▁; ▁} ▁void ▁print Sorted Array ▁( ▁int ▁* ▁arr ▁, ▁int ▁cnt ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁cnt ▁; ▁i ▁++ ▁) ▁{ ▁int ▁frequency ▁= ▁arr ▁[ ▁i ▁] ▁/ ▁100000 ▁; ▁int ▁value ▁= ▁100000 ▁- ▁( ▁arr ▁[ ▁i ▁] ▁% ▁100000 ▁) ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁frequency ▁; ▁j ▁++ ▁) ▁{ ▁c out ▁<< ▁value ▁<< ▁' ▁' ▁; ▁} ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁, ▁4 ▁, ▁2 ▁, ▁2 ▁, ▁8 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁cnt ▁= ▁sortBy Freq ▁( ▁arr ▁, ▁n ▁) ▁; ▁sort ▁( ▁arr ▁, ▁arr ▁+ ▁cnt ▁, ▁greater ▁< ▁int ▁> ▁( ▁) ▁) ▁; ▁print Sorted Array ▁( ▁arr ▁, ▁cnt ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max Mod ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁max Val ▁= ▁* ▁max _ element ▁( ▁arr ▁, ▁arr ▁+ ▁n ▁) ▁; ▁int ▁second Max ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁max Val ▁&& ▁arr ▁[ ▁i ▁] ▁> ▁second Max ▁) ▁{ ▁second Max ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁} ▁return ▁second Max ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁4 ▁, ▁1 ▁, ▁5 ▁, ▁3 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁c out ▁<< ▁max Mod ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁isP ossible ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁B ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁m ▁, ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁if ▁( ▁x ▁> ▁n ▁y ▁> ▁m ▁) ▁return ▁false ▁; ▁sort ▁( ▁A ▁, ▁A ▁+ ▁n ▁) ▁; ▁sort ▁( ▁B ▁, ▁B ▁+ ▁m ▁) ▁; ▁if ▁( ▁A ▁[ ▁x ▁- ▁1 ▁] ▁< ▁B ▁[ ▁m ▁- ▁y ▁] ▁) ▁return ▁true ▁; ▁else ▁return ▁false ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁} ▁; ▁int ▁B ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁A ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁int ▁m ▁= ▁sizeof ▁( ▁B ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁int ▁x ▁= ▁3 ▁, ▁y ▁= ▁1 ▁; ▁if ▁( ▁isP ossible ▁( ▁A ▁, ▁B ▁, ▁n ▁, ▁m ▁, ▁x ▁, ▁y ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁getNumber ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁arr ▁[ ▁n ▁] ▁; ▁int ▁i ▁= ▁0 ▁; ▁int ▁odd ▁= ▁1 ▁; ▁while ▁( ▁odd ▁<= ▁n ▁) ▁{ ▁arr ▁[ ▁i ▁++ ▁] ▁= ▁odd ▁; ▁odd ▁+= ▁2 ▁; ▁} ▁int ▁even ▁= ▁2 ▁; ▁while ▁( ▁even ▁<= ▁n ▁) ▁{ ▁arr ▁[ ▁i ▁++ ▁] ▁= ▁even ▁; ▁even ▁+= ▁2 ▁; ▁} ▁return ▁arr ▁[ ▁k ▁- ▁1 ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁8 ▁, ▁k ▁= ▁5 ▁; ▁c out ▁<< ▁getNumber ▁( ▁n ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁MAX ▁10000 5 ▁NEW _ LINE ▁int ▁Min _ Replace ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁sort ▁( ▁arr ▁, ▁arr ▁+ ▁n ▁) ▁; ▁int ▁freq ▁[ ▁MAX ▁] ▁; ▁mem set ▁( ▁freq ▁, ▁0 ▁, ▁sizeof ▁freq ▁) ▁; ▁int ▁p ▁= ▁0 ▁; ▁freq ▁[ ▁p ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁) ▁++ ▁freq ▁[ ▁p ▁] ▁; ▁else ▁++ ▁freq ▁[ ▁++ ▁p ▁] ▁; ▁} ▁sort ▁( ▁freq ▁, ▁freq ▁+ ▁n ▁, ▁greater ▁< ▁int ▁> ▁( ▁) ▁) ▁; ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁k ▁; ▁i ▁<= ▁p ▁; ▁i ▁++ ▁) ▁ans ▁+= ▁freq ▁[ ▁i ▁] ▁; ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁7 ▁, ▁8 ▁, ▁2 ▁, ▁3 ▁, ▁2 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁k ▁= ▁2 ▁; ▁c out ▁<< ▁Min _ Replace ▁( ▁arr ▁, ▁n ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁Segment ▁( ▁int ▁x ▁[ ▁] ▁, ▁int ▁l ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁1 ▁) ▁return ▁1 ▁; ▁int ▁ans ▁= ▁2 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁x ▁[ ▁i ▁] ▁- ▁l ▁[ ▁i ▁] ▁> ▁x ▁[ ▁i ▁- ▁1 ▁] ▁) ▁ans ▁++ ▁; ▁else ▁if ▁( ▁x ▁[ ▁i ▁] ▁+ ▁l ▁[ ▁i ▁] ▁< ▁x ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁{ ▁x ▁[ ▁i ▁] ▁= ▁x ▁[ ▁i ▁] ▁+ ▁l ▁[ ▁i ▁] ▁; ▁ans ▁++ ▁; ▁} ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁x ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁8 ▁} ▁, ▁l ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁1 ▁, ▁2 ▁, ▁2 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁x ▁) ▁/ ▁sizeof ▁( ▁x ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁Segment ▁( ▁x ▁, ▁l ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print Arr angement ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁sort ▁( ▁a ▁, ▁a ▁+ ▁n ▁) ▁; ▁int ▁b ▁[ ▁n ▁] ▁; ▁int ▁low ▁= ▁0 ▁, ▁high ▁= ▁n ▁- ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁% ▁2 ▁== ▁0 ▁) ▁b ▁[ ▁low ▁++ ▁] ▁= ▁a ▁[ ▁i ▁] ▁; ▁else ▁b ▁[ ▁high ▁-- ▁] ▁= ▁a ▁[ ▁i ▁] ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁== ▁0 ▁) ▁{ ▁if ▁( ▁b ▁[ ▁n ▁- ▁1 ▁] ▁+ ▁b ▁[ ▁1 ▁] ▁<= ▁b ▁[ ▁i ▁] ▁) ▁{ ▁c out ▁<< ▁-1 ▁; ▁return ▁; ▁} ▁} ▁else ▁if ▁( ▁i ▁== ▁( ▁n ▁- ▁1 ▁) ▁) ▁{ ▁if ▁( ▁b ▁[ ▁n ▁- ▁2 ▁] ▁+ ▁b ▁[ ▁0 ▁] ▁<= ▁b ▁[ ▁i ▁] ▁) ▁{ ▁c out ▁<< ▁-1 ▁; ▁return ▁; ▁} ▁} ▁else ▁{ ▁if ▁( ▁b ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁b ▁[ ▁i ▁+ ▁1 ▁] ▁<= ▁b ▁[ ▁i ▁] ▁) ▁{ ▁c out ▁<< ▁-1 ▁; ▁return ▁; ▁} ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁b ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁4 ▁, ▁4 ▁, ▁3 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁print Arr angement ▁( ▁a ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁N ▁2 ▁NEW _ LINE ▁# define ▁M ▁2 ▁NEW _ LINE ▁bool ▁is Matrix Inc ▁( ▁int ▁a ▁[ ▁N ▁] ▁[ ▁M ▁] ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁M ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁i ▁- ▁1 ▁>= ▁0 ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁[ ▁j ▁] ▁<= ▁a ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁) ▁return ▁false ▁; ▁} ▁if ▁( ▁j ▁- ▁1 ▁>= ▁0 ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁[ ▁j ▁] ▁<= ▁a ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁) ▁return ▁false ▁; ▁} ▁} ▁} ▁return ▁true ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁N ▁] ▁[ ▁M ▁] ▁= ▁{ ▁{ ▁2 ▁, ▁10 ▁} ▁, ▁{ ▁11 ▁, ▁20 ▁} ▁} ▁; ▁if ▁( ▁is Matrix Inc ▁( ▁a ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁int ▁N ▁= ▁1 e 7 ▁+ ▁5 ▁; ▁bool ▁prime ▁[ ▁N ▁] ▁; ▁void ▁se ive ▁( ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁! ▁prime ▁[ ▁i ▁] ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁i ▁; ▁j ▁< ▁N ▁; ▁j ▁+= ▁i ▁) ▁{ ▁prime ▁[ ▁j ▁] ▁= ▁1 ▁; ▁} ▁} ▁} ▁prime ▁[ ▁1 ▁] ▁= ▁1 ▁; ▁} ▁int ▁maxSize Arr ▁( ▁int ▁* ▁arr ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁vector ▁< ▁int ▁> ▁v ▁, ▁diff ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁) ▁v ▁. ▁push _ back ▁( ▁i ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁v ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁diff ▁. ▁push _ back ▁( ▁v ▁[ ▁i ▁] ▁- ▁v ▁[ ▁i ▁- ▁1 ▁] ▁- ▁1 ▁) ▁; ▁} ▁sort ▁( ▁diff ▁. ▁begin ▁( ▁) ▁, ▁diff ▁. ▁end ▁( ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁diff ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁diff ▁[ ▁i ▁] ▁+= ▁diff ▁[ ▁i ▁- ▁1 ▁] ▁; ▁} ▁if ▁( ▁k ▁> ▁n ▁|| ▁( ▁k ▁== ▁0 ▁&& ▁v ▁. ▁size ▁( ▁) ▁) ▁) ▁{ ▁return ▁-1 ▁; ▁} ▁else ▁if ▁( ▁v ▁. ▁size ▁( ▁) ▁<= ▁k ▁) ▁{ ▁return ▁( ▁n ▁- ▁k ▁) ▁; ▁} ▁else ▁if ▁( ▁v ▁. ▁size ▁( ▁) ▁> ▁k ▁) ▁{ ▁int ▁tt ▁= ▁v ▁. ▁size ▁( ▁) ▁- ▁k ▁; ▁int ▁sum ▁= ▁0 ▁; ▁sum ▁+= ▁diff ▁[ ▁tt ▁- ▁1 ▁] ▁; ▁int ▁res ▁= ▁n ▁- ▁( ▁v ▁. ▁size ▁( ▁) ▁+ ▁sum ▁) ▁; ▁return ▁res ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁se ive ▁( ▁) ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁4 ▁, ▁2 ▁, ▁2 ▁, ▁4 ▁, ▁2 ▁, ▁4 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁k ▁= ▁2 ▁; ▁c
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁struct ▁Node ▁{ ▁int ▁data ▁; ▁struct ▁Node ▁* ▁next ▁; ▁} ▁; ▁bool ▁sort List ▁( ▁struct ▁Node ▁* ▁head ▁) ▁{ ▁int ▁start Val ▁= ▁1 ▁; ▁while ▁( ▁head ▁!= ▁NULL ▁) ▁{ ▁head ▁-> ▁data ▁= ▁start Val ▁; ▁start Val ▁++ ▁; ▁head ▁= ▁head ▁-> ▁next ▁; ▁} ▁} ▁void ▁push ▁( ▁struct ▁Node ▁* ▁* ▁head _ ref ▁, ▁int ▁new _ data ▁) ▁{ ▁struct ▁Node ▁* ▁new _ node ▁= ▁( ▁struct ▁Node ▁* ▁) ▁m alloc ▁( ▁sizeof ▁( ▁struct ▁Node ▁) ▁) ▁; ▁new _ node ▁-> ▁data ▁= ▁new _ data ▁; ▁new _ node ▁-> ▁next ▁= ▁( ▁* ▁head _ ref ▁) ▁; ▁( ▁* ▁head _ ref ▁) ▁= ▁new _ node ▁; ▁} ▁void ▁print List ▁( ▁struct ▁Node ▁* ▁node ▁) ▁{ ▁while ▁( ▁node ▁!= ▁NULL ▁) ▁{ ▁c out ▁<< ▁node ▁-> ▁data ▁<< ▁" ▁" ▁; ▁node ▁= ▁node ▁-> ▁next ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁struct ▁Node ▁* ▁start ▁= ▁NULL ▁; ▁push ▁( ▁& ▁start ▁, ▁2 ▁) ▁; ▁push ▁( ▁& ▁start ▁, ▁1 ▁) ▁; ▁push ▁( ▁& ▁start ▁, ▁6 ▁) ▁; ▁push ▁( ▁& ▁start ▁, ▁4 ▁) ▁; ▁push ▁( ▁& ▁start ▁, ▁5 ▁) ▁; ▁push ▁( ▁& ▁start ▁, ▁3 ▁) ▁; ▁sort List ▁( ▁start ▁) ▁; ▁print List ▁( ▁start ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Tri pl ets LessThan ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁val ▁) ▁{ ▁sort ▁( ▁arr ▁, ▁arr ▁+ ▁n ▁) ▁; ▁int ▁ans ▁= ▁0 ▁; ▁int ▁j ▁, ▁k ▁; ▁int ▁sum ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁j ▁= ▁i ▁+ ▁1 ▁; ▁k ▁= ▁n ▁- ▁1 ▁; ▁while ▁( ▁j ▁!= ▁k ▁) ▁{ ▁sum ▁= ▁arr ▁[ ▁i ▁] ▁+ ▁arr ▁[ ▁j ▁] ▁+ ▁arr ▁[ ▁k ▁] ▁; ▁if ▁( ▁sum ▁> ▁val ▁) ▁k ▁-- ▁; ▁else ▁{ ▁ans ▁+= ▁( ▁k ▁- ▁j ▁) ▁; ▁j ▁++ ▁; ▁} ▁} ▁} ▁return ▁ans ▁; ▁} ▁int ▁count Tri pl ets ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁int ▁res ▁; ▁res ▁= ▁count Tri pl ets LessThan ▁( ▁arr ▁, ▁n ▁, ▁b ▁) ▁- ▁count Tri pl ets LessThan ▁( ▁arr ▁, ▁n ▁, ▁a ▁- ▁1 ▁) ▁; ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁7 ▁, ▁5 ▁, ▁3 ▁, ▁8 ▁, ▁4 ▁, ▁1 ▁, ▁9 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁arr ▁/ ▁sizeof ▁arr ▁[ ▁0 ▁] ▁; ▁int ▁a ▁= ▁8 ▁, ▁b ▁= ▁16 ▁; ▁c out ▁<< ▁count Tri pl ets ▁( ▁arr ▁, ▁n ▁, ▁a ▁, ▁b ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max Level ▁( ▁int ▁boxes ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁sort ▁( ▁boxes ▁, ▁boxes ▁+ ▁n ▁) ▁; ▁int ▁prev _ width ▁= ▁boxes ▁[ ▁0 ▁] ▁; ▁int ▁prev _ count ▁= ▁1 ▁; ▁int ▁curr _ count ▁= ▁0 ▁; ▁int ▁curr _ width ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁curr _ width ▁+= ▁boxes ▁[ ▁i ▁] ▁; ▁curr _ count ▁+= ▁1 ▁; ▁if ▁( ▁curr _ width ▁> ▁prev _ width ▁&& ▁curr _ count ▁> ▁prev _ count ▁) ▁{ ▁prev _ width ▁= ▁curr _ width ▁; ▁prev _ count ▁= ▁curr _ count ▁; ▁curr _ count ▁= ▁0 ▁; ▁curr _ width ▁= ▁0 ▁; ▁ans ▁++ ▁; ▁} ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁boxes ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁20 ▁, ▁30 ▁, ▁50 ▁, ▁60 ▁, ▁70 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁boxes ▁) ▁/ ▁sizeof ▁( ▁boxes ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁max Level ▁( ▁boxes ▁, ▁n ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁int ▁merge ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁temp ▁[ ▁] ▁, ▁int ▁left ▁, ▁int ▁mid ▁, ▁int ▁right ▁) ▁{ ▁int ▁inv _ count ▁= ▁0 ▁; ▁int ▁i ▁= ▁left ▁; ▁int ▁j ▁= ▁mid ▁; ▁int ▁k ▁= ▁left ▁; ▁while ▁( ▁( ▁i ▁<= ▁mid ▁- ▁1 ▁) ▁&& ▁( ▁j ▁<= ▁right ▁) ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁<= ▁arr ▁[ ▁j ▁] ▁) ▁temp ▁[ ▁k ▁++ ▁] ▁= ▁arr ▁[ ▁i ▁++ ▁] ▁; ▁else ▁{ ▁temp ▁[ ▁k ▁++ ▁] ▁= ▁arr ▁[ ▁j ▁++ ▁] ▁; ▁inv _ count ▁= ▁inv _ count ▁+ ▁( ▁mid ▁- ▁i ▁) ▁; ▁} ▁} ▁while ▁( ▁i ▁<= ▁mid ▁- ▁1 ▁) ▁temp ▁[ ▁k ▁++ ▁] ▁= ▁arr ▁[ ▁i ▁++ ▁] ▁; ▁while ▁( ▁j ▁<= ▁right ▁) ▁temp ▁[ ▁k ▁++ ▁] ▁= ▁arr ▁[ ▁j ▁++ ▁] ▁; ▁for ▁( ▁i ▁= ▁left ▁; ▁i ▁<= ▁right ▁; ▁i ▁++ ▁) ▁arr ▁[ ▁i ▁] ▁= ▁temp ▁[ ▁i ▁] ▁; ▁return ▁inv _ count ▁; ▁} ▁int ▁_ merge Sort ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁temp ▁[ ▁] ▁, ▁int ▁left ▁, ▁int ▁right ▁) ▁{ ▁int ▁mid ▁, ▁inv _ count ▁= ▁0 ▁; ▁if ▁( ▁right ▁> ▁left ▁) ▁{ ▁mid ▁= ▁( ▁right ▁+ ▁left ▁) ▁/ ▁2 ▁; ▁inv _ count ▁= ▁_ merge Sort ▁( ▁arr ▁, ▁temp ▁, ▁left ▁, ▁mid ▁) ▁; ▁inv _ count ▁+= ▁_ merge Sort ▁( ▁arr ▁, ▁temp ▁, ▁mid ▁+ ▁1 ▁, ▁right ▁) ▁; ▁inv _ count ▁+= ▁merge ▁( ▁arr ▁, ▁temp ▁, ▁left ▁, ▁mid ▁+ ▁1 ▁, ▁right ▁) ▁; ▁} ▁return ▁inv _ count ▁; ▁} ▁int ▁count Sw aps ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁temp ▁[ ▁n ▁] ▁; ▁return ▁_ merge Sort ▁( ▁arr ▁, ▁temp ▁, ▁0 ▁, ▁n ▁- ▁1 ▁) ▁; ▁} ▁int ▁main ▁( ▁int ▁argv ▁, ▁char ▁* ▁* ▁args ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁20 ▁, ▁6 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁printf ▁( ▁" ▁Number ▁of ▁sw aps ▁is ▁% ▁d ▁STRNEWLINE ▁"
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁minimum Size Array ▁( ▁int ▁S ▁, ▁int ▁P ▁) ▁{ ▁if ▁( ▁S ▁== ▁P ▁) ▁{ ▁return ▁1 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁S ▁; ▁i ▁++ ▁) ▁{ ▁double ▁d ▁= ▁i ▁; ▁if ▁( ▁( ▁S ▁/ ▁d ▁) ▁>= ▁pow ▁( ▁P ▁, ▁1.0 ▁/ ▁d ▁) ▁) ▁{ ▁return ▁i ▁; ▁} ▁} ▁return ▁-1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁S ▁= ▁5 ▁, ▁P ▁= ▁6 ▁; ▁c out ▁<< ▁minimum Size Array ▁( ▁S ▁, ▁P ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max Sub seq ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁sort ▁( ▁arr ▁, ▁arr ▁+ ▁N ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁K ▁== ▁0 ▁) ▁break ▁; ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁0 ▁) ▁{ ▁arr ▁[ ▁i ▁] ▁= ▁- ▁arr ▁[ ▁i ▁] ▁; ▁K ▁-- ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁0 ▁) ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁return ▁sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁6 ▁, ▁-10 ▁, ▁-1 ▁, ▁0 ▁, ▁-4 ▁, ▁2 ▁} ▁; ▁int ▁K ▁= ▁2 ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁max Sub seq ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print The Array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁} ▁void ▁re arrange ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁if ▁( ▁N ▁& ▁1 ▁) ▁N ▁-- ▁; ▁int ▁odd _ idx ▁= ▁1 ▁, ▁even _ idx ▁= ▁0 ▁; ▁int ▁i ▁, ▁max _ elem ▁= ▁arr ▁[ ▁N ▁- ▁1 ▁] ▁+ ▁1 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁/ ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁arr ▁[ ▁i ▁] ▁+= ▁( ▁arr ▁[ ▁odd _ idx ▁] ▁% ▁max _ elem ▁) ▁* ▁max _ elem ▁; ▁odd _ idx ▁+= ▁2 ▁; ▁} ▁for ▁( ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁arr ▁[ ▁i ▁] ▁+= ▁( ▁arr ▁[ ▁even _ idx ▁] ▁% ▁max _ elem ▁) ▁* ▁max _ elem ▁; ▁even _ idx ▁+= ▁2 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁arr ▁[ ▁i ▁] ▁= ▁arr ▁[ ▁i ▁] ▁/ ▁max _ elem ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁16 ▁, ▁18 ▁, ▁19 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁re arrange ▁( ▁arr ▁, ▁N ▁) ▁; ▁print The Array ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁check ▁( ▁int ▁num ▁) ▁{ ▁int ▁sm ▁= ▁0 ▁; ▁int ▁num 2 ▁= ▁num ▁* ▁num ▁; ▁while ▁( ▁num ▁) ▁{ ▁sm ▁+= ▁num ▁% ▁10 ▁; ▁num ▁/= ▁10 ▁; ▁} ▁int ▁sm 2 ▁= ▁0 ▁; ▁while ▁( ▁num 2 ▁) ▁{ ▁sm 2 ▁+= ▁num 2 ▁% ▁10 ▁; ▁num 2 ▁/= ▁10 ▁; ▁} ▁return ▁( ▁( ▁sm ▁* ▁sm ▁) ▁== ▁sm 2 ▁) ▁; ▁} ▁int ▁convert ▁( ▁string ▁s ▁) ▁{ ▁int ▁val ▁= ▁0 ▁; ▁reverse ▁( ▁s ▁. ▁begin ▁( ▁) ▁, ▁s ▁. ▁end ▁( ▁) ▁) ▁; ▁int ▁cur ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁val ▁+= ▁( ▁s ▁[ ▁i ▁] ▁- ▁'0' ▁) ▁* ▁cur ▁; ▁cur ▁*= ▁10 ▁; ▁} ▁return ▁val ▁; ▁} ▁void ▁generate ▁( ▁string ▁s ▁, ▁int ▁len ▁, ▁set ▁< ▁int ▁> ▁& ▁uniq ▁) ▁{ ▁if ▁( ▁s ▁. ▁size ▁( ▁) ▁== ▁len ▁) ▁{ ▁if ▁( ▁check ▁( ▁convert ▁( ▁s ▁) ▁) ▁) ▁{ ▁uniq ▁. ▁insert ▁( ▁convert ▁( ▁s ▁) ▁) ▁; ▁} ▁return ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁3 ▁; ▁i ▁++ ▁) ▁{ ▁generate ▁( ▁s ▁+ ▁char ▁( ▁i ▁+ ▁'0' ▁) ▁, ▁len ▁, ▁uniq ▁) ▁; ▁} ▁} ▁int ▁total Numbers ▁( ▁int ▁L ▁, ▁int ▁R ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁int ▁max _ len ▁= ▁log 10 ▁( ▁R ▁) ▁+ ▁1 ▁; ▁set ▁< ▁int ▁> ▁uniq ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁max _ len ▁; ▁i ▁++ ▁) ▁{ ▁generate ▁( ▁" ▁" ▁, ▁i ▁, ▁uniq ▁) ▁; ▁} ▁for ▁( ▁auto ▁x ▁: ▁uniq ▁) ▁{ ▁if ▁( ▁x ▁>= ▁L ▁&& ▁x ▁<= ▁R ▁) ▁{ ▁ans ▁++ ▁; ▁} ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁L ▁= ▁22 ▁, ▁R ▁= ▁22 ▁; ▁c out ▁<< ▁total Numbers ▁( ▁L ▁, ▁R ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Arrays ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁div is ors ▁( ▁k ▁+ ▁1 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁k ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁2 ▁* ▁i ▁; ▁j ▁<= ▁k ▁; ▁j ▁+= ▁i ▁) ▁{ ▁div is ors ▁[ ▁j ▁] ▁. ▁push _ back ▁( ▁i ▁) ▁; ▁} ▁} ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁dp ▁( ▁n ▁+ ▁1 ▁, ▁vector ▁< ▁int ▁> ▁( ▁k ▁+ ▁1 ▁) ▁) ▁; ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁<= ▁k ▁; ▁j ▁++ ▁) ▁{ ▁dp ▁[ ▁1 ▁] ▁[ ▁j ▁] ▁= ▁1 ▁; ▁} ▁for ▁( ▁int ▁x ▁= ▁2 ▁; ▁x ▁<= ▁n ▁; ▁x ▁++ ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁<= ▁k ▁; ▁j ▁++ ▁) ▁{ ▁sum ▁+= ▁dp ▁[ ▁x ▁- ▁1 ▁] ▁[ ▁j ▁] ▁; ▁} ▁for ▁( ▁int ▁y ▁= ▁1 ▁; ▁y ▁<= ▁k ▁; ▁y ▁++ ▁) ▁{ ▁dp ▁[ ▁x ▁] ▁[ ▁y ▁] ▁= ▁sum ▁; ▁for ▁( ▁int ▁d ▁: ▁div is ors ▁[ ▁y ▁] ▁) ▁{ ▁dp ▁[ ▁x ▁] ▁[ ▁y ▁] ▁= ▁( ▁dp ▁[ ▁x ▁] ▁[ ▁y ▁] ▁- ▁dp ▁[ ▁x ▁- ▁1 ▁] ▁[ ▁d ▁] ▁) ▁; ▁} ▁} ▁} ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁<= ▁k ▁; ▁j ▁++ ▁) ▁{ ▁sum ▁+= ▁dp ▁[ ▁n ▁] ▁[ ▁j ▁] ▁; ▁} ▁return ▁sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁2 ▁, ▁K ▁= ▁3 ▁; ▁c out ▁<< ▁count Arrays ▁( ▁N ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Maximum Points ▁( ▁int ▁N ▁, ▁int ▁X ▁[ ▁] ▁, ▁int ▁H ▁[ ▁] ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁int ▁prev ▁= ▁INT _ MIN ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁prev ▁< ▁( ▁X ▁[ ▁i ▁] ▁- ▁H ▁[ ▁i ▁] ▁) ▁) ▁{ ▁++ ▁ans ▁; ▁prev ▁= ▁X ▁[ ▁i ▁] ▁; ▁} ▁else ▁if ▁( ▁i ▁== ▁N ▁- ▁1 ▁|| ▁( ▁X ▁[ ▁i ▁] ▁+ ▁H ▁[ ▁i ▁] ▁) ▁< ▁X ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁{ ▁++ ▁ans ▁; ▁prev ▁= ▁X ▁[ ▁i ▁] ▁+ ▁H ▁[ ▁i ▁] ▁; ▁} ▁else ▁{ ▁prev ▁= ▁X ▁[ ▁i ▁] ▁; ▁} ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁X ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁; ▁int ▁H ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁5 ▁, ▁5 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁X ▁) ▁/ ▁sizeof ▁( ▁X ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁find Maximum Points ▁( ▁N ▁, ▁X ▁, ▁H ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁possible Numbers ▁( ▁set ▁< ▁int ▁> ▁& ▁numbers ▁, ▁int ▁N ▁, ▁int ▁M ▁, ▁int ▁A ▁, ▁int ▁B ▁) ▁{ ▁if ▁( ▁M ▁== ▁0 ▁) ▁{ ▁numbers ▁. ▁insert ▁( ▁N ▁) ▁; ▁return ▁; ▁} ▁possible Numbers ▁( ▁numbers ▁, ▁N ▁+ ▁A ▁, ▁M ▁- ▁1 ▁, ▁A ▁, ▁B ▁) ▁; ▁possible Numbers ▁( ▁numbers ▁, ▁N ▁+ ▁B ▁, ▁M ▁- ▁1 ▁, ▁A ▁, ▁B ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁5 ▁, ▁M ▁= ▁3 ▁, ▁A ▁= ▁4 ▁, ▁B ▁= ▁6 ▁; ▁set ▁< ▁int ▁> ▁numbers ▁; ▁possible Numbers ▁( ▁numbers ▁, ▁N ▁, ▁M ▁, ▁A ▁, ▁B ▁) ▁; ▁for ▁( ▁int ▁x ▁: ▁numbers ▁) ▁{ ▁c out ▁<< ▁x ▁<< ▁" ▁" ▁; ▁} ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁reduce ToOne ▁( ▁long ▁long ▁int ▁N ▁) ▁{ ▁int ▁cnt ▁= ▁0 ▁; ▁while ▁( ▁N ▁!= ▁1 ▁) ▁{ ▁if ▁( ▁N ▁== ▁2 ▁or ▁( ▁N ▁% ▁2 ▁== ▁1 ▁) ▁) ▁{ ▁N ▁= ▁N ▁- ▁1 ▁; ▁cnt ▁++ ▁; ▁} ▁else ▁if ▁( ▁N ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁N ▁= ▁N ▁/ ▁( ▁N ▁/ ▁2 ▁) ▁; ▁cnt ▁++ ▁; ▁} ▁} ▁return ▁cnt ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁long ▁long ▁int ▁N ▁= ▁35 ▁; ▁c out ▁<< ▁reduce ToOne ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁solve ▁( ▁int ▁S ▁, ▁int ▁K ▁, ▁int ▁N ▁) ▁{ ▁if ▁( ▁K ▁> ▁N ▁) ▁{ ▁c out ▁<< ▁" ▁- ▁1" ▁<< ▁end l ▁; ▁return ▁; ▁} ▁int ▁max _ sum ▁= ▁0 ▁, ▁min _ sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁K ▁; ▁i ▁++ ▁) ▁{ ▁min _ sum ▁+= ▁i ▁; ▁max _ sum ▁+= ▁N ▁- ▁i ▁+ ▁1 ▁; ▁} ▁if ▁( ▁S ▁< ▁min _ sum ▁S ▁> ▁max _ sum ▁) ▁{ ▁c out ▁<< ▁" ▁- ▁1" ▁<< ▁end l ▁; ▁return ▁; ▁} ▁int ▁s 1 ▁= ▁0 ▁; ▁vector ▁< ▁int ▁> ▁nums ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s 1 ▁> ▁S ▁) ▁break ▁; ▁s 1 ▁+= ▁i ▁; ▁nums ▁. ▁push _ back ▁( ▁i ▁) ▁; ▁} ▁vector ▁< ▁int ▁> ▁answer ▁; ▁int ▁s 2 ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁K ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁answer ▁. ▁push _ back ▁( ▁nums ▁[ ▁i ▁] ▁) ▁; ▁s 2 ▁+= ▁nums ▁[ ▁i ▁] ▁; ▁} ▁answer ▁. ▁push _ back ▁( ▁S ▁- ▁s 2 ▁) ▁; ▁int ▁Max ▁= ▁N ▁; ▁for ▁( ▁int ▁i ▁= ▁answer ▁. ▁size ▁( ▁) ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁answer ▁[ ▁i ▁] ▁> ▁Max ▁) ▁{ ▁int ▁extra ▁= ▁answer ▁[ ▁i ▁] ▁- ▁Max ▁; ▁if ▁( ▁i ▁- ▁1 ▁>= ▁0 ▁) ▁answer ▁[ ▁i ▁- ▁1 ▁] ▁+= ▁extra ▁; ▁answer ▁[ ▁i ▁] ▁= ▁Max ▁; ▁Max ▁-- ▁; ▁} ▁else ▁break ▁; ▁} ▁for ▁( ▁auto ▁x ▁: ▁answer ▁) ▁c out ▁<< ▁x ▁<< ▁" ▁" ▁; ▁c out ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁S ▁= ▁15 ▁, ▁K ▁= ▁4 ▁, ▁N ▁= ▁8 ▁; ▁solve ▁( ▁S ▁, ▁K ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁minSize Arr ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁sum ▁+= ▁A ▁[ ▁i ▁] ▁; ▁if ▁( ▁K ▁> ▁sum ▁) ▁{ ▁c out ▁<< ▁-1 ▁; ▁return ▁; ▁} ▁if ▁( ▁K ▁== ▁sum ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁c out ▁<< ▁A ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁} ▁return ▁; ▁} ▁int ▁tar ▁= ▁sum ▁- ▁K ▁; ▁unordered _ map ▁< ▁int ▁, ▁int ▁> ▁um ▁; ▁um ▁[ ▁0 ▁] ▁= ▁-1 ▁; ▁int ▁left ▁, ▁right ▁; ▁int ▁cur ▁= ▁0 ▁, ▁max i ▁= ▁-1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁cur ▁+= ▁A ▁[ ▁i ▁] ▁; ▁if ▁( ▁um ▁. ▁find ▁( ▁cur ▁- ▁tar ▁) ▁!= ▁um ▁. ▁end ▁( ▁) ▁&& ▁i ▁- ▁um ▁[ ▁cur ▁- ▁tar ▁] ▁> ▁max i ▁) ▁{ ▁max i ▁= ▁i ▁- ▁um ▁[ ▁cur ▁- ▁tar ▁] ▁; ▁right ▁= ▁i ▁; ▁left ▁= ▁um ▁[ ▁cur ▁- ▁tar ▁] ▁; ▁} ▁if ▁( ▁um ▁. ▁find ▁( ▁cur ▁) ▁== ▁um ▁. ▁end ▁( ▁) ▁) ▁um ▁[ ▁cur ▁] ▁= ▁i ▁; ▁} ▁if ▁( ▁max i ▁== ▁-1 ▁) ▁c out ▁<< ▁-1 ▁; ▁else ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁left ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁A ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁right ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁A ▁[ ▁N ▁- ▁i ▁- ▁1 ▁] ▁<< ▁" ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁7 ▁; ▁int ▁A ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁2 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁3 ▁} ▁; ▁int ▁K ▁= ▁10 ▁; ▁minSize Arr ▁( ▁A ▁, ▁N ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find Equ ation ▁( ▁int ▁A ▁, ▁int ▁B ▁, ▁int ▁C ▁, ▁int ▁K ▁) ▁{ ▁c out ▁<< ▁A ▁<< ▁" ▁" ▁<< ▁K ▁* ▁B ▁<< ▁" ▁" ▁<< ▁K ▁* ▁K ▁* ▁C ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁= ▁1 ▁, ▁B ▁= ▁2 ▁, ▁C ▁= ▁1 ▁, ▁K ▁= ▁2 ▁; ▁find Equ ation ▁( ▁A ▁, ▁B ▁, ▁C ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁can Array Be Red uced ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁if ▁( ▁N ▁== ▁1 ▁) ▁{ ▁c out ▁<< ▁arr ▁[ ▁0 ▁] ▁; ▁return ▁; ▁} ▁if ▁( ▁arr ▁[ ▁0 ▁] ▁< ▁arr ▁[ ▁N ▁- ▁1 ▁] ▁) ▁{ ▁c out ▁<< ▁arr ▁[ ▁N ▁- ▁1 ▁] ▁; ▁} ▁else ▁c out ▁<< ▁" ▁Not ▁Possible ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁6 ▁, ▁5 ▁, ▁2 ▁, ▁4 ▁, ▁1 ▁, ▁3 ▁, ▁7 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁can Array Be Red uced ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁construct Array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁br r ▁[ ▁N ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁int ▁K ▁= ▁log ▁( ▁arr ▁[ ▁i ▁] ▁) ▁/ ▁log ▁( ▁2 ▁) ▁; ▁int ▁R ▁= ▁pow ▁( ▁2 ▁, ▁K ▁) ▁; ▁br r ▁[ ▁i ▁] ▁= ▁R ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁c out ▁<< ▁br r ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁11 ▁, ▁5 ▁, ▁7 ▁, ▁3 ▁, ▁2 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁construct Array ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁min Ops To Turn Arr To Zero ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁unordered _ set ▁< ▁int ▁> ▁st ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁st ▁. ▁find ▁( ▁arr ▁[ ▁i ▁] ▁) ▁!= ▁st ▁. ▁end ▁( ▁) ▁arr ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁continue ▁; ▁} ▁else ▁{ ▁st ▁. ▁insert ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁} ▁c out ▁<< ▁st ▁. ▁size ▁( ▁) ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁7 ▁, ▁3 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁min Ops To Turn Arr To Zero ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁Check All Equal ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁0 ▁] ▁!= ▁arr ▁[ ▁i ▁] ▁) ▁{ ▁return ▁false ▁; ▁} ▁} ▁return ▁true ▁; ▁} ▁int ▁min Cnt Operations ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁Max ▁= ▁* ▁max _ element ▁( ▁arr ▁, ▁arr ▁+ ▁N ▁) ▁; ▁bool ▁is Power 2 ▁= ▁! ▁( ▁Max ▁&& ▁( ▁Max ▁& ▁( ▁Max ▁- ▁1 ▁) ▁) ▁) ▁; ▁if ▁( ▁is Power 2 ▁&& ▁Check All Equal ▁( ▁arr ▁, ▁N ▁) ▁) ▁{ ▁return ▁log 2 ▁( ▁Max ▁) ▁; ▁} ▁else ▁{ ▁return ▁ceil ▁( ▁log 2 ▁( ▁Max ▁) ▁) ▁+ ▁1 ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁4 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁min Cnt Operations ▁( ▁arr ▁, ▁N ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Max Val By Re arr Arr ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁sort ▁( ▁arr ▁, ▁arr ▁+ ▁N ▁) ▁; ▁int ▁res ▁= ▁0 ▁; ▁do ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁__ g cd ▁( ▁i ▁+ ▁1 ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁res ▁= ▁max ▁( ▁res ▁, ▁sum ▁) ▁; ▁} ▁while ▁( ▁next _ perm utation ▁( ▁arr ▁, ▁arr ▁+ ▁N ▁) ▁) ▁; ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁2 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁find Max Val By Re arr Arr ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁sum zero ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁if ▁( ▁sum ▁== ▁0 ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁else ▁if ▁( ▁sum ▁> ▁0 ▁) ▁{ ▁if ▁( ▁sum ▁% ▁K ▁== ▁0 ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁; ▁} ▁else ▁c out ▁<< ▁" ▁No ▁" ▁; ▁return ▁0 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁K ▁, ▁N ▁; ▁int ▁arr 1 ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁- 6 ▁, ▁2 ▁, ▁2 ▁} ▁; ▁K ▁= ▁1 ▁; ▁N ▁= ▁sizeof ▁( ▁arr 1 ▁) ▁/ ▁sizeof ▁( ▁arr 1 ▁[ ▁0 ▁] ▁) ▁; ▁sum zero ▁( ▁arr 1 ▁, ▁N ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁path _ to _ root ▁( ▁int ▁node ▁) ▁{ ▁while ▁( ▁node ▁>= ▁1 ▁) ▁{ ▁c out ▁<< ▁node ▁<< ▁' ▁' ▁; ▁node ▁/= ▁2 ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁7 ▁; ▁path _ to _ root ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find Small est Number Possible ▁( ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁if ▁( ▁N ▁> ▁45 ▁* ▁K ▁) ▁{ ▁c out ▁<< ▁" ▁- ▁1" ▁; ▁return ▁; ▁} ▁string ▁res ▁= ▁" ▁" ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁9 ▁; ▁i ▁>= ▁1 ▁; ▁) ▁{ ▁if ▁( ▁count ▁== ▁K ▁) ▁{ ▁i ▁-- ▁; ▁count ▁= ▁0 ▁; ▁} ▁if ▁( ▁N ▁> ▁i ▁) ▁{ ▁N ▁-= ▁i ▁; ▁res ▁+= ▁( ▁char ▁) ▁48 ▁+ ▁i ▁; ▁} ▁else ▁{ ▁res ▁+= ▁( ▁char ▁) ▁N ▁+ ▁48 ▁; ▁N ▁= ▁0 ▁; ▁break ▁; ▁} ▁count ▁++ ▁; ▁} ▁reverse ▁( ▁res ▁. ▁begin ▁( ▁) ▁, ▁res ▁. ▁end ▁( ▁) ▁) ▁; ▁c out ▁<< ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁25 ▁, ▁K ▁= ▁3 ▁; ▁find Small est Number Possible ▁( ▁N ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁result ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁> ▁45 ▁) ▁{ ▁c out ▁<< ▁-1 ▁; ▁return ▁; ▁} ▁string ▁res ▁; ▁int ▁digit ▁= ▁9 ▁; ▁while ▁( ▁n ▁> ▁digit ▁) ▁{ ▁res ▁= ▁char ▁( ▁'0' ▁+ ▁digit ▁) ▁+ ▁res ▁; ▁n ▁-= ▁digit ▁; ▁digit ▁-= ▁1 ▁; ▁} ▁if ▁( ▁n ▁> ▁0 ▁) ▁{ ▁res ▁= ▁char ▁( ▁'0' ▁+ ▁n ▁) ▁+ ▁res ▁; ▁} ▁c out ▁<< ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁19 ▁; ▁result ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find Numbers ▁( ▁int ▁a X OR b ▁, ▁int ▁a AND b ▁, ▁int ▁a X OR c ▁, ▁int ▁a AND c ▁, ▁int ▁b X OR c ▁, ▁int ▁b AND c ▁) ▁{ ▁int ▁a ▁, ▁b ▁, ▁c ▁; ▁int ▁a SUM b ▁; ▁int ▁a SUM c ▁; ▁int ▁b SUM c ▁; ▁a SUM b ▁= ▁a X OR b ▁+ ▁a AND b ▁* ▁2 ▁; ▁a SUM c ▁= ▁a X OR c ▁+ ▁a AND c ▁* ▁2 ▁; ▁b SUM c ▁= ▁b X OR c ▁+ ▁b AND c ▁* ▁2 ▁; ▁a ▁= ▁( ▁a SUM b ▁- ▁b SUM c ▁+ ▁a SUM c ▁) ▁/ ▁2 ▁; ▁b ▁= ▁a SUM b ▁- ▁a ▁; ▁c ▁= ▁a SUM c ▁- ▁a ▁; ▁c out ▁<< ▁" ▁a ▁= ▁" ▁<< ▁a ▁; ▁c out ▁<< ▁" ▁, ▁b ▁= ▁" ▁<< ▁b ▁; ▁c out ▁<< ▁" ▁, ▁c ▁= ▁" ▁<< ▁c ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a X OR b ▁= ▁30 ▁, ▁a AND b ▁= ▁0 ▁, ▁a X OR c ▁= ▁20 ▁, ▁a AND c ▁= ▁10 ▁, ▁b X OR c ▁= ▁10 ▁, ▁b AND c ▁= ▁20 ▁; ▁find Numbers ▁( ▁a X OR b ▁, ▁a AND b ▁, ▁a X OR c ▁, ▁a AND c ▁, ▁b X OR c ▁, ▁b AND c ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Number ▁( ▁int ▁N ▁) ▁{ ▁return ▁N ▁& ▁( ▁N ▁+ ▁1 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁39 ▁; ▁c out ▁<< ▁find Number ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Bit wise OR Given X OR AND ▁( ▁int ▁X ▁, ▁int ▁Y ▁) ▁{ ▁return ▁X ▁+ ▁Y ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁X ▁= ▁5 ▁, ▁Y ▁= ▁2 ▁; ▁c out ▁<< ▁find Bit wise OR Given X OR AND ▁( ▁X ▁, ▁Y ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁min Operation ▁( ▁int ▁X ▁[ ▁] ▁, ▁int ▁Y ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁C ▁= ▁0 ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁= ▁i ▁+ ▁2 ▁) ▁{ ▁if ▁( ▁X ▁[ ▁i ▁] ▁!= ▁Y ▁[ ▁i ▁] ▁) ▁{ ▁count ▁++ ▁; ▁} ▁else ▁{ ▁if ▁( ▁count ▁!= ▁0 ▁) ▁C ▁++ ▁; ▁count ▁= ▁0 ▁; ▁} ▁} ▁if ▁( ▁count ▁!= ▁0 ▁) ▁C ▁++ ▁; ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁= ▁i ▁+ ▁2 ▁) ▁{ ▁if ▁( ▁X ▁[ ▁i ▁] ▁!= ▁Y ▁[ ▁i ▁] ▁) ▁{ ▁count ▁++ ▁; ▁} ▁else ▁{ ▁if ▁( ▁count ▁!= ▁0 ▁) ▁C ▁++ ▁; ▁count ▁= ▁0 ▁; ▁} ▁} ▁if ▁( ▁count ▁!= ▁0 ▁) ▁C ▁++ ▁; ▁c out ▁<< ▁C ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁X ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁} ▁; ▁int ▁Y ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁X ▁) ▁/ ▁sizeof ▁( ▁X ▁[ ▁0 ▁] ▁) ▁; ▁min Operation ▁( ▁X ▁, ▁Y ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁Remove _ one _ element ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁post _ odd ▁= ▁0 ▁, ▁post _ even ▁= ▁0 ▁; ▁int ▁curr _ odd ▁= ▁0 ▁, ▁curr _ even ▁= ▁0 ▁; ▁int ▁res ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁i ▁% ▁2 ▁) ▁post _ odd ▁^= ▁arr ▁[ ▁i ▁] ▁; ▁else ▁post _ even ▁^= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁% ▁2 ▁) ▁post _ odd ▁^= ▁arr ▁[ ▁i ▁] ▁; ▁else ▁post _ even ▁^= ▁arr ▁[ ▁i ▁] ▁; ▁int ▁X ▁= ▁curr _ odd ▁^ ▁post _ even ▁; ▁int ▁Y ▁= ▁curr _ even ▁^ ▁post _ odd ▁; ▁if ▁( ▁X ▁== ▁Y ▁) ▁res ▁++ ▁; ▁if ▁( ▁i ▁% ▁2 ▁) ▁curr _ odd ▁^= ▁arr ▁[ ▁i ▁] ▁; ▁else ▁curr _ even ▁^= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁c out ▁<< ▁res ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁Remove _ one _ element ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁min Cost ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁arr _ size ▁) ▁{ ▁int ▁odd ▁= ▁0 ▁, ▁even ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁arr _ size ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁% ▁2 ▁== ▁0 ▁) ▁even ▁++ ▁; ▁else ▁odd ▁++ ▁; ▁} ▁c out ▁<< ▁min ▁( ▁even ▁, ▁odd ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁; ▁int ▁arr _ size ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁min Cost ▁( ▁arr ▁, ▁arr _ size ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁GC D ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁if ▁( ▁b ▁== ▁0 ▁) ▁return ▁a ▁; ▁return ▁GC D ▁( ▁b ▁, ▁a ▁% ▁b ▁) ▁; ▁} ▁int ▁find Partition ▁( ▁int ▁nums ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁prefix ▁[ ▁N ▁] ▁, ▁suffix ▁[ ▁N ▁] ▁, ▁i ▁, ▁k ▁; ▁prefix ▁[ ▁0 ▁] ▁= ▁nums ▁[ ▁0 ▁] ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁prefix ▁[ ▁i ▁] ▁= ▁prefix ▁[ ▁i ▁- ▁1 ▁] ▁* ▁nums ▁[ ▁i ▁] ▁; ▁} ▁suffix ▁[ ▁N ▁- ▁1 ▁] ▁= ▁nums ▁[ ▁N ▁- ▁1 ▁] ▁; ▁for ▁( ▁i ▁= ▁N ▁- ▁2 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁suffix ▁[ ▁i ▁] ▁= ▁suffix ▁[ ▁i ▁+ ▁1 ▁] ▁* ▁nums ▁[ ▁i ▁] ▁; ▁} ▁for ▁( ▁k ▁= ▁0 ▁; ▁k ▁< ▁N ▁- ▁1 ▁; ▁k ▁++ ▁) ▁{ ▁if ▁( ▁GC D ▁( ▁prefix ▁[ ▁k ▁] ▁, ▁suffix ▁[ ▁k ▁+ ▁1 ▁] ▁) ▁== ▁1 ▁) ▁{ ▁return ▁k ▁; ▁} ▁} ▁return ▁-1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁find Partition ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁pal indrome Matrix ▁( ▁int ▁N ▁, ▁int ▁M ▁, ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁arr ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁( ▁N ▁+ ▁1 ▁) ▁/ ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁( ▁M ▁+ ▁1 ▁) ▁/ ▁2 ▁; ▁j ▁++ ▁) ▁{ ▁set ▁< ▁pair ▁< ▁int ▁, ▁int ▁> ▁> ▁s ▁; ▁s ▁. ▁insert ▁( ▁{ ▁i ▁, ▁j ▁} ▁) ▁; ▁s ▁. ▁insert ▁( ▁{ ▁i ▁, ▁M ▁- ▁j ▁- ▁1 ▁} ▁) ▁; ▁s ▁. ▁insert ▁( ▁{ ▁N ▁- ▁i ▁- ▁1 ▁, ▁j ▁} ▁) ▁; ▁s ▁. ▁insert ▁( ▁{ ▁N ▁- ▁i ▁- ▁1 ▁, ▁M ▁- ▁j ▁- ▁1 ▁} ▁) ▁; ▁vector ▁< ▁int ▁> ▁values ▁; ▁for ▁( ▁pair ▁< ▁int ▁, ▁int ▁> ▁p ▁: ▁s ▁) ▁{ ▁values ▁. ▁push _ back ▁( ▁arr ▁[ ▁p ▁. ▁first ▁] ▁[ ▁p ▁. ▁second ▁] ▁) ▁; ▁} ▁int ▁max ▁= ▁* ▁max _ element ▁( ▁values ▁. ▁begin ▁( ▁) ▁, ▁values ▁. ▁end ▁( ▁) ▁) ▁; ▁for ▁( ▁int ▁k ▁= ▁0 ▁; ▁k ▁< ▁values ▁. ▁size ▁( ▁) ▁; ▁k ▁++ ▁) ▁{ ▁ans ▁+= ▁max ▁- ▁values ▁[ ▁k ▁] ▁; ▁} ▁} ▁} ▁c out ▁<< ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁3 ▁, ▁M ▁= ▁3 ▁; ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁arr ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁, ▁1 ▁} ▁, ▁{ ▁3 ▁, ▁4 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁2 ▁, ▁1 ▁} ▁} ▁; ▁pal indrome Matrix ▁( ▁N ▁, ▁M ▁, ▁arr ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁vector ▁< ▁int ▁> ▁re arrange Array ▁( ▁vector ▁< ▁int ▁> ▁& ▁A ▁, ▁vector ▁< ▁int ▁> ▁& ▁B ▁, ▁int ▁N ▁) ▁{ ▁map ▁< ▁int ▁, ▁int ▁> ▁m ▁; ▁int ▁xor _ value ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁xor _ value ▁^= ▁A ▁[ ▁i ▁] ▁; ▁xor _ value ▁^= ▁B ▁[ ▁i ▁] ▁; ▁m ▁[ ▁B ▁[ ▁i ▁] ▁] ▁++ ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁B ▁[ ▁i ▁] ▁= ▁A ▁[ ▁i ▁] ▁^ ▁xor _ value ▁; ▁if ▁( ▁m ▁[ ▁B ▁[ ▁i ▁] ▁] ▁) ▁{ ▁m ▁[ ▁B ▁[ ▁i ▁] ▁] ▁-- ▁; ▁} ▁else ▁return ▁vector ▁< ▁int ▁> ▁{ ▁} ▁; ▁} ▁return ▁B ▁; ▁} ▁void ▁re arrange Array Util ▁( ▁vector ▁< ▁int ▁> ▁& ▁A ▁, ▁vector ▁< ▁int ▁> ▁& ▁B ▁, ▁int ▁N ▁) ▁{ ▁vector ▁< ▁int ▁> ▁ans ▁= ▁re arrange Array ▁( ▁A ▁, ▁B ▁, ▁N ▁) ▁; ▁if ▁( ▁ans ▁. ▁size ▁( ▁) ▁) ▁{ ▁for ▁( ▁auto ▁x ▁: ▁ans ▁) ▁{ ▁c out ▁<< ▁x ▁<< ▁" ▁" ▁; ▁} ▁} ▁else ▁{ ▁c out ▁<< ▁" ▁- ▁1" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁int ▁> ▁A ▁= ▁{ ▁13 ▁, ▁21 ▁, ▁33 ▁, ▁49 ▁, ▁53 ▁} ▁; ▁vector ▁< ▁int ▁> ▁B ▁= ▁{ ▁54 ▁, ▁50 ▁, ▁34 ▁, ▁22 ▁, ▁14 ▁} ▁; ▁int ▁N ▁= ▁( ▁int ▁) ▁A ▁. ▁size ▁( ▁) ▁; ▁re arrange Array Util ▁( ▁A ▁, ▁B ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Of Sub array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁unordered _ map ▁< ▁int ▁, ▁int ▁> ▁mp ▁; ▁int ▁answer ▁= ▁0 ▁; ▁int ▁sum ▁= ▁0 ▁; ▁mp ▁[ ▁1 ▁] ▁++ ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁answer ▁+= ▁mp ▁[ ▁sum ▁- ▁i ▁] ▁; ▁mp ▁[ ▁sum ▁- ▁i ▁] ▁++ ▁; ▁} ▁c out ▁<< ▁answer ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁0 ▁, ▁2 ▁, ▁1 ▁, ▁2 ▁, ▁-2 ▁, ▁2 ▁, ▁4 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁arr ▁/ ▁sizeof ▁arr ▁[ ▁0 ▁] ▁; ▁count Of Sub array ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁gcd ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁if ▁( ▁a ▁== ▁0 ▁) ▁return ▁b ▁; ▁return ▁gcd ▁( ▁b ▁% ▁a ▁, ▁a ▁) ▁; ▁} ▁void ▁count Inverse ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁M ▁) ▁{ ▁int ▁XOR ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁int ▁gcd Of M and element ▁= ▁gcd ▁( ▁M ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁if ▁( ▁gcd Of M and element ▁== ▁1 ▁) ▁{ ▁XOR ▁^= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁} ▁c out ▁<< ▁XOR ▁<< ▁' ▁' ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁; ▁int ▁M ▁= ▁4 ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁count Inverse ▁( ▁arr ▁, ▁N ▁, ▁M ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁Total X or Pair ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁total X OR ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁total X OR ▁^= ▁arr ▁[ ▁i ▁] ▁^ ▁arr ▁[ ▁j ▁] ▁; ▁} ▁} ▁return ▁total X OR ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁Total X or Pair ▁( ▁arr ▁, ▁N ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁possible A cy c lic Graph ▁( ▁int ▁N ▁) ▁{ ▁c out ▁<< ▁pow ▁( ▁2 ▁, ▁N ▁- ▁1 ▁) ▁; ▁return ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁4 ▁; ▁possible A cy c lic Graph ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is Composite ▁( ▁int ▁N ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁* ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁N ▁% ▁i ▁== ▁0 ▁) ▁{ ▁return ▁true ▁; ▁} ▁} ▁return ▁false ▁; ▁} ▁int ▁composite Pair ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁res ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁int ▁prod ▁= ▁arr ▁[ ▁i ▁] ▁* ▁arr ▁[ ▁j ▁] ▁; ▁if ▁( ▁is Composite ▁( ▁prod ▁) ▁) ▁{ ▁res ▁++ ▁; ▁} ▁} ▁} ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁1 ▁, ▁2 ▁, ▁2 ▁, ▁8 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁composite Pair ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁" ▁bits ▁/ ▁std c ▁+ ▁+ ▁. ▁h ▁" ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find _ next ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁M ▁= ▁n ▁+ ▁1 ▁; ▁while ▁( ▁1 ▁) ▁{ ▁if ▁( ▁M ▁& ▁( ▁1 ll ▁<< ▁k ▁) ▁) ▁break ▁; ▁M ▁++ ▁; ▁} ▁return ▁M ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁15 ▁, ▁K ▁= ▁2 ▁; ▁c out ▁<< ▁find _ next ▁( ▁N ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁maximum Sub arrays ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁target ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁int ▁avail Idx ▁= ▁-1 ▁; ▁int ▁cur _ sum ▁= ▁0 ▁; ▁unordered _ map ▁< ▁int ▁, ▁int ▁> ▁mp ▁; ▁mp ▁[ ▁0 ▁] ▁= ▁-1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁cur _ sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁if ▁( ▁mp ▁. ▁find ▁( ▁cur _ sum ▁- ▁target ▁) ▁!= ▁mp ▁. ▁end ▁( ▁) ▁&& ▁mp ▁[ ▁cur _ sum ▁- ▁target ▁] ▁>= ▁avail Idx ▁) ▁{ ▁ans ▁++ ▁; ▁avail Idx ▁= ▁i ▁; ▁} ▁mp ▁[ ▁cur _ sum ▁] ▁= ▁i ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁-1 ▁, ▁4 ▁, ▁3 ▁, ▁6 ▁, ▁4 ▁, ▁5 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁target ▁= ▁6 ▁; ▁c out ▁<< ▁maximum Sub arrays ▁( ▁arr ▁, ▁N ▁, ▁target ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁getCount ▁( ▁int ▁N ▁, ▁int ▁M ▁) ▁{ ▁int ▁total _ count ▁= ▁0 ▁; ▁total _ count ▁+= ▁( ▁N ▁/ ▁10 ▁) ▁; ▁int ▁x ▁= ▁( ▁N ▁/ ▁10 ▁) ▁* ▁10 ▁; ▁if ▁( ▁( ▁N ▁- ▁x ▁) ▁>= ▁M ▁) ▁{ ▁total _ count ▁= ▁total _ count ▁+ ▁1 ▁; ▁} ▁return ▁total _ count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁100 ▁, ▁M ▁= ▁1 ▁; ▁c out ▁<< ▁getCount ▁( ▁N ▁, ▁M ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁digits Of ▁( ▁int ▁num ▁) ▁{ ▁return ▁to _ string ▁( ▁num ▁) ▁. ▁size ▁( ▁) ▁; ▁} ▁int ▁count ▁( ▁int ▁a ▁, ▁int ▁tn ▁) ▁{ ▁int ▁diff ▁= ▁pow ▁( ▁10 ▁, ▁digits Of ▁( ▁a ▁) ▁) ▁; ▁return ▁( ▁( ▁tn ▁- ▁a ▁) ▁/ ▁diff ▁) ▁+ ▁1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁, ▁m ▁; ▁n ▁= ▁25 ▁, ▁m ▁= ▁4 500 ▁; ▁c out ▁<< ▁count ▁( ▁n ▁, ▁m ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁min Operations ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁num _ of _ ops 1 ▁, ▁num _ of _ ops 2 ▁, ▁sum ▁; ▁num _ of _ ops 1 ▁= ▁num _ of _ ops 2 ▁= ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁a ▁[ ▁i ▁] ▁; ▁if ▁( ▁i ▁% ▁2 ▁== ▁0 ▁&& ▁sum ▁>= ▁0 ▁) ▁{ ▁num _ of _ ops 1 ▁+= ▁( ▁1 ▁+ ▁abs ▁( ▁sum ▁) ▁) ▁; ▁sum ▁= ▁-1 ▁; ▁} ▁else ▁if ▁( ▁i ▁% ▁2 ▁== ▁1 ▁&& ▁sum ▁<= ▁0 ▁) ▁{ ▁num _ of _ ops 1 ▁+= ▁( ▁1 ▁+ ▁abs ▁( ▁sum ▁) ▁) ▁; ▁sum ▁= ▁1 ▁; ▁} ▁} ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁a ▁[ ▁i ▁] ▁; ▁if ▁( ▁i ▁% ▁2 ▁== ▁1 ▁&& ▁sum ▁>= ▁0 ▁) ▁{ ▁num _ of _ ops 2 ▁+= ▁( ▁1 ▁+ ▁abs ▁( ▁sum ▁) ▁) ▁; ▁sum ▁= ▁-1 ▁; ▁} ▁else ▁if ▁( ▁i ▁% ▁2 ▁== ▁0 ▁&& ▁sum ▁<= ▁0 ▁) ▁{ ▁num _ of _ ops 2 ▁+= ▁( ▁1 ▁+ ▁abs ▁( ▁sum ▁) ▁) ▁; ▁sum ▁= ▁1 ▁; ▁} ▁} ▁return ▁min ▁( ▁num _ of _ ops 1 ▁, ▁num _ of _ ops 2 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁-4 ▁, ▁5 ▁, ▁0 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁min Operations ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Set Bits ▁( ▁int ▁L ▁, ▁int ▁R ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁L ▁; ▁i ▁<= ▁R ▁; ▁i ▁++ ▁) ▁{ ▁count ▁+= ▁__ builtin _ pop count ▁( ▁i ▁) ▁; ▁} ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁L ▁= ▁3 ▁, ▁R ▁= ▁5 ▁; ▁c out ▁<< ▁" ▁Total ▁set ▁bit ▁count ▁is ▁" ▁<< ▁count Set Bits ▁( ▁L ▁, ▁R ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Sw aps ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁sort ▁( ▁A ▁, ▁A ▁+ ▁n ▁) ▁; ▁int ▁ind ▁= ▁1 ▁, ▁res ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁while ▁( ▁ind ▁< ▁n ▁and ▁A ▁[ ▁ind ▁] ▁== ▁A ▁[ ▁i ▁] ▁) ▁ind ▁++ ▁; ▁if ▁( ▁ind ▁< ▁n ▁and ▁A ▁[ ▁ind ▁] ▁> ▁A ▁[ ▁i ▁] ▁) ▁{ ▁res ▁++ ▁; ▁ind ▁++ ▁; ▁} ▁if ▁( ▁ind ▁>= ▁n ▁) ▁break ▁; ▁} ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁3 ▁, ▁3 ▁, ▁2 ▁, ▁5 ▁} ▁; ▁c out ▁<< ▁count Sw aps ▁( ▁A ▁, ▁5 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁numberOf Pairs ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁% ▁2 ▁== ▁0 ▁) ▁return ▁n ▁/ ▁2 ▁- ▁1 ▁; ▁else ▁return ▁n ▁/ ▁2 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁8 ▁; ▁c out ▁<< ▁numberOf Pairs ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁int ▁N ▁= ▁100000 ▁; ▁int ▁can Take ▁; ▁int ▁best ▁; ▁int ▁dp ▁[ ▁N ▁] ▁; ▁bool ▁vis ▁[ ▁N ▁] ▁; ▁int ▁dfs ▁( ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁& ▁g ▁, ▁int ▁* ▁cost ▁, ▁int ▁u ▁, ▁int ▁pre ▁) ▁{ ▁vis ▁[ ▁u ▁] ▁= ▁true ▁; ▁dp ▁[ ▁u ▁] ▁= ▁cost ▁[ ▁u ▁] ▁; ▁bool ▁check ▁= ▁1 ▁; ▁int ▁cur ▁= ▁cost ▁[ ▁u ▁] ▁; ▁for ▁( ▁auto ▁& ▁x ▁: ▁g ▁[ ▁u ▁] ▁) ▁{ ▁if ▁( ▁vis ▁[ ▁x ▁] ▁&& ▁x ▁!= ▁pre ▁) ▁{ ▁check ▁= ▁0 ▁; ▁} ▁else ▁if ▁( ▁! ▁vis ▁[ ▁x ▁] ▁) ▁{ ▁check ▁&= ▁dfs ▁( ▁g ▁, ▁cost ▁, ▁x ▁, ▁u ▁) ▁; ▁cur ▁= ▁max ▁( ▁cur ▁, ▁cost ▁[ ▁u ▁] ▁+ ▁dp ▁[ ▁x ▁] ▁) ▁; ▁} ▁} ▁dp ▁[ ▁u ▁] ▁= ▁cur ▁; ▁if ▁( ▁! ▁check ▁) ▁{ ▁can Take ▁+= ▁cost ▁[ ▁u ▁] ▁; ▁} ▁else ▁{ ▁best ▁= ▁max ▁( ▁best ▁, ▁dp ▁[ ▁u ▁] ▁) ▁; ▁} ▁return ▁check ▁; ▁} ▁int ▁Find Max Cost ▁( ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁& ▁g ▁, ▁int ▁* ▁cost ▁, ▁int ▁source ▁) ▁{ ▁dfs ▁( ▁g ▁, ▁cost ▁, ▁source ▁, ▁-1 ▁) ▁; ▁c out ▁<< ▁can Take ▁+ ▁best ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁5 ▁, ▁m ▁= ▁5 ▁; ▁int ▁cost ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁2 ▁, ▁8 ▁, ▁6 ▁, ▁9 ▁} ▁; ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁g ▁( ▁n ▁) ▁; ▁g ▁[ ▁0 ▁] ▁. ▁push _ back ▁( ▁1 ▁) ▁; ▁g ▁[ ▁1 ▁] ▁. ▁push _ back ▁( ▁0 ▁) ▁; ▁g ▁[ ▁0 ▁] ▁. ▁push _ back ▁( ▁2 ▁) ▁; ▁g ▁[ ▁2 ▁] ▁. ▁push _ back ▁( ▁0 ▁) ▁; ▁g ▁[ ▁0 ▁] ▁. ▁push _ back ▁( ▁3 ▁) ▁; ▁g ▁[ ▁3 ▁] ▁. ▁push _ back ▁( ▁0 ▁) ▁; ▁g ▁[ ▁1 ▁] ▁. ▁push _ back ▁( ▁2 ▁) ▁; ▁g ▁[ ▁2 ▁] ▁. ▁push _ back ▁( ▁1 ▁) ▁; ▁g ▁[ ▁1 ▁] ▁. ▁push _ back ▁( ▁4
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁min Points ▁( ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁if ▁( ▁( ▁n ▁% ▁2 ▁!= ▁0 ▁) ▁&& ▁( ▁m ▁% ▁2 ▁!= ▁0 ▁) ▁) ▁{ ▁ans ▁= ▁( ▁( ▁n ▁* ▁m ▁) ▁/ ▁2 ▁) ▁+ ▁1 ▁; ▁} ▁else ▁{ ▁ans ▁= ▁( ▁n ▁* ▁m ▁) ▁/ ▁2 ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁5 ▁, ▁M ▁= ▁7 ▁; ▁c out ▁<< ▁min Points ▁( ▁N ▁, ▁M ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁create Array ▁( ▁int ▁n ▁, ▁int ▁s ▁) ▁{ ▁if ▁( ▁2 ▁* ▁n ▁<= ▁s ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁c out ▁<< ▁"2" ▁<< ▁" ▁" ▁; ▁s ▁-= ▁2 ▁; ▁} ▁c out ▁<< ▁s ▁<< ▁end l ▁; ▁c out ▁<< ▁"1" ▁<< ▁end l ▁; ▁} ▁else ▁c out ▁<< ▁" ▁- ▁1" ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁1 ▁; ▁int ▁S ▁= ▁4 ▁; ▁create Array ▁( ▁N ▁, ▁S ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁maximum Sum Sub array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁unordered _ map ▁< ▁int ▁, ▁int ▁> ▁mp ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁>= ▁0 ▁&& ▁mp ▁. ▁find ▁( ▁arr ▁[ ▁i ▁] ▁) ▁== ▁mp ▁. ▁end ▁( ▁) ▁) ▁mp ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁= ▁1 ▁; ▁} ▁int ▁first ▁= ▁0 ▁; ▁int ▁last ▁= ▁0 ▁; ▁int ▁ans ▁= ▁0 ▁; ▁int ▁INF ▁= ▁1 e 6 ▁; ▁for ▁( ▁auto ▁i ▁: ▁mp ▁) ▁{ ▁int ▁mx ▁= ▁i ▁. ▁first ▁; ▁int ▁curr ▁= ▁0 ▁; ▁int ▁curr _ start ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁curr ▁== ▁0 ▁) ▁curr _ start ▁= ▁j ▁; ▁int ▁val ▁= ▁arr ▁[ ▁j ▁] ▁> ▁mx ▁? ▁- ▁INF ▁: ▁arr ▁[ ▁j ▁] ▁; ▁curr ▁+= ▁val ▁; ▁if ▁( ▁curr ▁< ▁0 ▁) ▁curr ▁= ▁0 ▁; ▁if ▁( ▁curr ▁> ▁ans ▁) ▁{ ▁ans ▁= ▁curr ▁; ▁first ▁= ▁curr _ start ▁; ▁last ▁= ▁j ▁; ▁} ▁} ▁} ▁c out ▁<< ▁first ▁+ ▁1 ▁<< ▁" ▁" ▁<< ▁last ▁+ ▁1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁-2 ▁, ▁10 ▁, ▁-1 ▁, ▁4 ▁} ▁; ▁int ▁size ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁maximum Sum Sub array ▁( ▁arr ▁, ▁size ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁min F lip ▁( ▁string ▁s ▁, ▁int ▁n ▁, ▁int ▁k ▁, ▁char ▁a ▁[ ▁] ▁, ▁int ▁p ▁) ▁{ ▁bool ▁allowed ▁[ ▁26 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁p ▁; ▁i ▁++ ▁) ▁{ ▁allowed ▁[ ▁a ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁] ▁= ▁true ▁; ▁} ▁char ▁freq ▁[ ▁k ▁] ▁[ ▁26 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁k ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁26 ▁; ▁j ▁++ ▁) ▁freq ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁freq ▁[ ▁i ▁% ▁k ▁] ▁[ ▁s ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁] ▁+= ▁1 ▁; ▁} ▁int ▁ans ▁= ▁0 ▁; ▁int ▁total positions ▁= ▁n ▁/ ▁k ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁k ▁; ▁i ▁++ ▁) ▁{ ▁int ▁max frequency ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁26 ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁freq ▁[ ▁i ▁] ▁[ ▁j ▁] ▁> ▁max frequency ▁and ▁allowed ▁[ ▁j ▁] ▁== ▁true ▁) ▁max frequency ▁= ▁freq ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁} ▁ans ▁+= ▁( ▁total positions ▁- ▁max frequency ▁+ ▁( ▁( ▁i ▁% ▁k ▁< ▁n ▁% ▁k ▁) ▁? ▁1 ▁: ▁0 ▁) ▁) ▁; ▁} ▁c out ▁<< ▁ans ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁S ▁= ▁" ▁n ih si ak y t ▁" ▁; ▁int ▁n ▁= ▁S ▁. ▁length ▁( ▁) ▁; ▁int ▁K ▁= ▁3 ▁; ▁char ▁A ▁[ ▁5 ▁] ▁= ▁{ ▁' ▁n ▁' ▁, ▁' ▁i ▁' ▁, ▁' ▁p ▁' ▁, ▁' ▁s ▁' ▁, ▁' ▁q ▁' ▁} ▁; ▁int ▁p ▁= ▁sizeof ▁( ▁A ▁) ▁/ ▁sizeof ▁( ▁A ▁[ ▁0 ▁] ▁) ▁; ▁min F lip ▁( ▁S ▁, ▁n ▁, ▁K ▁, ▁A ▁, ▁p ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁Min Diff ▁( ▁int ▁n ▁) ▁{ ▁int ▁val ▁= ▁pow ▁( ▁2 ▁, ▁n ▁) ▁; ▁int ▁sep ▁= ▁n ▁/ ▁2 ▁; ▁int ▁grp 1 ▁= ▁0 ▁; ▁int ▁grp 2 ▁= ▁0 ▁; ▁grp 1 ▁= ▁grp 1 ▁+ ▁val ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁sep ▁; ▁i ▁++ ▁) ▁grp 1 ▁= ▁grp 1 ▁+ ▁pow ▁( ▁2 ▁, ▁i ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁sep ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁grp 2 ▁= ▁grp 2 ▁+ ▁pow ▁( ▁2 ▁, ▁i ▁) ▁; ▁c out ▁<< ▁( ▁abs ▁( ▁grp 1 ▁- ▁grp 2 ▁) ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁4 ▁; ▁Min Diff ▁( ▁n ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁Minimum Value ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁answer ▁= ▁INT _ MAX ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁answer ▁= ▁min ▁( ▁answer ▁, ▁( ▁( ▁a ▁[ ▁i ▁] ▁& ▁a ▁[ ▁j ▁] ▁) ▁^ ▁( ▁a ▁[ ▁i ▁] ▁a ▁[ ▁j ▁] ▁) ▁) ▁) ▁; ▁} ▁} ▁return ▁answer ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁6 ▁; ▁int ▁A ▁[ ▁N ▁] ▁= ▁{ ▁12 ▁, ▁3 ▁, ▁14 ▁, ▁5 ▁, ▁9 ▁, ▁8 ▁} ▁; ▁c out ▁<< ▁Minimum Value ▁( ▁A ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Of Sub strings ▁( ▁string ▁s ▁) ▁{ ▁int ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁int ▁prefix _ sum ▁[ ▁n ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁[ ▁i ▁] ▁== ▁'1' ▁) ▁prefix _ sum ▁[ ▁i ▁] ▁= ▁1 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁prefix _ sum ▁[ ▁i ▁] ▁+= ▁prefix _ sum ▁[ ▁i ▁- ▁1 ▁] ▁; ▁int ▁answer ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁int ▁count Of On es ▁= ▁prefix _ sum ▁[ ▁j ▁] ▁- ▁( ▁i ▁- ▁1 ▁>= ▁0 ▁? ▁prefix _ sum ▁[ ▁i ▁- ▁1 ▁] ▁: ▁0 ▁) ▁; ▁int ▁length ▁= ▁j ▁- ▁i ▁+ ▁1 ▁; ▁if ▁( ▁count Of On es ▁> ▁0 ▁&& ▁length ▁% ▁count Of On es ▁== ▁0 ▁) ▁answer ▁++ ▁; ▁} ▁} ▁return ▁answer ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁S ▁= ▁" 1111 100 000" ▁; ▁c out ▁<< ▁count Of Sub strings ▁( ▁S ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁digit _ xor ▁( ▁int ▁x ▁) ▁{ ▁int ▁xor r ▁= ▁0 ▁; ▁while ▁( ▁x ▁) ▁{ ▁xor r ▁^= ▁x ▁% ▁10 ▁; ▁x ▁= ▁x ▁/ ▁10 ▁; ▁} ▁return ▁xor r ▁; ▁} ▁int ▁find _ count ▁( ▁int ▁n ▁) ▁{ ▁map ▁< ▁int ▁, ▁int ▁> ▁m pp ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁m pp ▁[ ▁digit _ xor ▁( ▁i ▁) ▁] ▁+= ▁1 ▁; ▁} ▁int ▁max m ▁= ▁0 ▁; ▁for ▁( ▁auto ▁x ▁: ▁m pp ▁) ▁{ ▁if ▁( ▁x ▁. ▁second ▁> ▁max m ▁) ▁max m ▁= ▁x ▁. ▁second ▁; ▁} ▁return ▁max m ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁13 ▁; ▁c out ▁<< ▁find _ count ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁min _ val ▁= ▁INT _ MAX ▁; ▁int ▁min _ steps ▁= ▁0 ▁; ▁int ▁sum Of Digits ▁( ▁int ▁n ▁) ▁{ ▁string ▁s ▁= ▁to _ string ▁( ▁n ▁) ▁; ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁( ▁s ▁[ ▁i ▁] ▁- ▁'0' ▁) ▁; ▁} ▁return ▁sum ▁; ▁} ▁void ▁Transform ▁( ▁int ▁n ▁, ▁int ▁d ▁, ▁int ▁steps ▁) ▁{ ▁if ▁( ▁n ▁< ▁min _ val ▁) ▁{ ▁min _ val ▁= ▁n ▁; ▁min _ steps ▁= ▁steps ▁; ▁} ▁else ▁if ▁( ▁n ▁== ▁min _ val ▁) ▁{ ▁min _ steps ▁= ▁min ▁( ▁min _ steps ▁, ▁steps ▁) ▁; ▁} ▁if ▁( ▁steps ▁< ▁15 ▁) ▁{ ▁Transform ▁( ▁sum Of Digits ▁( ▁n ▁) ▁, ▁d ▁, ▁steps ▁+ ▁1 ▁) ▁; ▁Transform ▁( ▁n ▁+ ▁d ▁, ▁d ▁, ▁steps ▁+ ▁1 ▁) ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁9 ▁, ▁D ▁= ▁3 ▁; ▁Transform ▁( ▁N ▁, ▁D ▁, ▁0 ▁) ▁; ▁c out ▁<< ▁min _ val ▁<< ▁" ▁" ▁<< ▁min _ steps ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁sum Div is ib les ▁( ▁int ▁A ▁, ▁int ▁B ▁, ▁int ▁M ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁A ▁; ▁i ▁<= ▁B ▁; ▁i ▁++ ▁) ▁if ▁( ▁i ▁% ▁M ▁== ▁0 ▁) ▁sum ▁+= ▁i ▁; ▁return ▁sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁= ▁6 ▁, ▁B ▁= ▁15 ▁, ▁M ▁= ▁3 ▁; ▁c out ▁<< ▁sum Div is ib les ▁( ▁A ▁, ▁B ▁, ▁M ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Pairs ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁unordered _ map ▁< ▁int ▁, ▁int ▁> ▁frequency ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁frequency ▁[ ▁a ▁[ ▁i ▁] ▁] ▁++ ▁; ▁} ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁auto ▁x ▁: ▁frequency ▁) ▁{ ▁int ▁f ▁= ▁x ▁. ▁second ▁; ▁count ▁+= ▁f ▁* ▁( ▁f ▁- ▁1 ▁) ▁/ ▁2 ▁; ▁} ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁1 ▁, ▁1 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁count Pairs ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁dec Binary ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁k ▁= ▁log 2 ▁( ▁n ▁) ▁; ▁while ▁( ▁n ▁> ▁0 ▁) ▁{ ▁arr ▁[ ▁k ▁-- ▁] ▁= ▁n ▁% ▁2 ▁; ▁n ▁/= ▁2 ▁; ▁} ▁} ▁int ▁binary Dec ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁ans ▁+= ▁arr ▁[ ▁i ▁] ▁<< ▁( ▁n ▁- ▁i ▁- ▁1 ▁) ▁; ▁return ▁ans ▁; ▁} ▁int ▁max Num ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁l ▁= ▁log 2 ▁( ▁n ▁) ▁+ ▁1 ▁; ▁int ▁a ▁[ ▁l ▁] ▁= ▁{ ▁0 ▁} ▁; ▁dec Binary ▁( ▁a ▁, ▁n ▁) ▁; ▁int ▁cn ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁l ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁== ▁0 ▁&& ▁cn ▁< ▁k ▁) ▁{ ▁a ▁[ ▁i ▁] ▁= ▁1 ▁; ▁cn ▁++ ▁; ▁} ▁} ▁return ▁binary Dec ▁( ▁a ▁, ▁l ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁4 ▁, ▁k ▁= ▁1 ▁; ▁c out ▁<< ▁max Num ▁( ▁n ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁int ▁MAX ▁= ▁26 ▁; ▁char ▁max Alpha ▁( ▁string ▁str ▁, ▁int ▁len ▁) ▁{ ▁int ▁first ▁[ ▁MAX ▁] ▁, ▁last ▁[ ▁MAX ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁MAX ▁; ▁i ▁++ ▁) ▁{ ▁first ▁[ ▁i ▁] ▁= ▁-1 ▁; ▁last ▁[ ▁i ▁] ▁= ▁-1 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁len ▁; ▁i ▁++ ▁) ▁{ ▁int ▁index ▁= ▁( ▁str ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁) ▁; ▁if ▁( ▁first ▁[ ▁index ▁] ▁== ▁-1 ▁) ▁first ▁[ ▁index ▁] ▁= ▁i ▁; ▁last ▁[ ▁index ▁] ▁= ▁i ▁; ▁} ▁int ▁ans ▁= ▁-1 ▁, ▁max Val ▁= ▁-1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁MAX ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁first ▁[ ▁i ▁] ▁== ▁-1 ▁) ▁continue ▁; ▁if ▁( ▁( ▁last ▁[ ▁i ▁] ▁- ▁first ▁[ ▁i ▁] ▁) ▁> ▁max Val ▁) ▁{ ▁max Val ▁= ▁last ▁[ ▁i ▁] ▁- ▁first ▁[ ▁i ▁] ▁; ▁ans ▁= ▁i ▁; ▁} ▁} ▁return ▁( ▁char ▁) ▁( ▁ans ▁+ ▁' ▁a ▁' ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁ab bb a ▁" ▁; ▁int ▁len ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁c out ▁<< ▁max Alpha ▁( ▁str ▁, ▁len ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is V ow el ▁( ▁char ▁ch ▁) ▁{ ▁switch ▁( ▁ch ▁) ▁{ ▁case ▁' ▁a ▁' ▁: ▁case ▁' ▁e ▁' ▁: ▁case ▁' ▁i ▁' ▁: ▁case ▁' ▁o ▁' ▁: ▁case ▁' ▁u ▁' ▁: ▁return ▁true ▁; ▁default ▁: ▁return ▁false ▁; ▁} ▁} ▁int ▁vow el Pairs ▁( ▁string ▁s ▁, ▁int ▁n ▁) ▁{ ▁int ▁cnt ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁is V ow el ▁( ▁s ▁[ ▁i ▁] ▁) ▁&& ▁is V ow el ▁( ▁s ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁) ▁cnt ▁++ ▁; ▁} ▁return ▁cnt ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁" ▁ab a eb io ▁" ▁; ▁int ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁c out ▁<< ▁vow el Pairs ▁( ▁s ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁min _ el im ination ▁( ▁int ▁n ▁, ▁int ▁arr ▁[ ▁] ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁int ▁prev _ val ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁curr _ val ▁= ▁arr ▁[ ▁i ▁] ▁; ▁if ▁( ▁curr _ val ▁% ▁2 ▁== ▁prev _ val ▁% ▁2 ▁) ▁count ▁++ ▁; ▁prev _ val ▁= ▁curr _ val ▁; ▁} ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁7 ▁, ▁9 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁min _ el im ination ▁( ▁n ▁, ▁arr ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁checkIf Overlap ▁( ▁string ▁str ▁) ▁{ ▁int ▁len ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁int ▁visited ▁[ ▁len ▁+ ▁1 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁len ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁str ▁[ ▁i ▁] ▁== ▁' ▁. ▁' ▁) ▁continue ▁; ▁for ▁( ▁int ▁j ▁= ▁max ▁( ▁0 ▁, ▁i ▁- ▁str ▁[ ▁i ▁] ▁) ▁; ▁j ▁<= ▁min ▁( ▁len ▁, ▁i ▁+ ▁str ▁[ ▁i ▁] ▁) ▁; ▁j ▁++ ▁) ▁visited ▁[ ▁j ▁] ▁++ ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁len ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁visited ▁[ ▁i ▁] ▁> ▁1 ▁) ▁{ ▁return ▁true ▁; ▁} ▁} ▁return ▁false ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁. ▁2 ▁. ▁. ▁2 ▁. ▁" ▁; ▁if ▁( ▁checkIf Overlap ▁( ▁str ▁) ▁) ▁c out ▁<< ▁" ▁YES ▁" ▁; ▁else ▁c out ▁<< ▁" ▁NO ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is Correct Order ▁( ▁int ▁n ▁) ▁{ ▁bool ▁flag ▁= ▁true ▁; ▁int ▁prev ▁= ▁-1 ▁; ▁int ▁type ▁= ▁-1 ▁; ▁while ▁( ▁n ▁!= ▁0 ▁) ▁{ ▁if ▁( ▁type ▁== ▁-1 ▁) ▁{ ▁if ▁( ▁prev ▁== ▁-1 ▁) ▁{ ▁prev ▁= ▁n ▁% ▁10 ▁; ▁n ▁= ▁n ▁/ ▁10 ▁; ▁continue ▁; ▁} ▁if ▁( ▁prev ▁== ▁n ▁% ▁10 ▁) ▁{ ▁flag ▁= ▁false ▁; ▁break ▁; ▁} ▁if ▁( ▁prev ▁> ▁n ▁% ▁10 ▁) ▁{ ▁type ▁= ▁1 ▁; ▁prev ▁= ▁n ▁% ▁10 ▁; ▁n ▁= ▁n ▁/ ▁10 ▁; ▁continue ▁; ▁} ▁prev ▁= ▁n ▁% ▁10 ▁; ▁n ▁= ▁n ▁/ ▁10 ▁; ▁} ▁else ▁{ ▁if ▁( ▁prev ▁== ▁n ▁% ▁10 ▁) ▁{ ▁flag ▁= ▁false ▁; ▁break ▁; ▁} ▁if ▁( ▁prev ▁< ▁n ▁% ▁10 ▁) ▁{ ▁flag ▁= ▁false ▁; ▁break ▁; ▁} ▁prev ▁= ▁n ▁% ▁10 ▁; ▁n ▁= ▁n ▁/ ▁10 ▁; ▁} ▁} ▁return ▁flag ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁1234 54 321 ▁; ▁if ▁( ▁is Correct Order ▁( ▁n ▁) ▁) ▁c out ▁<< ▁" ▁YES ▁" ▁; ▁else ▁c out ▁<< ▁" ▁NO ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁V ▁5 ▁NEW _ LINE ▁bool ▁isValid Edge ▁( ▁int ▁u ▁, ▁int ▁v ▁, ▁vector ▁< ▁bool ▁> ▁in M ST ▁) ▁{ ▁if ▁( ▁u ▁== ▁v ▁) ▁return ▁false ▁; ▁if ▁( ▁in M ST ▁[ ▁u ▁] ▁== ▁false ▁&& ▁in M ST ▁[ ▁v ▁] ▁== ▁false ▁) ▁return ▁false ▁; ▁else ▁if ▁( ▁in M ST ▁[ ▁u ▁] ▁== ▁true ▁&& ▁in M ST ▁[ ▁v ▁] ▁== ▁true ▁) ▁return ▁false ▁; ▁return ▁true ▁; ▁} ▁void ▁prim M ST ▁( ▁int ▁cost ▁[ ▁] ▁[ ▁V ▁] ▁) ▁{ ▁vector ▁< ▁bool ▁> ▁in M ST ▁( ▁V ▁, ▁false ▁) ▁; ▁in M ST ▁[ ▁0 ▁] ▁= ▁true ▁; ▁int ▁edge _ count ▁= ▁0 ▁, ▁min cost ▁= ▁0 ▁; ▁while ▁( ▁edge _ count ▁< ▁V ▁- ▁1 ▁) ▁{ ▁int ▁min ▁= ▁INT _ MAX ▁, ▁a ▁= ▁-1 ▁, ▁b ▁= ▁-1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁V ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁V ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁cost ▁[ ▁i ▁] ▁[ ▁j ▁] ▁< ▁min ▁) ▁{ ▁if ▁( ▁isValid Edge ▁( ▁i ▁, ▁j ▁, ▁in M ST ▁) ▁) ▁{ ▁min ▁= ▁cost ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁a ▁= ▁i ▁; ▁b ▁= ▁j ▁; ▁} ▁} ▁} ▁} ▁if ▁( ▁a ▁!= ▁-1 ▁&& ▁b ▁!= ▁-1 ▁) ▁{ ▁printf ▁( ▁" ▁Edge ▁% ▁d ▁: ▁( ▁% ▁d ▁, ▁% ▁d ▁) ▁cost ▁: ▁% ▁d ▁STRNEWLINE ▁" ▁, ▁edge _ count ▁++ ▁, ▁a ▁, ▁b ▁, ▁min ▁) ▁; ▁min cost ▁= ▁min cost ▁+ ▁min ▁; ▁in M ST ▁[ ▁b ▁] ▁= ▁in M ST ▁[ ▁a ▁] ▁= ▁true ▁; ▁} ▁} ▁printf ▁( ▁" ▁Minimum ▁cost ▁= ▁% ▁d ▁" ▁, ▁min cost ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁cost ▁[ ▁] ▁[ ▁V ▁] ▁= ▁{ ▁{ ▁INT _ MAX ▁, ▁2 ▁, ▁INT _ MAX ▁, ▁6 ▁, ▁INT _ MAX ▁} ▁, ▁{ ▁2 ▁, ▁INT _ MAX ▁, ▁3 ▁, ▁8 ▁, ▁5 ▁} ▁, ▁{ ▁INT _ MAX ▁, ▁3 ▁, ▁INT _ MAX ▁, ▁INT
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁construct ▁( ▁int ▁n ▁, ▁pair ▁< ▁double ▁, ▁double ▁> ▁ans _ pair ▁) ▁{ ▁if ▁( ▁ans _ pair ▁. ▁first ▁== ▁-1 ▁) ▁{ ▁c out ▁<< ▁" ▁Not ▁possible ▁" ▁; ▁return ▁; ▁} ▁double ▁a 1 ▁= ▁ans _ pair ▁. ▁first ▁; ▁double ▁a 2 ▁= ▁ans _ pair ▁. ▁second ▁; ▁double ▁r ▁= ▁a 2 ▁/ ▁a 1 ▁; ▁c out ▁<< ▁" ▁The ▁result ant ▁sequence ▁is ▁: ▁STRNEWLINE ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁double ▁ai ▁= ▁a 1 ▁* ▁pow ▁( ▁r ▁, ▁i ▁- ▁1 ▁) ▁; ▁c out ▁<< ▁ai ▁<< ▁" ▁" ▁; ▁} ▁} ▁void ▁find Minimum Operations ▁( ▁double ▁* ▁a ▁, ▁int ▁n ▁) ▁{ ▁int ▁ans ▁= ▁INT _ MAX ▁; ▁int ▁c ▁[ ▁] ▁= ▁{ ▁-1 ▁, ▁0 ▁, ▁1 ▁} ▁; ▁int ▁possibilities ▁= ▁3 ▁; ▁int ▁pos 1 ▁= ▁-1 ▁, ▁pos 2 ▁= ▁-1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁possibilities ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁possibilities ▁; ▁j ▁++ ▁) ▁{ ▁double ▁a 1 ▁= ▁a ▁[ ▁1 ▁] ▁+ ▁c ▁[ ▁i ▁] ▁; ▁double ▁a 2 ▁= ▁a ▁[ ▁2 ▁] ▁+ ▁c ▁[ ▁j ▁] ▁; ▁int ▁temp ▁= ▁abs ▁( ▁a 1 ▁- ▁a ▁[ ▁1 ▁] ▁) ▁+ ▁abs ▁( ▁a 2 ▁- ▁a ▁[ ▁2 ▁] ▁) ▁; ▁if ▁( ▁a 1 ▁== ▁0 ▁a 2 ▁== ▁0 ▁) ▁continue ▁; ▁double ▁r ▁= ▁a 2 ▁/ ▁a 1 ▁; ▁for ▁( ▁int ▁pos ▁= ▁3 ▁; ▁pos ▁<= ▁n ▁; ▁pos ▁++ ▁) ▁{ ▁double ▁ai ▁= ▁a 1 ▁* ▁pow ▁( ▁r ▁, ▁pos ▁- ▁1 ▁) ▁; ▁if ▁( ▁a ▁[ ▁pos ▁] ▁== ▁ai ▁) ▁{ ▁continue ▁; ▁} ▁else ▁if ▁( ▁a ▁[ ▁pos ▁] ▁+ ▁1 ▁== ▁ai ▁a ▁[ ▁pos ▁] ▁- ▁1 ▁== ▁ai ▁) ▁{ ▁temp ▁++ ▁; ▁} ▁else ▁{ ▁temp ▁= ▁INT _ MAX ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁temp ▁< ▁ans ▁) ▁{ ▁ans ▁= ▁temp ▁; ▁pos 1 ▁= ▁a 1 ▁; ▁pos 2 ▁= ▁a 2 ▁; ▁} ▁} ▁} ▁if ▁(
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Minimum Ad jacent Sw aps ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁bool ▁visited ▁[ ▁N ▁+ ▁1 ▁] ▁; ▁int ▁minimum Sw aps ▁= ▁0 ▁; ▁mem set ▁( ▁visited ▁, ▁false ▁, ▁sizeof ▁( ▁visited ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁2 ▁* ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁visited ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁== ▁false ▁) ▁{ ▁visited ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁= ▁true ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁2 ▁* ▁N ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁visited ▁[ ▁arr ▁[ ▁j ▁] ▁] ▁== ▁false ▁) ▁count ▁++ ▁; ▁else ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁arr ▁[ ▁j ▁] ▁) ▁minimum Sw aps ▁+= ▁count ▁; ▁} ▁} ▁} ▁return ▁minimum Sw aps ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁3 ▁, ▁1 ▁, ▁2 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁N ▁/= ▁2 ▁; ▁c out ▁<< ▁find Minimum Ad jacent Sw aps ▁( ▁arr ▁, ▁N ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁Min Operation ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁result ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁!= ▁1 ▁&& ▁a ▁[ ▁i ▁] ▁> ▁k ▁) ▁{ ▁result ▁= ▁result ▁+ ▁min ▁( ▁a ▁[ ▁i ▁] ▁% ▁k ▁, ▁k ▁- ▁a ▁[ ▁i ▁] ▁% ▁k ▁) ▁; ▁} ▁else ▁{ ▁result ▁= ▁result ▁+ ▁k ▁- ▁a ▁[ ▁i ▁] ▁; ▁} ▁} ▁return ▁result ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁k ▁= ▁5 ▁; ▁c out ▁<< ▁Min Operation ▁( ▁arr ▁, ▁n ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print Vector ▁( ▁vector ▁< ▁int ▁> ▁v ▁) ▁{ ▁c out ▁<< ▁v ▁. ▁size ▁( ▁) ▁<< ▁end l ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁v ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁v ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁c out ▁<< ▁end l ▁; ▁} ▁void ▁find Two Group ▁( ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁n ▁* ▁( ▁n ▁+ ▁1 ▁) ▁/ ▁2 ▁; ▁int ▁group 1 Sum ▁= ▁sum ▁/ ▁2 ▁; ▁vector ▁< ▁int ▁> ▁group 1 ▁, ▁group 2 ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁; ▁i ▁> ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁group 1 Sum ▁- ▁i ▁>= ▁0 ▁) ▁{ ▁group 1 ▁. ▁push _ back ▁( ▁i ▁) ▁; ▁group 1 Sum ▁-= ▁i ▁; ▁} ▁else ▁{ ▁group 2 ▁. ▁push _ back ▁( ▁i ▁) ▁; ▁} ▁} ▁print Vector ▁( ▁group 1 ▁) ▁; ▁print Vector ▁( ▁group 2 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁5 ▁; ▁find Two Group ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁# include ▁< vector > ▁NEW _ LINE ▁# include ▁< algorithm > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁long ▁swap Count ▁( ▁string ▁s ▁) ▁{ ▁vector ▁< ▁int ▁> ▁pos ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁length ▁( ▁) ▁; ▁++ ▁i ▁) ▁if ▁( ▁s ▁[ ▁i ▁] ▁== ▁' ▁[ ▁' ▁) ▁pos ▁. ▁push _ back ▁( ▁i ▁) ▁; ▁int ▁count ▁= ▁0 ▁; ▁int ▁p ▁= ▁0 ▁; ▁long ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁length ▁( ▁) ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁s ▁[ ▁i ▁] ▁== ▁' ▁[ ▁' ▁) ▁{ ▁++ ▁count ▁; ▁++ ▁p ▁; ▁} ▁else ▁if ▁( ▁s ▁[ ▁i ▁] ▁== ▁' ▁] ▁' ▁) ▁-- ▁count ▁; ▁if ▁( ▁count ▁< ▁0 ▁) ▁{ ▁sum ▁+= ▁pos ▁[ ▁p ▁] ▁- ▁i ▁; ▁swap ▁( ▁s ▁[ ▁i ▁] ▁, ▁s ▁[ ▁pos ▁[ ▁p ▁] ▁] ▁) ▁; ▁++ ▁p ▁; ▁count ▁= ▁1 ▁; ▁} ▁} ▁return ▁sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁" ▁[ ▁] ▁] ▁[ ▁] ▁[ ▁" ▁; ▁c out ▁<< ▁swap Count ▁( ▁s ▁) ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁s ▁= ▁" ▁[ ▁[ ▁] ▁[ ▁] ▁] ▁" ▁; ▁c out ▁<< ▁swap Count ▁( ▁s ▁) ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁int ▁mod ▁= ▁1 e 9 ▁+ ▁7 ▁; ▁void ▁count Of Numbers ▁( ▁int ▁N ▁) ▁{ ▁int ▁ans ▁= ▁1 ▁; ▁for ▁( ▁int ▁index ▁= ▁1 ▁; ▁index ▁<= ▁N ▁; ▁++ ▁index ▁) ▁{ ▁int ▁choices ▁= ▁0 ▁; ▁for ▁( ▁int ▁digit ▁= ▁1 ▁; ▁digit ▁<= ▁9 ▁; ▁++ ▁digit ▁) ▁{ ▁if ▁( ▁index ▁% ▁digit ▁== ▁0 ▁) ▁{ ▁++ ▁choices ▁; ▁} ▁} ▁ans ▁= ▁( ▁ans ▁* ▁1 LL ▁* ▁choices ▁) ▁% ▁mod ▁; ▁} ▁c out ▁<< ▁ans ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁5 ▁; ▁count Of Numbers ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁dfs ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁left ▁, ▁int ▁K ▁) ▁{ ▁int ▁q ▁= ▁0 ▁; ▁if ▁( ▁left ▁== ▁0 ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁K ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁0 ▁) ▁{ ▁arr ▁[ ▁i ▁] ▁-- ▁; ▁q ▁= ▁max ▁( ▁q ▁, ▁1 ▁+ ▁dfs ▁( ▁arr ▁, ▁K ▁- ▁i ▁, ▁K ▁) ▁) ▁; ▁arr ▁[ ▁i ▁] ▁++ ▁; ▁} ▁} ▁} ▁else ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁K ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁0 ▁) ▁{ ▁arr ▁[ ▁i ▁] ▁-- ▁; ▁int ▁n left ▁= ▁( ▁i ▁<= ▁left ▁? ▁left ▁- ▁i ▁: ▁K ▁+ ▁left ▁- ▁i ▁) ▁; ▁q ▁= ▁max ▁( ▁q ▁, ▁dfs ▁( ▁arr ▁, ▁n left ▁, ▁K ▁) ▁) ▁; ▁arr ▁[ ▁i ▁] ▁++ ▁; ▁} ▁} ▁} ▁return ▁q ▁; ▁} ▁int ▁max Groups ▁( ▁int ▁K ▁, ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁V ▁[ ▁K ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁int ▁x ▁= ▁0 ▁; ▁x ▁< ▁n ▁; ▁x ▁++ ▁) ▁V ▁[ ▁arr ▁[ ▁x ▁] ▁% ▁K ▁] ▁++ ▁; ▁int ▁ans ▁= ▁V ▁[ ▁0 ▁] ▁+ ▁dfs ▁( ▁V ▁, ▁0 ▁, ▁K ▁) ▁; ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁K ▁= ▁3 ▁; ▁c out ▁<< ▁max Groups ▁( ▁K ▁, ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁longest Sub sequence ▁( ▁int ▁* ▁arr ▁, ▁int ▁N ▁) ▁{ ▁int ▁dp ▁[ ▁N ▁] ▁[ ▁N ▁+ ▁1 ▁] ▁; ▁mem set ▁( ▁dp ▁, ▁-1 ▁, ▁sizeof ▁dp ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁++ ▁i ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁} ▁dp ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁= ▁( ▁arr ▁[ ▁0 ▁] ▁>= ▁0 ▁? ▁arr ▁[ ▁0 ▁] ▁: ▁-1 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁++ ▁i ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁<= ▁( ▁i ▁+ ▁1 ▁) ▁; ▁++ ▁j ▁) ▁{ ▁if ▁( ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁!= ▁-1 ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁max ▁( ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁, ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁) ▁; ▁} ▁if ▁( ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁- ▁1 ▁] ▁>= ▁0 ▁&& ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁- ▁1 ▁] ▁+ ▁arr ▁[ ▁i ▁] ▁>= ▁0 ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁max ▁( ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁, ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁- ▁1 ▁] ▁+ ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁} ▁} ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁<= ▁N ▁; ▁++ ▁j ▁) ▁{ ▁if ▁( ▁dp ▁[ ▁N ▁- ▁1 ▁] ▁[ ▁j ▁] ▁>= ▁0 ▁) ▁{ ▁ans ▁= ▁j ▁; ▁} ▁} ▁c out ▁<< ▁ans ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁-4 ▁, ▁1 ▁, ▁-3 ▁, ▁1 ▁, ▁-3 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁arr ▁/ ▁sizeof ▁arr ▁[ ▁0 ▁] ▁; ▁longest Sub sequence ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁K visible From Left ▁( ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁if ▁( ▁N ▁== ▁K ▁) ▁return ▁1 ▁; ▁if ▁( ▁K ▁== ▁1 ▁) ▁{ ▁int ▁ans ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁ans ▁*= ▁i ▁; ▁return ▁ans ▁; ▁} ▁return ▁K visible From Left ▁( ▁N ▁- ▁1 ▁, ▁K ▁- ▁1 ▁) ▁+ ▁( ▁N ▁- ▁1 ▁) ▁* ▁K visible From Left ▁( ▁N ▁- ▁1 ▁, ▁K ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁5 ▁, ▁K ▁= ▁2 ▁; ▁c out ▁<< ▁K visible From Left ▁( ▁N ▁, ▁K ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁numOf W ays ▁( ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁a ▁, ▁int ▁n ▁, ▁int ▁i ▁, ▁set ▁< ▁int ▁> ▁& ▁blue ▁) ▁{ ▁if ▁( ▁i ▁== ▁n ▁) ▁return ▁1 ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁[ ▁j ▁] ▁== ▁1 ▁&& ▁blue ▁. ▁find ▁( ▁j ▁) ▁== ▁blue ▁. ▁end ▁( ▁) ▁) ▁{ ▁blue ▁. ▁insert ▁( ▁j ▁) ▁; ▁count ▁+= ▁numOf W ays ▁( ▁a ▁, ▁n ▁, ▁i ▁+ ▁1 ▁, ▁blue ▁) ▁; ▁blue ▁. ▁erase ▁( ▁j ▁) ▁; ▁} ▁} ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁3 ▁; ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁mat ▁= ▁{ ▁{ ▁0 ▁, ▁1 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁0 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁1 ▁, ▁1 ▁} ▁} ▁; ▁set ▁< ▁int ▁> ▁m pp ▁; ▁c out ▁<< ▁( ▁numOf W ays ▁( ▁mat ▁, ▁n ▁, ▁0 ▁, ▁m pp ▁) ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁total Arrays ▁( ▁int ▁N ▁, ▁int ▁M ▁) ▁{ ▁int ▁end _ with _ one ▁[ ▁N ▁+ ▁1 ▁] ▁; ▁int ▁end _ not _ with _ one ▁[ ▁N ▁+ ▁1 ▁] ▁; ▁end _ with _ one ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁end _ not _ with _ one ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁end _ with _ one ▁[ ▁1 ▁] ▁= ▁0 ▁; ▁end _ not _ with _ one ▁[ ▁1 ▁] ▁= ▁M ▁- ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁end _ with _ one ▁[ ▁i ▁] ▁= ▁end _ not _ with _ one ▁[ ▁i ▁- ▁1 ▁] ▁; ▁end _ not _ with _ one ▁[ ▁i ▁] ▁= ▁end _ with _ one ▁[ ▁i ▁- ▁1 ▁] ▁* ▁( ▁M ▁- ▁1 ▁) ▁+ ▁end _ not _ with _ one ▁[ ▁i ▁- ▁1 ▁] ▁* ▁( ▁M ▁- ▁2 ▁) ▁; ▁} ▁return ▁end _ with _ one ▁[ ▁N ▁- ▁1 ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁3 ▁, ▁M ▁= ▁3 ▁; ▁int ▁temp ▁= ▁total Arrays ▁( ▁N ▁, ▁M ▁) ▁; ▁int ▁ans ▁= ▁M ▁* ▁temp ▁; ▁c out ▁<< ▁ans ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁M ▁100 000000 7 ▁NEW _ LINE ▁long ▁long ▁power ▁( ▁long ▁long ▁X ▁, ▁long ▁long ▁Y ▁) ▁{ ▁long ▁long ▁res ▁= ▁1 ▁; ▁X ▁= ▁X ▁% ▁M ▁; ▁if ▁( ▁X ▁== ▁0 ▁) ▁return ▁0 ▁; ▁while ▁( ▁Y ▁> ▁0 ▁) ▁{ ▁if ▁( ▁Y ▁& ▁1 ▁) ▁{ ▁res ▁= ▁( ▁res ▁* ▁X ▁) ▁% ▁M ▁; ▁} ▁Y ▁= ▁Y ▁>> ▁1 ▁; ▁X ▁= ▁( ▁X ▁* ▁X ▁) ▁% ▁M ▁; ▁} ▁return ▁res ▁; ▁} ▁int ▁find Value ▁( ▁long ▁long ▁int ▁n ▁) ▁{ ▁long ▁long ▁X ▁= ▁0 ▁; ▁long ▁long ▁pow _10 ▁= ▁1 ▁; ▁while ▁( ▁n ▁) ▁{ ▁if ▁( ▁n ▁& ▁1 ▁) ▁{ ▁X ▁+= ▁pow _10 ▁; ▁} ▁pow _10 ▁*= ▁10 ▁; ▁n ▁/= ▁2 ▁; ▁} ▁X ▁= ▁( ▁X ▁* ▁2 ▁) ▁% ▁M ▁; ▁long ▁long ▁res ▁= ▁power ▁( ▁2 ▁, ▁X ▁) ▁; ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁long ▁long ▁n ▁= ▁2 ▁; ▁c out ▁<< ▁find Value ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁long ▁count W ays To Tile Board ▁( ▁long ▁N ▁) ▁{ ▁long ▁dp ▁[ ▁N ▁+ ▁1 ▁] ▁; ▁dp ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁dp ▁[ ▁1 ▁] ▁= ▁2 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁= ▁( ▁2 ▁* ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁dp ▁[ ▁i ▁- ▁2 ▁] ▁) ▁; ▁} ▁c out ▁<< ▁dp ▁[ ▁N ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁long ▁N ▁= ▁2 ▁; ▁count W ays To Tile Board ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁remove Small est Sub array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁S ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁target _ rem ainder ▁= ▁S ▁% ▁k ▁; ▁unordered _ map ▁< ▁int ▁, ▁int ▁> ▁map 1 ▁; ▁map 1 ▁[ ▁0 ▁] ▁= ▁-1 ▁; ▁int ▁curr _ rem ainder ▁= ▁0 ▁; ▁int ▁res ▁= ▁INT _ MAX ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁curr _ rem ainder ▁= ▁( ▁curr _ rem ainder ▁+ ▁arr ▁[ ▁i ▁] ▁+ ▁k ▁) ▁% ▁k ▁; ▁map 1 ▁[ ▁curr _ rem ainder ▁] ▁= ▁i ▁; ▁int ▁mod ▁= ▁( ▁curr _ rem ainder ▁- ▁target _ rem ainder ▁+ ▁k ▁) ▁% ▁k ▁; ▁if ▁( ▁map 1 ▁. ▁find ▁( ▁mod ▁) ▁!= ▁map 1 ▁. ▁end ▁( ▁) ▁) ▁{ ▁res ▁= ▁min ▁( ▁res ▁, ▁i ▁- ▁map 1 ▁[ ▁mod ▁] ▁) ▁; ▁} ▁} ▁if ▁( ▁res ▁== ▁INT _ MAX ▁res ▁== ▁n ▁) ▁{ ▁res ▁= ▁-1 ▁; ▁} ▁return ▁res ▁; ▁} ▁int ▁sm st Sub mat Deleted ▁( ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁& ▁mat ▁, ▁int ▁N ▁, ▁int ▁M ▁, ▁int ▁K ▁) ▁{ ▁int ▁S ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁M ▁; ▁j ▁++ ▁) ▁S ▁+= ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁} ▁int ▁min _ area ▁= ▁N ▁* ▁M ▁; ▁int ▁left ▁= ▁0 ▁; ▁int ▁right ▁= ▁0 ▁; ▁int ▁width ▁; ▁int ▁area ▁; ▁int ▁prefix Row Sum ▁[ ▁N ▁] ▁; ▁for ▁( ▁left ▁= ▁0 ▁; ▁left ▁< ▁M ▁; ▁left ▁++ ▁) ▁{ ▁mem set ▁( ▁prefix Row Sum ▁, ▁0 ▁, ▁sizeof ▁( ▁prefix Row Sum ▁) ▁) ▁; ▁for ▁( ▁right ▁= ▁left ▁; ▁right ▁< ▁M ▁; ▁right ▁++ ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁prefix Row Sum ▁[ ▁i ▁] ▁+= ▁mat ▁[ ▁i ▁] ▁[ ▁right ▁] ▁; ▁} ▁width ▁= ▁remove Small est Sub array ▁( ▁prefix Row Sum ▁, ▁S ▁,
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count strings ▁( ▁int ▁n ▁, ▁int ▁start ▁) ▁{ ▁if ▁( ▁n ▁== ▁0 ▁) ▁{ ▁return ▁1 ▁; ▁} ▁int ▁cnt ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁start ▁; ▁i ▁< ▁5 ▁; ▁i ▁++ ▁) ▁{ ▁cnt ▁+= ▁count strings ▁( ▁n ▁- ▁1 ▁, ▁i ▁) ▁; ▁} ▁return ▁cnt ▁; ▁} ▁int ▁count V ow el Strings ▁( ▁int ▁n ▁) ▁{ ▁return ▁count strings ▁( ▁n ▁, ▁0 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁2 ▁; ▁c out ▁<< ▁count V ow el Strings ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find NumberOf Strings ▁( ▁int ▁n ▁) ▁{ ▁return ▁( ▁n ▁+ ▁1 ▁) ▁* ▁( ▁n ▁+ ▁2 ▁) ▁* ▁( ▁n ▁+ ▁3 ▁) ▁* ▁( ▁n ▁+ ▁4 ▁) ▁/ ▁24 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁2 ▁; ▁c out ▁<< ▁find NumberOf Strings ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁# define ▁ll ▁long ▁long ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁int ▁mod ▁= ▁( ▁int ▁) ▁1 e 9 ▁+ ▁7 ▁; ▁ll ▁find Total Path ▁( ▁int ▁X ▁, ▁int ▁n ▁, ▁vector ▁< ▁int ▁> ▁& ▁dp ▁) ▁{ ▁if ▁( ▁X ▁== ▁0 ▁) ▁{ ▁return ▁1 ▁; ▁} ▁ll ▁ans ▁= ▁0 ▁; ▁if ▁( ▁dp ▁[ ▁X ▁] ▁!= ▁-1 ▁) ▁{ ▁return ▁dp ▁[ ▁X ▁] ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁min ▁( ▁X ▁, ▁n ▁) ▁; ▁++ ▁i ▁) ▁{ ▁ans ▁+= ▁find Total Path ▁( ▁X ▁- ▁i ▁, ▁n ▁, ▁dp ▁) ▁% ▁mod ▁; ▁ans ▁% = ▁mod ▁; ▁} ▁return ▁dp ▁[ ▁X ▁] ▁= ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁3 ▁, ▁X ▁= ▁2 ▁; ▁vector ▁< ▁int ▁> ▁dp ▁( ▁X ▁+ ▁1 ▁, ▁-1 ▁) ▁; ▁c out ▁<< ▁find Total Path ▁( ▁X ▁, ▁n ▁, ▁dp ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁MAX ▁10000 5 ▁NEW _ LINE ▁vector ▁< ▁int ▁> ▁S ieve Of E rat ost hen es ▁( ▁) ▁{ ▁bool ▁se ive ▁[ ▁MAX ▁] ▁; ▁mem set ▁( ▁se ive ▁, ▁true ▁, ▁sizeof ▁( ▁se ive ▁) ▁) ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁* ▁p ▁< ▁MAX ▁; ▁p ▁++ ▁) ▁{ ▁if ▁( ▁se ive ▁[ ▁p ▁] ▁== ▁true ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁p ▁* ▁p ▁; ▁i ▁< ▁MAX ▁; ▁i ▁+= ▁p ▁) ▁{ ▁se ive ▁[ ▁i ▁] ▁= ▁false ▁; ▁} ▁} ▁} ▁vector ▁< ▁int ▁> ▁v ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁< ▁MAX ▁; ▁p ▁++ ▁) ▁{ ▁if ▁( ▁se ive ▁[ ▁p ▁] ▁) ▁{ ▁v ▁. ▁push _ back ▁( ▁p ▁) ▁; ▁} ▁} ▁return ▁v ▁; ▁} ▁void ▁build ▁( ▁int ▁dp ▁[ ▁] ▁, ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁dp ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁dp ▁[ ▁1 ▁] ▁= ▁0 ▁; ▁vector ▁< ▁int ▁> ▁prime ▁= ▁S ieve Of E rat ost hen es ▁( ▁) ▁; ▁int ▁pref ▁[ ▁N ▁+ ▁1 ▁] ▁; ▁pref ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁pref ▁[ ▁i ▁] ▁= ▁pref ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁<= ▁prime ▁. ▁size ▁( ▁) ▁; ▁j ▁++ ▁) ▁{ ▁int ▁r ▁= ▁i ▁- ▁1 ▁; ▁int ▁l ▁= ▁r ▁- ▁prime ▁[ ▁j ▁] ▁+ ▁1 ▁; ▁if ▁( ▁l ▁< ▁0 ▁) ▁break ▁; ▁int ▁temp ▁= ▁0 ▁; ▁temp ▁= ▁pref ▁[ ▁r ▁+ ▁1 ▁] ▁- ▁pref ▁[ ▁l ▁] ▁; ▁if ▁( ▁l ▁- ▁2 ▁>= ▁0 ▁) ▁temp ▁+= ▁dp ▁[ ▁l ▁- ▁2 ▁+ ▁1 ▁] ▁; ▁dp ▁[ ▁i ▁] ▁= ▁max ▁( ▁dp ▁[ ▁i ▁] ▁, ▁temp ▁) ▁; ▁} ▁} ▁} ▁void ▁max Sum Sub seq ▁( ▁int ▁arr ▁[
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁bin C off ▁( ▁int ▁N ▁, ▁int ▁R ▁) ▁{ ▁int ▁res ▁= ▁1 ▁; ▁if ▁( ▁R ▁> ▁( ▁N ▁- ▁R ▁) ▁) ▁{ ▁R ▁= ▁( ▁N ▁- ▁R ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁R ▁; ▁i ▁++ ▁) ▁{ ▁res ▁*= ▁( ▁N ▁- ▁i ▁) ▁; ▁res ▁/= ▁( ▁i ▁+ ▁1 ▁) ▁; ▁} ▁return ▁res ▁; ▁} ▁int ▁cnt Perm utation ▁( ▁int ▁N ▁) ▁{ ▁int ▁cnt Perm ▁; ▁int ▁C _2 N _ N ▁= ▁bin C off ▁( ▁2 ▁* ▁N ▁, ▁N ▁) ▁; ▁cnt Perm ▁= ▁C _2 N _ N ▁/ ▁( ▁N ▁+ ▁1 ▁) ▁; ▁return ▁cnt Perm ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁cnt Perm utation ▁( ▁N ▁/ ▁2 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁check Equal Sum Util ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁sm 1 ▁, ▁int ▁sm 2 ▁, ▁int ▁sm 3 ▁, ▁int ▁j ▁) ▁{ ▁if ▁( ▁j ▁== ▁N ▁) ▁{ ▁if ▁( ▁sm 1 ▁== ▁sm 2 ▁&& ▁sm 2 ▁== ▁sm 3 ▁) ▁return ▁1 ▁; ▁else ▁return ▁0 ▁; ▁} ▁else ▁{ ▁int ▁l ▁= ▁check Equal Sum Util ▁( ▁arr ▁, ▁N ▁, ▁sm 1 ▁+ ▁arr ▁[ ▁j ▁] ▁, ▁sm 2 ▁, ▁sm 3 ▁, ▁j ▁+ ▁1 ▁) ▁; ▁int ▁m ▁= ▁check Equal Sum Util ▁( ▁arr ▁, ▁N ▁, ▁sm 1 ▁, ▁sm 2 ▁+ ▁arr ▁[ ▁j ▁] ▁, ▁sm 3 ▁, ▁j ▁+ ▁1 ▁) ▁; ▁int ▁r ▁= ▁check Equal Sum Util ▁( ▁arr ▁, ▁N ▁, ▁sm 1 ▁, ▁sm 2 ▁, ▁sm 3 ▁+ ▁arr ▁[ ▁j ▁] ▁, ▁j ▁+ ▁1 ▁) ▁; ▁return ▁max ▁( ▁max ▁( ▁l ▁, ▁m ▁) ▁, ▁r ▁) ▁; ▁} ▁} ▁void ▁check Equal Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁sum 1 ▁, ▁sum 2 ▁, ▁sum 3 ▁; ▁sum 1 ▁= ▁sum 2 ▁= ▁sum 3 ▁= ▁0 ▁; ▁if ▁( ▁check Equal Sum Util ▁( ▁arr ▁, ▁N ▁, ▁sum 1 ▁, ▁sum 2 ▁, ▁sum 3 ▁, ▁0 ▁) ▁== ▁1 ▁) ▁{ ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁" ▁No ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁17 ▁, ▁34 ▁, ▁59 ▁, ▁23 ▁, ▁17 ▁, ▁67 ▁, ▁57 ▁, ▁2 ▁, ▁18 ▁, ▁59 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁check Equal Sum ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁Sub array With Max Sum ▁( ▁vector ▁< ▁int ▁> ▁& ▁nums ▁) ▁{ ▁int ▁endIndex ▁, ▁curr Max ▁= ▁nums ▁[ ▁0 ▁] ▁; ▁int ▁global Max ▁= ▁nums ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁nums ▁. ▁size ▁( ▁) ▁; ▁++ ▁i ▁) ▁{ ▁curr Max ▁= ▁max ▁( ▁nums ▁[ ▁i ▁] ▁, ▁nums ▁[ ▁i ▁] ▁+ ▁curr Max ▁) ▁; ▁if ▁( ▁curr Max ▁> ▁global Max ▁) ▁{ ▁global Max ▁= ▁curr Max ▁; ▁endIndex ▁= ▁i ▁; ▁} ▁} ▁int ▁startIndex ▁= ▁endIndex ▁; ▁while ▁( ▁startIndex ▁>= ▁0 ▁) ▁{ ▁global Max ▁-= ▁nums ▁[ ▁startIndex ▁] ▁; ▁if ▁( ▁global Max ▁== ▁0 ▁) ▁break ▁; ▁startIndex ▁-- ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁startIndex ▁; ▁i ▁<= ▁endIndex ▁; ▁++ ▁i ▁) ▁{ ▁c out ▁<< ▁nums ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁int ▁> ▁arr ▁= ▁{ ▁-2 ▁, ▁-5 ▁, ▁6 ▁, ▁-2 ▁, ▁-3 ▁, ▁1 ▁, ▁5 ▁, ▁- 6 ▁} ▁; ▁Sub array With Max Sum ▁( ▁arr ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max imize Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁= ▁i ▁+ ▁2 ▁) ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁int ▁left DP ▁[ ▁n ▁/ ▁2 ▁] ▁; ▁int ▁right DP ▁[ ▁n ▁/ ▁2 ▁] ▁; ▁int ▁c ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁= ▁i ▁+ ▁2 ▁) ▁{ ▁int ▁left Diff ▁= ▁arr ▁[ ▁i ▁] ▁- ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁; ▁if ▁( ▁c ▁- ▁1 ▁< ▁0 ▁) ▁left DP ▁= ▁left Diff ▁; ▁else ▁{ ▁if ▁( ▁left DP ▁> ▁0 ▁) ▁left DP ▁= ▁left Diff ▁+ ▁left DP ▁; ▁else ▁left DP ▁[ ▁i ▁] ▁= ▁left Diff ▁; ▁} ▁int ▁right Diff ▁; ▁if ▁( ▁i ▁+ ▁1 ▁>= ▁n ▁) ▁right Diff ▁= ▁0 ▁; ▁else ▁right Diff ▁= ▁arr ▁[ ▁i ▁] ▁- ▁arr ▁[ ▁i ▁+ ▁1 ▁] ▁; ▁if ▁( ▁c ▁- ▁1 ▁< ▁0 ▁) ▁right DP ▁= ▁right Diff ▁; ▁else ▁{ ▁if ▁( ▁right DP ▁> ▁0 ▁) ▁right DP ▁= ▁right Diff ▁+ ▁right DP ▁; ▁else ▁right DP ▁= ▁right Diff ▁; ▁} ▁c ▁++ ▁; ▁} ▁int ▁max i ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁/ ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁max i ▁= ▁max ▁( ▁max i ▁, ▁max ▁( ▁left DP ▁[ ▁i ▁] ▁, ▁right DP ▁[ ▁i ▁] ▁) ▁) ▁; ▁} ▁return ▁max i ▁+ ▁sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁7 ▁, ▁8 ▁, ▁4 ▁, ▁5 ▁, ▁7 ▁, ▁6 ▁, ▁8 ▁, ▁9 ▁, ▁7 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁ans ▁= ▁max imize Sum ▁( ▁arr ▁, ▁n ▁) ▁; ▁c out ▁<< ▁( ▁ans ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁valid sub sequences ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁long ▁long ▁int ▁dp ▁[ ▁n ▁+ ▁1 ▁] ▁[ ▁2 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁dp ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁= ▁0 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁% ▁2 ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁+= ▁1 ▁; ▁dp ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁+= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁0 ▁] ▁; ▁dp ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁+= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁1 ▁] ▁; ▁dp ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁+= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁0 ▁] ▁; ▁} ▁else ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁+= ▁1 ▁; ▁dp ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁+= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁1 ▁] ▁; ▁dp ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁+= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁0 ▁] ▁; ▁dp ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁+= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁1 ▁] ▁; ▁} ▁} ▁return ▁dp ▁[ ▁n ▁] ▁[ ▁0 ▁] ▁+ ▁dp ▁[ ▁n ▁] ▁[ ▁1 ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁6 ▁, ▁9 ▁, ▁7 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁valid sub sequences ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁O dd Div is ors Count ▁( ▁int ▁n ▁, ▁int ▁q ▁, ▁int ▁a ▁[ ▁] ▁, ▁vector ▁< ▁pair ▁< ▁int ▁, ▁int ▁> ▁> ▁Query ▁) ▁{ ▁int ▁D P ▁[ ▁n ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁x ▁= ▁sqrt ▁( ▁a ▁[ ▁i ▁] ▁) ▁; ▁if ▁( ▁x ▁* ▁x ▁== ▁a ▁[ ▁i ▁] ▁) ▁D P ▁[ ▁i ▁] ▁= ▁1 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁D P ▁[ ▁i ▁] ▁= ▁D P ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁D P ▁[ ▁i ▁] ▁; ▁} ▁int ▁l ▁, ▁r ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁q ▁; ▁i ▁++ ▁) ▁{ ▁l ▁= ▁Query ▁[ ▁i ▁] ▁. ▁first ▁; ▁r ▁= ▁Query ▁[ ▁i ▁] ▁. ▁second ▁; ▁if ▁( ▁l ▁== ▁0 ▁) ▁{ ▁c out ▁<< ▁D P ▁[ ▁r ▁] ▁<< ▁end l ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁D P ▁[ ▁r ▁] ▁- ▁D P ▁[ ▁l ▁- ▁1 ▁] ▁<< ▁end l ▁; ▁} ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁5 ▁; ▁int ▁Q ▁= ▁3 ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁, ▁9 ▁} ▁; ▁vector ▁< ▁pair ▁< ▁int ▁, ▁int ▁> ▁> ▁Query ▁Query ▁= ▁{ ▁{ ▁0 ▁, ▁2 ▁} ▁, ▁{ ▁1 ▁, ▁3 ▁} ▁, ▁{ ▁1 ▁, ▁4 ▁} ▁} ▁; ▁O dd Div is ors Count ▁( ▁N ▁, ▁Q ▁, ▁arr ▁, ▁Query ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Stable Num ▁( ▁string ▁str ▁, ▁int ▁N ▁) ▁{ ▁int ▁count 1 ▁[ ▁N ▁] ▁[ ▁10 ▁] ▁; ▁int ▁count 2 ▁[ ▁N ▁] ▁[ ▁10 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁10 ▁; ▁j ▁++ ▁) ▁count 1 ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁count 2 ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁!= ▁0 ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁10 ▁; ▁j ▁++ ▁) ▁{ ▁count 1 ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+= ▁count 1 ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁; ▁} ▁} ▁count 1 ▁[ ▁i ▁] ▁[ ▁str ▁[ ▁i ▁] ▁- ▁'0' ▁] ▁++ ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁N ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁i ▁!= ▁N ▁- ▁1 ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁10 ▁; ▁j ▁++ ▁) ▁{ ▁count 2 ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+= ▁count 2 ▁[ ▁i ▁+ ▁1 ▁] ▁[ ▁j ▁] ▁; ▁} ▁} ▁count 2 ▁[ ▁i ▁] ▁[ ▁str ▁[ ▁i ▁] ▁- ▁'0' ▁] ▁++ ▁; ▁} ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁str ▁[ ▁i ▁] ▁== ▁'9' ▁) ▁continue ▁; ▁int ▁c 1 ▁= ▁count 1 ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁str ▁[ ▁i ▁] ▁- ▁'0' ▁] ▁; ▁int ▁c 2 ▁= ▁count 2 ▁[ ▁i ▁+ ▁1 ▁] ▁[ ▁str ▁[ ▁i ▁] ▁- ▁'0' ▁+ ▁1 ▁] ▁; ▁if ▁( ▁c 2 ▁== ▁0 ▁) ▁continue ▁; ▁ans ▁= ▁( ▁ans ▁+ ▁( ▁c 1 ▁* ▁( ▁( ▁c 2 ▁* ▁( ▁c 2 ▁- ▁1 ▁) ▁/ ▁2 ▁) ▁) ▁) ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁"2 24 35 3" ▁; ▁int ▁N ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁c out ▁<< ▁count Stable Num ▁( ▁str ▁, ▁N ▁)
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁long ▁long ▁MAX ▁= ▁1 e 18 ▁; ▁long ▁long ▁n ▁, ▁m ▁; ▁vector ▁< ▁long ▁long ▁> ▁v ▁[ ▁15 1 ▁] ▁; ▁long ▁long ▁dp ▁[ ▁15 1 ▁] ▁[ ▁15 1 ▁] ▁; ▁long ▁long ▁min _ operation ▁( ▁long ▁long ▁i ▁, ▁long ▁long ▁j ▁, ▁long ▁long ▁val ▁, ▁long ▁long ▁x ▁) ▁{ ▁if ▁( ▁i ▁== ▁n ▁- ▁1 ▁&& ▁j ▁== ▁m ▁- ▁1 ▁) ▁{ ▁if ▁( ▁val ▁> ▁v ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁{ ▁return ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁MAX ▁; ▁} ▁else ▁{ ▁return ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁v ▁[ ▁i ▁] ▁[ ▁j ▁] ▁- ▁val ▁; ▁} ▁} ▁if ▁( ▁i ▁== ▁n ▁j ▁== ▁m ▁) ▁{ ▁return ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁MAX ▁; ▁} ▁if ▁( ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁!= ▁-1 ▁) ▁{ ▁return ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁} ▁if ▁( ▁val ▁> ▁v ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁{ ▁return ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁MAX ▁; ▁} ▁long ▁long ▁tmp ▁= ▁v ▁[ ▁i ▁] ▁[ ▁j ▁] ▁- ▁val ▁; ▁tmp ▁+= ▁min ▁( ▁min _ operation ▁( ▁i ▁+ ▁1 ▁, ▁j ▁, ▁val ▁+ ▁x ▁, ▁x ▁) ▁, ▁min _ operation ▁( ▁i ▁, ▁j ▁+ ▁1 ▁, ▁val ▁+ ▁x ▁, ▁x ▁) ▁) ▁; ▁return ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁tmp ▁; ▁} ▁long ▁long ▁solve ▁( ▁long ▁long ▁x ▁) ▁{ ▁long ▁long ▁ans ▁= ▁INT 64_ MAX ▁; ▁for ▁( ▁long ▁long ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁long ▁long ▁j ▁= ▁0 ▁; ▁j ▁< ▁m ▁; ▁j ▁++ ▁) ▁{ ▁long ▁long ▁val ▁= ▁v ▁[ ▁i ▁] ▁[ ▁j ▁] ▁- ▁x ▁* ▁( ▁i ▁+ ▁j ▁) ▁; ▁mem set ▁( ▁dp ▁, ▁-1 ▁, ▁sizeof ▁( ▁dp ▁) ▁) ▁; ▁val ▁= ▁min _ operation ▁( ▁0 ▁, ▁0 ▁, ▁val ▁, ▁x ▁) ▁; ▁ans ▁= ▁min ▁( ▁ans ▁, ▁val ▁) ▁; ▁} ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁n ▁= ▁2 ▁, ▁m ▁= ▁2
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁ll ▁long ▁long ▁int ▁NEW _ LINE ▁ll ▁K ▁; ▁ll ▁N ▁; ▁vector ▁< ▁int ▁> ▁v ▁; ▁ll ▁dp ▁[ ▁20 ▁] ▁[ ▁1000 ▁] ▁[ ▁10 ▁] ▁[ ▁2 ▁] ▁[ ▁2 ▁] ▁; ▁void ▁init ▁( ▁ll ▁x ▁) ▁{ ▁mem set ▁( ▁dp ▁, ▁-1 ▁, ▁sizeof ▁( ▁dp ▁) ▁) ▁; ▁v ▁. ▁clear ▁( ▁) ▁; ▁while ▁( ▁x ▁> ▁0 ▁) ▁{ ▁v ▁. ▁push _ back ▁( ▁x ▁% ▁10 ▁) ▁; ▁x ▁/= ▁10 ▁; ▁} ▁reverse ▁( ▁v ▁. ▁begin ▁( ▁) ▁, ▁v ▁. ▁end ▁( ▁) ▁) ▁; ▁N ▁= ▁v ▁. ▁size ▁( ▁) ▁; ▁} ▁ll ▁fun ▁( ▁ll ▁pos ▁, ▁ll ▁sum ▁, ▁ll ▁st ▁, ▁ll ▁check ▁, ▁ll ▁f ▁) ▁{ ▁if ▁( ▁pos ▁== ▁N ▁) ▁{ ▁return ▁( ▁sum ▁== ▁0 ▁and ▁check ▁== ▁1 ▁) ▁; ▁} ▁if ▁( ▁dp ▁[ ▁pos ▁] ▁[ ▁sum ▁] ▁[ ▁st ▁] ▁[ ▁check ▁] ▁[ ▁f ▁] ▁!= ▁-1 ▁) ▁return ▁dp ▁[ ▁pos ▁] ▁[ ▁sum ▁] ▁[ ▁st ▁] ▁[ ▁check ▁] ▁[ ▁f ▁] ▁; ▁ll ▁l mt ▁= ▁9 ▁; ▁if ▁( ▁! ▁f ▁) ▁l mt ▁= ▁v ▁[ ▁pos ▁] ▁; ▁ll ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁digit ▁= ▁0 ▁; ▁digit ▁<= ▁l mt ▁; ▁digit ▁++ ▁) ▁{ ▁ll ▁nf ▁= ▁f ▁; ▁ll ▁new _ sum ▁= ▁( ▁sum ▁+ ▁digit ▁) ▁% ▁K ▁; ▁ll ▁new _ check ▁= ▁check ▁; ▁ll ▁new _ st ▁= ▁st ▁; ▁if ▁( ▁f ▁== ▁0 ▁and ▁digit ▁< ▁l mt ▁) ▁nf ▁= ▁1 ▁; ▁if ▁( ▁check ▁== ▁0 ▁and ▁digit ▁!= ▁0 ▁) ▁{ ▁new _ st ▁= ▁digit ▁; ▁new _ check ▁= ▁1 ▁; ▁} ▁if ▁( ▁pos ▁== ▁N ▁- ▁1 ▁and ▁new _ st ▁== ▁digit ▁) ▁continue ▁; ▁ans ▁+= ▁fun ▁( ▁pos ▁+ ▁1 ▁, ▁new _ sum ▁, ▁new _ st ▁, ▁new _ check ▁, ▁nf ▁) ▁; ▁} ▁return ▁dp ▁[ ▁pos ▁] ▁[ ▁sum ▁] ▁[ ▁st ▁] ▁[ ▁check ▁] ▁[ ▁f ▁] ▁= ▁ans ▁; ▁} ▁void ▁find Count ▁( ▁int ▁L ▁, ▁int ▁R ▁, ▁int ▁K ▁) ▁{ ▁init ▁( ▁R ▁) ▁; ▁ll ▁r _
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is Perf ect Square ▁( ▁long ▁double ▁x ▁) ▁{ ▁long ▁double ▁sr ▁= ▁sqrt ▁( ▁x ▁) ▁; ▁return ▁( ▁( ▁sr ▁- ▁floor ▁( ▁sr ▁) ▁) ▁== ▁0 ▁) ▁; ▁} ▁int ▁find Sub array Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁K ▁) ▁{ ▁unordered _ map ▁< ▁int ▁, ▁int ▁> ▁prev Sum ▁; ▁int ▁res ▁= ▁0 ▁; ▁int ▁curr sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁curr sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁if ▁( ▁curr sum ▁== ▁K ▁) ▁{ ▁res ▁++ ▁; ▁} ▁if ▁( ▁prev Sum ▁. ▁find ▁( ▁curr sum ▁- ▁K ▁) ▁!= ▁prev Sum ▁. ▁end ▁( ▁) ▁) ▁res ▁+= ▁( ▁prev Sum ▁[ ▁curr sum ▁- ▁K ▁] ▁) ▁; ▁prev Sum ▁[ ▁curr sum ▁] ▁++ ▁; ▁} ▁return ▁res ▁; ▁} ▁void ▁count Sub array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁K ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁is Perf ect Square ▁( ▁arr ▁[ ▁i ▁] ▁) ▁) ▁{ ▁arr ▁[ ▁i ▁] ▁= ▁1 ▁; ▁} ▁else ▁{ ▁arr ▁[ ▁i ▁] ▁= ▁0 ▁; ▁} ▁} ▁c out ▁<< ▁find Sub array Sum ▁( ▁arr ▁, ▁n ▁, ▁K ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁4 ▁, ▁9 ▁, ▁2 ▁} ▁; ▁int ▁K ▁= ▁2 ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁count Sub array ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁dim ▁5 ▁NEW _ LINE ▁void ▁createTable ▁( ▁int ▁m tr x ▁[ ▁] ▁[ ▁dim ▁] ▁, ▁int ▁k ▁, ▁int ▁p ▁, ▁int ▁dp ▁[ ▁] ▁[ ▁dim ▁] ▁) ▁{ ▁dp ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁= ▁m tr x ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁< ▁dim ▁; ▁j ▁++ ▁) ▁{ ▁dp ▁[ ▁0 ▁] ▁[ ▁j ▁] ▁= ▁m tr x ▁[ ▁0 ▁] ▁[ ▁j ▁] ▁+ ▁dp ▁[ ▁0 ▁] ▁[ ▁j ▁- ▁1 ▁] ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁dim ▁; ▁i ▁++ ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁= ▁m tr x ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁+ ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁0 ▁] ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁dim ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁< ▁dim ▁; ▁j ▁++ ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁m tr x ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+ ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁+ ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁- ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁- ▁1 ▁] ▁; ▁} ▁} ▁} ▁int ▁count Sub Matrix Util ▁( ▁int ▁dp ▁[ ▁] ▁[ ▁dim ▁] ▁, ▁int ▁k ▁, ▁int ▁p ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁int ▁sub Mat Sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁k ▁- ▁1 ▁; ▁i ▁< ▁dim ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁k ▁- ▁1 ▁; ▁j ▁< ▁dim ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁i ▁== ▁( ▁k ▁- ▁1 ▁) ▁|| ▁j ▁== ▁( ▁k ▁- ▁1 ▁) ▁) ▁{ ▁if ▁( ▁i ▁== ▁( ▁k ▁- ▁1 ▁) ▁&& ▁j ▁== ▁( ▁k ▁- ▁1 ▁) ▁) ▁{ ▁sub Mat Sum ▁= ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁} ▁else ▁if ▁( ▁i ▁== ▁( ▁k ▁- ▁1 ▁) ▁) ▁{ ▁sub Mat Sum ▁= ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁- ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁- ▁k ▁] ▁; ▁} ▁else ▁{ ▁sub Mat Sum ▁= ▁dp ▁[ ▁i
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count W ays ▁( ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁int ▁dp ▁[ ▁m ▁+ ▁1 ▁] ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁dp ▁[ ▁1 ▁] ▁[ ▁i ▁] ▁= ▁1 ▁; ▁if ▁( ▁i ▁!= ▁0 ▁) ▁{ ▁dp ▁[ ▁1 ▁] ▁[ ▁i ▁] ▁+= ▁dp ▁[ ▁1 ▁] ▁[ ▁i ▁- ▁1 ▁] ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁m ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁<= ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁j ▁== ▁0 ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁; ▁} ▁else ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁; ▁if ▁( ▁i ▁== ▁m ▁&& ▁j ▁== ▁n ▁) ▁{ ▁return ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁} ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+= ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁; ▁} ▁} ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁2 ▁, ▁K ▁= ▁3 ▁; ▁c out ▁<< ▁count W ays ▁( ▁N ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁check ▁( ▁vector ▁< ▁int ▁> ▁& ▁v ▁) ▁{ ▁set ▁< ▁int ▁> ▁digits ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁v ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁set ▁< ▁int ▁> ▁d ▁; ▁while ▁( ▁v ▁[ ▁i ▁] ▁) ▁{ ▁d ▁. ▁insert ▁( ▁v ▁[ ▁i ▁] ▁% ▁10 ▁) ▁; ▁v ▁[ ▁i ▁] ▁/= ▁10 ▁; ▁} ▁for ▁( ▁auto ▁it ▁: ▁d ▁) ▁{ ▁if ▁( ▁digits ▁. ▁count ▁( ▁it ▁) ▁) ▁return ▁false ▁; ▁} ▁for ▁( ▁auto ▁it ▁: ▁d ▁) ▁digits ▁. ▁insert ▁( ▁it ▁) ▁; ▁} ▁return ▁true ▁; ▁} ▁int ▁numberOf Sub arrays ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁answer ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁( ▁1 ▁<< ▁n ▁) ▁; ▁i ▁++ ▁) ▁{ ▁vector ▁< ▁int ▁> ▁temp ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁i ▁& ▁( ▁1 ▁<< ▁j ▁) ▁) ▁temp ▁. ▁push _ back ▁( ▁a ▁[ ▁j ▁] ▁) ▁; ▁} ▁if ▁( ▁check ▁( ▁temp ▁) ▁) ▁answer ▁++ ▁; ▁} ▁return ▁answer ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁4 ▁; ▁int ▁A ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁12 ▁, ▁23 ▁, ▁34 ▁} ▁; ▁c out ▁<< ▁numberOf Sub arrays ▁( ▁A ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁maximum Occurrence ▁( ▁string ▁s ▁) ▁{ ▁int ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁map ▁< ▁string ▁, ▁int ▁> ▁freq ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁string ▁temp ▁= ▁" ▁" ▁; ▁temp ▁+= ▁s ▁[ ▁i ▁] ▁; ▁freq ▁[ ▁temp ▁] ▁++ ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁string ▁temp ▁= ▁" ▁" ▁; ▁temp ▁+= ▁s ▁[ ▁i ▁] ▁; ▁temp ▁+= ▁s ▁[ ▁j ▁] ▁; ▁freq ▁[ ▁temp ▁] ▁++ ▁; ▁} ▁} ▁int ▁answer ▁= ▁INT _ MIN ▁; ▁for ▁( ▁auto ▁it ▁: ▁freq ▁) ▁answer ▁= ▁max ▁( ▁answer ▁, ▁it ▁. ▁second ▁) ▁; ▁return ▁answer ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁" ▁xx xy y ▁" ▁; ▁c out ▁<< ▁maximum Occurrence ▁( ▁s ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁maxLength ▁( ▁int ▁* ▁a ▁, ▁int ▁n ▁) ▁{ ▁int ▁maximum ▁= ▁1 ▁; ▁int ▁left ▁[ ▁n ▁] ▁; ▁int ▁right ▁[ ▁n ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁left ▁[ ▁i ▁] ▁= ▁1 ▁; ▁right ▁[ ▁i ▁] ▁= ▁1 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁2 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁> ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁{ ▁right ▁[ ▁i ▁] ▁= ▁right ▁[ ▁i ▁+ ▁1 ▁] ▁+ ▁1 ▁; ▁} ▁maximum ▁= ▁max ▁( ▁maximum ▁, ▁right ▁[ ▁i ▁] ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁< ▁a ▁[ ▁i ▁- ▁1 ▁] ▁) ▁{ ▁left ▁[ ▁i ▁] ▁= ▁left ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁1 ▁; ▁} ▁} ▁if ▁( ▁n ▁> ▁2 ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁- ▁1 ▁] ▁> ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁{ ▁maximum ▁= ▁max ▁( ▁maximum ▁, ▁left ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁right ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁; ▁} ▁} ▁} ▁return ▁maximum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁6 ▁] ▁= ▁{ ▁8 ▁, ▁7 ▁, ▁3 ▁, ▁5 ▁, ▁2 ▁, ▁9 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁maxLength ▁( ▁arr ▁, ▁n ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁l li ▁long ▁long ▁int ▁NEW _ LINE ▁unordered _ map ▁< ▁string ▁, ▁l li ▁> ▁dp ▁; ▁l li ▁solve ▁( ▁string ▁s ▁, ▁char ▁c ▁) ▁{ ▁if ▁( ▁s ▁. ▁length ▁( ▁) ▁== ▁1 ▁) ▁return ▁0 ▁; ▁if ▁( ▁s ▁. ▁length ▁( ▁) ▁== ▁2 ▁) ▁{ ▁if ▁( ▁s ▁[ ▁0 ▁] ▁== ▁s ▁[ ▁1 ▁] ▁&& ▁s ▁[ ▁0 ▁] ▁== ▁c ▁) ▁return ▁1 ▁; ▁else ▁return ▁0 ▁; ▁} ▁if ▁( ▁dp ▁[ ▁s ▁+ ▁" ▁" ▁+ ▁c ▁] ▁) ▁return ▁dp ▁[ ▁s ▁+ ▁" ▁" ▁+ ▁c ▁] ▁; ▁l li ▁ans ▁= ▁0 ▁; ▁if ▁( ▁s ▁[ ▁0 ▁] ▁== ▁s ▁[ ▁s ▁. ▁length ▁( ▁) ▁- ▁1 ▁] ▁&& ▁s ▁[ ▁0 ▁] ▁== ▁c ▁) ▁{ ▁for ▁( ▁char ▁c 1 ▁= ▁' ▁a ▁' ▁; ▁c 1 ▁<= ▁' ▁z ▁' ▁; ▁c 1 ▁++ ▁) ▁if ▁( ▁c 1 ▁!= ▁c ▁) ▁ans ▁= ▁max ▁( ▁ans ▁, ▁1 ▁+ ▁solve ▁( ▁s ▁. ▁substr ▁( ▁1 ▁, ▁s ▁. ▁length ▁( ▁) ▁- ▁2 ▁) ▁, ▁c 1 ▁) ▁) ▁; ▁} ▁else ▁{ ▁for ▁( ▁l li ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁[ ▁i ▁] ▁== ▁c ▁) ▁{ ▁for ▁( ▁l li ▁j ▁= ▁s ▁. ▁length ▁( ▁) ▁- ▁1 ▁; ▁j ▁> ▁i ▁; ▁j ▁-- ▁) ▁if ▁( ▁s ▁[ ▁j ▁] ▁== ▁c ▁) ▁{ ▁if ▁( ▁j ▁== ▁i ▁) ▁break ▁; ▁ans ▁= ▁solve ▁( ▁s ▁. ▁substr ▁( ▁i ▁, ▁j ▁- ▁i ▁+ ▁1 ▁) ▁, ▁c ▁) ▁; ▁break ▁; ▁} ▁break ▁; ▁} ▁} ▁} ▁dp ▁[ ▁s ▁+ ▁" ▁" ▁+ ▁c ▁] ▁= ▁ans ▁; ▁return ▁dp ▁[ ▁s ▁+ ▁" ▁" ▁+ ▁c ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁" ▁ab sc rc db a ▁" ▁; ▁l li ▁ma ▁= ▁0 ▁; ▁for ▁( ▁char ▁c 1 ▁= ▁' ▁a ▁' ▁; ▁c 1 ▁<= ▁' ▁z ▁' ▁; ▁c 1 ▁++ ▁) ▁ma ▁= ▁max ▁( ▁ma ▁, ▁solve ▁( ▁s ▁, ▁c 1 ▁) ▁* ▁2 ▁) ▁; ▁c out ▁<<
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max Inc Sub arr ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁pre ▁[ ▁n ▁] ▁= ▁{ ▁0 ▁} ▁; ▁int ▁pos ▁[ ▁n ▁] ▁= ▁{ ▁0 ▁} ▁; ▁pre ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁pos ▁[ ▁n ▁- ▁1 ▁] ▁= ▁1 ▁; ▁int ▁l ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁> ▁a ▁[ ▁i ▁- ▁1 ▁] ▁) ▁pre ▁[ ▁i ▁] ▁= ▁pre ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁1 ▁; ▁else ▁pre ▁[ ▁i ▁] ▁= ▁1 ▁; ▁} ▁l ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁2 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁< ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁pos ▁[ ▁i ▁] ▁= ▁pos ▁[ ▁i ▁+ ▁1 ▁] ▁+ ▁1 ▁; ▁else ▁pos ▁[ ▁i ▁] ▁= ▁1 ▁; ▁} ▁int ▁ans ▁= ▁0 ▁; ▁l ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁> ▁a ▁[ ▁i ▁- ▁1 ▁] ▁) ▁l ▁++ ▁; ▁else ▁l ▁= ▁1 ▁; ▁ans ▁= ▁max ▁( ▁ans ▁, ▁l ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁- ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁- ▁1 ▁] ▁< ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁ans ▁= ▁max ▁( ▁pre ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁pos ▁[ ▁i ▁+ ▁1 ▁] ▁, ▁ans ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁c out ▁<< ▁max Inc Sub arr ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁max N ▁20 ▁NEW _ LINE ▁# define ▁max M ▁64 ▁NEW _ LINE ▁int ▁dp ▁[ ▁max N ▁] ▁[ ▁max M ▁] ▁; ▁bool ▁v ▁[ ▁max N ▁] ▁[ ▁max M ▁] ▁; ▁int ▁find Len ▁( ▁int ▁* ▁arr ▁, ▁int ▁i ▁, ▁int ▁curr ▁, ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁if ▁( ▁i ▁== ▁n ▁) ▁{ ▁if ▁( ▁curr ▁== ▁m ▁) ▁return ▁0 ▁; ▁else ▁return ▁-1 ▁; ▁} ▁if ▁( ▁v ▁[ ▁i ▁] ▁[ ▁curr ▁] ▁) ▁return ▁dp ▁[ ▁i ▁] ▁[ ▁curr ▁] ▁; ▁v ▁[ ▁i ▁] ▁[ ▁curr ▁] ▁= ▁1 ▁; ▁int ▁l ▁= ▁find Len ▁( ▁arr ▁, ▁i ▁+ ▁1 ▁, ▁curr ▁, ▁n ▁, ▁m ▁) ▁; ▁int ▁r ▁= ▁find Len ▁( ▁arr ▁, ▁i ▁+ ▁1 ▁, ▁curr ▁arr ▁[ ▁i ▁] ▁, ▁n ▁, ▁m ▁) ▁; ▁dp ▁[ ▁i ▁] ▁[ ▁curr ▁] ▁= ▁l ▁; ▁if ▁( ▁r ▁!= ▁-1 ▁) ▁dp ▁[ ▁i ▁] ▁[ ▁curr ▁] ▁= ▁max ▁( ▁dp ▁[ ▁i ▁] ▁[ ▁curr ▁] ▁, ▁r ▁+ ▁1 ▁) ▁; ▁return ▁dp ▁[ ▁i ▁] ▁[ ▁curr ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁7 ▁, ▁2 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁int ▁m ▁= ▁3 ▁; ▁int ▁ans ▁= ▁find Len ▁( ▁arr ▁, ▁0 ▁, ▁0 ▁, ▁n ▁, ▁m ▁) ▁; ▁if ▁( ▁ans ▁== ▁-1 ▁) ▁c out ▁<< ▁0 ▁; ▁else ▁c out ▁<< ▁ans ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁max N ▁20 ▁NEW _ LINE ▁# define ▁max M ▁64 ▁NEW _ LINE ▁int ▁dp ▁[ ▁max N ▁] ▁[ ▁max M ▁] ▁; ▁bool ▁v ▁[ ▁max N ▁] ▁[ ▁max M ▁] ▁; ▁int ▁find Len ▁( ▁int ▁* ▁arr ▁, ▁int ▁i ▁, ▁int ▁curr ▁, ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁if ▁( ▁i ▁== ▁n ▁) ▁{ ▁if ▁( ▁! ▁curr ▁) ▁return ▁0 ▁; ▁else ▁return ▁-1 ▁; ▁} ▁if ▁( ▁v ▁[ ▁i ▁] ▁[ ▁curr ▁] ▁) ▁return ▁dp ▁[ ▁i ▁] ▁[ ▁curr ▁] ▁; ▁v ▁[ ▁i ▁] ▁[ ▁curr ▁] ▁= ▁1 ▁; ▁int ▁l ▁= ▁find Len ▁( ▁arr ▁, ▁i ▁+ ▁1 ▁, ▁curr ▁, ▁n ▁, ▁m ▁) ▁; ▁int ▁r ▁= ▁find Len ▁( ▁arr ▁, ▁i ▁+ ▁1 ▁, ▁( ▁curr ▁+ ▁arr ▁[ ▁i ▁] ▁) ▁% ▁m ▁, ▁n ▁, ▁m ▁) ▁; ▁dp ▁[ ▁i ▁] ▁[ ▁curr ▁] ▁= ▁l ▁; ▁if ▁( ▁r ▁!= ▁-1 ▁) ▁dp ▁[ ▁i ▁] ▁[ ▁curr ▁] ▁= ▁max ▁( ▁dp ▁[ ▁i ▁] ▁[ ▁curr ▁] ▁, ▁r ▁+ ▁1 ▁) ▁; ▁return ▁dp ▁[ ▁i ▁] ▁[ ▁curr ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁2 ▁, ▁2 ▁, ▁1 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁int ▁m ▁= ▁3 ▁; ▁c out ▁<< ▁find Len ▁( ▁arr ▁, ▁0 ▁, ▁0 ▁, ▁n ▁, ▁m ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁divide Array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁dp ▁[ ▁500 ▁] ▁[ ▁500 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁k ▁-= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁<= ▁k ▁; ▁j ▁++ ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁INT _ MAX ▁; ▁int ▁max _ ▁= ▁-1 ▁, ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁l ▁= ▁i ▁; ▁l ▁< ▁n ▁; ▁l ▁++ ▁) ▁{ ▁max _ ▁= ▁max ▁( ▁max _ ▁, ▁arr ▁[ ▁l ▁] ▁) ▁; ▁sum ▁+= ▁arr ▁[ ▁l ▁] ▁; ▁int ▁diff ▁= ▁( ▁l ▁- ▁i ▁+ ▁1 ▁) ▁* ▁max _ ▁- ▁sum ▁; ▁if ▁( ▁j ▁> ▁0 ▁) ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁min ▁( ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁, ▁diff ▁+ ▁dp ▁[ ▁l ▁+ ▁1 ▁] ▁[ ▁j ▁- ▁1 ▁] ▁) ▁; ▁else ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁diff ▁; ▁} ▁} ▁} ▁return ▁dp ▁[ ▁0 ▁] ▁[ ▁k ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁9 ▁, ▁5 ▁, ▁4 ▁, ▁8 ▁, ▁3 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁int ▁k ▁= ▁2 ▁; ▁c out ▁<< ▁divide Array ▁( ▁arr ▁, ▁n ▁, ▁k ▁) ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁Max H app iness ▁( ▁int ▁A ▁, ▁int ▁N ▁, ▁vector ▁< ▁string ▁> ▁v ▁) ▁{ ▁string ▁str ▁; ▁int ▁val ▁[ ▁N ▁] ▁, ▁wt ▁[ ▁N ▁] ▁, ▁c ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁str ▁= ▁v ▁[ ▁i ▁] ▁; ▁c ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁str ▁[ ▁j ▁] ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁str ▁[ ▁j ▁] ▁== ▁' ▁c ▁' ▁) ▁c ▁+= ▁4 ▁; ▁else ▁if ▁( ▁str ▁[ ▁j ▁] ▁== ▁' ▁w ▁' ▁) ▁c ▁+= ▁3 ▁; ▁else ▁if ▁( ▁str ▁[ ▁j ▁] ▁== ▁' ▁m ▁' ▁) ▁c ▁+= ▁2 ▁; ▁else ▁c ▁++ ▁; ▁} ▁c ▁*= ▁str ▁. ▁length ▁( ▁) ▁; ▁val ▁[ ▁i ▁] ▁= ▁c ▁; ▁wt ▁[ ▁i ▁] ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁} ▁int ▁k ▁[ ▁N ▁+ ▁1 ▁] ▁[ ▁A ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁w ▁= ▁0 ▁; ▁w ▁<= ▁A ▁; ▁w ▁++ ▁) ▁{ ▁if ▁( ▁i ▁== ▁0 ▁w ▁== ▁0 ▁) ▁k ▁[ ▁i ▁] ▁[ ▁w ▁] ▁= ▁0 ▁; ▁else ▁if ▁( ▁wt ▁[ ▁i ▁- ▁1 ▁] ▁<= ▁w ▁) ▁k ▁[ ▁i ▁] ▁[ ▁w ▁] ▁= ▁max ▁( ▁val ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁k ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁w ▁- ▁wt ▁[ ▁i ▁- ▁1 ▁] ▁] ▁, ▁k ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁w ▁] ▁) ▁; ▁else ▁k ▁[ ▁i ▁] ▁[ ▁w ▁] ▁= ▁k ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁w ▁] ▁; ▁} ▁} ▁return ▁k ▁[ ▁N ▁] ▁[ ▁A ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁= ▁5 ▁; ▁vector ▁< ▁string ▁> ▁v ▁= ▁{ ▁" ▁mm o ▁" ▁, ▁" ▁oo ▁" ▁, ▁" ▁cm w ▁" ▁, ▁" ▁cc ▁" ▁, ▁" ▁c ▁" ▁} ▁; ▁int ▁N ▁= ▁v ▁. ▁size ▁( ▁) ▁; ▁c out ▁<< ▁Max H app iness ▁( ▁A ▁, ▁N ▁, ▁v ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁N ▁10000 5 ▁NEW _ LINE ▁int ▁LI S ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁dp ▁[ ▁N ▁] ▁, ▁d ▁[ ▁N ▁] ▁; ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁dp ▁[ ▁a ▁[ ▁i ▁] ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁j ▁= ▁2 ▁; ▁j ▁* ▁j ▁<= ▁a ▁[ ▁i ▁] ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁% ▁j ▁== ▁0 ▁) ▁{ ▁dp ▁[ ▁a ▁[ ▁i ▁] ▁] ▁= ▁max ▁( ▁dp ▁[ ▁a ▁[ ▁i ▁] ▁] ▁, ▁dp ▁[ ▁d ▁[ ▁j ▁] ▁] ▁+ ▁1 ▁) ▁; ▁dp ▁[ ▁a ▁[ ▁i ▁] ▁] ▁= ▁max ▁( ▁dp ▁[ ▁a ▁[ ▁i ▁] ▁] ▁, ▁dp ▁[ ▁d ▁[ ▁a ▁[ ▁i ▁] ▁/ ▁j ▁] ▁] ▁+ ▁1 ▁) ▁; ▁d ▁[ ▁j ▁] ▁= ▁a ▁[ ▁i ▁] ▁; ▁d ▁[ ▁a ▁[ ▁i ▁] ▁/ ▁j ▁] ▁= ▁a ▁[ ▁i ▁] ▁; ▁} ▁} ▁ans ▁= ▁max ▁( ▁ans ▁, ▁dp ▁[ ▁a ▁[ ▁i ▁] ▁] ▁) ▁; ▁d ▁[ ▁a ▁[ ▁i ▁] ▁] ▁= ▁a ▁[ ▁i ▁] ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁LI S ▁( ▁a ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁check Combin ations ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁pow _ set _ size ▁= ▁pow ▁( ▁2 ▁, ▁n ▁) ▁; ▁int ▁counter ▁, ▁j ▁; ▁for ▁( ▁counter ▁= ▁0 ▁; ▁counter ▁< ▁pow _ set _ size ▁; ▁counter ▁++ ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁counter ▁& ▁( ▁1 ▁<< ▁j ▁) ▁) ▁else ▁} ▁if ▁( ▁sum ▁% ▁( ▁24 ▁* ▁60 ▁) ▁== ▁0 ▁) ▁return ▁true ▁; ▁} ▁return ▁false ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁60 ▁, ▁60 ▁, ▁120 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁if ▁( ▁check Combin ations ▁( ▁a ▁, ▁n ▁) ▁) ▁c out ▁<< ▁" ▁YES ▁" ▁; ▁else ▁c out ▁<< ▁" ▁NO ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁make Pairs ▁( ▁vector ▁< ▁int ▁> ▁& ▁pairs ▁, ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁a ▁; ▁i ▁<= ▁b ▁; ▁i ▁++ ▁) ▁{ ▁int ▁sum Of Digits ▁= ▁0 ▁, ▁k ▁= ▁i ▁; ▁while ▁( ▁k ▁> ▁0 ▁) ▁{ ▁sum Of Digits ▁+= ▁k ▁% ▁10 ▁; ▁k ▁/= ▁10 ▁; ▁} ▁if ▁( ▁sum Of Digits ▁<= ▁16 2 ▁) ▁pairs ▁. ▁push _ back ▁( ▁sum Of Digits ▁) ▁; ▁} ▁} ▁int ▁count Co Prime ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁vector ▁< ▁int ▁> ▁pairs ▁; ▁make Pairs ▁( ▁pairs ▁, ▁a ▁, ▁b ▁) ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁pairs ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁pairs ▁. ▁size ▁( ▁) ▁; ▁j ▁++ ▁) ▁if ▁( ▁__ g cd ▁( ▁pairs ▁[ ▁i ▁] ▁, ▁pairs ▁[ ▁j ▁] ▁) ▁== ▁1 ▁) ▁count ▁++ ▁; ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁= ▁12 ▁, ▁b ▁= ▁15 ▁; ▁c out ▁<< ▁count Co Prime ▁( ▁a ▁, ▁b ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁MAX ▁100 ▁NEW _ LINE ▁int ▁dp ▁[ ▁MAX ▁] ▁[ ▁MAX ▁] ▁; ▁int ▁count Rem ovals ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁i ▁, ▁int ▁j ▁, ▁int ▁k ▁) ▁{ ▁if ▁( ▁i ▁>= ▁j ▁) ▁return ▁0 ▁; ▁else ▁if ▁( ▁( ▁a ▁[ ▁j ▁] ▁- ▁a ▁[ ▁i ▁] ▁) ▁<= ▁k ▁) ▁return ▁0 ▁; ▁else ▁if ▁( ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁!= ▁-1 ▁) ▁return ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁else ▁if ▁( ▁( ▁a ▁[ ▁j ▁] ▁- ▁a ▁[ ▁i ▁] ▁) ▁> ▁k ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁1 ▁+ ▁min ▁( ▁count Rem ovals ▁( ▁a ▁, ▁i ▁+ ▁1 ▁, ▁j ▁, ▁k ▁) ▁, ▁count Rem ovals ▁( ▁a ▁, ▁i ▁, ▁j ▁- ▁1 ▁, ▁k ▁) ▁) ▁; ▁} ▁return ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁} ▁int ▁rem ovals ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁sort ▁( ▁a ▁, ▁a ▁+ ▁n ▁) ▁; ▁mem set ▁( ▁dp ▁, ▁-1 ▁, ▁sizeof ▁( ▁dp ▁) ▁) ▁; ▁if ▁( ▁n ▁== ▁1 ▁) ▁return ▁0 ▁; ▁else ▁return ▁count Rem ovals ▁( ▁a ▁, ▁0 ▁, ▁n ▁- ▁1 ▁, ▁k ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁4 ▁, ▁9 ▁, ▁10 ▁, ▁11 ▁, ▁12 ▁, ▁17 ▁, ▁20 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁int ▁k ▁= ▁4 ▁; ▁c out ▁<< ▁rem ovals ▁( ▁a ▁, ▁n ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁class ▁G F G ▁{ ▁public ▁: ▁int ▁find Step ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁1 ▁n ▁== ▁0 ▁) ▁return ▁1 ▁; ▁else ▁if ▁( ▁n ▁== ▁2 ▁) ▁return ▁2 ▁; ▁else ▁return ▁find Step ▁( ▁n ▁- ▁3 ▁) ▁+ ▁find Step ▁( ▁n ▁- ▁2 ▁) ▁+ ▁find Step ▁( ▁n ▁- ▁1 ▁) ▁; ▁} ▁} ▁; ▁int ▁main ▁( ▁) ▁{ ▁G F G ▁g ▁; ▁int ▁n ▁= ▁4 ▁; ▁c out ▁<< ▁g ▁. ▁find Step ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁deal n no y ▁( ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁if ▁( ▁m ▁== ▁0 ▁n ▁== ▁0 ▁) ▁return ▁1 ▁; ▁return ▁deal n no y ▁( ▁m ▁- ▁1 ▁, ▁n ▁) ▁+ ▁deal n no y ▁( ▁m ▁- ▁1 ▁, ▁n ▁- ▁1 ▁) ▁+ ▁deal n no y ▁( ▁m ▁, ▁n ▁- ▁1 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁3 ▁, ▁m ▁= ▁4 ▁; ▁c out ▁<< ▁deal n no y ▁( ▁n ▁, ▁m ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁# define ▁MAX ▁100 ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁all ones ▁( ▁string ▁s ▁, ▁int ▁n ▁) ▁{ ▁int ▁co ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁co ▁+= ▁( ▁s ▁[ ▁i ▁] ▁== ▁'1' ▁) ▁; ▁return ▁( ▁co ▁== ▁n ▁) ▁; ▁} ▁int ▁find length ▁( ▁int ▁arr ▁[ ▁] ▁, ▁string ▁s ▁, ▁int ▁n ▁, ▁int ▁ind ▁, ▁int ▁st ▁, ▁int ▁dp ▁[ ▁] ▁[ ▁3 ▁] ▁) ▁{ ▁if ▁( ▁ind ▁>= ▁n ▁) ▁return ▁0 ▁; ▁if ▁( ▁dp ▁[ ▁ind ▁] ▁[ ▁st ▁] ▁!= ▁-1 ▁) ▁return ▁dp ▁[ ▁ind ▁] ▁[ ▁st ▁] ▁; ▁if ▁( ▁st ▁== ▁0 ▁) ▁return ▁dp ▁[ ▁ind ▁] ▁[ ▁st ▁] ▁= ▁max ▁( ▁arr ▁[ ▁ind ▁] ▁+ ▁find length ▁( ▁arr ▁, ▁s ▁, ▁n ▁, ▁ind ▁+ ▁1 ▁, ▁1 ▁, ▁dp ▁) ▁, ▁find length ▁( ▁arr ▁, ▁s ▁, ▁n ▁, ▁ind ▁+ ▁1 ▁, ▁0 ▁, ▁dp ▁) ▁) ▁; ▁else ▁return ▁dp ▁[ ▁ind ▁] ▁[ ▁st ▁] ▁= ▁max ▁( ▁arr ▁[ ▁ind ▁] ▁+ ▁find length ▁( ▁arr ▁, ▁s ▁, ▁n ▁, ▁ind ▁+ ▁1 ▁, ▁1 ▁, ▁dp ▁) ▁, ▁0 ▁) ▁; ▁} ▁int ▁max Len ▁( ▁string ▁s ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁all ones ▁( ▁s ▁, ▁n ▁) ▁) ▁return ▁-1 ▁; ▁int ▁arr ▁[ ▁MAX ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁arr ▁[ ▁i ▁] ▁= ▁( ▁s ▁[ ▁i ▁] ▁== ▁'0' ▁? ▁1 ▁: ▁-1 ▁) ▁; ▁int ▁dp ▁[ ▁MAX ▁] ▁[ ▁3 ▁] ▁; ▁mem set ▁( ▁dp ▁, ▁-1 ▁, ▁sizeof ▁dp ▁) ▁; ▁return ▁find length ▁( ▁arr ▁, ▁s ▁, ▁n ▁, ▁0 ▁, ▁0 ▁, ▁dp ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁"11 0000 100 01" ▁; ▁int ▁n ▁= ▁11 ▁; ▁c out ▁<< ▁max Len ▁( ▁s ▁, ▁n ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# ▁define ▁R ▁4 ▁NEW _ LINE ▁# ▁define ▁C ▁3 ▁NEW _ LINE ▁bool ▁is Safe ▁( ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁return ▁( ▁x ▁< ▁R ▁&& ▁y ▁< ▁C ▁) ▁; ▁} ▁int ▁min Jump ▁( ▁int ▁height ▁[ ▁R ▁] ▁[ ▁C ▁] ▁, ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁if ▁( ▁x ▁== ▁R ▁- ▁1 ▁&& ▁y ▁== ▁C ▁- ▁1 ▁) ▁return ▁0 ▁; ▁int ▁diag ▁= ▁INT _ MAX ▁; ▁if ▁( ▁is Safe ▁( ▁x ▁+ ▁1 ▁, ▁y ▁+ ▁1 ▁) ▁) ▁diag ▁= ▁min Jump ▁( ▁height ▁, ▁x ▁+ ▁1 ▁, ▁y ▁+ ▁1 ▁) ▁+ ▁abs ▁( ▁height ▁[ ▁x ▁] ▁[ ▁y ▁] ▁- ▁height ▁[ ▁x ▁+ ▁1 ▁] ▁[ ▁y ▁+ ▁1 ▁] ▁) ▁; ▁int ▁down ▁= ▁INT _ MAX ▁; ▁if ▁( ▁is Safe ▁( ▁x ▁+ ▁1 ▁, ▁y ▁) ▁) ▁down ▁= ▁min Jump ▁( ▁height ▁, ▁x ▁+ ▁1 ▁, ▁y ▁) ▁+ ▁abs ▁( ▁height ▁[ ▁x ▁] ▁[ ▁y ▁] ▁- ▁height ▁[ ▁x ▁+ ▁1 ▁] ▁[ ▁y ▁] ▁) ▁; ▁int ▁right ▁= ▁INT _ MAX ▁; ▁if ▁( ▁is Safe ▁( ▁x ▁, ▁y ▁+ ▁1 ▁) ▁) ▁right ▁= ▁min Jump ▁( ▁height ▁, ▁x ▁, ▁y ▁+ ▁1 ▁) ▁+ ▁abs ▁( ▁height ▁[ ▁x ▁] ▁[ ▁y ▁] ▁- ▁height ▁[ ▁x ▁] ▁[ ▁y ▁+ ▁1 ▁] ▁) ▁; ▁return ▁min ▁( ▁{ ▁down ▁, ▁right ▁, ▁diag ▁} ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁height ▁[ ▁] ▁[ ▁C ▁] ▁= ▁{ ▁{ ▁5 ▁, ▁4 ▁, ▁2 ▁} ▁, ▁{ ▁9 ▁, ▁2 ▁, ▁1 ▁} ▁, ▁{ ▁2 ▁, ▁5 ▁, ▁9 ▁} ▁, ▁{ ▁1 ▁, ▁3 ▁, ▁11 ▁} ▁} ▁; ▁c out ▁<< ▁min Jump ▁( ▁height ▁, ▁0 ▁, ▁0 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁long ▁count W ays ▁( ▁int ▁n ▁) ▁{ ▁long ▁dp ▁[ ▁2 ▁] ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁dp ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁= ▁1 ▁; ▁dp ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁= ▁2 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁dp ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁= ▁dp ▁[ ▁0 ▁] ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁dp ▁[ ▁1 ▁] ▁[ ▁i ▁- ▁1 ▁] ▁; ▁dp ▁[ ▁1 ▁] ▁[ ▁i ▁] ▁= ▁dp ▁[ ▁0 ▁] ▁[ ▁i ▁- ▁1 ▁] ▁* ▁2 ▁+ ▁dp ▁[ ▁1 ▁] ▁[ ▁i ▁- ▁1 ▁] ▁; ▁} ▁return ▁dp ▁[ ▁0 ▁] ▁[ ▁n ▁] ▁+ ▁dp ▁[ ▁1 ▁] ▁[ ▁n ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁5 ▁; ▁c out ▁<< ▁" ▁Total ▁no ▁of ▁ways ▁with ▁n ▁= ▁" ▁<< ▁n ▁<< ▁" ▁are ▁: ▁" ▁<< ▁count W ays ▁( ▁n ▁) ▁<< ▁end l ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁count W ays To Jump ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁count _ jump ▁[ ▁n ▁] ▁; ▁mem set ▁( ▁count _ jump ▁, ▁0 ▁, ▁sizeof ▁( ▁count _ jump ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁2 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁>= ▁n ▁- ▁i ▁- ▁1 ▁) ▁count _ jump ▁[ ▁i ▁] ▁++ ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁- ▁1 ▁&& ▁j ▁<= ▁arr ▁[ ▁i ▁] ▁+ ▁i ▁; ▁j ▁++ ▁) ▁if ▁( ▁count _ jump ▁[ ▁j ▁] ▁!= ▁-1 ▁) ▁count _ jump ▁[ ▁i ▁] ▁+= ▁count _ jump ▁[ ▁j ▁] ▁; ▁if ▁( ▁count _ jump ▁[ ▁i ▁] ▁== ▁0 ▁) ▁count _ jump ▁[ ▁i ▁] ▁= ▁-1 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁count _ jump ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁5 ▁, ▁8 ▁, ▁9 ▁, ▁1 ▁, ▁0 ▁, ▁7 ▁, ▁6 ▁, ▁8 ▁, ▁9 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁count W ays To Jump ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁N ▁4 ▁NEW _ LINE ▁long ▁long ▁int ▁max Decimal Value ▁( ▁int ▁mat ▁[ ▁] ▁[ ▁N ▁] ▁, ▁int ▁i ▁, ▁int ▁j ▁, ▁int ▁p ▁) ▁{ ▁if ▁( ▁i ▁>= ▁N ▁j ▁>= ▁N ▁) ▁return ▁0 ▁; ▁int ▁result ▁= ▁max ▁( ▁max Decimal Value ▁( ▁mat ▁, ▁i ▁, ▁j ▁+ ▁1 ▁, ▁p ▁+ ▁1 ▁) ▁, ▁max Decimal Value ▁( ▁mat ▁, ▁i ▁+ ▁1 ▁, ▁j ▁, ▁p ▁+ ▁1 ▁) ▁) ▁; ▁if ▁( ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁== ▁1 ▁) ▁return ▁pow ▁( ▁2 ▁, ▁p ▁) ▁+ ▁result ▁; ▁else ▁return ▁result ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁mat ▁[ ▁] ▁[ ▁4 ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁} ▁, ▁{ ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁0 ▁} ▁, ▁{ ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁} ▁, ▁} ▁; ▁c out ▁<< ▁max Decimal Value ▁( ▁mat ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁N ▁4 ▁NEW _ LINE ▁long ▁long ▁int ▁Maximum Decimal Value ▁( ▁int ▁mat ▁[ ▁] ▁[ ▁N ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁dp ▁[ ▁n ▁] ▁[ ▁n ▁] ▁; ▁mem set ▁( ▁dp ▁, ▁0 ▁, ▁sizeof ▁( ▁dp ▁) ▁) ▁; ▁if ▁( ▁mat ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁== ▁1 ▁) ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁mat ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁== ▁1 ▁) ▁dp ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁= ▁dp ▁[ ▁0 ▁] ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁pow ▁( ▁2 ▁, ▁i ▁) ▁; ▁else ▁dp ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁= ▁dp ▁[ ▁0 ▁] ▁[ ▁i ▁- ▁1 ▁] ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁mat ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁== ▁1 ▁) ▁dp ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁0 ▁] ▁+ ▁pow ▁( ▁2 ▁, ▁i ▁) ▁; ▁else ▁dp ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁0 ▁] ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁== ▁1 ▁) ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁max ▁( ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁, ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁) ▁+ ▁pow ▁( ▁2 ▁, ▁i ▁+ ▁j ▁) ▁; ▁else ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁max ▁( ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁, ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁) ▁; ▁} ▁} ▁return ▁dp ▁[ ▁n ▁- ▁1 ▁] ▁[ ▁n ▁- ▁1 ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁mat ▁[ ▁] ▁[ ▁4 ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁} ▁, ▁{ ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁0 ▁} ▁, ▁{ ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁0 ▁,
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max Sum Pair With Difference LessThan K ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁sort ▁( ▁arr ▁, ▁arr ▁+ ▁N ▁) ▁; ▁int ▁dp ▁[ ▁N ▁] ▁; ▁dp ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁; ▁if ▁( ▁arr ▁[ ▁i ▁] ▁- ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁< ▁K ▁) ▁{ ▁if ▁( ▁i ▁>= ▁2 ▁) ▁dp ▁[ ▁i ▁] ▁= ▁max ▁( ▁dp ▁[ ▁i ▁] ▁, ▁dp ▁[ ▁i ▁- ▁2 ▁] ▁+ ▁arr ▁[ ▁i ▁] ▁+ ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁) ▁; ▁else ▁dp ▁[ ▁i ▁] ▁= ▁max ▁( ▁dp ▁[ ▁i ▁] ▁, ▁arr ▁[ ▁i ▁] ▁+ ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁) ▁; ▁} ▁} ▁return ▁dp ▁[ ▁N ▁- ▁1 ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁5 ▁, ▁10 ▁, ▁15 ▁, ▁17 ▁, ▁12 ▁, ▁9 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁int ▁K ▁= ▁4 ▁; ▁c out ▁<< ▁max Sum Pair With Difference LessThan K ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max Sum IS ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁i ▁, ▁j ▁, ▁max ▁= ▁0 ▁; ▁int ▁ms is ▁[ ▁n ▁] ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁ms is ▁[ ▁i ▁] ▁= ▁arr ▁[ ▁i ▁] ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁i ▁; ▁j ▁++ ▁) ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁arr ▁[ ▁j ▁] ▁&& ▁ms is ▁[ ▁i ▁] ▁< ▁ms is ▁[ ▁j ▁] ▁+ ▁arr ▁[ ▁i ▁] ▁) ▁ms is ▁[ ▁i ▁] ▁= ▁ms is ▁[ ▁j ▁] ▁+ ▁arr ▁[ ▁i ▁] ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁max ▁< ▁ms is ▁[ ▁i ▁] ▁) ▁max ▁= ▁ms is ▁[ ▁i ▁] ▁; ▁return ▁max ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁101 ▁, ▁2 ▁, ▁3 ▁, ▁100 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁Sum ▁of ▁maximum ▁sum ▁increasing ▁" ▁" ▁sub sequence ▁is ▁" ▁<< ▁max Sum IS ▁( ▁arr ▁, ▁n ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁Matrix Chain Order ▁( ▁int ▁p ▁[ ▁] ▁, ▁int ▁i ▁, ▁int ▁j ▁) ▁{ ▁if ▁( ▁i ▁== ▁j ▁) ▁return ▁0 ▁; ▁int ▁k ▁; ▁int ▁min ▁= ▁INT _ MAX ▁; ▁int ▁count ▁; ▁for ▁( ▁k ▁= ▁i ▁; ▁k ▁< ▁j ▁; ▁k ▁++ ▁) ▁{ ▁count ▁= ▁Matrix Chain Order ▁( ▁p ▁, ▁i ▁, ▁k ▁) ▁+ ▁Matrix Chain Order ▁( ▁p ▁, ▁k ▁+ ▁1 ▁, ▁j ▁) ▁+ ▁p ▁[ ▁i ▁- ▁1 ▁] ▁* ▁p ▁[ ▁k ▁] ▁* ▁p ▁[ ▁j ▁] ▁; ▁if ▁( ▁count ▁< ▁min ▁) ▁min ▁= ▁count ▁; ▁} ▁return ▁min ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁Minimum ▁number ▁of ▁multiplication s ▁is ▁" ▁<< ▁Matrix Chain Order ▁( ▁arr ▁, ▁1 ▁, ▁n ▁- ▁1 ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁encode String ▁( ▁string ▁str ▁) ▁{ ▁string ▁res ▁= ▁" ▁" ▁; ▁int ▁small ▁[ ▁26 ▁] ▁= ▁{ ▁0 ▁} ▁, ▁capital ▁[ ▁26 ▁] ▁= ▁{ ▁0 ▁} ▁, ▁num ▁[ ▁10 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁int ▁n ▁= ▁str ▁. ▁size ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁str ▁[ ▁i ▁] ▁>= ▁'0' ▁&& ▁str ▁[ ▁i ▁] ▁<= ▁'9' ▁) ▁{ ▁num ▁[ ▁str ▁[ ▁i ▁] ▁- ▁48 ▁] ▁= ▁i ▁; ▁} ▁else ▁if ▁( ▁str ▁[ ▁i ▁] ▁>= ▁' ▁a ▁' ▁&& ▁str ▁[ ▁i ▁] ▁<= ▁' ▁z ▁' ▁) ▁{ ▁small ▁[ ▁str ▁[ ▁i ▁] ▁- ▁97 ▁] ▁= ▁i ▁; ▁} ▁else ▁if ▁( ▁str ▁[ ▁i ▁] ▁>= ▁' ▁A ▁' ▁&& ▁str ▁[ ▁i ▁] ▁<= ▁' ▁Z ▁' ▁) ▁{ ▁capital ▁[ ▁str ▁[ ▁i ▁] ▁- ▁65 ▁] ▁= ▁i ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁str ▁[ ▁i ▁] ▁>= ▁' ▁a ▁' ▁&& ▁str ▁[ ▁i ▁] ▁<= ▁' ▁z ▁' ▁) ▁&& ▁small ▁[ ▁str ▁[ ▁i ▁] ▁- ▁97 ▁] ▁== ▁i ▁) ▁{ ▁int ▁occ ▁= ▁str ▁[ ▁i ▁] ▁- ▁96 ▁; ▁while ▁( ▁occ ▁-- ▁) ▁{ ▁res ▁+= ▁str ▁[ ▁i ▁] ▁; ▁} ▁} ▁else ▁if ▁( ▁( ▁str ▁[ ▁i ▁] ▁>= ▁' ▁A ▁' ▁&& ▁str ▁[ ▁i ▁] ▁<= ▁' ▁Z ▁' ▁) ▁&& ▁capital ▁[ ▁str ▁[ ▁i ▁] ▁- ▁65 ▁] ▁== ▁i ▁) ▁{ ▁int ▁occ ▁= ▁str ▁[ ▁i ▁] ▁- ▁64 ▁; ▁while ▁( ▁occ ▁-- ▁) ▁{ ▁res ▁+= ▁str ▁[ ▁i ▁] ▁; ▁} ▁} ▁else ▁if ▁( ▁( ▁str ▁[ ▁i ▁] ▁>= ▁'0' ▁&& ▁str ▁[ ▁i ▁] ▁<= ▁'9' ▁) ▁&& ▁num ▁[ ▁str ▁[ ▁i ▁] ▁- ▁48 ▁] ▁== ▁i ▁) ▁{ ▁int ▁occ ▁= ▁str ▁[ ▁i ▁] ▁- ▁48 ▁; ▁while ▁( ▁occ ▁-- ▁) ▁{ ▁res ▁+= ▁str ▁[ ▁i ▁] ▁; ▁} ▁} ▁else ▁{ ▁res ▁+= ▁str ▁[ ▁i ▁] ▁; ▁} ▁} ▁c out ▁<< ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁create Grid ▁( ▁char ▁grid ▁[ ▁] ▁[ ▁1001 ▁] ▁, ▁bool ▁is 1 ▁, ▁int ▁N ▁, ▁int ▁M ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁M ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁is 1 ▁) ▁{ ▁grid ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁'0' ▁; ▁is 1 ▁= ▁false ▁; ▁} ▁else ▁{ ▁grid ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁'1' ▁; ▁is 1 ▁= ▁true ▁; ▁} ▁} ▁if ▁( ▁M ▁% ▁2 ▁== ▁0 ▁) ▁is 1 ▁= ▁! ▁is 1 ▁; ▁} ▁} ▁bool ▁test Grid ▁( ▁char ▁test Grid ▁[ ▁] ▁[ ▁1001 ▁] ▁, ▁char ▁Grid ▁[ ▁] ▁[ ▁1001 ▁] ▁, ▁int ▁N ▁, ▁int ▁M ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁M ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁Grid ▁[ ▁i ▁] ▁[ ▁j ▁] ▁!= ▁' ▁* ▁' ▁) ▁{ ▁if ▁( ▁Grid ▁[ ▁i ▁] ▁[ ▁j ▁] ▁!= ▁test Grid ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁{ ▁return ▁false ▁; ▁} ▁} ▁} ▁} ▁return ▁true ▁; ▁} ▁void ▁print Grid ▁( ▁char ▁grid ▁[ ▁] ▁[ ▁1001 ▁] ▁, ▁int ▁N ▁, ▁int ▁M ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁M ▁; ▁j ▁++ ▁) ▁{ ▁c out ▁<< ▁grid ▁[ ▁i ▁] ▁[ ▁j ▁] ▁<< ▁" ▁" ▁; ▁} ▁c out ▁<< ▁end l ▁; ▁} ▁} ▁void ▁find Possible Grid ▁( ▁int ▁N ▁, ▁int ▁M ▁, ▁char ▁grid ▁[ ▁] ▁[ ▁1001 ▁] ▁) ▁{ ▁char ▁grid Test 1 ▁[ ▁N ▁] ▁[ ▁1001 ▁] ▁, ▁grid Test 2 ▁[ ▁N ▁] ▁[ ▁1001 ▁] ▁; ▁create Grid ▁( ▁grid Test 1 ▁, ▁true ▁, ▁N ▁, ▁M ▁) ▁; ▁create Grid ▁( ▁grid Test 2 ▁, ▁false ▁, ▁N ▁, ▁M ▁) ▁; ▁if ▁( ▁test Grid ▁( ▁grid Test 1 ▁, ▁grid ▁, ▁N ▁, ▁M ▁) ▁) ▁{ ▁c out ▁<< ▁" ▁Yes ▁STRNEWLINE ▁" ▁; ▁print Grid
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Min M oves ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁if ▁( ▁sum ▁% ▁N ▁!= ▁0 ▁) ▁return ▁-1 ▁; ▁int ▁avg ▁= ▁sum ▁/ ▁N ▁; ▁int ▁total ▁= ▁0 ▁; ▁int ▁need Count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁need Count ▁+= ▁( ▁arr ▁[ ▁i ▁] ▁- ▁avg ▁) ▁; ▁total ▁= ▁max ▁( ▁max ▁( ▁abs ▁( ▁need Count ▁) ▁, ▁arr ▁[ ▁i ▁] ▁- ▁avg ▁) ▁, ▁total ▁) ▁; ▁} ▁return ▁total ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁0 ▁, ▁5 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁find Min M oves ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁getZ arr ▁( ▁string ▁str ▁, ▁int ▁Z ▁[ ▁] ▁) ▁{ ▁int ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁int ▁k ▁; ▁int ▁L ▁= ▁0 ▁; ▁int ▁R ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁i ▁> ▁R ▁) ▁{ ▁L ▁= ▁R ▁= ▁i ▁; ▁while ▁( ▁R ▁< ▁n ▁&& ▁str ▁[ ▁R ▁- ▁L ▁] ▁== ▁str ▁[ ▁R ▁] ▁) ▁{ ▁R ▁++ ▁; ▁} ▁Z ▁[ ▁i ▁] ▁= ▁R ▁- ▁L ▁; ▁R ▁-- ▁; ▁} ▁else ▁{ ▁k ▁= ▁i ▁- ▁L ▁; ▁if ▁( ▁Z ▁[ ▁k ▁] ▁< ▁R ▁- ▁i ▁+ ▁1 ▁) ▁{ ▁Z ▁[ ▁i ▁] ▁= ▁Z ▁[ ▁k ▁] ▁; ▁} ▁else ▁{ ▁L ▁= ▁i ▁; ▁while ▁( ▁R ▁< ▁n ▁&& ▁str ▁[ ▁R ▁- ▁L ▁] ▁== ▁str ▁[ ▁R ▁] ▁) ▁{ ▁R ▁++ ▁; ▁} ▁Z ▁[ ▁i ▁] ▁= ▁R ▁- ▁L ▁; ▁R ▁-- ▁; ▁} ▁} ▁} ▁} ▁string ▁good Str ▁( ▁string ▁str ▁, ▁string ▁word ▁) ▁{ ▁string ▁concat ▁= ▁word ▁+ ▁" ▁$ ▁" ▁+ ▁str ▁; ▁int ▁l ▁= ▁concat ▁. ▁length ▁( ▁) ▁; ▁int ▁Z ▁[ ▁l ▁] ▁; ▁getZ arr ▁( ▁concat ▁, ▁Z ▁) ▁; ▁string ▁res ▁; ▁int ▁p Size ▁= ▁word ▁. ▁size ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁l ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁i ▁+ ▁p Size ▁< ▁l ▁- ▁1 ▁&& ▁Z ▁[ ▁i ▁+ ▁p Size ▁+ ▁1 ▁] ▁== ▁p Size ▁) ▁{ ▁i ▁+= ▁p Size ▁- ▁1 ▁; ▁} ▁else ▁if ▁( ▁i ▁< ▁str ▁. ▁length ▁( ▁) ▁) ▁{ ▁res ▁+= ▁str ▁[ ▁i ▁] ▁; ▁} ▁} ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁Z ▁- ▁km algorithm km isk mk mk m help ful km ink m search ing ▁" ▁; ▁string ▁word ▁= ▁" ▁km ▁" ▁; ▁c out ▁<< ▁good Str ▁( ▁str ▁, ▁word ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁sum Of Sub array Prod ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁int ▁res ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁int ▁incr ▁= ▁arr ▁[ ▁i ▁] ▁* ▁( ▁1 ▁+ ▁res ▁) ▁; ▁ans ▁+= ▁incr ▁; ▁res ▁= ▁incr ▁; ▁} ▁c out ▁<< ▁( ▁ans ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁sum Of Sub array Prod ▁( ▁arr ▁, ▁N ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁phi ▁( ▁int ▁n ▁) ▁{ ▁int ▁result ▁= ▁1 ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁< ▁n ▁; ▁p ▁++ ▁) ▁{ ▁if ▁( ▁__ g cd ▁( ▁p ▁, ▁n ▁) ▁== ▁1 ▁) ▁{ ▁result ▁++ ▁; ▁} ▁} ▁return ▁result ▁; ▁} ▁bool ▁same E uler T ot ient ▁( ▁int ▁n ▁) ▁{ ▁return ▁phi ▁( ▁n ▁) ▁== ▁phi ▁( ▁2 ▁* ▁n ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁13 ▁; ▁if ▁( ▁same E uler T ot ient ▁( ▁N ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁print Odd Factor Number ▁( ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁n ▁; ▁i ▁<= ▁m ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁i ▁> ▁0 ▁) ▁&& ▁( ▁( ▁i ▁& ▁( ▁i ▁- ▁1 ▁) ▁) ▁!= ▁0 ▁) ▁) ▁c out ▁<< ▁i ▁<< ▁" ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁2 ▁, ▁M ▁= ▁10 ▁; ▁print Odd Factor Number ▁( ▁N ▁, ▁M ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print Series ▁( ▁int ▁n ▁) ▁{ ▁int ▁k ▁= ▁2 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁c out ▁<< ▁( ▁k ▁* ▁( ▁2 ▁* ▁k ▁- ▁1 ▁) ▁) ▁<< ▁" ▁" ▁; ▁k ▁+= ▁2 ▁; ▁} ▁c out ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁12 ▁; ▁print Series ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print S in X ▁( ▁int ▁N ▁) ▁{ ▁int ▁X i ▁= ▁0 ▁; ▁int ▁num ▁= ▁1 ▁; ▁while ▁( ▁N ▁-- ▁) ▁{ ▁c out ▁<< ▁" ▁X ▁" ▁<< ▁num ▁<< ▁" ▁= ▁" ▁<< ▁X i ▁; ▁c out ▁<< ▁" ▁sin ▁( ▁X ▁" ▁<< ▁num ▁<< ▁" ▁) ▁= ▁" ▁<< ▁fixed ▁; ▁c out ▁<< ▁set precision ▁( ▁6 ▁) ▁<< ▁sin ▁( ▁X i ▁) ▁<< ▁end l ▁; ▁num ▁+= ▁1 ▁; ▁X i ▁+= ▁7 10 ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁5 ▁; ▁print S in X ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁" ▁bits ▁/ ▁std c ▁+ ▁+ ▁. ▁h ▁" ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁sum Between Zero ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁i ▁= ▁0 ▁; ▁vector ▁< ▁int ▁> ▁A ▁; ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁i ▁++ ▁; ▁break ▁; ▁} ▁} ▁for ▁( ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁A ▁. ▁push _ back ▁( ▁sum ▁) ▁; ▁sum ▁= ▁0 ▁; ▁} ▁else ▁{ ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁A ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁c out ▁<< ▁A ▁[ ▁i ▁] ▁<< ▁' ▁' ▁; ▁} ▁if ▁( ▁A ▁. ▁size ▁( ▁) ▁== ▁0 ▁) ▁c out ▁<< ▁" ▁- ▁1" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁0 ▁, ▁3 ▁, ▁4 ▁, ▁0 ▁, ▁4 ▁, ▁4 ▁, ▁0 ▁, ▁2 ▁, ▁1 ▁, ▁4 ▁, ▁0 ▁, ▁3 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁sum Between Zero ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Characters ▁( ▁vector ▁< ▁string ▁> ▁& ▁strings ▁, ▁string ▁chars ▁) ▁{ ▁int ▁res ▁= ▁0 ▁; ▁unordered _ map ▁< ▁char ▁, ▁int ▁> ▁freq ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁chars ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁freq ▁[ ▁chars ▁[ ▁i ▁] ▁] ▁+= ▁1 ▁; ▁for ▁( ▁auto ▁st ▁: ▁strings ▁) ▁{ ▁bool ▁flag ▁= ▁true ▁; ▁for ▁( ▁auto ▁c ▁: ▁st ▁) ▁{ ▁if ▁( ▁! ▁freq ▁) ▁{ ▁flag ▁= ▁false ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁flag ▁) ▁res ▁+= ▁st ▁. ▁length ▁( ▁) ▁; ▁} ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁string ▁> ▁strings ▁= ▁{ ▁" ▁hi ▁" ▁, ▁" ▁data ▁" ▁, ▁" ▁g eek s forge ek s ▁" ▁} ▁; ▁string ▁chars ▁= ▁" ▁ti ad ha e ▁" ▁; ▁c out ▁<< ▁count Characters ▁( ▁strings ▁, ▁chars ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find Numbers ▁( ▁int ▁n ▁) ▁{ ▁int ▁i ▁= ▁1 ▁; ▁while ▁( ▁i ▁<= ▁n ▁) ▁{ ▁c out ▁<< ▁( ▁3 ▁* ▁i ▁* ▁( ▁i ▁- ▁1 ▁) ▁+ ▁1 ▁) ▁<< ▁" ▁" ▁; ▁i ▁++ ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁4 ▁; ▁find Numbers ▁( ▁n ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁getEnd ing Index ▁( ▁string ▁str ▁, ▁int ▁n ▁, ▁int ▁i ▁) ▁{ ▁i ▁++ ▁; ▁while ▁( ▁i ▁< ▁n ▁) ▁{ ▁char ▁curr ▁= ▁str ▁[ ▁i ▁] ▁; ▁char ▁prev ▁= ▁str ▁[ ▁i ▁- ▁1 ▁] ▁; ▁if ▁( ▁( ▁curr ▁== ▁' ▁a ▁' ▁&& ▁prev ▁== ▁' ▁z ▁' ▁) ▁|| ▁( ▁curr ▁- ▁prev ▁== ▁1 ▁) ▁) ▁i ▁++ ▁; ▁else ▁break ▁; ▁} ▁return ▁i ▁- ▁1 ▁; ▁} ▁int ▁largest Sub Str ▁( ▁string ▁str ▁, ▁int ▁n ▁) ▁{ ▁int ▁len ▁= ▁0 ▁; ▁int ▁i ▁= ▁0 ▁; ▁while ▁( ▁i ▁< ▁n ▁) ▁{ ▁int ▁end ▁= ▁getEnd ing Index ▁( ▁str ▁, ▁n ▁, ▁i ▁) ▁; ▁len ▁= ▁max ▁( ▁end ▁- ▁i ▁+ ▁1 ▁, ▁len ▁) ▁; ▁i ▁= ▁end ▁+ ▁1 ▁; ▁} ▁return ▁len ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁abc abcdef abc ▁" ▁; ▁int ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁c out ▁<< ▁( ▁largest Sub Str ▁( ▁str ▁, ▁n ▁) ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁string ▁smallest Freq ▁( ▁string ▁S 1 ▁, ▁string ▁S 2 ▁) ▁{ ▁map ▁< ▁string ▁, ▁int ▁> ▁ban ned ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁S 2 ▁. ▁length ▁( ▁) ▁; ▁++ ▁i ▁) ▁{ ▁string ▁s ▁= ▁" ▁" ▁; ▁while ▁( ▁i ▁< ▁S 2 ▁. ▁length ▁( ▁) ▁&& ▁S 2 ▁[ ▁i ▁] ▁!= ▁' ▁' ▁) ▁s ▁+= ▁S 2 ▁[ ▁i ▁++ ▁] ▁; ▁ban ned ▁[ ▁s ▁] ▁++ ▁; ▁} ▁map ▁< ▁string ▁, ▁int ▁> ▁result ▁; ▁string ▁ans ▁; ▁int ▁freq ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁S 1 ▁. ▁length ▁( ▁) ▁; ▁++ ▁i ▁) ▁{ ▁string ▁s ▁= ▁" ▁" ▁; ▁while ▁( ▁i ▁< ▁S 1 ▁. ▁length ▁( ▁) ▁&& ▁S 1 ▁[ ▁i ▁] ▁!= ▁' ▁' ▁) ▁s ▁+= ▁S 1 ▁[ ▁i ▁++ ▁] ▁; ▁if ▁( ▁ban ned ▁[ ▁s ▁] ▁== ▁0 ▁) ▁{ ▁result ▁[ ▁s ▁] ▁++ ▁; ▁if ▁( ▁result ▁[ ▁s ▁] ▁> ▁freq ▁|| ▁( ▁result ▁[ ▁s ▁] ▁== ▁freq ▁&& ▁s ▁< ▁ans ▁) ▁) ▁{ ▁ans ▁= ▁s ▁; ▁freq ▁= ▁result ▁[ ▁s ▁] ▁; ▁} ▁} ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁S 1 ▁= ▁" ▁g eek s ▁for ▁g eek s ▁is ▁best ▁place ▁to ▁learn ▁" ▁; ▁string ▁S 2 ▁= ▁" ▁bad ▁place ▁" ▁; ▁c out ▁<< ▁smallest Freq ▁( ▁S 1 ▁, ▁S 2 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁is Sub string ▁( ▁string ▁s 1 ▁, ▁string ▁s 2 ▁) ▁{ ▁int ▁M ▁= ▁s 1 ▁. ▁length ▁( ▁) ▁; ▁int ▁N ▁= ▁s 2 ▁. ▁length ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁N ▁- ▁M ▁; ▁i ▁++ ▁) ▁{ ▁int ▁j ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁M ▁; ▁j ▁++ ▁) ▁if ▁( ▁s 2 ▁[ ▁i ▁+ ▁j ▁] ▁!= ▁s 1 ▁[ ▁j ▁] ▁) ▁break ▁; ▁if ▁( ▁j ▁== ▁M ▁) ▁return ▁i ▁; ▁} ▁return ▁-1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s 1 ▁= ▁" ▁for ▁" ▁; ▁string ▁s 2 ▁= ▁" ▁g eek s forge ek s ▁" ▁; ▁int ▁res ▁= ▁is Sub string ▁( ▁s 1 ▁, ▁s 2 ▁) ▁; ▁if ▁( ▁res ▁== ▁-1 ▁) ▁c out ▁<< ▁" ▁Not ▁present ▁" ▁; ▁else ▁c out ▁<< ▁" ▁P resent ▁at ▁index ▁" ▁<< ▁res ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁pattern Count ▁( ▁string ▁str ▁) ▁{ ▁char ▁last ▁= ▁str ▁[ ▁0 ▁] ▁; ▁int ▁i ▁= ▁1 ▁, ▁counter ▁= ▁0 ▁; ▁while ▁( ▁i ▁< ▁str ▁. ▁size ▁( ▁) ▁) ▁{ ▁if ▁( ▁str ▁[ ▁i ▁] ▁== ▁'0' ▁&& ▁last ▁== ▁'1' ▁) ▁{ ▁while ▁( ▁str ▁[ ▁i ▁] ▁== ▁'0' ▁) ▁i ▁++ ▁; ▁if ▁( ▁str ▁[ ▁i ▁] ▁== ▁'1' ▁) ▁counter ▁++ ▁; ▁} ▁last ▁= ▁str ▁[ ▁i ▁] ▁; ▁i ▁++ ▁; ▁} ▁return ▁counter ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁"100 1 ab 010 abc 0100 1" ▁; ▁c out ▁<< ▁pattern Count ▁( ▁str ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max i ▁= ▁0 ▁; ▁string ▁ans 1 ▁= ▁" ▁" ▁; ▁void ▁calculate ▁( ▁string ▁ans ▁) ▁{ ▁int ▁dp ▁[ ▁26 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁ans ▁. ▁length ▁( ▁) ▁; ▁++ ▁i ▁) ▁{ ▁dp ▁[ ▁ans ▁[ ▁i ▁] ▁- ▁' ▁A ▁' ▁] ▁++ ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁26 ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁dp ▁[ ▁i ▁] ▁% ▁2 ▁== ▁1 ▁) ▁{ ▁return ▁; ▁} ▁} ▁if ▁( ▁max i ▁< ▁ans ▁. ▁length ▁( ▁) ▁) ▁{ ▁max i ▁= ▁ans ▁. ▁length ▁( ▁) ▁; ▁ans 1 ▁= ▁ans ▁; ▁} ▁} ▁void ▁longest String ▁( ▁vector ▁< ▁string ▁> ▁arr ▁, ▁int ▁index ▁, ▁string ▁str ▁) ▁{ ▁if ▁( ▁index ▁== ▁arr ▁. ▁size ▁( ▁) ▁) ▁{ ▁return ▁; ▁} ▁longest String ▁( ▁arr ▁, ▁index ▁+ ▁1 ▁, ▁str ▁) ▁; ▁str ▁+= ▁arr ▁[ ▁index ▁] ▁; ▁calculate ▁( ▁str ▁) ▁; ▁longest String ▁( ▁arr ▁, ▁index ▁+ ▁1 ▁, ▁str ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁string ▁> ▁A ▁= ▁{ ▁" ▁AB AB ▁" ▁, ▁" ▁AB F ▁" ▁, ▁" ▁C DA ▁" ▁, ▁" ▁AD ▁" ▁, ▁" ▁C CC ▁" ▁} ▁; ▁longest String ▁( ▁A ▁, ▁0 ▁, ▁" ▁" ▁) ▁; ▁c out ▁<< ▁ans 1 ▁<< ▁" ▁" ▁<< ▁ans 1 ▁. ▁length ▁( ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find Sub sequence ▁( ▁string ▁str ▁) ▁{ ▁int ▁n ▁= ▁str ▁. ▁size ▁( ▁) ▁; ▁char ▁res ▁[ ▁n ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁res ▁[ ▁i ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁pos ▁= ▁0 ▁; ▁pos ▁<= ▁9 ▁; ▁pos ▁++ ▁) ▁{ ▁char ▁lst 1 ▁= ▁'0' ▁; ▁bool ▁flag ▁= ▁1 ▁; ▁char ▁lst 2 ▁= ▁pos ▁+ ▁'0' ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁lst 2 ▁<= ▁str ▁[ ▁i ▁] ▁) ▁{ ▁res ▁[ ▁i ▁] ▁= ▁'2' ▁; ▁lst 2 ▁= ▁str ▁[ ▁i ▁] ▁; ▁} ▁else ▁if ▁( ▁lst 1 ▁<= ▁str ▁[ ▁i ▁] ▁) ▁{ ▁res ▁[ ▁i ▁] ▁= ▁'1' ▁; ▁lst 1 ▁= ▁str ▁[ ▁i ▁] ▁; ▁} ▁else ▁flag ▁= ▁0 ▁; ▁} ▁if ▁( ▁lst 1 ▁> ▁pos ▁+ ▁'0' ▁) ▁flag ▁= ▁0 ▁; ▁if ▁( ▁flag ▁) ▁{ ▁string ▁S 1 ▁= ▁" ▁" ▁; ▁string ▁S 2 ▁= ▁" ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁res ▁[ ▁i ▁] ▁== ▁'1' ▁) ▁{ ▁S 1 ▁+= ▁str ▁[ ▁i ▁] ▁; ▁} ▁else ▁{ ▁S 2 ▁+= ▁str ▁[ ▁i ▁] ▁; ▁} ▁} ▁c out ▁<< ▁S 1 ▁<< ▁' ▁' ▁<< ▁S 2 ▁<< ▁end l ▁; ▁return ▁; ▁} ▁} ▁c out ▁<< ▁" ▁- ▁1" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁S ▁= ▁"0 404 255 24 64 4" ▁; ▁find Sub sequence ▁( ▁S ▁) ▁; ▁S ▁= ▁"1234 56789 " ▁; ▁find Sub sequence ▁( ▁S ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁getString ▁( ▁int ▁curl en ▁, ▁string ▁& ▁ans ▁, ▁string ▁& ▁s ▁, ▁int ▁N ▁, ▁int ▁& ▁K ▁, ▁vector ▁< ▁int ▁> ▁& ▁prod ▁) ▁{ ▁if ▁( ▁curl en ▁== ▁N ▁) ▁{ ▁K ▁-- ▁; ▁if ▁( ▁K ▁== ▁0 ▁) ▁ans ▁= ▁s ▁; ▁return ▁; ▁} ▁char ▁ch ▁; ▁int ▁ok ▁, ▁t ▁, ▁i ▁; ▁for ▁( ▁ch ▁= ▁'2' ▁; ▁ch ▁<= ▁'9' ▁; ▁ch ▁++ ▁) ▁{ ▁s ▁+= ▁ch ▁; ▁ok ▁= ▁1 ▁; ▁t ▁= ▁1 ▁; ▁for ▁( ▁i ▁= ▁curl en ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁t ▁*= ▁s ▁[ ▁i ▁] ▁- ▁48 ▁; ▁if ▁( ▁prod ▁[ ▁t ▁] ▁) ▁ok ▁= ▁0 ▁; ▁prod ▁[ ▁t ▁] ▁++ ▁; ▁} ▁if ▁( ▁ok ▁) ▁getString ▁( ▁curl en ▁+ ▁1 ▁, ▁ans ▁, ▁s ▁, ▁N ▁, ▁K ▁, ▁prod ▁) ▁; ▁t ▁= ▁1 ▁; ▁for ▁( ▁i ▁= ▁curl en ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁t ▁*= ▁s ▁[ ▁i ▁] ▁- ▁48 ▁; ▁prod ▁[ ▁t ▁] ▁-- ▁; ▁} ▁s ▁. ▁erase ▁( ▁s ▁. ▁length ▁( ▁) ▁- ▁1 ▁) ▁; ▁} ▁} ▁string ▁k th Valid String ▁( ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁if ▁( ▁N ▁> ▁10 ▁) ▁{ ▁return ▁" ▁- ▁1" ▁; ▁} ▁if ▁( ▁N ▁== ▁1 ▁) ▁{ ▁if ▁( ▁K ▁> ▁10 ▁) ▁{ ▁return ▁" ▁- ▁1" ▁; ▁} ▁string ▁s ▁= ▁" ▁" ▁; ▁K ▁-- ▁; ▁s ▁+= ▁( ▁K ▁+ ▁'0' ▁) ▁; ▁return ▁s ▁; ▁} ▁string ▁ans ▁= ▁" ▁- ▁1" ▁; ▁string ▁s ▁= ▁" ▁" ▁; ▁vector ▁< ▁int ▁> ▁prod ▁( ▁1000 5 ▁, ▁0 ▁) ▁; ▁getString ▁( ▁0 ▁, ▁ans ▁, ▁s ▁, ▁N ▁, ▁K ▁, ▁prod ▁) ▁; ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁3 ▁, ▁K ▁= ▁4 ▁; ▁c out ▁<< ▁k th Valid String ▁( ▁N ▁, ▁K ▁) ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁string ▁checkIf Possible ▁( ▁int ▁N ▁, ▁string ▁arr ▁[ ▁] ▁, ▁string ▁T ▁) ▁{ ▁int ▁freq S ▁[ ▁256 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁int ▁freq T ▁[ ▁256 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁char ▁ch ▁: ▁T ▁) ▁{ ▁freq T ▁[ ▁ch ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁char ▁ch ▁: ▁arr ▁[ ▁i ▁] ▁) ▁{ ▁freq S ▁[ ▁ch ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁256 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁freq T ▁[ ▁i ▁] ▁== ▁0 ▁&& ▁freq S ▁[ ▁i ▁] ▁!= ▁0 ▁) ▁{ ▁return ▁" ▁No ▁" ▁; ▁} ▁else ▁if ▁( ▁freq S ▁[ ▁i ▁] ▁== ▁0 ▁&& ▁freq T ▁[ ▁i ▁] ▁!= ▁0 ▁) ▁{ ▁return ▁" ▁No ▁" ▁; ▁} ▁else ▁if ▁( ▁freq T ▁[ ▁i ▁] ▁!= ▁0 ▁&& ▁freq S ▁[ ▁i ▁] ▁!= ▁( ▁freq T ▁[ ▁i ▁] ▁* ▁N ▁) ▁) ▁{ ▁return ▁" ▁No ▁" ▁; ▁} ▁} ▁return ▁" ▁Yes ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁arr ▁[ ▁] ▁= ▁{ ▁" ▁abc ▁" ▁, ▁" ▁ab b ▁" ▁, ▁" ▁acc ▁" ▁} ▁; ▁string ▁T ▁= ▁" ▁abc ▁" ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁checkIf Possible ▁( ▁N ▁, ▁arr ▁, ▁T ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁groups Of On es ▁( ▁string ▁S ▁, ▁int ▁N ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁stack ▁< ▁int ▁> ▁st ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁S ▁[ ▁i ▁] ▁== ▁'1' ▁) ▁st ▁. ▁push ▁( ▁1 ▁) ▁; ▁else ▁{ ▁if ▁( ▁! ▁st ▁. ▁empty ▁( ▁) ▁) ▁{ ▁count ▁++ ▁; ▁while ▁( ▁! ▁st ▁. ▁empty ▁( ▁) ▁) ▁{ ▁st ▁. ▁pop ▁( ▁) ▁; ▁} ▁} ▁} ▁} ▁if ▁( ▁! ▁st ▁. ▁empty ▁( ▁) ▁) ▁count ▁++ ▁; ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁S ▁= ▁"100 11 01 11" ▁; ▁int ▁N ▁= ▁S ▁. ▁length ▁( ▁) ▁; ▁c out ▁<< ▁groups Of On es ▁( ▁S ▁, ▁N ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find Minimum Cost ▁( ▁string ▁s ▁, ▁int ▁N ▁) ▁{ ▁int ▁count _1 ▁= ▁0 ▁, ▁count _0 ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁[ ▁i ▁] ▁== ▁'1' ▁) ▁count _1 ▁++ ▁; ▁else ▁count _0 ▁++ ▁; ▁} ▁int ▁k ▁= ▁abs ▁( ▁count _0 ▁- ▁count _1 ▁) ▁; ▁if ▁( ▁count _1 ▁== ▁N ▁count _0 ▁== ▁N ▁) ▁c out ▁<< ▁-1 ▁<< ▁end l ▁; ▁else ▁c out ▁<< ▁k ▁/ ▁2 ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁S ▁= ▁"11 01 10" ▁; ▁int ▁N ▁= ▁S ▁. ▁length ▁( ▁) ▁; ▁find Minimum Cost ▁( ▁S ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁min Length ▁( ▁string ▁S ▁) ▁{ ▁stack ▁< ▁char ▁> ▁st ▁; ▁for ▁( ▁auto ▁ch ▁: ▁S ▁) ▁{ ▁if ▁( ▁st ▁. ▁empty ▁( ▁) ▁) ▁st ▁. ▁push ▁( ▁ch ▁) ▁; ▁else ▁{ ▁char ▁top ▁= ▁st ▁. ▁top ▁( ▁) ▁; ▁if ▁( ▁abs ▁( ▁ch ▁- ▁top ▁) ▁== ▁1 ▁) ▁st ▁. ▁pop ▁( ▁) ▁; ▁else ▁{ ▁st ▁. ▁push ▁( ▁ch ▁) ▁; ▁} ▁} ▁} ▁return ▁st ▁. ▁size ▁( ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁S ▁= ▁"12 21 3" ▁; ▁c out ▁<< ▁min Length ▁( ▁S ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁minimum Del et ions ▁( ▁string ▁s ▁) ▁{ ▁int ▁right _0 ▁= ▁count ▁( ▁s ▁. ▁begin ▁( ▁) ▁, ▁s ▁. ▁end ▁( ▁) ▁, ▁'0' ▁) ▁; ▁int ▁left _1 ▁= ▁0 ▁; ▁int ▁n ▁= ▁s ▁. ▁size ▁( ▁) ▁; ▁int ▁res ▁= ▁INT _ MAX ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁[ ▁i ▁] ▁== ▁'0' ▁) ▁{ ▁right _0 ▁-= ▁1 ▁; ▁} ▁else ▁{ ▁left _1 ▁+= ▁1 ▁; ▁} ▁res ▁= ▁min ▁( ▁res ▁, ▁right _0 ▁+ ▁left _1 ▁) ▁; ▁} ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁"00 11 01" ▁; ▁int ▁count ▁= ▁minimum Del et ions ▁( ▁s ▁) ▁; ▁c out ▁<< ▁count ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁cnt Bal anced Parent hesis ▁( ▁string ▁s ▁, ▁int ▁N ▁) ▁{ ▁int ▁cnt Pairs ▁= ▁0 ▁; ▁int ▁cnt Cur ly ▁= ▁0 ▁; ▁int ▁cnt S ml ▁= ▁0 ▁; ▁int ▁cnt S qr ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁[ ▁i ▁] ▁== ▁' ▁{ ▁' ▁) ▁{ ▁cnt Cur ly ▁++ ▁; ▁} ▁else ▁if ▁( ▁s ▁[ ▁i ▁] ▁== ▁' ▁( ▁' ▁) ▁{ ▁cnt S ml ▁++ ▁; ▁} ▁else ▁if ▁( ▁s ▁[ ▁i ▁] ▁== ▁' ▁[ ▁' ▁) ▁{ ▁cnt S qr ▁++ ▁; ▁} ▁else ▁if ▁( ▁s ▁[ ▁i ▁] ▁== ▁' ▁} ▁' ▁&& ▁cnt Cur ly ▁> ▁0 ▁) ▁{ ▁cnt Cur ly ▁-- ▁; ▁cnt Pairs ▁++ ▁; ▁} ▁else ▁if ▁( ▁s ▁[ ▁i ▁] ▁== ▁' ▁) ▁' ▁&& ▁cnt S ml ▁> ▁0 ▁) ▁{ ▁cnt S ml ▁-- ▁; ▁cnt Pairs ▁++ ▁; ▁} ▁else ▁if ▁( ▁s ▁[ ▁i ▁] ▁== ▁' ▁] ▁' ▁&& ▁cnt S qr ▁> ▁0 ▁) ▁{ ▁cnt S qr ▁-- ▁; ▁cnt Pairs ▁++ ▁; ▁} ▁} ▁c out ▁<< ▁cnt Pairs ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁" ▁{ ▁( ▁} ▁) ▁" ▁; ▁int ▁N ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁cnt Bal anced Parent hesis ▁( ▁s ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁canBe Bal anced ▁( ▁string ▁sequence ▁) ▁{ ▁if ▁( ▁sequence ▁. ▁size ▁( ▁) ▁% ▁2 ▁) ▁return ▁false ▁; ▁stack ▁< ▁char ▁> ▁stack _ ▁, ▁stack 2_ ▁; ▁int ▁count Open ▁= ▁0 ▁, ▁count Closed ▁= ▁0 ▁; ▁int ▁count Symbol ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁sequence ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁sequence ▁[ ▁i ▁] ▁== ▁' ▁) ▁' ▁) ▁{ ▁count Closed ▁++ ▁; ▁if ▁( ▁stack _ ▁. ▁empty ▁( ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁else ▁{ ▁stack _ ▁. ▁pop ▁( ▁) ▁; ▁} ▁} ▁else ▁{ ▁if ▁( ▁sequence ▁[ ▁i ▁] ▁== ▁' ▁$ ▁' ▁) ▁{ ▁count Symbol ▁++ ▁; ▁} ▁else ▁{ ▁count Open ▁++ ▁; ▁} ▁stack _ ▁. ▁push ▁( ▁sequence ▁[ ▁i ▁] ▁) ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁sequence ▁. ▁size ▁( ▁) ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁sequence ▁[ ▁i ▁] ▁== ▁' ▁( ▁' ▁) ▁{ ▁if ▁( ▁stack 2_ ▁. ▁empty ▁( ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁else ▁{ ▁stack 2_ ▁. ▁pop ▁( ▁) ▁; ▁} ▁} ▁else ▁{ ▁stack 2_ ▁. ▁push ▁( ▁sequence ▁[ ▁i ▁] ▁) ▁; ▁} ▁} ▁int ▁extra ▁= ▁abs ▁( ▁count Closed ▁- ▁count Open ▁) ▁; ▁if ▁( ▁count Symbol ▁< ▁extra ▁) ▁{ ▁return ▁false ▁; ▁} ▁else ▁{ ▁count Symbol ▁-= ▁extra ▁; ▁if ▁( ▁count Symbol ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁return ▁true ▁; ▁} ▁} ▁return ▁false ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁S ▁= ▁" ▁( ▁) ▁( ▁$ ▁" ▁; ▁if ▁( ▁canBe Bal anced ▁( ▁S ▁) ▁) ▁{ ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁" ▁No ▁" ▁; ▁} ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁max Diff Freq ▁( ▁vector ▁< ▁pair ▁< ▁int ▁, ▁int ▁> ▁> ▁queries ▁, ▁string ▁S ▁) ▁{ ▁int ▁N ▁= ▁S ▁. ▁size ▁( ▁) ▁; ▁int ▁Q ▁= ▁queries ▁. ▁size ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁Q ▁; ▁++ ▁i ▁) ▁{ ▁int ▁l ▁= ▁queries ▁[ ▁i ▁] ▁. ▁first ▁- ▁1 ▁; ▁int ▁r ▁= ▁queries ▁[ ▁i ▁] ▁. ▁second ▁- ▁1 ▁; ▁int ▁freq ▁[ ▁26 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁int ▁j ▁= ▁l ▁; ▁j ▁<= ▁r ▁; ▁j ▁++ ▁) ▁{ ▁freq ▁[ ▁S ▁[ ▁j ▁] ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁} ▁int ▁mx ▁= ▁0 ▁; ▁int ▁mn ▁= ▁9 9999 999 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁26 ▁; ▁j ▁++ ▁) ▁{ ▁mx ▁= ▁max ▁( ▁mx ▁, ▁freq ▁[ ▁j ▁] ▁) ▁; ▁if ▁( ▁freq ▁[ ▁j ▁] ▁) ▁mn ▁= ▁min ▁( ▁mn ▁, ▁freq ▁[ ▁j ▁] ▁) ▁; ▁} ▁c out ▁<< ▁mx ▁- ▁mn ▁<< ▁end l ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁S ▁= ▁" ▁ab a ab ac ▁" ▁; ▁vector ▁< ▁pair ▁< ▁int ▁, ▁int ▁> ▁> ▁queries ▁{ ▁{ ▁2 ▁, ▁6 ▁} ▁, ▁{ ▁1 ▁, ▁7 ▁} ▁} ▁; ▁max Diff Freq ▁( ▁queries ▁, ▁S ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁isEqual Strings ▁( ▁string ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁M ▁= ▁arr ▁[ ▁0 ▁] ▁. ▁length ▁( ▁) ▁; ▁int ▁cnt Freq ▁[ ▁256 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁M ▁; ▁j ▁++ ▁) ▁{ ▁cnt Freq ▁[ ▁arr ▁[ ▁i ▁] ▁[ ▁j ▁] ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁256 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁cnt Freq ▁[ ▁i ▁] ▁% ▁N ▁!= ▁0 ▁) ▁{ ▁return ▁false ▁; ▁} ▁} ▁return ▁true ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁arr ▁[ ▁] ▁= ▁{ ▁" ▁a ab ▁" ▁, ▁" ▁bb c ▁" ▁, ▁" ▁c ca ▁" ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁if ▁( ▁isEqual Strings ▁( ▁arr ▁, ▁N ▁) ▁) ▁{ ▁c out ▁<< ▁" ▁YES ▁" ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁" ▁NO ▁" ▁; ▁} ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find Freq ▁( ▁string ▁str ▁, ▁int ▁N ▁) ▁{ ▁int ▁freq ▁[ ▁256 ▁] ▁; ▁mem set ▁( ▁freq ▁, ▁0 ▁, ▁sizeof ▁( ▁freq ▁) ▁) ▁; ▁int ▁max ▁= ▁0 ▁; ▁char ▁char Max ▁= ▁'0' ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁char ▁ch ▁= ▁str ▁[ ▁i ▁] ▁; ▁freq ▁[ ▁ch ▁] ▁++ ▁; ▁if ▁( ▁freq ▁[ ▁ch ▁] ▁>= ▁max ▁) ▁{ ▁max ▁= ▁freq ▁[ ▁ch ▁] ▁; ▁char Max ▁= ▁ch ▁; ▁} ▁c out ▁<< ▁char Max ▁<< ▁" ▁- ▁> ▁" ▁<< ▁max ▁<< ▁end l ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁ab bc ▁" ▁; ▁int ▁N ▁= ▁str ▁. ▁size ▁( ▁) ▁; ▁find Freq ▁( ▁str ▁, ▁N ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Of Sub string With Only On es ▁( ▁string ▁s ▁) ▁{ ▁int ▁res ▁= ▁0 ▁, ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁count ▁= ▁s ▁[ ▁i ▁] ▁== ▁'1' ▁? ▁count ▁+ ▁1 ▁: ▁0 ▁; ▁res ▁= ▁( ▁res ▁+ ▁count ▁) ▁; ▁} ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁"01 101 11" ▁; ▁c out ▁<< ▁count Of Sub string With Only On es ▁( ▁s ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁int ▁N ▁= ▁1 e 5 ▁+ ▁5 ▁; ▁vector ▁< ▁int ▁> ▁prefix ▁( ▁N ▁, ▁0 ▁) ▁; ▁vector ▁< ▁int ▁> ▁sum ▁( ▁N ▁, ▁0 ▁) ▁; ▁bool ▁is Special ▁( ▁char ▁c ▁, ▁vector ▁< ▁char ▁> ▁& ▁special ▁) ▁{ ▁for ▁( ▁auto ▁& ▁i ▁: ▁special ▁) ▁if ▁( ▁i ▁== ▁c ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁double ▁count Ratio ▁( ▁string ▁& ▁s ▁, ▁vector ▁< ▁char ▁> ▁& ▁special ▁) ▁{ ▁int ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁prefix ▁[ ▁i ▁] ▁= ▁int ▁( ▁is Special ▁( ▁s ▁[ ▁i ▁] ▁, ▁special ▁) ▁) ▁; ▁if ▁( ▁i ▁> ▁0 ▁) ▁prefix ▁[ ▁i ▁] ▁+= ▁prefix ▁[ ▁i ▁- ▁1 ▁] ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁[ ▁i ▁] ▁= ▁prefix ▁[ ▁i ▁] ▁; ▁if ▁( ▁i ▁> ▁0 ▁) ▁sum ▁[ ▁i ▁] ▁+= ▁sum ▁[ ▁i ▁- ▁1 ▁] ▁; ▁} ▁double ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁count ▁= ▁sum ▁[ ▁n ▁- ▁1 ▁] ▁- ▁( ▁i ▁> ▁1 ▁? ▁sum ▁[ ▁i ▁- ▁2 ▁] ▁: ▁0 ▁) ▁; ▁count ▁-= ▁( ▁i ▁< ▁n ▁? ▁sum ▁[ ▁n ▁- ▁i ▁- ▁1 ▁] ▁: ▁0 ▁) ▁; ▁ans ▁+= ▁double ▁( ▁count ▁) ▁/ ▁double ▁( ▁i ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁" ▁abcd ▁" ▁; ▁vector ▁< ▁char ▁> ▁special ▁= ▁{ ▁' ▁b ▁' ▁, ▁' ▁c ▁' ▁} ▁; ▁double ▁ans ▁= ▁count Ratio ▁( ▁s ▁, ▁special ▁) ▁; ▁c out ▁<< ▁fixed ▁<< ▁set precision ▁( ▁6 ▁) ▁<< ▁ans ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁isP al indrome ▁( ▁string ▁str ▁) ▁{ ▁int ▁l ▁= ▁0 ▁; ▁int ▁h ▁= ▁str ▁. ▁size ▁( ▁) ▁- ▁1 ▁; ▁while ▁( ▁h ▁> ▁l ▁) ▁{ ▁if ▁( ▁str ▁[ ▁l ▁++ ▁] ▁!= ▁str ▁[ ▁h ▁-- ▁] ▁) ▁{ ▁return ▁false ▁; ▁} ▁} ▁return ▁true ▁; ▁} ▁string ▁make Odd String ▁( ▁string ▁str ▁) ▁{ ▁string ▁odd ▁= ▁" ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁str ▁. ▁size ▁( ▁) ▁; ▁i ▁+= ▁2 ▁) ▁{ ▁odd ▁+= ▁str ▁[ ▁i ▁] ▁; ▁} ▁return ▁odd ▁; ▁} ▁void ▁check Odd ly Pal indrome ▁( ▁string ▁str ▁) ▁{ ▁string ▁odd ▁= ▁make Odd String ▁( ▁str ▁) ▁; ▁if ▁( ▁isP al indrome ▁( ▁odd ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁<< ▁end l ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁dd w f ef w de ▁" ▁; ▁check Odd ly Pal indrome ▁( ▁str ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁" ▁bits ▁/ ▁std c ▁+ ▁+ ▁. ▁h ▁" ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁check Suffix ▁( ▁int ▁A ▁, ▁int ▁B ▁) ▁{ ▁string ▁s 1 ▁= ▁to _ string ▁( ▁A ▁) ▁; ▁string ▁s 2 ▁= ▁to _ string ▁( ▁B ▁) ▁; ▁int ▁n 1 ▁= ▁s 1 ▁. ▁length ▁( ▁) ▁; ▁int ▁n 2 ▁= ▁s 2 ▁. ▁length ▁( ▁) ▁; ▁if ▁( ▁n 1 ▁< ▁n 2 ▁) ▁{ ▁return ▁false ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n 2 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s 1 ▁[ ▁n 1 ▁- ▁i ▁- ▁1 ▁] ▁!= ▁s 2 ▁[ ▁n 2 ▁- ▁i ▁- ▁1 ▁] ▁) ▁{ ▁return ▁false ▁; ▁} ▁} ▁return ▁true ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁= ▁12345 ▁, ▁B ▁= ▁45 ▁; ▁bool ▁result ▁= ▁check Suffix ▁( ▁A ▁, ▁B ▁) ▁; ▁if ▁( ▁result ▁) ▁{ ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁" ▁No ▁" ▁; ▁} ▁return ▁0 ▁; ▁}
▁# include ▁" ▁bits ▁/ ▁std c ▁+ ▁+ ▁. ▁h ▁" ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is Prime ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁<= ▁1 ▁) ▁return ▁false ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁sqrt ▁( ▁n ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁return ▁false ▁; ▁} ▁return ▁true ▁; ▁} ▁bool ▁isP ossible Sum ▁( ▁int ▁N ▁) ▁{ ▁if ▁( ▁is Prime ▁( ▁N ▁) ▁&& ▁is Prime ▁( ▁N ▁- ▁2 ▁) ▁) ▁{ ▁return ▁true ▁; ▁} ▁else ▁{ ▁return ▁false ▁; ▁} ▁} ▁bool ▁check Sem ip r ime ▁( ▁int ▁num ▁) ▁{ ▁int ▁cnt ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁cnt ▁< ▁2 ▁&& ▁i ▁* ▁i ▁<= ▁num ▁; ▁++ ▁i ▁) ▁{ ▁while ▁( ▁num ▁% ▁i ▁== ▁0 ▁) ▁{ ▁num ▁/= ▁i ▁, ▁++ ▁cnt ▁; ▁} ▁} ▁if ▁( ▁num ▁> ▁1 ▁) ▁{ ▁++ ▁cnt ▁; ▁} ▁return ▁cnt ▁== ▁2 ▁; ▁} ▁void ▁make C y pher String ▁( ▁int ▁N ▁) ▁{ ▁string ▁semi Prime ▁= ▁" ▁" ▁; ▁string ▁sum Of Prime ▁= ▁" ▁" ▁; ▁string ▁str ▁= ▁to _ string ▁( ▁N ▁) ▁; ▁if ▁( ▁check Sem ip r ime ▁( ▁N ▁) ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁str ▁[ ▁i ▁] ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁& ▁1 ▁) ▁{ ▁semi Prime ▁+= ▁str ▁[ ▁i ▁] ▁; ▁} ▁else ▁{ ▁semi Prime ▁+= ▁char ▁( ▁str ▁[ ▁i ▁] ▁- ▁'0' ▁+ ▁65 ▁) ▁; ▁} ▁} ▁} ▁if ▁( ▁isP ossible Sum ▁( ▁N ▁) ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁str ▁[ ▁i ▁] ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁& ▁1 ▁) ▁{ ▁sum Of Prime ▁+= ▁char ▁( ▁str ▁[ ▁i ▁] ▁- ▁'0' ▁+ ▁65 ▁) ▁; ▁} ▁else ▁{ ▁sum Of Prime ▁+= ▁str ▁[ ▁i ▁] ▁; ▁} ▁} ▁} ▁if ▁( ▁semi Prime ▁+ ▁sum Of Prime ▁== ▁" ▁" ▁) ▁{ ▁c out ▁<< ▁" ▁- ▁1" ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁semi Prime ▁+ ▁sum Of Prime ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁101 12 43 ▁; ▁make C y pher String ▁( ▁N ▁) ▁; ▁return
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁k th _ string ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁2 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁k ▁<= ▁( ▁n ▁- ▁i ▁- ▁1 ▁) ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁j ▁== ▁i ▁or ▁j ▁== ▁n ▁- ▁k ▁) ▁c out ▁<< ▁' ▁Y ▁' ▁; ▁else ▁c out ▁<< ▁' ▁X ▁' ▁; ▁} ▁break ▁; ▁} ▁k ▁-= ▁( ▁n ▁- ▁i ▁- ▁1 ▁) ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁5 ▁, ▁k ▁= ▁7 ▁; ▁k th _ string ▁( ▁n ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁string ▁remove Duplicates ▁( ▁string ▁str ▁) ▁{ ▁int ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁string ▁res ▁= ▁" ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁j ▁; ▁for ▁( ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁if ▁( ▁str ▁[ ▁i ▁] ▁== ▁str ▁[ ▁j ▁] ▁) ▁break ▁; ▁if ▁( ▁j ▁== ▁n ▁) ▁res ▁= ▁res ▁+ ▁str ▁[ ▁i ▁] ▁; ▁} ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁g eek s forge ek s ▁" ▁; ▁c out ▁<< ▁remove Duplicates ▁( ▁str ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁value ▁( ▁char ▁x ▁) ▁{ ▁return ▁( ▁int ▁) ▁( ▁x ▁- ▁' ▁a ▁' ▁) ▁; ▁} ▁string ▁maximum Product ▁( ▁string ▁str ▁, ▁int ▁n ▁) ▁{ ▁string ▁answer ▁= ▁" ▁" ▁, ▁curr ▁= ▁" ▁" ▁; ▁long ▁long ▁max Product ▁= ▁0 ▁, ▁product ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁product ▁*= ▁1 LL ▁* ▁value ▁( ▁str ▁[ ▁i ▁] ▁) ▁; ▁curr ▁+= ▁str ▁[ ▁i ▁] ▁; ▁if ▁( ▁product ▁>= ▁max Product ▁) ▁{ ▁max Product ▁= ▁product ▁; ▁answer ▁= ▁curr ▁; ▁} ▁if ▁( ▁product ▁== ▁0 ▁) ▁{ ▁product ▁= ▁1 ▁; ▁curr ▁= ▁" ▁" ▁; ▁} ▁} ▁return ▁answer ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁sd tf ak dh da hd zz ▁" ▁; ▁int ▁n ▁= ▁str ▁. ▁size ▁( ▁) ▁; ▁c out ▁<< ▁maximum Product ▁( ▁str ▁, ▁n ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁k th String ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁total ▁= ▁0 ▁; ▁int ▁i ▁= ▁1 ▁; ▁while ▁( ▁total ▁< ▁k ▁) ▁{ ▁total ▁= ▁total ▁+ ▁n ▁- ▁i ▁; ▁i ▁++ ▁; ▁} ▁int ▁first _ y _ position ▁= ▁i ▁- ▁1 ▁; ▁int ▁second _ y _ position ▁= ▁k ▁- ▁( ▁total ▁- ▁n ▁+ ▁first _ y _ position ▁) ▁; ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁< ▁first _ y _ position ▁; ▁j ▁++ ▁) ▁c out ▁<< ▁" ▁x ▁" ▁; ▁c out ▁<< ▁" ▁y ▁" ▁; ▁int ▁j ▁= ▁first _ y _ position ▁+ ▁1 ▁; ▁while ▁( ▁second _ y _ position ▁> ▁1 ▁) ▁{ ▁c out ▁<< ▁" ▁x ▁" ▁; ▁second _ y _ position ▁-- ▁; ▁j ▁++ ▁; ▁} ▁c out ▁<< ▁" ▁y ▁" ▁; ▁while ▁( ▁j ▁< ▁n ▁) ▁{ ▁c out ▁<< ▁" ▁x ▁" ▁; ▁j ▁++ ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁5 ▁; ▁int ▁k ▁= ▁7 ▁; ▁k th String ▁( ▁n ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁X or Ascii ▁( ▁string ▁str ▁, ▁int ▁len ▁) ▁{ ▁int ▁ans ▁= ▁int ▁( ▁str ▁[ ▁0 ▁] ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁len ▁; ▁i ▁++ ▁) ▁{ ▁ans ▁= ▁( ▁ans ▁^ ▁( ▁int ▁( ▁str ▁[ ▁i ▁] ▁) ▁) ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁g eek s forge ek s ▁" ▁; ▁int ▁len ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁c out ▁<< ▁X or Ascii ▁( ▁str ▁, ▁len ▁) ▁<< ▁end l ▁; ▁str ▁= ▁" ▁G f G ▁" ▁; ▁len ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁c out ▁<< ▁X or Ascii ▁( ▁str ▁, ▁len ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁product At K th Level ▁( ▁string ▁tree ▁, ▁int ▁k ▁, ▁int ▁& ▁i ▁, ▁int ▁level ▁) ▁{ ▁if ▁( ▁tree ▁[ ▁i ▁++ ▁] ▁== ▁' ▁( ▁' ▁) ▁{ ▁if ▁( ▁tree ▁[ ▁i ▁] ▁== ▁' ▁) ▁' ▁) ▁return ▁1 ▁; ▁int ▁product ▁= ▁1 ▁; ▁if ▁( ▁level ▁== ▁k ▁) ▁product ▁= ▁tree ▁[ ▁i ▁] ▁- ▁'0' ▁; ▁int ▁le ftp ro duct ▁= ▁product At K th Level ▁( ▁tree ▁, ▁k ▁, ▁++ ▁i ▁, ▁level ▁+ ▁1 ▁) ▁; ▁int ▁right product ▁= ▁product At K th Level ▁( ▁tree ▁, ▁k ▁, ▁++ ▁i ▁, ▁level ▁+ ▁1 ▁) ▁; ▁++ ▁i ▁; ▁return ▁product ▁* ▁le ftp ro duct ▁* ▁right product ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁tree ▁= ▁" ▁( ▁0 (5 (6 ▁( ▁) ▁( ▁) ▁) ▁( ▁4 ▁( ▁) ▁" ▁" ▁( ▁9 ▁( ▁) ▁( ▁) ▁) ▁) ▁) ▁( ▁7 (1 ▁( ▁) ▁( ▁) ▁) ▁( ▁3 ▁( ▁) ▁( ▁) ▁) ▁) ▁) ▁" ▁; ▁int ▁k ▁= ▁2 ▁; ▁int ▁i ▁= ▁0 ▁; ▁c out ▁<< ▁product At K th Level ▁( ▁tree ▁, ▁k ▁, ▁i ▁, ▁0 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁string ▁CHAR S ▁= ▁" ▁q w erty ui op asdf gh j kl z xc v bn m ▁" ▁; ▁const ▁int ▁MAX ▁= ▁26 ▁; ▁string ▁getString ▁( ▁string ▁str ▁, ▁int ▁n ▁) ▁{ ▁unordered _ map ▁< ▁char ▁, ▁char ▁> ▁u Map ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁MAX ▁; ▁i ▁++ ▁) ▁{ ▁u Map ▁[ ▁CHAR S ▁[ ▁i ▁] ▁] ▁= ▁CHAR S ▁[ ▁( ▁i ▁+ ▁1 ▁) ▁% ▁MAX ▁] ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁str ▁[ ▁i ▁] ▁= ▁u Map ▁[ ▁str ▁[ ▁i ▁] ▁] ▁; ▁} ▁return ▁str ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁g eek s ▁" ▁; ▁int ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁c out ▁<< ▁getString ▁( ▁str ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁long ▁MOD ▁= ▁100 000000 7 ▁; ▁long ▁count Strings ▁( ▁long ▁N ▁) ▁{ ▁long ▁dp ▁[ ▁N ▁+ ▁1 ▁] ▁[ ▁3 ▁] ▁; ▁mem set ▁( ▁dp ▁, ▁0 ▁, ▁sizeof ▁( ▁dp ▁) ▁) ▁; ▁dp ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁dp ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁= ▁1 ▁; ▁dp ▁[ ▁1 ▁] ▁[ ▁2 ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁= ▁( ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁0 ▁] ▁+ ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁1 ▁] ▁+ ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁2 ▁] ▁) ▁% ▁MOD ▁; ▁dp ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁0 ▁] ▁% ▁MOD ▁; ▁dp ▁[ ▁i ▁] ▁[ ▁2 ▁] ▁= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁1 ▁] ▁% ▁MOD ▁; ▁} ▁long ▁ans ▁= ▁( ▁dp ▁[ ▁N ▁] ▁[ ▁0 ▁] ▁+ ▁dp ▁[ ▁N ▁] ▁[ ▁1 ▁] ▁+ ▁dp ▁[ ▁N ▁] ▁[ ▁2 ▁] ▁) ▁% ▁MOD ▁; ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁long ▁N ▁= ▁3 ▁; ▁c out ▁<< ▁count Strings ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁string ▁max Number ▁( ▁string ▁str ▁, ▁int ▁n ▁) ▁{ ▁int ▁freq ▁[ ▁2 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁str ▁[ ▁i ▁] ▁== ▁' ▁z ▁' ▁) ▁{ ▁freq ▁[ ▁0 ▁] ▁++ ▁; ▁} ▁else ▁if ▁( ▁str ▁[ ▁i ▁] ▁== ▁' ▁n ▁' ▁) ▁{ ▁freq ▁[ ▁1 ▁] ▁++ ▁; ▁} ▁} ▁string ▁num ▁= ▁" ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁freq ▁[ ▁1 ▁] ▁; ▁i ▁++ ▁) ▁num ▁+= ▁'1' ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁freq ▁[ ▁0 ▁] ▁; ▁i ▁++ ▁) ▁num ▁+= ▁'0' ▁; ▁return ▁num ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁ro en en z oo e ▁" ▁; ▁int ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁c out ▁<< ▁max Number ▁( ▁str ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁main ▁( ▁) ▁{ ▁string ▁String ▁= ▁" ▁{ ▁[ ▁( ▁) ▁] ▁} ▁[ ▁] ▁" ▁; ▁vector ▁< ▁char ▁> ▁lst 1 ▁= ▁{ ▁' ▁{ ▁' ▁, ▁' ▁( ▁' ▁, ▁' ▁[ ▁' ▁} ▁; ▁vector ▁< ▁char ▁> ▁lst 2 ▁= ▁{ ▁' ▁} ▁' ▁, ▁' ▁) ▁' ▁, ▁' ▁] ▁' ▁} ▁; ▁vector ▁< ▁char ▁> ▁lst ▁; ▁int ▁k ▁; ▁map ▁< ▁char ▁, ▁char ▁> ▁Dict ▁; ▁Dict ▁. ▁insert ▁( ▁pair ▁< ▁int ▁, ▁int ▁> ▁( ▁' ▁) ▁' ▁, ▁' ▁( ▁' ▁) ▁) ▁; ▁Dict ▁. ▁insert ▁( ▁pair ▁< ▁int ▁, ▁int ▁> ▁( ▁' ▁} ▁' ▁, ▁' ▁{ ▁' ▁) ▁) ▁; ▁Dict ▁. ▁insert ▁( ▁pair ▁< ▁int ▁, ▁int ▁> ▁( ▁' ▁] ▁' ▁, ▁' ▁[ ▁' ▁) ▁) ▁; ▁int ▁a ▁= ▁0 ▁, ▁b ▁= ▁0 ▁, ▁c ▁= ▁0 ▁; ▁if ▁( ▁count ▁( ▁lst 2 ▁. ▁begin ▁( ▁) ▁, ▁lst 2 ▁. ▁end ▁( ▁) ▁, ▁String ▁[ ▁0 ▁] ▁) ▁) ▁{ ▁c out ▁<< ▁1 ▁<< ▁end l ▁; ▁} ▁else ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁String ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁count ▁( ▁lst 1 ▁. ▁begin ▁( ▁) ▁, ▁lst 1 ▁. ▁end ▁( ▁) ▁, ▁String ▁[ ▁i ▁] ▁) ▁) ▁{ ▁lst ▁. ▁push _ back ▁( ▁String ▁[ ▁i ▁] ▁) ▁; ▁k ▁= ▁i ▁+ ▁2 ▁; ▁} ▁else ▁{ ▁if ▁( ▁lst ▁. ▁size ▁( ▁) ▁== ▁0 ▁&& ▁( ▁count ▁( ▁lst 2 ▁. ▁begin ▁( ▁) ▁, ▁lst 2 ▁. ▁end ▁( ▁) ▁, ▁String ▁[ ▁i ▁] ▁) ▁) ▁) ▁{ ▁c out ▁<< ▁( ▁i ▁+ ▁1 ▁) ▁<< ▁end l ▁; ▁c ▁= ▁1 ▁; ▁break ▁; ▁} ▁else ▁{ ▁if ▁( ▁Dict ▁[ ▁String ▁[ ▁i ▁] ▁] ▁== ▁lst ▁[ ▁lst ▁. ▁size ▁( ▁) ▁- ▁1 ▁] ▁) ▁{ ▁lst ▁. ▁pop _ back ▁( ▁) ▁; ▁} ▁else ▁{ ▁break ▁; ▁c out ▁<< ▁( ▁i ▁+ ▁1 ▁) ▁<< ▁end l ▁; ▁a ▁= ▁1 ▁; ▁} ▁} ▁} ▁} ▁if ▁( ▁lst ▁. ▁size ▁( ▁) ▁== ▁0 ▁&& ▁c ▁== ▁0 ▁) ▁{ ▁c out
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁# define ▁MAX ▁26 ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁string ▁encrypt Str ▁( ▁string ▁str ▁, ▁int ▁n ▁, ▁int ▁x ▁) ▁{ ▁x ▁= ▁x ▁% ▁MAX ▁; ▁int ▁freq ▁[ ▁MAX ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁freq ▁[ ▁str ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁freq ▁[ ▁str ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁] ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁int ▁pos ▁= ▁( ▁str ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁+ ▁x ▁) ▁% ▁MAX ▁; ▁str ▁[ ▁i ▁] ▁= ▁( ▁char ▁) ▁( ▁pos ▁+ ▁' ▁a ▁' ▁) ▁; ▁} ▁else ▁{ ▁int ▁pos ▁= ▁( ▁str ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁- ▁x ▁) ▁; ▁if ▁( ▁pos ▁< ▁0 ▁) ▁{ ▁pos ▁+= ▁MAX ▁; ▁} ▁str ▁[ ▁i ▁] ▁= ▁( ▁char ▁) ▁( ▁pos ▁+ ▁' ▁a ▁' ▁) ▁; ▁} ▁} ▁return ▁str ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁" ▁abc da ▁" ▁; ▁int ▁n ▁= ▁s ▁. ▁size ▁( ▁) ▁; ▁int ▁x ▁= ▁3 ▁; ▁c out ▁<< ▁encrypt Str ▁( ▁s ▁, ▁n ▁, ▁x ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Occurrence ▁( ▁string ▁s ▁, ▁int ▁position ▁) ▁{ ▁int ▁alpha ▁[ ▁26 ▁] ▁= ▁{ ▁0 ▁} ▁, ▁b ▁[ ▁s ▁. ▁size ▁( ▁) ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁b ▁[ ▁i ▁] ▁= ▁alpha ▁[ ▁( ▁int ▁) ▁s ▁[ ▁i ▁] ▁- ▁97 ▁] ▁; ▁alpha ▁[ ▁( ▁int ▁) ▁s ▁[ ▁i ▁] ▁- ▁97 ▁] ▁++ ▁; ▁} ▁return ▁b ▁[ ▁position ▁- ▁1 ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁" ▁ab ab ab ab ab ▁" ▁; ▁int ▁p ▁= ▁9 ▁; ▁c out ▁<< ▁count Occurrence ▁( ▁s ▁, ▁p ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁# include ▁< time . h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁isP ossible ▁( ▁string ▁str ▁) ▁{ ▁unordered _ map ▁< ▁char ▁, ▁int ▁> ▁freq ▁; ▁int ▁max _ freq ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁( ▁str ▁. ▁length ▁( ▁) ▁) ▁; ▁j ▁++ ▁) ▁{ ▁freq ▁[ ▁str ▁[ ▁j ▁] ▁] ▁++ ▁; ▁if ▁( ▁freq ▁[ ▁str ▁[ ▁j ▁] ▁] ▁> ▁max _ freq ▁) ▁max _ freq ▁= ▁freq ▁[ ▁str ▁[ ▁j ▁] ▁] ▁; ▁} ▁if ▁( ▁max _ freq ▁<= ▁( ▁str ▁. ▁length ▁( ▁) ▁- ▁max _ freq ▁+ ▁1 ▁) ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁g eek s forge ek s ▁" ▁; ▁if ▁( ▁isP ossible ▁( ▁str ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print Un common ▁( ▁string ▁str 1 ▁, ▁string ▁str 2 ▁) ▁{ ▁int ▁a 1 ▁= ▁0 ▁, ▁a 2 ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁str 1 ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁int ▁ch ▁= ▁int ▁( ▁str 1 ▁[ ▁i ▁] ▁) ▁- ▁' ▁a ▁' ▁; ▁a 1 ▁= ▁a 1 ▁| ▁( ▁1 ▁<< ▁ch ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁str 2 ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁int ▁ch ▁= ▁int ▁( ▁str 2 ▁[ ▁i ▁] ▁) ▁- ▁' ▁a ▁' ▁; ▁a 2 ▁= ▁a 2 ▁| ▁( ▁1 ▁<< ▁ch ▁) ▁; ▁} ▁int ▁ans ▁= ▁a 1 ▁^ ▁a 2 ▁; ▁int ▁i ▁= ▁0 ▁; ▁while ▁( ▁i ▁< ▁26 ▁) ▁{ ▁if ▁( ▁ans ▁% ▁2 ▁== ▁1 ▁) ▁{ ▁c out ▁<< ▁char ▁( ▁' ▁a ▁' ▁+ ▁i ▁) ▁; ▁} ▁ans ▁= ▁ans ▁/ ▁2 ▁; ▁i ▁++ ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str 1 ▁= ▁" ▁g eek s forge ek s ▁" ▁; ▁string ▁str 2 ▁= ▁" ▁g eek s quiz ▁" ▁; ▁print Un common ▁( ▁str 1 ▁, ▁str 2 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁cnt ▁= ▁0 ▁; ▁vector ▁< ▁int ▁> ▁graph ▁[ ▁100 ▁] ▁; ▁vector ▁< ▁string ▁> ▁weight ▁( ▁100 ▁) ▁; ▁bool ▁unique Chars ▁( ▁string ▁x ▁) ▁{ ▁map ▁< ▁char ▁, ▁int ▁> ▁mp ▁; ▁int ▁n ▁= ▁x ▁. ▁size ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁mp ▁[ ▁x ▁[ ▁i ▁] ▁] ▁++ ▁; ▁if ▁( ▁mp ▁. ▁size ▁( ▁) ▁== ▁x ▁. ▁size ▁( ▁) ▁) ▁return ▁true ▁; ▁else ▁return ▁false ▁; ▁} ▁void ▁dfs ▁( ▁int ▁node ▁, ▁int ▁parent ▁) ▁{ ▁if ▁( ▁unique Chars ▁( ▁weight ▁[ ▁node ▁] ▁) ▁) ▁cnt ▁+= ▁1 ▁; ▁for ▁( ▁int ▁to ▁: ▁graph ▁[ ▁node ▁] ▁) ▁{ ▁if ▁( ▁to ▁== ▁parent ▁) ▁continue ▁; ▁dfs ▁( ▁to ▁, ▁node ▁) ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁weight ▁[ ▁1 ▁] ▁= ▁" ▁abc ▁" ▁; ▁weight ▁[ ▁2 ▁] ▁= ▁" ▁ab a ▁" ▁; ▁weight ▁[ ▁3 ▁] ▁= ▁" ▁b cb ▁" ▁; ▁weight ▁[ ▁4 ▁] ▁= ▁" ▁m oh ▁" ▁; ▁weight ▁[ ▁5 ▁] ▁= ▁" ▁aa ▁" ▁; ▁graph ▁[ ▁1 ▁] ▁. ▁push _ back ▁( ▁2 ▁) ▁; ▁graph ▁[ ▁2 ▁] ▁. ▁push _ back ▁( ▁3 ▁) ▁; ▁graph ▁[ ▁2 ▁] ▁. ▁push _ back ▁( ▁4 ▁) ▁; ▁graph ▁[ ▁1 ▁] ▁. ▁push _ back ▁( ▁5 ▁) ▁; ▁dfs ▁( ▁1 ▁, ▁1 ▁) ▁; ▁c out ▁<< ▁cnt ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁# include ▁< std io . h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁check ▁( ▁string ▁s ▁, ▁int ▁l ▁) ▁{ ▁vector ▁< ▁int ▁> ▁pos ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁l ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁[ ▁i ▁] ▁== ▁'1' ▁) ▁pos ▁. ▁push _ back ▁( ▁i ▁) ▁; ▁} ▁int ▁t ▁= ▁pos ▁. ▁size ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁t ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁pos ▁[ ▁i ▁] ▁- ▁pos ▁[ ▁i ▁- ▁1 ▁] ▁) ▁!= ▁( ▁pos ▁[ ▁1 ▁] ▁- ▁pos ▁[ ▁0 ▁] ▁) ▁) ▁return ▁false ▁; ▁} ▁return ▁true ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁"100 01 0001 000" ▁; ▁int ▁l ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁if ▁( ▁check ▁( ▁s ▁, ▁l ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is Prefix ▁( ▁string ▁str ▁, ▁int ▁len ▁, ▁int ▁i ▁, ▁int ▁k ▁) ▁{ ▁if ▁( ▁i ▁+ ▁k ▁> ▁len ▁) ▁return ▁false ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁k ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁str ▁[ ▁i ▁] ▁!= ▁str ▁[ ▁j ▁] ▁) ▁return ▁false ▁; ▁i ▁++ ▁; ▁} ▁return ▁true ▁; ▁} ▁bool ▁is K Period ic ▁( ▁string ▁str ▁, ▁int ▁len ▁, ▁int ▁k ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁k ▁; ▁i ▁< ▁len ▁; ▁i ▁+= ▁k ▁) ▁if ▁( ▁! ▁is Prefix ▁( ▁str ▁, ▁len ▁, ▁i ▁, ▁k ▁) ▁) ▁return ▁false ▁; ▁return ▁true ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁g eek sg eek s ▁" ▁; ▁int ▁len ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁int ▁k ▁= ▁5 ▁; ▁if ▁( ▁is K Period ic ▁( ▁str ▁, ▁len ▁, ▁k ▁) ▁) ▁c out ▁<< ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁c out ▁<< ▁( ▁" ▁No ▁" ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁p ang ram Cost ▁( ▁int ▁arr ▁[ ▁] ▁, ▁string ▁str ▁) ▁{ ▁int ▁cost ▁= ▁0 ▁; ▁bool ▁occurred ▁[ ▁26 ▁] ▁= ▁{ ▁false ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁str ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁occurred ▁[ ▁str ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁] ▁= ▁true ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁26 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁! ▁occurred ▁[ ▁i ▁] ▁) ▁cost ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁return ▁cost ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁, ▁7 ▁, ▁8 ▁, ▁9 ▁, ▁10 ▁, ▁11 ▁, ▁12 ▁, ▁13 ▁, ▁14 ▁, ▁15 ▁, ▁16 ▁, ▁17 ▁, ▁18 ▁, ▁19 ▁, ▁20 ▁, ▁21 ▁, ▁22 ▁, ▁23 ▁, ▁24 ▁, ▁25 ▁, ▁26 ▁} ▁; ▁string ▁str ▁= ▁" ▁abcdef ghijkl m op qrst uvw z ▁" ▁; ▁c out ▁<< ▁p ang ram Cost ▁( ▁arr ▁, ▁str ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁check ▁( ▁string ▁s ▁) ▁{ ▁int ▁i ▁, ▁j ▁; ▁int ▁fr ▁[ ▁26 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁int ▁n ▁= ▁s ▁. ▁size ▁( ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁char ▁x ▁= ▁s ▁[ ▁i ▁] ▁; ▁fr ▁[ ▁x ▁- ▁' ▁a ▁' ▁] ▁+= ▁1 ▁; ▁} ▁int ▁minimum ▁= ▁INT _ MAX ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁26 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁26 ▁; ▁j ▁++ ▁) ▁{ ▁int ▁z ▁= ▁fr ▁[ ▁i ▁] ▁+ ▁fr ▁[ ▁j ▁] ▁; ▁minimum ▁= ▁min ▁( ▁minimum ▁, ▁n ▁- ▁z ▁) ▁; ▁} ▁} ▁return ▁minimum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁" ▁g eek s forge ek s ▁" ▁; ▁c out ▁<< ▁check ▁( ▁s ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁string ▁separate Char ▁( ▁string ▁str ▁) ▁{ ▁int ▁n ▁= ▁str ▁. ▁size ▁( ▁) ▁, ▁digit Sum ▁= ▁0 ▁; ▁int ▁alphabet Sum ▁= ▁0 ▁, ▁j ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁isdigit ▁( ▁str ▁[ ▁i ▁] ▁) ▁) ▁digit Sum ▁+= ▁str ▁[ ▁i ▁] ▁- ▁'0' ▁; ▁else ▁{ ▁alphabet Sum ▁+= ▁str ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁+ ▁1 ▁; ▁alphabet Sum ▁% = ▁26 ▁; ▁} ▁} ▁string ▁sum Str ▁= ▁to _ string ▁( ▁digit Sum ▁) ▁; ▁char ▁alphabet Str ▁= ▁char ▁( ▁alphabet Sum ▁+ ▁' ▁a ▁' ▁- ▁1 ▁) ▁; ▁sum Str ▁+= ▁alphabet Str ▁; ▁return ▁sum Str ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" 36 52 ad yz 34 2 3" ▁; ▁c out ▁<< ▁separate Char ▁( ▁str ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Words ▁( ▁string ▁str ▁) ▁{ ▁int ▁count ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁str ▁. ▁length ▁( ▁) ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁is upper ▁( ▁str ▁[ ▁i ▁] ▁) ▁) ▁count ▁++ ▁; ▁} ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁g eek s For G eek s ▁" ▁; ▁c out ▁<< ▁count Words ▁( ▁str ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find ▁( ▁string ▁s ▁) ▁{ ▁int ▁max ▁= ▁0 ▁, ▁i ▁, ▁j ▁= ▁0 ▁, ▁count k ▁= ▁0 ▁, ▁c oun tr ▁= ▁0 ▁; ▁int ▁table ▁[ ▁s ▁. ▁length ▁( ▁) ▁] ▁[ ▁2 ▁] ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁[ ▁i ▁] ▁== ▁' ▁R ▁' ▁) ▁c oun tr ▁++ ▁; ▁else ▁table ▁[ ▁j ▁++ ▁] ▁[ ▁0 ▁] ▁= ▁c oun tr ▁; ▁} ▁j ▁-- ▁; ▁for ▁( ▁i ▁= ▁s ▁. ▁length ▁( ▁) ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁s ▁[ ▁i ▁] ▁== ▁' ▁K ▁' ▁) ▁{ ▁count k ▁++ ▁; ▁table ▁[ ▁j ▁-- ▁] ▁[ ▁1 ▁] ▁= ▁count k ▁; ▁} ▁if ▁( ▁min ▁( ▁table ▁[ ▁j ▁+ ▁1 ▁] ▁[ ▁0 ▁] ▁, ▁table ▁[ ▁j ▁+ ▁1 ▁] ▁[ ▁1 ▁] ▁) ▁> ▁max ▁) ▁max ▁= ▁min ▁( ▁table ▁[ ▁j ▁+ ▁1 ▁] ▁[ ▁0 ▁] ▁, ▁table ▁[ ▁j ▁+ ▁1 ▁] ▁[ ▁1 ▁] ▁) ▁; ▁} ▁return ▁max ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁" ▁R K RR R K K RR K K K K RR ▁" ▁; ▁int ▁n ▁= ▁find ▁( ▁s ▁) ▁; ▁c out ▁<< ▁( ▁n ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁power Of Jump ▁( ▁string ▁s ▁) ▁{ ▁int ▁count ▁= ▁1 ▁; ▁int ▁max _ so _ far ▁= ▁INT _ MIN ▁; ▁char ▁ch ▁= ▁s ▁[ ▁s ▁. ▁length ▁( ▁) ▁- ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁[ ▁i ▁] ▁== ▁ch ▁) ▁{ ▁if ▁( ▁count ▁> ▁max _ so _ far ▁) ▁{ ▁max _ so _ far ▁= ▁count ▁; ▁} ▁count ▁= ▁1 ▁; ▁} ▁else ▁count ▁++ ▁; ▁} ▁return ▁max _ so _ far ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁st ▁= ▁"1 0101 01" ▁; ▁c out ▁<< ▁power Of Jump ▁( ▁st ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁string ▁multiply ▁( ▁string ▁num 1 ▁, ▁string ▁num 2 ▁) ▁{ ▁int ▁n 1 ▁= ▁num 1 ▁. ▁size ▁( ▁) ▁; ▁int ▁n 2 ▁= ▁num 2 ▁. ▁size ▁( ▁) ▁; ▁if ▁( ▁n 1 ▁== ▁0 ▁n 2 ▁== ▁0 ▁) ▁return ▁"0" ▁; ▁vector ▁< ▁int ▁> ▁result ▁( ▁n 1 ▁+ ▁n 2 ▁, ▁0 ▁) ▁; ▁int ▁i _ n 1 ▁= ▁0 ▁; ▁int ▁i _ n 2 ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁n 1 ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁int ▁carry ▁= ▁0 ▁; ▁int ▁n 1 ▁= ▁num 1 ▁[ ▁i ▁] ▁- ▁'0' ▁; ▁i _ n 2 ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁n 2 ▁- ▁1 ▁; ▁j ▁>= ▁0 ▁; ▁j ▁-- ▁) ▁{ ▁int ▁n 2 ▁= ▁num 2 ▁[ ▁j ▁] ▁- ▁'0' ▁; ▁int ▁sum ▁= ▁n 1 ▁* ▁n 2 ▁+ ▁result ▁[ ▁i _ n 1 ▁+ ▁i _ n 2 ▁] ▁+ ▁carry ▁; ▁carry ▁= ▁sum ▁/ ▁10 ▁; ▁result ▁[ ▁i _ n 1 ▁+ ▁i _ n 2 ▁] ▁= ▁sum ▁% ▁10 ▁; ▁i _ n 2 ▁++ ▁; ▁} ▁if ▁( ▁carry ▁> ▁0 ▁) ▁result ▁[ ▁i _ n 1 ▁+ ▁i _ n 2 ▁] ▁+= ▁carry ▁; ▁i _ n 1 ▁++ ▁; ▁} ▁int ▁i ▁= ▁result ▁. ▁size ▁( ▁) ▁- ▁1 ▁; ▁while ▁( ▁i ▁>= ▁0 ▁&& ▁result ▁[ ▁i ▁] ▁== ▁0 ▁) ▁i ▁-- ▁; ▁if ▁( ▁i ▁== ▁-1 ▁) ▁return ▁"0" ▁; ▁string ▁s ▁= ▁" ▁" ▁; ▁while ▁( ▁i ▁>= ▁0 ▁) ▁s ▁+= ▁std ▁:: ▁to _ string ▁( ▁result ▁[ ▁i ▁-- ▁] ▁) ▁; ▁return ▁s ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str 1 ▁= ▁" 45 45 45 45 45 45 45 45 45 " ▁; ▁c out ▁<< ▁multiply ▁( ▁str 1 ▁, ▁str 1 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁match _ words ▁( ▁string ▁dictionary ▁[ ▁] ▁, ▁string ▁sentence ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁unordered _ map ▁< ▁string ▁, ▁int ▁> ▁mp ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁mp ▁[ ▁dictionary ▁[ ▁i ▁] ▁] ▁++ ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁m ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁mp ▁[ ▁sentence ▁[ ▁i ▁] ▁] ▁) ▁mp ▁[ ▁sentence ▁[ ▁i ▁] ▁] ▁-= ▁1 ▁; ▁else ▁return ▁false ▁; ▁} ▁return ▁true ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁dictionary ▁[ ▁] ▁= ▁{ ▁" ▁find ▁" ▁, ▁" ▁a ▁" ▁, ▁" ▁g eek s ▁" ▁, ▁" ▁all ▁" ▁, ▁" ▁for ▁" ▁, ▁" ▁on ▁" ▁, ▁" ▁g eek s ▁" ▁, ▁" ▁answers ▁" ▁, ▁" ▁inter ▁" ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁dictionary ▁) ▁/ ▁sizeof ▁( ▁dictionary ▁[ ▁0 ▁] ▁) ▁; ▁string ▁sentence ▁[ ▁] ▁= ▁{ ▁" ▁find ▁" ▁, ▁" ▁all ▁" ▁, ▁" ▁answers ▁" ▁, ▁" ▁on ▁" ▁, ▁" ▁g eek s ▁" ▁, ▁" ▁for ▁" ▁, ▁" ▁g eek s ▁" ▁} ▁; ▁int ▁m ▁= ▁sizeof ▁( ▁sentence ▁) ▁/ ▁sizeof ▁( ▁sentence ▁[ ▁0 ▁] ▁) ▁; ▁if ▁( ▁match _ words ▁( ▁dictionary ▁, ▁sentence ▁, ▁n ▁, ▁m ▁) ▁) ▁c out ▁<< ▁" ▁YES ▁" ▁; ▁else ▁c out ▁<< ▁" ▁NO ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find _ sub ▁( ▁string ▁s ▁, ▁int ▁k ▁) ▁{ ▁int ▁len ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁int ▁lp ▁= ▁0 ▁, ▁rp ▁= ▁0 ▁; ▁int ▁ans ▁= ▁0 ▁; ▁int ▁hash _ char ▁[ ▁26 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁; ▁rp ▁< ▁len ▁; ▁rp ▁++ ▁) ▁{ ▁hash _ char ▁[ ▁s ▁[ ▁rp ▁] ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁while ▁( ▁hash _ char ▁[ ▁s ▁[ ▁rp ▁] ▁- ▁' ▁a ▁' ▁] ▁> ▁k ▁) ▁{ ▁hash _ char ▁[ ▁s ▁[ ▁lp ▁] ▁- ▁' ▁a ▁' ▁] ▁-- ▁; ▁lp ▁++ ▁; ▁} ▁ans ▁+= ▁rp ▁- ▁lp ▁+ ▁1 ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁" ▁aa abb ▁" ▁; ▁int ▁k ▁= ▁2 ▁; ▁c out ▁<< ▁find _ sub ▁( ▁s ▁, ▁k ▁) ▁<< ▁end l ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁transform String ▁( ▁string ▁& ▁s ▁) ▁{ ▁char ▁ch ▁= ▁' ▁a ▁' ▁; ▁if ▁( ▁s ▁. ▁size ▁( ▁) ▁< ▁26 ▁) ▁return ▁false ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁int ▁( ▁ch ▁) ▁> ▁int ▁( ▁' ▁z ▁' ▁) ▁) ▁break ▁; ▁if ▁( ▁s ▁[ ▁i ▁] ▁<= ▁ch ▁) ▁{ ▁s ▁[ ▁i ▁] ▁= ▁ch ▁; ▁ch ▁= ▁char ▁( ▁int ▁( ▁ch ▁) ▁+ ▁1 ▁) ▁; ▁} ▁} ▁if ▁( ▁ch ▁<= ▁' ▁z ▁' ▁) ▁return ▁false ▁; ▁return ▁true ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁a aaaaaaaaaaaaaaaa aaaaaaaa a ▁" ▁; ▁if ▁( ▁transform String ▁( ▁str ▁) ▁) ▁c out ▁<< ▁str ▁<< ▁end l ▁; ▁else ▁c out ▁<< ▁" ▁Not ▁Possible ▁" ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁isP al indrome ▁( ▁string ▁str ▁) ▁{ ▁int ▁i ▁= ▁0 ▁, ▁j ▁= ▁str ▁. ▁size ▁( ▁) ▁- ▁1 ▁; ▁while ▁( ▁i ▁< ▁j ▁) ▁if ▁( ▁str ▁[ ▁i ▁++ ▁] ▁!= ▁str ▁[ ▁j ▁-- ▁] ▁) ▁return ▁false ▁; ▁return ▁true ▁; ▁} ▁string ▁remove Pal in Words ▁( ▁string ▁str ▁) ▁{ ▁string ▁final _ str ▁= ▁" ▁" ▁, ▁word ▁= ▁" ▁" ▁; ▁str ▁= ▁str ▁+ ▁" ▁" ▁; ▁int ▁n ▁= ▁str ▁. ▁size ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁str ▁[ ▁i ▁] ▁!= ▁' ▁' ▁) ▁word ▁= ▁word ▁+ ▁str ▁[ ▁i ▁] ▁; ▁else ▁{ ▁if ▁( ▁! ▁( ▁isP al indrome ▁( ▁word ▁) ▁) ▁) ▁final _ str ▁+= ▁word ▁+ ▁" ▁" ▁; ▁word ▁= ▁" ▁" ▁; ▁} ▁} ▁return ▁final _ str ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁Text ▁contains ▁m al ay al am ▁and ▁level ▁words ▁" ▁; ▁c out ▁<< ▁remove Pal in Words ▁( ▁str ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁ASC I IS ent ence ▁( ▁std ▁:: ▁string ▁str ▁) ▁{ ▁int ▁l ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁int ▁convert ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁l ▁; ▁i ▁++ ▁) ▁{ ▁convert ▁= ▁str ▁[ ▁i ▁] ▁- ▁NULL ▁; ▁c out ▁<< ▁convert ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁G eek s for G eek s ▁" ▁; ▁c out ▁<< ▁" ▁ASCII ▁Sentence ▁: ▁" ▁<< ▁std ▁:: ▁end l ▁; ▁ASC I IS ent ence ▁( ▁str ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁convert ▁( ▁string ▁str ▁) ▁{ ▁int ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁str ▁. ▁at ▁( ▁i ▁) ▁== ▁' ▁' ▁) ▁str ▁. ▁at ▁( ▁i ▁) ▁= ▁' ▁_ ▁' ▁; ▁else ▁str ▁. ▁at ▁( ▁i ▁) ▁= ▁to lower ▁( ▁str ▁. ▁at ▁( ▁i ▁) ▁) ▁; ▁} ▁c out ▁<< ▁str ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁I ▁got ▁intern ▁at ▁g eek s forge ek s ▁" ▁; ▁convert ▁( ▁str ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find Next Word ▁( ▁string ▁s ▁, ▁int ▁m ▁) ▁{ ▁m ▁+= ▁97 ▁; ▁int ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁int ▁i ▁= ▁s ▁. ▁length ▁( ▁) ▁- ▁1 ▁; ▁s ▁[ ▁i ▁] ▁++ ▁; ▁while ▁( ▁i ▁>= ▁0 ▁&& ▁i ▁<= ▁n ▁- ▁1 ▁) ▁{ ▁if ▁( ▁s ▁[ ▁i ▁] ▁>= ▁m ▁) ▁{ ▁s ▁[ ▁i ▁] ▁= ▁' ▁a ▁' ▁; ▁s ▁[ ▁-- ▁i ▁] ▁++ ▁; ▁} ▁else ▁if ▁( ▁s ▁[ ▁i ▁] ▁== ▁s ▁[ ▁i ▁- ▁1 ▁] ▁s ▁[ ▁i ▁] ▁== ▁s ▁[ ▁i ▁- ▁2 ▁] ▁) ▁s ▁[ ▁i ▁] ▁++ ▁; ▁else ▁i ▁++ ▁; ▁} ▁if ▁( ▁i ▁<= ▁-1 ▁) ▁c out ▁<< ▁" ▁- ▁1" ▁; ▁else ▁c out ▁<< ▁s ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁abcd ▁" ▁; ▁int ▁k ▁= ▁4 ▁; ▁find Next Word ▁( ▁str ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁string ▁next Word ▁( ▁string ▁s ▁) ▁{ ▁if ▁( ▁s ▁== ▁" ▁" ▁) ▁return ▁" ▁a ▁" ▁; ▁int ▁i ▁= ▁s ▁. ▁length ▁( ▁) ▁- ▁1 ▁; ▁while ▁( ▁s ▁[ ▁i ▁] ▁== ▁' ▁z ▁' ▁&& ▁i ▁>= ▁0 ▁) ▁i ▁-- ▁; ▁if ▁( ▁i ▁== ▁-1 ▁) ▁s ▁= ▁s ▁+ ▁' ▁a ▁' ▁; ▁else ▁s ▁[ ▁i ▁] ▁++ ▁; ▁return ▁s ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁same z ▁" ▁; ▁c out ▁<< ▁next Word ▁( ▁str ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁int ▁MAX _ CHAR ▁= ▁26 ▁; ▁int ▁least Count ▁( ▁string ▁s 1 ▁, ▁string ▁s 2 ▁, ▁int ▁n ▁) ▁{ ▁int ▁count 1 ▁[ ▁MAX _ CHAR ▁] ▁= ▁{ ▁0 ▁} ▁; ▁int ▁count 2 ▁[ ▁MAX _ CHAR ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁count 1 ▁[ ▁s 1 ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁] ▁+= ▁1 ▁; ▁count 2 ▁[ ▁s 2 ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁] ▁+= ▁1 ▁; ▁} ▁int ▁res ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁MAX _ CHAR ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁count 1 ▁[ ▁i ▁] ▁!= ▁0 ▁) ▁{ ▁res ▁+= ▁abs ▁( ▁count 1 ▁[ ▁i ▁] ▁- ▁count 2 ▁[ ▁i ▁] ▁) ▁; ▁} ▁} ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s 1 ▁= ▁" ▁abc ▁" ▁; ▁string ▁s 2 ▁= ▁" ▁c dd ▁" ▁; ▁int ▁len ▁= ▁s 1 ▁. ▁length ▁( ▁) ▁; ▁int ▁res ▁= ▁least Count ▁( ▁s 1 ▁, ▁s 2 ▁, ▁len ▁) ▁; ▁c out ▁<< ▁res ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁# include ▁< std lib . h > ▁NEW _ LINE ▁# include ▁< string . h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print LC Sub Str ▁( ▁char ▁* ▁X ▁, ▁char ▁* ▁Y ▁, ▁int ▁m ▁, ▁int ▁n ▁) ▁{ ▁int ▁L CS uff ▁[ ▁m ▁+ ▁1 ▁] ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁int ▁len ▁= ▁0 ▁; ▁int ▁row ▁, ▁col ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁m ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁<= ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁i ▁== ▁0 ▁j ▁== ▁0 ▁) ▁L CS uff ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁0 ▁; ▁else ▁if ▁( ▁X ▁[ ▁i ▁- ▁1 ▁] ▁== ▁Y ▁[ ▁j ▁- ▁1 ▁] ▁) ▁{ ▁L CS uff ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁L CS uff ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁- ▁1 ▁] ▁+ ▁1 ▁; ▁if ▁( ▁len ▁< ▁L CS uff ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁{ ▁len ▁= ▁L CS uff ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁row ▁= ▁i ▁; ▁col ▁= ▁j ▁; ▁} ▁} ▁else ▁L CS uff ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁0 ▁; ▁} ▁} ▁if ▁( ▁len ▁== ▁0 ▁) ▁{ ▁c out ▁<< ▁" ▁No ▁Common ▁Sub string ▁" ▁; ▁return ▁; ▁} ▁char ▁* ▁result Str ▁= ▁( ▁char ▁* ▁) ▁m alloc ▁( ▁( ▁len ▁+ ▁1 ▁) ▁* ▁sizeof ▁( ▁char ▁) ▁) ▁; ▁while ▁( ▁L CS uff ▁[ ▁row ▁] ▁[ ▁col ▁] ▁!= ▁0 ▁) ▁{ ▁row ▁-- ▁; ▁col ▁-- ▁; ▁} ▁c out ▁<< ▁result Str ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁char ▁X ▁[ ▁] ▁= ▁" ▁Old Site ▁: ▁G eek s for G eek s ▁. ▁org ▁" ▁; ▁char ▁Y ▁[ ▁] ▁= ▁" ▁New Site ▁: ▁G eek s Qu iz ▁. ▁com ▁" ▁; ▁int ▁m ▁= ▁str len ▁( ▁X ▁) ▁; ▁int ▁n ▁= ▁str len ▁( ▁Y ▁) ▁; ▁print LC Sub Str ▁( ▁X ▁, ▁Y ▁, ▁m ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁substring Con versions ▁( ▁string ▁str ▁, ▁int ▁k ▁, ▁int ▁b ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁+ ▁k ▁<= ▁str ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁string ▁sub ▁= ▁str ▁. ▁substr ▁( ▁i ▁, ▁k ▁) ▁; ▁int ▁sum ▁= ▁0 ▁, ▁counter ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁sub ▁. ▁size ▁( ▁) ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁sum ▁= ▁sum ▁+ ▁( ▁( ▁sub ▁. ▁at ▁( ▁i ▁) ▁- ▁'0' ▁) ▁* ▁pow ▁( ▁b ▁, ▁counter ▁) ▁) ▁; ▁counter ▁++ ▁; ▁} ▁c out ▁<< ▁sum ▁<< ▁" ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁"12 2 12" ▁; ▁int ▁b ▁= ▁3 ▁, ▁k ▁= ▁3 ▁; ▁substring Con versions ▁( ▁str ▁, ▁b ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁int ▁MAX _ CHAR ▁= ▁26 ▁; ▁bool ▁check Correct Or Not ▁( ▁string ▁s ▁) ▁{ ▁int ▁count 1 ▁[ ▁MAX _ CHAR ▁] ▁= ▁{ ▁0 ▁} ▁; ▁int ▁count 2 ▁[ ▁MAX _ CHAR ▁] ▁= ▁{ ▁0 ▁} ▁; ▁int ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁if ▁( ▁n ▁== ▁1 ▁) ▁return ▁true ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁, ▁j ▁= ▁n ▁- ▁1 ▁; ▁i ▁< ▁j ▁; ▁i ▁++ ▁, ▁j ▁-- ▁) ▁{ ▁count 1 ▁[ ▁s ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁count 2 ▁[ ▁s ▁[ ▁j ▁] ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁MAX _ CHAR ▁; ▁i ▁++ ▁) ▁if ▁( ▁count 1 ▁[ ▁i ▁] ▁!= ▁count 2 ▁[ ▁i ▁] ▁) ▁return ▁false ▁; ▁return ▁true ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁" ▁ab ab ▁" ▁; ▁if ▁( ▁check Correct Or Not ▁( ▁s ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁STRNEWLINE ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁STRNEWLINE ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁remainder With 7 ▁( ▁string ▁num ▁) ▁{ ▁int ▁series ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁2 ▁, ▁-1 ▁, ▁-3 ▁, ▁-2 ▁} ▁; ▁int ▁series _ index ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁num ▁. ▁size ▁( ▁) ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁int ▁digit ▁= ▁num ▁[ ▁i ▁] ▁- ▁'0' ▁; ▁result ▁+= ▁digit ▁* ▁series ▁[ ▁series _ index ▁] ▁; ▁series _ index ▁= ▁( ▁series _ index ▁+ ▁1 ▁) ▁% ▁6 ▁; ▁result ▁% = ▁7 ▁; ▁} ▁if ▁( ▁result ▁< ▁0 ▁) ▁result ▁= ▁( ▁result ▁+ ▁7 ▁) ▁% ▁7 ▁; ▁return ▁result ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁"1234 5" ▁; ▁c out ▁<< ▁" ▁Rem ainder ▁with ▁7 ▁is ▁" ▁<< ▁remainder With 7 ▁( ▁str ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁int ▁CHAR S ▁= ▁26 ▁; ▁bool ▁isValid String ▁( ▁string ▁str ▁) ▁{ ▁int ▁freq ▁[ ▁CHAR S ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁str ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁freq ▁[ ▁str ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁int ▁i ▁, ▁freq 1 ▁= ▁0 ▁, ▁count _ freq 1 ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁CHAR S ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁freq ▁[ ▁i ▁] ▁!= ▁0 ▁) ▁{ ▁freq 1 ▁= ▁freq ▁[ ▁i ▁] ▁; ▁count _ freq 1 ▁= ▁1 ▁; ▁break ▁; ▁} ▁} ▁int ▁j ▁, ▁freq 2 ▁= ▁0 ▁, ▁count _ freq 2 ▁= ▁0 ▁; ▁for ▁( ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁CHAR S ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁freq ▁[ ▁j ▁] ▁!= ▁0 ▁) ▁{ ▁if ▁( ▁freq ▁[ ▁j ▁] ▁== ▁freq 1 ▁) ▁count _ freq 1 ▁++ ▁; ▁else ▁{ ▁count _ freq 2 ▁= ▁1 ▁; ▁freq 2 ▁= ▁freq ▁[ ▁j ▁] ▁; ▁break ▁; ▁} ▁} ▁} ▁for ▁( ▁int ▁k ▁= ▁j ▁+ ▁1 ▁; ▁k ▁< ▁CHAR S ▁; ▁k ▁++ ▁) ▁{ ▁if ▁( ▁freq ▁[ ▁k ▁] ▁!= ▁0 ▁) ▁{ ▁if ▁( ▁freq ▁[ ▁k ▁] ▁== ▁freq 1 ▁) ▁count _ freq 1 ▁++ ▁; ▁if ▁( ▁freq ▁[ ▁k ▁] ▁== ▁freq 2 ▁) ▁count _ freq 2 ▁++ ▁; ▁return ▁false ▁; ▁} ▁if ▁( ▁count _ freq 1 ▁> ▁1 ▁&& ▁count _ freq 2 ▁> ▁1 ▁) ▁return ▁false ▁; ▁} ▁return ▁true ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁char ▁str ▁[ ▁] ▁= ▁" ▁abc bc ▁" ▁; ▁if ▁( ▁isValid String ▁( ▁str ▁) ▁) ▁c out ▁<< ▁" ▁YES ▁" ▁<< ▁end l ▁; ▁else ▁c out ▁<< ▁" ▁NO ▁" ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is Re vers ible ▁( ▁string ▁str ▁) ▁{ ▁int ▁i ▁= ▁0 ▁, ▁j ▁= ▁str ▁. ▁length ▁( ▁) ▁- ▁1 ▁; ▁while ▁( ▁i ▁< ▁j ▁) ▁{ ▁if ▁( ▁str ▁[ ▁i ▁] ▁!= ▁str ▁[ ▁j ▁] ▁) ▁return ▁false ▁; ▁i ▁++ ▁; ▁j ▁-- ▁; ▁} ▁return ▁true ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁ab a ▁" ▁; ▁if ▁( ▁is Re vers ible ▁( ▁str ▁) ▁) ▁c out ▁<< ▁" ▁YES ▁" ▁; ▁else ▁c out ▁<< ▁" ▁NO ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁string ▁encode String ▁( ▁string ▁str ▁) ▁{ ▁unordered _ map ▁< ▁char ▁, ▁int ▁> ▁map ▁; ▁string ▁res ▁= ▁" ▁" ▁; ▁int ▁i ▁= ▁0 ▁; ▁for ▁( ▁char ▁ch ▁: ▁str ▁) ▁{ ▁if ▁( ▁map ▁. ▁find ▁( ▁ch ▁) ▁== ▁map ▁. ▁end ▁( ▁) ▁) ▁map ▁[ ▁ch ▁] ▁= ▁i ▁++ ▁; ▁res ▁+= ▁to _ string ▁( ▁map ▁[ ▁ch ▁] ▁) ▁; ▁} ▁return ▁res ▁; ▁} ▁void ▁find Matched Words ▁( ▁unordered _ set ▁< ▁string ▁> ▁dict ▁, ▁string ▁pattern ▁) ▁{ ▁int ▁len ▁= ▁pattern ▁. ▁length ▁( ▁) ▁; ▁string ▁hash ▁= ▁encode String ▁( ▁pattern ▁) ▁; ▁for ▁( ▁string ▁word ▁: ▁dict ▁) ▁{ ▁if ▁( ▁word ▁. ▁length ▁( ▁) ▁== ▁len ▁&& ▁encode String ▁( ▁word ▁) ▁== ▁hash ▁) ▁c out ▁<< ▁word ▁<< ▁" ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁unordered _ set ▁< ▁string ▁> ▁dict ▁= ▁{ ▁" ▁ab b ▁" ▁, ▁" ▁abc ▁" ▁, ▁" ▁xyz ▁" ▁, ▁" ▁x yy ▁" ▁} ▁; ▁string ▁pattern ▁= ▁" ▁foo ▁" ▁; ▁find Matched Words ▁( ▁dict ▁, ▁pattern ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁check ▁( ▁string ▁pattern ▁, ▁string ▁word ▁) ▁{ ▁if ▁( ▁pattern ▁. ▁length ▁( ▁) ▁!= ▁word ▁. ▁length ▁( ▁) ▁) ▁return ▁false ▁; ▁char ▁ch ▁[ ▁128 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁int ▁len ▁= ▁word ▁. ▁length ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁len ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁ch ▁[ ▁pattern ▁[ ▁i ▁] ▁] ▁== ▁0 ▁) ▁ch ▁[ ▁pattern ▁[ ▁i ▁] ▁] ▁= ▁word ▁[ ▁i ▁] ▁; ▁else ▁if ▁( ▁ch ▁[ ▁pattern ▁[ ▁i ▁] ▁] ▁!= ▁word ▁[ ▁i ▁] ▁) ▁return ▁false ▁; ▁} ▁return ▁true ▁; ▁} ▁void ▁find Matched Words ▁( ▁unordered _ set ▁< ▁string ▁> ▁dict ▁, ▁string ▁pattern ▁) ▁{ ▁int ▁len ▁= ▁pattern ▁. ▁length ▁( ▁) ▁; ▁for ▁( ▁string ▁word ▁: ▁dict ▁) ▁{ ▁if ▁( ▁check ▁( ▁pattern ▁, ▁word ▁) ▁) ▁c out ▁<< ▁word ▁<< ▁" ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁unordered _ set ▁< ▁string ▁> ▁dict ▁= ▁{ ▁" ▁ab b ▁" ▁, ▁" ▁abc ▁" ▁, ▁" ▁xyz ▁" ▁, ▁" ▁x yy ▁" ▁} ▁; ▁string ▁pattern ▁= ▁" ▁foo ▁" ▁; ▁find Matched Words ▁( ▁dict ▁, ▁pattern ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁string ▁int To R oman ▁( ▁int ▁num ▁) ▁{ ▁string ▁m ▁[ ▁] ▁= ▁{ ▁" ▁" ▁, ▁" ▁M ▁" ▁, ▁" ▁MM ▁" ▁, ▁" ▁M MM ▁" ▁} ▁; ▁string ▁c ▁[ ▁] ▁= ▁{ ▁" ▁" ▁, ▁" ▁C ▁" ▁, ▁" ▁CC ▁" ▁, ▁" ▁C CC ▁" ▁, ▁" ▁CD ▁" ▁, ▁" ▁D ▁" ▁, ▁" ▁DC ▁" ▁, ▁" ▁D CC ▁" ▁, ▁" ▁D CC C ▁" ▁, ▁" ▁CM ▁" ▁} ▁; ▁string ▁x ▁[ ▁] ▁= ▁{ ▁" ▁" ▁, ▁" ▁X ▁" ▁, ▁" ▁XX ▁" ▁, ▁" ▁XXX ▁" ▁, ▁" ▁X L ▁" ▁, ▁" ▁L ▁" ▁, ▁" ▁L X ▁" ▁, ▁" ▁L XX ▁" ▁, ▁" ▁L XXX ▁" ▁, ▁" ▁X C ▁" ▁} ▁; ▁string ▁i ▁[ ▁] ▁= ▁{ ▁" ▁" ▁, ▁" ▁I ▁" ▁, ▁" ▁II ▁" ▁, ▁" ▁I II ▁" ▁, ▁" ▁IV ▁" ▁, ▁" ▁V ▁" ▁, ▁" ▁VI ▁" ▁, ▁" ▁VI I ▁" ▁, ▁" ▁VI II ▁" ▁, ▁" ▁I X ▁" ▁} ▁; ▁string ▁thousands ▁= ▁m ▁[ ▁num ▁/ ▁1000 ▁] ▁; ▁string ▁h under ed s ▁= ▁c ▁[ ▁( ▁num ▁% ▁1000 ▁) ▁/ ▁100 ▁] ▁; ▁string ▁t ens ▁= ▁x ▁[ ▁( ▁num ▁% ▁100 ▁) ▁/ ▁10 ▁] ▁; ▁string ▁ones ▁= ▁i ▁[ ▁num ▁% ▁10 ▁] ▁; ▁string ▁ans ▁= ▁thousands ▁+ ▁h under ed s ▁+ ▁t ens ▁+ ▁ones ▁; ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁number ▁= ▁35 49 ▁; ▁c out ▁<< ▁int To R oman ▁( ▁number ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁string ▁z ig Z ag Concat ▁( ▁string ▁s ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁<= ▁1 ▁) ▁{ ▁return ▁s ▁; ▁} ▁string ▁result ▁= ▁" ▁" ▁; ▁for ▁( ▁int ▁row Num ▁= ▁0 ▁; ▁row Num ▁< ▁n ▁; ▁row Num ▁++ ▁) ▁{ ▁int ▁i ▁= ▁row Num ▁; ▁bool ▁up ▁= ▁true ▁; ▁while ▁( ▁i ▁< ▁s ▁. ▁length ▁( ▁) ▁) ▁{ ▁result ▁+= ▁s ▁[ ▁i ▁] ▁; ▁if ▁( ▁row Num ▁== ▁0 ▁row Num ▁== ▁n ▁- ▁1 ▁) ▁{ ▁i ▁+= ▁( ▁2 ▁* ▁n ▁- ▁2 ▁) ▁; ▁} ▁else ▁{ ▁if ▁( ▁up ▁) ▁{ ▁i ▁+= ▁( ▁2 ▁* ▁( ▁n ▁- ▁row Num ▁) ▁- ▁2 ▁) ▁; ▁} ▁else ▁{ ▁i ▁+= ▁row Num ▁* ▁2 ▁; ▁} ▁up ▁^= ▁true ▁; ▁} ▁} ▁} ▁return ▁result ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁G EEK S FOR GE EK S ▁" ▁; ▁int ▁n ▁= ▁3 ▁; ▁c out ▁<< ▁z ig Z ag Concat ▁( ▁str ▁, ▁n ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁maximum X OR ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁K ▁) ▁{ ▁K ▁++ ▁; ▁int ▁maxX or ▁= ▁INT _ MIN ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁( ▁1 ▁<< ▁n ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁__ builtin _ pop count ▁( ▁i ▁) ▁== ▁K ▁) ▁{ ▁int ▁cur _ xor ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁i ▁& ▁( ▁1 ▁<< ▁j ▁) ▁) ▁cur _ xor ▁= ▁cur _ xor ▁^ ▁arr ▁[ ▁j ▁] ▁; ▁} ▁maxX or ▁= ▁max ▁( ▁maxX or ▁, ▁cur _ xor ▁) ▁; ▁} ▁} ▁return ▁maxX or ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁int ▁M ▁= ▁2 ▁; ▁c out ▁<< ▁maximum X OR ▁( ▁arr ▁, ▁N ▁, ▁M ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁T ower Of H ano i ▁( ▁int ▁N ▁) ▁{ ▁for ▁( ▁int ▁x ▁= ▁1 ▁; ▁x ▁<= ▁pow ▁( ▁2 ▁, ▁N ▁) ▁- ▁1 ▁; ▁x ▁++ ▁) ▁{ ▁c out ▁<< ▁" ▁Move ▁from ▁R od ▁" ▁<< ▁( ▁( ▁x ▁& ▁x ▁- ▁1 ▁) ▁% ▁3 ▁+ ▁1 ▁) ▁<< ▁" ▁to ▁R od ▁" ▁<< ▁( ▁( ▁( ▁x ▁x ▁- ▁1 ▁) ▁+ ▁1 ▁) ▁% ▁3 ▁+ ▁1 ▁) ▁<< ▁end l ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁3 ▁; ▁T ower Of H ano i ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁isValid ▁( ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁& ▁board ▁, ▁int ▁i ▁, ▁int ▁j ▁, ▁int ▁K ▁) ▁{ ▁if ▁( ▁board ▁[ ▁i ▁] ▁[ ▁j ▁] ▁<= ▁K ▁) ▁{ ▁return ▁true ▁; ▁} ▁return ▁false ▁; ▁} ▁bool ▁find Path ▁( ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁& ▁board ▁, ▁int ▁X ▁, ▁int ▁Y ▁, ▁int ▁M ▁, ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁if ▁( ▁X ▁< ▁0 ▁X ▁== ▁M ▁Y ▁< ▁0 ▁Y ▁== ▁N ▁) ▁{ ▁return ▁true ▁; ▁} ▁if ▁( ▁isValid ▁( ▁board ▁, ▁X ▁, ▁Y ▁, ▁K ▁) ▁) ▁{ ▁int ▁board _ XY ▁= ▁board ▁[ ▁X ▁] ▁[ ▁Y ▁] ▁; ▁board ▁[ ▁X ▁] ▁[ ▁Y ▁] ▁= ▁INT _ MAX ▁; ▁if ▁( ▁find Path ▁( ▁board ▁, ▁X ▁+ ▁1 ▁, ▁Y ▁, ▁M ▁, ▁N ▁, ▁K ▁- ▁board _ XY ▁) ▁|| ▁find Path ▁( ▁board ▁, ▁X ▁- ▁1 ▁, ▁Y ▁, ▁M ▁, ▁N ▁, ▁K ▁- ▁board _ XY ▁) ▁|| ▁find Path ▁( ▁board ▁, ▁X ▁, ▁Y ▁+ ▁1 ▁, ▁M ▁, ▁N ▁, ▁K ▁- ▁board _ XY ▁) ▁|| ▁find Path ▁( ▁board ▁, ▁X ▁, ▁Y ▁- ▁1 ▁, ▁M ▁, ▁N ▁, ▁K ▁- ▁board _ XY ▁) ▁) ▁{ ▁return ▁true ▁; ▁} ▁board ▁[ ▁X ▁] ▁[ ▁Y ▁] ▁= ▁board _ XY ▁; ▁} ▁return ▁false ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁grid ▁= ▁{ ▁{ ▁25 ▁, ▁5 ▁, ▁25 ▁, ▁25 ▁, ▁25 ▁, ▁25 ▁} ▁, ▁{ ▁25 ▁, ▁1 ▁, ▁1 ▁, ▁5 ▁, ▁12 ▁, ▁25 ▁} ▁, ▁{ ▁25 ▁, ▁1 ▁, ▁12 ▁, ▁0 ▁, ▁15 ▁, ▁25 ▁} ▁, ▁{ ▁22 ▁, ▁1 ▁, ▁11 ▁, ▁2 ▁, ▁19 ▁, ▁15 ▁} ▁, ▁{ ▁25 ▁, ▁2 ▁, ▁2 ▁, ▁1 ▁, ▁12 ▁, ▁15 ▁} ▁, ▁{ ▁25 ▁, ▁9 ▁, ▁10 ▁, ▁1 ▁, ▁11 ▁, ▁25 ▁} ▁, ▁{ ▁25 ▁, ▁25 ▁, ▁25 ▁, ▁25 ▁, ▁25 ▁, ▁25 ▁} ▁} ▁; ▁int ▁K ▁= ▁17 ▁; ▁int ▁M ▁= ▁grid ▁. ▁size ▁( ▁) ▁; ▁int ▁N ▁= ▁grid ▁[ ▁0 ▁] ▁. ▁size ▁(
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁solve ▁( ▁int ▁& ▁N ▁, ▁int ▁& ▁P 1 ▁, ▁int ▁& ▁P 2 ▁, ▁int ▁& ▁X ▁, ▁bool ▁Move ▁, ▁bool ▁Qu it P 1 ▁, ▁bool ▁Qu it P 2 ▁) ▁{ ▁if ▁( ▁N ▁== ▁0 ▁or ▁( ▁Qu it P 1 ▁and ▁Qu it P 2 ▁) ▁) ▁{ ▁c out ▁<< ▁" ▁Number ▁of ▁p ens ▁remaining ▁" ▁<< ▁" ▁in ▁the ▁box ▁: ▁" ▁<< ▁N ▁<< ▁end l ▁; ▁c out ▁<< ▁" ▁Number ▁of ▁p ens ▁collected ▁" ▁<< ▁" ▁by ▁P 1 ▁: ▁" ▁<< ▁P 1 ▁<< ▁end l ▁; ▁c out ▁<< ▁" ▁Number ▁of ▁p ens ▁collected ▁" ▁<< ▁" ▁by ▁P 2 ▁: ▁" ▁<< ▁P 2 ▁<< ▁end l ▁; ▁return ▁; ▁} ▁if ▁( ▁Move ▁== ▁0 ▁and ▁Qu it P 1 ▁== ▁false ▁) ▁{ ▁int ▁req _ P 1 ▁= ▁pow ▁( ▁2 ▁, ▁X ▁) ▁; ▁if ▁( ▁req _ P 1 ▁<= ▁N ▁) ▁{ ▁P 1 ▁+= ▁req _ P 1 ▁; ▁N ▁-= ▁req _ P 1 ▁; ▁} ▁else ▁{ ▁Qu it P 1 ▁= ▁true ▁; ▁} ▁} ▁else ▁if ▁( ▁Move ▁== ▁1 ▁and ▁Qu it P 2 ▁== ▁false ▁) ▁{ ▁int ▁req _ P 2 ▁= ▁pow ▁( ▁3 ▁, ▁X ▁) ▁; ▁if ▁( ▁req _ P 2 ▁<= ▁N ▁) ▁{ ▁P 2 ▁+= ▁req _ P 2 ▁; ▁N ▁-= ▁req _ P 2 ▁; ▁} ▁else ▁{ ▁Qu it P 2 ▁= ▁true ▁; ▁} ▁} ▁X ▁++ ▁; ▁Move ▁= ▁( ▁( ▁Move ▁== ▁1 ▁) ▁? ▁0 ▁: ▁1 ▁) ▁; ▁solve ▁( ▁N ▁, ▁P 1 ▁, ▁P 2 ▁, ▁X ▁, ▁Move ▁, ▁Qu it P 1 ▁, ▁Qu it P 2 ▁) ▁; ▁} ▁void ▁P en Game ▁( ▁int ▁N ▁) ▁{ ▁int ▁P 1 ▁= ▁0 ▁; ▁int ▁P 2 ▁= ▁0 ▁; ▁int ▁X ▁= ▁0 ▁; ▁bool ▁Move ▁= ▁0 ▁; ▁bool ▁Qu it P 1 ▁= ▁0 ▁; ▁bool ▁Qu it P 2 ▁= ▁0 ▁; ▁solve ▁( ▁N ▁, ▁P 1 ▁, ▁P 2 ▁, ▁X ▁, ▁Move ▁, ▁Qu it P 1 ▁, ▁Qu it P 2 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁=
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁can Place ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁p ▁, ▁int ▁sep ▁) ▁{ ▁int ▁pr ison ers _ pla ced ▁= ▁1 ▁; ▁int ▁last _ pr ison er _ pla ced ▁= ▁a ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁current _ cell ▁= ▁a ▁[ ▁i ▁] ▁; ▁if ▁( ▁current _ cell ▁- ▁last _ pr ison er _ pla ced ▁>= ▁sep ▁) ▁{ ▁pr ison ers _ pla ced ▁++ ▁; ▁last _ pr ison er _ pla ced ▁= ▁current _ cell ▁; ▁if ▁( ▁pr ison ers _ pla ced ▁== ▁p ▁) ▁{ ▁return ▁true ▁; ▁} ▁} ▁} ▁return ▁false ▁; ▁} ▁int ▁max Distance ▁( ▁int ▁cell ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁p ▁) ▁{ ▁sort ▁( ▁cell ▁, ▁cell ▁+ ▁n ▁) ▁; ▁int ▁start ▁= ▁0 ▁; ▁int ▁end ▁= ▁cell ▁[ ▁n ▁- ▁1 ▁] ▁- ▁cell ▁[ ▁0 ▁] ▁; ▁int ▁ans ▁= ▁0 ▁; ▁while ▁( ▁start ▁<= ▁end ▁) ▁{ ▁int ▁mid ▁= ▁start ▁+ ▁( ▁( ▁end ▁- ▁start ▁) ▁/ ▁2 ▁) ▁; ▁if ▁( ▁can Place ▁( ▁cell ▁, ▁n ▁, ▁p ▁, ▁mid ▁) ▁) ▁{ ▁ans ▁= ▁mid ▁; ▁start ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁else ▁{ ▁end ▁= ▁mid ▁- ▁1 ▁; ▁} ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁cell ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁8 ▁, ▁4 ▁, ▁9 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁cell ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁int ▁p ▁= ▁3 ▁; ▁c out ▁<< ▁max Distance ▁( ▁cell ▁, ▁n ▁, ▁p ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁max Len ▁30 ▁NEW _ LINE ▁int ▁seg ▁[ ▁3 ▁* ▁max Len ▁] ▁; ▁int ▁build ▁( ▁int ▁l ▁, ▁int ▁r ▁, ▁int ▁in ▁, ▁int ▁* ▁arr ▁) ▁{ ▁if ▁( ▁l ▁== ▁r ▁) ▁return ▁seg ▁[ ▁in ▁] ▁= ▁arr ▁[ ▁l ▁] ▁; ▁int ▁mid ▁= ▁( ▁l ▁+ ▁r ▁) ▁/ ▁2 ▁; ▁return ▁seg ▁[ ▁in ▁] ▁= ▁__ g cd ▁( ▁build ▁( ▁l ▁, ▁mid ▁, ▁2 ▁* ▁in ▁+ ▁1 ▁, ▁arr ▁) ▁, ▁build ▁( ▁mid ▁+ ▁1 ▁, ▁r ▁, ▁2 ▁* ▁in ▁+ ▁2 ▁, ▁arr ▁) ▁) ▁; ▁} ▁int ▁query ▁( ▁int ▁l ▁, ▁int ▁r ▁, ▁int ▁l 1 ▁, ▁int ▁r 1 ▁, ▁int ▁in ▁) ▁{ ▁if ▁( ▁l 1 ▁<= ▁l ▁and ▁r ▁<= ▁r 1 ▁) ▁return ▁seg ▁[ ▁in ▁] ▁; ▁if ▁( ▁l ▁> ▁r 1 ▁or ▁r ▁< ▁l 1 ▁) ▁return ▁0 ▁; ▁int ▁mid ▁= ▁( ▁l ▁+ ▁r ▁) ▁/ ▁2 ▁; ▁return ▁__ g cd ▁( ▁query ▁( ▁l ▁, ▁mid ▁, ▁l 1 ▁, ▁r 1 ▁, ▁2 ▁* ▁in ▁+ ▁1 ▁) ▁, ▁query ▁( ▁mid ▁+ ▁1 ▁, ▁r ▁, ▁l 1 ▁, ▁r 1 ▁, ▁2 ▁* ▁in ▁+ ▁2 ▁) ▁) ▁; ▁} ▁int ▁find Len ▁( ▁int ▁* ▁arr ▁, ▁int ▁n ▁) ▁{ ▁build ▁( ▁0 ▁, ▁n ▁- ▁1 ▁, ▁0 ▁, ▁arr ▁) ▁; ▁int ▁i ▁= ▁0 ▁, ▁j ▁= ▁0 ▁; ▁int ▁ans ▁= ▁INT _ MAX ▁; ▁while ▁( ▁i ▁< ▁n ▁) ▁{ ▁while ▁( ▁j ▁< ▁n ▁and ▁query ▁( ▁0 ▁, ▁n ▁- ▁1 ▁, ▁i ▁, ▁j ▁, ▁0 ▁) ▁!= ▁1 ▁) ▁j ▁++ ▁; ▁if ▁( ▁j ▁== ▁n ▁) ▁break ▁; ▁ans ▁= ▁min ▁( ▁( ▁j ▁- ▁i ▁+ ▁1 ▁) ▁, ▁ans ▁) ▁; ▁i ▁++ ▁; ▁j ▁= ▁max ▁( ▁j ▁, ▁i ▁) ▁; ▁} ▁if ▁( ▁ans ▁== ▁INT _ MAX ▁) ▁return ▁-1 ▁; ▁else ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁2 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁c out ▁<< ▁find Len ▁( ▁arr ▁,
▁# include ▁< iom an ip > ▁NEW _ LINE ▁# include ▁< i ost ream > ▁NEW _ LINE ▁# include ▁< math . h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find Area ▁( ▁double ▁a ▁, ▁double ▁b ▁, ▁double ▁c ▁) ▁{ ▁double ▁area ▁= ▁4 ▁* ▁3.14 159 26 53 ▁* ▁pow ▁( ▁( ▁pow ▁( ▁a ▁* ▁b ▁, ▁1.6 ▁) ▁+ ▁pow ▁( ▁a ▁* ▁c ▁, ▁1.6 ▁) ▁+ ▁pow ▁( ▁b ▁* ▁c ▁, ▁1.6 ▁) ▁) ▁/ ▁3 ▁, ▁1 ▁/ ▁1.6 ▁) ▁; ▁c out ▁<< ▁fixed ▁<< ▁set precision ▁( ▁2 ▁) ▁<< ▁area ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁double ▁A ▁= ▁11 ▁, ▁B ▁= ▁12 ▁, ▁C ▁= ▁13 ▁; ▁find Area ▁( ▁A ▁, ▁B ▁, ▁C ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁double ▁find Radius ▁( ▁double ▁r 1 ▁, ▁double ▁r 2 ▁, ▁double ▁r 3 ▁) ▁{ ▁double ▁r 4 ▁= ▁( ▁r 1 ▁* ▁r 2 ▁* ▁r 3 ▁) ▁/ ▁( ▁r 1 ▁* ▁r 2 ▁+ ▁r 2 ▁* ▁r 3 ▁+ ▁r 1 ▁* ▁r 3 ▁+ ▁2.0 ▁* ▁sqrt ▁( ▁r 1 ▁* ▁r 2 ▁* ▁r 3 ▁* ▁( ▁r 1 ▁+ ▁r 2 ▁+ ▁r 3 ▁) ▁) ▁) ▁; ▁return ▁r 4 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁double ▁r 1 ▁= ▁1 ▁; ▁double ▁r 2 ▁= ▁1 ▁; ▁double ▁r 3 ▁= ▁1 ▁; ▁double ▁r 4 ▁= ▁find Radius ▁( ▁r 1 ▁, ▁r 2 ▁, ▁r 3 ▁) ▁; ▁c out ▁<< ▁" ▁The ▁radius ▁of ▁fourth ▁circle ▁: ▁" ▁<< ▁r 4 ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁minimum Rectangle Area ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁ans ▁; ▁sort ▁( ▁A ▁, ▁A ▁+ ▁2 ▁* ▁N ▁) ▁; ▁ans ▁= ▁( ▁A ▁[ ▁N ▁- ▁1 ▁] ▁- ▁A ▁[ ▁0 ▁] ▁) ▁* ▁( ▁A ▁[ ▁2 ▁* ▁N ▁- ▁1 ▁] ▁- ▁A ▁[ ▁N ▁] ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁ans ▁= ▁min ▁( ▁ans ▁, ▁( ▁A ▁[ ▁2 ▁* ▁N ▁- ▁1 ▁] ▁- ▁A ▁[ ▁0 ▁] ▁) ▁* ▁( ▁A ▁[ ▁i ▁+ ▁N ▁- ▁1 ▁] ▁- ▁A ▁[ ▁i ▁] ▁) ▁) ▁; ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁4 ▁, ▁1 ▁, ▁5 ▁, ▁3 ▁, ▁6 ▁, ▁7 ▁, ▁8 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁A ▁) ▁/ ▁sizeof ▁( ▁A ▁[ ▁0 ▁] ▁) ▁; ▁N ▁/= ▁2 ▁; ▁c out ▁<< ▁minimum Rectangle Area ▁( ▁A ▁, ▁N ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁double ▁e cc Hyper b ola ▁( ▁double ▁A ▁, ▁double ▁B ▁) ▁{ ▁double ▁r ▁= ▁( ▁double ▁) ▁B ▁* ▁B ▁/ ▁A ▁* ▁A ▁; ▁r ▁+= ▁1 ▁; ▁return ▁sqrt ▁( ▁r ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁double ▁A ▁= ▁3.0 ▁, ▁B ▁= ▁2.0 ▁; ▁c out ▁<< ▁e cc Hyper b ola ▁( ▁A ▁, ▁B ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁float ▁calculate Area ▁( ▁float ▁A ▁, ▁float ▁B ▁, ▁float ▁C ▁, ▁float ▁D ▁) ▁{ ▁float ▁S ▁= ▁( ▁A ▁+ ▁B ▁+ ▁C ▁+ ▁D ▁) ▁/ ▁2 ▁; ▁float ▁area ▁= ▁sqrt ▁( ▁( ▁S ▁- ▁A ▁) ▁* ▁( ▁S ▁- ▁B ▁) ▁* ▁( ▁S ▁- ▁C ▁) ▁* ▁( ▁S ▁- ▁D ▁) ▁) ▁; ▁return ▁area ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁float ▁A ▁= ▁10 ▁; ▁float ▁B ▁= ▁15 ▁; ▁float ▁C ▁= ▁20 ▁; ▁float ▁D ▁= ▁25 ▁; ▁c out ▁<< ▁calculate Area ▁( ▁A ▁, ▁B ▁, ▁C ▁, ▁D ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁total C ir cles ▁( ▁int ▁L ▁, ▁int ▁B ▁) ▁{ ▁if ▁( ▁L ▁> ▁B ▁) ▁{ ▁int ▁temp ▁= ▁L ▁; ▁L ▁= ▁B ▁; ▁B ▁= ▁temp ▁; ▁} ▁return ▁B ▁/ ▁L ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁L ▁= ▁3 ▁; ▁int ▁B ▁= ▁8 ▁; ▁c out ▁<< ▁total C ir cles ▁( ▁L ▁, ▁B ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁double ▁find Radius ▁( ▁double ▁r 1 ▁, ▁double ▁r 2 ▁) ▁{ ▁double ▁a 1 ▁, ▁a 2 ▁, ▁a 3 ▁, ▁r 3 ▁; ▁a 1 ▁= ▁3.14 ▁* ▁r 1 ▁* ▁r 1 ▁; ▁a 2 ▁= ▁3.14 ▁* ▁r 2 ▁* ▁r 2 ▁; ▁a 3 ▁= ▁a 1 ▁+ ▁a 2 ▁; ▁r 3 ▁= ▁sqrt ▁( ▁a 3 ▁/ ▁3.14 ▁) ▁; ▁return ▁r 3 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁double ▁r 1 ▁= ▁8 ▁, ▁r 2 ▁= ▁6 ▁; ▁c out ▁<< ▁find Radius ▁( ▁r 1 ▁, ▁r 2 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find _ l cm ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁int ▁c ▁) ▁{ ▁int ▁g ▁= ▁__ g cd ▁( ▁a ▁, ▁b ▁) ▁; ▁int ▁L CM 1 ▁= ▁( ▁a ▁* ▁b ▁) ▁/ ▁g ▁; ▁g ▁= ▁__ g cd ▁( ▁L CM 1 ▁, ▁c ▁) ▁; ▁int ▁L CM ▁= ▁( ▁L CM 1 ▁* ▁c ▁) ▁/ ▁g ▁; ▁return ▁L CM ▁; ▁} ▁void ▁minimum C ub oid s ▁( ▁int ▁L ▁, ▁int ▁B ▁, ▁int ▁H ▁) ▁{ ▁int ▁l cm ▁= ▁find _ l cm ▁( ▁L ▁, ▁B ▁, ▁H ▁) ▁; ▁int ▁volume _ cube ▁= ▁l cm ▁* ▁l cm ▁* ▁l cm ▁; ▁int ▁volume _ c ub oid ▁= ▁L ▁* ▁B ▁* ▁H ▁; ▁c out ▁<< ▁( ▁volume _ cube ▁/ ▁volume _ c ub oid ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁L ▁= ▁1 ▁, ▁B ▁= ▁1 ▁, ▁H ▁= ▁2 ▁; ▁minimum C ub oid s ▁( ▁L ▁, ▁B ▁, ▁H ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁Cross Product ▁( ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁& ▁A ▁) ▁{ ▁int ▁X 1 ▁= ▁( ▁A ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁- ▁A ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁) ▁; ▁int ▁Y 1 ▁= ▁( ▁A ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁- ▁A ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁) ▁; ▁int ▁X 2 ▁= ▁( ▁A ▁[ ▁2 ▁] ▁[ ▁0 ▁] ▁- ▁A ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁) ▁; ▁int ▁Y 2 ▁= ▁( ▁A ▁[ ▁2 ▁] ▁[ ▁1 ▁] ▁- ▁A ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁) ▁; ▁return ▁( ▁X 1 ▁* ▁Y 2 ▁- ▁Y 1 ▁* ▁X 2 ▁) ▁; ▁} ▁bool ▁is Conv ex ▁( ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁& ▁points ▁) ▁{ ▁int ▁N ▁= ▁points ▁. ▁size ▁( ▁) ▁; ▁int ▁prev ▁= ▁0 ▁; ▁int ▁curr ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁temp ▁= ▁{ ▁points ▁[ ▁i ▁] ▁, ▁points ▁[ ▁( ▁i ▁+ ▁1 ▁) ▁% ▁N ▁] ▁, ▁points ▁[ ▁( ▁i ▁+ ▁2 ▁) ▁% ▁N ▁] ▁} ▁; ▁curr ▁= ▁Cross Product ▁( ▁temp ▁) ▁; ▁if ▁( ▁curr ▁!= ▁0 ▁) ▁{ ▁if ▁( ▁curr ▁* ▁prev ▁< ▁0 ▁) ▁{ ▁return ▁false ▁; ▁} ▁else ▁{ ▁prev ▁= ▁curr ▁; ▁} ▁} ▁} ▁return ▁true ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁points ▁= ▁{ ▁{ ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁0 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁0 ▁} ▁} ▁; ▁if ▁( ▁is Conv ex ▁( ▁points ▁) ▁) ▁{ ▁c out ▁<< ▁" ▁Yes ▁" ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁" ▁No ▁" ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁} ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁double ▁distance ▁( ▁int ▁r ▁, ▁int ▁R ▁) ▁{ ▁double ▁d ▁= ▁sqrt ▁( ▁pow ▁( ▁R ▁, ▁2 ▁) ▁- ▁( ▁2 ▁* ▁r ▁* ▁R ▁) ▁) ▁; ▁return ▁d ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁r ▁= ▁2 ▁; ▁int ▁R ▁= ▁5 ▁; ▁c out ▁<< ▁( ▁round ▁( ▁distance ▁( ▁r ▁, ▁R ▁) ▁* ▁100.0 ▁) ▁/ ▁100.0 ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁double ▁min An gl Rot ▁( ▁int ▁N ▁) ▁{ ▁double ▁res ▁; ▁res ▁= ▁360 ▁/ ▁( ▁double ▁) ▁N ▁; ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁4 ▁; ▁c out ▁<< ▁" ▁An gle ▁of ▁Rot ational ▁Sym m etry ▁: ▁" ▁<< ▁min An gl Rot ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁double ▁Area _ of _ Triangle ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁int ▁c ▁) ▁{ ▁int ▁s ▁= ▁( ▁a ▁+ ▁b ▁+ ▁c ▁) ▁/ ▁2 ▁; ▁int ▁x ▁= ▁s ▁* ▁( ▁s ▁- ▁a ▁) ▁; ▁x ▁= ▁x ▁* ▁( ▁s ▁- ▁b ▁) ▁; ▁x ▁= ▁x ▁* ▁( ▁s ▁- ▁c ▁) ▁; ▁double ▁area ▁= ▁( ▁4 ▁/ ▁( ▁double ▁) ▁3 ▁) ▁* ▁sqrt ▁( ▁x ▁) ▁; ▁return ▁area ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁= ▁9 ▁; ▁int ▁b ▁= ▁12 ▁; ▁int ▁c ▁= ▁15 ▁; ▁double ▁ans ▁= ▁Area _ of _ Triangle ▁( ▁a ▁, ▁b ▁, ▁c ▁) ▁; ▁c out ▁<< ▁ans ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is T rid ec agon ▁( ▁int ▁N ▁) ▁{ ▁float ▁n ▁= ▁( ▁9 ▁+ ▁sqrt ▁( ▁88 ▁* ▁N ▁+ ▁81 ▁) ▁) ▁/ ▁22 ▁; ▁return ▁( ▁n ▁- ▁( ▁int ▁) ▁n ▁) ▁== ▁0 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁i ▁= ▁13 ▁; ▁if ▁( ▁is T rid ec agon ▁( ▁i ▁) ▁) ▁{ ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁" ▁No ▁" ▁; ▁} ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁check Overlap ▁( ▁int ▁R ▁, ▁int ▁X c ▁, ▁int ▁Y c ▁, ▁int ▁X 1 ▁, ▁int ▁Y 1 ▁, ▁int ▁X 2 ▁, ▁int ▁Y 2 ▁) ▁{ ▁int ▁X n ▁= ▁max ▁( ▁X 1 ▁, ▁min ▁( ▁X c ▁, ▁X 2 ▁) ▁) ▁; ▁int ▁Y n ▁= ▁max ▁( ▁Y 1 ▁, ▁min ▁( ▁Y c ▁, ▁Y 2 ▁) ▁) ▁; ▁int ▁D x ▁= ▁X n ▁- ▁X c ▁; ▁int ▁D y ▁= ▁Y n ▁- ▁Y c ▁; ▁return ▁( ▁D x ▁* ▁D x ▁+ ▁D y ▁* ▁D y ▁) ▁<= ▁R ▁* ▁R ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁R ▁= ▁1 ▁; ▁int ▁X c ▁= ▁0 ▁, ▁Y c ▁= ▁0 ▁; ▁int ▁X 1 ▁= ▁1 ▁, ▁Y 1 ▁= ▁-1 ▁; ▁int ▁X 2 ▁= ▁3 ▁, ▁Y 2 ▁= ▁1 ▁; ▁if ▁( ▁check Overlap ▁( ▁R ▁, ▁X c ▁, ▁Y c ▁, ▁X 1 ▁, ▁Y 1 ▁, ▁X 2 ▁, ▁Y 2 ▁) ▁) ▁{ ▁c out ▁<< ▁" ▁True ▁" ▁<< ▁end l ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁" ▁False ▁" ▁; ▁} ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁check Intersection ▁( ▁pair ▁< ▁int ▁, ▁int ▁> ▁p 1 ▁, ▁pair ▁< ▁int ▁, ▁int ▁> ▁p 2 ▁, ▁pair ▁< ▁int ▁, ▁int ▁> ▁p ▁) ▁{ ▁int ▁val ▁; ▁if ▁( ▁p 1 ▁. ▁second ▁== ▁p 2 ▁. ▁second ▁&& ▁p 1 ▁. ▁second ▁== ▁p ▁. ▁second ▁) ▁{ ▁if ▁( ▁p ▁. ▁first ▁<= ▁max ▁( ▁p 1 ▁. ▁first ▁, ▁p 2 ▁. ▁first ▁) ▁&& ▁( ▁p ▁. ▁first ▁>= ▁min ▁( ▁p 1 ▁. ▁first ▁, ▁p 2 ▁. ▁first ▁) ▁) ▁) ▁return ▁1 ▁; ▁} ▁if ▁( ▁p 1 ▁. ▁first ▁== ▁p 2 ▁. ▁first ▁&& ▁p 1 ▁. ▁first ▁== ▁p ▁. ▁first ▁) ▁{ ▁if ▁( ▁p ▁. ▁second ▁<= ▁max ▁( ▁p 1 ▁. ▁second ▁, ▁p 2 ▁. ▁second ▁) ▁&& ▁( ▁p ▁. ▁second ▁>= ▁min ▁( ▁p 1 ▁. ▁second ▁, ▁p 2 ▁. ▁second ▁) ▁) ▁) ▁return ▁1 ▁; ▁} ▁else ▁{ ▁val ▁= ▁( ▁p ▁. ▁second ▁- ▁p 1 ▁. ▁second ▁) ▁* ▁( ▁p 2 ▁. ▁first ▁- ▁p 1 ▁. ▁first ▁) ▁- ▁( ▁p ▁. ▁first ▁- ▁p 1 ▁. ▁first ▁) ▁* ▁( ▁p 2 ▁. ▁second ▁- ▁p 1 ▁. ▁second ▁) ▁; ▁if ▁( ▁val ▁== ▁0 ▁) ▁if ▁( ▁( ▁p ▁. ▁first ▁<= ▁max ▁( ▁p 1 ▁. ▁first ▁, ▁p 2 ▁. ▁first ▁) ▁&& ▁( ▁p ▁. ▁first ▁>= ▁min ▁( ▁p 1 ▁. ▁first ▁, ▁p 2 ▁. ▁first ▁) ▁) ▁) ▁&& ▁( ▁p ▁. ▁second ▁<= ▁max ▁( ▁p 1 ▁. ▁second ▁, ▁p 2 ▁. ▁second ▁) ▁&& ▁( ▁p ▁. ▁second ▁>= ▁min ▁( ▁p 1 ▁. ▁second ▁, ▁p 2 ▁. ▁second ▁) ▁) ▁) ▁) ▁return ▁1 ▁; ▁} ▁return ▁0 ▁; ▁} ▁void ▁tower Of S ight ▁( ▁pair ▁< ▁int ▁, ▁int ▁> ▁a ▁, ▁pair ▁< ▁int ▁, ▁int ▁> ▁b ▁, ▁pair ▁< ▁int ▁, ▁int ▁> ▁c ▁, ▁pair ▁< ▁int ▁, ▁int ▁> ▁d ▁) ▁{ ▁int ▁flag ▁= ▁0 ▁; ▁if ▁( ▁check Intersection ▁( ▁a ▁, ▁c ▁, ▁b ▁) ▁) ▁flag ▁= ▁1 ▁; ▁else ▁if ▁( ▁check Intersection ▁( ▁a ▁, ▁c ▁, ▁d ▁) ▁) ▁flag ▁= ▁1 ▁; ▁else ▁if
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁double ▁area ▁( ▁int ▁R ▁) ▁{ ▁double ▁base ▁= ▁1.7 32 ▁* ▁R ▁; ▁double ▁height ▁= ▁( ▁1.5 ▁) ▁* ▁R ▁; ▁double ▁area ▁= ▁0.5 ▁* ▁base ▁* ▁height ▁; ▁return ▁area ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁R ▁= ▁7 ▁; ▁c out ▁<< ▁( ▁area ▁( ▁R ▁) ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Pairs ▁( ▁int ▁* ▁P ▁, ▁int ▁* ▁Q ▁, ▁int ▁N ▁, ▁int ▁M ▁) ▁{ ▁int ▁A ▁[ ▁2 ▁] ▁= ▁{ ▁0 ▁} ▁, ▁B ▁[ ▁2 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁A ▁[ ▁P ▁[ ▁i ▁] ▁% ▁2 ▁] ▁++ ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁M ▁; ▁i ▁++ ▁) ▁B ▁[ ▁Q ▁[ ▁i ▁] ▁% ▁2 ▁] ▁++ ▁; ▁return ▁( ▁A ▁[ ▁0 ▁] ▁* ▁B ▁[ ▁0 ▁] ▁+ ▁A ▁[ ▁1 ▁] ▁* ▁B ▁[ ▁1 ▁] ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁P ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁2 ▁} ▁, ▁Q ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁0 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁P ▁) ▁/ ▁sizeof ▁( ▁P ▁[ ▁0 ▁] ▁) ▁; ▁int ▁M ▁= ▁sizeof ▁( ▁Q ▁) ▁/ ▁sizeof ▁( ▁Q ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁count Pairs ▁( ▁P ▁, ▁Q ▁, ▁N ▁, ▁M ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁# include ▁< math . h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁new _ vol ▁( ▁double ▁x ▁) ▁{ ▁if ▁( ▁x ▁> ▁0 ▁) ▁{ ▁c out ▁<< ▁" ▁% ▁change ▁in ▁the ▁" ▁<< ▁" ▁volume ▁of ▁the ▁h em is phere ▁: ▁" ▁<< ▁pow ▁( ▁x ▁, ▁3 ▁) ▁/ ▁10000 ▁+ ▁3 ▁* ▁x ▁+ ▁( ▁3 ▁* ▁pow ▁( ▁x ▁, ▁2 ▁) ▁) ▁/ ▁100 ▁<< ▁" ▁% ▁" ▁<< ▁" ▁increase ▁STRNEWLINE ▁" ▁; ▁} ▁else ▁if ▁( ▁x ▁< ▁0 ▁) ▁{ ▁c out ▁<< ▁" ▁% ▁change ▁in ▁the ▁" ▁<< ▁" ▁volume ▁of ▁the ▁h em is phere ▁: ▁" ▁<< ▁pow ▁( ▁x ▁, ▁3 ▁) ▁/ ▁10000 ▁+ ▁3 ▁* ▁x ▁+ ▁( ▁3 ▁* ▁pow ▁( ▁x ▁, ▁2 ▁) ▁) ▁/ ▁100 ▁<< ▁" ▁% ▁decrease ▁STRNEWLINE ▁" ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁" ▁Volume ▁remains ▁the ▁same ▁. ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁double ▁x ▁= ▁-10 .0 ▁; ▁new _ vol ▁( ▁x ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Inter sections ▁( ▁int ▁n ▁) ▁{ ▁return ▁n ▁* ▁( ▁n ▁- ▁1 ▁) ▁/ ▁2 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁3 ▁; ▁c out ▁<< ▁count Inter sections ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁float ▁Area ▁( ▁int ▁d ▁, ▁int ▁h 1 ▁, ▁int ▁h 2 ▁) ▁{ ▁float ▁area ▁; ▁area ▁= ▁0.5 ▁* ▁d ▁* ▁( ▁h 1 ▁+ ▁h 2 ▁) ▁; ▁return ▁area ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁d ▁= ▁6 ▁, ▁h 1 ▁= ▁4 ▁, ▁h 2 ▁= ▁3 ▁; ▁c out ▁<< ▁" ▁Area ▁of ▁Quad r il ater al ▁= ▁" ▁<< ▁( ▁Area ▁( ▁d ▁, ▁h 1 ▁, ▁h 2 ▁) ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁angle ext cy c quad ▁( ▁int ▁z ▁) ▁{ ▁c out ▁<< ▁" ▁The ▁ex ter ior ▁angle ▁of ▁the ▁" ▁<< ▁" ▁cyclic ▁quad r il ater al ▁is ▁" ▁<< ▁z ▁<< ▁" ▁degrees ▁" ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁z ▁= ▁48 ▁; ▁angle ext cy c quad ▁( ▁z ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁is Perf ect ▁( ▁int ▁N ▁) ▁{ ▁int ▁sum Of Div is ors ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁N ▁/ ▁2 ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁N ▁% ▁i ▁== ▁0 ▁) ▁{ ▁sum Of Div is ors ▁+= ▁i ▁; ▁} ▁} ▁if ▁( ▁sum Of Div is ors ▁== ▁N ▁) ▁{ ▁return ▁1 ▁; ▁} ▁else ▁return ▁0 ▁; ▁} ▁int ▁sum Of Digits ▁( ▁int ▁N ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁while ▁( ▁N ▁!= ▁0 ▁) ▁{ ▁sum ▁+= ▁( ▁N ▁% ▁10 ▁) ▁; ▁N ▁= ▁N ▁/ ▁10 ▁; ▁} ▁return ▁sum ▁; ▁} ▁void ▁count Perf ect Numbers ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁is Perf ect ▁( ▁arr ▁[ ▁i ▁] ▁) ▁) ▁{ ▁int ▁sum ▁= ▁sum Of Digits ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁if ▁( ▁is Perf ect ▁( ▁sum ▁) ▁) ▁{ ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁} ▁} ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁8 ▁, ▁12 ▁, ▁28 ▁, ▁6 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁count Perf ect Numbers ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁f izz B uzz ▁( ▁int ▁N ▁) ▁{ ▁int ▁count 3 ▁= ▁0 ▁; ▁int ▁count 5 ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁count 3 ▁++ ▁; ▁count 5 ▁++ ▁; ▁bool ▁flag ▁= ▁false ▁; ▁if ▁( ▁count 3 ▁== ▁3 ▁) ▁{ ▁c out ▁<< ▁" ▁F izz ▁" ▁; ▁count 3 ▁= ▁0 ▁; ▁flag ▁= ▁true ▁; ▁} ▁if ▁( ▁count 5 ▁== ▁5 ▁) ▁{ ▁c out ▁<< ▁" ▁B uzz ▁" ▁; ▁count 5 ▁= ▁0 ▁; ▁flag ▁= ▁true ▁; ▁} ▁if ▁( ▁! ▁flag ▁) ▁{ ▁c out ▁<< ▁i ▁; ▁} ▁c out ▁<< ▁" ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁15 ▁; ▁f izz B uzz ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Pairs ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁j ▁] ▁!= ▁0 ▁&& ▁a ▁[ ▁i ▁] ▁% ▁a ▁[ ▁j ▁] ▁== ▁0 ▁) ▁{ ▁if ▁( ▁( ▁a ▁[ ▁i ▁] ▁+ ▁a ▁[ ▁j ▁] ▁) ▁== ▁( ▁a ▁[ ▁i ▁] ▁/ ▁a ▁[ ▁j ▁] ▁) ▁) ▁count ▁++ ▁; ▁} ▁} ▁} ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁-4 ▁, ▁-3 ▁, ▁0 ▁, ▁2 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁count Pairs ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁numberOf Tiles ▁( ▁int ▁N ▁, ▁int ▁M ▁) ▁{ ▁if ▁( ▁N ▁% ▁2 ▁== ▁1 ▁) ▁{ ▁return ▁-1 ▁; ▁} ▁return ▁( ▁N ▁* ▁1 LL ▁* ▁M ▁) ▁/ ▁2 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁2 ▁, ▁M ▁= ▁4 ▁; ▁c out ▁<< ▁numberOf Tiles ▁( ▁N ▁, ▁M ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁check Same Position ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁unordered _ map ▁< ▁int ▁, ▁int ▁> ▁mp ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁temp ▁= ▁( ▁( ▁i ▁+ ▁arr ▁[ ▁i ▁] ▁) ▁% ▁n ▁+ ▁n ▁) ▁% ▁n ▁; ▁if ▁( ▁mp ▁. ▁find ▁( ▁temp ▁) ▁!= ▁mp ▁. ▁end ▁( ▁) ▁) ▁{ ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁return ▁; ▁} ▁mp ▁[ ▁temp ▁] ▁++ ▁; ▁} ▁c out ▁<< ▁" ▁No ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁4 ▁, ▁3 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁check Same Position ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁convertTo ASCII ▁( ▁int ▁N ▁) ▁{ ▁string ▁num ▁= ▁to _ string ▁( ▁N ▁) ▁; ▁for ▁( ▁char ▁ch ▁: ▁num ▁) ▁{ ▁c out ▁<< ▁ch ▁<< ▁" ▁( ▁" ▁<< ▁( ▁int ▁) ▁ch ▁<< ▁" ▁) ▁STRNEWLINE ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁36 ▁; ▁convertTo ASCII ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁check Possible ▁( ▁int ▁* ▁arr ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁) ▁{ ▁c out ▁<< ▁" ▁No ▁STRNEWLINE ▁" ▁; ▁return ▁; ▁} ▁else ▁{ ▁arr ▁[ ▁i ▁] ▁-= ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁; ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁= ▁0 ▁; ▁} ▁} ▁if ▁( ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁== ▁0 ▁) ▁{ ▁c out ▁<< ▁" ▁Yes ▁STRNEWLINE ▁" ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁" ▁No ▁STRNEWLINE ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁3 ▁, ▁4 ▁, ▁2 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁check Possible ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁single Digit Sub array Count ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁res ▁= ▁0 ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁<= ▁9 ▁) ▁{ ▁count ▁++ ▁; ▁res ▁+= ▁count ▁; ▁} ▁else ▁{ ▁count ▁= ▁0 ▁; ▁} ▁} ▁c out ▁<< ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁1 ▁, ▁14 ▁, ▁2 ▁, ▁5 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁single Digit Sub array Count ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁long ▁long ▁int ▁Fact ▁( ▁int ▁N ▁) ▁{ ▁long ▁long ▁int ▁result ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁result ▁= ▁( ▁result ▁* ▁i ▁) ▁; ▁} ▁return ▁result ▁; ▁} ▁void ▁numberOf W ays ▁( ▁int ▁M ▁, ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁B ▁[ ▁M ▁] ▁= ▁{ ▁0 ▁} ▁; ▁int ▁counter ▁[ ▁M ▁+ ▁1 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁!= ▁0 ▁) ▁{ ▁if ▁( ▁B ▁[ ▁i ▁% ▁M ▁] ▁== ▁0 ▁) ▁{ ▁B ▁[ ▁i ▁% ▁M ▁] ▁= ▁arr ▁[ ▁i ▁] ▁; ▁counter ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁++ ▁; ▁if ▁( ▁counter ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁> ▁1 ▁) ▁{ ▁c out ▁<< ▁0 ▁<< ▁end l ▁; ▁return ▁; ▁} ▁} ▁else ▁if ▁( ▁B ▁[ ▁i ▁% ▁M ▁] ▁!= ▁arr ▁[ ▁i ▁] ▁) ▁{ ▁c out ▁<< ▁0 ▁<< ▁end l ▁; ▁return ▁; ▁} ▁} ▁} ▁int ▁cnt ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁M ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁B ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁cnt ▁++ ▁; ▁} ▁} ▁c out ▁<< ▁Fact ▁( ▁cnt ▁) ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁M ▁= ▁4 ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁0 ▁, ▁3 ▁, ▁0 ▁, ▁0 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁numberOf W ays ▁( ▁M ▁, ▁arr ▁, ▁N ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁typedef ▁long ▁long ▁ll ▁; ▁void ▁no Of Arrays Possible ▁( ▁ll ▁N ▁, ▁ll ▁M ▁) ▁{ ▁ll ▁ans ▁= ▁1 ▁; ▁for ▁( ▁ll ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁++ ▁i ▁) ▁{ ▁ans ▁= ▁ans ▁* ▁( ▁M ▁- ▁i ▁) ▁; ▁} ▁c out ▁<< ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁ll ▁N ▁= ▁2 ▁, ▁M ▁= ▁3 ▁; ▁no Of Arrays Possible ▁( ▁N ▁, ▁M ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁Minimum Operation Req ▁( ▁int ▁N ▁) ▁{ ▁int ▁cnt Dec r ▁= ▁0 ▁; ▁int ▁temp ▁= ▁N ▁; ▁while ▁( ▁temp ▁> ▁0 ▁) ▁{ ▁int ▁X ▁= ▁sqrt ▁( ▁temp ▁) ▁; ▁if ▁( ▁X ▁* ▁X ▁== ▁temp ▁) ▁{ ▁break ▁; ▁} ▁temp ▁= ▁temp ▁- ▁2 ▁; ▁cnt Dec r ▁+= ▁1 ▁; ▁} ▁int ▁cnt In cr ▁= ▁0 ▁; ▁while ▁( ▁true ▁) ▁{ ▁int ▁X ▁= ▁sqrt ▁( ▁N ▁) ▁; ▁if ▁( ▁X ▁* ▁X ▁== ▁N ▁) ▁{ ▁break ▁; ▁} ▁N ▁= ▁N ▁+ ▁2 ▁; ▁cnt In cr ▁+= ▁1 ▁; ▁} ▁return ▁min ▁( ▁cnt In cr ▁, ▁cnt Dec r ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁15 ▁; ▁c out ▁<< ▁Minimum Operation Req ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max Disconnected ▁( ▁int ▁N ▁, ▁int ▁E ▁) ▁{ ▁int ▁curr ▁= ▁1 ▁; ▁int ▁rem ▁= ▁E ▁; ▁while ▁( ▁rem ▁> ▁0 ▁) ▁{ ▁rem ▁= ▁rem ▁- ▁min ▁( ▁curr ▁, ▁rem ▁) ▁; ▁curr ▁++ ▁; ▁} ▁if ▁( ▁curr ▁> ▁1 ▁) ▁{ ▁return ▁N ▁- ▁curr ▁; ▁} ▁else ▁{ ▁return ▁N ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁5 ▁, ▁E ▁= ▁1 ▁; ▁c out ▁<< ▁max Disconnected ▁( ▁N ▁, ▁E ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is Prime ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁<= ▁1 ▁) ▁return ▁false ▁; ▁if ▁( ▁n ▁<= ▁3 ▁) ▁return ▁true ▁; ▁if ▁( ▁n ▁% ▁2 ▁== ▁0 ▁n ▁% ▁3 ▁== ▁0 ▁) ▁return ▁false ▁; ▁for ▁( ▁int ▁i ▁= ▁5 ▁; ▁i ▁* ▁i ▁<= ▁n ▁; ▁i ▁= ▁i ▁+ ▁6 ▁) ▁if ▁( ▁n ▁% ▁i ▁== ▁0 ▁|| ▁n ▁% ▁( ▁i ▁+ ▁2 ▁) ▁== ▁0 ▁) ▁return ▁false ▁; ▁return ▁true ▁; ▁} ▁string ▁delete I th ▁( ▁string ▁str ▁, ▁int ▁i ▁) ▁{ ▁str ▁. ▁erase ▁( ▁str ▁. ▁begin ▁( ▁) ▁+ ▁i ▁) ▁; ▁return ▁str ▁; ▁} ▁bool ▁is Prime Possible ▁( ▁int ▁N ▁) ▁{ ▁string ▁s ▁= ▁to _ string ▁( ▁N ▁) ▁; ▁int ▁l ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁if ▁( ▁l ▁< ▁2 ▁) ▁return ▁false ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁l ▁; ▁i ▁++ ▁) ▁{ ▁string ▁str ▁= ▁delete I th ▁( ▁s ▁, ▁i ▁) ▁; ▁int ▁num ▁= ▁sto i ▁( ▁str ▁) ▁; ▁if ▁( ▁is Prime ▁( ▁num ▁) ▁) ▁return ▁true ▁; ▁} ▁return ▁false ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁6 10 ▁; ▁is Prime Possible ▁( ▁N ▁) ▁? ▁c out ▁<< ▁" ▁Yes ▁" ▁: ▁c out ▁<< ▁" ▁No ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁Find _ min ▁( ▁set ▁< ▁int ▁> ▁& ▁diff _ mod ▁, ▁map ▁< ▁int ▁, ▁int ▁> ▁count _ mod ▁, ▁int ▁k ▁) ▁{ ▁int ▁min _ op rn ▁= ▁INT _ MAX ▁; ▁int ▁op rn ▁= ▁0 ▁; ▁for ▁( ▁int ▁x ▁= ▁0 ▁; ▁x ▁< ▁k ▁; ▁x ▁++ ▁) ▁{ ▁op rn ▁= ▁0 ▁; ▁for ▁( ▁auto ▁w ▁: ▁diff _ mod ▁) ▁{ ▁if ▁( ▁w ▁!= ▁x ▁) ▁{ ▁if ▁( ▁w ▁== ▁0 ▁) ▁{ ▁op rn ▁+= ▁min ▁( ▁x ▁, ▁k ▁- ▁x ▁) ▁* ▁count _ mod ▁[ ▁w ▁] ▁; ▁} ▁else ▁{ ▁op rn ▁+= ▁min ▁( ▁abs ▁( ▁x ▁- ▁w ▁) ▁, ▁k ▁+ ▁x ▁- ▁w ▁) ▁* ▁count _ mod ▁[ ▁w ▁] ▁; ▁} ▁} ▁} ▁if ▁( ▁op rn ▁< ▁min _ op rn ▁) ▁min _ op rn ▁= ▁op rn ▁; ▁} ▁return ▁min _ op rn ▁; ▁} ▁int ▁Cal _ min ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁set ▁< ▁int ▁> ▁diff _ mod ▁; ▁map ▁< ▁int ▁, ▁int ▁> ▁count _ mod ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁diff _ mod ▁. ▁insert ▁( ▁arr ▁[ ▁i ▁] ▁% ▁k ▁) ▁; ▁count _ mod ▁[ ▁arr ▁[ ▁i ▁] ▁% ▁k ▁] ▁++ ▁; ▁} ▁return ▁Find _ min ▁( ▁diff _ mod ▁, ▁count _ mod ▁, ▁k ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁35 ▁, ▁48 ▁, ▁23 ▁, ▁52 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁k ▁= ▁3 ▁; ▁c out ▁<< ▁Cal _ min ▁( ▁arr ▁, ▁n ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁inverse Equal ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁br r ▁[ ▁n ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁present _ index ▁= ▁arr ▁[ ▁i ▁] ▁- ▁1 ▁; ▁br r ▁[ ▁present _ index ▁] ▁= ▁i ▁+ ▁1 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁!= ▁br r ▁[ ▁i ▁] ▁) ▁{ ▁c out ▁<< ▁" ▁No ▁" ▁<< ▁end l ▁; ▁return ▁; ▁} ▁} ▁c out ▁<< ▁" ▁Yes ▁" ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁4 ▁; ▁int ▁arr ▁[ ▁n ▁] ▁= ▁{ ▁1 ▁, ▁4 ▁, ▁3 ▁, ▁2 ▁} ▁; ▁inverse Equal ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁Square Root ▁( ▁int ▁num ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁n ▁= ▁1 ▁; ▁n ▁<= ▁num ▁; ▁n ▁+= ▁2 ▁) ▁{ ▁num ▁= ▁num ▁- ▁n ▁; ▁count ▁+= ▁1 ▁; ▁if ▁( ▁num ▁== ▁0 ▁) ▁break ▁; ▁} ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁81 ▁; ▁c out ▁<< ▁Square Root ▁( ▁N ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find W inner ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁cnt ▁= ▁0 ▁; ▁if ▁( ▁n ▁== ▁1 ▁) ▁c out ▁<< ▁" ▁No ▁" ▁<< ▁end l ▁; ▁else ▁if ▁( ▁( ▁n ▁& ▁1 ▁) ▁or ▁n ▁== ▁2 ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁<< ▁end l ▁; ▁else ▁{ ▁int ▁tmp ▁= ▁n ▁; ▁int ▁val ▁= ▁1 ▁; ▁while ▁( ▁tmp ▁> ▁k ▁and ▁tmp ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁tmp ▁/= ▁2 ▁; ▁val ▁*= ▁2 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁3 ▁; ▁i ▁<= ▁sqrt ▁( ▁tmp ▁) ▁; ▁i ▁++ ▁) ▁{ ▁while ▁( ▁tmp ▁% ▁i ▁== ▁0 ▁) ▁{ ▁cnt ▁++ ▁; ▁tmp ▁/= ▁i ▁; ▁} ▁} ▁if ▁( ▁tmp ▁> ▁1 ▁) ▁cnt ▁++ ▁; ▁if ▁( ▁val ▁== ▁n ▁) ▁c out ▁<< ▁" ▁No ▁" ▁<< ▁end l ▁; ▁else ▁if ▁( ▁n ▁/ ▁tmp ▁== ▁2 ▁and ▁cnt ▁== ▁1 ▁) ▁c out ▁<< ▁" ▁No ▁" ▁<< ▁end l ▁; ▁else ▁c out ▁<< ▁" ▁Yes ▁" ▁<< ▁end l ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁long ▁long ▁n ▁= ▁1 ▁, ▁k ▁= ▁1 ▁; ▁find W inner ▁( ▁n ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count _ c ra zy _ pr imes ▁( ▁int ▁L ▁, ▁int ▁R ▁) ▁{ ▁int ▁prime ▁[ ▁R ▁+ ▁1 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁int ▁count Prime ▁[ ▁R ▁+ ▁1 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁int ▁freq Prime ▁[ ▁R ▁+ ▁1 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁prime ▁[ ▁0 ▁] ▁= ▁prime ▁[ ▁1 ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁* ▁p ▁<= ▁R ▁; ▁p ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁p ▁] ▁== ▁0 ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁p ▁* ▁p ▁; ▁i ▁<= ▁R ▁; ▁i ▁+= ▁p ▁) ▁prime ▁[ ▁i ▁] ▁= ▁1 ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁R ▁; ▁i ▁++ ▁) ▁{ ▁count Prime ▁[ ▁i ▁] ▁= ▁count Prime ▁[ ▁i ▁- ▁1 ▁] ▁; ▁if ▁( ▁! ▁prime ▁[ ▁i ▁] ▁) ▁{ ▁count Prime ▁[ ▁i ▁] ▁++ ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁R ▁; ▁i ▁++ ▁) ▁{ ▁freq Prime ▁[ ▁i ▁] ▁= ▁freq Prime ▁[ ▁i ▁- ▁1 ▁] ▁; ▁if ▁( ▁! ▁prime ▁[ ▁count Prime ▁[ ▁i ▁] ▁] ▁) ▁{ ▁freq Prime ▁[ ▁i ▁] ▁++ ▁; ▁} ▁} ▁return ▁( ▁freq Prime ▁[ ▁R ▁] ▁- ▁freq Prime ▁[ ▁L ▁- ▁1 ▁] ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁L ▁= ▁4 ▁, ▁R ▁= ▁12 ▁; ▁c out ▁<< ▁count _ c ra zy _ pr imes ▁( ▁L ▁, ▁R ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁compute ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁map ▁< ▁long ▁, ▁long ▁> ▁eq Val ▁; ▁long ▁maxX ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁long ▁val ▁= ▁a ▁[ ▁i ▁] ▁% ▁K ▁; ▁val ▁= ▁( ▁val ▁== ▁0 ▁? ▁0 ▁: ▁K ▁- ▁val ▁) ▁; ▁if ▁( ▁val ▁== ▁0 ▁) ▁continue ▁; ▁if ▁( ▁eq Val ▁. ▁find ▁( ▁val ▁) ▁!= ▁eq Val ▁. ▁end ▁( ▁) ▁) ▁{ ▁long ▁num Val ▁= ▁eq Val ▁[ ▁val ▁] ▁; ▁maxX ▁= ▁max ▁( ▁maxX ▁, ▁val ▁+ ▁( ▁K ▁* ▁num Val ▁) ▁) ▁; ▁eq Val ▁[ ▁val ▁] ▁++ ▁; ▁} ▁else ▁{ ▁eq Val ▁[ ▁val ▁] ▁++ ▁; ▁maxX ▁= ▁max ▁( ▁maxX ▁, ▁val ▁) ▁; ▁} ▁} ▁c out ▁<< ▁( ▁maxX ▁== ▁0 ▁? ▁0 ▁: ▁maxX ▁+ ▁1 ▁) ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁K ▁= ▁3 ▁; ▁int ▁a ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁2 ▁, ▁18 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁compute ▁( ▁a ▁, ▁N ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁getSum ▁( ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁while ▁( ▁n ▁!= ▁0 ▁) ▁{ ▁sum ▁= ▁sum ▁+ ▁n ▁% ▁10 ▁; ▁n ▁= ▁n ▁/ ▁10 ▁; ▁} ▁return ▁sum ▁; ▁} ▁bool ▁is Self Num ▁( ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁m ▁= ▁1 ▁; ▁m ▁<= ▁n ▁; ▁m ▁++ ▁) ▁{ ▁if ▁( ▁m ▁+ ▁getSum ▁( ▁m ▁) ▁== ▁n ▁) ▁return ▁false ▁; ▁} ▁return ▁true ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁20 ▁; ▁if ▁( ▁is Self Num ▁( ▁n ▁) ▁) ▁{ ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁" ▁No ▁" ▁; ▁} ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁series Sum Util ▁( ▁int ▁k ▁, ▁int ▁n ▁, ▁int ▁prev Sum ▁, ▁int ▁multi ▁, ▁int ▁add ▁) ▁{ ▁if ▁( ▁k ▁== ▁n ▁+ ▁1 ▁) ▁{ ▁return ▁prev Sum ▁; ▁} ▁multi ▁= ▁multi ▁* ▁k ▁; ▁add ▁= ▁add ▁+ ▁k ▁; ▁prev Sum ▁= ▁prev Sum ▁+ ▁multi ▁- ▁add ▁; ▁return ▁series Sum Util ▁( ▁k ▁+ ▁1 ▁, ▁n ▁, ▁prev Sum ▁, ▁multi ▁, ▁add ▁) ▁; ▁} ▁int ▁series Sum ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁1 ▁) ▁return ▁0 ▁; ▁int ▁prev Sum ▁= ▁0 ▁; ▁int ▁multi ▁= ▁1 ▁; ▁int ▁add ▁= ▁1 ▁; ▁return ▁series Sum Util ▁( ▁2 ▁, ▁n ▁, ▁prev Sum ▁, ▁multi ▁, ▁add ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁5 ▁; ▁c out ▁<< ▁series Sum ▁( ▁N ▁) ▁<< ▁" ▁" ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁# include ▁< math . h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁getSum ▁( ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁while ▁( ▁n ▁!= ▁0 ▁) ▁{ ▁sum ▁= ▁sum ▁+ ▁n ▁% ▁10 ▁; ▁n ▁= ▁n ▁/ ▁10 ▁; ▁} ▁return ▁sum ▁; ▁} ▁void ▁smallest Number ▁( ▁int ▁N ▁) ▁{ ▁int ▁i ▁= ▁1 ▁; ▁while ▁( ▁1 ▁) ▁{ ▁if ▁( ▁getSum ▁( ▁i ▁) ▁== ▁N ▁) ▁{ ▁c out ▁<< ▁i ▁; ▁break ▁; ▁} ▁i ▁++ ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁10 ▁; ▁smallest Number ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is z yg od rome Num ▁( ▁int ▁N ▁) ▁{ ▁string ▁s ▁= ▁to _ string ▁( ▁N ▁) ▁; ▁s ▁= ▁' ▁' ▁+ ▁s ▁+ ▁' ▁' ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁s ▁. ▁size ▁( ▁) ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁[ ▁i ▁] ▁!= ▁s ▁[ ▁i ▁- ▁1 ▁] ▁&& ▁s ▁[ ▁i ▁] ▁!= ▁s ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁{ ▁return ▁false ▁; ▁} ▁} ▁return ▁true ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁112 2 ▁; ▁if ▁( ▁is z yg od rome Num ▁( ▁n ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁can Replace ▁( ▁int ▁array ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁i ▁= ▁0 ▁, ▁count ▁= ▁0 ▁; ▁while ▁( ▁i ▁< ▁n ▁) ▁{ ▁if ▁( ▁array ▁[ ▁i ▁] ▁== ▁0 ▁&& ▁( ▁i ▁== ▁0 ▁array ▁[ ▁i ▁- ▁1 ▁] ▁== ▁0 ▁) ▁&& ▁( ▁i ▁== ▁n ▁- ▁1 ▁array ▁[ ▁i ▁+ ▁1 ▁] ▁== ▁0 ▁) ▁) ▁{ ▁array ▁[ ▁i ▁] ▁= ▁1 ▁; ▁count ▁++ ▁; ▁} ▁i ▁++ ▁; ▁} ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁array ▁[ ▁5 ▁] ▁= ▁{ ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁} ▁; ▁c out ▁<< ▁can Replace ▁( ▁array ▁, ▁5 ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁M eg agon Num ▁( ▁int ▁n ▁) ▁{ ▁return ▁( ▁9 9999 8 ▁* ▁n ▁* ▁n ▁- ▁9 9999 6 ▁* ▁n ▁) ▁/ ▁2 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁3 ▁; ▁c out ▁<< ▁M eg agon Num ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁T et ra cont ao ct ag onal Num ▁( ▁int ▁n ▁) ▁{ ▁return ▁( ▁46 ▁* ▁n ▁* ▁n ▁- ▁44 ▁* ▁n ▁) ▁/ ▁2 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁3 ▁; ▁c out ▁<< ▁T et ra cont ao ct ag onal Num ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Index ▁( ▁int ▁n ▁) ▁{ ▁float ▁x ▁= ▁sqrt ▁( ▁2 ▁* ▁pow ▁( ▁10 ▁, ▁( ▁n ▁- ▁1 ▁) ▁) ▁) ▁; ▁return ▁round ▁( ▁x ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁3 ▁; ▁c out ▁<< ▁find Index ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁# include ▁< math . h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁smallest Number ▁( ▁int ▁N ▁) ▁{ ▁c out ▁<< ▁N ▁* ▁floor ▁( ▁( ▁pow ▁( ▁10 ▁, ▁N ▁) ▁- ▁1 ▁) ▁/ ▁N ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁2 ▁; ▁smallest Number ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁ic os ik ai he pt ag onal Num ▁( ▁int ▁n ▁) ▁{ ▁return ▁( ▁25 ▁* ▁n ▁* ▁n ▁- ▁23 ▁* ▁n ▁) ▁/ ▁2 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁3 ▁; ▁c out ▁<< ▁"3 rd ▁ic os ik ai he pt ag onal ▁Number ▁is ▁" ▁<< ▁ic os ik ai he pt ag onal Num ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁i stri a cont ag onal ▁( ▁int ▁N ▁) ▁{ ▁float ▁n ▁= ▁( ▁26 ▁+ ▁sqrt ▁( ▁224 ▁* ▁N ▁+ ▁6 76 ▁) ▁) ▁/ ▁56 ▁; ▁return ▁( ▁n ▁- ▁( ▁int ▁) ▁n ▁) ▁== ▁0 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁i ▁= ▁30 ▁; ▁if ▁( ▁i stri a cont ag onal ▁( ▁i ▁) ▁) ▁{ ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁" ▁No ▁" ▁; ▁} ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁Max length ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁vector ▁< ▁int ▁> ▁zero index ▁; ▁int ▁maxlen ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁0 ▁) ▁zero index ▁. ▁push _ back ▁( ▁i ▁) ▁; ▁} ▁if ▁( ▁zero index ▁. ▁size ▁( ▁) ▁== ▁0 ▁) ▁{ ▁maxlen ▁= ▁N ▁; ▁} ▁else ▁{ ▁maxlen ▁= ▁zero index ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁zero index ▁. ▁size ▁( ▁) ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁zero index ▁[ ▁i ▁+ ▁1 ▁] ▁- ▁zero index ▁[ ▁i ▁] ▁- ▁1 ▁> ▁maxlen ▁) ▁{ ▁maxlen ▁= ▁zero index ▁[ ▁i ▁+ ▁1 ▁] ▁- ▁zero index ▁[ ▁i ▁] ▁- ▁1 ▁; ▁} ▁} ▁if ▁( ▁N ▁- ▁zero index ▁[ ▁zero index ▁. ▁size ▁( ▁) ▁- ▁1 ▁] ▁- ▁1 ▁> ▁maxlen ▁) ▁{ ▁maxlen ▁= ▁N ▁- ▁zero index ▁[ ▁zero index ▁. ▁size ▁( ▁) ▁- ▁1 ▁] ▁- ▁1 ▁; ▁} ▁} ▁c out ▁<< ▁maxlen ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁9 ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁7 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁2 ▁, ▁0 ▁, ▁9 ▁, ▁2 ▁, ▁1 ▁} ▁; ▁Max length ▁( ▁arr ▁, ▁N ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁solve ▁( ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁x ▁= ▁1 ▁; ▁x ▁<= ▁sqrt ▁( ▁n ▁) ▁; ▁x ▁++ ▁) ▁{ ▁if ▁( ▁n ▁% ▁x ▁== ▁0 ▁) ▁{ ▁int ▁small ▁= ▁x ▁; ▁int ▁big ▁= ▁n ▁/ ▁x ▁; ▁if ▁( ▁small ▁% ▁2 ▁== ▁big ▁% ▁2 ▁) ▁{ ▁int ▁a ▁= ▁( ▁small ▁+ ▁big ▁) ▁/ ▁2 ▁; ▁int ▁b ▁= ▁( ▁big ▁- ▁small ▁) ▁/ ▁2 ▁; ▁c out ▁<< ▁a ▁<< ▁" ▁" ▁<< ▁b ▁<< ▁end l ▁; ▁return ▁; ▁} ▁} ▁} ▁c out ▁<< ▁-1 ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁7 ▁; ▁solve ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁inv ▁( ▁int ▁a ▁, ▁int ▁m ▁) ▁{ ▁int ▁m 0 ▁= ▁m ▁, ▁t ▁, ▁q ▁; ▁int ▁x 0 ▁= ▁0 ▁, ▁x 1 ▁= ▁1 ▁; ▁if ▁( ▁m ▁== ▁1 ▁) ▁return ▁0 ▁; ▁while ▁( ▁a ▁> ▁1 ▁) ▁{ ▁q ▁= ▁a ▁/ ▁m ▁; ▁t ▁= ▁m ▁; ▁m ▁= ▁a ▁% ▁m ▁; ▁a ▁= ▁t ▁; ▁t ▁= ▁x 0 ▁; ▁x 0 ▁= ▁x 1 ▁- ▁q ▁* ▁x 0 ▁; ▁x 1 ▁= ▁t ▁; ▁} ▁if ▁( ▁x 1 ▁< ▁0 ▁) ▁x 1 ▁+= ▁m 0 ▁; ▁return ▁x 1 ▁; ▁} ▁int ▁derivative ▁( ▁int ▁x ▁) ▁{ ▁return ▁3 ▁* ▁x ▁* ▁x ▁; ▁} ▁int ▁Image ▁( ▁int ▁x ▁, ▁int ▁k ▁) ▁{ ▁return ▁x ▁* ▁x ▁* ▁x ▁- ▁k ▁; ▁} ▁int ▁next _ power ▁( ▁int ▁a _ t ▁, ▁int ▁t ▁, ▁int ▁a 1 ▁, ▁int ▁prime ▁, ▁int ▁k ▁) ▁{ ▁int ▁power _ p ▁= ▁( ▁int ▁) ▁pow ▁( ▁prime ▁, ▁t ▁+ ▁1 ▁) ▁; ▁int ▁next _ a ▁= ▁( ▁a _ t ▁- ▁Image ▁( ▁a _ t ▁, ▁k ▁) ▁* ▁inv ▁( ▁derivative ▁( ▁a 1 ▁) ▁, ▁prime ▁) ▁) ▁% ▁power _ p ▁; ▁if ▁( ▁next _ a ▁< ▁0 ▁) ▁return ▁next _ a ▁+= ▁power _ p ▁; ▁return ▁next _ a ▁; ▁} ▁int ▁power Of Prime ▁( ▁int ▁prime ▁, ▁int ▁power ▁, ▁int ▁k ▁, ▁int ▁a 1 ▁) ▁{ ▁if ▁( ▁derivative ▁( ▁a 1 ▁) ▁!= ▁0 ▁) ▁{ ▁int ▁a _ t ▁= ▁a 1 ▁; ▁for ▁( ▁int ▁p ▁= ▁1 ▁; ▁p ▁< ▁power ▁; ▁p ▁++ ▁) ▁{ ▁a _ t ▁= ▁next _ power ▁( ▁a _ t ▁, ▁p ▁, ▁a 1 ▁, ▁prime ▁, ▁k ▁) ▁; ▁} ▁return ▁a _ t ▁; ▁} ▁return ▁-1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁prime ▁= ▁7 ▁, ▁a 1 ▁= ▁3 ▁; ▁int ▁power ▁= ▁2 ▁, ▁k ▁= ▁3 ▁; ▁c out ▁<< ▁power Of Prime ▁( ▁prime ▁, ▁power ▁, ▁k ▁, ▁a 1 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁mod ▁100 000000 7 ▁NEW _ LINE ▁int ▁product Pairs ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁product ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁product ▁*= ▁( ▁arr ▁[ ▁i ▁] ▁% ▁mod ▁* ▁arr ▁[ ▁j ▁] ▁% ▁mod ▁) ▁% ▁mod ▁; ▁product ▁= ▁product ▁% ▁mod ▁; ▁} ▁} ▁return ▁product ▁% ▁mod ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁product Pairs ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁getMin Steps ▁( ▁int ▁n ▁, ▁int ▁jump ▁) ▁{ ▁int ▁quot ient ▁= ▁n ▁/ ▁jump ▁; ▁int ▁remainder ▁= ▁n ▁% ▁jump ▁; ▁int ▁steps ▁= ▁quot ient ▁+ ▁remainder ▁; ▁return ▁steps ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁6 ▁, ▁K ▁= ▁3 ▁; ▁c out ▁<< ▁getMin Steps ▁( ▁N ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is Center ed non ad ec ag onal ▁( ▁int ▁N ▁) ▁{ ▁float ▁n ▁= ▁( ▁19 ▁+ ▁sqrt ▁( ▁15 2 ▁* ▁N ▁+ ▁20 9 ▁) ▁) ▁/ ▁38 ▁; ▁return ▁( ▁n ▁- ▁( ▁int ▁) ▁n ▁) ▁== ▁0 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁20 ▁; ▁if ▁( ▁is Center ed non ad ec ag onal ▁( ▁n ▁) ▁) ▁{ ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁" ▁No ▁" ▁; ▁} ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁cnt Array ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁result ▁= ▁0 ▁; ▁int ▁frequency ▁[ ▁N ▁+ ▁1 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁frequency ▁[ ▁A ▁[ ▁i ▁] ▁] ▁++ ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁int ▁frequency _ of _ i ▁= ▁frequency ▁[ ▁i ▁] ▁; ▁result ▁+= ▁+ ▁( ▁( ▁frequency _ of _ i ▁) ▁* ▁( ▁frequency _ of _ i ▁+ ▁1 ▁) ▁) ▁/ ▁2 ▁; ▁} ▁c out ▁<< ▁result ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁5 ▁, ▁6 ▁, ▁1 ▁, ▁9 ▁, ▁5 ▁, ▁8 ▁, ▁10 ▁, ▁8 ▁, ▁9 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁A ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁cnt Array ▁( ▁A ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁sub array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁ans ▁= ▁1 ▁, ▁temp ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁) ▁{ ▁++ ▁temp ▁; ▁} ▁else ▁{ ▁ans ▁= ▁max ▁( ▁ans ▁, ▁temp ▁) ▁; ▁temp ▁= ▁1 ▁; ▁} ▁} ▁ans ▁= ▁max ▁( ▁ans ▁, ▁temp ▁) ▁; ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁2 ▁, ▁1 ▁, ▁1 ▁, ▁2 ▁, ▁2 ▁, ▁2 ▁, ▁3 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁sub array ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find Max Min Sub Array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁K ▁, ▁int ▁n ▁) ▁{ ▁int ▁min ▁= ▁n ▁; ▁int ▁max ▁= ▁0 ▁; ▁int ▁left ▁; ▁int ▁right ▁; ▁int ▁tmp ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁tmp ▁= ▁1 ▁; ▁left ▁= ▁i ▁; ▁while ▁( ▁left ▁- ▁1 ▁>= ▁0 ▁&& ▁abs ▁( ▁arr ▁[ ▁left ▁] ▁- ▁arr ▁[ ▁left ▁- ▁1 ▁] ▁) ▁<= ▁K ▁) ▁{ ▁left ▁-- ▁; ▁tmp ▁++ ▁; ▁} ▁right ▁= ▁i ▁; ▁while ▁( ▁right ▁+ ▁1 ▁<= ▁n ▁- ▁1 ▁&& ▁abs ▁( ▁arr ▁[ ▁right ▁] ▁- ▁arr ▁[ ▁right ▁+ ▁1 ▁] ▁) ▁<= ▁K ▁) ▁{ ▁right ▁++ ▁; ▁tmp ▁++ ▁; ▁} ▁if ▁( ▁min ▁> ▁tmp ▁) ▁min ▁= ▁tmp ▁; ▁if ▁( ▁max ▁< ▁tmp ▁) ▁max ▁= ▁tmp ▁; ▁} ▁c out ▁<< ▁min ▁<< ▁" ▁, ▁" ▁<< ▁max ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁5 ▁, ▁6 ▁, ▁7 ▁} ▁; ▁int ▁K ▁= ▁2 ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁find Max Min Sub Array ▁( ▁arr ▁, ▁K ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁minimum Steps ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁int ▁c ▁) ▁{ ▁if ▁( ▁a ▁< ▁1 ▁b ▁< ▁1 ▁) ▁return ▁-1 ▁; ▁if ▁( ▁a ▁== ▁1 ▁&& ▁b ▁== ▁1 ▁) ▁return ▁c ▁; ▁if ▁( ▁a ▁< ▁b ▁) ▁{ ▁a ▁= ▁a ▁+ ▁b ▁; ▁b ▁= ▁a ▁- ▁b ▁; ▁a ▁= ▁a ▁- ▁b ▁; ▁} ▁return ▁minimum Steps ▁( ▁a ▁- ▁b ▁, ▁b ▁, ▁c ▁+ ▁1 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁= ▁75 ▁; ▁int ▁b ▁= ▁17 ▁; ▁c out ▁<< ▁minimum Steps ▁( ▁a ▁, ▁b ▁, ▁0 ▁) ▁<< ▁end l ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is Perf ect Square ▁( ▁long ▁double ▁x ▁) ▁{ ▁long ▁double ▁sr ▁= ▁sqrt ▁( ▁x ▁) ▁; ▁return ▁( ▁( ▁sr ▁- ▁floor ▁( ▁sr ▁) ▁) ▁== ▁0 ▁) ▁; ▁} ▁int ▁count Square s ▁( ▁int ▁n ▁) ▁{ ▁int ▁cnt ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁pow ▁( ▁10 ▁, ▁( ▁n ▁- ▁1 ▁) ▁) ▁; ▁i ▁< ▁pow ▁( ▁10 ▁, ▁n ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁!= ▁0 ▁&& ▁is Perf ect Square ▁( ▁i ▁) ▁) ▁cnt ▁++ ▁; ▁} ▁return ▁cnt ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁3 ▁; ▁c out ▁<< ▁count Square s ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁print Arr ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁% ▁4 ▁== ▁0 ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁/ ▁2 ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁i ▁* ▁2 ▁<< ▁' ▁' ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁/ ▁2 ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁i ▁* ▁2 ▁- ▁1 ▁<< ▁' ▁' ▁; ▁c out ▁<< ▁n ▁+ ▁n ▁/ ▁2 ▁- ▁1 ▁<< ▁' ▁' ▁; ▁} ▁else ▁c out ▁<< ▁" ▁- ▁1" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁22 ▁; ▁print Arr ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁double ▁C g pa Calc ▁( ▁double ▁marks ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁double ▁grade ▁[ ▁n ▁] ▁; ▁double ▁cg pa ▁, ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁grade ▁[ ▁i ▁] ▁= ▁( ▁marks ▁[ ▁i ▁] ▁/ ▁10 ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁grade ▁[ ▁i ▁] ▁; ▁} ▁cg pa ▁= ▁sum ▁/ ▁n ▁; ▁return ▁cg pa ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁5 ▁; ▁double ▁marks ▁[ ▁] ▁= ▁{ ▁90 ▁, ▁80 ▁, ▁70 ▁, ▁80 ▁, ▁90 ▁} ▁; ▁double ▁cg pa ▁= ▁C g pa Calc ▁( ▁marks ▁, ▁n ▁) ▁; ▁c out ▁<< ▁" ▁CG PA ▁= ▁" ▁; ▁printf ▁( ▁" ▁% ▁.1 f ▁STRNEWLINE ▁" ▁, ▁cg pa ▁) ▁; ▁c out ▁<< ▁" ▁CG PA ▁Percent age ▁= ▁" ▁; ▁printf ▁( ▁" ▁% ▁.2 f ▁" ▁, ▁cg pa ▁* ▁9. 5 ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁check G olden Ratio ▁( ▁float ▁a ▁, ▁float ▁b ▁) ▁{ ▁if ▁( ▁a ▁<= ▁b ▁) ▁{ ▁float ▁temp ▁= ▁a ▁; ▁a ▁= ▁b ▁; ▁b ▁= ▁temp ▁; ▁} ▁std ▁:: ▁string stream ▁ratio 1 ▁; ▁ratio 1 ▁<< ▁std ▁:: ▁fixed ▁<< ▁std ▁:: ▁set precision ▁( ▁3 ▁) ▁<< ▁( ▁a ▁/ ▁b ▁) ▁; ▁std ▁:: ▁string stream ▁ratio 2 ▁; ▁ratio 2 ▁<< ▁std ▁:: ▁fixed ▁<< ▁std ▁:: ▁set precision ▁( ▁3 ▁) ▁<< ▁( ▁a ▁+ ▁b ▁) ▁/ ▁a ▁; ▁if ▁( ▁( ▁ratio 1 ▁. ▁str ▁( ▁) ▁== ▁ratio 2 ▁. ▁str ▁( ▁) ▁) ▁&& ▁ratio 1 ▁. ▁str ▁( ▁) ▁== ▁"1. 6 18 " ▁) ▁{ ▁c out ▁<< ▁" ▁Yes ▁" ▁<< ▁end l ▁; ▁return ▁true ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁" ▁No ▁" ▁<< ▁end l ▁; ▁return ▁false ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁float ▁a ▁= ▁0.6 18 ▁; ▁float ▁b ▁= ▁1 ▁; ▁check G olden Ratio ▁( ▁a ▁, ▁b ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁# define ▁ll ▁long ▁long ▁int ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁min Num ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁x ▁= ▁( ▁int ▁) ▁( ▁log ▁( ▁n ▁) ▁/ ▁log ▁( ▁k ▁) ▁) ▁+ ▁1 ▁; ▁int ▁mn ▁= ▁pow ▁( ▁k ▁, ▁x ▁) ▁- ▁n ▁; ▁return ▁mn ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁20 ▁, ▁k ▁= ▁5 ▁; ▁c out ▁<< ▁min Num ▁( ▁n ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁C nt cont Sub s ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁prod ▁= ▁1 ▁; ▁vector ▁< ▁pair ▁< ▁int ▁, ▁int ▁> ▁> ▁vect ▁; ▁vect ▁. ▁push _ back ▁( ▁make _ pair ▁( ▁0 ▁, ▁2 ▁) ▁) ▁; ▁vector ▁< ▁int ▁> ▁two ▁, ▁zero ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁a ▁[ ▁i ▁] ▁= ▁a ▁[ ▁i ▁] ▁% ▁4 ▁; ▁if ▁( ▁a ▁[ ▁i ▁] ▁< ▁0 ▁) ▁a ▁[ ▁i ▁] ▁= ▁a ▁[ ▁i ▁] ▁+ ▁4 ▁; ▁if ▁( ▁a ▁[ ▁i ▁] ▁== ▁2 ▁) ▁two ▁. ▁push _ back ▁( ▁i ▁+ ▁1 ▁) ▁; ▁if ▁( ▁a ▁[ ▁i ▁] ▁== ▁0 ▁) ▁zero ▁. ▁push _ back ▁( ▁i ▁+ ▁1 ▁) ▁; ▁if ▁( ▁a ▁[ ▁i ▁] ▁== ▁0 ▁a ▁[ ▁i ▁] ▁== ▁2 ▁) ▁vect ▁. ▁push _ back ▁( ▁make _ pair ▁( ▁i ▁+ ▁1 ▁, ▁a ▁[ ▁i ▁] ▁) ▁) ▁; ▁} ▁vect ▁. ▁push _ back ▁( ▁make _ pair ▁( ▁n ▁+ ▁1 ▁, ▁2 ▁) ▁) ▁; ▁int ▁total ▁= ▁( ▁n ▁* ▁( ▁n ▁+ ▁1 ▁) ▁) ▁/ ▁2 ▁; ▁if ▁( ▁two ▁. ▁empty ▁( ▁) ▁) ▁return ▁total ▁; ▁else ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁int ▁pos 1 ▁= ▁-1 ▁, ▁pos 2 ▁= ▁-1 ▁, ▁pos 3 ▁= ▁-1 ▁; ▁int ▁sz ▁= ▁vect ▁. ▁size ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁+ ▁1 ▁< ▁sz ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁vect ▁[ ▁i ▁] ▁. ▁second ▁== ▁2 ▁) ▁{ ▁sum ▁+= ▁( ▁vect ▁[ ▁i ▁] ▁. ▁first ▁- ▁vect ▁[ ▁i ▁- ▁1 ▁] ▁. ▁first ▁) ▁* ▁( ▁vect ▁[ ▁i ▁+ ▁1 ▁] ▁. ▁first ▁- ▁vect ▁[ ▁i ▁] ▁. ▁first ▁) ▁- ▁1 ▁; ▁} ▁} ▁return ▁total ▁- ▁sum ▁- ▁two ▁. ▁size ▁( ▁) ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁4 ▁, ▁2 ▁, ▁9 ▁, ▁8 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁C
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁int ▁mod ▁= ▁100 000000 7 ▁; ▁int ▁count Sub sets ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁answer ▁= ▁0 ▁; ▁int ▁power Of Two ▁[ ▁10000 5 ▁] ▁; ▁power Of Two ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁10000 5 ▁; ▁i ▁++ ▁) ▁power Of Two ▁[ ▁i ▁] ▁= ▁( ▁power Of Two ▁[ ▁i ▁- ▁1 ▁] ▁* ▁2 ▁) ▁% ▁mod ▁; ▁unordered _ map ▁< ▁int ▁, ▁int ▁> ▁frequency ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁frequency ▁[ ▁a ▁[ ▁i ▁] ▁] ▁++ ▁; ▁for ▁( ▁auto ▁el ▁: ▁frequency ▁) ▁{ ▁if ▁( ▁el ▁. ▁first ▁!= ▁0 ▁) ▁answer ▁= ▁( ▁answer ▁% ▁mod ▁+ ▁power Of Two ▁[ ▁el ▁. ▁second ▁- ▁1 ▁] ▁) ▁% ▁mod ▁; ▁else ▁answer ▁= ▁( ▁answer ▁% ▁mod ▁+ ▁power Of Two ▁[ ▁el ▁. ▁second ▁] ▁- ▁1 ▁+ ▁mod ▁) ▁% ▁mod ▁; ▁} ▁return ▁answer ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁6 ▁; ▁int ▁A ▁[ ▁N ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁2 ▁, ▁1 ▁, ▁2 ▁, ▁1 ▁} ▁; ▁c out ▁<< ▁count Sub sets ▁( ▁A ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁long ▁long ▁product ▁( ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁& ▁mat ▁, ▁int ▁n ▁) ▁{ ▁long ▁long ▁d 1 ▁= ▁0 ▁, ▁d 2 ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁d 1 ▁+= ▁mat ▁[ ▁i ▁] ▁[ ▁i ▁] ▁; ▁d 2 ▁+= ▁mat ▁[ ▁i ▁] ▁[ ▁n ▁- ▁i ▁- ▁1 ▁] ▁; ▁} ▁return ▁1 LL ▁* ▁d 1 ▁* ▁d 2 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁mat ▁= ▁{ ▁{ ▁5 ▁, ▁8 ▁, ▁1 ▁} ▁, ▁{ ▁5 ▁, ▁10 ▁, ▁3 ▁} ▁, ▁{ ▁- 6 ▁, ▁17 ▁, ▁-9 ▁} ▁} ▁; ▁int ▁n ▁= ▁mat ▁. ▁size ▁( ▁) ▁; ▁c out ▁<< ▁product ▁( ▁mat ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Sum ▁( ▁int ▁* ▁arr ▁, ▁int ▁n ▁, ▁int ▁left ▁, ▁int ▁right ▁) ▁{ ▁int ▁k ▁= ▁right ▁- ▁left ▁; ▁int ▁d ▁= ▁arr ▁[ ▁1 ▁] ▁- ▁arr ▁[ ▁0 ▁] ▁; ▁int ▁ans ▁= ▁arr ▁[ ▁left ▁- ▁1 ▁] ▁* ▁( ▁k ▁+ ▁1 ▁) ▁; ▁ans ▁= ▁ans ▁+ ▁( ▁d ▁* ▁( ▁k ▁* ▁( ▁k ▁+ ▁1 ▁) ▁) ▁) ▁/ ▁2 ▁; ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁4 ▁, ▁6 ▁, ▁8 ▁, ▁10 ▁, ▁12 ▁, ▁14 ▁, ▁16 ▁} ▁; ▁int ▁queries ▁= ▁3 ▁; ▁int ▁q ▁[ ▁queries ▁] ▁[ ▁2 ▁] ▁= ▁{ ▁{ ▁2 ▁, ▁4 ▁} ▁, ▁{ ▁2 ▁, ▁6 ▁} ▁, ▁{ ▁5 ▁, ▁6 ▁} ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁queries ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁find Sum ▁( ▁arr ▁, ▁n ▁, ▁q ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁, ▁q ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁) ▁<< ▁end l ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁sub array Possible ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁if ▁( ▁sum ▁<= ▁0 ▁) ▁return ▁1 ▁; ▁} ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁if ▁( ▁sum ▁<= ▁0 ▁) ▁return ▁1 ▁; ▁} ▁return ▁0 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁5 ▁, ▁-12 ▁, ▁7 ▁, ▁-10 ▁, ▁20 ▁, ▁30 ▁, ▁-10 ▁, ▁50 ▁, ▁60 ▁} ▁; ▁int ▁size ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁if ▁( ▁sub array Possible ▁( ▁arr ▁, ▁size ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁# define ▁limit ▁10000 000 ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁position ▁[ ▁limit ▁+ ▁1 ▁] ▁; ▁void ▁s ieve ▁( ▁) ▁{ ▁position ▁[ ▁0 ▁] ▁= ▁-1 ▁, ▁position ▁[ ▁1 ▁] ▁= ▁-1 ▁; ▁int ▁pos ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁limit ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁position ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁position ▁[ ▁i ▁] ▁= ▁++ ▁pos ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁* ▁2 ▁; ▁j ▁<= ▁limit ▁; ▁j ▁+= ▁i ▁) ▁position ▁[ ▁j ▁] ▁= ▁-1 ▁; ▁} ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁s ieve ▁( ▁) ▁; ▁int ▁n ▁= ▁11 ▁; ▁c out ▁<< ▁position ▁[ ▁n ▁] ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁double ▁max Sub Array Sum ▁( ▁double ▁a ▁[ ▁] ▁, ▁int ▁size ▁) ▁{ ▁double ▁max _ so _ far ▁= ▁INT _ MIN ▁, ▁max _ ending _ here ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁{ ▁max _ ending _ here ▁= ▁max _ ending _ here ▁+ ▁a ▁[ ▁i ▁] ▁; ▁if ▁( ▁max _ so _ far ▁< ▁max _ ending _ here ▁) ▁max _ so _ far ▁= ▁max _ ending _ here ▁; ▁if ▁( ▁max _ ending _ here ▁< ▁0 ▁) ▁max _ ending _ here ▁= ▁0 ▁; ▁} ▁return ▁max _ so _ far ▁; ▁} ▁double ▁min Possible Sum ▁( ▁double ▁a ▁[ ▁] ▁, ▁int ▁n ▁, ▁double ▁x ▁) ▁{ ▁double ▁mx Sum ▁= ▁max Sub Array Sum ▁( ▁a ▁, ▁n ▁) ▁; ▁double ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁a ▁[ ▁i ▁] ▁; ▁} ▁sum ▁= ▁sum ▁- ▁mx Sum ▁+ ▁mx Sum ▁/ ▁x ▁; ▁c out ▁<< ▁set precision ▁( ▁2 ▁) ▁<< ▁sum ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁3 ▁; ▁double ▁X ▁= ▁2 ▁; ▁double ▁A ▁[ ▁N ▁] ▁= ▁{ ▁1 ▁, ▁-2 ▁, ▁3 ▁} ▁; ▁min Possible Sum ▁( ▁A ▁, ▁N ▁, ▁X ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁reverse ▁( ▁int ▁num ▁) ▁{ ▁int ▁rev _ num ▁= ▁0 ▁; ▁while ▁( ▁num ▁> ▁0 ▁) ▁{ ▁rev _ num ▁= ▁rev _ num ▁* ▁10 ▁+ ▁num ▁% ▁10 ▁; ▁num ▁= ▁num ▁/ ▁10 ▁; ▁} ▁return ▁rev _ num ▁; ▁} ▁int ▁count Reverse ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁unordered _ map ▁< ▁int ▁, ▁int ▁> ▁freq ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁++ ▁freq ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁; ▁int ▁res ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁-- ▁freq ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁; ▁res ▁+= ▁freq ▁[ ▁reverse ▁( ▁arr ▁[ ▁i ▁] ▁) ▁] ▁; ▁} ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁16 ▁, ▁61 ▁, ▁12 ▁, ▁21 ▁, ▁25 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁count Reverse ▁( ▁a ▁, ▁n ▁) ▁<< ▁' ▁' ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁isP ossible ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁count Of Two ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁A ▁[ ▁i ▁] ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁count Of Two ▁++ ▁; ▁} ▁} ▁if ▁( ▁k ▁== ▁0 ▁&& ▁count Of Two ▁== ▁n ▁) ▁c out ▁<< ▁" ▁NO ▁STRNEWLINE ▁" ▁; ▁else ▁if ▁( ▁count Of Two ▁>= ▁k ▁) ▁{ ▁c out ▁<< ▁" ▁Yes ▁STRNEWLINE ▁" ▁; ▁} ▁else ▁c out ▁<< ▁" ▁No ▁STRNEWLINE ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁K ▁= ▁2 ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁isP ossible ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁# define ▁size ▁100 01 ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁prime ▁[ ▁size ▁] ▁; ▁int ▁freq ▁[ ▁size ▁] ▁; ▁void ▁s ieve ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁prime ▁[ ▁1 ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁* ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁* ▁2 ▁; ▁j ▁< ▁size ▁; ▁j ▁+= ▁i ▁) ▁prime ▁[ ▁j ▁] ▁= ▁1 ▁; ▁} ▁} ▁for ▁( ▁int ▁p ▁= ▁1 ▁; ▁p ▁< ▁size ▁; ▁p ▁++ ▁) ▁{ ▁for ▁( ▁int ▁q ▁= ▁1 ▁; ▁q ▁< ▁size ▁; ▁q ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁p ▁] ▁== ▁0 ▁&& ▁prime ▁[ ▁q ▁] ▁== ▁0 ▁&& ▁a ▁* ▁p ▁+ ▁b ▁* ▁q ▁< ▁size ▁) ▁{ ▁freq ▁[ ▁a ▁* ▁p ▁+ ▁b ▁* ▁q ▁] ▁++ ▁; ▁} ▁} ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁queries ▁= ▁2 ▁, ▁a ▁= ▁1 ▁, ▁b ▁= ▁2 ▁; ▁s ieve ▁( ▁a ▁, ▁b ▁) ▁; ▁int ▁arr ▁[ ▁queries ▁] ▁= ▁{ ▁15 ▁, ▁25 ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁queries ▁; ▁i ▁++ ▁) ▁{ ▁c out ▁<< ▁freq ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁<< ▁" ▁" ▁; ▁} ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print Mod ulus ▁( ▁int ▁X ▁, ▁int ▁Y ▁) ▁{ ▁int ▁n ▁= ▁max ▁( ▁X ▁, ▁Y ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁X ▁% ▁i ▁== ▁Y ▁% ▁i ▁) ▁c out ▁<< ▁i ▁<< ▁" ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁X ▁, ▁Y ▁; ▁X ▁= ▁10 ▁; ▁Y ▁= ▁20 ▁; ▁print Mod ulus ▁( ▁X ▁, ▁Y ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁string ▁check ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁& ▁1 ▁) ▁count ▁++ ▁; ▁} ▁if ▁( ▁count ▁& ▁1 ▁) ▁return ▁" ▁O dd ▁" ▁; ▁else ▁return ▁" ▁Even ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁9 ▁, ▁12 ▁, ▁13 ▁, ▁15 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁check ▁( ▁arr ▁, ▁n ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁# include ▁< std lib . h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is Div isible ▁( ▁int ▁n ▁) ▁{ ▁int ▁d ▁; ▁while ▁( ▁n ▁/ ▁100 ▁) ▁{ ▁d ▁= ▁n ▁% ▁10 ▁; ▁n ▁/= ▁10 ▁; ▁n ▁= ▁abs ▁( ▁n ▁- ▁( ▁d ▁* ▁14 ▁) ▁) ▁; ▁} ▁return ▁( ▁n ▁% ▁47 ▁== ▁0 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁59 17 3 ▁; ▁if ▁( ▁is Div isible ▁( ▁N ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁<< ▁end l ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁proper Div isor Sum ▁( ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁++ ▁i ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁* ▁j ▁<= ▁i ▁; ▁++ ▁j ▁) ▁{ ▁if ▁( ▁i ▁% ▁j ▁== ▁0 ▁) ▁{ ▁if ▁( ▁i ▁/ ▁j ▁== ▁j ▁) ▁sum ▁+= ▁j ▁; ▁else ▁sum ▁+= ▁j ▁+ ▁i ▁/ ▁j ▁; ▁} ▁} ▁sum ▁= ▁sum ▁- ▁i ▁; ▁} ▁return ▁sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁4 ▁; ▁c out ▁<< ▁proper Div isor Sum ▁( ▁n ▁) ▁<< ▁end l ▁; ▁n ▁= ▁5 ▁; ▁c out ▁<< ▁proper Div isor Sum ▁( ▁n ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁proper Div isor Sum ▁( ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁++ ▁i ▁) ▁sum ▁+= ▁( ▁n ▁/ ▁i ▁) ▁* ▁i ▁; ▁return ▁sum ▁- ▁n ▁* ▁( ▁n ▁+ ▁1 ▁) ▁/ ▁2 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁4 ▁; ▁c out ▁<< ▁proper Div isor Sum ▁( ▁n ▁) ▁<< ▁end l ▁; ▁n ▁= ▁5 ▁; ▁c out ▁<< ▁proper Div isor Sum ▁( ▁n ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁int ▁sz ▁= ▁1 e 5 ▁; ▁bool ▁is Prime ▁[ ▁sz ▁+ ▁1 ▁] ▁; ▁void ▁generate Prime ▁( ▁) ▁{ ▁int ▁i ▁, ▁j ▁; ▁mem set ▁( ▁is Prime ▁, ▁true ▁, ▁sizeof ▁( ▁is Prime ▁) ▁) ▁; ▁is Prime ▁[ ▁0 ▁] ▁= ▁is Prime ▁[ ▁1 ▁] ▁= ▁false ▁; ▁for ▁( ▁i ▁= ▁2 ▁; ▁i ▁* ▁i ▁<= ▁sz ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁is Prime ▁[ ▁i ▁] ▁) ▁{ ▁for ▁( ▁j ▁= ▁i ▁* ▁i ▁; ▁j ▁< ▁sz ▁; ▁j ▁+= ▁i ▁) ▁{ ▁is Prime ▁[ ▁j ▁] ▁= ▁false ▁; ▁} ▁} ▁} ▁} ▁void ▁Pair _ of _ Prime X or ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁is Prime ▁[ ▁( ▁A ▁[ ▁i ▁] ▁^ ▁A ▁[ ▁j ▁] ▁) ▁] ▁) ▁{ ▁c out ▁<< ▁" ▁( ▁" ▁<< ▁A ▁[ ▁i ▁] ▁<< ▁" ▁, ▁" ▁<< ▁A ▁[ ▁j ▁] ▁<< ▁" ▁) ▁" ▁; ▁} ▁} ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁6 ▁, ▁11 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁A ▁) ▁/ ▁sizeof ▁( ▁A ▁[ ▁0 ▁] ▁) ▁; ▁generate Prime ▁( ▁) ▁; ▁Pair _ of _ Prime X or ▁( ▁A ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is Prime ▁( ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁* ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁{ ▁return ▁false ▁; ▁} ▁} ▁return ▁true ▁; ▁} ▁void ▁print Min Count Prime ▁( ▁int ▁N ▁) ▁{ ▁int ▁min Count ▁; ▁if ▁( ▁is Prime ▁( ▁N ▁) ▁) ▁{ ▁min Count ▁= ▁1 ▁; ▁} ▁else ▁if ▁( ▁N ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁min Count ▁= ▁2 ▁; ▁} ▁else ▁{ ▁if ▁( ▁is Prime ▁( ▁N ▁- ▁2 ▁) ▁) ▁{ ▁min Count ▁= ▁2 ▁; ▁} ▁else ▁{ ▁min Count ▁= ▁3 ▁; ▁} ▁} ▁c out ▁<< ▁min Count ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁100 ▁; ▁print Min Count Prime ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Steps ▁( ▁int ▁n ▁) ▁{ ▁int ▁steps ▁= ▁0 ▁; ▁while ▁( ▁n ▁) ▁{ ▁int ▁largest ▁= ▁c br t ▁( ▁n ▁) ▁; ▁n ▁-= ▁( ▁largest ▁* ▁largest ▁* ▁largest ▁) ▁; ▁steps ▁++ ▁; ▁} ▁return ▁steps ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁150 ▁; ▁c out ▁<< ▁count Steps ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁rad ▁( ▁double ▁d ▁, ▁double ▁h ▁) ▁{ ▁c out ▁<< ▁" ▁The ▁radius ▁of ▁the ▁circle ▁is ▁" ▁<< ▁( ▁( ▁d ▁* ▁d ▁) ▁/ ▁( ▁8 ▁* ▁h ▁) ▁+ ▁h ▁/ ▁2 ▁) ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁double ▁d ▁= ▁4 ▁, ▁h ▁= ▁1 ▁; ▁rad ▁( ▁d ▁, ▁h ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁float ▁Area ▁( ▁float ▁r ▁) ▁{ ▁if ▁( ▁r ▁< ▁0 ▁) ▁return ▁-1 ▁; ▁float ▁x ▁= ▁( ▁2 ▁* ▁r ▁) ▁/ ▁sqrt ▁( ▁5 ▁) ▁; ▁float ▁A ▁= ▁0. 704 77 ▁* ▁pow ▁( ▁x ▁, ▁2 ▁) ▁; ▁return ▁A ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁float ▁r ▁= ▁5 ▁; ▁c out ▁<< ▁Area ▁( ▁r ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁float ▁poly diag onal ▁( ▁float ▁n ▁, ▁float ▁a ▁) ▁{ ▁if ▁( ▁a ▁< ▁0 ▁&& ▁n ▁< ▁0 ▁) ▁return ▁-1 ▁; ▁return ▁2 ▁* ▁a ▁* ▁sin ▁( ▁( ▁( ▁( ▁n ▁- ▁2 ▁) ▁* ▁180 ▁) ▁/ ▁( ▁2 ▁* ▁n ▁) ▁) ▁* ▁3.14 159 ▁/ ▁180 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁float ▁a ▁= ▁9 ▁, ▁n ▁= ▁10 ▁; ▁c out ▁<< ▁poly diag onal ▁( ▁n ▁, ▁a ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁# define ▁PI ▁3.14 159 265 ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁float ▁area _ c irc um scri bed ▁( ▁float ▁c ▁) ▁{ ▁return ▁( ▁c ▁* ▁c ▁* ▁( ▁PI ▁/ ▁4 ▁) ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁float ▁c ▁= ▁8 ▁; ▁c out ▁<< ▁area _ c irc um scri bed ▁( ▁c ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max Area ▁( ▁float ▁per imeter ▁) ▁{ ▁int ▁length ▁= ▁( ▁int ▁) ▁ceil ▁( ▁per imeter ▁/ ▁4 ▁) ▁; ▁int ▁b readth ▁= ▁( ▁int ▁) ▁floor ▁( ▁per imeter ▁/ ▁4 ▁) ▁; ▁return ▁length ▁* ▁b readth ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁float ▁n ▁= ▁38 ▁; ▁c out ▁<< ▁" ▁Maximum ▁Area ▁= ▁" ▁<< ▁max Area ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁float ▁Per imeter ▁( ▁float ▁s ▁, ▁int ▁n ▁) ▁{ ▁float ▁per imeter ▁= ▁1 ▁; ▁per imeter ▁= ▁n ▁* ▁s ▁; ▁return ▁per imeter ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁5 ▁; ▁float ▁s ▁= ▁2.5 ▁, ▁per i ▁; ▁per i ▁= ▁Per imeter ▁( ▁s ▁, ▁n ▁) ▁; ▁c out ▁<< ▁" ▁Per imeter ▁of ▁Regular ▁Polygon ▁" ▁<< ▁" ▁with ▁" ▁<< ▁n ▁<< ▁" ▁sides ▁of ▁length ▁" ▁<< ▁s ▁<< ▁" ▁= ▁" ▁<< ▁per i ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁float ▁hex ad iag onal ▁( ▁float ▁a ▁) ▁{ ▁if ▁( ▁a ▁< ▁0 ▁) ▁return ▁-1 ▁; ▁return ▁2 ▁* ▁a ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁float ▁a ▁= ▁4 ▁; ▁c out ▁<< ▁hex ad iag onal ▁( ▁a ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁float ▁find Radius Of c irc um circle ▁( ▁float ▁l ▁, ▁float ▁b ▁) ▁{ ▁if ▁( ▁l ▁< ▁0 ▁b ▁< ▁0 ▁) ▁return ▁-1 ▁; ▁float ▁radius ▁= ▁sqrt ▁( ▁pow ▁( ▁l ▁, ▁2 ▁) ▁+ ▁pow ▁( ▁b ▁, ▁2 ▁) ▁) ▁/ ▁2 ▁; ▁return ▁radius ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁float ▁l ▁= ▁4 ▁, ▁b ▁= ▁3 ▁; ▁c out ▁<< ▁find Radius Of c irc um circle ▁( ▁l ▁, ▁b ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁hal fs quare ▁( ▁int ▁n ▁, ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁int ▁half ▁= ▁n ▁/ ▁2 ▁; ▁if ▁( ▁( ▁half ▁== ▁x ▁half ▁== ▁x ▁- ▁1 ▁) ▁&& ▁( ▁half ▁== ▁y ▁half ▁== ▁y ▁- ▁1 ▁) ▁) ▁c out ▁<< ▁" ▁NO ▁" ▁<< ▁end l ▁; ▁else ▁c out ▁<< ▁" ▁YES ▁" ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁100 ▁; ▁int ▁x ▁= ▁51 ▁, ▁y ▁= ▁100 ▁; ▁hal fs quare ▁( ▁n ▁, ▁x ▁, ▁y ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁Find Point ▁( ▁int ▁x 1 ▁, ▁int ▁y 1 ▁, ▁int ▁x 2 ▁, ▁int ▁y 2 ▁, ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁if ▁( ▁x ▁> ▁x 1 ▁and ▁x ▁< ▁x 2 ▁and ▁y ▁> ▁y 1 ▁and ▁y ▁< ▁y 2 ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁x 1 ▁= ▁0 ▁, ▁y 1 ▁= ▁0 ▁, ▁x 2 ▁= ▁10 ▁, ▁y 2 ▁= ▁8 ▁; ▁int ▁x ▁= ▁1 ▁, ▁y ▁= ▁5 ▁; ▁if ▁( ▁Find Point ▁( ▁x 1 ▁, ▁y 1 ▁, ▁x 2 ▁, ▁y 2 ▁, ▁x ▁, ▁y ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁# include ▁< math . h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁shortest _ distance ▁( ▁float ▁x 1 ▁, ▁float ▁y 1 ▁, ▁float ▁z 1 ▁, ▁float ▁a ▁, ▁float ▁b ▁, ▁float ▁c ▁, ▁float ▁d ▁) ▁{ ▁d ▁= ▁f abs ▁( ▁( ▁a ▁* ▁x 1 ▁+ ▁b ▁* ▁y 1 ▁+ ▁c ▁* ▁z 1 ▁+ ▁d ▁) ▁) ▁; ▁float ▁e ▁= ▁sqrt ▁( ▁a ▁* ▁a ▁+ ▁b ▁* ▁b ▁+ ▁c ▁* ▁c ▁) ▁; ▁c out ▁<< ▁" ▁Per p end icular ▁distance ▁is ▁" ▁<< ▁( ▁d ▁/ ▁e ▁) ▁; ▁return ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁float ▁x 1 ▁= ▁4 ▁; ▁float ▁y 1 ▁= ▁-4 ▁; ▁float ▁z 1 ▁= ▁3 ▁; ▁float ▁a ▁= ▁2 ▁; ▁float ▁b ▁= ▁-2 ▁; ▁float ▁c ▁= ▁5 ▁; ▁float ▁d ▁= ▁8 ▁; ▁shortest _ distance ▁( ▁x 1 ▁, ▁y 1 ▁, ▁z 1 ▁, ▁a ▁, ▁b ▁, ▁c ▁, ▁d ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁p ent agon _ py ramid al ▁( ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁p ▁= ▁( ▁3 ▁* ▁i ▁* ▁i ▁- ▁i ▁) ▁/ ▁2 ▁; ▁sum ▁= ▁sum ▁+ ▁p ▁; ▁} ▁return ▁sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁4 ▁; ▁c out ▁<< ▁p ent agon _ py ramid al ▁( ▁n ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is Rectangle ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁int ▁c ▁, ▁int ▁d ▁) ▁{ ▁if ▁( ▁a ▁== ▁b ▁== ▁c ▁== ▁d ▁) ▁return ▁true ▁; ▁else ▁if ▁( ▁a ▁== ▁b ▁&& ▁c ▁== ▁d ▁) ▁return ▁true ▁; ▁else ▁if ▁( ▁a ▁== ▁d ▁&& ▁c ▁== ▁b ▁) ▁return ▁true ▁; ▁else ▁if ▁( ▁a ▁== ▁c ▁&& ▁d ▁== ▁b ▁) ▁return ▁true ▁; ▁else ▁return ▁false ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁, ▁b ▁, ▁c ▁, ▁d ▁; ▁a ▁= ▁1 ▁, ▁b ▁= ▁2 ▁, ▁c ▁= ▁3 ▁, ▁d ▁= ▁4 ▁; ▁if ▁( ▁is Rectangle ▁( ▁a ▁, ▁b ▁, ▁c ▁, ▁d ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁# include ▁< math . h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁double ▁max Area ▁( ▁double ▁a ▁, ▁double ▁b ▁, ▁double ▁c ▁, ▁double ▁d ▁) ▁{ ▁double ▁semi per imeter ▁= ▁( ▁a ▁+ ▁b ▁+ ▁c ▁+ ▁d ▁) ▁/ ▁2 ▁; ▁return ▁sqrt ▁( ▁( ▁semi per imeter ▁- ▁a ▁) ▁* ▁( ▁semi per imeter ▁- ▁b ▁) ▁* ▁( ▁semi per imeter ▁- ▁c ▁) ▁* ▁( ▁semi per imeter ▁- ▁d ▁) ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁double ▁a ▁= ▁1 ▁, ▁b ▁= ▁2 ▁, ▁c ▁= ▁1 ▁, ▁d ▁= ▁2 ▁; ▁c out ▁<< ▁max Area ▁( ▁a ▁, ▁b ▁, ▁c ▁, ▁d ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁check Collision ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁int ▁c ▁, ▁int ▁x ▁, ▁int ▁y ▁, ▁int ▁radius ▁) ▁{ ▁int ▁dist ▁= ▁( ▁abs ▁( ▁a ▁* ▁x ▁+ ▁b ▁* ▁y ▁+ ▁c ▁) ▁) ▁/ ▁sqrt ▁( ▁a ▁* ▁a ▁+ ▁b ▁* ▁b ▁) ▁; ▁if ▁( ▁radius ▁== ▁dist ▁) ▁c out ▁<< ▁" ▁Touch ▁" ▁<< ▁end l ▁; ▁else ▁if ▁( ▁radius ▁> ▁dist ▁) ▁c out ▁<< ▁" ▁Inter sect ▁" ▁<< ▁end l ▁; ▁else ▁c out ▁<< ▁" ▁Out side ▁" ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁radius ▁= ▁5 ▁; ▁int ▁x ▁= ▁0 ▁, ▁y ▁= ▁0 ▁; ▁int ▁a ▁= ▁3 ▁, ▁b ▁= ▁4 ▁, ▁c ▁= ▁25 ▁; ▁check Collision ▁( ▁a ▁, ▁b ▁, ▁c ▁, ▁x ▁, ▁y ▁, ▁radius ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁circle ▁( ▁int ▁x 1 ▁, ▁int ▁y 1 ▁, ▁int ▁x 2 ▁, ▁int ▁y 2 ▁, ▁int ▁r 1 ▁, ▁int ▁r 2 ▁) ▁{ ▁int ▁dist Sq ▁= ▁( ▁x 1 ▁- ▁x 2 ▁) ▁* ▁( ▁x 1 ▁- ▁x 2 ▁) ▁+ ▁( ▁y 1 ▁- ▁y 2 ▁) ▁* ▁( ▁y 1 ▁- ▁y 2 ▁) ▁; ▁int ▁rad Sum Sq ▁= ▁( ▁r 1 ▁+ ▁r 2 ▁) ▁* ▁( ▁r 1 ▁+ ▁r 2 ▁) ▁; ▁if ▁( ▁dist Sq ▁== ▁rad Sum Sq ▁) ▁return ▁1 ▁; ▁else ▁if ▁( ▁dist Sq ▁> ▁rad Sum Sq ▁) ▁return ▁-1 ▁; ▁else ▁return ▁0 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁x 1 ▁= ▁-10 ▁, ▁y 1 ▁= ▁8 ▁; ▁int ▁x 2 ▁= ▁14 ▁, ▁y 2 ▁= ▁- 24 ▁; ▁int ▁r 1 ▁= ▁30 ▁, ▁r 2 ▁= ▁10 ▁; ▁int ▁t ▁= ▁circle ▁( ▁x 1 ▁, ▁y 1 ▁, ▁x 2 ▁, ▁y 2 ▁, ▁r 1 ▁, ▁r 2 ▁) ▁; ▁if ▁( ▁t ▁== ▁1 ▁) ▁c out ▁<< ▁" ▁Circle ▁touch ▁to ▁" ▁<< ▁" ▁each ▁other ▁. ▁" ▁; ▁else ▁if ▁( ▁t ▁< ▁0 ▁) ▁c out ▁<< ▁" ▁Circle ▁not ▁touch ▁" ▁<< ▁" ▁to ▁each ▁other ▁. ▁" ▁; ▁else ▁c out ▁<< ▁" ▁Circle ▁intersect ▁" ▁<< ▁" ▁to ▁each ▁other ▁. ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁minimum Cost ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁X ▁, ▁int ▁Y ▁) ▁{ ▁int ▁even _ count ▁= ▁0 ▁, ▁odd _ count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁arr ▁[ ▁i ▁] ▁& ▁1 ▁) ▁&& ▁( ▁i ▁% ▁2 ▁== ▁0 ▁) ▁) ▁{ ▁odd _ count ▁++ ▁; ▁} ▁if ▁( ▁( ▁arr ▁[ ▁i ▁] ▁% ▁2 ▁) ▁== ▁0 ▁&& ▁( ▁i ▁& ▁1 ▁) ▁) ▁{ ▁even _ count ▁++ ▁; ▁} ▁} ▁int ▁cost 1 ▁= ▁X ▁* ▁min ▁( ▁odd _ count ▁, ▁even _ count ▁) ▁; ▁int ▁cost 2 ▁= ▁Y ▁* ▁( ▁max ▁( ▁odd _ count ▁, ▁even _ count ▁) ▁- ▁min ▁( ▁odd _ count ▁, ▁even _ count ▁) ▁) ▁; ▁int ▁cost 3 ▁= ▁( ▁odd _ count ▁+ ▁even _ count ▁) ▁* ▁Y ▁; ▁return ▁min ▁( ▁cost 1 ▁+ ▁cost 2 ▁, ▁cost 3 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁3 ▁, ▁7 ▁, ▁2 ▁, ▁1 ▁} ▁, ▁X ▁= ▁10 ▁, ▁Y ▁= ▁2 ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁minimum Cost ▁( ▁arr ▁, ▁N ▁, ▁X ▁, ▁Y ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max imize Subset ▁( ▁int ▁N ▁, ▁int ▁arr ▁[ ▁] ▁, ▁int ▁M ▁, ▁int ▁x ▁= ▁0 ▁) ▁{ ▁if ▁( ▁x ▁== ▁M ▁) ▁{ ▁return ▁0 ▁; ▁} ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁x ▁; ▁i ▁< ▁M ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁N ▁% ▁arr ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁ans ▁= ▁max ▁( ▁ans ▁, ▁max imize Subset ▁( ▁N ▁/ ▁arr ▁[ ▁i ▁] ▁, ▁arr ▁, ▁M ▁, ▁x ▁+ ▁1 ▁) ▁+ ▁1 ▁) ▁; ▁} ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁64 ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁4 ▁, ▁8 ▁, ▁16 ▁, ▁32 ▁} ▁; ▁int ▁M ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁max imize Subset ▁( ▁N ▁, ▁arr ▁, ▁M ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁getProduct ▁( ▁int ▁n ▁) ▁{ ▁int ▁product ▁= ▁1 ▁; ▁while ▁( ▁n ▁!= ▁0 ▁) ▁{ ▁product ▁= ▁product ▁* ▁( ▁n ▁% ▁10 ▁) ▁; ▁n ▁= ▁n ▁/ ▁10 ▁; ▁} ▁return ▁product ▁; ▁} ▁int ▁count Pairs ▁( ▁int ▁L ▁, ▁int ▁R ▁) ▁{ ▁int ▁cnt Pair ▁= ▁0 ▁; ▁for ▁( ▁int ▁a ▁= ▁L ▁; ▁a ▁<= ▁R ▁; ▁a ▁++ ▁) ▁{ ▁for ▁( ▁int ▁b ▁= ▁a ▁+ ▁1 ▁; ▁b ▁<= ▁R ▁; ▁b ▁++ ▁) ▁{ ▁int ▁x ▁= ▁getProduct ▁( ▁a ▁) ▁; ▁int ▁y ▁= ▁getProduct ▁( ▁b ▁) ▁; ▁if ▁( ▁x ▁&& ▁y ▁&& ▁( ▁a ▁* ▁y ▁) ▁== ▁( ▁b ▁* ▁x ▁) ▁) ▁{ ▁cnt Pair ▁++ ▁; ▁} ▁} ▁} ▁return ▁cnt Pair ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁L ▁= ▁1 ▁; ▁int ▁R ▁= ▁100 ▁; ▁c out ▁<< ▁count Pairs ▁( ▁1 ▁, ▁100 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max Sum ▁( ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁& ▁matrix ▁) ▁{ ▁int ▁r ▁= ▁matrix ▁. ▁size ▁( ▁) ▁; ▁int ▁c ▁= ▁matrix ▁[ ▁0 ▁] ▁. ▁size ▁( ▁) ▁; ▁int ▁sum ▁= ▁0 ▁; ▁int ▁mini ▁= ▁INT _ MAX ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁r ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁c ▁; ▁j ▁++ ▁) ▁{ ▁int ▁k ▁= ▁matrix ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁mini ▁= ▁min ▁( ▁mini ▁, ▁abs ▁( ▁k ▁) ▁) ▁; ▁if ▁( ▁k ▁< ▁0 ▁) ▁count ▁++ ▁; ▁sum ▁+= ▁abs ▁( ▁k ▁) ▁; ▁} ▁} ▁if ▁( ▁count ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁return ▁sum ▁; ▁} ▁else ▁{ ▁return ▁( ▁sum ▁- ▁2 ▁* ▁mini ▁) ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁matrix ▁= ▁{ ▁{ ▁2 ▁, ▁-2 ▁} ▁, ▁{ ▁-2 ▁, ▁2 ▁} ▁} ▁; ▁c out ▁<< ▁max Sum ▁( ▁matrix ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Sub sequences ▁( ▁vector ▁< ▁int ▁> ▁arr ▁) ▁{ ▁int ▁odd ▁= ▁0 ▁; ▁for ▁( ▁int ▁x ▁: ▁arr ▁) ▁{ ▁if ▁( ▁x ▁& ▁1 ▁) ▁odd ▁++ ▁; ▁} ▁return ▁( ▁1 ▁<< ▁odd ▁) ▁- ▁1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁int ▁> ▁arr ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁3 ▁} ▁; ▁c out ▁<< ▁count Sub sequences ▁( ▁arr ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁update Array ▁( ▁vector ▁< ▁int ▁> ▁& ▁arr ▁, ▁int ▁K ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁vector ▁< ▁int ▁> ▁res ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁( ▁int ▁) ▁arr ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁K ▁) ▁{ ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁else ▁{ ▁if ▁( ▁sum ▁!= ▁0 ▁) ▁{ ▁res ▁. ▁push _ back ▁( ▁sum ▁) ▁; ▁} ▁sum ▁= ▁0 ▁; ▁res ▁. ▁push _ back ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁} ▁if ▁( ▁sum ▁!= ▁0 ▁) ▁res ▁. ▁push _ back ▁( ▁sum ▁) ▁; ▁for ▁( ▁auto ▁& ▁it ▁: ▁res ▁) ▁c out ▁<< ▁it ▁<< ▁' ▁' ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁int ▁> ▁arr ▁= ▁{ ▁200 ▁, ▁6 ▁, ▁36 ▁, ▁6 12 ▁, ▁12 1 ▁, ▁66 ▁, ▁63 ▁, ▁39 ▁, ▁6 68 ▁, ▁108 ▁} ▁; ▁int ▁K ▁= ▁100 ▁; ▁update Array ▁( ▁arr ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Quad ru ples ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁unordered _ map ▁< ▁int ▁, ▁int ▁> ▁freq ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁ans ▁+= ▁freq ▁[ ▁A ▁[ ▁i ▁] ▁] ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁i ▁; ▁j ▁++ ▁) ▁{ ▁for ▁( ▁int ▁k ▁= ▁0 ▁; ▁k ▁< ▁j ▁; ▁k ▁++ ▁) ▁{ ▁freq ▁[ ▁A ▁[ ▁i ▁] ▁* ▁A ▁[ ▁j ▁] ▁* ▁A ▁[ ▁k ▁] ▁] ▁++ ▁; ▁} ▁} ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁2 ▁, ▁2 ▁, ▁7 ▁, ▁40 ▁, ▁160 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁count Quad ru ples ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁long ▁long ▁count Cells ▁( ▁int ▁n ▁, ▁int ▁m ▁, ▁int ▁s ▁) ▁{ ▁int ▁mx 1 ▁= ▁-1 ▁; ▁int ▁cont 1 ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁&& ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁{ ▁int ▁aux ▁= ▁( ▁n ▁- ▁( ▁i ▁+ ▁1 ▁) ▁) ▁/ ▁s ▁+ ▁1 ▁; ▁if ▁( ▁aux ▁> ▁mx 1 ▁) ▁{ ▁mx 1 ▁= ▁cont 1 ▁= ▁aux ▁; ▁} ▁else ▁if ▁( ▁aux ▁== ▁mx 1 ▁) ▁cont 1 ▁+= ▁aux ▁; ▁} ▁int ▁mx 2 ▁= ▁-1 ▁; ▁int ▁cont 2 ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁&& ▁i ▁< ▁m ▁; ▁++ ▁i ▁) ▁{ ▁int ▁aux ▁= ▁( ▁m ▁- ▁( ▁i ▁+ ▁1 ▁) ▁) ▁/ ▁s ▁+ ▁1 ▁; ▁if ▁( ▁aux ▁> ▁mx 2 ▁) ▁mx 2 ▁= ▁cont 2 ▁= ▁aux ▁; ▁else ▁if ▁( ▁aux ▁== ▁mx 2 ▁) ▁cont 2 ▁+= ▁aux ▁; ▁} ▁return ▁( ▁long ▁long ▁) ▁( ▁cont 1 ▁* ▁cont 2 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁5 ▁, ▁M ▁= ▁5 ▁, ▁K ▁= ▁2 ▁; ▁c out ▁<< ▁count Cells ▁( ▁N ▁, ▁M ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁minimum Sub array ▁( ▁vector ▁< ▁int ▁> ▁arr ▁, ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁vector ▁< ▁int ▁> ▁map u ▁( ▁m ▁+ ▁1 ▁, ▁0 ▁) ▁; ▁int ▁c ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁map u ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁++ ▁; ▁if ▁( ▁map u ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁== ▁( ▁n ▁/ ▁m ▁) ▁+ ▁1 ▁) ▁c ▁++ ▁; ▁} ▁if ▁( ▁c ▁== ▁0 ▁) ▁return ▁0 ▁; ▁int ▁ans ▁= ▁n ▁; ▁int ▁l ▁= ▁0 ▁, ▁r ▁= ▁0 ▁; ▁while ▁( ▁r ▁< ▁n ▁) ▁{ ▁if ▁( ▁-- ▁map u ▁[ ▁arr ▁[ ▁r ▁] ▁] ▁== ▁( ▁n ▁/ ▁m ▁) ▁) ▁c ▁-- ▁; ▁if ▁( ▁c ▁== ▁0 ▁) ▁{ ▁while ▁( ▁l ▁<= ▁r ▁&& ▁c ▁== ▁0 ▁) ▁{ ▁ans ▁= ▁min ▁( ▁ans ▁, ▁r ▁- ▁l ▁+ ▁1 ▁) ▁; ▁if ▁( ▁++ ▁map u ▁[ ▁arr ▁[ ▁l ▁] ▁] ▁> ▁( ▁n ▁/ ▁m ▁) ▁) ▁c ▁++ ▁; ▁l ▁++ ▁; ▁} ▁} ▁r ▁++ ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁int ▁> ▁arr ▁= ▁{ ▁1 ▁, ▁1 ▁, ▁2 ▁, ▁1 ▁, ▁1 ▁, ▁2 ▁} ▁; ▁int ▁M ▁= ▁2 ▁; ▁int ▁N ▁= ▁arr ▁. ▁size ▁( ▁) ▁; ▁c out ▁<< ▁minimum Sub array ▁( ▁arr ▁, ▁N ▁, ▁M ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁fact ▁( ▁int ▁n ▁) ▁{ ▁int ▁res ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁res ▁= ▁res ▁* ▁i ▁; ▁} ▁return ▁res ▁; ▁} ▁int ▁n Cr ▁( ▁int ▁n ▁, ▁int ▁r ▁) ▁{ ▁return ▁fact ▁( ▁n ▁) ▁/ ▁( ▁fact ▁( ▁r ▁) ▁* ▁fact ▁( ▁n ▁- ▁r ▁) ▁) ▁; ▁} ▁void ▁count W ays ▁( ▁string ▁s ▁, ▁string ▁t ▁) ▁{ ▁int ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁int ▁sum 1 ▁= ▁0 ▁, ▁sum 2 ▁= ▁0 ▁, ▁K ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁[ ▁i ▁] ▁== ▁'1' ▁) ▁{ ▁sum 1 ▁++ ▁; ▁} ▁else ▁sum 1 ▁-- ▁; ▁} ▁int ▁m ▁= ▁t ▁. ▁length ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁m ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁t ▁[ ▁i ▁] ▁== ▁'1' ▁) ▁{ ▁sum 2 ▁++ ▁; ▁} ▁else ▁if ▁( ▁t ▁[ ▁i ▁] ▁== ▁'0' ▁) ▁{ ▁sum 2 ▁-- ▁; ▁} ▁else ▁K ▁++ ▁; ▁} ▁int ▁P ▁= ▁abs ▁( ▁sum 1 ▁- ▁sum 2 ▁) ▁; ▁if ▁( ▁P ▁> ▁K ▁or ▁( ▁K ▁- ▁P ▁) ▁% ▁2 ▁) ▁{ ▁c out ▁<< ▁0 ▁; ▁return ▁; ▁} ▁c out ▁<< ▁n Cr ▁( ▁K ▁, ▁( ▁P ▁+ ▁K ▁) ▁/ ▁2 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁S 1 ▁= ▁"1 01 0" ▁; ▁string ▁S 2 ▁= ▁"10 ▁? ▁? ▁" ▁; ▁count W ays ▁( ▁S 1 ▁, ▁S 2 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁long ▁long ▁AB S ▁( ▁long ▁long ▁x ▁) ▁{ ▁return ▁max ▁( ▁x ▁, ▁- ▁x ▁) ▁; ▁} ▁void ▁find Fraction ▁( ▁long ▁long ▁x ▁, ▁long ▁long ▁y ▁, ▁long ▁long ▁n ▁) ▁{ ▁long ▁long ▁A ▁= ▁-1 ▁, ▁B ▁= ▁-1 ▁; ▁for ▁( ▁long ▁long ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁long ▁long ▁d ▁= ▁( ▁i ▁* ▁x ▁) ▁/ ▁y ▁; ▁if ▁( ▁d ▁>= ▁0 ▁&& ▁( ▁A ▁== ▁-1 ▁|| ▁AB S ▁( ▁B ▁* ▁x ▁- ▁y ▁* ▁A ▁) ▁* ▁AB S ▁( ▁i ▁* ▁y ▁) ▁> ▁AB S ▁( ▁i ▁* ▁x ▁- ▁y ▁* ▁d ▁) ▁* ▁AB S ▁( ▁B ▁* ▁y ▁) ▁) ▁) ▁A ▁= ▁d ▁, ▁B ▁= ▁i ▁; ▁d ▁++ ▁; ▁if ▁( ▁d ▁>= ▁0 ▁&& ▁( ▁A ▁== ▁-1 ▁|| ▁AB S ▁( ▁B ▁* ▁x ▁- ▁y ▁* ▁A ▁) ▁* ▁AB S ▁( ▁i ▁* ▁y ▁) ▁> ▁AB S ▁( ▁i ▁* ▁x ▁- ▁y ▁* ▁d ▁) ▁* ▁AB S ▁( ▁B ▁* ▁y ▁) ▁) ▁) ▁A ▁= ▁d ▁, ▁B ▁= ▁i ▁; ▁} ▁c out ▁<< ▁A ▁<< ▁" ▁/ ▁" ▁<< ▁B ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁long ▁long ▁x ▁= ▁3 ▁, ▁y ▁= ▁7 ▁, ▁n ▁= ▁6 ▁; ▁find Fraction ▁( ▁x ▁, ▁y ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁vector ▁< ▁string ▁> ▁Fraction Split ▁( ▁long ▁long ▁n ▁, ▁long ▁long ▁d ▁) ▁{ ▁vector ▁< ▁string ▁> ▁Unit F actions ▁; ▁while ▁( ▁n ▁> ▁0 ▁) ▁{ ▁long ▁long ▁x ▁= ▁( ▁d ▁+ ▁n ▁- ▁1 ▁) ▁/ ▁n ▁; ▁string ▁s ▁= ▁"1 ▁/ ▁" ▁+ ▁to _ string ▁( ▁x ▁) ▁; ▁Unit F actions ▁. ▁push _ back ▁( ▁s ▁) ▁; ▁n ▁= ▁n ▁* ▁x ▁- ▁d ▁; ▁d ▁= ▁d ▁* ▁x ▁; ▁} ▁return ▁Unit F actions ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁long ▁long ▁n ▁= ▁13 ▁, ▁d ▁= ▁18 ▁; ▁auto ▁res ▁= ▁Fraction Split ▁( ▁n ▁, ▁d ▁) ▁; ▁for ▁( ▁string ▁s ▁: ▁res ▁) ▁c out ▁<< ▁s ▁<< ▁" ▁, ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁minimum Distance ▁( ▁vector ▁< ▁int ▁> ▁arr ▁, ▁int ▁N ▁) ▁{ ▁int ▁ind ▁= ▁0 ▁; ▁int ▁prev ▁= ▁arr ▁[ ▁ind ▁] ▁; ▁int ▁s ▁= ▁arr ▁. ▁size ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁int ▁distance ▁= ▁INT _ MAX ▁; ▁if ▁( ▁i ▁< ▁arr ▁[ ▁0 ▁] ▁) ▁{ ▁distance ▁= ▁arr ▁[ ▁0 ▁] ▁- ▁i ▁; ▁} ▁else ▁if ▁( ▁i ▁>= ▁prev ▁&& ▁ind ▁+ ▁1 ▁< ▁s ▁&& ▁i ▁<= ▁arr ▁[ ▁ind ▁+ ▁1 ▁] ▁) ▁{ ▁distance ▁= ▁min ▁( ▁i ▁- ▁prev ▁, ▁arr ▁[ ▁ind ▁+ ▁1 ▁] ▁- ▁i ▁) ▁; ▁if ▁( ▁i ▁== ▁arr ▁[ ▁ind ▁+ ▁1 ▁] ▁) ▁{ ▁distance ▁= ▁0 ▁; ▁prev ▁= ▁arr ▁[ ▁ind ▁+ ▁1 ▁] ▁; ▁ind ▁++ ▁; ▁} ▁} ▁else ▁{ ▁distance ▁= ▁i ▁- ▁prev ▁; ▁} ▁c out ▁<< ▁distance ▁<< ▁" ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁5 ▁; ▁vector ▁< ▁int ▁> ▁arr ▁= ▁{ ▁0 ▁, ▁4 ▁} ▁; ▁minimum Distance ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Of Pairs ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁X ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁unordered _ map ▁< ▁int ▁, ▁int ▁> ▁M ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁M ▁[ ▁( ▁arr ▁[ ▁i ▁] ▁& ▁X ▁) ▁] ▁++ ▁; ▁} ▁for ▁( ▁auto ▁m ▁: ▁M ▁) ▁{ ▁int ▁p ▁= ▁m ▁. ▁second ▁; ▁count ▁+= ▁p ▁* ▁( ▁p ▁- ▁1 ▁) ▁/ ▁2 ▁; ▁} ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁2 ▁, ▁5 ▁, ▁4 ▁, ▁6 ▁, ▁7 ▁} ▁; ▁int ▁X ▁= ▁6 ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁count Of Pairs ▁( ▁arr ▁, ▁N ▁, ▁X ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁prime Factor ization ▁( ▁int ▁N ▁) ▁{ ▁int ▁s ieve ▁[ ▁N ▁/ ▁2 ▁+ ▁1 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁N ▁/ ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ieve ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁* ▁i ▁; ▁j ▁<= ▁N ▁/ ▁2 ▁; ▁j ▁+= ▁i ▁) ▁{ ▁s ieve ▁[ ▁j ▁] ▁= ▁1 ▁; ▁} ▁} ▁} ▁vector ▁< ▁int ▁> ▁prime ▁; ▁for ▁( ▁int ▁i ▁= ▁3 ▁; ▁i ▁<= ▁N ▁/ ▁2 ▁; ▁i ▁++ ▁) ▁if ▁( ▁s ieve ▁[ ▁i ▁] ▁== ▁0 ▁) ▁prime ▁. ▁push _ back ▁( ▁i ▁) ▁; ▁int ▁x ▁= ▁prime ▁. ▁size ▁( ▁) ▁; ▁c out ▁<< ▁"2 ▁- ▁> ▁" ▁<< ▁x ▁<< ▁end l ▁; ▁for ▁( ▁int ▁i ▁: ▁prime ▁) ▁c out ▁<< ▁i ▁<< ▁" ▁- ▁> ▁1" ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁18 ▁; ▁prime Factor ization ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁no Of W ays ▁( ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁string ▁S ▁= ▁to _ string ▁( ▁N ▁) ▁; ▁int ▁ans ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁S ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁int ▁count ▁= ▁1 ▁; ▁while ▁( ▁i ▁< ▁S ▁. ▁length ▁( ▁) ▁&& ▁S ▁[ ▁i ▁] ▁- ▁'0' ▁+ ▁S ▁[ ▁i ▁- ▁1 ▁] ▁- ▁'0' ▁== ▁K ▁) ▁{ ▁count ▁++ ▁; ▁i ▁++ ▁; ▁} ▁if ▁( ▁count ▁% ▁2 ▁) ▁ans ▁*= ▁( ▁count ▁+ ▁1 ▁) ▁/ ▁2 ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁145 4 78 1 ▁; ▁int ▁K ▁= ▁9 ▁; ▁c out ▁<< ▁no Of W ays ▁( ▁N ▁, ▁K ▁) ▁<< ▁end l ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print Unit ary Div is ors ▁( ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁sqrt ▁( ▁n ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁{ ▁if ▁( ▁n ▁/ ▁i ▁== ▁i ▁&& ▁__ g cd ▁( ▁i ▁, ▁n ▁/ ▁i ▁) ▁== ▁1 ▁) ▁{ ▁printf ▁( ▁" ▁% ▁d ▁" ▁, ▁i ▁) ▁; ▁} ▁else ▁{ ▁if ▁( ▁__ g cd ▁( ▁i ▁, ▁n ▁/ ▁i ▁) ▁== ▁1 ▁) ▁{ ▁printf ▁( ▁" ▁% ▁d ▁% ▁d ▁" ▁, ▁i ▁, ▁n ▁/ ▁i ▁) ▁; ▁} ▁} ▁} ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁12 ▁; ▁print Unit ary Div is ors ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁getPerm utation ▁( ▁int ▁N ▁) ▁{ ▁if ▁( ▁N ▁<= ▁3 ▁) ▁{ ▁c out ▁<< ▁-1 ▁; ▁return ▁; ▁} ▁int ▁i ▁= ▁N ▁; ▁if ▁( ▁N ▁% ▁2 ▁== ▁0 ▁) ▁i ▁-- ▁; ▁while ▁( ▁i ▁>= ▁1 ▁) ▁{ ▁c out ▁<< ▁i ▁<< ▁" ▁" ▁; ▁i ▁-= ▁2 ▁; ▁} ▁c out ▁<< ▁4 ▁<< ▁" ▁" ▁<< ▁2 ▁<< ▁" ▁" ▁; ▁i ▁= ▁6 ▁; ▁while ▁( ▁i ▁<= ▁N ▁) ▁{ ▁c out ▁<< ▁i ▁<< ▁" ▁" ▁; ▁i ▁+= ▁2 ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁9 ▁; ▁getPerm utation ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁max Score Sub Array ▁( ▁int ▁* ▁a ▁, ▁int ▁* ▁b ▁, ▁int ▁n ▁) ▁{ ▁int ▁res ▁= ▁0 ▁; ▁for ▁( ▁int ▁mid ▁= ▁0 ▁; ▁mid ▁< ▁n ▁; ▁mid ▁++ ▁) ▁{ ▁int ▁straight Score ▁= ▁a ▁[ ▁mid ▁] ▁* ▁b ▁[ ▁mid ▁] ▁, ▁reverse Score ▁= ▁a ▁[ ▁mid ▁] ▁* ▁a ▁[ ▁mid ▁] ▁; ▁int ▁prev ▁= ▁mid ▁- ▁1 ▁, ▁next ▁= ▁mid ▁+ ▁1 ▁; ▁res ▁= ▁max ▁( ▁res ▁, ▁max ▁( ▁straight Score ▁, ▁reverse Score ▁) ▁) ▁; ▁while ▁( ▁prev ▁>= ▁0 ▁&& ▁next ▁< ▁n ▁) ▁{ ▁straight Score ▁+= ▁( ▁a ▁[ ▁prev ▁] ▁* ▁b ▁[ ▁prev ▁] ▁+ ▁a ▁[ ▁next ▁] ▁* ▁b ▁[ ▁next ▁] ▁) ▁; ▁reverse Score ▁+= ▁( ▁a ▁[ ▁prev ▁] ▁* ▁b ▁[ ▁next ▁] ▁+ ▁a ▁[ ▁next ▁] ▁* ▁b ▁[ ▁prev ▁] ▁) ▁; ▁res ▁= ▁max ▁( ▁res ▁, ▁max ▁( ▁straight Score ▁, ▁reverse Score ▁) ▁) ▁; ▁prev ▁-- ▁; ▁next ▁++ ▁; ▁} ▁straight Score ▁= ▁0 ▁; ▁reverse Score ▁= ▁0 ▁; ▁prev ▁= ▁mid ▁- ▁1 ▁, ▁next ▁= ▁mid ▁; ▁while ▁( ▁prev ▁>= ▁0 ▁&& ▁next ▁< ▁n ▁) ▁{ ▁straight Score ▁+= ▁( ▁a ▁[ ▁prev ▁] ▁* ▁b ▁[ ▁prev ▁] ▁+ ▁a ▁[ ▁next ▁] ▁* ▁b ▁[ ▁next ▁] ▁) ▁; ▁reverse Score ▁+= ▁( ▁a ▁[ ▁prev ▁] ▁* ▁b ▁[ ▁next ▁] ▁+ ▁a ▁[ ▁next ▁] ▁* ▁b ▁[ ▁prev ▁] ▁) ▁; ▁res ▁= ▁max ▁( ▁res ▁, ▁max ▁( ▁straight Score ▁, ▁reverse Score ▁) ▁) ▁; ▁prev ▁-- ▁; ▁next ▁++ ▁; ▁} ▁} ▁c out ▁<< ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁13 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁B ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁22 ▁, ▁2 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁A ▁) ▁/ ▁sizeof ▁( ▁A ▁[ ▁0 ▁] ▁) ▁; ▁max Score Sub Array ▁( ▁A ▁, ▁B ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁count Values ▁( ▁int ▁A ▁, ▁int ▁B ▁, ▁int ▁C ▁) ▁{ ▁if ▁( ▁B ▁>= ▁A ▁) ▁{ ▁c out ▁<< ▁0 ▁; ▁return ▁; ▁} ▁if ▁( ▁B ▁== ▁0 ▁) ▁{ ▁c out ▁<< ▁C ▁/ ▁A ▁; ▁return ▁; ▁} ▁int ▁ans ▁= ▁C ▁/ ▁A ▁; ▁if ▁( ▁ans ▁* ▁A ▁+ ▁B ▁<= ▁C ▁) ▁{ ▁ans ▁++ ▁; ▁} ▁c out ▁<< ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁= ▁6 ▁, ▁B ▁= ▁3 ▁, ▁N ▁= ▁15 ▁; ▁count Values ▁( ▁A ▁, ▁B ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁max Frequency ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁sort ▁( ▁arr ▁, ▁arr ▁+ ▁N ▁) ▁; ▁int ▁start ▁= ▁0 ▁, ▁end ▁= ▁0 ▁; ▁int ▁sum ▁= ▁0 ▁, ▁res ▁= ▁0 ▁; ▁for ▁( ▁end ▁= ▁0 ▁; ▁end ▁< ▁N ▁; ▁end ▁++ ▁) ▁{ ▁sum ▁+= ▁arr ▁[ ▁end ▁] ▁; ▁while ▁( ▁( ▁end ▁- ▁start ▁+ ▁1 ▁) ▁* ▁arr ▁[ ▁end ▁] ▁- ▁sum ▁> ▁K ▁) ▁{ ▁sum ▁-= ▁arr ▁[ ▁start ▁] ▁; ▁start ▁++ ▁; ▁} ▁res ▁= ▁max ▁( ▁res ▁, ▁end ▁- ▁start ▁+ ▁1 ▁) ▁; ▁} ▁c out ▁<< ▁res ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁4 ▁, ▁8 ▁, ▁13 ▁} ▁; ▁int ▁N ▁= ▁4 ▁; ▁int ▁K ▁= ▁5 ▁; ▁max Frequency ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁count Pairs ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁x ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁map ▁< ▁int ▁, ▁int ▁> ▁mp ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁mp ▁[ ▁arr ▁[ ▁i ▁] ▁- ▁x ▁* ▁i ▁] ▁++ ▁; ▁} ▁for ▁( ▁auto ▁x ▁: ▁mp ▁) ▁{ ▁int ▁n ▁= ▁x ▁. ▁second ▁; ▁count ▁+= ▁( ▁n ▁* ▁( ▁n ▁- ▁1 ▁) ▁) ▁/ ▁2 ▁; ▁} ▁c out ▁<< ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁6 ▁, ▁x ▁= ▁3 ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁4 ▁, ▁8 ▁, ▁11 ▁, ▁13 ▁, ▁16 ▁} ▁; ▁count Pairs ▁( ▁arr ▁, ▁n ▁, ▁x ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁sum Of Div is ors ▁( ▁int ▁N ▁) ▁{ ▁return ▁N ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁5 ▁; ▁c out ▁<< ▁sum Of Div is ors ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find X ORS ▁( ▁int ▁arr 1 ▁[ ▁] ▁, ▁int ▁arr 2 ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁M ▁) ▁{ ▁int ▁X ORS 1 ▁= ▁0 ▁; ▁int ▁X ORS 2 ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁X ORS 1 ▁^= ▁arr 1 ▁[ ▁i ▁] ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁M ▁; ▁i ▁++ ▁) ▁{ ▁X ORS 2 ▁^= ▁arr 2 ▁[ ▁i ▁] ▁; ▁} ▁return ▁X ORS 1 ▁and ▁X ORS 2 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr 1 ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁; ▁int ▁arr 2 ▁[ ▁] ▁= ▁{ ▁6 ▁, ▁5 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr 1 ▁) ▁/ ▁sizeof ▁( ▁arr 1 ▁[ ▁0 ▁] ▁) ▁; ▁int ▁M ▁= ▁sizeof ▁( ▁arr 2 ▁) ▁/ ▁sizeof ▁( ▁arr 2 ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁find X ORS ▁( ▁arr 1 ▁, ▁arr 2 ▁, ▁N ▁, ▁M ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁ceil Difference ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁x ▁) ▁{ ▁int ▁total Sum ▁= ▁0 ▁; ▁int ▁per Element Sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁total Sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁per Element Sum ▁+= ▁ceil ▁( ▁( ▁double ▁) ▁( ▁arr ▁[ ▁i ▁] ▁) ▁/ ▁( ▁double ▁) ▁( ▁x ▁) ▁) ▁; ▁} ▁int ▁total C e il Sum ▁= ▁ceil ▁( ▁( ▁double ▁) ▁( ▁total Sum ▁) ▁/ ▁( ▁double ▁) ▁( ▁x ▁) ▁) ▁; ▁return ▁abs ▁( ▁per Element Sum ▁- ▁total C e il Sum ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁int ▁K ▁= ▁4 ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁ceil Difference ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Tri pl ets ▁( ▁int ▁N ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁<= ▁N ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁i ▁* ▁j ▁> ▁N ▁) ▁break ▁; ▁ans ▁+= ▁N ▁/ ▁( ▁i ▁* ▁j ▁) ▁; ▁} ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁10 ▁; ▁c out ▁<< ▁count Tri pl ets ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁min Step K ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁int ▁E ▁= ▁0 ▁; ▁int ▁S ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁S ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁if ▁( ▁arr ▁[ ▁i ▁] ▁% ▁2 ▁== ▁0 ▁) ▁E ▁+= ▁1 ▁; ▁} ▁if ▁( ▁S ▁>= ▁K ▁) ▁return ▁0 ▁; ▁else ▁if ▁( ▁S ▁+ ▁E ▁< ▁K ▁) ▁return ▁-1 ▁; ▁else ▁return ▁K ▁- ▁S ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁K ▁= ▁4 ▁; ▁c out ▁<< ▁min Step K ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁S ieve Of E rat ost hen es ▁( ▁int ▁n ▁, ▁bool ▁prime ▁[ ▁] ▁) ▁{ ▁prime ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁prime ▁[ ▁1 ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁* ▁p ▁<= ▁n ▁; ▁p ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁p ▁] ▁== ▁true ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁p ▁* ▁p ▁; ▁i ▁<= ▁n ▁; ▁i ▁+= ▁p ▁) ▁{ ▁prime ▁[ ▁i ▁] ▁= ▁false ▁; ▁} ▁} ▁} ▁} ▁void ▁count Prime ▁( ▁int ▁n ▁) ▁{ ▁bool ▁prime ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁mem set ▁( ▁prime ▁, ▁true ▁, ▁sizeof ▁( ▁prime ▁) ▁) ▁; ▁S ieve Of E rat ost hen es ▁( ▁n ▁, ▁prime ▁) ▁; ▁int ▁dp ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁mem set ▁( ▁dp ▁, ▁0 ▁, ▁sizeof ▁( ▁dp ▁) ▁) ▁; ▁dp ▁[ ▁1 ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁+= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁; ▁if ▁( ▁prime ▁[ ▁i ▁] ▁== ▁1 ▁&& ▁prime ▁[ ▁i ▁- ▁2 ▁] ▁== ▁1 ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁++ ▁; ▁} ▁} ▁c out ▁<< ▁dp ▁[ ▁n ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁6 ▁; ▁count Prime ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁sum Of S quared D ifferences ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁int ▁sum A ▁= ▁0 ▁, ▁sum B ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁sum A ▁+= ▁( ▁arr ▁[ ▁i ▁] ▁* ▁arr ▁[ ▁i ▁] ▁) ▁; ▁sum B ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁sum A ▁= ▁N ▁* ▁sum A ▁; ▁sum B ▁= ▁( ▁sum B ▁* ▁sum B ▁) ▁; ▁ans ▁= ▁sum A ▁- ▁sum B ▁; ▁c out ▁<< ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁8 ▁, ▁4 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁sum Of S quared D ifferences ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count AP s ▁( ▁int ▁S ▁, ▁int ▁D ▁) ▁{ ▁S ▁= ▁S ▁* ▁2 ▁; ▁int ▁answer ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁sqrt ▁( ▁S ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁S ▁% ▁i ▁== ▁0 ▁) ▁{ ▁if ▁( ▁( ▁( ▁S ▁/ ▁i ▁) ▁- ▁D ▁* ▁i ▁+ ▁D ▁) ▁% ▁2 ▁== ▁0 ▁) ▁answer ▁++ ▁; ▁if ▁( ▁( ▁D ▁* ▁i ▁- ▁( ▁S ▁/ ▁i ▁) ▁+ ▁D ▁) ▁% ▁2 ▁== ▁0 ▁) ▁answer ▁++ ▁; ▁} ▁} ▁return ▁answer ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁S ▁= ▁12 ▁, ▁D ▁= ▁1 ▁; ▁c out ▁<< ▁count AP s ▁( ▁S ▁, ▁D ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁distinct ▁( ▁vector ▁< ▁int ▁> ▁arr ▁, ▁int ▁N ▁) ▁{ ▁set ▁< ▁int ▁> ▁st ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁st ▁. ▁insert ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁return ▁st ▁. ▁size ▁( ▁) ▁; ▁} ▁int ▁max Sub array Sum Util ▁( ▁vector ▁< ▁int ▁> ▁arr ▁, ▁int ▁N ▁, ▁int ▁K ▁, ▁int ▁total Distinct ▁) ▁{ ▁if ▁( ▁K ▁> ▁N ▁) ▁return ▁0 ▁; ▁int ▁mx ▁= ▁0 ▁; ▁int ▁sum ▁= ▁0 ▁; ▁map ▁< ▁int ▁, ▁int ▁> ▁mp ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁mp ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁+= ▁1 ▁; ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁if ▁( ▁i ▁>= ▁K ▁) ▁{ ▁mp ▁[ ▁arr ▁[ ▁i ▁- ▁K ▁] ▁] ▁-= ▁1 ▁; ▁sum ▁-= ▁arr ▁[ ▁i ▁- ▁K ▁] ▁; ▁if ▁( ▁mp ▁[ ▁arr ▁[ ▁i ▁- ▁K ▁] ▁] ▁== ▁0 ▁) ▁mp ▁. ▁erase ▁( ▁arr ▁[ ▁i ▁- ▁K ▁] ▁) ▁; ▁} ▁if ▁( ▁mp ▁. ▁size ▁( ▁) ▁== ▁total Distinct ▁) ▁mx ▁= ▁max ▁( ▁mx ▁, ▁sum ▁) ▁; ▁} ▁return ▁mx ▁; ▁} ▁void ▁max Sub array Sum ▁( ▁vector ▁< ▁int ▁> ▁arr ▁, ▁int ▁K ▁) ▁{ ▁int ▁N ▁= ▁arr ▁. ▁size ▁( ▁) ▁; ▁int ▁total Distinct ▁= ▁distinct ▁( ▁arr ▁, ▁N ▁) ▁; ▁c out ▁<< ▁max Sub array Sum Util ▁( ▁arr ▁, ▁N ▁, ▁K ▁, ▁total Distinct ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁int ▁> ▁arr ▁{ ▁7 ▁, ▁7 ▁, ▁2 ▁, ▁4 ▁, ▁2 ▁, ▁7 ▁, ▁4 ▁, ▁6 ▁, ▁6 ▁, ▁6 ▁} ▁; ▁int ▁K ▁= ▁6 ▁; ▁max Sub array Sum ▁( ▁arr ▁, ▁K ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁process Diag onal ▁( ▁vector ▁< ▁int ▁> ▁arr ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁int ▁getBit ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁32 ▁; ▁i ▁++ ▁) ▁{ ▁int ▁S ▁= ▁0 ▁; ▁int ▁NS ▁= ▁0 ▁; ▁for ▁( ▁auto ▁j ▁: ▁arr ▁) ▁{ ▁if ▁( ▁getBit ▁& ▁j ▁) ▁S ▁+= ▁1 ▁; ▁else ▁NS ▁+= ▁1 ▁; ▁} ▁if ▁( ▁S ▁> ▁NS ▁) ▁ans ▁+= ▁pow ▁( ▁2 ▁, ▁i ▁) ▁; ▁getBit ▁<<= ▁1 ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁find Sum ▁( ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁mat ▁) ▁{ ▁int ▁i ▁= ▁0 ▁; ▁int ▁j ▁= ▁0 ▁; ▁vector ▁< ▁int ▁> ▁pri Diag ▁; ▁while ▁( ▁i ▁< ▁mat ▁. ▁size ▁( ▁) ▁) ▁{ ▁pri Diag ▁. ▁push _ back ▁( ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁; ▁i ▁+= ▁1 ▁; ▁j ▁+= ▁1 ▁; ▁} ▁i ▁= ▁0 ▁; ▁j ▁= ▁mat ▁. ▁size ▁( ▁) ▁- ▁1 ▁; ▁vector ▁< ▁int ▁> ▁sec Diag ▁; ▁while ▁( ▁i ▁< ▁mat ▁. ▁size ▁( ▁) ▁) ▁{ ▁sec Diag ▁. ▁push _ back ▁( ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁; ▁i ▁+= ▁1 ▁; ▁j ▁-= ▁1 ▁; ▁} ▁return ▁process Diag onal ▁( ▁pri Diag ▁) ▁+ ▁process Diag onal ▁( ▁sec Diag ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁mat ▁{ ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁, ▁{ ▁4 ▁, ▁5 ▁, ▁6 ▁} ▁, ▁{ ▁7 ▁, ▁8 ▁, ▁9 ▁} ▁} ▁; ▁c out ▁<< ▁find Sum ▁( ▁mat ▁) ▁<< ▁end l ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is pal in ▁( ▁int ▁num ▁) ▁{ ▁string ▁s ▁= ▁to _ string ▁( ▁num ▁) ▁; ▁int ▁st ▁= ▁0 ▁, ▁ed ▁= ▁s ▁. ▁size ▁( ▁) ▁- ▁1 ▁; ▁while ▁( ▁st ▁<= ▁ed ▁) ▁{ ▁if ▁( ▁s ▁[ ▁st ▁] ▁!= ▁s ▁[ ▁ed ▁] ▁) ▁return ▁false ▁; ▁st ▁++ ▁; ▁ed ▁-- ▁; ▁} ▁return ▁true ▁; ▁} ▁void ▁Calculate X OR and OR ▁( ▁int ▁n ▁) ▁{ ▁int ▁Calculate X OR ▁= ▁0 ▁; ▁int ▁Calculate OR ▁= ▁0 ▁; ▁int ▁start ▁= ▁pow ▁( ▁10 ▁, ▁n ▁- ▁1 ▁) ▁; ▁int ▁end ▁= ▁pow ▁( ▁10 ▁, ▁n ▁) ▁- ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁start ▁; ▁i ▁<= ▁end ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁is pal in ▁( ▁i ▁) ▁) ▁{ ▁Calculate X OR ▁= ▁Calculate X OR ▁^ ▁i ▁; ▁Calculate OR ▁= ▁Calculate OR ▁| ▁i ▁; ▁} ▁} ▁c out ▁<< ▁" ▁XOR ▁= ▁" ▁<< ▁Calculate X OR ▁; ▁c out ▁<< ▁" ▁OR ▁= ▁" ▁<< ▁Calculate OR ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁4 ▁; ▁Calculate X OR and OR ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁pow Of Positive ▁( ▁int ▁n ▁) ▁{ ▁int ▁pos ▁= ▁floor ▁( ▁log 2 ▁( ▁n ▁) ▁) ▁; ▁return ▁pow ▁( ▁2 ▁, ▁pos ▁) ▁; ▁} ▁int ▁pow Of Negative ▁( ▁int ▁n ▁) ▁{ ▁int ▁pos ▁= ▁ceil ▁( ▁log 2 ▁( ▁n ▁) ▁) ▁; ▁return ▁( ▁-1 ▁* ▁pow ▁( ▁2 ▁, ▁pos ▁) ▁) ▁; ▁} ▁void ▁highest Power Of 2 ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁> ▁0 ▁) ▁{ ▁c out ▁<< ▁pow Of Positive ▁( ▁n ▁) ▁; ▁} ▁else ▁{ ▁n ▁= ▁- ▁n ▁; ▁c out ▁<< ▁pow Of Negative ▁( ▁n ▁) ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁- 24 ▁; ▁highest Power Of 2 ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁summ ation ▁( ▁int ▁n ▁) ▁{ ▁int ▁abs _ sum ▁= ▁n ▁* ▁( ▁n ▁+ ▁1 ▁) ▁/ ▁2 ▁; ▁int ▁sign ▁= ▁n ▁+ ▁1 ▁% ▁2 ▁== ▁0 ▁? ▁1 ▁: ▁-1 ▁; ▁int ▁result _ sum ▁= ▁sign ▁* ▁abs _ sum ▁; ▁return ▁result _ sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁2 ▁; ▁c out ▁<< ▁summ ation ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is Power ▁( ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁int ▁res 1 ▁= ▁log ▁( ▁y ▁) ▁/ ▁log ▁( ▁x ▁) ▁; ▁double ▁res 2 ▁= ▁log ▁( ▁y ▁) ▁/ ▁log ▁( ▁x ▁) ▁; ▁return ▁( ▁res 1 ▁== ▁res 2 ▁) ▁; ▁} ▁int ▁count Power ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁res ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁if ▁( ▁is Power ▁( ▁arr ▁[ ▁i ▁] ▁, ▁arr ▁[ ▁j ▁] ▁) ▁|| ▁is Power ▁( ▁arr ▁[ ▁j ▁] ▁, ▁arr ▁[ ▁i ▁] ▁) ▁) ▁res ▁++ ▁; ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁16 ▁, ▁2 ▁, ▁3 ▁, ▁9 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁count Power ▁( ▁a ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁no Of Cards ▁( ▁int ▁n ▁) ▁{ ▁return ▁n ▁* ▁( ▁3 ▁* ▁n ▁+ ▁1 ▁) ▁/ ▁2 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁3 ▁; ▁c out ▁<< ▁no Of Cards ▁( ▁n ▁) ▁<< ▁" ▁, ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁pair Count ▁( ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁int ▁cnt ▁= ▁0 ▁, ▁b ▁, ▁a ▁; ▁for ▁( ▁b ▁= ▁0 ▁; ▁b ▁<= ▁sqrt ▁( ▁m ▁) ▁; ▁b ▁++ ▁) ▁{ ▁a ▁= ▁m ▁- ▁b ▁* ▁b ▁; ▁if ▁( ▁a ▁* ▁a ▁+ ▁b ▁== ▁n ▁) ▁{ ▁cnt ▁++ ▁; ▁} ▁} ▁return ▁cnt ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁9 ▁, ▁m ▁= ▁3 ▁; ▁c out ▁<< ▁pair Count ▁( ▁n ▁, ▁m ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁bin omial Co eff ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁C ▁[ ▁k ▁+ ▁1 ▁] ▁; ▁mem set ▁( ▁C ▁, ▁0 ▁, ▁sizeof ▁( ▁C ▁) ▁) ▁; ▁C ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁min ▁( ▁i ▁, ▁k ▁) ▁; ▁j ▁> ▁0 ▁; ▁j ▁-- ▁) ▁C ▁[ ▁j ▁] ▁= ▁C ▁[ ▁j ▁] ▁+ ▁C ▁[ ▁j ▁- ▁1 ▁] ▁; ▁} ▁return ▁C ▁[ ▁k ▁] ▁; ▁} ▁int ▁count _ of _ sub arrays ▁( ▁int ▁N ▁) ▁{ ▁int ▁count ▁= ▁bin omial Co eff ▁( ▁2 ▁* ▁N ▁- ▁1 ▁, ▁N ▁) ▁; ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁3 ▁; ▁c out ▁<< ▁count _ of _ sub arrays ▁( ▁N ▁) ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max G CD ▁( ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁int ▁min Sum ▁= ▁( ▁K ▁* ▁( ▁K ▁+ ▁1 ▁) ▁) ▁/ ▁2 ▁; ▁if ▁( ▁N ▁< ▁min Sum ▁) ▁return ▁-1 ▁; ▁int ▁i ▁= ▁sqrt ▁( ▁N ▁) ▁; ▁int ▁res ▁= ▁1 ▁; ▁while ▁( ▁i ▁>= ▁1 ▁) ▁{ ▁if ▁( ▁N ▁% ▁i ▁== ▁0 ▁) ▁{ ▁if ▁( ▁i ▁>= ▁min Sum ▁) ▁res ▁= ▁max ▁( ▁res ▁, ▁N ▁/ ▁i ▁) ▁; ▁if ▁( ▁N ▁/ ▁i ▁>= ▁min Sum ▁) ▁res ▁= ▁max ▁( ▁res ▁, ▁i ▁) ▁; ▁} ▁i ▁-- ▁; ▁} ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁18 ▁, ▁K ▁= ▁3 ▁; ▁c out ▁<< ▁max G CD ▁( ▁N ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁long ▁double ▁getSum ▁( ▁int ▁n ▁) ▁{ ▁long ▁double ▁sum ▁= ▁0 ▁; ▁if ▁( ▁n ▁== ▁1 ▁) ▁{ ▁sum ▁= ▁45 .0 ▁; ▁} ▁else ▁{ ▁sum ▁= ▁( ▁99 .0 ▁/ ▁2.0 ▁) ▁* ▁pow ▁( ▁10 ▁, ▁n ▁- ▁1 ▁) ▁* ▁pow ▁( ▁10 ▁, ▁( ▁n ▁- ▁1 ▁) ▁/ ▁2 ▁) ▁; ▁} ▁return ▁sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁3 ▁; ▁long ▁double ▁ans ▁= ▁getSum ▁( ▁n ▁) ▁; ▁c out ▁<< ▁set precision ▁( ▁12 ▁) ▁<< ▁ans ▁<< ▁' ▁' ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Min ▁( ▁int ▁* ▁arr ▁, ▁int ▁n ▁) ▁{ ▁int ▁m ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁m ▁= ▁max ▁( ▁m ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁int ▁freq ▁[ ▁m ▁+ ▁2 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁freq ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁++ ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁m ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁int ▁j ▁= ▁i ▁; ▁int ▁cnt ▁= ▁0 ▁; ▁while ▁( ▁j ▁<= ▁m ▁) ▁{ ▁cnt ▁+= ▁freq ▁[ ▁j ▁] ▁; ▁j ▁+= ▁i ▁; ▁} ▁if ▁( ▁! ▁cnt ▁) ▁return ▁i ▁; ▁} ▁return ▁m ▁+ ▁1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁12 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁c out ▁<< ▁find Min ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Min Del ▁( ▁int ▁* ▁arr ▁, ▁int ▁n ▁) ▁{ ▁int ▁min _ num ▁= ▁INT _ MAX ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁min _ num ▁= ▁min ▁( ▁arr ▁[ ▁i ▁] ▁, ▁min _ num ▁) ▁; ▁int ▁cnt ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁min _ num ▁) ▁cnt ▁++ ▁; ▁return ▁n ▁- ▁cnt ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁3 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁c out ▁<< ▁find Min Del ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Digits ▁( ▁int ▁n ▁) ▁{ ▁int ▁cnt ▁= ▁0 ▁; ▁while ▁( ▁n ▁> ▁0 ▁) ▁{ ▁cnt ▁++ ▁; ▁n ▁/= ▁10 ▁; ▁} ▁return ▁cnt ▁; ▁} ▁int ▁digit Pow Sum ▁( ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁int ▁pw ▁= ▁count Digits ▁( ▁n ▁) ▁; ▁while ▁( ▁n ▁> ▁0 ▁) ▁{ ▁int ▁d ▁= ▁n ▁% ▁10 ▁; ▁sum ▁+= ▁pow ▁( ▁d ▁, ▁pw ▁) ▁; ▁pw ▁-- ▁; ▁n ▁/= ▁10 ▁; ▁} ▁return ▁sum ▁; ▁} ▁int ▁count Num ▁( ▁int ▁n ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁== ▁digit Pow Sum ▁( ▁i ▁) ▁) ▁{ ▁count ▁++ ▁; ▁} ▁} ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁200 ▁; ▁c out ▁<< ▁count Num ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁perfect Square s ▁( ▁float ▁l ▁, ▁float ▁r ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁l ▁; ▁i ▁<= ▁r ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁sqrt ▁( ▁i ▁) ▁== ▁( ▁int ▁) ▁sqrt ▁( ▁i ▁) ▁) ▁c out ▁<< ▁i ▁<< ▁" ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁l ▁= ▁2 ▁, ▁r ▁= ▁24 ▁; ▁perfect Square s ▁( ▁l ▁, ▁r ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find W inner ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁( ▁n ▁- ▁1 ▁) ▁% ▁6 ▁== ▁0 ▁) ▁{ ▁c out ▁<< ▁" ▁Second ▁Player ▁wins ▁the ▁game ▁" ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁" ▁First ▁Player ▁wins ▁the ▁game ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁7 ▁; ▁find W inner ▁( ▁n ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁l cm ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁int ▁GC D ▁= ▁__ g cd ▁( ▁a ▁, ▁b ▁) ▁; ▁return ▁( ▁a ▁* ▁b ▁) ▁/ ▁GC D ▁; ▁} ▁int ▁Min L CM ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁Prefix ▁[ ▁n ▁+ ▁2 ▁] ▁; ▁int ▁S uffix ▁[ ▁n ▁+ ▁2 ▁] ▁; ▁Prefix ▁[ ▁1 ▁] ▁= ▁a ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁n ▁; ▁i ▁+= ▁1 ▁) ▁{ ▁Prefix ▁[ ▁i ▁] ▁= ▁l cm ▁( ▁Prefix ▁[ ▁i ▁- ▁1 ▁] ▁, ▁a ▁[ ▁i ▁- ▁1 ▁] ▁) ▁; ▁} ▁S uffix ▁[ ▁n ▁] ▁= ▁a ▁[ ▁n ▁- ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁1 ▁; ▁i ▁-= ▁1 ▁) ▁{ ▁S uffix ▁[ ▁i ▁] ▁= ▁l cm ▁( ▁S uffix ▁[ ▁i ▁+ ▁1 ▁] ▁, ▁a ▁[ ▁i ▁- ▁1 ▁] ▁) ▁; ▁} ▁int ▁ans ▁= ▁min ▁( ▁S uffix ▁[ ▁2 ▁] ▁, ▁Prefix ▁[ ▁n ▁- ▁1 ▁] ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁< ▁n ▁; ▁i ▁+= ▁1 ▁) ▁{ ▁ans ▁= ▁min ▁( ▁ans ▁, ▁l cm ▁( ▁Prefix ▁[ ▁i ▁- ▁1 ▁] ▁, ▁S uffix ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁15 ▁, ▁9 ▁, ▁36 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁Min L CM ▁( ▁a ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁int ▁MOD ▁= ▁100 000000 7 ▁; ▁int ▁fact Mod ▁( ▁int ▁n ▁) ▁{ ▁long ▁fact ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁fact ▁*= ▁( ▁i ▁% ▁MOD ▁) ▁; ▁fact ▁% = ▁MOD ▁; ▁} ▁return ▁fact ▁; ▁} ▁int ▁count W ays ▁( ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁return ▁fact Mod ▁( ▁m ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁2 ▁, ▁m ▁= ▁2 ▁; ▁c out ▁<< ▁count W ays ▁( ▁n ▁, ▁m ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is Composite ▁( ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁sqrt ▁( ▁n ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁return ▁true ▁; ▁} ▁return ▁false ▁; ▁} ▁int ▁Power ▁( ▁int ▁x ▁, ▁int ▁y ▁, ▁int ▁p ▁) ▁{ ▁int ▁res ▁= ▁1 ▁; ▁x ▁= ▁x ▁% ▁p ▁; ▁while ▁( ▁y ▁> ▁0 ▁) ▁{ ▁if ▁( ▁y ▁& ▁1 ▁) ▁{ ▁res ▁= ▁( ▁res ▁* ▁x ▁) ▁% ▁p ▁; ▁} ▁x ▁= ▁( ▁x ▁* ▁x ▁) ▁% ▁p ▁; ▁} ▁return ▁res ▁; ▁} ▁bool ▁is E uler P seud op r ime ▁( ▁int ▁N ▁, ▁int ▁A ▁) ▁{ ▁if ▁( ▁A ▁<= ▁0 ▁) ▁return ▁false ▁; ▁if ▁( ▁N ▁% ▁2 ▁== ▁0 ▁|| ▁! ▁is Composite ▁( ▁N ▁) ▁) ▁return ▁false ▁; ▁if ▁( ▁__ g cd ▁( ▁A ▁, ▁N ▁) ▁!= ▁1 ▁) ▁return ▁false ▁; ▁int ▁mod ▁= ▁Power ▁( ▁A ▁, ▁( ▁N ▁- ▁1 ▁) ▁/ ▁2 ▁, ▁N ▁) ▁; ▁if ▁( ▁mod ▁!= ▁1 ▁&& ▁mod ▁!= ▁N ▁- ▁1 ▁) ▁return ▁false ▁; ▁return ▁true ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁12 1 ▁, ▁A ▁= ▁3 ▁; ▁if ▁( ▁is E uler P seud op r ime ▁( ▁N ▁, ▁A ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁geom etric Mean ▁( ▁int ▁n ▁) ▁{ ▁return ▁sqrt ▁( ▁n ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁16 ▁; ▁c out ▁<< ▁geom etric Mean ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find _ k ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁if ▁( ▁( ▁a ▁+ ▁b ▁) ▁% ▁2 ▁== ▁0 ▁) ▁return ▁( ▁( ▁a ▁+ ▁b ▁) ▁/ ▁2 ▁) ▁; ▁return ▁-1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁= ▁2 ▁, ▁b ▁= ▁16 ▁; ▁c out ▁<< ▁find _ k ▁( ▁a ▁, ▁b ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁cnt Sub Sets ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁max Val ▁= ▁* ▁max _ element ▁( ▁arr ▁, ▁arr ▁+ ▁n ▁) ▁; ▁int ▁cnt ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁max Val ▁) ▁cnt ▁++ ▁; ▁} ▁return ▁( ▁pow ▁( ▁2 ▁, ▁cnt ▁) ▁- ▁1 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁1 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁c out ▁<< ▁cnt Sub Sets ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁getSum ▁( ▁int ▁n ▁) ▁{ ▁return ▁( ▁( ▁n ▁- ▁1 ▁) ▁+ ▁pow ▁( ▁n ▁, ▁2 ▁) ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁3 ▁; ▁c out ▁<< ▁getSum ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁cnt Edges ▁( ▁int ▁n ▁) ▁{ ▁int ▁edges ▁= ▁pow ▁( ▁2 ▁, ▁n ▁) ▁- ▁2 ▁; ▁return ▁edges ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁4 ▁; ▁c out ▁<< ▁cnt Edges ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count ▁( ▁int ▁n ▁) ▁{ ▁return ▁15 ▁* ▁pow ▁( ▁16 ▁, ▁n ▁- ▁1 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁2 ▁; ▁c out ▁<< ▁count ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁float ▁find Prob ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁long ▁max Sum ▁= ▁INT _ MIN ▁, ▁max Count ▁= ▁0 ▁, ▁total Pairs ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁int ▁sum ▁= ▁arr ▁[ ▁i ▁] ▁+ ▁arr ▁[ ▁j ▁] ▁; ▁if ▁( ▁sum ▁== ▁max Sum ▁) ▁{ ▁max Count ▁++ ▁; ▁} ▁else ▁if ▁( ▁sum ▁> ▁max Sum ▁) ▁{ ▁max Sum ▁= ▁sum ▁; ▁max Count ▁= ▁1 ▁; ▁} ▁total Pairs ▁++ ▁; ▁} ▁} ▁float ▁prob ▁= ▁( ▁float ▁) ▁max Count ▁/ ▁( ▁float ▁) ▁total Pairs ▁; ▁return ▁prob ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁2 ▁, ▁2 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁c out ▁<< ▁find Prob ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁previous F ib onacci ▁( ▁int ▁n ▁) ▁{ ▁double ▁a ▁= ▁n ▁/ ▁( ▁( ▁1 ▁+ ▁sqrt ▁( ▁5 ▁) ▁) ▁/ ▁2.0 ▁) ▁; ▁return ▁round ▁( ▁a ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁8 ▁; ▁c out ▁<< ▁( ▁previous F ib onacci ▁( ▁n ▁) ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count ▁( ▁int ▁n ▁) ▁{ ▁return ▁3 ▁* ▁n ▁* ▁( ▁n ▁- ▁1 ▁) ▁+ ▁1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁3 ▁; ▁c out ▁<< ▁count ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁ways ▁( ▁int ▁n ▁) ▁{ ▁return ▁n ▁/ ▁2 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁2 ▁; ▁c out ▁<< ▁ways ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Min Value ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁long ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁return ▁( ▁( ▁sum ▁/ ▁n ▁) ▁+ ▁1 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁2 ▁, ▁1 ▁, ▁10 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁c out ▁<< ▁find Min Value ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁sum Pairs ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁= ▁sum ▁+ ▁( ▁arr ▁[ ▁i ▁] ▁* ▁( ▁2 ▁* ▁n ▁) ▁) ▁; ▁} ▁return ▁sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁sum Pairs ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁min Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁sort ▁( ▁arr ▁, ▁arr ▁+ ▁n ▁, ▁greater ▁< ▁int ▁> ▁( ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁% ▁4 ▁< ▁2 ▁) ▁sum ▁= ▁sum ▁+ ▁arr ▁[ ▁i ▁] ▁; ▁} ▁return ▁sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁1 ▁, ▁10 ▁, ▁2 ▁, ▁2 ▁, ▁2 ▁, ▁1 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁min Sum ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁long ▁long ▁getCount ▁( ▁int ▁A ▁, ▁int ▁B 2 ▁, ▁int ▁C ▁) ▁{ ▁long ▁long ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁A ▁; ▁i ▁++ ▁) ▁{ ▁long ▁long ▁j ▁= ▁( ▁B 2 ▁/ ▁i ▁) ▁+ ▁1 ▁; ▁if ▁( ▁C ▁>= ▁j ▁) ▁count ▁= ▁( ▁count ▁+ ▁C ▁- ▁j ▁+ ▁1 ▁) ▁; ▁if ▁( ▁A ▁>= ▁j ▁&& ▁C ▁>= ▁i ▁) ▁count ▁= ▁( ▁count ▁+ ▁( ▁C ▁- ▁i ▁+ ▁1 ▁) ▁* ▁( ▁A ▁- ▁j ▁+ ▁1 ▁) ▁) ▁; ▁if ▁( ▁A ▁>= ▁j ▁) ▁A ▁= ▁j ▁- ▁1 ▁; ▁} ▁return ▁count ▁; ▁} ▁long ▁long ▁count Tri pl ets ▁( ▁int ▁A ▁, ▁int ▁B ▁, ▁int ▁C ▁) ▁{ ▁long ▁long ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁B ▁; ▁i ▁++ ▁) ▁{ ▁ans ▁= ▁( ▁ans ▁+ ▁getCount ▁( ▁A ▁, ▁i ▁* ▁i ▁, ▁C ▁) ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁, ▁B ▁, ▁C ▁; ▁A ▁= ▁3 ▁, ▁B ▁= ▁2 ▁, ▁C ▁= ▁2 ▁; ▁c out ▁<< ▁count Tri pl ets ▁( ▁A ▁, ▁B ▁, ▁C ▁) ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁sum ▁( ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁( ▁n ▁* ▁( ▁n ▁+ ▁1 ▁) ▁) ▁/ ▁2 ▁; ▁return ▁sum ▁; ▁} ▁int ▁repeated Sum ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁k ▁; ▁i ▁++ ▁) ▁{ ▁n ▁= ▁sum ▁( ▁n ▁) ▁; ▁} ▁return ▁n ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁2 ▁, ▁k ▁= ▁2 ▁; ▁c out ▁<< ▁repeated Sum ▁( ▁n ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁MAX ▁100000 ▁NEW _ LINE ▁bool ▁prime ▁[ ▁MAX ▁+ ▁1 ▁] ▁; ▁void ▁S ieve Of E rat ost hen es ▁( ▁) ▁{ ▁mem set ▁( ▁prime ▁, ▁true ▁, ▁sizeof ▁( ▁prime ▁) ▁) ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁* ▁p ▁<= ▁MAX ▁; ▁p ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁p ▁] ▁== ▁true ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁p ▁* ▁p ▁; ▁i ▁<= ▁MAX ▁; ▁i ▁+= ▁p ▁) ▁prime ▁[ ▁i ▁] ▁= ▁false ▁; ▁} ▁} ▁} ▁int ▁smallest Prime ▁( ▁int ▁d ▁) ▁{ ▁int ▁l ▁= ▁pow ▁( ▁10 ▁, ▁d ▁- ▁1 ▁) ▁; ▁int ▁r ▁= ▁pow ▁( ▁10 ▁, ▁d ▁) ▁- ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁l ▁; ▁i ▁<= ▁r ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁i ▁] ▁) ▁{ ▁return ▁i ▁; ▁} ▁} ▁return ▁-1 ▁; ▁} ▁int ▁largest Prime ▁( ▁int ▁d ▁) ▁{ ▁int ▁l ▁= ▁pow ▁( ▁10 ▁, ▁d ▁- ▁1 ▁) ▁; ▁int ▁r ▁= ▁pow ▁( ▁10 ▁, ▁d ▁) ▁- ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁r ▁; ▁i ▁>= ▁l ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁i ▁] ▁) ▁{ ▁return ▁i ▁; ▁} ▁} ▁return ▁-1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁S ieve Of E rat ost hen es ▁( ▁) ▁; ▁int ▁queries ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁5 ▁} ▁; ▁int ▁q ▁= ▁sizeof ▁( ▁queries ▁) ▁/ ▁sizeof ▁( ▁queries ▁[ ▁0 ▁] ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁q ▁; ▁i ▁++ ▁) ▁{ ▁c out ▁<< ▁smallest Prime ▁( ▁queries ▁[ ▁i ▁] ▁) ▁<< ▁" ▁" ▁<< ▁largest Prime ▁( ▁queries ▁[ ▁i ▁] ▁) ▁<< ▁end l ▁; ▁} ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁possible ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁> ▁3 ▁) ▁{ ▁int ▁sum ▁= ▁( ▁n ▁* ▁( ▁n ▁+ ▁1 ▁) ▁) ▁/ ▁2 ▁; ▁if ▁( ▁sum ▁% ▁3 ▁== ▁0 ▁) ▁{ ▁return ▁true ▁; ▁} ▁} ▁return ▁false ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁5 ▁; ▁if ▁( ▁possible ▁( ▁n ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁check Type ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁0 ▁] ▁<= ▁arr ▁[ ▁1 ▁] ▁&& ▁arr ▁[ ▁n ▁- ▁2 ▁] ▁<= ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁) ▁c out ▁<< ▁" ▁In cre asing ▁" ▁; ▁else ▁if ▁( ▁arr ▁[ ▁0 ▁] ▁>= ▁arr ▁[ ▁1 ▁] ▁&& ▁arr ▁[ ▁n ▁- ▁2 ▁] ▁>= ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁) ▁c out ▁<< ▁" ▁Dec re asing ▁" ▁; ▁else ▁if ▁( ▁arr ▁[ ▁0 ▁] ▁<= ▁arr ▁[ ▁1 ▁] ▁&& ▁arr ▁[ ▁n ▁- ▁2 ▁] ▁>= ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁) ▁c out ▁<< ▁" ▁In cre asing ▁then ▁decre asing ▁" ▁; ▁else ▁c out ▁<< ▁" ▁Dec re asing ▁then ▁increasing ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁check Type ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁double ▁sum ▁( ▁double ▁a ▁, ▁double ▁b ▁, ▁double ▁c ▁, ▁double ▁d ▁, ▁double ▁x ▁) ▁{ ▁double ▁ans ▁= ▁( ▁x ▁* ▁( ▁a ▁+ ▁b ▁) ▁* ▁( ▁c ▁- ▁d ▁) ▁) ▁/ ▁( ▁( ▁a ▁* ▁d ▁) ▁- ▁( ▁b ▁* ▁c ▁) ▁) ▁; ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁double ▁a ▁= ▁1 ▁, ▁b ▁= ▁2 ▁, ▁c ▁= ▁9 ▁, ▁d ▁= ▁13 ▁, ▁x ▁= ▁5 ▁; ▁c out ▁<< ▁sum ▁( ▁a ▁, ▁b ▁, ▁c ▁, ▁d ▁, ▁x ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print Roots ▁( ▁long ▁a ▁, ▁long ▁b ▁, ▁long ▁c ▁) ▁{ ▁c out ▁<< ▁1 ▁<< ▁" ▁, ▁" ▁<< ▁c ▁/ ▁( ▁a ▁* ▁1.0 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁long ▁a ▁= ▁2 ▁; ▁long ▁b ▁= ▁3 ▁; ▁long ▁c ▁= ▁-5 ▁; ▁print Roots ▁( ▁a ▁, ▁b ▁, ▁c ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁Max _ sum ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁pos ▁= ▁0 ▁, ▁neg ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁> ▁0 ▁) ▁pos ▁= ▁1 ▁; ▁else ▁if ▁( ▁a ▁[ ▁i ▁] ▁< ▁0 ▁) ▁neg ▁= ▁1 ▁; ▁if ▁( ▁pos ▁== ▁1 ▁and ▁neg ▁== ▁1 ▁) ▁break ▁; ▁} ▁int ▁sum ▁= ▁0 ▁; ▁if ▁( ▁pos ▁== ▁1 ▁and ▁neg ▁== ▁1 ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁sum ▁+= ▁abs ▁( ▁a ▁[ ▁i ▁] ▁) ▁; ▁} ▁else ▁if ▁( ▁pos ▁== ▁1 ▁) ▁{ ▁int ▁mini ▁= ▁a ▁[ ▁0 ▁] ▁; ▁sum ▁= ▁a ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁mini ▁= ▁min ▁( ▁mini ▁, ▁a ▁[ ▁i ▁] ▁) ▁; ▁sum ▁+= ▁a ▁[ ▁i ▁] ▁; ▁} ▁sum ▁-= ▁2 ▁* ▁mini ▁; ▁} ▁else ▁if ▁( ▁neg ▁== ▁1 ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁a ▁[ ▁i ▁] ▁= ▁abs ▁( ▁a ▁[ ▁i ▁] ▁) ▁; ▁int ▁mini ▁= ▁a ▁[ ▁0 ▁] ▁; ▁sum ▁= ▁a ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁mini ▁= ▁min ▁( ▁mini ▁, ▁a ▁[ ▁i ▁] ▁) ▁; ▁sum ▁+= ▁a ▁[ ▁i ▁] ▁; ▁} ▁sum ▁-= ▁2 ▁* ▁mini ▁; ▁} ▁return ▁sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁5 ▁, ▁-2 ▁, ▁- 6 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁Max _ sum ▁( ▁a ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁decimal To Binary ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁0 ▁) ▁{ ▁c out ▁<< ▁"0" ▁; ▁return ▁; ▁} ▁decimal To Binary ▁( ▁n ▁/ ▁2 ▁) ▁; ▁c out ▁<< ▁n ▁% ▁2 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁13 ▁; ▁decimal To Binary ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁Vert ices ▁( ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁int ▁val ▁= ▁abs ▁( ▁x ▁) ▁+ ▁abs ▁( ▁y ▁) ▁; ▁c out ▁<< ▁val ▁* ▁( ▁x ▁< ▁0 ▁? ▁-1 ▁: ▁1 ▁) ▁<< ▁" ▁0 ▁" ▁; ▁c out ▁<< ▁"0 ▁" ▁<< ▁val ▁* ▁( ▁y ▁< ▁0 ▁? ▁-1 ▁: ▁1 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁x ▁= ▁3 ▁, ▁y ▁= ▁3 ▁; ▁Vert ices ▁( ▁x ▁, ▁y ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁MAX ▁32 ▁NEW _ LINE ▁unsigned ▁int ▁count Set Bits ▁( ▁int ▁n ▁) ▁{ ▁unsigned ▁int ▁count ▁= ▁0 ▁; ▁while ▁( ▁n ▁) ▁{ ▁n ▁&= ▁( ▁n ▁- ▁1 ▁) ▁; ▁count ▁++ ▁; ▁} ▁return ▁count ▁; ▁} ▁int ▁pairs ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁int ▁f ▁[ ▁MAX ▁+ ▁1 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁f ▁[ ▁count Set Bits ▁( ▁arr ▁[ ▁i ▁] ▁) ▁] ▁++ ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁MAX ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁<= ▁MAX ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁i ▁+ ▁j ▁== ▁k ▁) ▁{ ▁if ▁( ▁i ▁== ▁j ▁) ▁count ▁+= ▁( ▁( ▁f ▁[ ▁i ▁] ▁* ▁( ▁f ▁[ ▁i ▁] ▁- ▁1 ▁) ▁) ▁/ ▁2 ▁) ▁; ▁else ▁count ▁+= ▁( ▁f ▁[ ▁i ▁] ▁* ▁f ▁[ ▁j ▁] ▁) ▁; ▁} ▁} ▁} ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁k ▁= ▁4 ▁; ▁c out ▁<< ▁pairs ▁( ▁arr ▁, ▁n ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁cnt _ neg ▁; ▁bool ▁exists _ zero ▁; ▁void ▁pre Process ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁0 ▁) ▁cnt _ neg ▁++ ▁; ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁0 ▁) ▁exists _ zero ▁= ▁true ▁; ▁} ▁} ▁bool ▁isP ossible ▁( ▁int ▁k ▁) ▁{ ▁if ▁( ▁! ▁exists _ zero ▁) ▁{ ▁if ▁( ▁k ▁>= ▁cnt _ neg ▁and ▁( ▁k ▁- ▁cnt _ neg ▁) ▁% ▁2 ▁== ▁0 ▁) ▁return ▁true ▁; ▁else ▁return ▁false ▁; ▁} ▁else ▁{ ▁if ▁( ▁k ▁>= ▁cnt _ neg ▁) ▁return ▁true ▁; ▁else ▁return ▁false ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁-1 ▁, ▁2 ▁, ▁-3 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁pre Process ▁( ▁arr ▁, ▁n ▁) ▁; ▁int ▁queries ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁q ▁= ▁sizeof ▁( ▁queries ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁q ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁isP ossible ▁( ▁queries ▁[ ▁i ▁] ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁<< ▁end l ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁<< ▁end l ▁; ▁} ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁MAX ▁1000000 ▁NEW _ LINE ▁int ▁prime ▁[ ▁MAX ▁+ ▁1 ▁] ▁; ▁void ▁update Pr imes ▁( ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁MAX ▁; ▁i ▁++ ▁) ▁{ ▁prime ▁[ ▁i ▁] ▁= ▁1 ▁; ▁} ▁prime ▁[ ▁0 ▁] ▁= ▁prime ▁[ ▁1 ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁* ▁i ▁<= ▁MAX ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁i ▁] ▁== ▁1 ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁* ▁i ▁; ▁j ▁<= ▁MAX ▁; ▁j ▁+= ▁i ▁) ▁{ ▁prime ▁[ ▁j ▁] ▁= ▁0 ▁; ▁} ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁MAX ▁; ▁i ▁++ ▁) ▁{ ▁prime ▁[ ▁i ▁] ▁+= ▁prime ▁[ ▁i ▁- ▁1 ▁] ▁; ▁} ▁} ▁int ▁getD ifference ▁( ▁int ▁l ▁, ▁int ▁r ▁) ▁{ ▁int ▁total ▁= ▁r ▁- ▁l ▁+ ▁1 ▁; ▁int ▁primes ▁= ▁prime ▁[ ▁r ▁] ▁- ▁prime ▁[ ▁l ▁- ▁1 ▁] ▁; ▁int ▁comp osit es ▁= ▁total ▁- ▁primes ▁; ▁return ▁( ▁abs ▁( ▁primes ▁- ▁comp osit es ▁) ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁queries ▁[ ▁] ▁[ ▁2 ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁10 ▁} ▁, ▁{ ▁5 ▁, ▁30 ▁} ▁} ▁; ▁int ▁q ▁= ▁sizeof ▁( ▁queries ▁) ▁/ ▁sizeof ▁( ▁queries ▁[ ▁0 ▁] ▁) ▁; ▁update Pr imes ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁q ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁getD ifference ▁( ▁queries ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁, ▁queries ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Index ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁index ▁= ▁-1 ▁, ▁max _ ceil ▁= ▁INT _ MIN ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁a ▁[ ▁i ▁] ▁= ▁( ▁a ▁[ ▁i ▁] ▁+ ▁k ▁- ▁1 ▁) ▁/ ▁k ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁>= ▁max _ ceil ▁) ▁{ ▁max _ ceil ▁= ▁a ▁[ ▁i ▁] ▁; ▁index ▁= ▁i ▁; ▁} ▁} ▁return ▁index ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁31 ▁, ▁12 ▁, ▁25 ▁, ▁27 ▁, ▁32 ▁, ▁19 ▁} ▁; ▁int ▁K ▁= ▁5 ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁find Index ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁Count _ Segment ▁( ▁int ▁p ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁int ▁upto ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁upto ▁[ ▁i ▁] ▁= ▁0 ▁; ▁int ▁j ▁= ▁0 ▁, ▁curr ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁p ▁[ ▁i ▁] ▁> ▁p ▁[ ▁i ▁- ▁1 ▁] ▁and ▁p ▁[ ▁i ▁] ▁> ▁p ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁{ ▁curr ▁= ▁p ▁[ ▁i ▁] ▁; ▁j ▁= ▁i ▁- ▁1 ▁; ▁while ▁( ▁j ▁>= ▁0 ▁and ▁p ▁[ ▁j ▁] ▁< ▁curr ▁) ▁{ ▁upto ▁[ ▁p ▁[ ▁j ▁] ▁] ▁= ▁curr ▁; ▁j ▁-= ▁1 ▁; ▁} ▁j ▁= ▁i ▁+ ▁1 ▁; ▁while ▁( ▁j ▁< ▁n ▁and ▁p ▁[ ▁j ▁] ▁< ▁curr ▁) ▁{ ▁if ▁( ▁upto ▁[ ▁curr ▁- ▁p ▁[ ▁j ▁] ▁] ▁== ▁curr ▁) ▁count ▁+= ▁1 ▁; ▁j ▁+= ▁1 ▁; ▁} ▁} ▁} ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁p ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁4 ▁, ▁1 ▁, ▁5 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁p ▁) ▁/ ▁sizeof ▁( ▁p ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁( ▁Count _ Segment ▁( ▁p ▁, ▁n ▁) ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁valid Position ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁int ▁count ▁= ▁0 ▁, ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁K ▁) ▁> ▁( ▁sum ▁- ▁arr ▁[ ▁i ▁] ▁) ▁) ▁count ▁++ ▁; ▁} ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁1 ▁, ▁6 ▁, ▁7 ▁} ▁, ▁K ▁= ▁4 ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁valid Position ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁int ▁N ▁= ▁1000 ▁; ▁int ▁count Pairs ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁size ▁= ▁( ▁2 ▁* ▁N ▁) ▁+ ▁1 ▁; ▁int ▁freq ▁[ ▁size ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁x ▁= ▁arr ▁[ ▁i ▁] ▁; ▁freq ▁[ ▁x ▁+ ▁N ▁] ▁++ ▁; ▁} ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁freq ▁[ ▁i ▁] ▁> ▁0 ▁) ▁{ ▁ans ▁+= ▁( ▁( ▁freq ▁[ ▁i ▁] ▁) ▁* ▁( ▁freq ▁[ ▁i ▁] ▁- ▁1 ▁) ▁) ▁/ ▁2 ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁2 ▁; ▁j ▁< ▁2001 ▁; ▁j ▁+= ▁2 ▁) ▁{ ▁if ▁( ▁freq ▁[ ▁j ▁] ▁> ▁0 ▁&& ▁( ▁freq ▁[ ▁( ▁i ▁+ ▁j ▁) ▁/ ▁2 ▁] ▁> ▁0 ▁) ▁) ▁{ ▁ans ▁+= ▁( ▁freq ▁[ ▁i ▁] ▁* ▁freq ▁[ ▁j ▁] ▁) ▁; ▁} ▁} ▁} ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁2 ▁, ▁5 ▁, ▁1 ▁, ▁3 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁count Pairs ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁highest Power ▁( ▁string ▁str ▁, ▁int ▁len ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁len ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁str ▁[ ▁i ▁] ▁== ▁'0' ▁) ▁ans ▁++ ▁; ▁else ▁break ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁"100 100 " ▁; ▁int ▁len ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁c out ▁<< ▁highest Power ▁( ▁str ▁, ▁len ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁isP ossible ▁( ▁int ▁n ▁) ▁{ ▁int ▁fac ▁[ ▁10 ▁] ▁; ▁fac ▁[ ▁0 ▁] ▁= ▁fac ▁[ ▁1 ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁< ▁10 ▁; ▁i ▁++ ▁) ▁fac ▁[ ▁i ▁] ▁= ▁fac ▁[ ▁i ▁- ▁1 ▁] ▁* ▁i ▁; ▁int ▁sum ▁= ▁0 ▁; ▁int ▁x ▁= ▁n ▁; ▁while ▁( ▁x ▁) ▁{ ▁sum ▁+= ▁fac ▁[ ▁x ▁% ▁10 ▁] ▁; ▁x ▁/= ▁10 ▁; ▁} ▁if ▁( ▁sum ▁% ▁n ▁== ▁0 ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁19 ▁; ▁if ▁( ▁isP ossible ▁( ▁n ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is Perf ect Square ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁unordered _ map ▁< ▁int ▁, ▁int ▁> ▁u map ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁u map ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁++ ▁; ▁unordered _ map ▁< ▁int ▁, ▁int ▁> ▁:: ▁iterator ▁itr ▁; ▁for ▁( ▁itr ▁= ▁u map ▁. ▁begin ▁( ▁) ▁; ▁itr ▁!= ▁u map ▁. ▁end ▁( ▁) ▁; ▁itr ▁++ ▁) ▁if ▁( ▁( ▁itr ▁-> ▁second ▁) ▁% ▁2 ▁== ▁1 ▁) ▁return ▁false ▁; ▁return ▁true ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁2 ▁, ▁7 ▁, ▁7 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁if ▁( ▁is Perf ect Square ▁( ▁arr ▁, ▁n ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print Max Val Pair ▁( ▁vector ▁< ▁long ▁long ▁> ▁& ▁v ▁, ▁int ▁n ▁) ▁{ ▁sort ▁( ▁v ▁. ▁begin ▁( ▁) ▁, ▁v ▁. ▁end ▁( ▁) ▁) ▁; ▁long ▁long ▁N ▁= ▁v ▁[ ▁n ▁- ▁1 ▁] ▁; ▁if ▁( ▁N ▁% ▁2 ▁== ▁1 ▁) ▁{ ▁long ▁long ▁first _ max ima ▁= ▁N ▁/ ▁2 ▁; ▁long ▁long ▁second _ max ima ▁= ▁first _ max ima ▁+ ▁1 ▁; ▁long ▁long ▁ans 1 ▁= ▁3 e 18 ▁, ▁ans 2 ▁= ▁3 e 18 ▁; ▁long ▁long ▁from _ left ▁= ▁-1 ▁, ▁from _ right ▁= ▁-1 ▁; ▁long ▁long ▁from ▁= ▁-1 ▁; ▁for ▁( ▁long ▁long ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁v ▁[ ▁i ▁] ▁> ▁first _ max ima ▁) ▁{ ▁from ▁= ▁i ▁; ▁break ▁; ▁} ▁else ▁{ ▁long ▁long ▁diff ▁= ▁first _ max ima ▁- ▁v ▁[ ▁i ▁] ▁; ▁if ▁( ▁diff ▁< ▁ans 1 ▁) ▁{ ▁ans 1 ▁= ▁diff ▁; ▁from _ left ▁= ▁v ▁[ ▁i ▁] ▁; ▁} ▁} ▁} ▁from _ right ▁= ▁v ▁[ ▁from ▁] ▁; ▁long ▁long ▁diff 1 ▁= ▁first _ max ima ▁- ▁from _ left ▁; ▁long ▁long ▁diff 2 ▁= ▁from _ right ▁- ▁second _ max ima ▁; ▁if ▁( ▁diff 1 ▁< ▁diff 2 ▁) ▁c out ▁<< ▁N ▁<< ▁" ▁" ▁<< ▁from _ left ▁; ▁else ▁c out ▁<< ▁N ▁<< ▁" ▁" ▁<< ▁from _ right ▁; ▁} ▁else ▁{ ▁long ▁long ▁max ima ▁= ▁N ▁/ ▁2 ▁; ▁long ▁long ▁ans 1 ▁= ▁3 e 18 ▁; ▁long ▁long ▁R ▁= ▁-1 ▁; ▁for ▁( ▁long ▁long ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁++ ▁i ▁) ▁{ ▁long ▁long ▁diff ▁= ▁abs ▁( ▁v ▁[ ▁i ▁] ▁- ▁max ima ▁) ▁; ▁if ▁( ▁diff ▁< ▁ans 1 ▁) ▁{ ▁ans 1 ▁= ▁diff ▁; ▁R ▁= ▁v ▁[ ▁i ▁] ▁; ▁} ▁} ▁c out ▁<< ▁N ▁<< ▁" ▁" ▁<< ▁R ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁long ▁long ▁> ▁v ▁= ▁{ ▁1 ▁, ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁6 ▁, ▁1 ▁} ▁; ▁int ▁n
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Quad ru ples ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁unordered _ map ▁< ▁int ▁, ▁int ▁> ▁m pp ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁m pp ▁[ ▁a ▁[ ▁i ▁] ▁] ▁++ ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁for ▁( ▁int ▁k ▁= ▁0 ▁; ▁k ▁< ▁n ▁; ▁k ▁++ ▁) ▁{ ▁if ▁( ▁j ▁== ▁k ▁) ▁continue ▁; ▁m pp ▁[ ▁a ▁[ ▁j ▁] ▁] ▁-- ▁; ▁m pp ▁[ ▁a ▁[ ▁k ▁] ▁] ▁-- ▁; ▁int ▁first ▁= ▁a ▁[ ▁j ▁] ▁- ▁( ▁a ▁[ ▁k ▁] ▁- ▁a ▁[ ▁j ▁] ▁) ▁; ▁int ▁fourth ▁= ▁( ▁a ▁[ ▁k ▁] ▁* ▁a ▁[ ▁k ▁] ▁) ▁/ ▁a ▁[ ▁j ▁] ▁; ▁if ▁( ▁( ▁a ▁[ ▁k ▁] ▁* ▁a ▁[ ▁k ▁] ▁) ▁% ▁a ▁[ ▁j ▁] ▁== ▁0 ▁) ▁{ ▁if ▁( ▁a ▁[ ▁j ▁] ▁!= ▁a ▁[ ▁k ▁] ▁) ▁count ▁+= ▁m pp ▁[ ▁first ▁] ▁* ▁m pp ▁[ ▁fourth ▁] ▁; ▁else ▁count ▁+= ▁m pp ▁[ ▁first ▁] ▁* ▁( ▁m pp ▁[ ▁fourth ▁] ▁- ▁1 ▁) ▁; ▁} ▁m pp ▁[ ▁a ▁[ ▁j ▁] ▁] ▁++ ▁; ▁m pp ▁[ ▁a ▁[ ▁k ▁] ▁] ▁++ ▁; ▁} ▁} ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁6 ▁, ▁4 ▁, ▁9 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁count Quad ru ples ▁( ▁a ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁getPosition ▁( ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁if ▁( ▁m ▁> ▁( ▁n ▁/ ▁2 ▁) ▁) ▁return ▁( ▁m ▁- ▁( ▁n ▁/ ▁2 ▁) ▁) ▁; ▁return ▁( ▁m ▁+ ▁( ▁n ▁/ ▁2 ▁) ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁8 ▁, ▁m ▁= ▁5 ▁; ▁c out ▁<< ▁getPosition ▁( ▁n ▁, ▁m ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁par ity ▁( ▁int ▁a ▁) ▁{ ▁return ▁a ▁% ▁3 ▁; ▁} ▁int ▁solve ▁( ▁int ▁array ▁[ ▁] ▁, ▁int ▁size ▁) ▁{ ▁int ▁operations ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁par ity ▁( ▁array ▁[ ▁i ▁] ▁) ▁== ▁par ity ▁( ▁array ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁) ▁{ ▁operations ▁++ ▁; ▁if ▁( ▁i ▁+ ▁2 ▁< ▁size ▁) ▁{ ▁int ▁par i 1 ▁= ▁par ity ▁( ▁array ▁[ ▁i ▁] ▁) ▁; ▁int ▁par i 2 ▁= ▁par ity ▁( ▁array ▁[ ▁i ▁+ ▁2 ▁] ▁) ▁; ▁if ▁( ▁par i 1 ▁== ▁par i 2 ▁) ▁{ ▁if ▁( ▁par i 1 ▁== ▁0 ▁) ▁array ▁[ ▁i ▁+ ▁1 ▁] ▁= ▁1 ▁; ▁else ▁if ▁( ▁par i 1 ▁== ▁1 ▁) ▁array ▁[ ▁i ▁+ ▁1 ▁] ▁= ▁0 ▁; ▁else ▁array ▁[ ▁i ▁+ ▁1 ▁] ▁= ▁1 ▁; ▁} ▁else ▁{ ▁if ▁( ▁( ▁par i 1 ▁== ▁0 ▁&& ▁par i 2 ▁== ▁1 ▁) ▁|| ▁( ▁par i 1 ▁== ▁1 ▁&& ▁par i 2 ▁== ▁0 ▁) ▁) ▁array ▁[ ▁i ▁+ ▁1 ▁] ▁= ▁2 ▁; ▁if ▁( ▁( ▁par i 1 ▁== ▁1 ▁&& ▁par i 2 ▁== ▁2 ▁) ▁|| ▁( ▁par i 1 ▁== ▁2 ▁&& ▁par i 2 ▁== ▁1 ▁) ▁) ▁array ▁[ ▁i ▁+ ▁1 ▁] ▁= ▁0 ▁; ▁if ▁( ▁( ▁par i 1 ▁== ▁2 ▁&& ▁par i 2 ▁== ▁0 ▁) ▁|| ▁( ▁par i 1 ▁== ▁0 ▁&& ▁par i 2 ▁== ▁2 ▁) ▁) ▁array ▁[ ▁i ▁+ ▁1 ▁] ▁= ▁1 ▁; ▁} ▁} ▁} ▁} ▁return ▁operations ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁array ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁1 ▁, ▁3 ▁, ▁0 ▁} ▁; ▁int ▁size ▁= ▁sizeof ▁( ▁array ▁) ▁/ ▁sizeof ▁( ▁array ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁solve ▁( ▁array ▁, ▁size ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁check Array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁return ▁( ▁arr ▁[ ▁0 ▁] ▁% ▁2 ▁) ▁&& ▁( ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁% ▁2 ▁) ▁&& ▁( ▁n ▁% ▁2 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁( ▁int ▁) ▁check Array ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Tri pl ets ▁( ▁int ▁n ▁, ▁vector ▁< ▁pair ▁< ▁int ▁, ▁int ▁> ▁> ▁points ▁) ▁{ ▁set ▁< ▁pair ▁< ▁int ▁, ▁int ▁> ▁> ▁pts ▁; ▁int ▁ct ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁pts ▁. ▁insert ▁( ▁points ▁[ ▁i ▁] ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁int ▁x ▁= ▁points ▁[ ▁i ▁] ▁. ▁first ▁+ ▁points ▁[ ▁j ▁] ▁. ▁first ▁; ▁int ▁y ▁= ▁points ▁[ ▁i ▁] ▁. ▁second ▁+ ▁points ▁[ ▁j ▁] ▁. ▁second ▁; ▁if ▁( ▁x ▁% ▁2 ▁== ▁0 ▁&& ▁y ▁% ▁2 ▁== ▁0 ▁) ▁if ▁( ▁pts ▁. ▁find ▁( ▁make _ pair ▁( ▁x ▁/ ▁2 ▁, ▁y ▁/ ▁2 ▁) ▁) ▁!= ▁pts ▁. ▁end ▁( ▁) ▁) ▁ct ▁++ ▁; ▁} ▁return ▁ct ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁pair ▁< ▁int ▁, ▁int ▁> ▁> ▁points ▁= ▁{ ▁{ ▁1 ▁, ▁1 ▁} ▁, ▁{ ▁2 ▁, ▁2 ▁} ▁, ▁{ ▁3 ▁, ▁3 ▁} ▁} ▁; ▁int ▁n ▁= ▁points ▁. ▁size ▁( ▁) ▁; ▁c out ▁<< ▁count Tri pl ets ▁( ▁n ▁, ▁points ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁ll ▁long ▁long ▁int ▁NEW _ LINE ▁ll ▁gcd ▁( ▁ll ▁a ▁, ▁ll ▁b ▁) ▁{ ▁if ▁( ▁b ▁== ▁0 ▁) ▁return ▁a ▁; ▁else ▁return ▁gcd ▁( ▁b ▁, ▁a ▁% ▁b ▁) ▁; ▁} ▁ll ▁l cm Of Array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁< ▁1 ▁) ▁return ▁0 ▁; ▁ll ▁l cm ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁l cm ▁= ▁( ▁l cm ▁* ▁arr ▁[ ▁i ▁] ▁) ▁/ ▁gcd ▁( ▁l cm ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁return ▁l cm ▁; ▁} ▁int ▁min Perf ect Cube ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁ll ▁min Perf ect Cube ▁; ▁ll ▁l cm ▁= ▁l cm Of Array ▁( ▁arr ▁, ▁n ▁) ▁; ▁min Perf ect Cube ▁= ▁( ▁long ▁long ▁) ▁l cm ▁; ▁int ▁cnt ▁= ▁0 ▁; ▁while ▁( ▁l cm ▁> ▁1 ▁&& ▁l cm ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁cnt ▁++ ▁; ▁l cm ▁/= ▁2 ▁; ▁} ▁if ▁( ▁cnt ▁% ▁3 ▁== ▁2 ▁) ▁min Perf ect Cube ▁*= ▁2 ▁; ▁else ▁if ▁( ▁cnt ▁% ▁3 ▁== ▁1 ▁) ▁min Perf ect Cube ▁*= ▁4 ▁; ▁int ▁i ▁= ▁3 ▁; ▁while ▁( ▁l cm ▁> ▁1 ▁) ▁{ ▁cnt ▁= ▁0 ▁; ▁while ▁( ▁l cm ▁% ▁i ▁== ▁0 ▁) ▁{ ▁cnt ▁++ ▁; ▁l cm ▁/= ▁i ▁; ▁} ▁if ▁( ▁cnt ▁% ▁3 ▁== ▁1 ▁) ▁min Perf ect Cube ▁*= ▁i ▁* ▁i ▁; ▁else ▁if ▁( ▁cnt ▁% ▁3 ▁== ▁2 ▁) ▁min Perf ect Cube ▁*= ▁i ▁; ▁i ▁+= ▁2 ▁; ▁} ▁return ▁min Perf ect Cube ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁125 ▁, ▁14 ▁, ▁42 ▁, ▁100 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁min Perf ect Cube ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max G CD ▁( ▁int ▁N ▁, ▁int ▁P ▁) ▁{ ▁int ▁ans ▁= ▁1 ▁; ▁unordered _ map ▁< ▁int ▁, ▁int ▁> ▁prime _ factors ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁* ▁i ▁<= ▁P ▁; ▁i ▁++ ▁) ▁{ ▁while ▁( ▁P ▁% ▁i ▁== ▁0 ▁) ▁{ ▁prime _ factors ▁[ ▁i ▁] ▁++ ▁; ▁P ▁/= ▁i ▁; ▁} ▁} ▁if ▁( ▁P ▁!= ▁1 ▁) ▁prime _ factors ▁[ ▁P ▁] ▁++ ▁; ▁for ▁( ▁auto ▁v ▁: ▁prime _ factors ▁) ▁ans ▁*= ▁pow ▁( ▁v ▁. ▁first ▁, ▁v ▁. ▁second ▁/ ▁N ▁) ▁; ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁3 ▁, ▁P ▁= ▁24 ▁; ▁c out ▁<< ▁max G CD ▁( ▁N ▁, ▁P ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁vector ▁< ▁int ▁> ▁getPer f ect Square s ▁( ▁int ▁n ▁) ▁{ ▁vector ▁< ▁int ▁> ▁perfect Square s ▁; ▁int ▁current ▁= ▁1 ▁, ▁i ▁= ▁1 ▁; ▁while ▁( ▁current ▁<= ▁n ▁) ▁{ ▁perfect Square s ▁. ▁push _ back ▁( ▁current ▁) ▁; ▁current ▁= ▁pow ▁( ▁++ ▁i ▁, ▁2 ▁) ▁; ▁} ▁return ▁perfect Square s ▁; ▁} ▁int ▁count Tri pl ets ▁( ▁int ▁n ▁) ▁{ ▁vector ▁< ▁int ▁> ▁perfect Square s ▁= ▁getPer f ect Square s ▁( ▁pow ▁( ▁n ▁, ▁2 ▁) ▁) ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁a ▁= ▁1 ▁; ▁a ▁<= ▁n ▁; ▁a ▁++ ▁) ▁{ ▁int ▁a Square ▁= ▁pow ▁( ▁a ▁, ▁2 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁perfect Square s ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁int ▁c Square ▁= ▁perfect Square s ▁[ ▁i ▁] ▁; ▁int ▁b Square ▁= ▁abs ▁( ▁c Square ▁- ▁a Square ▁) ▁; ▁int ▁b ▁= ▁sqrt ▁( ▁b Square ▁) ▁; ▁int ▁c ▁= ▁sqrt ▁( ▁c Square ▁) ▁; ▁if ▁( ▁c ▁< ▁a ▁|| ▁( ▁find ▁( ▁perfect Square s ▁. ▁begin ▁( ▁) ▁, ▁perfect Square s ▁. ▁end ▁( ▁) ▁, ▁b Square ▁) ▁== ▁perfect Square s ▁. ▁end ▁( ▁) ▁) ▁) ▁continue ▁; ▁if ▁( ▁( ▁b ▁>= ▁a ▁) ▁&& ▁( ▁b ▁<= ▁c ▁) ▁&& ▁( ▁a Square ▁+ ▁b Square ▁== ▁c Square ▁) ▁) ▁count ▁++ ▁; ▁} ▁} ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁10 ▁; ▁c out ▁<< ▁count Tri pl ets ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁Min Steps ▁( ▁int ▁Source X ▁, ▁int ▁Source Y ▁, ▁int ▁Dest X ▁, ▁int ▁Dest Y ▁) ▁{ ▁c out ▁<< ▁max ▁( ▁abs ▁( ▁Source X ▁- ▁Dest X ▁) ▁, ▁abs ▁( ▁Source Y ▁- ▁Dest Y ▁) ▁) ▁<< ▁end l ▁; ▁while ▁( ▁( ▁Source X ▁!= ▁Dest X ▁) ▁|| ▁( ▁Source Y ▁!= ▁Dest Y ▁) ▁) ▁{ ▁if ▁( ▁Source X ▁< ▁Dest X ▁) ▁{ ▁c out ▁<< ▁' ▁U ▁' ▁; ▁Source X ▁++ ▁; ▁} ▁if ▁( ▁Source X ▁> ▁Dest X ▁) ▁{ ▁c out ▁<< ▁' ▁D ▁' ▁; ▁Source X ▁-- ▁; ▁} ▁if ▁( ▁Source Y ▁> ▁Dest Y ▁) ▁{ ▁c out ▁<< ▁' ▁L ▁' ▁; ▁Source Y ▁-- ▁; ▁} ▁if ▁( ▁Source Y ▁< ▁Dest Y ▁) ▁{ ▁c out ▁<< ▁' ▁R ▁' ▁; ▁Source Y ▁++ ▁; ▁} ▁c out ▁<< ▁end l ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁source X ▁= ▁4 ▁, ▁source Y ▁= ▁4 ▁; ▁int ▁destination X ▁= ▁7 ▁, ▁destination Y ▁= ▁0 ▁; ▁Min Steps ▁( ▁source X ▁, ▁source Y ▁, ▁destination X ▁, ▁destination Y ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁isP al indrome ▁( ▁int ▁num ▁) ▁{ ▁int ▁reverse _ num ▁= ▁0 ▁, ▁remainder ▁, ▁temp ▁; ▁temp ▁= ▁num ▁; ▁while ▁( ▁temp ▁!= ▁0 ▁) ▁{ ▁remainder ▁= ▁temp ▁% ▁10 ▁; ▁reverse _ num ▁= ▁reverse _ num ▁* ▁10 ▁+ ▁remainder ▁; ▁temp ▁/= ▁10 ▁; ▁} ▁if ▁( ▁reverse _ num ▁== ▁num ▁) ▁{ ▁return ▁true ▁; ▁} ▁return ▁false ▁; ▁} ▁bool ▁is Odd Length ▁( ▁int ▁num ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁while ▁( ▁num ▁> ▁0 ▁) ▁{ ▁num ▁/= ▁10 ▁; ▁count ▁++ ▁; ▁} ▁if ▁( ▁count ▁% ▁2 ▁!= ▁0 ▁) ▁{ ▁return ▁true ▁; ▁} ▁return ▁false ▁; ▁} ▁long ▁sum Of All Pal indrome ▁( ▁int ▁L ▁, ▁int ▁R ▁) ▁{ ▁long ▁sum ▁= ▁0 ▁; ▁if ▁( ▁L ▁<= ▁R ▁) ▁for ▁( ▁int ▁i ▁= ▁L ▁; ▁i ▁<= ▁R ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁isP al indrome ▁( ▁i ▁) ▁&& ▁is Odd Length ▁( ▁i ▁) ▁) ▁{ ▁sum ▁+= ▁i ▁; ▁} ▁} ▁return ▁sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁L ▁= ▁110 ▁, ▁R ▁= ▁11 30 ▁; ▁c out ▁<< ▁" ▁" ▁<< ▁sum Of All Pal indrome ▁( ▁L ▁, ▁R ▁) ▁<< ▁end l ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁product Sum Div isible ▁( ▁int ▁n ▁, ▁int ▁size ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁, ▁product ▁= ▁1 ▁; ▁while ▁( ▁n ▁> ▁0 ▁) ▁{ ▁if ▁( ▁size ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁product ▁*= ▁n ▁% ▁10 ▁; ▁} ▁else ▁{ ▁sum ▁+= ▁n ▁% ▁10 ▁; ▁} ▁n ▁= ▁n ▁/ ▁10 ▁; ▁size ▁-- ▁; ▁} ▁if ▁( ▁product ▁% ▁sum ▁== ▁0 ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁1234 ▁; ▁int ▁len ▁= ▁4 ▁; ▁if ▁( ▁product Sum Div isible ▁( ▁n ▁, ▁len ▁) ▁) ▁c out ▁<< ▁" ▁TRUE ▁" ▁; ▁else ▁c out ▁<< ▁" ▁FALSE ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁count Digit ▁( ▁int ▁n ▁) ▁{ ▁int ▁temp ▁= ▁n ▁, ▁sum ▁= ▁0 ▁, ▁product ▁= ▁1 ▁; ▁while ▁( ▁temp ▁!= ▁0 ▁) ▁{ ▁int ▁d ▁= ▁temp ▁% ▁10 ▁; ▁temp ▁/= ▁10 ▁; ▁if ▁( ▁d ▁> ▁0 ▁&& ▁n ▁% ▁d ▁== ▁0 ▁) ▁{ ▁sum ▁+= ▁d ▁; ▁product ▁*= ▁d ▁; ▁} ▁} ▁c out ▁<< ▁" ▁Sum ▁= ▁" ▁<< ▁sum ▁; ▁c out ▁<< ▁" ▁Product ▁= ▁" ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁101 2 ▁; ▁count Digit ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁MAX ▁1000000 ▁NEW _ LINE ▁bool ▁prime ▁[ ▁MAX ▁+ ▁1 ▁] ▁; ▁void ▁S ieve Of E rat ost hen es ▁( ▁) ▁{ ▁mem set ▁( ▁prime ▁, ▁true ▁, ▁sizeof ▁( ▁prime ▁) ▁) ▁; ▁prime ▁[ ▁1 ▁] ▁= ▁false ▁; ▁prime ▁[ ▁0 ▁] ▁= ▁false ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁* ▁p ▁<= ▁MAX ▁; ▁p ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁p ▁] ▁== ▁true ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁p ▁* ▁2 ▁; ▁i ▁<= ▁MAX ▁; ▁i ▁+= ▁p ▁) ▁prime ▁[ ▁i ▁] ▁= ▁false ▁; ▁} ▁} ▁} ▁void ▁product Of K th Pr imes ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁c ▁= ▁0 ▁; ▁long ▁long ▁int ▁product ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁) ▁{ ▁c ▁++ ▁; ▁if ▁( ▁c ▁% ▁k ▁== ▁0 ▁) ▁{ ▁product ▁*= ▁arr ▁[ ▁i ▁] ▁; ▁c ▁= ▁0 ▁; ▁} ▁} ▁} ▁c out ▁<< ▁product ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁S ieve Of E rat ost hen es ▁( ▁) ▁; ▁int ▁n ▁= ▁5 ▁, ▁k ▁= ▁2 ▁; ▁int ▁arr ▁[ ▁n ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁5 ▁, ▁7 ▁, ▁11 ▁} ▁; ▁product Of K th Pr imes ▁( ▁arr ▁, ▁n ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁long ▁nth K yn ea Number ▁( ▁int ▁n ▁) ▁{ ▁return ▁( ▁( ▁1 ▁<< ▁( ▁2 ▁* ▁n ▁) ▁) ▁+ ▁( ▁1 ▁<< ▁( ▁n ▁+ ▁1 ▁) ▁) ▁- ▁1 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁2 ▁; ▁c out ▁<< ▁nth K yn ea Number ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁fn Mod ▁( ▁int ▁n ▁) ▁{ ▁int ▁rem ▁= ▁n ▁% ▁4 ▁; ▁if ▁( ▁rem ▁== ▁0 ▁rem ▁== ▁3 ▁) ▁return ▁0 ▁; ▁else ▁if ▁( ▁rem ▁== ▁1 ▁rem ▁== ▁2 ▁) ▁return ▁1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁6 ▁; ▁c out ▁<< ▁fn Mod ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁mod Exp ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁int ▁result ▁= ▁1 ▁; ▁while ▁( ▁b ▁> ▁0 ▁) ▁{ ▁if ▁( ▁b ▁& ▁1 ▁) ▁result ▁= ▁result ▁* ▁a ▁; ▁a ▁= ▁a ▁* ▁a ▁; ▁b ▁/= ▁2 ▁; ▁} ▁return ▁result ▁; ▁} ▁int ▁check ▁( ▁int ▁num ▁) ▁{ ▁if ▁( ▁num ▁& ▁1 ▁num ▁< ▁3 ▁) ▁return ▁-1 ▁; ▁else ▁if ▁( ▁num ▁% ▁4 ▁== ▁0 ▁) ▁return ▁mod Exp ▁( ▁num ▁/ ▁4 ▁, ▁4 ▁) ▁; ▁else ▁if ▁( ▁num ▁% ▁6 ▁== ▁0 ▁) ▁return ▁mod Exp ▁( ▁num ▁/ ▁3 ▁, ▁2 ▁) ▁* ▁mod Exp ▁( ▁num ▁/ ▁6 ▁, ▁2 ▁) ▁; ▁else ▁if ▁( ▁num ▁% ▁10 ▁== ▁0 ▁) ▁return ▁mod Exp ▁( ▁num ▁/ ▁5 ▁, ▁2 ▁) ▁* ▁( ▁num ▁/ ▁10 ▁) ▁* ▁( ▁num ▁/ ▁2 ▁) ▁; ▁else ▁return ▁-1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁num ▁= ▁10 ▁; ▁c out ▁<< ▁check ▁( ▁num ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁R ace ▁( ▁int ▁B ▁, ▁int ▁C ▁) ▁{ ▁int ▁result ▁= ▁0 ▁; ▁result ▁= ▁( ▁( ▁C ▁* ▁100 ▁) ▁/ ▁B ▁) ▁; ▁return ▁100 ▁- ▁result ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁B ▁= ▁10 ▁, ▁C ▁= ▁28 ▁; ▁B ▁= ▁100 ▁- ▁B ▁; ▁C ▁= ▁100 ▁- ▁C ▁; ▁c out ▁<< ▁R ace ▁( ▁B ▁, ▁C ▁) ▁<< ▁" ▁meters ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁unsigned ▁long ▁int ▁bin omial Co eff ▁( ▁unsigned ▁int ▁n ▁, ▁unsigned ▁int ▁k ▁) ▁{ ▁unsigned ▁long ▁int ▁res ▁= ▁1 ▁; ▁if ▁( ▁k ▁> ▁n ▁- ▁k ▁) ▁k ▁= ▁n ▁- ▁k ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁k ▁; ▁++ ▁i ▁) ▁{ ▁res ▁*= ▁( ▁n ▁- ▁i ▁) ▁; ▁res ▁/= ▁( ▁i ▁+ ▁1 ▁) ▁; ▁} ▁return ▁res ▁; ▁} ▁unsigned ▁long ▁int ▁catal an ▁( ▁unsigned ▁int ▁n ▁) ▁{ ▁unsigned ▁long ▁int ▁c ▁= ▁bin omial Co eff ▁( ▁2 ▁* ▁n ▁, ▁n ▁) ▁; ▁return ▁c ▁/ ▁( ▁n ▁+ ▁1 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁3 ▁; ▁c out ▁<< ▁catal an ▁( ▁n ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁# include ▁< iom an ip > ▁NEW _ LINE ▁# include ▁< i ost ream > ▁NEW _ LINE ▁# include ▁< math . h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁distance ▁( ▁float ▁x 1 ▁, ▁float ▁y 1 ▁, ▁float ▁z 1 ▁, ▁float ▁x 2 ▁, ▁float ▁y 2 ▁, ▁float ▁z 2 ▁) ▁{ ▁float ▁d ▁= ▁sqrt ▁( ▁pow ▁( ▁x 2 ▁- ▁x 1 ▁, ▁2 ▁) ▁+ ▁pow ▁( ▁y 2 ▁- ▁y 1 ▁, ▁2 ▁) ▁+ ▁pow ▁( ▁z 2 ▁- ▁z 1 ▁, ▁2 ▁) ▁* ▁1.0 ▁) ▁; ▁std ▁:: ▁c out ▁<< ▁std ▁:: ▁fixed ▁; ▁std ▁:: ▁c out ▁<< ▁std ▁:: ▁set precision ▁( ▁2 ▁) ▁; ▁c out ▁<< ▁" ▁Distance ▁is ▁" ▁<< ▁d ▁; ▁return ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁float ▁x 1 ▁= ▁2 ▁; ▁float ▁y 1 ▁= ▁-5 ▁; ▁float ▁z 1 ▁= ▁7 ▁; ▁float ▁x 2 ▁= ▁3 ▁; ▁float ▁y 2 ▁= ▁4 ▁; ▁float ▁z 2 ▁= ▁5 ▁; ▁distance ▁( ▁x 1 ▁, ▁y 1 ▁, ▁z 1 ▁, ▁x 2 ▁, ▁y 2 ▁, ▁z 2 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find Greater ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁! ▁( ▁n ▁& ▁1 ▁) ▁) ▁{ ▁a ▁= ▁abs ▁( ▁a ▁) ▁; ▁b ▁= ▁abs ▁( ▁b ▁) ▁; ▁} ▁if ▁( ▁a ▁== ▁b ▁) ▁c out ▁<< ▁" ▁a ▁^ ▁n ▁is ▁equal ▁to ▁b ▁^ ▁n ▁" ▁; ▁else ▁if ▁( ▁a ▁> ▁b ▁) ▁c out ▁<< ▁" ▁a ▁^ ▁n ▁is ▁greater ▁than ▁b ▁^ ▁n ▁" ▁; ▁else ▁c out ▁<< ▁" ▁b ▁^ ▁n ▁is ▁greater ▁than ▁a ▁^ ▁n ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁= ▁12 ▁, ▁b ▁= ▁24 ▁, ▁n ▁= ▁5 ▁; ▁find Greater ▁( ▁a ▁, ▁b ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁subtract One ▁( ▁int ▁x ▁) ▁{ ▁int ▁m ▁= ▁1 ▁; ▁while ▁( ▁! ▁( ▁x ▁& ▁m ▁) ▁) ▁{ ▁x ▁= ▁x ▁^ ▁m ▁; ▁m ▁<<= ▁1 ▁; ▁} ▁x ▁= ▁x ▁^ ▁m ▁; ▁return ▁x ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁c out ▁<< ▁subtract One ▁( ▁13 ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁double ▁PI ▁= ▁3.1 42 ▁; ▁double ▁cos X S ert ies Sum ▁( ▁double ▁x ▁, ▁int ▁n ▁) ▁{ ▁x ▁= ▁x ▁* ▁( ▁PI ▁/ ▁180 .0 ▁) ▁; ▁double ▁res ▁= ▁1 ▁; ▁double ▁sign ▁= ▁1 ▁, ▁fact ▁= ▁1 ▁, ▁pow ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁5 ▁; ▁i ▁++ ▁) ▁{ ▁sign ▁= ▁sign ▁* ▁-1 ▁; ▁fact ▁= ▁fact ▁* ▁( ▁2 ▁* ▁i ▁- ▁1 ▁) ▁* ▁( ▁2 ▁* ▁i ▁) ▁; ▁pow ▁= ▁pow ▁* ▁x ▁* ▁x ▁; ▁res ▁= ▁res ▁+ ▁sign ▁* ▁pow ▁/ ▁fact ▁; ▁} ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁float ▁x ▁= ▁50 ▁; ▁int ▁n ▁= ▁5 ▁; ▁c out ▁<< ▁cos X S ert ies Sum ▁( ▁x ▁, ▁5 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Bucket No ▁( ▁int ▁p ▁) ▁{ ▁return ▁ceil ▁( ▁( ▁sqrt ▁( ▁8 ▁* ▁p ▁+ ▁1 ▁) ▁- ▁1 ▁) ▁/ ▁2 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁p ▁= ▁10 ▁; ▁c out ▁<< ▁find Bucket No ▁( ▁p ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁MAX ▁5000 2 ▁NEW _ LINE ▁vector ▁< ▁int ▁> ▁primes ▁; ▁void ▁s ieve ▁( ▁) ▁{ ▁bool ▁is Prime ▁[ ▁MAX ▁] ▁; ▁mem set ▁( ▁is Prime ▁, ▁true ▁, ▁sizeof ▁( ▁is Prime ▁) ▁) ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁* ▁p ▁< ▁MAX ▁; ▁p ▁++ ▁) ▁{ ▁if ▁( ▁is Prime ▁[ ▁p ▁] ▁== ▁true ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁p ▁* ▁2 ▁; ▁i ▁< ▁MAX ▁; ▁i ▁+= ▁p ▁) ▁is Prime ▁[ ▁i ▁] ▁= ▁false ▁; ▁} ▁} ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁< ▁MAX ▁; ▁p ▁++ ▁) ▁if ▁( ▁is Prime ▁[ ▁p ▁] ▁) ▁primes ▁. ▁push _ back ▁( ▁p ▁) ▁; ▁} ▁long ▁long ▁int ▁power ▁( ▁long ▁long ▁int ▁x ▁, ▁long ▁long ▁int ▁y ▁) ▁{ ▁long ▁long ▁int ▁count ▁= ▁0 ▁; ▁long ▁long ▁int ▁z ▁= ▁y ▁; ▁while ▁( ▁x ▁>= ▁z ▁) ▁{ ▁count ▁+= ▁( ▁x ▁/ ▁z ▁) ▁; ▁z ▁*= ▁y ▁; ▁} ▁return ▁count ▁; ▁} ▁long ▁long ▁int ▁mod Mult ▁( ▁long ▁long ▁int ▁a ▁, ▁long ▁long ▁int ▁b ▁, ▁long ▁long ▁int ▁mod ▁) ▁{ ▁long ▁long ▁int ▁res ▁= ▁0 ▁; ▁a ▁= ▁a ▁% ▁mod ▁; ▁while ▁( ▁b ▁> ▁0 ▁) ▁{ ▁if ▁( ▁b ▁% ▁2 ▁== ▁1 ▁) ▁res ▁= ▁( ▁res ▁+ ▁a ▁) ▁% ▁mod ▁; ▁a ▁= ▁( ▁a ▁* ▁2 ▁) ▁% ▁mod ▁; ▁b ▁/= ▁2 ▁; ▁} ▁return ▁res ▁% ▁mod ▁; ▁} ▁long ▁long ▁int ▁count W ays ▁( ▁long ▁long ▁int ▁n ▁, ▁long ▁long ▁int ▁m ▁) ▁{ ▁long ▁long ▁int ▁ans ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁primes ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁long ▁long ▁int ▁powers ▁= ▁power ▁( ▁n ▁, ▁primes ▁[ ▁i ▁] ▁) ▁; ▁if ▁( ▁powers ▁== ▁0 ▁) ▁break ▁; ▁ans ▁= ▁mod Mult ▁( ▁ans ▁, ▁powers ▁+ ▁1 ▁, ▁m ▁) ▁% ▁m ▁; ▁} ▁if ▁( ▁( ▁( ▁ans ▁- ▁1 ▁) ▁% ▁m ▁) ▁< ▁0 ▁) ▁return ▁( ▁ans ▁- ▁1 ▁+ ▁m ▁) ▁% ▁m ▁; ▁else ▁return ▁( ▁ans ▁- ▁1 ▁) ▁% ▁m ▁;
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁p yth ag ore an Tri plet ▁( ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁/ ▁3 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁<= ▁n ▁/ ▁2 ▁; ▁j ▁++ ▁) ▁{ ▁int ▁k ▁= ▁n ▁- ▁i ▁- ▁j ▁; ▁if ▁( ▁i ▁* ▁i ▁+ ▁j ▁* ▁j ▁== ▁k ▁* ▁k ▁) ▁{ ▁c out ▁<< ▁i ▁<< ▁" ▁, ▁" ▁<< ▁j ▁<< ▁" ▁, ▁" ▁<< ▁k ▁; ▁return ▁; ▁} ▁} ▁} ▁c out ▁<< ▁" ▁No ▁Tri plet ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁12 ▁; ▁p yth ag ore an Tri plet ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁dig Sum ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁0 ▁) ▁return ▁0 ▁; ▁return ▁( ▁n ▁% ▁9 ▁== ▁0 ▁) ▁? ▁9 ▁: ▁( ▁n ▁% ▁9 ▁) ▁; ▁} ▁int ▁repeated Number Sum ▁( ▁int ▁n ▁, ▁int ▁x ▁) ▁{ ▁int ▁sum ▁= ▁x ▁* ▁dig Sum ▁( ▁n ▁) ▁; ▁return ▁dig Sum ▁( ▁sum ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁24 ▁, ▁x ▁= ▁3 ▁; ▁c out ▁<< ▁repeated Number Sum ▁( ▁n ▁, ▁x ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁MAX ▁100000 ▁NEW _ LINE ▁int ▁multiply ▁( ▁int ▁x ▁, ▁int ▁res ▁[ ▁] ▁, ▁int ▁res _ size ▁) ▁{ ▁int ▁carry ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁res _ size ▁; ▁i ▁++ ▁) ▁{ ▁int ▁prod ▁= ▁res ▁[ ▁i ▁] ▁* ▁x ▁+ ▁carry ▁; ▁res ▁[ ▁i ▁] ▁= ▁prod ▁% ▁10 ▁; ▁carry ▁= ▁prod ▁/ ▁10 ▁; ▁} ▁while ▁( ▁carry ▁) ▁{ ▁res ▁[ ▁res _ size ▁] ▁= ▁carry ▁% ▁10 ▁; ▁carry ▁= ▁carry ▁/ ▁10 ▁; ▁res _ size ▁++ ▁; ▁} ▁return ▁res _ size ▁; ▁} ▁void ▁power ▁( ▁int ▁x ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁0 ▁) ▁{ ▁c out ▁<< ▁"1" ▁; ▁return ▁; ▁} ▁int ▁res ▁[ ▁MAX ▁] ▁; ▁int ▁res _ size ▁= ▁0 ▁; ▁int ▁temp ▁= ▁x ▁; ▁while ▁( ▁temp ▁!= ▁0 ▁) ▁{ ▁res ▁[ ▁res _ size ▁++ ▁] ▁= ▁temp ▁% ▁10 ▁; ▁temp ▁= ▁temp ▁/ ▁10 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁res _ size ▁= ▁multiply ▁( ▁x ▁, ▁res ▁, ▁res _ size ▁) ▁; ▁c out ▁<< ▁x ▁<< ▁" ▁^ ▁" ▁<< ▁n ▁<< ▁" ▁= ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁res _ size ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁c out ▁<< ▁res ▁[ ▁i ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁exponent ▁= ▁100 ▁; ▁int ▁base ▁= ▁20 ▁; ▁power ▁( ▁base ▁, ▁exponent ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁double ▁find Area ▁( ▁double ▁d ▁) ▁{ ▁return ▁( ▁d ▁* ▁d ▁) ▁/ ▁2.0 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁double ▁d ▁= ▁10 ▁; ▁c out ▁<< ▁( ▁find Area ▁( ▁d ▁) ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find Numbers ▁( ▁int ▁n ▁, ▁int ▁d ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁2 ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁"1" ▁<< ▁" ▁" ▁; ▁c out ▁<< ▁"2" ▁<< ▁" ▁" ▁; ▁c out ▁<< ▁n ▁+ ▁d ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁3 ▁, ▁D ▁= ▁5 ▁; ▁find Numbers ▁( ▁N ▁, ▁D ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁float ▁Avg of Square N ▁( ▁int ▁n ▁) ▁{ ▁float ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁sum ▁+= ▁( ▁i ▁* ▁i ▁) ▁; ▁return ▁sum ▁/ ▁n ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁2 ▁; ▁c out ▁<< ▁Avg of Square N ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁L CM ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁return ▁( ▁a ▁* ▁b ▁) ▁/ ▁( ▁__ g cd ▁( ▁a ▁, ▁b ▁) ▁) ▁; ▁} ▁int ▁l cm Of Num erator ▁( ▁vector ▁< ▁pair ▁< ▁int ▁, ▁int ▁> ▁> ▁vect ▁) ▁{ ▁int ▁l cm ▁= ▁vect ▁[ ▁0 ▁] ▁. ▁first ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁vect ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁l cm ▁= ▁L CM ▁( ▁vect ▁[ ▁i ▁] ▁. ▁first ▁, ▁l cm ▁) ▁; ▁return ▁l cm ▁; ▁} ▁int ▁gcd Of D emon in ators ▁( ▁vector ▁< ▁pair ▁< ▁int ▁, ▁int ▁> ▁> ▁vect ▁) ▁{ ▁int ▁gcd ▁= ▁vect ▁[ ▁0 ▁] ▁. ▁second ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁vect ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁gcd ▁= ▁__ g cd ▁( ▁vect ▁[ ▁i ▁] ▁. ▁second ▁, ▁gcd ▁) ▁; ▁return ▁gcd ▁; ▁} ▁void ▁l cm Of R ation als ▁( ▁vector ▁< ▁pair ▁< ▁int ▁, ▁int ▁> ▁> ▁vect ▁) ▁{ ▁c out ▁<< ▁l cm Of Num erator ▁( ▁vect ▁) ▁<< ▁" ▁/ ▁" ▁<< ▁gcd Of D emon in ators ▁( ▁vect ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁pair ▁< ▁int ▁, ▁int ▁> ▁> ▁vect ▁; ▁vect ▁. ▁push _ back ▁( ▁make _ pair ▁( ▁2 ▁, ▁7 ▁) ▁) ▁; ▁vect ▁. ▁push _ back ▁( ▁make _ pair ▁( ▁3 ▁, ▁14 ▁) ▁) ▁; ▁vect ▁. ▁push _ back ▁( ▁make _ pair ▁( ▁5 ▁, ▁3 ▁) ▁) ▁; ▁l cm Of R ation als ▁( ▁vect ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁sum of N term ▁( ▁int ▁a ▁, ▁int ▁d ▁, ▁int ▁b ▁, ▁int ▁r ▁, ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁sum ▁+= ▁( ▁( ▁a ▁+ ▁( ▁i ▁- ▁1 ▁) ▁* ▁d ▁) ▁* ▁( ▁b ▁* ▁pow ▁( ▁r ▁, ▁i ▁- ▁1 ▁) ▁) ▁) ▁; ▁return ▁sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁= ▁1 ▁, ▁d ▁= ▁1 ▁, ▁b ▁= ▁2 ▁, ▁r ▁= ▁2 ▁, ▁n ▁= ▁3 ▁; ▁c out ▁<< ▁sum of N term ▁( ▁a ▁, ▁d ▁, ▁b ▁, ▁r ▁, ▁n ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁first ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁int ▁c ▁) ▁{ ▁a ▁% = ▁b ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁b ▁; ▁i ▁++ ▁) ▁{ ▁a ▁= ▁a ▁* ▁10 ▁; ▁if ▁( ▁a ▁/ ▁b ▁== ▁c ▁) ▁return ▁i ▁; ▁a ▁% = ▁b ▁; ▁} ▁return ▁-1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁= ▁1 ▁, ▁b ▁= ▁4 ▁, ▁c ▁= ▁5 ▁; ▁c out ▁<< ▁first ▁( ▁a ▁, ▁b ▁, ▁c ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is Prime ▁( ▁int ▁n ▁) ▁{ ▁int ▁i ▁= ▁2 ▁; ▁while ▁( ▁i ▁* ▁i ▁<= ▁n ▁) ▁{ ▁if ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁return ▁false ▁; ▁i ▁++ ▁; ▁} ▁return ▁true ▁; ▁} ▁int ▁minimum Sum ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁is Prime ▁( ▁n ▁) ▁) ▁return ▁1 ▁; ▁if ▁( ▁n ▁% ▁2 ▁== ▁0 ▁) ▁return ▁2 ▁; ▁if ▁( ▁is Prime ▁( ▁n ▁- ▁2 ▁) ▁) ▁return ▁2 ▁; ▁return ▁3 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁27 ▁; ▁c out ▁<< ▁minimum Sum ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁term ▁( ▁int ▁n ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁ans ▁+= ▁i ▁; ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁4 ▁; ▁c out ▁<< ▁term ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁double ▁sum ▁( ▁int ▁x ▁, ▁int ▁n ▁) ▁{ ▁double ▁i ▁, ▁total ▁= ▁1.0 ▁, ▁multi ▁= ▁x ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁total ▁= ▁total ▁+ ▁multi ▁/ ▁i ▁; ▁multi ▁= ▁multi ▁* ▁x ▁; ▁} ▁return ▁total ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁x ▁= ▁2 ▁; ▁int ▁n ▁= ▁5 ▁; ▁c out ▁<< ▁fixed ▁<< ▁set precision ▁( ▁2 ▁) ▁<< ▁sum ▁( ▁x ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁double ▁gcd ▁( ▁double ▁a ▁, ▁double ▁b ▁) ▁{ ▁if ▁( ▁a ▁< ▁b ▁) ▁return ▁gcd ▁( ▁b ▁, ▁a ▁) ▁; ▁if ▁( ▁f abs ▁( ▁b ▁) ▁< ▁0.001 ▁) ▁return ▁a ▁; ▁else ▁return ▁( ▁gcd ▁( ▁b ▁, ▁a ▁- ▁floor ▁( ▁a ▁/ ▁b ▁) ▁* ▁b ▁) ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁double ▁a ▁= ▁1. 20 ▁, ▁b ▁= ▁2 2.5 ▁; ▁c out ▁<< ▁gcd ▁( ▁a ▁, ▁b ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁gcd Max ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁b ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁N ▁) ▁{ ▁int ▁cnt ▁[ ▁N ▁] ▁= ▁{ ▁0 ▁} ▁; ▁int ▁first ▁[ ▁N ▁] ▁= ▁{ ▁0 ▁} ▁, ▁second ▁[ ▁N ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁cnt ▁[ ▁a ▁[ ▁i ▁] ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁++ ▁i ▁) ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁< ▁N ▁; ▁j ▁+= ▁i ▁) ▁if ▁( ▁cnt ▁[ ▁j ▁] ▁) ▁first ▁[ ▁i ▁] ▁= ▁max ▁( ▁first ▁[ ▁i ▁] ▁, ▁j ▁) ▁; ▁mem set ▁( ▁cnt ▁, ▁0 ▁, ▁sizeof ▁( ▁cnt ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁cnt ▁[ ▁b ▁[ ▁i ▁] ▁] ▁= ▁true ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁++ ▁i ▁) ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁< ▁N ▁; ▁j ▁+= ▁i ▁) ▁if ▁( ▁cnt ▁[ ▁j ▁] ▁) ▁second ▁[ ▁i ▁] ▁= ▁max ▁( ▁second ▁[ ▁i ▁] ▁, ▁j ▁) ▁; ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁N ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁if ▁( ▁first ▁[ ▁i ▁] ▁&& ▁second ▁[ ▁i ▁] ▁) ▁break ▁; ▁c out ▁<< ▁" ▁Maximum ▁GC D ▁pair ▁with ▁maximum ▁" ▁" ▁sum ▁is ▁" ▁<< ▁first ▁[ ▁i ▁] ▁<< ▁" ▁" ▁<< ▁second ▁[ ▁i ▁] ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁1 ▁, ▁4 ▁, ▁2 ▁, ▁8 ▁} ▁; ▁int ▁b ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁2 ▁, ▁12 ▁, ▁8 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁int ▁N ▁= ▁20 ▁; ▁gcd Max ▁( ▁a ▁, ▁b ▁, ▁n ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁calculate ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁r ▁= ▁i ▁+ ▁1 ▁; ▁for ▁( ▁int ▁j ▁= ▁r ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁== ▁a ▁[ ▁j ▁] ▁) ▁r ▁+= ▁1 ▁; ▁else ▁break ▁; ▁} ▁int ▁d ▁= ▁r ▁- ▁i ▁; ▁ans ▁+= ▁( ▁d ▁* ▁( ▁d ▁+ ▁1 ▁) ▁/ ▁2 ▁) ▁; ▁i ▁= ▁r ▁- ▁1 ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁4 ▁, ▁5 ▁, ▁3 ▁, ▁3 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁calculate ▁( ▁a ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁sum ▁( ▁int ▁n ▁) ▁{ ▁int ▁rem ▁= ▁0 ▁; ▁int ▁sum _ of _ digits ▁= ▁0 ▁; ▁while ▁( ▁n ▁> ▁0 ▁) ▁{ ▁rem ▁= ▁n ▁% ▁10 ▁; ▁sum _ of _ digits ▁+= ▁rem ▁; ▁n ▁= ▁n ▁/ ▁10 ▁; ▁} ▁return ▁sum _ of _ digits ▁; ▁} ▁int ▁count ▁( ▁int ▁n ▁) ▁{ ▁int ▁c ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁97 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁a ▁= ▁sum ▁( ▁i ▁) ▁; ▁int ▁b ▁= ▁sum ▁( ▁a ▁) ▁; ▁if ▁( ▁( ▁i ▁+ ▁a ▁+ ▁b ▁) ▁== ▁n ▁) ▁{ ▁c ▁+= ▁1 ▁; ▁} ▁} ▁return ▁c ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁99 39 ▁; ▁c out ▁<< ▁count ▁( ▁n ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# include ▁< cm ath > ▁NEW _ LINE ▁vector ▁< ▁int ▁> ▁S ieve Of E rat ost hen es ▁( ▁int ▁n ▁) ▁{ ▁bool ▁prime ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁mem set ▁( ▁prime ▁, ▁false ▁, ▁sizeof ▁( ▁prime ▁) ▁) ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁* ▁p ▁<= ▁n ▁; ▁p ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁p ▁] ▁== ▁false ▁) ▁for ▁( ▁int ▁i ▁= ▁p ▁* ▁2 ▁; ▁i ▁< ▁n ▁+ ▁1 ▁; ▁i ▁+= ▁p ▁) ▁prime ▁[ ▁i ▁] ▁= ▁true ▁; ▁} ▁vector ▁< ▁int ▁> ▁lis ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁<= ▁n ▁; ▁p ▁++ ▁) ▁if ▁( ▁prime ▁[ ▁p ▁] ▁== ▁false ▁) ▁lis ▁. ▁push _ back ▁( ▁p ▁) ▁; ▁return ▁lis ▁; ▁} ▁int ▁set Bits ▁( ▁int ▁n ▁) ▁{ ▁return ▁__ builtin _ pop count ▁( ▁n ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁x ▁= ▁4 ▁, ▁y ▁= ▁8 ▁; ▁int ▁count ▁= ▁0 ▁; ▁vector ▁< ▁int ▁> ▁prime Arr ▁= ▁S ieve Of E rat ost hen es ▁( ▁ceil ▁( ▁log 2 ▁( ▁y ▁) ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁x ▁; ▁i ▁< ▁y ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁int ▁temp ▁= ▁set Bits ▁( ▁i ▁) ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁prime Arr ▁. ▁size ▁( ▁) ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁temp ▁== ▁prime Arr ▁[ ▁j ▁] ▁) ▁{ ▁count ▁+= ▁1 ▁; ▁break ▁; ▁} ▁} ▁} ▁c out ▁<< ▁count ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Trailing Zero es ▁( ▁int ▁N ▁) ▁{ ▁int ▁res ▁= ▁log 2 ▁( ▁N ▁^ ▁( ▁N ▁- ▁1 ▁) ▁) ▁; ▁return ▁res ▁>= ▁0 ▁? ▁res ▁: ▁0 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁12 ▁; ▁c out ▁<< ▁count Trailing Zero es ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁prod _ of _ max _ min ▁( ▁int ▁n ▁) ▁{ ▁int ▁largest ▁= ▁0 ▁; ▁int ▁smallest ▁= ▁10 ▁; ▁while ▁( ▁n ▁) ▁{ ▁int ▁r ▁= ▁n ▁% ▁10 ▁; ▁largest ▁= ▁max ▁( ▁r ▁, ▁largest ▁) ▁; ▁smallest ▁= ▁min ▁( ▁r ▁, ▁smallest ▁) ▁; ▁n ▁= ▁n ▁/ ▁10 ▁; ▁} ▁return ▁largest ▁* ▁smallest ▁; ▁} ▁int ▁formed _ no ▁( ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁if ▁( ▁K ▁== ▁1 ▁) ▁{ ▁return ▁N ▁; ▁} ▁int ▁answer ▁= ▁N ▁; ▁while ▁( ▁K ▁-- ▁) ▁{ ▁int ▁a _ current ▁= ▁prod _ of _ max _ min ▁( ▁answer ▁) ▁; ▁if ▁( ▁a _ current ▁== ▁0 ▁) ▁break ▁; ▁answer ▁+= ▁a _ current ▁; ▁} ▁return ▁answer ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁4 87 ▁, ▁K ▁= ▁100 000000 ▁; ▁c out ▁<< ▁formed _ no ▁( ▁N ▁, ▁K ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁subset Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁i ▁, ▁int ▁sum ▁, ▁int ▁count ▁) ▁{ ▁if ▁( ▁i ▁== ▁n ▁) ▁{ ▁if ▁( ▁sum ▁== ▁0 ▁) ▁{ ▁count ▁++ ▁; ▁} ▁return ▁count ▁; ▁} ▁count ▁= ▁subset Sum ▁( ▁arr ▁, ▁n ▁, ▁i ▁+ ▁1 ▁, ▁sum ▁- ▁arr ▁[ ▁i ▁] ▁, ▁count ▁) ▁; ▁count ▁= ▁subset Sum ▁( ▁arr ▁, ▁n ▁, ▁i ▁+ ▁1 ▁, ▁sum ▁, ▁count ▁) ▁; ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁sum ▁= ▁10 ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁subset Sum ▁( ▁arr ▁, ▁n ▁, ▁0 ▁, ▁sum ▁, ▁0 ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁does Contain B ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁int ▁c ▁) ▁{ ▁if ▁( ▁a ▁== ▁b ▁) ▁return ▁true ▁; ▁if ▁( ▁( ▁b ▁- ▁a ▁) ▁* ▁c ▁> ▁0 ▁&& ▁( ▁b ▁- ▁a ▁) ▁% ▁c ▁== ▁0 ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁= ▁1 ▁, ▁b ▁= ▁7 ▁, ▁c ▁= ▁3 ▁; ▁if ▁( ▁does Contain B ▁( ▁a ▁, ▁b ▁, ▁c ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< std io . h > ▁NEW _ LINE ▁int ▁subtract One ▁( ▁int ▁x ▁) ▁{ ▁return ▁( ▁( ▁x ▁<< ▁1 ▁) ▁+ ▁( ▁~ ▁x ▁) ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁printf ▁( ▁" ▁% ▁d ▁" ▁, ▁subtract One ▁( ▁13 ▁) ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁digit Sum ▁( ▁long ▁long ▁int ▁n ▁) ▁{ ▁int ▁dig Sum ▁= ▁0 ▁; ▁while ▁( ▁n ▁) ▁{ ▁dig Sum ▁+= ▁n ▁% ▁10 ▁; ▁n ▁/= ▁10 ▁; ▁} ▁return ▁dig Sum ▁; ▁} ▁long ▁long ▁int ▁count Integer ▁( ▁long ▁long ▁int ▁n ▁, ▁long ▁long ▁int ▁s ▁) ▁{ ▁if ▁( ▁n ▁< ▁s ▁) ▁return ▁0 ▁; ▁for ▁( ▁long ▁long ▁int ▁i ▁= ▁s ▁; ▁i ▁<= ▁min ▁( ▁n ▁, ▁s ▁+ ▁16 3 ▁) ▁; ▁i ▁++ ▁) ▁if ▁( ▁( ▁i ▁- ▁digit Sum ▁( ▁i ▁) ▁) ▁> ▁s ▁) ▁return ▁( ▁n ▁- ▁i ▁+ ▁1 ▁) ▁; ▁return ▁0 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁long ▁long ▁int ▁n ▁= ▁1000 ▁, ▁s ▁= ▁100 ▁; ▁c out ▁<< ▁count Integer ▁( ▁n ▁, ▁s ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁float ▁sum Of Series ▁( ▁int ▁n ▁) ▁{ ▁return ▁0.0 246 ▁* ▁( ▁pow ▁( ▁10 ▁, ▁n ▁) ▁- ▁1 ▁- ▁( ▁9 ▁* ▁n ▁) ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁3 ▁; ▁c out ▁<< ▁sum Of Series ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print _ sequence ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁b ▁= ▁n ▁/ ▁( ▁k ▁* ▁( ▁k ▁+ ▁1 ▁) ▁/ ▁2 ▁) ▁; ▁if ▁( ▁b ▁== ▁0 ▁) ▁{ ▁c out ▁<< ▁-1 ▁<< ▁end l ▁; ▁} ▁else ▁{ ▁int ▁r ▁= ▁1 ▁; ▁for ▁( ▁int ▁x ▁= ▁1 ▁; ▁x ▁* ▁x ▁<= ▁n ▁; ▁x ▁++ ▁) ▁{ ▁if ▁( ▁n ▁% ▁x ▁!= ▁0 ▁) ▁continue ▁; ▁if ▁( ▁x ▁<= ▁b ▁&& ▁x ▁> ▁r ▁) ▁r ▁= ▁x ▁; ▁if ▁( ▁n ▁/ ▁x ▁<= ▁b ▁&& ▁n ▁/ ▁x ▁> ▁r ▁) ▁r ▁= ▁n ▁/ ▁x ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁k ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁r ▁* ▁i ▁<< ▁" ▁" ▁; ▁int ▁res ▁= ▁n ▁- ▁( ▁r ▁* ▁( ▁k ▁* ▁( ▁k ▁- ▁1 ▁) ▁/ ▁2 ▁) ▁) ▁; ▁c out ▁<< ▁res ▁<< ▁end l ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁24 ▁; ▁int ▁k ▁= ▁4 ▁; ▁print _ sequence ▁( ▁n ▁, ▁k ▁) ▁; ▁n ▁= ▁24 ▁, ▁k ▁= ▁5 ▁; ▁print _ sequence ▁( ▁n ▁, ▁k ▁) ▁; ▁n ▁= ▁6 ▁, ▁k ▁= ▁4 ▁; ▁print _ sequence ▁( ▁n ▁, ▁k ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Digit ▁( ▁long ▁long ▁n ▁) ▁{ ▁if ▁( ▁n ▁/ ▁10 ▁== ▁0 ▁) ▁return ▁1 ▁; ▁return ▁1 ▁+ ▁count Digit ▁( ▁n ▁/ ▁10 ▁) ▁; ▁} ▁int ▁main ▁( ▁void ▁) ▁{ ▁long ▁long ▁n ▁= ▁3 45 289 46 7 ▁; ▁c out ▁<< ▁" ▁Number ▁of ▁digits ▁: ▁" ▁<< ▁count Digit ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁string ▁dec To Bin ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁0 ▁) ▁return ▁"0" ▁; ▁string ▁bin ▁= ▁" ▁" ▁; ▁while ▁( ▁n ▁> ▁0 ▁) ▁{ ▁bin ▁= ▁( ▁( ▁n ▁& ▁1 ▁) ▁== ▁0 ▁? ▁'0' ▁: ▁'1' ▁) ▁+ ▁bin ▁; ▁n ▁>>= ▁1 ▁; ▁} ▁return ▁bin ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁38 ▁; ▁c out ▁<< ▁dec To Bin ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁find No Is Div isible Or Not ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁l ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁l ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁% ▁n ▁!= ▁0 ▁) ▁return ▁false ▁; ▁} ▁return ▁true ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁14 ▁, ▁12 ▁, ▁4 ▁, ▁18 ▁} ▁; ▁int ▁n ▁= ▁2 ▁; ▁int ▁l ▁= ▁( ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁) ▁; ▁if ▁( ▁find No Is Div isible Or Not ▁( ▁a ▁, ▁n ▁, ▁l ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁getTotal X or Of Sub array X ors ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁if ▁( ▁N ▁% ▁2 ▁== ▁0 ▁) ▁return ▁0 ▁; ▁int ▁res ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁+= ▁2 ▁) ▁res ▁^= ▁arr ▁[ ▁i ▁] ▁; ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁5 ▁, ▁2 ▁, ▁4 ▁, ▁6 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁getTotal X or Of Sub array X ors ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find N th Even Digit Number ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁1 ▁) ▁return ▁0 ▁; ▁vector ▁< ▁int ▁> ▁v ▁; ▁n ▁= ▁n ▁- ▁1 ▁; ▁while ▁( ▁n ▁> ▁0 ▁) ▁{ ▁v ▁. ▁push _ back ▁( ▁n ▁% ▁5 ▁) ▁; ▁n ▁= ▁n ▁/ ▁5 ▁; ▁} ▁int ▁result ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁v ▁. ▁size ▁( ▁) ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁result ▁= ▁result ▁* ▁10 ▁; ▁result ▁= ▁result ▁+ ▁v ▁[ ▁i ▁] ▁; ▁} ▁return ▁2 ▁* ▁result ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁c out ▁<< ▁find N th Even Digit Number ▁( ▁2 ▁) ▁<< ▁end l ▁; ▁c out ▁<< ▁find N th Even Digit Number ▁( ▁10 ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁long ▁long ▁modulo Multip lication ▁( ▁long ▁long ▁a ▁, ▁long ▁long ▁b ▁, ▁long ▁long ▁mod ▁) ▁{ ▁a ▁% = ▁mod ▁; ▁while ▁( ▁b ▁) ▁{ ▁if ▁( ▁b ▁& ▁1 ▁) ▁res ▁= ▁( ▁res ▁+ ▁a ▁) ▁% ▁mod ▁; ▁a ▁= ▁( ▁2 ▁* ▁a ▁) ▁% ▁mod ▁; ▁} ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁long ▁long ▁a ▁= ▁4 26 ▁; ▁long ▁long ▁b ▁= ▁9 64 ▁; ▁long ▁long ▁m ▁= ▁2 35 ▁; ▁c out ▁<< ▁modulo Multip lication ▁( ▁a ▁, ▁b ▁, ▁m ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁k Fact ors ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁vector ▁< ▁int ▁> ▁P ▁; ▁while ▁( ▁n ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁P ▁. ▁push _ back ▁( ▁2 ▁) ▁; ▁n ▁/= ▁2 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁3 ▁; ▁i ▁* ▁i ▁<= ▁n ▁; ▁i ▁= ▁i ▁+ ▁2 ▁) ▁{ ▁while ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁{ ▁n ▁= ▁n ▁/ ▁i ▁; ▁P ▁. ▁push _ back ▁( ▁i ▁) ▁; ▁} ▁} ▁if ▁( ▁n ▁> ▁2 ▁) ▁P ▁. ▁push _ back ▁( ▁n ▁) ▁; ▁if ▁( ▁P ▁. ▁size ▁( ▁) ▁< ▁k ▁) ▁{ ▁c out ▁<< ▁" ▁- ▁1" ▁<< ▁end l ▁; ▁return ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁k ▁- ▁1 ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁P ▁[ ▁i ▁] ▁<< ▁" ▁, ▁" ▁; ▁int ▁product ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁k ▁- ▁1 ▁; ▁i ▁< ▁P ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁product ▁= ▁product ▁* ▁P ▁[ ▁i ▁] ▁; ▁c out ▁<< ▁product ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁54 ▁, ▁k ▁= ▁3 ▁; ▁k Fact ors ▁( ▁n ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁MAX ▁10000 1 ▁NEW _ LINE ▁int ▁perfect Div ▁[ ▁MAX ▁] ▁; ▁void ▁pre compute Counts ▁( ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁* ▁i ▁< ▁MAX ▁; ▁++ ▁i ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁* ▁i ▁; ▁j ▁< ▁MAX ▁; ▁j ▁+= ▁i ▁* ▁i ▁) ▁++ ▁perfect Div ▁[ ▁j ▁] ▁; ▁} ▁} ▁int ▁count Perf ect Div is ors ▁( ▁int ▁n ▁) ▁{ ▁return ▁perfect Div ▁[ ▁n ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁pre compute Counts ▁( ▁) ▁; ▁int ▁n ▁= ▁16 ▁; ▁c out ▁<< ▁" ▁Total ▁perfect ▁div is ors ▁of ▁" ▁<< ▁n ▁<< ▁" ▁= ▁" ▁<< ▁count Perf ect Div is ors ▁( ▁n ▁) ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁n ▁= ▁12 ▁; ▁c out ▁<< ▁" ▁Total ▁perfect ▁div is ors ▁of ▁" ▁<< ▁n ▁<< ▁" ▁= ▁" ▁<< ▁count Perf ect Div is ors ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Min Number ▁( ▁int ▁n ▁) ▁{ ▁int ▁count ▁= ▁0 ▁, ▁ans ▁= ▁1 ▁; ▁while ▁( ▁n ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁count ▁++ ▁; ▁n ▁/= ▁2 ▁; ▁} ▁if ▁( ▁count ▁% ▁2 ▁) ▁ans ▁*= ▁2 ▁; ▁for ▁( ▁int ▁i ▁= ▁3 ▁; ▁i ▁<= ▁sqrt ▁( ▁n ▁) ▁; ▁i ▁+= ▁2 ▁) ▁{ ▁count ▁= ▁0 ▁; ▁while ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁{ ▁count ▁++ ▁; ▁n ▁/= ▁i ▁; ▁} ▁if ▁( ▁count ▁% ▁2 ▁) ▁ans ▁*= ▁i ▁; ▁} ▁if ▁( ▁n ▁> ▁2 ▁) ▁ans ▁*= ▁n ▁; ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁72 ▁; ▁c out ▁<< ▁find Min Number ▁( ▁n ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁S ieve Of E rat ost hen es ▁( ▁int ▁n ▁, ▁bool ▁prime ▁[ ▁] ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁prime ▁[ ▁i ▁] ▁= ▁true ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁* ▁p ▁<= ▁n ▁; ▁p ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁p ▁] ▁== ▁true ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁p ▁* ▁2 ▁; ▁i ▁<= ▁n ▁; ▁i ▁+= ▁p ▁) ▁prime ▁[ ▁i ▁] ▁= ▁false ▁; ▁} ▁} ▁} ▁void ▁m ers en ne Pr imes ▁( ▁int ▁n ▁) ▁{ ▁bool ▁prime ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁S ieve Of E rat ost hen es ▁( ▁n ▁, ▁prime ▁) ▁; ▁for ▁( ▁int ▁k ▁= ▁2 ▁; ▁( ▁( ▁1 ▁<< ▁k ▁) ▁- ▁1 ▁) ▁<= ▁n ▁; ▁k ▁++ ▁) ▁{ ▁long ▁long ▁num ▁= ▁( ▁1 ▁<< ▁k ▁) ▁- ▁1 ▁; ▁if ▁( ▁prime ▁[ ▁num ▁] ▁) ▁c out ▁<< ▁num ▁<< ▁" ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁31 ▁; ▁c out ▁<< ▁" ▁M ers en ne ▁prime ▁numbers ▁smaller ▁" ▁<< ▁" ▁than ▁or ▁equal ▁to ▁" ▁<< ▁n ▁<< ▁end l ▁; ▁m ers en ne Pr imes ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is Perf ect ▁( ▁int ▁n ▁) ▁{ ▁int ▁s ▁= ▁sqrt ▁( ▁n ▁) ▁; ▁return ▁( ▁s ▁* ▁s ▁== ▁n ▁) ▁; ▁} ▁int ▁div is ors Count ▁( ▁int ▁n ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁sqrt ▁( ▁n ▁) ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁{ ▁if ▁( ▁n ▁/ ▁i ▁== ▁i ▁) ▁count ▁+= ▁1 ▁; ▁else ▁count ▁+= ▁2 ▁; ▁} ▁} ▁return ▁count ▁; ▁} ▁int ▁k Div is ors ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁int ▁k ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁a ▁; ▁i ▁<= ▁b ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁is Perf ect ▁( ▁i ▁) ▁) ▁if ▁( ▁div is ors ▁( ▁i ▁) ▁== ▁k ▁) ▁count ▁++ ▁; ▁} ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁= ▁2 ▁, ▁b ▁= ▁49 ▁, ▁k ▁= ▁3 ▁; ▁c out ▁<< ▁k Div is ors ▁( ▁a ▁, ▁b ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁typedef ▁long ▁long ▁ll ▁; ▁int ▁find Count Of Solution s ▁( ▁int ▁n ▁, ▁int ▁p ▁) ▁{ ▁ll ▁ans ▁= ▁0 ▁; ▁for ▁( ▁ll ▁x ▁= ▁1 ▁; ▁x ▁< ▁p ▁; ▁x ▁++ ▁) ▁{ ▁if ▁( ▁( ▁x ▁* ▁x ▁) ▁% ▁p ▁== ▁1 ▁) ▁{ ▁ll ▁last ▁= ▁x ▁+ ▁p ▁* ▁( ▁n ▁/ ▁p ▁) ▁; ▁if ▁( ▁last ▁> ▁n ▁) ▁last ▁-= ▁p ▁; ▁ans ▁+= ▁( ▁( ▁last ▁- ▁x ▁) ▁/ ▁p ▁+ ▁1 ▁) ▁; ▁} ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁ll ▁n ▁= ▁10 ▁, ▁p ▁= ▁5 ▁; ▁printf ▁( ▁" ▁% ▁l ld ▁STRNEWLINE ▁" ▁, ▁find Count Of Solution s ▁( ▁n ▁, ▁p ▁) ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁k ap re k ar Rec ▁( ▁int ▁n ▁, ▁int ▁& ▁prev ▁) ▁{ ▁if ▁( ▁n ▁== ▁0 ▁) ▁return ▁0 ▁; ▁prev ▁= ▁n ▁; ▁int ▁digits ▁[ ▁4 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁4 ▁; ▁i ▁++ ▁) ▁{ ▁digits ▁[ ▁i ▁] ▁= ▁n ▁% ▁10 ▁; ▁n ▁= ▁n ▁/ ▁10 ▁; ▁} ▁sort ▁( ▁digits ▁, ▁digits ▁+ ▁4 ▁) ▁; ▁int ▁asc ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁4 ▁; ▁i ▁++ ▁) ▁asc ▁= ▁asc ▁* ▁10 ▁+ ▁digits ▁[ ▁i ▁] ▁; ▁sort ▁( ▁digits ▁, ▁digits ▁+ ▁4 ▁, ▁std ▁:: ▁greater ▁< ▁int ▁> ▁( ▁) ▁) ▁; ▁int ▁desc ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁4 ▁; ▁i ▁++ ▁) ▁desc ▁= ▁desc ▁* ▁10 ▁+ ▁digits ▁[ ▁i ▁] ▁; ▁int ▁diff ▁= ▁abs ▁( ▁asc ▁- ▁desc ▁) ▁; ▁if ▁( ▁diff ▁== ▁prev ▁) ▁return ▁diff ▁; ▁return ▁k ap re k ar Rec ▁( ▁diff ▁, ▁prev ▁) ▁; ▁} ▁int ▁k ap re k ar ▁( ▁int ▁n ▁) ▁{ ▁int ▁prev ▁= ▁0 ▁; ▁return ▁k ap re k ar Rec ▁( ▁n ▁, ▁prev ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁c out ▁<< ▁k ap re k ar ▁( ▁1000 ▁) ▁<< ▁end l ▁; ▁c out ▁<< ▁k ap re k ar ▁( ▁11 12 ▁) ▁<< ▁end l ▁; ▁c out ▁<< ▁k ap re k ar ▁( ▁98 12 ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁char ▁xor _ c ▁( ▁char ▁a ▁, ▁char ▁b ▁) ▁{ ▁return ▁( ▁a ▁== ▁b ▁) ▁? ▁'0' ▁: ▁'1' ▁; ▁} ▁char ▁flip ▁( ▁char ▁c ▁) ▁{ ▁return ▁( ▁c ▁== ▁'0' ▁) ▁? ▁'1' ▁: ▁'0' ▁; ▁} ▁string ▁binary to Gray ▁( ▁string ▁binary ▁) ▁{ ▁string ▁gray ▁= ▁" ▁" ▁; ▁gray ▁+= ▁binary ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁binary ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁gray ▁+= ▁xor _ c ▁( ▁binary ▁[ ▁i ▁- ▁1 ▁] ▁, ▁binary ▁[ ▁i ▁] ▁) ▁; ▁} ▁return ▁gray ▁; ▁} ▁string ▁gray to Binary ▁( ▁string ▁gray ▁) ▁{ ▁string ▁binary ▁= ▁" ▁" ▁; ▁binary ▁+= ▁gray ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁gray ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁gray ▁[ ▁i ▁] ▁== ▁'0' ▁) ▁binary ▁+= ▁binary ▁[ ▁i ▁- ▁1 ▁] ▁; ▁else ▁binary ▁+= ▁flip ▁( ▁binary ▁[ ▁i ▁- ▁1 ▁] ▁) ▁; ▁} ▁return ▁binary ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁binary ▁= ▁" 0100 1" ▁; ▁c out ▁<< ▁" ▁G ray ▁code ▁of ▁" ▁<< ▁binary ▁<< ▁" ▁is ▁" ▁<< ▁binary to Gray ▁( ▁binary ▁) ▁<< ▁end l ▁; ▁string ▁gray ▁= ▁"01 101 " ▁; ▁c out ▁<< ▁" ▁Binary ▁code ▁of ▁" ▁<< ▁gray ▁<< ▁" ▁is ▁" ▁<< ▁gray to Binary ▁( ▁gray ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁getSum ▁( ▁int ▁BIT ree ▁[ ▁] ▁, ▁int ▁index ▁) ▁{ ▁while ▁( ▁index ▁> ▁0 ▁) ▁{ ▁sum ▁+= ▁BIT ree ▁[ ▁index ▁] ▁; ▁index ▁-= ▁index ▁& ▁( ▁- ▁index ▁) ▁; ▁} ▁return ▁sum ▁; ▁} ▁void ▁update BIT ▁( ▁int ▁BIT ree ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁index ▁, ▁int ▁val ▁) ▁{ ▁while ▁( ▁index ▁<= ▁n ▁) ▁{ ▁BIT ree ▁[ ▁index ▁] ▁+= ▁val ▁; ▁index ▁+= ▁index ▁& ▁( ▁- ▁index ▁) ▁; ▁} ▁} ▁void ▁convert ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁temp ▁[ ▁n ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁temp ▁[ ▁i ▁] ▁= ▁arr ▁[ ▁i ▁] ▁; ▁sort ▁( ▁temp ▁, ▁temp ▁+ ▁n ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁arr ▁[ ▁i ▁] ▁= ▁lower _ bound ▁( ▁temp ▁, ▁temp ▁+ ▁n ▁, ▁arr ▁[ ▁i ▁] ▁) ▁- ▁temp ▁+ ▁1 ▁; ▁} ▁} ▁int ▁getIn v Count ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁convert ▁( ▁arr ▁, ▁n ▁) ▁; ▁int ▁BIT ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁BIT ▁[ ▁i ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁inv count ▁+= ▁getSum ▁( ▁BIT ▁, ▁arr ▁[ ▁i ▁] ▁- ▁1 ▁) ▁; ▁update BIT ▁( ▁BIT ▁, ▁n ▁, ▁arr ▁[ ▁i ▁] ▁, ▁1 ▁) ▁; ▁} ▁return ▁inv count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁8 ▁, ▁4 ▁, ▁2 ▁, ▁1 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁c out ▁<< ▁" ▁Number ▁of ▁in versions ▁are ▁: ▁" ▁<< ▁getIn v Count ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁mod ▁( ▁string ▁num ▁, ▁int ▁a ▁) ▁{ ▁int ▁res ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁num ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁res ▁= ▁( ▁res ▁* ▁10 ▁+ ▁( ▁int ▁) ▁num ▁[ ▁i ▁] ▁- ▁'0' ▁) ▁% ▁a ▁; ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁num ▁= ▁"123 16 76 76 786 78 " ▁; ▁c out ▁<< ▁mod ▁( ▁num ▁, ▁10 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁phi ▁( ▁int ▁n ▁) ▁{ ▁float ▁result ▁= ▁n ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁* ▁p ▁<= ▁n ▁; ▁++ ▁p ▁) ▁{ ▁if ▁( ▁n ▁% ▁p ▁== ▁0 ▁) ▁{ ▁while ▁( ▁n ▁% ▁p ▁== ▁0 ▁) ▁n ▁/= ▁p ▁; ▁result ▁*= ▁( ▁1.0 ▁- ▁( ▁1.0 ▁/ ▁( ▁float ▁) ▁p ▁) ▁) ▁; ▁} ▁} ▁if ▁( ▁n ▁> ▁1 ▁) ▁result ▁*= ▁( ▁1.0 ▁- ▁( ▁1.0 ▁/ ▁( ▁float ▁) ▁n ▁) ▁) ▁; ▁return ▁( ▁int ▁) ▁result ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁; ▁for ▁( ▁n ▁= ▁1 ▁; ▁n ▁<= ▁10 ▁; ▁n ▁++ ▁) ▁{ ▁c out ▁<< ▁" ▁Ph i ▁" ▁<< ▁" ▁( ▁" ▁<< ▁n ▁<< ▁" ▁) ▁" ▁<< ▁" ▁= ▁" ▁<< ▁phi ▁( ▁n ▁) ▁<< ▁end l ▁; ▁} ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁largest Power ▁( ▁int ▁n ▁, ▁int ▁p ▁) ▁{ ▁int ▁x ▁= ▁0 ▁; ▁while ▁( ▁n ▁) ▁{ ▁n ▁/= ▁p ▁; ▁x ▁+= ▁n ▁; ▁} ▁return ▁x ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁10 ▁, ▁p ▁= ▁3 ▁; ▁c out ▁<< ▁" ▁The ▁largest ▁power ▁of ▁" ▁<< ▁p ▁<< ▁" ▁that ▁div ides ▁" ▁<< ▁n ▁<< ▁" ▁! ▁is ▁" ▁<< ▁largest Power ▁( ▁n ▁, ▁p ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print Square s ▁( ▁int ▁n ▁) ▁{ ▁int ▁square ▁= ▁0 ▁, ▁odd ▁= ▁1 ▁; ▁for ▁( ▁int ▁x ▁= ▁0 ▁; ▁x ▁< ▁n ▁; ▁x ▁++ ▁) ▁{ ▁c out ▁<< ▁square ▁<< ▁" ▁" ▁; ▁square ▁= ▁square ▁+ ▁odd ▁; ▁odd ▁= ▁odd ▁+ ▁2 ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁5 ▁; ▁print Square s ▁( ▁n ▁) ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁factorial ▁( ▁int ▁n ▁) ▁{ ▁return ▁( ▁n ▁== ▁1 ▁n ▁== ▁0 ▁) ▁? ▁1 ▁: ▁n ▁* ▁factorial ▁( ▁n ▁- ▁1 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁num ▁= ▁5 ▁; ▁c out ▁<< ▁" ▁Factor ial ▁of ▁" ▁<< ▁num ▁<< ▁" ▁is ▁" ▁<< ▁factorial ▁( ▁num ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁Or _ of _ And s _ for _ each _ query ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁queries ▁[ ▁] ▁[ ▁2 ▁] ▁, ▁int ▁q ▁) ▁{ ▁int ▁bits ▁[ ▁32 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁32 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁( ▁1 ▁<< ▁i ▁) ▁& ▁arr ▁[ ▁j ▁] ▁) ▁{ ▁bits ▁[ ▁i ▁] ▁++ ▁; ▁} ▁} ▁} ▁for ▁( ▁int ▁p ▁= ▁0 ▁; ▁p ▁< ▁q ▁; ▁p ▁++ ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁32 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁1 ▁<< ▁i ▁) ▁& ▁arr ▁[ ▁queries ▁[ ▁p ▁] ▁[ ▁0 ▁] ▁] ▁) ▁{ ▁bits ▁[ ▁i ▁] ▁-- ▁; ▁} ▁if ▁( ▁queries ▁[ ▁p ▁] ▁[ ▁1 ▁] ▁& ▁( ▁1 ▁<< ▁i ▁) ▁) ▁{ ▁bits ▁[ ▁i ▁] ▁++ ▁; ▁} ▁} ▁arr ▁[ ▁queries ▁[ ▁p ▁] ▁[ ▁0 ▁] ▁] ▁= ▁queries ▁[ ▁p ▁] ▁[ ▁1 ▁] ▁; ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁32 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁bits ▁[ ▁i ▁] ▁!= ▁0 ▁) ▁{ ▁ans ▁|= ▁( ▁1 ▁<< ▁i ▁) ▁; ▁} ▁} ▁c out ▁<< ▁ans ▁<< ▁end l ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁3 ▁, ▁q ▁= ▁2 ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁5 ▁, ▁7 ▁} ▁; ▁int ▁queries ▁[ ▁2 ▁] ▁[ ▁2 ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁} ▁, ▁{ ▁2 ▁, ▁1 ▁} ▁} ▁; ▁Or _ of _ And s _ for _ each _ query ▁( ▁arr ▁, ▁n ▁, ▁queries ▁, ▁q ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find max ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁tra v ▁, ▁i ▁; ▁int ▁c ▁= ▁0 ▁, ▁maximum ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁k ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁tra v ▁= ▁i ▁- ▁1 ▁; ▁c ▁= ▁0 ▁; ▁while ▁( ▁tra v ▁>= ▁0 ▁&& ▁arr ▁[ ▁tra v ▁] ▁== ▁1 ▁) ▁{ ▁tra v ▁-- ▁; ▁c ▁++ ▁; ▁} ▁tra v ▁= ▁i ▁+ ▁k ▁; ▁while ▁( ▁tra v ▁< ▁n ▁&& ▁arr ▁[ ▁tra v ▁] ▁== ▁1 ▁) ▁{ ▁tra v ▁++ ▁; ▁c ▁++ ▁; ▁} ▁c ▁+= ▁k ▁; ▁if ▁( ▁c ▁> ▁maximum ▁) ▁maximum ▁= ▁c ▁; ▁} ▁return ▁maximum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁k ▁= ▁3 ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁arr ▁/ ▁sizeof ▁arr ▁[ ▁0 ▁] ▁; ▁int ▁ans ▁= ▁find max ▁( ▁arr ▁, ▁n ▁, ▁k ▁) ▁; ▁c out ▁<< ▁ans ▁<< ▁' ▁' ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max And X or ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁ans ▁= ▁INT _ MAX ▁; ▁sort ▁( ▁arr ▁, ▁arr ▁+ ▁n ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁ans ▁= ▁min ▁( ▁ans ▁, ▁arr ▁[ ▁i ▁] ▁^ ▁arr ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁max And X or ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Sub array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁K ▁, ▁int ▁N ▁) ▁{ ▁if ▁( ▁K ▁% ▁2 ▁!= ▁0 ▁) ▁return ▁0 ▁; ▁if ▁( ▁N ▁< ▁K ▁) ▁return ▁0 ▁; ▁int ▁start ▁= ▁0 ▁; ▁int ▁i ▁= ▁0 ▁; ▁int ▁count ▁= ▁0 ▁; ▁int ▁curr X or ▁= ▁arr ▁[ ▁i ▁++ ▁] ▁; ▁while ▁( ▁i ▁< ▁K ▁) ▁{ ▁curr X or ▁^= ▁arr ▁[ ▁i ▁] ▁; ▁i ▁++ ▁; ▁} ▁if ▁( ▁curr X or ▁== ▁0 ▁) ▁count ▁++ ▁; ▁curr X or ▁^= ▁arr ▁[ ▁start ▁++ ▁] ▁; ▁while ▁( ▁i ▁< ▁N ▁) ▁{ ▁curr X or ▁^= ▁arr ▁[ ▁i ▁] ▁; ▁i ▁++ ▁; ▁if ▁( ▁curr X or ▁== ▁0 ▁) ▁count ▁++ ▁; ▁curr X or ▁^= ▁arr ▁[ ▁start ▁++ ▁] ▁; ▁} ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁4 ▁, ▁4 ▁, ▁2 ▁, ▁2 ▁, ▁4 ▁} ▁; ▁int ▁K ▁= ▁4 ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁( ▁count Sub array ▁( ▁arr ▁, ▁K ▁, ▁N ▁) ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁minimum F lips ▁( ▁int ▁X ▁, ▁int ▁Y ▁, ▁int ▁Z ▁) ▁{ ▁int ▁res ▁= ▁0 ▁; ▁while ▁( ▁X ▁> ▁0 ▁Y ▁> ▁0 ▁Z ▁> ▁0 ▁) ▁{ ▁if ▁( ▁( ▁( ▁X ▁& ▁1 ▁) ▁|| ▁( ▁Y ▁& ▁1 ▁) ▁) ▁&& ▁( ▁Z ▁& ▁1 ▁) ▁) ▁{ ▁X ▁= ▁X ▁>> ▁1 ▁; ▁Y ▁= ▁Y ▁>> ▁1 ▁; ▁Z ▁= ▁Z ▁>> ▁1 ▁; ▁continue ▁; ▁} ▁else ▁if ▁( ▁! ▁( ▁X ▁& ▁1 ▁) ▁&& ▁! ▁( ▁Y ▁& ▁1 ▁) ▁&& ▁( ▁Z ▁& ▁1 ▁) ▁) ▁{ ▁res ▁++ ▁; ▁} ▁else ▁if ▁( ▁( ▁X ▁& ▁1 ▁) ▁|| ▁( ▁Y ▁& ▁1 ▁) ▁== ▁1 ▁) ▁{ ▁if ▁( ▁( ▁X ▁& ▁1 ▁) ▁&& ▁( ▁Y ▁& ▁1 ▁) ▁&& ▁! ▁( ▁Z ▁& ▁1 ▁) ▁) ▁{ ▁res ▁+= ▁2 ▁; ▁} ▁else ▁if ▁( ▁( ▁( ▁X ▁& ▁1 ▁) ▁|| ▁( ▁Y ▁& ▁1 ▁) ▁) ▁&& ▁! ▁( ▁Z ▁& ▁1 ▁) ▁) ▁{ ▁res ▁++ ▁; ▁} ▁} ▁X ▁= ▁X ▁>> ▁1 ▁; ▁Y ▁= ▁Y ▁>> ▁1 ▁; ▁Z ▁= ▁Z ▁>> ▁1 ▁; ▁} ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁X ▁= ▁5 ▁, ▁Y ▁= ▁8 ▁, ▁Z ▁= ▁6 ▁; ▁c out ▁<< ▁minimum F lips ▁( ▁X ▁, ▁Y ▁, ▁Z ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁F lip Bits ▁( ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁bit ▁= ▁0 ▁; ▁bit ▁< ▁32 ▁; ▁bit ▁++ ▁) ▁{ ▁if ▁( ▁( ▁n ▁>> ▁bit ▁) ▁& ▁1 ▁) ▁{ ▁n ▁= ▁n ▁^ ▁( ▁1 ll ▁<< ▁bit ▁) ▁; ▁break ▁; ▁} ▁} ▁c out ▁<< ▁" ▁The ▁number ▁after ▁un setting ▁the ▁" ▁; ▁c out ▁<< ▁" ▁right most ▁set ▁bit ▁" ▁<< ▁n ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁12 ▁; ▁F lip Bits ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁bitwise And Odd ▁( ▁int ▁n ▁) ▁{ ▁int ▁result ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁3 ▁; ▁i ▁<= ▁n ▁; ▁i ▁= ▁i ▁+ ▁2 ▁) ▁{ ▁result ▁= ▁( ▁result ▁& ▁i ▁) ▁; ▁} ▁return ▁result ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁10 ▁; ▁c out ▁<< ▁bitwise And Odd ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁long ▁multiply By F if te en ▁( ▁long ▁n ▁) ▁{ ▁long ▁prod ▁= ▁( ▁n ▁<< ▁3 ▁) ▁; ▁prod ▁+= ▁( ▁n ▁<< ▁2 ▁) ▁; ▁prod ▁+= ▁( ▁n ▁<< ▁1 ▁) ▁; ▁prod ▁+= ▁n ▁; ▁return ▁prod ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁long ▁n ▁= ▁7 ▁; ▁c out ▁<< ▁multiply By F if te en ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count X ▁( ▁int ▁n ▁) ▁{ ▁string ▁binary ▁= ▁bit set ▁< ▁8 ▁> ▁( ▁n ▁) ▁. ▁to _ string ▁( ▁) ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁binary ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁binary ▁. ▁at ▁( ▁i ▁) ▁== ▁'1' ▁) ▁count ▁++ ▁; ▁} ▁int ▁answer ▁= ▁( ▁int ▁) ▁pow ▁( ▁2 ▁, ▁count ▁) ▁; ▁return ▁answer ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁5 ▁; ▁int ▁answer ▁= ▁count X ▁( ▁n ▁) ▁; ▁c out ▁<< ▁( ▁answer ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁alternate ▁( ▁int ▁& ▁a ▁, ▁int ▁& ▁b ▁, ▁int ▁& ▁x ▁) ▁{ ▁x ▁= ▁a ▁^ ▁b ▁^ ▁x ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁= ▁-10 ▁; ▁int ▁b ▁= ▁15 ▁; ▁int ▁x ▁= ▁a ▁; ▁c out ▁<< ▁" ▁x ▁is ▁: ▁" ▁<< ▁x ▁; ▁alternate ▁( ▁a ▁, ▁b ▁, ▁x ▁) ▁; ▁c out ▁<< ▁" ▁After ▁exchange ▁" ▁c out ▁<< ▁" ▁STRNEWLINE ▁x ▁is ▁: ▁" ▁<< ▁x ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁solve ▁( ▁int ▁A ▁, ▁int ▁B ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁32 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁( ▁A ▁>> ▁i ▁) ▁& ▁1 ▁) ▁!= ▁( ▁( ▁B ▁>> ▁i ▁) ▁& ▁1 ▁) ▁) ▁{ ▁count ▁++ ▁; ▁} ▁} ▁c out ▁<< ▁" ▁Number ▁of ▁different ▁bits ▁: ▁" ▁<< ▁count ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁= ▁12 ▁, ▁B ▁= ▁15 ▁; ▁solve ▁( ▁A ▁, ▁B ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁struct ▁Node ▁{ ▁int ▁data ▁; ▁struct ▁Node ▁* ▁left ▁, ▁* ▁right ▁; ▁} ▁; ▁Node ▁* ▁newNode ▁( ▁int ▁data ▁) ▁{ ▁Node ▁* ▁node ▁= ▁new ▁Node ▁; ▁node ▁-> ▁data ▁= ▁data ▁; ▁node ▁-> ▁left ▁= ▁node ▁-> ▁right ▁= ▁NULL ▁; ▁return ▁( ▁node ▁) ▁; ▁} ▁void ▁print Set Bit ▁( ▁Node ▁* ▁root ▁) ▁{ ▁if ▁( ▁root ▁== ▁NULL ▁) ▁return ▁; ▁c out ▁<< ▁" ▁Set ▁bits ▁in ▁Node ▁" ▁<< ▁root ▁-> ▁data ▁<< ▁" ▁= ▁" ▁<< ▁__ builtin _ pop count ▁( ▁root ▁-> ▁data ▁) ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁print Set Bit ▁( ▁root ▁-> ▁left ▁) ▁; ▁print Set Bit ▁( ▁root ▁-> ▁right ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁Node ▁* ▁root ▁= ▁newNode ▁( ▁16 ▁) ▁; ▁root ▁-> ▁left ▁= ▁newNode ▁( ▁13 ▁) ▁; ▁root ▁-> ▁left ▁-> ▁left ▁= ▁newNode ▁( ▁14 ▁) ▁; ▁root ▁-> ▁left ▁-> ▁right ▁= ▁newNode ▁( ▁12 ▁) ▁; ▁root ▁-> ▁right ▁= ▁newNode ▁( ▁11 ▁) ▁; ▁root ▁-> ▁right ▁-> ▁left ▁= ▁newNode ▁( ▁10 ▁) ▁; ▁root ▁-> ▁right ▁-> ▁right ▁= ▁newNode ▁( ▁16 ▁) ▁; ▁print Set Bit ▁( ▁root ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁Make Pre Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁presum ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁presum ▁[ ▁0 ▁] ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁presum ▁[ ▁i ▁] ▁= ▁presum ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁arr ▁[ ▁i ▁] ▁; ▁} ▁int ▁Binary L if ting ▁( ▁int ▁presum ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁x ▁) ▁{ ▁int ▁pos ▁= ▁0 ▁; ▁int ▁LOG N ▁= ▁log 2 ▁( ▁n ▁) ▁; ▁if ▁( ▁x ▁<= ▁presum ▁[ ▁0 ▁] ▁) ▁return ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁LOG N ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁pos ▁+ ▁( ▁1 ▁<< ▁i ▁) ▁< ▁n ▁&& ▁presum ▁[ ▁pos ▁+ ▁( ▁1 ▁<< ▁i ▁) ▁] ▁< ▁x ▁) ▁{ ▁pos ▁+= ▁( ▁1 ▁<< ▁i ▁) ▁; ▁} ▁} ▁return ▁pos ▁+ ▁1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁5 ▁, ▁7 ▁, ▁1 ▁, ▁6 ▁, ▁9 ▁, ▁12 ▁, ▁4 ▁, ▁6 ▁} ▁; ▁int ▁x ▁= ▁8 ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁presum ▁[ ▁n ▁] ▁= ▁{ ▁0 ▁} ▁; ▁Make Pre Sum ▁( ▁arr ▁, ▁presum ▁, ▁n ▁) ▁; ▁c out ▁<< ▁Binary L if ting ▁( ▁presum ▁, ▁n ▁, ▁x ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁all Bits Set In The Given Range ▁( ▁unsigned ▁int ▁n ▁, ▁unsigned ▁int ▁l ▁, ▁unsigned ▁int ▁r ▁) ▁{ ▁int ▁num ▁= ▁( ▁( ▁1 ▁<< ▁r ▁) ▁- ▁1 ▁) ▁^ ▁( ▁( ▁1 ▁<< ▁( ▁l ▁- ▁1 ▁) ▁) ▁- ▁1 ▁) ▁; ▁int ▁new _ num ▁= ▁n ▁& ▁num ▁; ▁if ▁( ▁new _ num ▁== ▁0 ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁unsigned ▁int ▁n ▁= ▁17 ▁; ▁unsigned ▁int ▁l ▁= ▁2 ▁, ▁r ▁= ▁4 ▁; ▁if ▁( ▁all Bits Set In The Given Range ▁( ▁n ▁, ▁l ▁, ▁r ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁only First And Last Are Set ▁( ▁unsigned ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁1 ▁) ▁return ▁true ▁; ▁if ▁( ▁n ▁== ▁2 ▁) ▁return ▁false ▁; ▁return ▁( ▁( ▁( ▁n ▁- ▁1 ▁) ▁& ▁( ▁n ▁- ▁2 ▁) ▁) ▁== ▁0 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁unsigned ▁int ▁n ▁= ▁9 ▁; ▁if ▁( ▁only First And Last Are Set ▁( ▁n ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁# define ▁ll ▁unsigned ▁int ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁ll ▁minimize ▁( ▁ll ▁a ▁) ▁{ ▁ll ▁n ▁= ▁_ pop cnt 32 ▁( ▁a ▁) ▁; ▁return ▁( ▁pow ▁( ▁2 ▁, ▁n ▁) ▁- ▁1 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁ll ▁a ▁= ▁11 ▁; ▁c out ▁<< ▁minimize ▁( ▁a ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁getM id ▁( ▁int ▁s ▁, ▁int ▁e ▁) ▁{ ▁return ▁s ▁+ ▁( ▁e ▁- ▁s ▁) ▁/ ▁2 ▁; ▁} ▁void ▁construct ST Util ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁ss ▁, ▁int ▁se ▁, ▁int ▁* ▁st ▁, ▁int ▁si ▁, ▁int ▁operation ▁) ▁{ ▁if ▁( ▁ss ▁== ▁se ▁) ▁{ ▁st ▁[ ▁si ▁] ▁= ▁arr ▁[ ▁ss ▁] ▁; ▁return ▁; ▁} ▁int ▁mid ▁= ▁getM id ▁( ▁ss ▁, ▁se ▁) ▁; ▁construct ST Util ▁( ▁arr ▁, ▁ss ▁, ▁mid ▁, ▁st ▁, ▁si ▁* ▁2 ▁+ ▁1 ▁, ▁! ▁operation ▁) ▁; ▁construct ST Util ▁( ▁arr ▁, ▁mid ▁+ ▁1 ▁, ▁se ▁, ▁st ▁, ▁si ▁* ▁2 ▁+ ▁2 ▁, ▁! ▁operation ▁) ▁; ▁if ▁( ▁operation ▁== ▁1 ▁) ▁{ ▁st ▁[ ▁si ▁] ▁= ▁( ▁st ▁[ ▁2 ▁* ▁si ▁+ ▁1 ▁] ▁st ▁[ ▁2 ▁* ▁si ▁+ ▁2 ▁] ▁) ▁; ▁} ▁else ▁{ ▁st ▁[ ▁si ▁] ▁= ▁( ▁st ▁[ ▁2 ▁* ▁si ▁+ ▁1 ▁] ▁^ ▁st ▁[ ▁2 ▁* ▁si ▁+ ▁2 ▁] ▁) ▁; ▁} ▁} ▁int ▁* ▁construct ST ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁x ▁= ▁( ▁int ▁) ▁( ▁ceil ▁( ▁log 2 ▁( ▁n ▁) ▁) ▁) ▁; ▁int ▁max _ size ▁= ▁2 ▁* ▁( ▁int ▁) ▁pow ▁( ▁2 ▁, ▁x ▁) ▁- ▁1 ▁; ▁int ▁* ▁st ▁= ▁new ▁int ▁[ ▁max _ size ▁] ▁; ▁int ▁operation At Root ▁= ▁( ▁x ▁% ▁2 ▁== ▁0 ▁? ▁0 ▁: ▁1 ▁) ▁; ▁construct ST Util ▁( ▁arr ▁, ▁0 ▁, ▁n ▁- ▁1 ▁, ▁st ▁, ▁0 ▁, ▁operation At Root ▁) ▁; ▁return ▁st ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁leaves ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁6 ▁, ▁3 ▁, ▁7 ▁, ▁5 ▁, ▁9 ▁, ▁10 ▁, ▁4 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁leaves ▁) ▁/ ▁sizeof ▁( ▁leaves ▁[ ▁0 ▁] ▁) ▁; ▁int ▁* ▁segment Tree ▁= ▁construct ST ▁( ▁leaves ▁, ▁n ▁) ▁; ▁int ▁root Index ▁= ▁0 ▁; ▁c out ▁<< ▁" ▁Value ▁at ▁Root ▁Node ▁= ▁" ▁<< ▁segment Tree ▁[ ▁root Index ▁] ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁isF ib binary Num ▁( ▁unsigned ▁int ▁n ▁) ▁{ ▁if ▁( ▁( ▁n ▁& ▁( ▁n ▁>> ▁1 ▁) ▁) ▁== ▁0 ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁unsigned ▁int ▁n ▁= ▁10 ▁; ▁if ▁( ▁isF ib binary Num ▁( ▁n ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁divide ▁( ▁long ▁long ▁div id end ▁, ▁long ▁long ▁divisor ▁) ▁{ ▁int ▁sign ▁= ▁( ▁( ▁div id end ▁< ▁0 ▁) ▁^ ▁( ▁divisor ▁< ▁0 ▁) ▁) ▁? ▁-1 ▁: ▁1 ▁; ▁div id end ▁= ▁abs ▁( ▁div id end ▁) ▁; ▁divisor ▁= ▁abs ▁( ▁divisor ▁) ▁; ▁long ▁long ▁quot ient ▁= ▁0 ▁, ▁temp ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁31 ▁; ▁i ▁>= ▁0 ▁; ▁-- ▁i ▁) ▁{ ▁if ▁( ▁temp ▁+ ▁( ▁divisor ▁<< ▁i ▁) ▁<= ▁div id end ▁) ▁{ ▁temp ▁+= ▁divisor ▁<< ▁i ▁; ▁quot ient ▁|= ▁1 LL ▁<< ▁i ▁; ▁} ▁} ▁if ▁( ▁sign ▁== ▁-1 ▁) ▁quot ient ▁= ▁- ▁quot ient ▁; ▁return ▁quot ient ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁= ▁10 ▁, ▁b ▁= ▁3 ▁; ▁c out ▁<< ▁divide ▁( ▁a ▁, ▁b ▁) ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁a ▁= ▁43 ▁, ▁b ▁= ▁- 8 ▁; ▁c out ▁<< ▁divide ▁( ▁a ▁, ▁b ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max AND ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁res ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁res ▁= ▁max ▁( ▁res ▁, ▁arr ▁[ ▁i ▁] ▁& ▁arr ▁[ ▁j ▁] ▁) ▁; ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁8 ▁, ▁6 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁Maximum ▁AND ▁Value ▁= ▁" ▁<< ▁max AND ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁setAll Bits After MS B ▁( ▁int ▁n ▁) ▁{ ▁n ▁|= ▁n ▁>> ▁1 ▁; ▁n ▁|= ▁n ▁>> ▁2 ▁; ▁n ▁|= ▁n ▁>> ▁4 ▁; ▁n ▁|= ▁n ▁>> ▁8 ▁; ▁n ▁|= ▁n ▁>> ▁16 ▁; ▁return ▁n ▁; ▁} ▁void ▁toggle ▁( ▁int ▁& ▁n ▁) ▁{ ▁n ▁= ▁n ▁^ ▁setAll Bits After MS B ▁( ▁n ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁10 ▁; ▁toggle ▁( ▁n ▁) ▁; ▁c out ▁<< ▁n ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁construct N th Number ▁( ▁int ▁group _ no ▁, ▁int ▁aux _ num ▁, ▁int ▁op ▁) ▁{ ▁int ▁INT _ SIZE ▁= ▁32 ▁; ▁int ▁a ▁[ ▁INT _ SIZE ▁] ▁= ▁{ ▁0 ▁} ▁; ▁int ▁num ▁= ▁0 ▁, ▁len _ f ▁; ▁int ▁i ▁= ▁0 ▁; ▁if ▁( ▁op ▁== ▁2 ▁) ▁{ ▁len _ f ▁= ▁2 ▁* ▁group _ no ▁; ▁a ▁[ ▁len _ f ▁- ▁1 ▁] ▁= ▁a ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁while ▁( ▁aux _ num ▁) ▁{ ▁a ▁[ ▁group _ no ▁+ ▁i ▁] ▁= ▁a ▁[ ▁group _ no ▁- ▁1 ▁- ▁i ▁] ▁= ▁aux _ num ▁& ▁1 ▁; ▁aux _ num ▁= ▁aux _ num ▁>> ▁1 ▁; ▁i ▁++ ▁; ▁} ▁} ▁else ▁if ▁( ▁op ▁== ▁0 ▁) ▁{ ▁len _ f ▁= ▁2 ▁* ▁group _ no ▁+ ▁1 ▁; ▁a ▁[ ▁len _ f ▁- ▁1 ▁] ▁= ▁a ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁a ▁[ ▁group _ no ▁] ▁= ▁0 ▁; ▁while ▁( ▁aux _ num ▁) ▁{ ▁a ▁[ ▁group _ no ▁+ ▁1 ▁+ ▁i ▁] ▁= ▁a ▁[ ▁group _ no ▁- ▁1 ▁- ▁i ▁] ▁= ▁aux _ num ▁& ▁1 ▁; ▁aux _ num ▁= ▁aux _ num ▁>> ▁1 ▁; ▁i ▁++ ▁; ▁} ▁} ▁else ▁{ ▁len _ f ▁= ▁2 ▁* ▁group _ no ▁+ ▁1 ▁; ▁a ▁[ ▁len _ f ▁- ▁1 ▁] ▁= ▁a ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁a ▁[ ▁group _ no ▁] ▁= ▁1 ▁; ▁while ▁( ▁aux _ num ▁) ▁{ ▁a ▁[ ▁group _ no ▁+ ▁1 ▁+ ▁i ▁] ▁= ▁a ▁[ ▁group _ no ▁- ▁1 ▁- ▁i ▁] ▁= ▁aux _ num ▁& ▁1 ▁; ▁aux _ num ▁= ▁aux _ num ▁>> ▁1 ▁; ▁i ▁++ ▁; ▁} ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁len _ f ▁; ▁i ▁++ ▁) ▁num ▁+= ▁( ▁1 ▁<< ▁i ▁) ▁* ▁a ▁[ ▁i ▁] ▁; ▁return ▁num ▁; ▁} ▁int ▁getN th Number ▁( ▁int ▁n ▁) ▁{ ▁int ▁group _ no ▁= ▁0 ▁, ▁group _ offset ▁; ▁int ▁count _
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁unsigned ▁int ▁toggle Last MB its ▁( ▁unsigned ▁int ▁n ▁, ▁unsigned ▁int ▁m ▁) ▁{ ▁unsigned ▁int ▁num ▁= ▁( ▁1 ▁<< ▁m ▁) ▁- ▁1 ▁; ▁return ▁( ▁n ▁^ ▁num ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁unsigned ▁int ▁n ▁= ▁107 ▁; ▁unsigned ▁int ▁m ▁= ▁4 ▁; ▁c out ▁<< ▁toggle Last MB its ▁( ▁n ▁, ▁m ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁xor Pair Count ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁x ▁) ▁{ ▁unordered _ map ▁< ▁int ▁, ▁int ▁> ▁m ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁curr _ xor ▁= ▁x ▁^ ▁arr ▁[ ▁i ▁] ▁; ▁if ▁( ▁m ▁. ▁find ▁( ▁curr _ xor ▁) ▁!= ▁m ▁. ▁end ▁( ▁) ▁) ▁result ▁+= ▁m ▁[ ▁curr _ xor ▁] ▁; ▁m ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁++ ▁; ▁} ▁return ▁result ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁5 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁x ▁= ▁0 ▁; ▁c out ▁<< ▁" ▁Count ▁of ▁pairs ▁with ▁given ▁XOR ▁= ▁" ▁<< ▁xor Pair Count ▁( ▁arr ▁, ▁n ▁, ▁x ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁maxLength ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁max Len ▁= ▁0 ▁; ▁int ▁i ▁= ▁0 ▁; ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁while ▁( ▁j ▁< ▁n ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁!= ▁arr ▁[ ▁j ▁] ▁) ▁{ ▁max Len ▁= ▁max ▁( ▁max Len ▁, ▁2 ▁) ▁; ▁int ▁l ▁= ▁i ▁- ▁1 ▁; ▁int ▁r ▁= ▁j ▁+ ▁1 ▁; ▁while ▁( ▁l ▁>= ▁0 ▁&& ▁r ▁< ▁n ▁&& ▁arr ▁[ ▁l ▁] ▁== ▁arr ▁[ ▁i ▁] ▁&& ▁arr ▁[ ▁r ▁] ▁== ▁arr ▁[ ▁j ▁] ▁) ▁{ ▁l ▁-- ▁; ▁r ▁++ ▁; ▁} ▁max Len ▁= ▁max ▁( ▁max Len ▁, ▁2 ▁* ▁( ▁r ▁- ▁j ▁) ▁) ▁; ▁} ▁i ▁++ ▁; ▁j ▁= ▁i ▁+ ▁1 ▁; ▁} ▁return ▁max Len ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁maxLength ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁min Digits ▁( ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁int ▁digits _ num ▁= ▁floor ▁( ▁log 10 ▁( ▁N ▁) ▁+ ▁1 ▁) ▁; ▁int ▁temp _ sum ▁= ▁0 ▁; ▁int ▁temp ▁= ▁digits _ num ▁; ▁int ▁result ▁; ▁int ▁X ▁, ▁var ▁; ▁int ▁sum ▁= ▁0 ▁; ▁int ▁num 2 ▁= ▁N ▁; ▁while ▁( ▁num 2 ▁!= ▁0 ▁) ▁{ ▁sum ▁+= ▁num 2 ▁% ▁10 ▁; ▁num 2 ▁/= ▁10 ▁; ▁} ▁if ▁( ▁sum ▁<= ▁K ▁) ▁{ ▁X ▁= ▁0 ▁; ▁} ▁else ▁{ ▁while ▁( ▁temp ▁> ▁0 ▁) ▁{ ▁var ▁= ▁( ▁N ▁/ ▁( ▁pow ▁( ▁10 ▁, ▁temp ▁- ▁1 ▁) ▁) ▁) ▁; ▁temp _ sum ▁+= ▁var ▁% ▁10 ▁; ▁if ▁( ▁temp _ sum ▁>= ▁K ▁) ▁{ ▁var ▁/= ▁10 ▁; ▁var ▁++ ▁; ▁result ▁= ▁var ▁* ▁pow ▁( ▁10 ▁, ▁temp ▁) ▁; ▁break ▁; ▁} ▁temp ▁-- ▁; ▁} ▁X ▁= ▁result ▁- ▁N ▁; ▁return ▁X ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁11 ▁, ▁K ▁= ▁1 ▁; ▁c out ▁<< ▁min Digits ▁( ▁N ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁upperBound ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁int ▁l ▁= ▁0 ▁; ▁int ▁r ▁= ▁N ▁; ▁while ▁( ▁l ▁< ▁r ▁) ▁{ ▁int ▁mid ▁= ▁( ▁l ▁+ ▁r ▁) ▁/ ▁2 ▁; ▁if ▁( ▁arr ▁[ ▁mid ▁] ▁<= ▁K ▁) ▁{ ▁l ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁else ▁{ ▁r ▁= ▁mid ▁; ▁} ▁} ▁return ▁l ▁; ▁} ▁void ▁N Div K With Freq ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁sort ▁( ▁arr ▁, ▁arr ▁+ ▁N ▁) ▁; ▁int ▁i ▁= ▁0 ▁; ▁while ▁( ▁i ▁< ▁N ▁) ▁{ ▁int ▁X ▁= ▁upperBound ▁( ▁arr ▁, ▁N ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁if ▁( ▁( ▁X ▁- ▁i ▁) ▁> ▁N ▁/ ▁4 ▁) ▁{ ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁} ▁i ▁= ▁X ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁2 ▁, ▁6 ▁, ▁6 ▁, ▁6 ▁, ▁6 ▁, ▁7 ▁, ▁10 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁K ▁= ▁4 ▁; ▁N Div K With Freq ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁float ▁getMax Medi an ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁size ▁= ▁n ▁+ ▁k ▁; ▁sort ▁( ▁arr ▁, ▁arr ▁+ ▁n ▁) ▁; ▁if ▁( ▁size ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁float ▁median ▁= ▁( ▁float ▁) ▁( ▁arr ▁[ ▁( ▁size ▁/ ▁2 ▁) ▁- ▁1 ▁] ▁+ ▁arr ▁[ ▁size ▁/ ▁2 ▁] ▁) ▁/ ▁2 ▁; ▁return ▁median ▁; ▁} ▁float ▁median ▁= ▁arr ▁[ ▁size ▁/ ▁2 ▁] ▁; ▁return ▁median ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁k ▁= ▁2 ▁; ▁c out ▁<< ▁getMax Medi an ▁( ▁arr ▁, ▁n ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< c string > ▁NEW _ LINE ▁# include ▁< i ost ream > ▁NEW _ LINE ▁# include ▁< string > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# ▁define ▁MAX ▁26 ▁NEW _ LINE ▁bool ▁function ▁( ▁string ▁str ▁) ▁{ ▁int ▁l ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁int ▁counter ▁[ ▁MAX ▁] ▁; ▁mem set ▁( ▁counter ▁, ▁0 ▁, ▁sizeof ▁( ▁counter ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁l ▁/ ▁2 ▁; ▁i ▁++ ▁) ▁counter ▁[ ▁str ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁for ▁( ▁int ▁i ▁= ▁l ▁/ ▁2 ▁; ▁i ▁< ▁l ▁; ▁i ▁++ ▁) ▁counter ▁[ ▁str ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁] ▁-- ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁MAX ▁; ▁i ▁++ ▁) ▁if ▁( ▁counter ▁[ ▁i ▁] ▁!= ▁0 ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁abc as ds ab ca e ▁" ▁; ▁if ▁( ▁function ▁( ▁str ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁, ▁both ▁hal ves ▁differ ▁" ▁<< ▁" ▁by ▁at ▁least ▁one ▁character ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁, ▁both ▁hal ves ▁do ▁" ▁<< ▁" ▁not ▁differ ▁at ▁all ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print Sorted ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁int ▁c ▁) ▁{ ▁int ▁get _ max ▁= ▁max ▁( ▁a ▁, ▁max ▁( ▁b ▁, ▁c ▁) ▁) ▁; ▁int ▁get _ min ▁= ▁- ▁max ▁( ▁- ▁a ▁, ▁max ▁( ▁- ▁b ▁, ▁- ▁c ▁) ▁) ▁; ▁int ▁get _ mid ▁= ▁( ▁a ▁+ ▁b ▁+ ▁c ▁) ▁- ▁( ▁get _ max ▁+ ▁get _ min ▁) ▁; ▁c out ▁<< ▁get _ min ▁<< ▁" ▁" ▁<< ▁get _ mid ▁<< ▁" ▁" ▁<< ▁get _ max ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁= ▁4 ▁, ▁b ▁= ▁1 ▁, ▁c ▁= ▁9 ▁; ▁print Sorted ▁( ▁a ▁, ▁b ▁, ▁c ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁insertion Sort ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁i ▁, ▁key ▁, ▁j ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁key ▁= ▁arr ▁[ ▁i ▁] ▁; ▁j ▁= ▁i ▁- ▁1 ▁; ▁while ▁( ▁j ▁>= ▁0 ▁&& ▁arr ▁[ ▁j ▁] ▁> ▁key ▁) ▁{ ▁arr ▁[ ▁j ▁+ ▁1 ▁] ▁= ▁arr ▁[ ▁j ▁] ▁; ▁j ▁= ▁j ▁- ▁1 ▁; ▁} ▁arr ▁[ ▁j ▁+ ▁1 ▁] ▁= ▁key ▁; ▁} ▁} ▁void ▁print Array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁c out ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁12 ▁, ▁11 ▁, ▁13 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁insertion Sort ▁( ▁arr ▁, ▁n ▁) ▁; ▁print Array ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max Num Pal indrome ▁( ▁string ▁S ▁) ▁{ ▁int ▁i ▁= ▁0 ▁; ▁int ▁freq ▁[ ▁26 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁int ▁freq Pair ▁= ▁0 ▁; ▁int ▁len ▁= ▁S ▁. ▁length ▁( ▁) ▁/ ▁3 ▁; ▁while ▁( ▁i ▁< ▁S ▁. ▁length ▁( ▁) ▁) ▁{ ▁freq ▁[ ▁S ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁i ▁++ ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁26 ▁; ▁i ▁++ ▁) ▁{ ▁freq Pair ▁+= ▁( ▁freq ▁[ ▁i ▁] ▁/ ▁2 ▁) ▁; ▁} ▁return ▁min ▁( ▁freq Pair ▁, ▁len ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁S ▁= ▁" ▁g eek s for g ▁" ▁; ▁c out ▁<< ▁max Num Pal indrome ▁( ▁S ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁height ▁( ▁int ▁s ▁, ▁vector ▁< ▁int ▁> ▁adj ▁[ ▁] ▁, ▁int ▁* ▁visited ▁) ▁{ ▁visited ▁[ ▁s ▁] ▁= ▁1 ▁; ▁int ▁h ▁= ▁0 ▁; ▁for ▁( ▁auto ▁& ▁child ▁: ▁adj ▁[ ▁s ▁] ▁) ▁{ ▁if ▁( ▁visited ▁[ ▁child ▁] ▁== ▁0 ▁) ▁{ ▁h ▁= ▁max ▁( ▁h ▁, ▁1 ▁+ ▁height ▁( ▁child ▁, ▁adj ▁, ▁visited ▁) ▁) ▁; ▁} ▁} ▁return ▁h ▁; ▁} ▁int ▁minimum Groups ▁( ▁vector ▁< ▁int ▁> ▁adj ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁visited ▁[ ▁N ▁+ ▁1 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁int ▁groups ▁= ▁INT _ MIN ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁visited ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁int ▁com Height ▁; ▁com Height ▁= ▁height ▁( ▁i ▁, ▁adj ▁, ▁visited ▁) ▁; ▁groups ▁= ▁max ▁( ▁groups ▁, ▁com Height ▁) ▁; ▁} ▁} ▁return ▁groups ▁; ▁} ▁void ▁addEdge ▁( ▁vector ▁< ▁int ▁> ▁adj ▁[ ▁] ▁, ▁int ▁u ▁, ▁int ▁v ▁) ▁{ ▁adj ▁[ ▁u ▁] ▁. ▁push _ back ▁( ▁v ▁) ▁; ▁adj ▁[ ▁v ▁] ▁. ▁push _ back ▁( ▁u ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁5 ▁; ▁vector ▁< ▁int ▁> ▁adj ▁[ ▁N ▁+ ▁1 ▁] ▁; ▁addEdge ▁( ▁adj ▁, ▁1 ▁, ▁2 ▁) ▁; ▁addEdge ▁( ▁adj ▁, ▁3 ▁, ▁2 ▁) ▁; ▁addEdge ▁( ▁adj ▁, ▁4 ▁, ▁3 ▁) ▁; ▁c out ▁<< ▁minimum Groups ▁( ▁adj ▁, ▁N ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find _ sum ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁total _ sum ▁= ▁( ▁n ▁* ▁( ▁n ▁+ ▁1 ▁) ▁) ▁/ ▁2 ▁; ▁int ▁power ▁= ▁k ▁; ▁while ▁( ▁power ▁<= ▁n ▁) ▁{ ▁total _ sum ▁-= ▁power ▁; ▁power ▁*= ▁k ▁; ▁} ▁return ▁total _ sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁11 ▁, ▁k ▁= ▁2 ▁; ▁c out ▁<< ▁find _ sum ▁( ▁n ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁R ▁3 ▁NEW _ LINE ▁# define ▁C ▁3 ▁NEW _ LINE ▁int ▁min ▁( ▁int ▁x ▁, ▁int ▁y ▁, ▁int ▁z ▁) ▁; ▁int ▁min Cost ▁( ▁int ▁cost ▁[ ▁R ▁] ▁[ ▁C ▁] ▁, ▁int ▁m ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁< ▁0 ▁m ▁< ▁0 ▁) ▁return ▁INT _ MAX ▁; ▁else ▁if ▁( ▁m ▁== ▁0 ▁&& ▁n ▁== ▁0 ▁) ▁return ▁cost ▁[ ▁m ▁] ▁[ ▁n ▁] ▁; ▁else ▁return ▁cost ▁[ ▁m ▁] ▁[ ▁n ▁] ▁+ ▁min ▁( ▁min Cost ▁( ▁cost ▁, ▁m ▁- ▁1 ▁, ▁n ▁- ▁1 ▁) ▁, ▁min Cost ▁( ▁cost ▁, ▁m ▁- ▁1 ▁, ▁n ▁) ▁, ▁min Cost ▁( ▁cost ▁, ▁m ▁, ▁n ▁- ▁1 ▁) ▁) ▁; ▁} ▁int ▁min ▁( ▁int ▁x ▁, ▁int ▁y ▁, ▁int ▁z ▁) ▁{ ▁if ▁( ▁x ▁< ▁y ▁) ▁return ▁( ▁x ▁< ▁z ▁) ▁? ▁x ▁: ▁z ▁; ▁else ▁return ▁( ▁y ▁< ▁z ▁) ▁? ▁y ▁: ▁z ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁cost ▁[ ▁R ▁] ▁[ ▁C ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁, ▁{ ▁4 ▁, ▁8 ▁, ▁2 ▁} ▁, ▁{ ▁1 ▁, ▁5 ▁, ▁3 ▁} ▁} ▁; ▁c out ▁<< ▁min Cost ▁( ▁cost ▁, ▁2 ▁, ▁2 ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁count Small er ▁( ▁string ▁str ▁) ▁{ ▁int ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁int ▁arr ▁[ ▁26 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁int ▁ans ▁[ ▁n ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁arr ▁[ ▁str ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁int ▁ct ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁str ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁; ▁j ▁++ ▁) ▁{ ▁ct ▁+= ▁arr ▁[ ▁j ▁] ▁; ▁} ▁ans ▁[ ▁i ▁] ▁= ▁ct ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁c out ▁<< ▁ans ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁ed cb aa ▁" ▁; ▁count Small er ▁( ▁str ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁string ▁process Words ▁( ▁char ▁* ▁input ▁) ▁{ ▁char ▁* ▁p ▁; ▁vector ▁< ▁string ▁> ▁s ▁; ▁p ▁= ▁str tok ▁( ▁input ▁, ▁" ▁" ▁) ▁; ▁while ▁( ▁p ▁!= ▁NULL ▁) ▁{ ▁s ▁. ▁push _ back ▁( ▁p ▁) ▁; ▁p ▁= ▁str tok ▁( ▁NULL ▁, ▁" ▁" ▁) ▁; ▁} ▁string ▁char Buffer ▁; ▁for ▁( ▁string ▁values ▁: ▁s ▁) ▁char Buffer ▁+= ▁values ▁[ ▁0 ▁] ▁; ▁return ▁char Buffer ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁char ▁input ▁[ ▁] ▁= ▁" ▁g eek s ▁for ▁g eek s ▁" ▁; ▁c out ▁<< ▁process Words ▁( ▁input ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁# include ▁< string > ▁NEW _ LINE ▁# include ▁< vector > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁generate Gray arr ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁<= ▁0 ▁) ▁return ▁; ▁vector ▁< ▁string ▁> ▁arr ▁; ▁arr ▁. ▁push _ back ▁( ▁"0" ▁) ▁; ▁arr ▁. ▁push _ back ▁( ▁"1" ▁) ▁; ▁int ▁i ▁, ▁j ▁; ▁for ▁( ▁i ▁= ▁2 ▁; ▁i ▁< ▁( ▁1 ▁<< ▁n ▁) ▁; ▁i ▁= ▁i ▁<< ▁1 ▁) ▁{ ▁for ▁( ▁j ▁= ▁i ▁- ▁1 ▁; ▁j ▁>= ▁0 ▁; ▁j ▁-- ▁) ▁arr ▁. ▁push _ back ▁( ▁arr ▁[ ▁j ▁] ▁) ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁i ▁; ▁j ▁++ ▁) ▁arr ▁[ ▁j ▁] ▁= ▁"0" ▁+ ▁arr ▁[ ▁j ▁] ▁; ▁for ▁( ▁j ▁= ▁i ▁; ▁j ▁< ▁2 ▁* ▁i ▁; ▁j ▁++ ▁) ▁arr ▁[ ▁j ▁] ▁= ▁"1" ▁+ ▁arr ▁[ ▁j ▁] ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁arr ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁generate Gray arr ▁( ▁3 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁# define ▁MAX ▁5 ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is Safe ▁( ▁int ▁row ▁, ▁int ▁col ▁, ▁int ▁m ▁[ ▁] ▁[ ▁MAX ▁] ▁, ▁int ▁n ▁, ▁bool ▁visited ▁[ ▁] ▁[ ▁MAX ▁] ▁) ▁{ ▁if ▁( ▁row ▁== ▁-1 ▁row ▁== ▁n ▁col ▁== ▁-1 ▁col ▁== ▁n ▁visited ▁[ ▁row ▁] ▁[ ▁col ▁] ▁m ▁[ ▁row ▁] ▁[ ▁col ▁] ▁== ▁0 ▁) ▁return ▁false ▁; ▁return ▁true ▁; ▁} ▁void ▁print Path Util ▁( ▁int ▁row ▁, ▁int ▁col ▁, ▁int ▁m ▁[ ▁] ▁[ ▁MAX ▁] ▁, ▁int ▁n ▁, ▁string ▁& ▁path ▁, ▁vector ▁< ▁string ▁> ▁& ▁possible Paths ▁, ▁bool ▁visited ▁[ ▁] ▁[ ▁MAX ▁] ▁) ▁{ ▁if ▁( ▁row ▁== ▁-1 ▁row ▁== ▁n ▁col ▁== ▁-1 ▁col ▁== ▁n ▁visited ▁[ ▁row ▁] ▁[ ▁col ▁] ▁m ▁[ ▁row ▁] ▁[ ▁col ▁] ▁== ▁0 ▁) ▁return ▁; ▁if ▁( ▁row ▁== ▁n ▁- ▁1 ▁&& ▁col ▁== ▁n ▁- ▁1 ▁) ▁{ ▁possible Paths ▁. ▁push _ back ▁( ▁path ▁) ▁; ▁return ▁; ▁} ▁visited ▁[ ▁row ▁] ▁[ ▁col ▁] ▁= ▁true ▁; ▁if ▁( ▁is Safe ▁( ▁row ▁+ ▁1 ▁, ▁col ▁, ▁m ▁, ▁n ▁, ▁visited ▁) ▁) ▁{ ▁path ▁. ▁push _ back ▁( ▁' ▁D ▁' ▁) ▁; ▁print Path Util ▁( ▁row ▁+ ▁1 ▁, ▁col ▁, ▁m ▁, ▁n ▁, ▁path ▁, ▁possible Paths ▁, ▁visited ▁) ▁; ▁path ▁. ▁pop _ back ▁( ▁) ▁; ▁} ▁if ▁( ▁is Safe ▁( ▁row ▁, ▁col ▁- ▁1 ▁, ▁m ▁, ▁n ▁, ▁visited ▁) ▁) ▁{ ▁path ▁. ▁push _ back ▁( ▁' ▁L ▁' ▁) ▁; ▁print Path Util ▁( ▁row ▁, ▁col ▁- ▁1 ▁, ▁m ▁, ▁n ▁, ▁path ▁, ▁possible Paths ▁, ▁visited ▁) ▁; ▁path ▁. ▁pop _ back ▁( ▁) ▁; ▁} ▁if ▁( ▁is Safe ▁( ▁row ▁, ▁col ▁+ ▁1 ▁, ▁m ▁, ▁n ▁, ▁visited ▁) ▁) ▁{ ▁path ▁. ▁push _ back ▁( ▁' ▁R ▁' ▁) ▁; ▁print Path Util ▁( ▁row ▁, ▁col ▁+ ▁1 ▁, ▁m ▁, ▁n ▁, ▁path ▁, ▁possible Paths ▁, ▁visited ▁) ▁; ▁path ▁. ▁pop _ back ▁( ▁) ▁; ▁} ▁if ▁( ▁is Safe ▁( ▁row ▁- ▁1 ▁, ▁col ▁,
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Direct Path ▁( ▁int ▁N ▁) ▁{ ▁return ▁N ▁+ ▁( ▁N ▁* ▁( ▁N ▁- ▁3 ▁) ▁) ▁/ ▁2 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁5 ▁; ▁c out ▁<< ▁count Direct Path ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁checkpoint ▁( ▁int ▁h ▁, ▁int ▁k ▁, ▁int ▁x ▁, ▁int ▁y ▁, ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁int ▁p ▁= ▁( ▁pow ▁( ▁( ▁x ▁- ▁h ▁) ▁, ▁2 ▁) ▁/ ▁pow ▁( ▁a ▁, ▁2 ▁) ▁) ▁+ ▁( ▁pow ▁( ▁( ▁y ▁- ▁k ▁) ▁, ▁2 ▁) ▁/ ▁pow ▁( ▁b ▁, ▁2 ▁) ▁) ▁; ▁return ▁p ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁h ▁= ▁0 ▁, ▁k ▁= ▁0 ▁, ▁x ▁= ▁2 ▁, ▁y ▁= ▁1 ▁, ▁a ▁= ▁4 ▁, ▁b ▁= ▁5 ▁; ▁if ▁( ▁checkpoint ▁( ▁h ▁, ▁k ▁, ▁x ▁, ▁y ▁, ▁a ▁, ▁b ▁) ▁> ▁1 ▁) ▁c out ▁<< ▁" ▁Out side ▁" ▁<< ▁end l ▁; ▁else ▁if ▁( ▁checkpoint ▁( ▁h ▁, ▁k ▁, ▁x ▁, ▁y ▁, ▁a ▁, ▁b ▁) ▁== ▁1 ▁) ▁c out ▁<< ▁" ▁On ▁the ▁ellipse ▁" ▁<< ▁end l ▁; ▁else ▁c out ▁<< ▁" ▁Inside ▁" ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁center ▁( ▁int ▁x 1 ▁, ▁int ▁x 2 ▁, ▁int ▁y 1 ▁, ▁int ▁y 2 ▁) ▁{ ▁c out ▁<< ▁( ▁float ▁) ▁( ▁x 1 ▁+ ▁x 2 ▁) ▁/ ▁2 ▁<< ▁" ▁, ▁" ▁<< ▁( ▁float ▁) ▁( ▁y 1 ▁+ ▁y 2 ▁) ▁/ ▁2 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁x 1 ▁= ▁-9 ▁, ▁y 1 ▁= ▁3 ▁, ▁x 2 ▁= ▁5 ▁, ▁y 2 ▁= ▁- 7 ▁; ▁center ▁( ▁x 1 ▁, ▁x 2 ▁, ▁y 1 ▁, ▁y 2 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁double ▁Area ▁( ▁int ▁b 1 ▁, ▁int ▁b 2 ▁, ▁int ▁h ▁) ▁{ ▁return ▁( ▁( ▁b 1 ▁+ ▁b 2 ▁) ▁/ ▁2 ▁) ▁* ▁h ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁base 1 ▁= ▁8 ▁, ▁base 2 ▁= ▁10 ▁, ▁height ▁= ▁6 ▁; ▁double ▁area ▁= ▁Area ▁( ▁base 1 ▁, ▁base 2 ▁, ▁height ▁) ▁; ▁c out ▁<< ▁" ▁Area ▁is ▁: ▁" ▁<< ▁area ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁double ▁area Cube ▁( ▁double ▁a ▁) ▁{ ▁return ▁( ▁a ▁* ▁a ▁* ▁a ▁) ▁; ▁} ▁double ▁surface Cube ▁( ▁double ▁a ▁) ▁{ ▁return ▁( ▁6 ▁* ▁a ▁* ▁a ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁double ▁a ▁= ▁5 ▁; ▁c out ▁<< ▁" ▁Area ▁= ▁" ▁<< ▁area Cube ▁( ▁a ▁) ▁<< ▁end l ▁; ▁c out ▁<< ▁" ▁Total ▁surface ▁area ▁= ▁" ▁<< ▁surface Cube ▁( ▁a ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁pair ▁< ▁double ▁, ▁double ▁> ▁mirror Image ▁( ▁double ▁a ▁, ▁double ▁b ▁, ▁double ▁c ▁, ▁double ▁x 1 ▁, ▁double ▁y 1 ▁) ▁{ ▁double ▁temp ▁= ▁-2 ▁* ▁( ▁a ▁* ▁x 1 ▁+ ▁b ▁* ▁y 1 ▁+ ▁c ▁) ▁/ ▁( ▁a ▁* ▁a ▁+ ▁b ▁* ▁b ▁) ▁; ▁double ▁x ▁= ▁temp ▁* ▁a ▁+ ▁x 1 ▁; ▁double ▁y ▁= ▁temp ▁* ▁b ▁+ ▁y 1 ▁; ▁return ▁make _ pair ▁( ▁x ▁, ▁y ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁double ▁a ▁= ▁- 1.0 ▁; ▁double ▁b ▁= ▁1.0 ▁; ▁double ▁c ▁= ▁0.0 ▁; ▁double ▁x 1 ▁= ▁1.0 ▁; ▁double ▁y 1 ▁= ▁0.0 ▁; ▁pair ▁< ▁double ▁, ▁double ▁> ▁image ▁= ▁mirror Image ▁( ▁a ▁, ▁b ▁, ▁c ▁, ▁x 1 ▁, ▁y 1 ▁) ▁; ▁c out ▁<< ▁" ▁Image ▁of ▁point ▁( ▁" ▁<< ▁x 1 ▁<< ▁" ▁, ▁" ▁<< ▁y 1 ▁<< ▁" ▁) ▁" ▁; ▁c out ▁<< ▁" ▁by ▁mirror ▁( ▁" ▁<< ▁a ▁<< ▁" ▁) ▁x ▁+ ▁( ▁" ▁<< ▁b ▁<< ▁" ▁) ▁y ▁+ ▁( ▁" ▁<< ▁c ▁<< ▁" ▁) ▁= ▁0 ▁, ▁is ▁: ▁" ▁; ▁c out ▁<< ▁" ▁( ▁" ▁<< ▁image ▁. ▁first ▁<< ▁" ▁, ▁" ▁<< ▁image ▁. ▁second ▁<< ▁" ▁) ▁" ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁fact ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁1 ▁n ▁== ▁0 ▁) ▁return ▁1 ▁; ▁else ▁return ▁n ▁* ▁fact ▁( ▁n ▁- ▁1 ▁) ▁; ▁} ▁int ▁find Value ▁( ▁int ▁n ▁, ▁int ▁r ▁, ▁int ▁a ▁) ▁{ ▁int ▁k ▁= ▁( ▁a ▁- ▁1 ▁) ▁/ ▁fact ▁( ▁n ▁) ▁; ▁int ▁answer ▁= ▁k ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁answer ▁= ▁answer ▁* ▁( ▁n ▁+ ▁r ▁- ▁i ▁) ▁; ▁answer ▁= ▁answer ▁+ ▁1 ▁; ▁return ▁answer ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁1 ▁; ▁int ▁A ▁= ▁2 ▁; ▁int ▁R ▁= ▁3 ▁; ▁c out ▁<< ▁( ▁find Value ▁( ▁N ▁, ▁R ▁, ▁A ▁) ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁count No ▁( ▁int ▁A ▁, ▁int ▁N ▁, ▁int ▁L ▁, ▁int ▁R ▁) ▁{ ▁int ▁ans ▁= ▁L ▁- ▁1 ▁+ ▁N ▁+ ▁floor ▁( ▁( ▁N ▁- ▁1 ▁) ▁/ ▁( ▁A ▁- ▁1 ▁) ▁) ▁; ▁if ▁( ▁ans ▁% ▁A ▁== ▁0 ▁) ▁{ ▁ans ▁= ▁ans ▁+ ▁1 ▁; ▁} ▁c out ▁<< ▁ans ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁= ▁5 ▁, ▁N ▁= ▁10 ▁, ▁L ▁= ▁4 ▁, ▁R ▁= ▁20 ▁; ▁count No ▁( ▁A ▁, ▁N ▁, ▁L ▁, ▁R ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁MAX ▁1000000 ▁NEW _ LINE ▁bool ▁prime ▁[ ▁MAX ▁] ▁; ▁void ▁S ieve Of E rat ost hen es ▁( ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁MAX ▁; ▁i ▁++ ▁) ▁prime ▁[ ▁i ▁] ▁= ▁true ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁* ▁p ▁< ▁MAX ▁; ▁p ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁p ▁] ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁p ▁* ▁p ▁; ▁i ▁< ▁MAX ▁; ▁i ▁+= ▁p ▁) ▁prime ▁[ ▁i ▁] ▁= ▁false ▁; ▁} ▁} ▁} ▁int ▁sum Prime ▁( ▁int ▁k ▁) ▁{ ▁S ieve Of E rat ost hen es ▁( ▁) ▁; ▁vector ▁< ▁int ▁> ▁v ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁< ▁MAX ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁i ▁] ▁) ▁v ▁. ▁push _ back ▁( ▁i ▁) ▁; ▁} ▁int ▁sum ▁= ▁0 ▁; ▁int ▁skip ▁= ▁( ▁k ▁* ▁( ▁k ▁- ▁1 ▁) ▁) ▁/ ▁2 ▁; ▁while ▁( ▁k ▁> ▁0 ▁) ▁{ ▁sum ▁+= ▁v ▁[ ▁skip ▁] ▁; ▁skip ▁++ ▁; ▁k ▁-- ▁; ▁} ▁return ▁sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁k ▁= ▁3 ▁; ▁c out ▁<< ▁sum Prime ▁( ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁next Occurrence ▁( ▁string ▁str ▁, ▁int ▁n ▁, ▁int ▁start ▁, ▁char ▁ch ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁start ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁str ▁[ ▁i ▁] ▁== ▁ch ▁) ▁return ▁i ▁; ▁} ▁return ▁-1 ▁; ▁} ▁int ▁count Sub Str ▁( ▁string ▁str ▁, ▁int ▁n ▁, ▁char ▁ch ▁) ▁{ ▁int ▁cnt ▁= ▁0 ▁; ▁int ▁j ▁= ▁next Occurrence ▁( ▁str ▁, ▁n ▁, ▁0 ▁, ▁ch ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁while ▁( ▁j ▁!= ▁-1 ▁&& ▁j ▁< ▁i ▁) ▁{ ▁j ▁= ▁next Occurrence ▁( ▁str ▁, ▁n ▁, ▁j ▁+ ▁1 ▁, ▁ch ▁) ▁; ▁} ▁if ▁( ▁j ▁== ▁-1 ▁) ▁break ▁; ▁cnt ▁+= ▁( ▁n ▁- ▁j ▁) ▁; ▁} ▁return ▁cnt ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁g eek s forge ek s ▁" ▁; ▁int ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁char ▁ch ▁= ▁' ▁k ▁' ▁; ▁c out ▁<< ▁count Sub Str ▁( ▁str ▁, ▁n ▁, ▁ch ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁power ▁( ▁int ▁x ▁, ▁unsigned ▁int ▁y ▁, ▁int ▁p ▁) ▁{ ▁int ▁res ▁= ▁1 ▁; ▁x ▁= ▁x ▁% ▁p ▁; ▁while ▁( ▁y ▁> ▁0 ▁) ▁{ ▁if ▁( ▁y ▁& ▁1 ▁) ▁res ▁= ▁( ▁res ▁* ▁x ▁) ▁% ▁p ▁; ▁x ▁= ▁( ▁x ▁* ▁x ▁) ▁% ▁p ▁; ▁} ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁L ▁= ▁2 ▁, ▁P ▁= ▁pow ▁( ▁10 ▁, ▁9 ▁) ▁; ▁int ▁ans ▁= ▁power ▁( ▁3 25 ▁, ▁L ▁, ▁P ▁) ▁; ▁c out ▁<< ▁ans ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁re ver ese Array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁rev ▁[ ▁n ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁rev ▁[ ▁n ▁- ▁i ▁- ▁1 ▁] ▁= ▁arr ▁[ ▁i ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁arr ▁[ ▁i ▁] ▁= ▁rev ▁[ ▁i ▁] ▁; ▁} ▁void ▁print Array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁size ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁c out ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁print Array ▁( ▁arr ▁, ▁n ▁) ▁; ▁re ver ese Array ▁( ▁arr ▁, ▁n ▁) ▁; ▁c out ▁<< ▁" ▁Rever sed ▁array ▁is ▁" ▁<< ▁end l ▁; ▁print Array ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find String ▁( ▁string ▁str ▁, ▁int ▁M ▁) ▁{ ▁int ▁N ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁M ▁= ▁min ▁( ▁M ▁, ▁N ▁) ▁; ▁string ▁s 1 ▁= ▁" ▁" ▁; ▁while ▁( ▁M ▁!= ▁0 ▁) ▁{ ▁s 1 ▁= ▁" ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁str ▁[ ▁i ▁] ▁== ▁'0' ▁) ▁{ ▁if ▁( ▁( ▁str ▁[ ▁i ▁- ▁1 ▁] ▁== ▁'1' ▁&& ▁str ▁[ ▁i ▁+ ▁1 ▁] ▁!= ▁'1' ▁) ▁|| ▁( ▁str ▁[ ▁i ▁- ▁1 ▁] ▁!= ▁'1' ▁&& ▁str ▁[ ▁i ▁+ ▁1 ▁] ▁== ▁'1' ▁) ▁) ▁s 1 ▁+= ▁'1' ▁; ▁else ▁s 1 ▁+= ▁'0' ▁; ▁} ▁else ▁s 1 ▁+= ▁'1' ▁; ▁} ▁if ▁( ▁str ▁== ▁s 1 ▁) ▁break ▁; ▁str ▁= ▁s 1 ▁; ▁M ▁-- ▁; ▁} ▁c out ▁<< ▁s 1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁"01 101 00" ▁; ▁int ▁M ▁= ▁3 ▁; ▁find String ▁( ▁str ▁, ▁M ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁ind iv isible Digits ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁int ▁num ▁= ▁0 ▁; ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁<< ▁" ▁: ▁" ▁; ▁for ▁( ▁int ▁j ▁= ▁2 ▁; ▁j ▁< ▁10 ▁; ▁j ▁++ ▁) ▁{ ▁int ▁temp ▁= ▁arr ▁[ ▁i ▁] ▁; ▁bool ▁flag ▁= ▁true ▁; ▁while ▁( ▁temp ▁> ▁0 ▁) ▁{ ▁if ▁( ▁( ▁temp ▁% ▁10 ▁) ▁!= ▁0 ▁&& ▁( ▁temp ▁% ▁10 ▁) ▁% ▁j ▁== ▁0 ▁) ▁{ ▁flag ▁= ▁false ▁; ▁break ▁; ▁} ▁temp ▁/= ▁10 ▁; ▁} ▁if ▁( ▁flag ▁) ▁{ ▁c out ▁<< ▁j ▁<< ▁' ▁' ▁; ▁} ▁} ▁c out ▁<< ▁end l ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁4 16 2 ▁, ▁115 2 ▁, ▁9 98 42 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁ind iv isible Digits ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁check ▁( ▁string ▁s 1 ▁, ▁string ▁s 2 ▁) ▁{ ▁int ▁s 1 _0 ▁= ▁0 ▁, ▁s 2 _0 ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s 1 ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s 1 ▁[ ▁i ▁] ▁== ▁'0' ▁) ▁{ ▁s 1 _0 ▁++ ▁; ▁} ▁if ▁( ▁s 2 ▁[ ▁i ▁] ▁== ▁'0' ▁) ▁{ ▁s 2 _0 ▁++ ▁; ▁} ▁} ▁if ▁( ▁s 1 _0 ▁!= ▁s 2 _0 ▁) ▁{ ▁c out ▁<< ▁" ▁NO ▁" ▁<< ▁end l ▁; ▁return ▁; ▁} ▁else ▁{ ▁int ▁Count 1 ▁= ▁0 ▁, ▁Count 2 ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s 1 ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s 1 ▁[ ▁i ▁] ▁== ▁'0' ▁) ▁{ ▁Count 1 ▁++ ▁; ▁} ▁if ▁( ▁s 2 ▁[ ▁i ▁] ▁== ▁'0' ▁) ▁{ ▁Count 2 ▁++ ▁; ▁} ▁if ▁( ▁Count 1 ▁< ▁Count 2 ▁) ▁{ ▁c out ▁<< ▁" ▁NO ▁" ▁<< ▁end l ▁; ▁return ▁; ▁} ▁} ▁c out ▁<< ▁" ▁YES ▁" ▁<< ▁end l ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s 1 ▁= ▁"100 11 1" ▁; ▁string ▁s 2 ▁= ▁"11 101 0" ▁; ▁check ▁( ▁s 1 ▁, ▁s 2 ▁) ▁; ▁s 1 ▁= ▁"11 01 00" ▁; ▁s 2 ▁= ▁" 0101 01" ▁; ▁check ▁( ▁s 1 ▁, ▁s 2 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max Even Integ ers ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁M ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁N ▁- ▁M ▁; ▁i ▁++ ▁) ▁{ ▁int ▁cnt ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁M ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁+ ▁j ▁] ▁% ▁2 ▁== ▁0 ▁) ▁cnt ▁++ ▁; ▁} ▁ans ▁= ▁max ▁( ▁ans ▁, ▁cnt ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁5 ▁, ▁4 ▁, ▁7 ▁, ▁6 ▁} ▁; ▁int ▁K ▁= ▁3 ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁max Even Integ ers ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁string ▁check ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁map ▁< ▁int ▁, ▁int ▁> ▁hm ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁hm ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁hm ▁[ ▁arr ▁[ ▁j ▁] ▁] ▁++ ▁; ▁bool ▁flag ▁= ▁false ▁; ▁for ▁( ▁auto ▁x ▁: ▁hm ▁) ▁{ ▁if ▁( ▁x ▁. ▁second ▁== ▁1 ▁) ▁{ ▁flag ▁= ▁true ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁! ▁flag ▁) ▁return ▁" ▁No ▁" ▁; ▁} ▁hm ▁. ▁clear ▁( ▁) ▁; ▁} ▁return ▁" ▁Yes ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁check ▁( ▁arr ▁, ▁N ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find _ index ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁K ▁) ▁{ ▁int ▁start ▁= ▁0 ▁; ▁int ▁end ▁= ▁n ▁- ▁1 ▁; ▁while ▁( ▁start ▁<= ▁end ▁) ▁{ ▁int ▁mid ▁= ▁( ▁start ▁+ ▁end ▁) ▁/ ▁2 ▁; ▁if ▁( ▁arr ▁[ ▁mid ▁] ▁== ▁K ▁) ▁return ▁mid ▁; ▁else ▁if ▁( ▁arr ▁[ ▁mid ▁] ▁< ▁K ▁) ▁start ▁= ▁mid ▁+ ▁1 ▁; ▁else ▁end ▁= ▁mid ▁- ▁1 ▁; ▁} ▁return ▁end ▁+ ▁1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁K ▁= ▁2 ▁; ▁c out ▁<< ▁find _ index ▁( ▁arr ▁, ▁n ▁, ▁K ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁isP al indrome ▁( ▁string ▁str ▁) ▁{ ▁int ▁i ▁= ▁0 ▁, ▁j ▁= ▁str ▁. ▁size ▁( ▁) ▁- ▁1 ▁; ▁while ▁( ▁i ▁< ▁j ▁) ▁{ ▁if ▁( ▁str ▁[ ▁i ▁] ▁!= ▁str ▁[ ▁j ▁] ▁) ▁return ▁false ▁; ▁i ▁++ ▁; ▁j ▁-- ▁; ▁} ▁return ▁true ▁; ▁} ▁void ▁form Pal indrome ▁( ▁string ▁a ▁, ▁string ▁b ▁, ▁int ▁n ▁) ▁{ ▁char ▁aa ▁[ ▁n ▁+ ▁2 ▁] ▁; ▁char ▁bb ▁[ ▁n ▁+ ▁2 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁+ ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁aa ▁[ ▁i ▁] ▁= ▁' ▁' ▁; ▁bb ▁[ ▁i ▁] ▁= ▁' ▁' ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁aa ▁[ ▁i ▁] ▁= ▁a ▁[ ▁i ▁- ▁1 ▁] ▁; ▁bb ▁[ ▁i ▁] ▁= ▁b ▁[ ▁i ▁- ▁1 ▁] ▁; ▁} ▁bool ▁ok ▁= ▁false ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁n ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁string ▁la ▁= ▁" ▁" ▁; ▁string ▁ra ▁= ▁" ▁" ▁; ▁string ▁lb ▁= ▁" ▁" ▁; ▁string ▁rb ▁= ▁" ▁" ▁; ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁<= ▁i ▁- ▁1 ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁aa ▁[ ▁j ▁] ▁== ▁' ▁' ▁) ▁la ▁+= ▁" ▁" ▁; ▁else ▁la ▁+= ▁aa ▁[ ▁j ▁] ▁; ▁if ▁( ▁bb ▁[ ▁j ▁] ▁== ▁' ▁' ▁) ▁lb ▁+= ▁" ▁" ▁; ▁else ▁lb ▁+= ▁bb ▁[ ▁j ▁] ▁; ▁} ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁<= ▁n ▁+ ▁1 ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁aa ▁[ ▁j ▁] ▁== ▁' ▁' ▁) ▁ra ▁+= ▁" ▁" ▁; ▁else ▁ra ▁+= ▁aa ▁[ ▁j ▁] ▁; ▁if ▁( ▁bb ▁[ ▁j ▁] ▁== ▁' ▁' ▁) ▁rb ▁+= ▁" ▁" ▁; ▁else ▁rb ▁+= ▁bb ▁[ ▁j ▁] ▁; ▁} ▁if ▁( ▁isP al indrome ▁( ▁la ▁+ ▁rb ▁) ▁|| ▁isP al indrome ▁( ▁lb ▁+ ▁ra ▁) ▁) ▁{ ▁ok ▁= ▁true ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁ok ▁) ▁c out ▁<< ▁( ▁" ▁Yes ▁" ▁) ▁; ▁else ▁c out ▁<< ▁(
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is Cross ed ▁( ▁string ▁path ▁) ▁{ ▁if ▁( ▁path ▁. ▁size ▁( ▁) ▁== ▁0 ▁) ▁return ▁false ▁; ▁bool ▁ans ▁= ▁false ▁; ▁set ▁< ▁pair ▁< ▁int ▁, ▁int ▁> ▁> ▁set ▁; ▁int ▁x ▁= ▁0 ▁, ▁y ▁= ▁0 ▁; ▁set ▁. ▁insert ▁( ▁{ ▁x ▁, ▁y ▁} ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁path ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁path ▁[ ▁i ▁] ▁== ▁' ▁N ▁' ▁) ▁set ▁. ▁insert ▁( ▁{ ▁x ▁, ▁y ▁++ ▁} ▁) ▁; ▁if ▁( ▁path ▁[ ▁i ▁] ▁== ▁' ▁S ▁' ▁) ▁set ▁. ▁insert ▁( ▁{ ▁x ▁, ▁y ▁-- ▁} ▁) ▁; ▁if ▁( ▁path ▁[ ▁i ▁] ▁== ▁' ▁E ▁' ▁) ▁set ▁. ▁insert ▁( ▁{ ▁x ▁++ ▁, ▁y ▁} ▁) ▁; ▁if ▁( ▁path ▁[ ▁i ▁] ▁== ▁' ▁W ▁' ▁) ▁set ▁. ▁insert ▁( ▁{ ▁x ▁-- ▁, ▁y ▁} ▁) ▁; ▁if ▁( ▁set ▁. ▁find ▁( ▁{ ▁x ▁, ▁y ▁} ▁) ▁!= ▁set ▁. ▁end ▁( ▁) ▁) ▁{ ▁ans ▁= ▁true ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁ans ▁) ▁c out ▁<< ▁" ▁Cross ed ▁" ▁; ▁else ▁c out ▁<< ▁" ▁Not ▁Cross ed ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁path ▁= ▁" ▁NE SW ▁" ▁; ▁is Cross ed ▁( ▁path ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁len ght Of Long est AP ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁unordered _ map ▁< ▁int ▁, ▁unordered _ map ▁< ▁int ▁, ▁int ▁> ▁> ▁dp ▁; ▁int ▁res ▁= ▁2 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁++ ▁j ▁) ▁{ ▁int ▁d ▁= ▁A ▁[ ▁j ▁] ▁- ▁A ▁[ ▁i ▁] ▁; ▁dp ▁[ ▁d ▁] ▁[ ▁j ▁] ▁= ▁dp ▁[ ▁d ▁] ▁. ▁count ▁( ▁i ▁) ▁? ▁dp ▁[ ▁d ▁] ▁[ ▁i ▁] ▁+ ▁1 ▁: ▁2 ▁; ▁res ▁= ▁max ▁( ▁res ▁, ▁dp ▁[ ▁d ▁] ▁[ ▁j ▁] ▁) ▁; ▁} ▁} ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁20 ▁, ▁1 ▁, ▁15 ▁, ▁3 ▁, ▁10 ▁, ▁5 ▁, ▁8 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁len ght Of Long est AP ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁check Sum Of N atural ▁( ▁int ▁n ▁) ▁{ ▁int ▁i ▁= ▁1 ▁; ▁bool ▁flag ▁= ▁false ▁; ▁while ▁( ▁i ▁* ▁( ▁i ▁+ ▁1 ▁) ▁< ▁n ▁* ▁2 ▁) ▁{ ▁int ▁X ▁= ▁i ▁* ▁( ▁i ▁+ ▁1 ▁) ▁; ▁int ▁t ▁= ▁n ▁* ▁2 ▁- ▁X ▁; ▁int ▁k ▁= ▁sqrt ▁( ▁t ▁) ▁; ▁if ▁( ▁k ▁* ▁( ▁k ▁+ ▁1 ▁) ▁== ▁t ▁) ▁{ ▁flag ▁= ▁true ▁; ▁break ▁; ▁} ▁i ▁+= ▁1 ▁; ▁} ▁if ▁( ▁flag ▁) ▁c out ▁<< ▁" ▁YES ▁" ▁; ▁else ▁c out ▁<< ▁" ▁NO ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁25 ▁; ▁check Sum Of N atural ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is Perf ect Square ▁( ▁int ▁n ▁) ▁{ ▁double ▁sr ▁= ▁sqrt ▁( ▁n ▁) ▁; ▁return ▁( ▁( ▁sr ▁- ▁floor ▁( ▁sr ▁) ▁) ▁== ▁0 ▁) ▁; ▁} ▁void ▁Sub array H aving Perf ect Square ▁( ▁vector ▁< ▁int ▁> ▁arr ▁, ▁int ▁k ▁) ▁{ ▁pair ▁< ▁int ▁, ▁int ▁> ▁ans ▁; ▁int ▁sum ▁= ▁0 ▁, ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁k ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁bool ▁found ▁= ▁false ▁; ▁if ▁( ▁is Perf ect Square ▁( ▁sum ▁) ▁) ▁{ ▁ans ▁. ▁first ▁= ▁0 ▁; ▁ans ▁. ▁second ▁= ▁i ▁- ▁1 ▁; ▁} ▁else ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁< ▁arr ▁. ▁size ▁( ▁) ▁; ▁j ▁++ ▁) ▁{ ▁sum ▁= ▁sum ▁+ ▁arr ▁[ ▁j ▁] ▁- ▁arr ▁[ ▁j ▁- ▁k ▁] ▁; ▁if ▁( ▁is Perf ect Square ▁( ▁sum ▁) ▁) ▁{ ▁found ▁= ▁true ▁; ▁ans ▁. ▁first ▁= ▁j ▁- ▁k ▁+ ▁1 ▁; ▁ans ▁. ▁second ▁= ▁j ▁; ▁} ▁} ▁for ▁( ▁int ▁k ▁= ▁ans ▁. ▁first ▁; ▁k ▁<= ▁ans ▁. ▁second ▁; ▁k ▁++ ▁) ▁{ ▁c out ▁<< ▁arr ▁[ ▁k ▁] ▁<< ▁" ▁" ▁; ▁} ▁} ▁if ▁( ▁found ▁== ▁false ▁) ▁{ ▁c out ▁<< ▁" ▁- ▁1" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁int ▁> ▁arr ▁; ▁arr ▁= ▁{ ▁20 ▁, ▁34 ▁, ▁51 ▁, ▁10 ▁, ▁99 ▁, ▁87 ▁, ▁23 ▁, ▁45 ▁} ▁; ▁int ▁K ▁= ▁3 ▁; ▁Sub array H aving Perf ect Square ▁( ▁arr ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁mirror Matrix ▁( ▁int ▁mat 1 ▁[ ▁] ▁[ ▁4 ▁] ▁, ▁int ▁mat 2 ▁[ ▁] ▁[ ▁4 ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁row ▁= ▁0 ▁; ▁int ▁col ▁= ▁0 ▁; ▁bool ▁is Mirror Image ▁= ▁true ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁N ▁- ▁1 ▁; ▁j ▁>= ▁0 ▁; ▁j ▁-- ▁) ▁{ ▁if ▁( ▁mat 2 ▁[ ▁row ▁] ▁[ ▁col ▁] ▁!= ▁mat 1 ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁{ ▁is Mirror Image ▁= ▁false ▁; ▁} ▁col ▁++ ▁; ▁} ▁col ▁= ▁0 ▁; ▁row ▁++ ▁; ▁} ▁if ▁( ▁is Mirror Image ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁4 ▁; ▁int ▁mat 1 ▁[ ▁] ▁[ ▁4 ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁, ▁{ ▁0 ▁, ▁6 ▁, ▁7 ▁, ▁8 ▁} ▁, ▁{ ▁9 ▁, ▁10 ▁, ▁11 ▁, ▁12 ▁} ▁, ▁{ ▁13 ▁, ▁14 ▁, ▁15 ▁, ▁16 ▁} ▁} ▁; ▁int ▁mat 2 ▁[ ▁] ▁[ ▁4 ▁] ▁= ▁{ ▁{ ▁4 ▁, ▁3 ▁, ▁2 ▁, ▁1 ▁} ▁, ▁{ ▁8 ▁, ▁7 ▁, ▁6 ▁, ▁0 ▁} ▁, ▁{ ▁12 ▁, ▁11 ▁, ▁10 ▁, ▁9 ▁} ▁, ▁{ ▁16 ▁, ▁15 ▁, ▁14 ▁, ▁13 ▁} ▁} ▁; ▁mirror Matrix ▁( ▁mat 1 ▁, ▁mat 2 ▁, ▁N ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁split string ▁( ▁string ▁s ▁) ▁{ ▁int ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁int ▁zeros ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁s ▁[ ▁i ▁] ▁== ▁'0' ▁) ▁zeros ▁++ ▁; ▁if ▁( ▁zeros ▁% ▁3 ▁!= ▁0 ▁) ▁return ▁0 ▁; ▁if ▁( ▁zeros ▁== ▁0 ▁) ▁return ▁( ▁( ▁n ▁- ▁1 ▁) ▁* ▁( ▁n ▁- ▁2 ▁) ▁) ▁/ ▁2 ▁; ▁int ▁zeros In Each Sub string ▁= ▁zeros ▁/ ▁3 ▁; ▁int ▁ways Of First Cut ▁= ▁0 ▁, ▁ways Of Second Cut ▁= ▁0 ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁[ ▁i ▁] ▁== ▁'0' ▁) ▁count ▁++ ▁; ▁if ▁( ▁count ▁== ▁zeros In Each Sub string ▁) ▁ways Of First Cut ▁++ ▁; ▁else ▁if ▁( ▁count ▁== ▁2 ▁* ▁zeros In Each Sub string ▁) ▁ways Of Second Cut ▁++ ▁; ▁} ▁return ▁ways Of First Cut ▁* ▁ways Of Second Cut ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁" 0101 0" ▁; ▁c out ▁<< ▁" ▁The ▁number ▁of ▁ways ▁to ▁split ▁is ▁" ▁<< ▁split string ▁( ▁s ▁) ▁<< ▁end l ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁can Transform ▁( ▁string ▁str 1 ▁, ▁string ▁str 2 ▁) ▁{ ▁string ▁s 1 ▁= ▁" ▁" ▁; ▁string ▁s 2 ▁= ▁" ▁" ▁; ▁for ▁( ▁char ▁c ▁: ▁str 1 ▁) ▁{ ▁if ▁( ▁c ▁!= ▁' ▁C ▁' ▁) ▁{ ▁s 1 ▁+= ▁c ▁; ▁} ▁} ▁for ▁( ▁char ▁c ▁: ▁str 2 ▁) ▁{ ▁if ▁( ▁c ▁!= ▁' ▁C ▁' ▁) ▁{ ▁s 2 ▁+= ▁c ▁; ▁} ▁} ▁if ▁( ▁s 1 ▁!= ▁s 2 ▁) ▁return ▁false ▁; ▁int ▁i ▁= ▁0 ▁; ▁int ▁j ▁= ▁0 ▁; ▁int ▁n ▁= ▁str 1 ▁. ▁length ▁( ▁) ▁; ▁while ▁( ▁i ▁< ▁n ▁and ▁j ▁< ▁n ▁) ▁{ ▁if ▁( ▁str 1 ▁[ ▁i ▁] ▁== ▁' ▁C ▁' ▁) ▁{ ▁i ▁++ ▁; ▁} ▁else ▁if ▁( ▁str 2 ▁[ ▁j ▁] ▁== ▁' ▁C ▁' ▁) ▁{ ▁j ▁++ ▁; ▁} ▁else ▁{ ▁if ▁( ▁( ▁str 1 ▁[ ▁i ▁] ▁== ▁' ▁A ▁' ▁and ▁i ▁< ▁j ▁) ▁or ▁( ▁str 1 ▁[ ▁i ▁] ▁== ▁' ▁B ▁' ▁and ▁i ▁> ▁j ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁i ▁++ ▁; ▁j ▁++ ▁; ▁} ▁} ▁return ▁true ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str 1 ▁= ▁" ▁B CC AB CB CA ▁" ▁; ▁string ▁str 2 ▁= ▁" ▁CB AC C BB AC ▁" ▁; ▁if ▁( ▁can Transform ▁( ▁str 1 ▁, ▁str 2 ▁) ▁) ▁{ ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁" ▁No ▁" ▁; ▁} ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁X ▁= ▁1 ▁; ▁int ▁diam eter ▁= ▁0 ▁; ▁map ▁< ▁int ▁, ▁bool ▁> ▁mp ▁; ▁void ▁dfs ▁( ▁int ▁current _ node ▁, ▁int ▁prev _ node ▁, ▁int ▁len ▁, ▁bool ▁add _ to _ map ▁, ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁& ▁adj ▁) ▁{ ▁if ▁( ▁len ▁> ▁diam eter ▁) ▁{ ▁diam eter ▁= ▁len ▁; ▁X ▁= ▁current _ node ▁; ▁} ▁if ▁( ▁add _ to _ map ▁&& ▁len ▁== ▁diam eter ▁) ▁{ ▁mp ▁[ ▁current _ node ▁] ▁= ▁1 ▁; ▁} ▁for ▁( ▁auto ▁& ▁it ▁: ▁adj ▁[ ▁current _ node ▁] ▁) ▁{ ▁if ▁( ▁it ▁!= ▁prev _ node ▁) ▁dfs ▁( ▁it ▁, ▁current _ node ▁, ▁len ▁+ ▁1 ▁, ▁add _ to _ map ▁, ▁adj ▁) ▁; ▁} ▁} ▁void ▁dfs Utility ▁( ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁& ▁adj ▁) ▁{ ▁dfs ▁( ▁1 ▁, ▁-1 ▁, ▁0 ▁, ▁0 ▁, ▁adj ▁) ▁; ▁int ▁far th est _ node ▁= ▁X ▁; ▁dfs ▁( ▁far th est _ node ▁, ▁-1 ▁, ▁0 ▁, ▁0 ▁, ▁adj ▁) ▁; ▁dfs ▁( ▁far th est _ node ▁, ▁-1 ▁, ▁0 ▁, ▁1 ▁, ▁adj ▁) ▁; ▁dfs ▁( ▁X ▁, ▁-1 ▁, ▁0 ▁, ▁1 ▁, ▁adj ▁) ▁; ▁} ▁void ▁print D iam eters ▁( ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁& ▁adj ▁) ▁{ ▁dfs Utility ▁( ▁adj ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁6 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁mp ▁[ ▁i ▁] ▁== ▁1 ▁) ▁c out ▁<< ▁diam eter ▁+ ▁1 ▁<< ▁" ▁, ▁" ▁; ▁else ▁c out ▁<< ▁diam eter ▁<< ▁" ▁, ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁adj ▁( ▁7 ▁) ▁; ▁adj ▁[ ▁1 ▁] ▁. ▁push _ back ▁( ▁2 ▁) ▁; ▁adj ▁[ ▁2 ▁] ▁. ▁push _ back ▁( ▁1 ▁) ▁; ▁adj ▁[ ▁1 ▁] ▁. ▁push _ back ▁( ▁3 ▁) ▁; ▁adj ▁[ ▁3 ▁] ▁. ▁push _ back ▁( ▁1 ▁) ▁; ▁adj ▁[ ▁2 ▁] ▁. ▁push _ back ▁( ▁4 ▁) ▁; ▁adj ▁[ ▁4 ▁] ▁. ▁push _
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁kn ap S ack ▁( ▁int ▁nums ▁[ ▁] ▁, ▁int ▁S ▁, ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁sum ▁+= ▁nums ▁[ ▁i ▁] ▁; ▁if ▁( ▁sum ▁< ▁S ▁|| ▁- ▁sum ▁> ▁- ▁S ▁|| ▁( ▁S ▁+ ▁sum ▁) ▁% ▁2 ▁== ▁1 ▁) ▁return ▁0 ▁; ▁int ▁dp ▁[ ▁( ▁S ▁+ ▁sum ▁) ▁/ ▁2 ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁( ▁S ▁+ ▁sum ▁) ▁/ ▁2 ▁; ▁i ▁++ ▁) ▁dp ▁[ ▁i ▁] ▁= ▁0 ▁; ▁dp ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁( ▁S ▁+ ▁sum ▁) ▁/ ▁2 ▁; ▁i ▁>= ▁nums ▁[ ▁j ▁] ▁; ▁i ▁-- ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁+= ▁dp ▁[ ▁i ▁- ▁nums ▁[ ▁j ▁] ▁] ▁; ▁} ▁} ▁return ▁dp ▁[ ▁( ▁S ▁+ ▁sum ▁) ▁/ ▁2 ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁S ▁= ▁3 ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁answer ▁= ▁kn ap S ack ▁( ▁arr ▁, ▁S ▁, ▁5 ▁) ▁; ▁c out ▁<< ▁answer ▁<< ▁end l ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁no _ of _ substring ▁( ▁string ▁s ▁, ▁int ▁N ▁) ▁{ ▁int ▁fre ▁[ ▁26 ▁] ▁; ▁int ▁str _ len ▁; ▁str _ len ▁= ▁( ▁int ▁) ▁s ▁. ▁length ▁( ▁) ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁str _ len ▁; ▁i ▁++ ▁) ▁{ ▁mem set ▁( ▁fre ▁, ▁0 ▁, ▁sizeof ▁( ▁fre ▁) ▁) ▁; ▁int ▁max _ index ▁= ▁0 ▁; ▁int ▁dist ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁< ▁str _ len ▁; ▁j ▁++ ▁) ▁{ ▁int ▁x ▁= ▁s ▁[ ▁j ▁] ▁- ▁' ▁a ▁' ▁; ▁if ▁( ▁fre ▁[ ▁x ▁] ▁== ▁0 ▁) ▁dist ▁++ ▁; ▁fre ▁[ ▁x ▁] ▁++ ▁; ▁max _ index ▁= ▁max ▁( ▁max _ index ▁, ▁fre ▁[ ▁x ▁] ▁) ▁; ▁if ▁( ▁dist ▁>= ▁N ▁&& ▁( ▁( ▁max _ index ▁* ▁dist ▁) ▁== ▁( ▁j ▁- ▁i ▁+ ▁1 ▁) ▁) ▁) ▁count ▁++ ▁; ▁} ▁} ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁" ▁ab h ay ▁" ▁; ▁int ▁N ▁= ▁3 ▁; ▁c out ▁<< ▁no _ of _ substring ▁( ▁s ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁mat ▁[ ▁1001 ▁] ▁[ ▁1001 ▁] ▁; ▁int ▁r ▁, ▁c ▁, ▁x ▁, ▁y ▁; ▁int ▁dx ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁-1 ▁, ▁-1 ▁, ▁-1 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁} ▁; ▁int ▁dy ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁1 ▁, ▁0 ▁, ▁-1 ▁, ▁-1 ▁, ▁-1 ▁, ▁0 ▁, ▁1 ▁} ▁; ▁void ▁Find Minimum Distance ▁( ▁) ▁{ ▁queue ▁< ▁pair ▁< ▁int ▁, ▁int ▁> ▁> ▁q ▁; ▁q ▁. ▁push ▁( ▁{ ▁x ▁, ▁y ▁} ▁) ▁; ▁mat ▁[ ▁x ▁] ▁[ ▁y ▁] ▁= ▁0 ▁; ▁while ▁( ▁! ▁q ▁. ▁empty ▁( ▁) ▁) ▁{ ▁x ▁= ▁q ▁. ▁front ▁( ▁) ▁. ▁first ▁; ▁y ▁= ▁q ▁. ▁front ▁( ▁) ▁. ▁second ▁; ▁q ▁. ▁pop ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁8 ▁; ▁i ▁++ ▁) ▁{ ▁int ▁a ▁= ▁x ▁+ ▁dx ▁[ ▁i ▁] ▁; ▁int ▁b ▁= ▁y ▁+ ▁dy ▁[ ▁i ▁] ▁; ▁if ▁( ▁a ▁< ▁0 ▁a ▁> ▁= ▁r ▁b ▁>= ▁c ▁b ▁< ▁0 ▁) ▁continue ▁; ▁if ▁( ▁mat ▁[ ▁a ▁] ▁[ ▁b ▁] ▁== ▁0 ▁) ▁{ ▁mat ▁[ ▁a ▁] ▁[ ▁b ▁] ▁= ▁mat ▁[ ▁x ▁] ▁[ ▁y ▁] ▁+ ▁1 ▁; ▁q ▁. ▁push ▁( ▁{ ▁a ▁, ▁b ▁} ▁) ▁; ▁} ▁} ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁r ▁= ▁5 ▁, ▁c ▁= ▁5 ▁, ▁x ▁= ▁1 ▁, ▁y ▁= ▁1 ▁; ▁int ▁t ▁= ▁x ▁; ▁int ▁l ▁= ▁y ▁; ▁mat ▁[ ▁x ▁] ▁[ ▁y ▁] ▁= ▁0 ▁; ▁Find Minimum Distance ▁( ▁) ▁; ▁mat ▁[ ▁t ▁] ▁[ ▁l ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁r ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁c ▁; ▁j ▁++ ▁) ▁{ ▁c out ▁<< ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁<< ▁" ▁" ▁; ▁} ▁c out ▁<< ▁end l ▁; ▁} ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is V ow el ▁( ▁char ▁c ▁) ▁{ ▁if ▁( ▁c ▁== ▁' ▁a ▁' ▁c ▁== ▁' ▁e ▁' ▁c ▁== ▁' ▁i ▁' ▁c ▁== ▁' ▁o ▁' ▁c ▁== ▁' ▁u ▁' ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁void ▁count Sub strings ▁( ▁string ▁s ▁, ▁int ▁n ▁) ▁{ ▁int ▁result ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁is V ow el ▁( ▁s ▁[ ▁j ▁] ▁) ▁) ▁{ ▁count ▁++ ▁; ▁} ▁if ▁( ▁count ▁% ▁2 ▁== ▁0 ▁) ▁result ▁++ ▁; ▁} ▁} ▁c out ▁<< ▁result ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁5 ▁; ▁string ▁s ▁= ▁" ▁abc de ▁" ▁; ▁count Sub strings ▁( ▁s ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁check Pal indrome ▁( ▁string ▁S ▁) ▁{ ▁int ▁N ▁= ▁S ▁. ▁size ▁( ▁) ▁; ▁bool ▁first _ half ▁= ▁true ▁; ▁bool ▁second _ half ▁= ▁true ▁; ▁int ▁cnt ▁= ▁( ▁N ▁/ ▁2 ▁) ▁- ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁( ▁( ▁N ▁/ ▁2 ▁) ▁/ ▁2 ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁S ▁[ ▁i ▁] ▁!= ▁S ▁[ ▁cnt ▁] ▁) ▁{ ▁first _ half ▁= ▁false ▁; ▁break ▁; ▁} ▁if ▁( ▁S ▁[ ▁N ▁/ ▁2 ▁+ ▁i ▁] ▁!= ▁S ▁[ ▁N ▁/ ▁2 ▁+ ▁cnt ▁] ▁) ▁{ ▁second _ half ▁- ▁false ▁; ▁break ▁; ▁} ▁cnt ▁-- ▁; ▁} ▁if ▁( ▁first _ half ▁&& ▁second _ half ▁) ▁{ ▁c out ▁<< ▁" ▁Yes ▁" ▁<< ▁end l ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁" ▁No ▁" ▁<< ▁end l ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁S ▁= ▁" ▁mom d ad ▁" ▁; ▁check Pal indrome ▁( ▁S ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁longest Sub array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁i ▁, ▁j ▁, ▁Max ▁= ▁1 ▁; ▁set ▁< ▁int ▁> ▁s ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁s ▁. ▁insert ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁for ▁( ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁abs ▁( ▁arr ▁[ ▁i ▁] ▁- ▁arr ▁[ ▁j ▁] ▁) ▁== ▁0 ▁|| ▁abs ▁( ▁arr ▁[ ▁i ▁] ▁- ▁arr ▁[ ▁j ▁] ▁) ▁== ▁k ▁) ▁{ ▁if ▁( ▁! ▁s ▁. ▁count ▁( ▁arr ▁[ ▁j ▁] ▁) ▁) ▁{ ▁if ▁( ▁s ▁. ▁size ▁( ▁) ▁== ▁2 ▁) ▁break ▁; ▁else ▁s ▁. ▁insert ▁( ▁arr ▁[ ▁j ▁] ▁) ▁; ▁} ▁} ▁else ▁break ▁; ▁} ▁if ▁( ▁s ▁. ▁size ▁( ▁) ▁== ▁2 ▁) ▁{ ▁Max ▁= ▁max ▁( ▁Max ▁, ▁j ▁- ▁i ▁) ▁; ▁s ▁. ▁clear ▁( ▁) ▁; ▁} ▁else ▁s ▁. ▁clear ▁( ▁) ▁; ▁} ▁return ▁Max ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁0 ▁, ▁2 ▁, ▁2 ▁, ▁5 ▁, ▁5 ▁, ▁5 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁K ▁= ▁1 ▁; ▁int ▁length ▁= ▁longest Sub array ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁; ▁if ▁( ▁length ▁== ▁1 ▁) ▁c out ▁<< ▁-1 ▁; ▁else ▁c out ▁<< ▁length ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁prefix _2 D ▁[ ▁2005 ▁] ▁[ ▁2005 ▁] ▁; ▁int ▁sub Matrix Sum ▁( ▁int ▁i ▁, ▁int ▁j ▁, ▁int ▁len ▁) ▁{ ▁return ▁prefix _2 D ▁[ ▁i ▁] ▁[ ▁j ▁] ▁- ▁prefix _2 D ▁[ ▁i ▁] ▁[ ▁j ▁- ▁len ▁] ▁- ▁prefix _2 D ▁[ ▁i ▁- ▁len ▁] ▁[ ▁j ▁] ▁+ ▁prefix _2 D ▁[ ▁i ▁- ▁len ▁] ▁[ ▁j ▁- ▁len ▁] ▁; ▁} ▁int ▁numberOf W ays ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁b ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁m ▁, ▁int ▁k ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁<= ▁m ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁- ▁1 ▁] ▁== ▁b ▁[ ▁j ▁- ▁1 ▁] ▁) ▁prefix _2 D ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁1 ▁; ▁else ▁prefix _2 D ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁0 ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁<= ▁m ▁; ▁j ▁++ ▁) ▁{ ▁prefix _2 D ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+= ▁prefix _2 D ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁<= ▁m ▁; ▁j ▁++ ▁) ▁{ ▁prefix _2 D ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+= ▁prefix _2 D ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁; ▁} ▁} ▁int ▁answer ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁<= ▁m ▁; ▁j ▁++ ▁) ▁{ ▁int ▁low ▁= ▁1 ▁; ▁int ▁high ▁= ▁min ▁( ▁i ▁, ▁j ▁) ▁; ▁while ▁( ▁low ▁< ▁high ▁) ▁{ ▁int ▁mid ▁= ▁( ▁low ▁+ ▁high ▁) ▁>> ▁1 ▁; ▁if ▁( ▁sub Matrix Sum ▁( ▁i ▁, ▁j ▁, ▁mid ▁) ▁>= ▁k ▁) ▁{ ▁high ▁= ▁mid ▁; ▁} ▁else ▁{ ▁low ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁} ▁if ▁(
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁NO _ OF _ CHARS ▁256 ▁NEW _ LINE ▁int ▁first Repe ating ▁( ▁string ▁& ▁str ▁) ▁{ ▁bool ▁visited ▁[ ▁NO _ OF _ CHARS ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁NO _ OF _ CHARS ▁; ▁i ▁++ ▁) ▁visited ▁[ ▁i ▁] ▁= ▁false ▁; ▁int ▁res ▁= ▁-1 ▁; ▁for ▁( ▁int ▁i ▁= ▁str ▁. ▁length ▁( ▁) ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁visited ▁[ ▁str ▁[ ▁i ▁] ▁] ▁== ▁false ▁) ▁visited ▁[ ▁str ▁[ ▁i ▁] ▁] ▁= ▁true ▁; ▁else ▁res ▁= ▁i ▁; ▁} ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁g eek s forge ek s ▁" ▁; ▁int ▁index ▁= ▁first Repe ating ▁( ▁str ▁) ▁; ▁if ▁( ▁index ▁== ▁-1 ▁) ▁printf ▁( ▁" ▁Either ▁all ▁characters ▁are ▁" ▁" ▁distinct ▁or ▁string ▁is ▁empty ▁" ▁) ▁; ▁else ▁printf ▁( ▁" ▁First ▁Re pe ating ▁character ▁" ▁" ▁is ▁% ▁c ▁" ▁, ▁str ▁[ ▁index ▁] ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find Sum Pairs ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁unordered _ map ▁< ▁int ▁, ▁int ▁> ▁m pp ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁m pp ▁[ ▁a ▁[ ▁i ▁] ▁+ ▁a ▁[ ▁j ▁] ▁] ▁++ ▁; ▁} ▁} ▁int ▁occur ▁= ▁0 ▁; ▁for ▁( ▁auto ▁it ▁: ▁m pp ▁) ▁{ ▁if ▁( ▁it ▁. ▁second ▁> ▁occur ▁) ▁{ ▁occur ▁= ▁it ▁. ▁second ▁; ▁} ▁} ▁for ▁( ▁auto ▁it ▁: ▁m pp ▁) ▁{ ▁if ▁( ▁it ▁. ▁second ▁== ▁occur ▁) ▁c out ▁<< ▁it ▁. ▁first ▁<< ▁end l ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁8 ▁, ▁3 ▁, ▁11 ▁, ▁4 ▁, ▁9 ▁, ▁2 ▁, ▁7 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁find Sum Pairs ▁( ▁a ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁" ▁cl imits ▁" ▁NEW _ LINE ▁# include ▁" ▁i ost ream ▁" ▁NEW _ LINE ▁# include ▁" ▁unordered ▁_ ▁map ▁" ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Small est After Del ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁m ▁, ▁int ▁del ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁unordered _ map ▁< ▁int ▁, ▁int ▁> ▁mp ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁{ ▁mp ▁[ ▁del ▁[ ▁i ▁] ▁] ▁++ ▁; ▁} ▁int ▁smallest Element ▁= ▁INT _ MAX ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁m ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁mp ▁. ▁find ▁( ▁arr ▁[ ▁i ▁] ▁) ▁!= ▁mp ▁. ▁end ▁( ▁) ▁) ▁{ ▁mp ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁-- ▁; ▁if ▁( ▁mp ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁== ▁0 ▁) ▁mp ▁. ▁erase ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁else ▁smallest Element ▁= ▁min ▁( ▁smallest Element ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁return ▁smallest Element ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁array ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁12 ▁, ▁33 ▁, ▁4 ▁, ▁56 ▁, ▁12 ▁, ▁20 ▁} ▁; ▁int ▁m ▁= ▁sizeof ▁( ▁array ▁) ▁/ ▁sizeof ▁( ▁array ▁[ ▁0 ▁] ▁) ▁; ▁int ▁del ▁[ ▁] ▁= ▁{ ▁12 ▁, ▁4 ▁, ▁56 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁del ▁) ▁/ ▁sizeof ▁( ▁del ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁find Small est After Del ▁( ▁array ▁, ▁m ▁, ▁del ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁" ▁cl imits ▁" ▁NEW _ LINE ▁# include ▁" ▁i ost ream ▁" ▁NEW _ LINE ▁# include ▁" ▁unordered ▁_ ▁map ▁" ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find l argest After Del ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁m ▁, ▁int ▁del ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁unordered _ map ▁< ▁int ▁, ▁int ▁> ▁mp ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁{ ▁mp ▁[ ▁del ▁[ ▁i ▁] ▁] ▁++ ▁; ▁} ▁int ▁largest Element ▁= ▁INT _ MIN ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁m ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁mp ▁. ▁find ▁( ▁arr ▁[ ▁i ▁] ▁) ▁!= ▁mp ▁. ▁end ▁( ▁) ▁) ▁{ ▁mp ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁-- ▁; ▁if ▁( ▁mp ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁== ▁0 ▁) ▁mp ▁. ▁erase ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁else ▁largest Element ▁= ▁max ▁( ▁largest Element ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁return ▁largest Element ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁array ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁12 ▁, ▁33 ▁, ▁4 ▁, ▁56 ▁, ▁12 ▁, ▁20 ▁} ▁; ▁int ▁m ▁= ▁sizeof ▁( ▁array ▁) ▁/ ▁sizeof ▁( ▁array ▁[ ▁0 ▁] ▁) ▁; ▁int ▁del ▁[ ▁] ▁= ▁{ ▁12 ▁, ▁33 ▁, ▁56 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁del ▁) ▁/ ▁sizeof ▁( ▁del ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁find l argest After Del ▁( ▁array ▁, ▁m ▁, ▁del ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁solve ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁min 1 ▁= ▁a ▁[ ▁0 ▁] ▁; ▁int ▁max 1 ▁= ▁a ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁> ▁max 1 ▁) ▁max 1 ▁= ▁a ▁[ ▁i ▁] ▁; ▁if ▁( ▁a ▁[ ▁i ▁] ▁< ▁min 1 ▁) ▁min 1 ▁= ▁a ▁[ ▁i ▁] ▁; ▁} ▁return ▁abs ▁( ▁min 1 ▁- ▁max 1 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁-1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁-10 ▁} ▁; ▁int ▁size ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁L argest ▁gap ▁is ▁: ▁" ▁<< ▁solve ▁( ▁arr ▁, ▁size ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁getMinimum Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁vector ▁< ▁int ▁> ▁res ▁; ▁vector ▁< ▁int ▁> ▁pos ▁; ▁vector ▁< ▁int ▁> ▁neg ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁0 ▁) ▁pos ▁. ▁push _ back ▁( ▁i ▁) ▁; ▁else ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁0 ▁) ▁neg ▁. ▁push _ back ▁( ▁i ▁) ▁; ▁} ▁if ▁( ▁pos ▁. ▁size ▁( ▁) ▁>= ▁2 ▁&& ▁neg ▁. ▁size ▁( ▁) ▁>= ▁2 ▁) ▁{ ▁int ▁pos Max ▁= ▁INT _ MIN ▁, ▁pos Max Idx ▁= ▁-1 ▁; ▁int ▁pos Min ▁= ▁INT _ MAX ▁, ▁pos Min Idx ▁= ▁-1 ▁; ▁int ▁neg Max ▁= ▁INT _ MIN ▁, ▁neg Max Idx ▁= ▁-1 ▁; ▁int ▁neg Min ▁= ▁INT _ MAX ▁, ▁neg Min Idx ▁= ▁-1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁pos ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁pos ▁[ ▁i ▁] ▁] ▁> ▁pos Max ▁) ▁{ ▁pos Max Idx ▁= ▁pos ▁[ ▁i ▁] ▁; ▁pos Max ▁= ▁arr ▁[ ▁pos Max Idx ▁] ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁pos ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁pos ▁[ ▁i ▁] ▁] ▁< ▁pos Min ▁&& ▁pos ▁[ ▁i ▁] ▁!= ▁pos Max Idx ▁) ▁{ ▁pos Min Idx ▁= ▁pos ▁[ ▁i ▁] ▁; ▁pos Min ▁= ▁arr ▁[ ▁pos Min Idx ▁] ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁neg ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁abs ▁( ▁arr ▁[ ▁neg ▁[ ▁i ▁] ▁] ▁) ▁> ▁neg Max ▁) ▁{ ▁neg Max Idx ▁= ▁neg ▁[ ▁i ▁] ▁; ▁neg Max ▁= ▁abs ▁( ▁arr ▁[ ▁neg Max Idx ▁] ▁) ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁neg ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁abs ▁( ▁arr ▁[ ▁neg ▁[ ▁i ▁] ▁] ▁) ▁< ▁neg Min ▁&& ▁neg ▁[ ▁i ▁] ▁!= ▁neg Max Idx ▁) ▁{ ▁neg Min
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁missing Num ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁min value ▁= ▁* ▁min _ element ▁( ▁arr ▁, ▁arr ▁+ ▁n ▁) ▁; ▁int ▁xor num ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁xor num ▁^= ▁( ▁min value ▁) ▁^ ▁arr ▁[ ▁i ▁] ▁; ▁min value ▁++ ▁; ▁} ▁return ▁xor num ▁^ ▁min value ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁13 ▁, ▁12 ▁, ▁11 ▁, ▁15 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁missing Num ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁maximum M ex ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁vector ▁< ▁int ▁> ▁ans ▁; ▁sort ▁( ▁arr ▁, ▁arr ▁+ ▁N ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁== ▁0 ▁arr ▁[ ▁i ▁] ▁!= ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁) ▁ans ▁. ▁push _ back ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁> ▁0 ▁&& ▁arr ▁[ ▁i ▁] ▁== ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁) ▁ans ▁. ▁push _ back ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁ans ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁0 ▁, ▁0 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁maximum M ex ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁vector ▁< ▁int ▁> ▁bubble _ sort ▁( ▁vector ▁< ▁int ▁> ▁ar ▁) ▁{ ▁if ▁( ▁ar ▁. ▁size ▁( ▁) ▁<= ▁1 ▁) ▁return ▁ar ▁; ▁if ▁( ▁ar ▁. ▁size ▁( ▁) ▁== ▁2 ▁) ▁{ ▁if ▁( ▁ar ▁[ ▁0 ▁] ▁< ▁ar ▁[ ▁1 ▁] ▁) ▁return ▁ar ▁; ▁else ▁return ▁{ ▁ar ▁[ ▁1 ▁] ▁, ▁ar ▁[ ▁0 ▁] ▁} ▁; ▁} ▁int ▁a ▁= ▁ar ▁[ ▁0 ▁] ▁; ▁int ▁b ▁= ▁ar ▁[ ▁1 ▁] ▁; ▁vector ▁< ▁int ▁> ▁bs ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁< ▁ar ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁bs ▁. ▁push _ back ▁( ▁ar ▁[ ▁i ▁] ▁) ▁; ▁vector ▁< ▁int ▁> ▁res ▁; ▁if ▁( ▁a ▁< ▁b ▁) ▁{ ▁vector ▁< ▁int ▁> ▁temp 1 ▁; ▁temp 1 ▁. ▁push _ back ▁( ▁b ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁bs ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁temp 1 ▁. ▁push _ back ▁( ▁bs ▁[ ▁i ▁] ▁) ▁; ▁vector ▁< ▁int ▁> ▁v ▁= ▁bubble _ sort ▁( ▁temp 1 ▁) ▁; ▁v ▁. ▁insert ▁( ▁v ▁. ▁begin ▁( ▁) ▁, ▁a ▁) ▁; ▁res ▁= ▁v ▁; ▁} ▁else ▁{ ▁vector ▁< ▁int ▁> ▁temp 1 ▁; ▁temp 1 ▁. ▁push _ back ▁( ▁a ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁bs ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁temp 1 ▁. ▁push _ back ▁( ▁bs ▁[ ▁i ▁] ▁) ▁; ▁vector ▁< ▁int ▁> ▁v ▁= ▁bubble _ sort ▁( ▁temp 1 ▁) ▁; ▁v ▁. ▁insert ▁( ▁v ▁. ▁begin ▁( ▁) ▁, ▁b ▁) ▁; ▁res ▁= ▁v ▁; ▁} ▁vector ▁< ▁int ▁> ▁pass ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁res ▁. ▁size ▁( ▁) ▁- ▁1 ▁; ▁i ▁++ ▁) ▁pass ▁. ▁push _ back ▁( ▁res ▁[ ▁i ▁] ▁) ▁; ▁vector ▁< ▁int ▁> ▁ans ▁= ▁bubble _ sort ▁( ▁pass ▁) ▁; ▁ans ▁. ▁push _ back ▁( ▁res ▁[ ▁res ▁. ▁size ▁( ▁) ▁- ▁1 ▁] ▁) ▁; ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁int ▁> ▁arr ▁{ ▁1 ▁, ▁3
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁solution ▁( ▁int ▁A ▁, ▁int ▁B ▁, ▁int ▁C ▁) ▁{ ▁int ▁arr ▁[ ▁3 ▁] ▁; ▁arr ▁[ ▁0 ▁] ▁= ▁A ▁, ▁arr ▁[ ▁1 ▁] ▁= ▁B ▁, ▁arr ▁[ ▁2 ▁] ▁= ▁C ▁; ▁sort ▁( ▁arr ▁, ▁arr ▁+ ▁3 ▁) ▁; ▁if ▁( ▁arr ▁[ ▁2 ▁] ▁< ▁arr ▁[ ▁0 ▁] ▁+ ▁arr ▁[ ▁1 ▁] ▁) ▁return ▁( ▁( ▁arr ▁[ ▁0 ▁] ▁+ ▁arr ▁[ ▁1 ▁] ▁+ ▁arr ▁[ ▁2 ▁] ▁) ▁/ ▁2 ▁) ▁; ▁else ▁return ▁( ▁arr ▁[ ▁0 ▁] ▁+ ▁arr ▁[ ▁1 ▁] ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁= ▁8 ▁, ▁B ▁= ▁1 ▁, ▁C ▁= ▁5 ▁; ▁c out ▁<< ▁solution ▁( ▁A ▁, ▁B ▁, ▁C ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max _ length ▁= ▁0 ▁; ▁vector ▁< ▁int ▁> ▁store ▁; ▁vector ▁< ▁int ▁> ▁ans ▁; ▁void ▁find _ max _ length ▁( ▁vector ▁< ▁int ▁> ▁& ▁arr ▁, ▁int ▁index ▁, ▁int ▁sum ▁, ▁int ▁k ▁) ▁{ ▁sum ▁= ▁sum ▁+ ▁arr ▁[ ▁index ▁] ▁; ▁store ▁. ▁push _ back ▁( ▁arr ▁[ ▁index ▁] ▁) ▁; ▁if ▁( ▁sum ▁== ▁k ▁) ▁{ ▁if ▁( ▁max _ length ▁< ▁store ▁. ▁size ▁( ▁) ▁) ▁{ ▁max _ length ▁= ▁store ▁. ▁size ▁( ▁) ▁; ▁ans ▁= ▁store ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁index ▁+ ▁1 ▁; ▁i ▁< ▁arr ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁sum ▁+ ▁arr ▁[ ▁i ▁] ▁<= ▁k ▁) ▁{ ▁find _ max _ length ▁( ▁arr ▁, ▁i ▁, ▁sum ▁, ▁k ▁) ▁; ▁store ▁. ▁pop _ back ▁( ▁) ▁; ▁} ▁else ▁return ▁; ▁} ▁return ▁; ▁} ▁int ▁longest Sub sequence ▁( ▁vector ▁< ▁int ▁> ▁arr ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁sort ▁( ▁arr ▁. ▁begin ▁( ▁) ▁, ▁arr ▁. ▁end ▁( ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁max _ length ▁>= ▁n ▁- ▁i ▁) ▁break ▁; ▁store ▁. ▁clear ▁( ▁) ▁; ▁find _ max _ length ▁( ▁arr ▁, ▁i ▁, ▁0 ▁, ▁k ▁) ▁; ▁} ▁return ▁max _ length ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁int ▁> ▁arr ▁{ ▁-3 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁size ▁( ▁) ▁; ▁int ▁k ▁= ▁1 ▁; ▁c out ▁<< ▁longest Sub sequence ▁( ▁arr ▁, ▁n ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁getNumber ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁pos ▁; ▁if ▁( ▁n ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁pos ▁= ▁n ▁/ ▁2 ▁; ▁} ▁else ▁{ ▁pos ▁= ▁( ▁n ▁/ ▁2 ▁) ▁+ ▁1 ▁; ▁} ▁if ▁( ▁k ▁<= ▁pos ▁) ▁{ ▁return ▁( ▁k ▁* ▁2 ▁- ▁1 ▁) ▁; ▁} ▁else ▁return ▁( ▁( ▁k ▁- ▁pos ▁) ▁* ▁2 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁8 ▁, ▁k ▁= ▁5 ▁; ▁c out ▁<< ▁getNumber ▁( ▁n ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Sequ ences ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁count ▁= ▁1 ▁; ▁sort ▁( ▁arr ▁, ▁arr ▁+ ▁n ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁if ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁1 ▁!= ▁arr ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁count ▁++ ▁; ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁7 ▁, ▁3 ▁, ▁5 ▁, ▁10 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁count Sequ ences ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁check Fit ting Arrays ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁B ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁sort ▁( ▁A ▁, ▁A ▁+ ▁N ▁) ▁; ▁sort ▁( ▁B ▁, ▁B ▁+ ▁N ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁if ▁( ▁A ▁[ ▁i ▁] ▁> ▁B ▁[ ▁i ▁] ▁) ▁return ▁false ▁; ▁return ▁true ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁7 ▁, ▁5 ▁, ▁3 ▁, ▁2 ▁} ▁; ▁int ▁B ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁4 ▁, ▁8 ▁, ▁7 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁A ▁) ▁/ ▁sizeof ▁( ▁A ▁[ ▁0 ▁] ▁) ▁; ▁if ▁( ▁check Fit ting Arrays ▁( ▁A ▁, ▁B ▁, ▁N ▁) ▁) ▁c out ▁<< ▁" ▁YES ▁" ▁; ▁else ▁c out ▁<< ▁" ▁NO ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁stable Selection Sort ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁int ▁min ▁= ▁i ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁if ▁( ▁a ▁[ ▁min ▁] ▁> ▁a ▁[ ▁j ▁] ▁) ▁min ▁= ▁j ▁; ▁int ▁key ▁= ▁a ▁[ ▁min ▁] ▁; ▁while ▁( ▁min ▁> ▁i ▁) ▁{ ▁a ▁[ ▁min ▁] ▁= ▁a ▁[ ▁min ▁- ▁1 ▁] ▁; ▁min ▁-- ▁; ▁} ▁a ▁[ ▁i ▁] ▁= ▁key ▁; ▁} ▁} ▁void ▁print Array ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁a ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁c out ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁5 ▁, ▁3 ▁, ▁2 ▁, ▁4 ▁, ▁1 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁stable Selection Sort ▁( ▁a ▁, ▁n ▁) ▁; ▁print Array ▁( ▁a ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁flip ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁i ▁) ▁{ ▁int ▁temp ▁, ▁start ▁= ▁0 ▁; ▁while ▁( ▁start ▁< ▁i ▁) ▁{ ▁temp ▁= ▁arr ▁[ ▁start ▁] ▁; ▁arr ▁[ ▁start ▁] ▁= ▁arr ▁[ ▁i ▁] ▁; ▁arr ▁[ ▁i ▁] ▁= ▁temp ▁; ▁start ▁++ ▁; ▁i ▁-- ▁; ▁} ▁} ▁int ▁find Max ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁mi ▁, ▁i ▁; ▁for ▁( ▁mi ▁= ▁0 ▁, ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁arr ▁[ ▁mi ▁] ▁) ▁mi ▁= ▁i ▁; ▁return ▁mi ▁; ▁} ▁void ▁p anc ake Sort ▁( ▁int ▁* ▁arr ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁curr _ size ▁= ▁n ▁; ▁curr _ size ▁> ▁1 ▁; ▁-- ▁curr _ size ▁) ▁{ ▁int ▁mi ▁= ▁find Max ▁( ▁arr ▁, ▁curr _ size ▁) ▁; ▁if ▁( ▁mi ▁!= ▁curr _ size ▁- ▁1 ▁) ▁{ ▁flip ▁( ▁arr ▁, ▁mi ▁) ▁; ▁flip ▁( ▁arr ▁, ▁curr _ size ▁- ▁1 ▁) ▁; ▁} ▁} ▁} ▁void ▁print Array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁23 ▁, ▁10 ▁, ▁20 ▁, ▁11 ▁, ▁12 ▁, ▁6 ▁, ▁7 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁p anc ake Sort ▁( ▁arr ▁, ▁n ▁) ▁; ▁c out ▁<< ▁" ▁Sorted ▁Array ▁" ▁<< ▁end l ▁; ▁print Array ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find Array With Max Product ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁if ▁( ▁arr ▁[ ▁i ▁] ▁>= ▁0 ▁) ▁{ ▁arr ▁[ ▁i ▁] ▁= ▁- ▁arr ▁[ ▁i ▁] ▁- ▁1 ▁; ▁} ▁if ▁( ▁N ▁% ▁2 ▁== ▁1 ▁) ▁{ ▁int ▁max _ element ▁= ▁-1 ▁; ▁int ▁index ▁= ▁-1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁if ▁( ▁abs ▁( ▁arr ▁[ ▁i ▁] ▁) ▁> ▁max _ element ▁) ▁{ ▁max _ element ▁= ▁abs ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁index ▁= ▁i ▁; ▁} ▁arr ▁[ ▁index ▁] ▁= ▁- ▁arr ▁[ ▁index ▁] ▁- ▁1 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁printf ▁( ▁" ▁% ▁d ▁" ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁-3 ▁, ▁0 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁find Array With Max Product ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁int ▁N ▁= ▁1 e 5 ▁+ ▁5 ▁; ▁int ▁visited ▁[ ▁N ▁] ▁; ▁void ▁construct _ tree ▁( ▁int ▁weights ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁minimum ▁= ▁* ▁min _ element ▁( ▁weights ▁, ▁weights ▁+ ▁n ▁) ▁; ▁int ▁maximum ▁= ▁* ▁max _ element ▁( ▁weights ▁, ▁weights ▁+ ▁n ▁) ▁; ▁if ▁( ▁minimum ▁== ▁maximum ▁) ▁{ ▁c out ▁<< ▁" ▁No ▁" ▁; ▁return ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁" ▁Yes ▁" ▁<< ▁end l ▁; ▁} ▁int ▁root ▁= ▁weights ▁[ ▁0 ▁] ▁; ▁visited ▁[ ▁1 ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁weights ▁[ ▁i ▁] ▁!= ▁root ▁&& ▁visited ▁[ ▁i ▁+ ▁1 ▁] ▁== ▁0 ▁) ▁{ ▁c out ▁<< ▁1 ▁<< ▁" ▁" ▁<< ▁i ▁+ ▁1 ▁<< ▁" ▁" ▁<< ▁end l ▁; ▁visited ▁[ ▁i ▁+ ▁1 ▁] ▁= ▁1 ▁; ▁} ▁} ▁int ▁not root ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁weights ▁[ ▁i ▁] ▁!= ▁root ▁) ▁{ ▁not root ▁= ▁i ▁+ ▁1 ▁; ▁break ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁weights ▁[ ▁i ▁] ▁== ▁root ▁&& ▁visited ▁[ ▁i ▁+ ▁1 ▁] ▁== ▁0 ▁) ▁{ ▁c out ▁<< ▁not root ▁<< ▁" ▁" ▁<< ▁i ▁+ ▁1 ▁<< ▁end l ▁; ▁visited ▁[ ▁i ▁+ ▁1 ▁] ▁= ▁1 ▁; ▁} ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁weights ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁1 ▁, ▁2 ▁, ▁5 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁weights ▁) ▁/ ▁sizeof ▁( ▁weights ▁[ ▁0 ▁] ▁) ▁; ▁construct _ tree ▁( ▁weights ▁, ▁N ▁) ▁; ▁}
▁# include ▁" ▁bits ▁/ ▁std c ▁+ ▁+ ▁. ▁h ▁" ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁addEdge ▁( ▁vector ▁< ▁int ▁> ▁adj ▁[ ▁] ▁, ▁int ▁u ▁, ▁int ▁v ▁) ▁{ ▁adj ▁[ ▁u ▁] ▁. ▁push _ back ▁( ▁v ▁) ▁; ▁adj ▁[ ▁v ▁] ▁. ▁push _ back ▁( ▁u ▁) ▁; ▁} ▁void ▁DFS ▁( ▁int ▁u ▁, ▁vector ▁< ▁int ▁> ▁adj ▁[ ▁] ▁, ▁int ▁& ▁cnt ▁, ▁vector ▁< ▁bool ▁> ▁& ▁visited ▁, ▁int ▁fre ▁[ ▁] ▁, ▁string ▁S ▁) ▁{ ▁visited ▁[ ▁u ▁] ▁= ▁true ▁; ▁cnt ▁++ ▁; ▁fre ▁[ ▁S ▁[ ▁u ▁] ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁adj ▁[ ▁u ▁] ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁! ▁visited ▁[ ▁adj ▁[ ▁u ▁] ▁[ ▁i ▁] ▁] ▁) ▁{ ▁DFS ▁( ▁adj ▁[ ▁u ▁] ▁[ ▁i ▁] ▁, ▁adj ▁, ▁cnt ▁, ▁visited ▁, ▁fre ▁, ▁S ▁) ▁; ▁} ▁} ▁} ▁int ▁minimum Operations ▁( ▁string ▁& ▁S ▁, ▁int ▁m ▁) ▁{ ▁int ▁V ▁= ▁100 ▁; ▁vector ▁< ▁int ▁> ▁adj ▁[ ▁V ▁] ▁; ▁int ▁total ▁= ▁0 ▁, ▁N ▁= ▁S ▁. ▁length ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁addEdge ▁( ▁adj ▁, ▁i ▁, ▁N ▁- ▁i ▁- ▁1 ▁) ▁; ▁addEdge ▁( ▁adj ▁, ▁N ▁- ▁i ▁- ▁1 ▁, ▁i ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁- ▁m ▁; ▁i ▁++ ▁) ▁{ ▁addEdge ▁( ▁adj ▁, ▁i ▁, ▁i ▁+ ▁m ▁) ▁; ▁addEdge ▁( ▁adj ▁, ▁i ▁+ ▁m ▁, ▁i ▁) ▁; ▁} ▁vector ▁< ▁bool ▁> ▁visited ▁( ▁V ▁, ▁0 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁! ▁visited ▁[ ▁i ▁] ▁) ▁{ ▁int ▁fre ▁[ ▁26 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁int ▁cnt ▁= ▁0 ▁, ▁max x ▁= ▁-1 ▁; ▁DFS ▁( ▁i ▁, ▁adj ▁, ▁cnt ▁, ▁visited ▁, ▁fre ▁, ▁S ▁) ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁26 ▁; ▁j ▁++ ▁) ▁max x ▁= ▁max ▁( ▁max x ▁, ▁fre ▁[ ▁j ▁] ▁) ▁; ▁total
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁clear Last Bit ▁( ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁int ▁mask ▁= ▁( ▁-1 ▁<< ▁K ▁+ ▁1 ▁) ▁; ▁return ▁N ▁= ▁N ▁& ▁mask ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁7 30 ▁, ▁K ▁= ▁3 ▁; ▁c out ▁<< ▁clear Last Bit ▁( ▁N ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁isP ossible ▁( ▁int ▁r ▁, ▁int ▁b ▁, ▁int ▁g ▁) ▁{ ▁r ▁= ▁r ▁% ▁3 ▁; ▁b ▁= ▁b ▁% ▁3 ▁; ▁g ▁= ▁g ▁% ▁3 ▁; ▁if ▁( ▁r ▁== ▁b ▁b ▁== ▁g ▁g ▁== ▁r ▁) ▁{ ▁return ▁true ▁; ▁} ▁else ▁{ ▁return ▁false ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁R ▁= ▁1 ▁, ▁B ▁= ▁3 ▁, ▁G ▁= ▁6 ▁; ▁if ▁( ▁isP ossible ▁( ▁R ▁, ▁B ▁, ▁G ▁) ▁) ▁{ ▁c out ▁<< ▁" ▁Yes ▁" ▁<< ▁end l ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁" ▁No ▁" ▁<< ▁end l ▁; ▁} ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁unsigned ▁int ▁count Set Bits Util ▁( ▁unsigned ▁int ▁x ▁) ▁{ ▁if ▁( ▁x ▁<= ▁0 ▁) ▁return ▁0 ▁; ▁return ▁( ▁( ▁x ▁% ▁2 ▁== ▁0 ▁? ▁0 ▁: ▁1 ▁) ▁+ ▁count Set Bits Util ▁( ▁x ▁/ ▁2 ▁) ▁) ▁; ▁} ▁unsigned ▁int ▁count Set Bits ▁( ▁unsigned ▁int ▁L ▁, ▁unsigned ▁int ▁R ▁) ▁{ ▁int ▁bit Count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁L ▁; ▁i ▁<= ▁R ▁; ▁i ▁++ ▁) ▁{ ▁bit Count ▁+= ▁count Set Bits Util ▁( ▁i ▁) ▁; ▁} ▁return ▁bit Count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁L ▁= ▁3 ▁, ▁R ▁= ▁5 ▁; ▁printf ▁( ▁" ▁Total ▁set ▁bit ▁count ▁is ▁% ▁d ▁" ▁, ▁count Set Bits ▁( ▁L ▁, ▁R ▁) ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁getMin Cost ▁( ▁vector ▁< ▁int ▁> ▁A ▁, ▁vector ▁< ▁int ▁> ▁B ▁, ▁int ▁N ▁) ▁{ ▁int ▁mini ▁= ▁INT _ MAX ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁mini ▁= ▁min ▁( ▁mini ▁, ▁min ▁( ▁A ▁[ ▁i ▁] ▁, ▁B ▁[ ▁i ▁] ▁) ▁) ▁; ▁} ▁return ▁mini ▁* ▁( ▁2 ▁* ▁N ▁- ▁1 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁3 ▁; ▁vector ▁< ▁int ▁> ▁A ▁= ▁{ ▁1 ▁, ▁4 ▁, ▁2 ▁} ▁; ▁vector ▁< ▁int ▁> ▁B ▁= ▁{ ▁10 ▁, ▁6 ▁, ▁12 ▁} ▁; ▁c out ▁<< ▁getMin Cost ▁( ▁A ▁, ▁B ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find M ▁( ▁int ▁N ▁) ▁{ ▁int ▁M ▁= ▁0 ▁; ▁int ▁MS B ▁= ▁( ▁int ▁) ▁log 2 ▁( ▁N ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁MS B ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁! ▁( ▁N ▁& ▁( ▁1 ▁<< ▁i ▁) ▁) ▁) ▁M ▁+= ▁( ▁1 ▁<< ▁i ▁) ▁; ▁} ▁return ▁M ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁6 ▁; ▁c out ▁<< ▁find M ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max Mod ul os um ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁a ▁[ ▁i ▁] ▁; ▁} ▁return ▁sum ▁- ▁n ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁4 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁max Mod ul os um ▁( ▁a ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁make Zero ▁( ▁int ▁x ▁, ▁int ▁y ▁, ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁if ▁( ▁x ▁> ▁y ▁) ▁x ▁= ▁y ▁, ▁y ▁= ▁x ▁; ▁int ▁tot _ cost ▁= ▁( ▁y ▁- ▁x ▁) ▁* ▁a ▁; ▁int ▁cost 1 ▁= ▁2 ▁* ▁x ▁* ▁a ▁; ▁int ▁cost 2 ▁= ▁x ▁* ▁b ▁; ▁tot _ cost ▁+= ▁min ▁( ▁cost 1 ▁, ▁cost 2 ▁) ▁; ▁c out ▁<< ▁tot _ cost ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁X ▁= ▁1 ▁, ▁Y ▁= ▁3 ▁; ▁int ▁cost 1 ▁= ▁3 91 ▁, ▁cost 2 ▁= ▁5 55 ▁; ▁make Zero ▁( ▁X ▁, ▁Y ▁, ▁cost 1 ▁, ▁cost 2 ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁split Fraction ▁( ▁int ▁n ▁, ▁int ▁d ▁) ▁{ ▁int ▁ar ▁[ ▁n ▁] ▁; ▁int ▁first ▁= ▁d ▁+ ▁n ▁- ▁1 ▁; ▁ar ▁[ ▁0 ▁] ▁= ▁first ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁temp ▁= ▁-- ▁first ▁; ▁first ▁++ ▁; ▁ar ▁[ ▁i ▁] ▁= ▁first ▁* ▁temp ▁; ▁-- ▁first ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁ar ▁[ ▁i ▁] ▁% ▁n ▁== ▁0 ▁) ▁{ ▁c out ▁<< ▁"1 ▁/ ▁" ▁<< ▁ar ▁[ ▁i ▁] ▁/ ▁n ▁<< ▁" ▁, ▁" ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁n ▁<< ▁" ▁/ ▁" ▁<< ▁ar ▁[ ▁i ▁] ▁<< ▁" ▁, ▁" ▁; ▁} ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁4 ▁; ▁int ▁D ▁= ▁2 ▁; ▁split Fraction ▁( ▁N ▁, ▁D ▁) ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Minimum Sub sequences ▁( ▁string ▁A ▁, ▁string ▁B ▁) ▁{ ▁int ▁numberOf Sub sequences ▁= ▁1 ▁; ▁int ▁sizeOf B ▁= ▁B ▁. ▁size ▁( ▁) ▁; ▁int ▁sizeOf A ▁= ▁A ▁. ▁size ▁( ▁) ▁; ▁int ▁inf ▁= ▁1000000 ▁; ▁int ▁next ▁[ ▁26 ▁] ▁[ ▁sizeOf B ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁26 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁sizeOf B ▁; ▁j ▁++ ▁) ▁{ ▁next ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁inf ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁sizeOf B ▁; ▁i ▁++ ▁) ▁{ ▁next ▁[ ▁B ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁] ▁[ ▁i ▁] ▁= ▁i ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁26 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁sizeOf B ▁- ▁2 ▁; ▁j ▁>= ▁0 ▁; ▁j ▁-- ▁) ▁{ ▁if ▁( ▁next ▁[ ▁i ▁] ▁[ ▁j ▁] ▁== ▁inf ▁) ▁{ ▁next ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁next ▁[ ▁i ▁] ▁[ ▁j ▁+ ▁1 ▁] ▁; ▁} ▁} ▁} ▁int ▁pos ▁= ▁0 ▁; ▁int ▁i ▁= ▁0 ▁; ▁while ▁( ▁i ▁< ▁sizeOf A ▁) ▁{ ▁if ▁( ▁pos ▁== ▁0 ▁&& ▁next ▁[ ▁A ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁] ▁[ ▁pos ▁] ▁== ▁inf ▁) ▁{ ▁numberOf Sub sequences ▁= ▁-1 ▁; ▁break ▁; ▁} ▁else ▁if ▁( ▁pos ▁< ▁sizeOf B ▁&& ▁next ▁[ ▁A ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁] ▁[ ▁pos ▁] ▁< ▁inf ▁) ▁{ ▁int ▁nextIndex ▁= ▁next ▁[ ▁A ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁] ▁[ ▁pos ▁] ▁+ ▁1 ▁; ▁pos ▁= ▁nextIndex ▁; ▁i ▁++ ▁; ▁} ▁else ▁{ ▁numberOf Sub sequences ▁++ ▁; ▁pos ▁= ▁0 ▁; ▁} ▁} ▁return ▁numberOf Sub sequences ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁A ▁= ▁" ▁a ac be ▁" ▁; ▁string ▁B ▁= ▁" ▁ace ab ▁" ▁; ▁c out ▁<< ▁find Minimum Sub sequences ▁( ▁A ▁, ▁B ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count _ minimum _ operations ▁( ▁long ▁long ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁2 ▁) ▁{ ▁return ▁1 ▁; ▁} ▁else ▁if ▁( ▁n ▁== ▁1 ▁) ▁{ ▁return ▁0 ▁; ▁} ▁if ▁( ▁n ▁% ▁3 ▁== ▁0 ▁) ▁{ ▁return ▁1 ▁+ ▁count _ minimum _ operations ▁( ▁n ▁/ ▁3 ▁) ▁; ▁} ▁else ▁if ▁( ▁n ▁% ▁3 ▁== ▁1 ▁) ▁{ ▁return ▁1 ▁+ ▁count _ minimum _ operations ▁( ▁n ▁- ▁1 ▁) ▁; ▁} ▁else ▁{ ▁return ▁1 ▁+ ▁count _ minimum _ operations ▁( ▁n ▁+ ▁1 ▁) ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁long ▁long ▁n ▁= ▁4 ▁; ▁long ▁long ▁ans ▁= ▁count _ minimum _ operations ▁( ▁n ▁) ▁; ▁c out ▁<< ▁ans ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁problems Left ▁( ▁int ▁K ▁, ▁int ▁P ▁, ▁int ▁N ▁) ▁{ ▁if ▁( ▁K ▁<= ▁P ▁) ▁return ▁0 ▁; ▁else ▁return ▁( ▁K ▁- ▁P ▁) ▁* ▁N ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁K ▁, ▁P ▁, ▁N ▁; ▁K ▁= ▁4 ▁; ▁P ▁= ▁1 ▁; ▁N ▁= ▁10 ▁; ▁c out ▁<< ▁problems Left ▁( ▁K ▁, ▁P ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁V ▁5 ▁NEW _ LINE ▁int ▁parent ▁[ ▁V ▁] ▁; ▁int ▁find ▁( ▁int ▁i ▁) ▁{ ▁while ▁( ▁parent ▁[ ▁i ▁] ▁!= ▁i ▁) ▁i ▁= ▁parent ▁[ ▁i ▁] ▁; ▁return ▁i ▁; ▁} ▁void ▁union 1 ▁( ▁int ▁i ▁, ▁int ▁j ▁) ▁{ ▁int ▁a ▁= ▁find ▁( ▁i ▁) ▁; ▁int ▁b ▁= ▁find ▁( ▁j ▁) ▁; ▁parent ▁[ ▁a ▁] ▁= ▁b ▁; ▁} ▁void ▁k r us k al M ST ▁( ▁int ▁cost ▁[ ▁] ▁[ ▁V ▁] ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁V ▁; ▁i ▁++ ▁) ▁parent ▁[ ▁i ▁] ▁= ▁i ▁; ▁int ▁edge _ count ▁= ▁0 ▁; ▁while ▁( ▁edge _ count ▁< ▁V ▁- ▁1 ▁) ▁{ ▁int ▁min ▁= ▁INT _ MAX ▁, ▁a ▁= ▁-1 ▁, ▁b ▁= ▁-1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁V ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁V ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁find ▁( ▁i ▁) ▁!= ▁find ▁( ▁j ▁) ▁&& ▁cost ▁[ ▁i ▁] ▁[ ▁j ▁] ▁< ▁min ▁) ▁{ ▁min ▁= ▁cost ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁a ▁= ▁i ▁; ▁b ▁= ▁j ▁; ▁} ▁} ▁} ▁union 1 ▁( ▁a ▁, ▁b ▁) ▁; ▁printf ▁( ▁" ▁Edge ▁% ▁d ▁: ▁( ▁% ▁d ▁, ▁% ▁d ▁) ▁cost ▁: ▁% ▁d ▁STRNEWLINE ▁" ▁, ▁edge _ count ▁++ ▁, ▁a ▁, ▁b ▁, ▁min ▁) ▁; ▁min cost ▁+= ▁min ▁; ▁} ▁printf ▁( ▁" ▁Minimum ▁cost ▁= ▁% ▁d ▁" ▁, ▁min cost ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁cost ▁[ ▁] ▁[ ▁V ▁] ▁= ▁{ ▁{ ▁INT _ MAX ▁, ▁2 ▁, ▁INT _ MAX ▁, ▁6 ▁, ▁INT _ MAX ▁} ▁, ▁{ ▁2 ▁, ▁INT _ MAX ▁, ▁3 ▁, ▁8 ▁, ▁5 ▁} ▁, ▁{ ▁INT _ MAX ▁, ▁3 ▁, ▁INT _ MAX ▁, ▁INT _ MAX ▁, ▁7 ▁} ▁, ▁{ ▁6 ▁, ▁8 ▁, ▁INT _ MAX ▁, ▁INT _ MAX ▁, ▁9 ▁} ▁, ▁{ ▁INT _ MAX ▁, ▁5 ▁, ▁7 ▁, ▁9 ▁, ▁INT _ MAX ▁} ▁, ▁} ▁; ▁k r
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Min Cost ▁( ▁pair ▁< ▁int ▁, ▁int ▁> ▁arr ▁[ ▁] ▁, ▁int ▁X ▁, ▁int ▁n ▁, ▁int ▁i ▁= ▁0 ▁) ▁{ ▁if ▁( ▁X ▁<= ▁0 ▁) ▁return ▁0 ▁; ▁if ▁( ▁i ▁>= ▁n ▁) ▁return ▁INT _ MAX ▁; ▁int ▁inc ▁= ▁find Min Cost ▁( ▁arr ▁, ▁X ▁- ▁arr ▁[ ▁i ▁] ▁. ▁first ▁, ▁n ▁, ▁i ▁+ ▁1 ▁) ▁; ▁if ▁( ▁inc ▁!= ▁INT _ MAX ▁) ▁inc ▁+= ▁arr ▁[ ▁i ▁] ▁. ▁second ▁; ▁int ▁exc ▁= ▁find Min Cost ▁( ▁arr ▁, ▁X ▁, ▁n ▁, ▁i ▁+ ▁1 ▁) ▁; ▁return ▁min ▁( ▁inc ▁, ▁exc ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁pair ▁< ▁int ▁, ▁int ▁> ▁arr ▁[ ▁] ▁= ▁{ ▁{ ▁4 ▁, ▁3 ▁} ▁, ▁{ ▁3 ▁, ▁2 ▁} ▁, ▁{ ▁2 ▁, ▁4 ▁} ▁, ▁{ ▁1 ▁, ▁3 ▁} ▁, ▁{ ▁4 ▁, ▁2 ▁} ▁} ▁; ▁int ▁X ▁= ▁7 ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁ans ▁= ▁find Min Cost ▁( ▁arr ▁, ▁X ▁, ▁n ▁) ▁; ▁if ▁( ▁ans ▁!= ▁INT _ MAX ▁) ▁c out ▁<< ▁ans ▁; ▁else ▁c out ▁<< ▁-1 ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁map ▁< ▁string ▁, ▁int ▁> ▁dp ▁; ▁int ▁max Score ▁( ▁string ▁s ▁, ▁vector ▁< ▁int ▁> ▁a ▁) ▁{ ▁if ▁( ▁dp ▁. ▁find ▁( ▁s ▁) ▁!= ▁dp ▁. ▁end ▁( ▁) ▁) ▁return ▁dp ▁[ ▁s ▁] ▁; ▁int ▁n ▁= ▁s ▁. ▁size ▁( ▁) ▁; ▁if ▁( ▁n ▁== ▁0 ▁) ▁return ▁0 ▁; ▁if ▁( ▁n ▁== ▁1 ▁) ▁return ▁a ▁[ ▁0 ▁] ▁; ▁int ▁head ▁= ▁0 ▁; ▁int ▁mx ▁= ▁-1 ▁; ▁while ▁( ▁head ▁< ▁n ▁) ▁{ ▁int ▁tail ▁= ▁head ▁; ▁while ▁( ▁tail ▁< ▁n ▁) ▁{ ▁if ▁( ▁s ▁[ ▁tail ▁] ▁!= ▁s ▁[ ▁head ▁] ▁) ▁{ ▁head ▁= ▁tail ▁; ▁break ▁; ▁} ▁string ▁sub ▁= ▁s ▁. ▁substr ▁( ▁head ▁, ▁tail ▁+ ▁1 ▁) ▁; ▁mx ▁= ▁max ▁( ▁mx ▁, ▁a ▁[ ▁sub ▁. ▁size ▁( ▁) ▁- ▁1 ▁] ▁+ ▁max Score ▁( ▁s ▁. ▁substr ▁( ▁0 ▁, ▁head ▁) ▁+ ▁s ▁. ▁substr ▁( ▁tail ▁+ ▁1 ▁, ▁s ▁. ▁size ▁( ▁) ▁) ▁, ▁a ▁) ▁) ▁; ▁tail ▁+= ▁1 ▁; ▁} ▁if ▁( ▁tail ▁== ▁n ▁) ▁break ▁; ▁} ▁dp ▁[ ▁s ▁] ▁= ▁mx ▁; ▁return ▁mx ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁" ▁ab b ▁" ▁; ▁vector ▁< ▁int ▁> ▁a ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁1 ▁} ▁; ▁c out ▁<< ▁( ▁max Score ▁( ▁s ▁, ▁a ▁) ▁- ▁1 ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁k ad ane ▁( ▁vector ▁< ▁int ▁> ▁v ▁) ▁{ ▁int ▁curr Sum ▁= ▁0 ▁; ▁int ▁max Sum ▁= ▁INT _ MIN ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁( ▁int ▁) ▁v ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁curr Sum ▁+= ▁v ▁[ ▁i ▁] ▁; ▁if ▁( ▁curr Sum ▁> ▁max Sum ▁) ▁{ ▁max Sum ▁= ▁curr Sum ▁; ▁} ▁if ▁( ▁curr Sum ▁< ▁0 ▁) ▁{ ▁curr Sum ▁= ▁0 ▁; ▁} ▁} ▁return ▁max Sum ▁; ▁} ▁void ▁max Sub matrix Sum ▁( ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁A ▁) ▁{ ▁int ▁r ▁= ▁A ▁. ▁size ▁( ▁) ▁; ▁int ▁c ▁= ▁A ▁[ ▁0 ▁] ▁. ▁size ▁( ▁) ▁; ▁int ▁* ▁* ▁prefix ▁= ▁new ▁int ▁* ▁[ ▁r ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁r ▁; ▁i ▁++ ▁) ▁{ ▁prefix ▁[ ▁i ▁] ▁= ▁new ▁int ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁c ▁; ▁j ▁++ ▁) ▁{ ▁prefix ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁0 ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁r ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁c ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁j ▁== ▁0 ▁) ▁prefix ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁A ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁else ▁prefix ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁A ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+ ▁prefix ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁; ▁} ▁} ▁int ▁max Sum ▁= ▁INT _ MIN ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁c ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁< ▁c ▁; ▁j ▁++ ▁) ▁{ ▁vector ▁< ▁int ▁> ▁v ▁; ▁for ▁( ▁int ▁k ▁= ▁0 ▁; ▁k ▁< ▁r ▁; ▁k ▁++ ▁) ▁{ ▁int ▁el ▁= ▁0 ▁; ▁if ▁( ▁i ▁== ▁0 ▁) ▁el ▁= ▁prefix ▁[ ▁k ▁] ▁[ ▁j ▁] ▁; ▁else ▁el ▁= ▁prefix ▁[ ▁k ▁] ▁[ ▁j ▁] ▁- ▁prefix ▁[ ▁k ▁] ▁[ ▁i ▁- ▁1 ▁] ▁; ▁v ▁. ▁push _ back ▁( ▁el ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁number of pairs ▁( ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁v ▁, ▁int ▁k ▁) ▁{ ▁int ▁n ▁= ▁v ▁. ▁size ▁( ▁) ▁; ▁if ▁( ▁n ▁% ▁2 ▁== ▁1 ▁) ▁{ ▁c out ▁<< ▁0 ▁; ▁return ▁; ▁} ▁int ▁ans ▁= ▁0 ▁; ▁int ▁dp ▁[ ▁k ▁] ▁[ ▁2 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁k ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁2 ▁; ▁j ▁++ ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁0 ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁( ▁i ▁+ ▁j ▁) ▁% ▁2 ▁== ▁0 ▁) ▁dp ▁[ ▁v ▁[ ▁i ▁] ▁[ ▁j ▁] ▁- ▁1 ▁] ▁[ ▁0 ▁] ▁++ ▁; ▁else ▁dp ▁[ ▁v ▁[ ▁i ▁] ▁[ ▁j ▁] ▁- ▁1 ▁] ▁[ ▁1 ▁] ▁++ ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁k ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁k ▁; ▁j ▁++ ▁) ▁{ ▁ans ▁+= ▁dp ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁* ▁dp ▁[ ▁j ▁] ▁[ ▁1 ▁] ▁; ▁ans ▁+= ▁dp ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁* ▁dp ▁[ ▁j ▁] ▁[ ▁0 ▁] ▁; ▁} ▁} ▁c out ▁<< ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁mat ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁} ▁, ▁{ ▁3 ▁, ▁4 ▁} ▁} ▁; ▁int ▁K ▁= ▁4 ▁; ▁number of pairs ▁( ▁mat ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Max G CD ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁high ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁high ▁= ▁max ▁( ▁high ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁int ▁count ▁[ ▁high ▁+ ▁1 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁count ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁+= ▁1 ▁; ▁} ▁int ▁counter ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁high ▁; ▁i ▁> ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁int ▁j ▁= ▁i ▁; ▁while ▁( ▁j ▁<= ▁high ▁) ▁{ ▁if ▁( ▁count ▁[ ▁j ▁] ▁> ▁0 ▁) ▁counter ▁+= ▁count ▁[ ▁j ▁] ▁; ▁j ▁+= ▁i ▁; ▁if ▁( ▁counter ▁== ▁2 ▁) ▁return ▁i ▁; ▁} ▁counter ▁= ▁0 ▁; ▁} ▁} ▁int ▁maxlen ▁( ▁int ▁i ▁, ▁int ▁j ▁, ▁int ▁arr ▁[ ▁] ▁, ▁int ▁arr 1 ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁max g cd ▁) ▁{ ▁int ▁a ▁= ▁1 ▁; ▁if ▁( ▁i ▁>= ▁N ▁or ▁j ▁>= ▁N ▁) ▁return ▁0 ▁; ▁if ▁( ▁__ g cd ▁( ▁arr ▁[ ▁i ▁] ▁, ▁arr 1 ▁[ ▁j ▁] ▁) ▁== ▁max g cd ▁&& ▁arr ▁[ ▁i ▁] ▁!= ▁arr 1 ▁[ ▁j ▁] ▁) ▁{ ▁a ▁= ▁max ▁( ▁a ▁, ▁1 ▁+ ▁maxlen ▁( ▁i ▁, ▁j ▁+ ▁1 ▁, ▁arr ▁, ▁arr 1 ▁, ▁N ▁, ▁max g cd ▁) ▁) ▁; ▁return ▁a ▁; ▁} ▁return ▁max ▁( ▁maxlen ▁( ▁i ▁+ ▁1 ▁, ▁j ▁, ▁arr ▁, ▁arr 1 ▁, ▁N ▁, ▁max g cd ▁) ▁, ▁maxlen ▁( ▁i ▁, ▁j ▁+ ▁1 ▁, ▁arr ▁, ▁arr 1 ▁, ▁N ▁, ▁max g cd ▁) ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁8 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁int ▁arr 1 ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁8 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁sort ▁( ▁arr ▁, ▁arr ▁+ ▁n ▁) ▁; ▁sort ▁( ▁arr 1 ▁,
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find W ays ▁( ▁int ▁N ▁, ▁int ▁dp ▁[ ▁] ▁) ▁{ ▁if ▁( ▁N ▁== ▁0 ▁) ▁{ ▁return ▁1 ▁; ▁} ▁if ▁( ▁dp ▁[ ▁N ▁] ▁!= ▁-1 ▁) ▁{ ▁return ▁dp ▁[ ▁N ▁] ▁; ▁} ▁int ▁cnt ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁6 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁N ▁- ▁i ▁>= ▁0 ▁) ▁{ ▁cnt ▁= ▁cnt ▁+ ▁find W ays ▁( ▁N ▁- ▁i ▁, ▁dp ▁) ▁; ▁} ▁} ▁return ▁dp ▁[ ▁N ▁] ▁= ▁cnt ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁4 ▁; ▁int ▁dp ▁[ ▁N ▁+ ▁1 ▁] ▁; ▁mem set ▁( ▁dp ▁, ▁-1 ▁, ▁sizeof ▁( ▁dp ▁) ▁) ▁; ▁c out ▁<< ▁find W ays ▁( ▁N ▁, ▁dp ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁min Days ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁< ▁1 ▁) ▁return ▁n ▁; ▁int ▁cnt ▁= ▁1 ▁+ ▁min ▁( ▁n ▁% ▁2 ▁+ ▁min Days ▁( ▁n ▁/ ▁2 ▁) ▁, ▁n ▁% ▁3 ▁+ ▁min Days ▁( ▁n ▁/ ▁3 ▁) ▁) ▁; ▁return ▁cnt ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁6 ▁; ▁c out ▁<< ▁min Days ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁count Num s ▁( ▁int ▁N ▁) ▁{ ▁int ▁dp ▁[ ▁N ▁] ▁[ ▁16 ▁] ▁; ▁mem set ▁( ▁dp ▁, ▁0 ▁, ▁sizeof ▁( ▁dp ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁) ▁* ▁N ▁* ▁16 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁9 ▁; ▁i ▁++ ▁) ▁dp ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁10 ▁; ▁j ▁++ ▁) ▁{ ▁for ▁( ▁int ▁k ▁= ▁0 ▁; ▁k ▁< ▁16 ▁; ▁k ▁++ ▁) ▁{ ▁int ▁x o ▁= ▁j ▁^ ▁k ▁; ▁dp ▁[ ▁i ▁] ▁[ ▁x o ▁] ▁+= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁k ▁] ▁; ▁} ▁} ▁} ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁10 ▁; ▁i ▁++ ▁) ▁count ▁+= ▁dp ▁[ ▁N ▁- ▁1 ▁] ▁[ ▁i ▁] ▁; ▁c out ▁<< ▁( ▁count ▁) ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁1 ▁; ▁count Num s ▁( ▁N ▁) ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁M ▁, ▁int ▁N ▁) ▁{ ▁int ▁cnt ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁M ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁i ▁% ▁a ▁[ ▁j ▁] ▁== ▁0 ▁) ▁{ ▁cnt ▁++ ▁; ▁break ▁; ▁} ▁} ▁} ▁return ▁cnt ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁5 ▁, ▁7 ▁} ▁; ▁int ▁m ▁= ▁100 ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁count ▁( ▁arr ▁, ▁m ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
