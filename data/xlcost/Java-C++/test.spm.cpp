▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print Max Of Min ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁k ▁= ▁1 ▁; ▁k ▁<= ▁n ▁; ▁k ▁++ ▁) ▁{ ▁int ▁max Of Min ▁= ▁INT _ MIN ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁n ▁- ▁k ▁; ▁i ▁++ ▁) ▁{ ▁int ▁min ▁= ▁arr ▁[ ▁i ▁] ▁; ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁< ▁k ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁+ ▁j ▁] ▁< ▁min ▁) ▁min ▁= ▁arr ▁[ ▁i ▁+ ▁j ▁] ▁; ▁} ▁if ▁( ▁min ▁> ▁max Of Min ▁) ▁max Of Min ▁= ▁min ▁; ▁} ▁c out ▁<< ▁max Of Min ▁<< ▁" ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁20 ▁, ▁30 ▁, ▁50 ▁, ▁10 ▁, ▁70 ▁, ▁30 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁print Max Of Min ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁# include ▁< stack > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print Max Of Min ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁stack ▁< ▁int ▁> ▁s ▁; ▁int ▁left ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁int ▁right ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁left ▁[ ▁i ▁] ▁= ▁-1 ▁; ▁right ▁[ ▁i ▁] ▁= ▁n ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁while ▁( ▁! ▁s ▁. ▁empty ▁( ▁) ▁&& ▁arr ▁[ ▁s ▁. ▁top ▁( ▁) ▁] ▁>= ▁arr ▁[ ▁i ▁] ▁) ▁s ▁. ▁pop ▁( ▁) ▁; ▁if ▁( ▁! ▁s ▁. ▁empty ▁( ▁) ▁) ▁left ▁[ ▁i ▁] ▁= ▁s ▁. ▁top ▁( ▁) ▁; ▁s ▁. ▁push ▁( ▁i ▁) ▁; ▁} ▁while ▁( ▁! ▁s ▁. ▁empty ▁( ▁) ▁) ▁s ▁. ▁pop ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁while ▁( ▁! ▁s ▁. ▁empty ▁( ▁) ▁&& ▁arr ▁[ ▁s ▁. ▁top ▁( ▁) ▁] ▁>= ▁arr ▁[ ▁i ▁] ▁) ▁s ▁. ▁pop ▁( ▁) ▁; ▁if ▁( ▁! ▁s ▁. ▁empty ▁( ▁) ▁) ▁right ▁[ ▁i ▁] ▁= ▁s ▁. ▁top ▁( ▁) ▁; ▁s ▁. ▁push ▁( ▁i ▁) ▁; ▁} ▁int ▁ans ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁ans ▁[ ▁i ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁len ▁= ▁right ▁[ ▁i ▁] ▁- ▁left ▁[ ▁i ▁] ▁- ▁1 ▁; ▁ans ▁[ ▁len ▁] ▁= ▁max ▁( ▁ans ▁[ ▁len ▁] ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁1 ▁; ▁i ▁-- ▁) ▁ans ▁[ ▁i ▁] ▁= ▁max ▁( ▁ans ▁[ ▁i ▁] ▁, ▁ans ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁ans ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁20 ▁, ▁30 ▁, ▁50 ▁, ▁10 ▁, ▁70 ▁, ▁30 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁print Max Of Min ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁sum Between Two K th ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k 1 ▁, ▁int ▁k 2 ▁) ▁{ ▁sort ▁( ▁arr ▁, ▁arr ▁+ ▁n ▁) ▁; ▁int ▁result ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁k 1 ▁; ▁i ▁< ▁k 2 ▁- ▁1 ▁; ▁i ▁++ ▁) ▁result ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁return ▁result ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁20 ▁, ▁8 ▁, ▁22 ▁, ▁4 ▁, ▁12 ▁, ▁10 ▁, ▁14 ▁} ▁; ▁int ▁k 1 ▁= ▁3 ▁, ▁k 2 ▁= ▁6 ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁sum Between Two K th ▁( ▁arr ▁, ▁n ▁, ▁k 1 ▁, ▁k 2 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁struct ▁Node ▁{ ▁int ▁data ▁; ▁struct ▁Node ▁* ▁left ▁, ▁* ▁right ▁; ▁} ▁; ▁struct ▁Node ▁* ▁newNode ▁( ▁int ▁x ▁) ▁{ ▁struct ▁Node ▁* ▁temp ▁= ▁new ▁Node ▁; ▁temp ▁-> ▁data ▁= ▁x ▁; ▁temp ▁-> ▁left ▁= ▁temp ▁-> ▁right ▁= ▁NULL ▁; ▁return ▁temp ▁; ▁} ▁; ▁int ▁count ▁( ▁Node ▁* ▁root ▁) ▁{ ▁if ▁( ▁root ▁== ▁NULL ▁) ▁return ▁0 ▁; ▁return ▁count ▁( ▁root ▁-> ▁left ▁) ▁+ ▁count ▁( ▁root ▁-> ▁right ▁) ▁+ ▁1 ▁; ▁} ▁int ▁check Rec ▁( ▁Node ▁* ▁root ▁, ▁int ▁n ▁, ▁bool ▁& ▁res ▁) ▁{ ▁if ▁( ▁root ▁== ▁NULL ▁) ▁return ▁0 ▁; ▁int ▁c ▁= ▁check Rec ▁( ▁root ▁-> ▁left ▁, ▁n ▁, ▁res ▁) ▁+ ▁1 ▁+ ▁check Rec ▁( ▁root ▁-> ▁right ▁, ▁n ▁, ▁res ▁) ▁; ▁if ▁( ▁c ▁== ▁n ▁- ▁c ▁) ▁res ▁= ▁true ▁; ▁return ▁c ▁; ▁} ▁bool ▁check ▁( ▁Node ▁* ▁root ▁) ▁{ ▁int ▁n ▁= ▁count ▁( ▁root ▁) ▁; ▁bool ▁res ▁= ▁false ▁; ▁check Rec ▁( ▁root ▁, ▁n ▁, ▁res ▁) ▁; ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁struct ▁Node ▁* ▁root ▁= ▁newNode ▁( ▁5 ▁) ▁; ▁root ▁-> ▁left ▁= ▁newNode ▁( ▁1 ▁) ▁; ▁root ▁-> ▁right ▁= ▁newNode ▁( ▁6 ▁) ▁; ▁root ▁-> ▁left ▁-> ▁left ▁= ▁newNode ▁( ▁3 ▁) ▁; ▁root ▁-> ▁right ▁-> ▁left ▁= ▁newNode ▁( ▁7 ▁) ▁; ▁root ▁-> ▁right ▁-> ▁right ▁= ▁newNode ▁( ▁4 ▁) ▁; ▁check ▁( ▁root ▁) ▁? ▁printf ▁( ▁" ▁YES ▁" ▁) ▁: ▁printf ▁( ▁" ▁NO ▁" ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find Sym Pairs ▁( ▁int ▁arr ▁[ ▁] ▁[ ▁2 ▁] ▁, ▁int ▁row ▁) ▁{ ▁unordered _ map ▁< ▁int ▁, ▁int ▁> ▁h M ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁row ▁; ▁i ▁++ ▁) ▁{ ▁int ▁first ▁= ▁arr ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁; ▁int ▁sec ▁= ▁arr ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁; ▁if ▁( ▁h M ▁. ▁find ▁( ▁sec ▁) ▁!= ▁h M ▁. ▁end ▁( ▁) ▁&& ▁h M ▁[ ▁sec ▁] ▁== ▁first ▁) ▁c out ▁<< ▁" ▁( ▁" ▁<< ▁sec ▁<< ▁" ▁, ▁" ▁<< ▁first ▁<< ▁" ▁) ▁" ▁<< ▁end l ▁; ▁else ▁h M ▁[ ▁first ▁] ▁= ▁sec ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁5 ▁] ▁[ ▁2 ▁] ▁; ▁arr ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁= ▁11 ▁; ▁arr ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁= ▁20 ▁; ▁arr ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁= ▁30 ▁; ▁arr ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁= ▁40 ▁; ▁arr ▁[ ▁2 ▁] ▁[ ▁0 ▁] ▁= ▁5 ▁; ▁arr ▁[ ▁2 ▁] ▁[ ▁1 ▁] ▁= ▁10 ▁; ▁arr ▁[ ▁3 ▁] ▁[ ▁0 ▁] ▁= ▁40 ▁; ▁arr ▁[ ▁3 ▁] ▁[ ▁1 ▁] ▁= ▁30 ▁; ▁arr ▁[ ▁4 ▁] ▁[ ▁0 ▁] ▁= ▁10 ▁; ▁arr ▁[ ▁4 ▁] ▁[ ▁1 ▁] ▁= ▁5 ▁; ▁find Sym Pairs ▁( ▁arr ▁, ▁5 ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁struct ▁item ▁{ ▁string ▁name ▁; ▁int ▁price ▁; ▁} ▁; ▁int ▁count Items ▁( ▁item ▁list 1 ▁[ ▁] ▁, ▁int ▁m ▁, ▁item ▁list 2 ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁m ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁if ▁( ▁( ▁list 1 ▁[ ▁i ▁] ▁. ▁name ▁. ▁compare ▁( ▁list 2 ▁[ ▁j ▁] ▁. ▁name ▁) ▁== ▁0 ▁) ▁&& ▁( ▁list 1 ▁[ ▁i ▁] ▁. ▁price ▁!= ▁list 2 ▁[ ▁j ▁] ▁. ▁price ▁) ▁) ▁count ▁++ ▁; ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁item ▁list 1 ▁[ ▁] ▁= ▁{ ▁{ ▁" ▁apple ▁" ▁, ▁60 ▁} ▁, ▁{ ▁" ▁b read ▁" ▁, ▁20 ▁} ▁, ▁{ ▁" ▁wh eat ▁" ▁, ▁50 ▁} ▁, ▁{ ▁" ▁o il ▁" ▁, ▁30 ▁} ▁} ▁; ▁item ▁list 2 ▁[ ▁] ▁= ▁{ ▁{ ▁" ▁mil k ▁" ▁, ▁20 ▁} ▁, ▁{ ▁" ▁b read ▁" ▁, ▁15 ▁} ▁, ▁{ ▁" ▁wh eat ▁" ▁, ▁40 ▁} ▁, ▁{ ▁" ▁apple ▁" ▁, ▁60 ▁} ▁} ▁; ▁int ▁m ▁= ▁sizeof ▁( ▁list 1 ▁) ▁/ ▁sizeof ▁( ▁list 1 ▁[ ▁0 ▁] ▁) ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁list 2 ▁) ▁/ ▁sizeof ▁( ▁list 2 ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁Count ▁= ▁" ▁<< ▁count Items ▁( ▁list 1 ▁, ▁m ▁, ▁list 2 ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Sub array Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁sum ▁) ▁{ ▁unordered _ map ▁< ▁int ▁, ▁int ▁> ▁prev Sum ▁; ▁int ▁res ▁= ▁0 ▁; ▁int ▁curr sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁curr sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁if ▁( ▁curr sum ▁== ▁sum ▁) ▁res ▁++ ▁; ▁if ▁( ▁prev Sum ▁. ▁find ▁( ▁curr sum ▁- ▁sum ▁) ▁!= ▁prev Sum ▁. ▁end ▁( ▁) ▁) ▁res ▁+= ▁( ▁prev Sum ▁[ ▁curr sum ▁- ▁sum ▁] ▁) ▁; ▁prev Sum ▁[ ▁curr sum ▁] ▁++ ▁; ▁} ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁2 ▁, ▁-2 ▁, ▁- 20 ▁, ▁10 ▁} ▁; ▁int ▁sum ▁= ▁-10 ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁find Sub array Sum ▁( ▁arr ▁, ▁n ▁, ▁sum ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Pairs ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁arr ▁[ ▁j ▁] ▁) ▁ans ▁++ ▁; ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁1 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁count Pairs ▁( ▁arr ▁, ▁n ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁MAX _ PATH _ SIZE ▁1000 ▁NEW _ LINE ▁struct ▁Node ▁{ ▁char ▁data ▁; ▁Node ▁* ▁left ▁, ▁* ▁right ▁; ▁} ▁; ▁Node ▁* ▁newNode ▁( ▁char ▁data ▁) ▁{ ▁struct ▁Node ▁* ▁temp ▁= ▁new ▁Node ▁; ▁temp ▁-> ▁data ▁= ▁data ▁; ▁temp ▁-> ▁left ▁= ▁temp ▁-> ▁right ▁= ▁NULL ▁; ▁return ▁temp ▁; ▁} ▁struct ▁PATH ▁{ ▁int ▁H d ▁; ▁char ▁key ▁; ▁} ▁; ▁void ▁print Path ▁( ▁vector ▁< ▁PATH ▁> ▁path ▁, ▁int ▁size ▁) ▁{ ▁int ▁minimum _ H d ▁= ▁INT _ MAX ▁; ▁PATH ▁p ▁; ▁for ▁( ▁int ▁it ▁= ▁0 ▁; ▁it ▁< ▁size ▁; ▁it ▁++ ▁) ▁{ ▁p ▁= ▁path ▁[ ▁it ▁] ▁; ▁minimum _ H d ▁= ▁min ▁( ▁minimum _ H d ▁, ▁p ▁. ▁H d ▁) ▁; ▁} ▁for ▁( ▁int ▁it ▁= ▁0 ▁; ▁it ▁< ▁size ▁; ▁it ▁++ ▁) ▁{ ▁p ▁= ▁path ▁[ ▁it ▁] ▁; ▁int ▁no Of Under Scores ▁= ▁abs ▁( ▁p ▁. ▁H d ▁- ▁minimum _ H d ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁no Of Under Scores ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁" ▁_ ▁" ▁; ▁c out ▁<< ▁p ▁. ▁key ▁<< ▁end l ▁; ▁} ▁c out ▁<< ▁" ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁= ▁" ▁<< ▁end l ▁; ▁} ▁void ▁print All Paths Util ▁( ▁Node ▁* ▁root ▁, ▁vector ▁< ▁PATH ▁> ▁& ▁All Path ▁, ▁int ▁HD ▁, ▁int ▁order ▁) ▁{ ▁if ▁( ▁root ▁== ▁NULL ▁) ▁return ▁; ▁if ▁( ▁root ▁-> ▁left ▁== ▁NULL ▁&& ▁root ▁-> ▁right ▁== ▁NULL ▁) ▁{ ▁All Path ▁[ ▁order ▁] ▁= ▁( ▁PATH ▁{ ▁HD ▁, ▁root ▁-> ▁data ▁} ▁) ▁; ▁print Path ▁( ▁All Path ▁, ▁order ▁+ ▁1 ▁) ▁; ▁return ▁; ▁} ▁All Path ▁[ ▁order ▁] ▁= ▁( ▁PATH ▁{ ▁HD ▁, ▁root ▁-> ▁data ▁} ▁) ▁; ▁print All Paths Util ▁( ▁root ▁-> ▁left ▁, ▁All Path ▁, ▁HD ▁- ▁1 ▁, ▁order ▁+ ▁1 ▁) ▁; ▁print All Paths Util ▁( ▁root ▁-> ▁right ▁, ▁All Path ▁, ▁HD ▁+ ▁1 ▁, ▁order ▁+ ▁1 ▁) ▁; ▁} ▁void ▁print All Paths ▁( ▁Node ▁* ▁root ▁) ▁{ ▁if ▁( ▁root ▁== ▁NULL ▁) ▁return ▁; ▁vector ▁< ▁PATH ▁> ▁All paths ▁( ▁MAX _ PATH _ SIZE ▁) ▁; ▁print All Paths Util ▁( ▁root ▁, ▁All paths ▁, ▁0 ▁, ▁0 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁Node ▁* ▁root ▁= ▁newNode ▁( ▁' ▁A ▁' ▁) ▁; ▁root ▁-> ▁left ▁= ▁newNode ▁( ▁' ▁B ▁' ▁) ▁; ▁root ▁-> ▁right ▁= ▁newNode ▁( ▁' ▁C ▁' ▁) ▁; ▁root ▁-> ▁left ▁-> ▁left ▁= ▁newNode ▁( ▁' ▁D ▁' ▁) ▁; ▁root ▁-> ▁left ▁-> ▁right ▁= ▁newNode ▁( ▁' ▁E ▁' ▁) ▁; ▁root ▁-> ▁right ▁-> ▁left ▁= ▁newNode ▁( ▁' ▁F ▁' ▁) ▁; ▁root ▁-> ▁right ▁-> ▁right ▁= ▁newNode ▁( ▁' ▁G ▁' ▁) ▁; ▁print All Paths ▁( ▁root ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Min ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁low ▁, ▁int ▁high ▁) ▁{ ▁while ▁( ▁low ▁< ▁high ▁) ▁{ ▁int ▁mid ▁= ▁low ▁+ ▁( ▁high ▁- ▁low ▁) ▁/ ▁2 ▁; ▁if ▁( ▁arr ▁[ ▁mid ▁] ▁== ▁arr ▁[ ▁high ▁] ▁) ▁high ▁-- ▁; ▁else ▁if ▁( ▁arr ▁[ ▁mid ▁] ▁> ▁arr ▁[ ▁high ▁] ▁) ▁low ▁= ▁mid ▁+ ▁1 ▁; ▁else ▁high ▁= ▁mid ▁; ▁} ▁return ▁arr ▁[ ▁high ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr 1 ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁6 ▁, ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁n 1 ▁= ▁sizeof ▁( ▁arr 1 ▁) ▁/ ▁sizeof ▁( ▁arr 1 ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁The ▁minimum ▁element ▁is ▁" ▁<< ▁find Min ▁( ▁arr 1 ▁, ▁0 ▁, ▁n 1 ▁- ▁1 ▁) ▁<< ▁end l ▁; ▁int ▁arr 2 ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁n 2 ▁= ▁sizeof ▁( ▁arr 2 ▁) ▁/ ▁sizeof ▁( ▁arr 2 ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁The ▁minimum ▁element ▁is ▁" ▁<< ▁find Min ▁( ▁arr 2 ▁, ▁0 ▁, ▁n 2 ▁- ▁1 ▁) ▁<< ▁end l ▁; ▁int ▁arr 3 ▁[ ▁] ▁= ▁{ ▁1 ▁} ▁; ▁int ▁n 3 ▁= ▁sizeof ▁( ▁arr 3 ▁) ▁/ ▁sizeof ▁( ▁arr 3 ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁The ▁minimum ▁element ▁is ▁" ▁<< ▁find Min ▁( ▁arr 3 ▁, ▁0 ▁, ▁n 3 ▁- ▁1 ▁) ▁<< ▁end l ▁; ▁int ▁arr 4 ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁} ▁; ▁int ▁n 4 ▁= ▁sizeof ▁( ▁arr 4 ▁) ▁/ ▁sizeof ▁( ▁arr 4 ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁The ▁minimum ▁element ▁is ▁" ▁<< ▁find Min ▁( ▁arr 4 ▁, ▁0 ▁, ▁n 4 ▁- ▁1 ▁) ▁<< ▁end l ▁; ▁int ▁arr 5 ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁1 ▁} ▁; ▁int ▁n 5 ▁= ▁sizeof ▁( ▁arr 5 ▁) ▁/ ▁sizeof ▁( ▁arr 5 ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁The ▁minimum ▁element ▁is ▁" ▁<< ▁find Min ▁( ▁arr 5 ▁, ▁0 ▁, ▁n 5 ▁- ▁1 ▁) ▁<< ▁end l ▁; ▁int ▁arr 6 ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁6 ▁, ▁7 ▁, ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁n 6 ▁= ▁sizeof ▁( ▁arr 6 ▁) ▁/ ▁sizeof ▁( ▁arr 6 ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁The ▁minimum ▁element ▁is ▁" ▁<< ▁find Min ▁( ▁arr 6 ▁, ▁0 ▁, ▁n 6 ▁- ▁1 ▁) ▁<< ▁end l ▁; ▁int ▁arr 7 ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁, ▁7 ▁} ▁; ▁int ▁n 7 ▁= ▁sizeof ▁( ▁arr 7 ▁) ▁/ ▁sizeof ▁( ▁arr 7 ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁The ▁minimum ▁element ▁is ▁" ▁<< ▁find Min ▁( ▁arr 7 ▁, ▁0 ▁, ▁n 7 ▁- ▁1 ▁) ▁<< ▁end l ▁; ▁int ▁arr 8 ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁, ▁7 ▁, ▁8 ▁, ▁1 ▁} ▁; ▁int ▁n 8 ▁= ▁sizeof ▁( ▁arr 8 ▁) ▁/ ▁sizeof ▁( ▁arr 8 ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁The ▁minimum ▁element ▁is ▁" ▁<< ▁find Min ▁( ▁arr 8 ▁, ▁0 ▁, ▁n 8 ▁- ▁1 ▁) ▁<< ▁end l ▁; ▁int ▁arr 9 ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁1 ▁, ▁2 ▁} ▁; ▁int ▁n 9 ▁= ▁sizeof ▁( ▁arr 9 ▁) ▁/ ▁sizeof ▁( ▁arr 9 ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁The ▁minimum ▁element ▁is ▁" ▁<< ▁find Min ▁( ▁arr 9 ▁, ▁0 ▁, ▁n 9 ▁- ▁1 ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁void ▁print Array ▁( ▁int ▁array ▁[ ▁] ▁, ▁int ▁length ▁) ▁{ ▁std ▁:: ▁c out ▁<< ▁" ▁[ ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁length ▁; ▁i ▁++ ▁) ▁{ ▁std ▁:: ▁c out ▁<< ▁array ▁[ ▁i ▁] ▁; ▁if ▁( ▁i ▁< ▁( ▁length ▁- ▁1 ▁) ▁) ▁std ▁:: ▁c out ▁<< ▁" ▁, ▁" ▁; ▁else ▁std ▁:: ▁c out ▁<< ▁" ▁] ▁" ▁<< ▁std ▁:: ▁end l ▁; ▁} ▁} ▁void ▁reverse ▁( ▁int ▁array ▁[ ▁] ▁, ▁int ▁start ▁, ▁int ▁end ▁) ▁{ ▁while ▁( ▁start ▁< ▁end ▁) ▁{ ▁int ▁temp ▁= ▁array ▁[ ▁start ▁] ▁; ▁array ▁[ ▁start ▁] ▁= ▁array ▁[ ▁end ▁] ▁; ▁array ▁[ ▁end ▁] ▁= ▁temp ▁; ▁start ▁++ ▁; ▁end ▁-- ▁; ▁} ▁} ▁void ▁re arrange ▁( ▁int ▁array ▁[ ▁] ▁, ▁int ▁start ▁, ▁int ▁end ▁) ▁{ ▁if ▁( ▁start ▁== ▁end ▁) ▁return ▁; ▁re arrange ▁( ▁array ▁, ▁( ▁start ▁+ ▁1 ▁) ▁, ▁end ▁) ▁; ▁if ▁( ▁array ▁[ ▁start ▁] ▁>= ▁0 ▁) ▁{ ▁reverse ▁( ▁array ▁, ▁( ▁start ▁+ ▁1 ▁) ▁, ▁end ▁) ▁; ▁reverse ▁( ▁array ▁, ▁start ▁, ▁end ▁) ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁array ▁[ ▁] ▁= ▁{ ▁-12 ▁, ▁- 11 ▁, ▁- 13 ▁, ▁-5 ▁, ▁- 6 ▁, ▁7 ▁, ▁5 ▁, ▁3 ▁, ▁6 ▁} ▁; ▁int ▁length ▁= ▁( ▁sizeof ▁( ▁array ▁) ▁/ ▁sizeof ▁( ▁array ▁[ ▁0 ▁] ▁) ▁) ▁; ▁int ▁count Negative ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁length ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁array ▁[ ▁i ▁] ▁< ▁0 ▁) ▁count Negative ▁++ ▁; ▁} ▁std ▁:: ▁c out ▁<< ▁" ▁array ▁: ▁" ▁; ▁print Array ▁( ▁array ▁, ▁length ▁) ▁; ▁re arrange ▁( ▁array ▁, ▁0 ▁, ▁( ▁length ▁- ▁1 ▁) ▁) ▁; ▁reverse ▁( ▁array ▁, ▁count Negative ▁, ▁( ▁length ▁- ▁1 ▁) ▁) ▁; ▁std ▁:: ▁c out ▁<< ▁" ▁re arr anged ▁array ▁: ▁" ▁; ▁print Array ▁( ▁array ▁, ▁length ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁re arrange ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁size ▁) ▁{ ▁int ▁positive ▁= ▁0 ▁, ▁negative ▁= ▁1 ▁; ▁while ▁( ▁true ▁) ▁{ ▁while ▁( ▁positive ▁< ▁size ▁&& ▁a ▁[ ▁positive ▁] ▁>= ▁0 ▁) ▁positive ▁+= ▁2 ▁; ▁while ▁( ▁negative ▁< ▁size ▁&& ▁a ▁[ ▁negative ▁] ▁<= ▁0 ▁) ▁negative ▁+= ▁2 ▁; ▁if ▁( ▁positive ▁< ▁size ▁&& ▁negative ▁< ▁size ▁) ▁swap ▁( ▁a ▁[ ▁positive ▁] ▁, ▁a ▁[ ▁negative ▁] ▁) ▁; ▁else ▁break ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁-3 ▁, ▁5 ▁, ▁6 ▁, ▁-3 ▁, ▁6 ▁, ▁7 ▁, ▁-4 ▁, ▁9 ▁, ▁10 ▁} ▁; ▁int ▁n ▁= ▁( ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁) ▁; ▁re arrange ▁( ▁arr ▁, ▁n ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find 3 l argest ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁sort ▁( ▁arr ▁, ▁arr ▁+ ▁n ▁) ▁; ▁int ▁check ▁= ▁0 ▁, ▁count ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁count ▁< ▁4 ▁) ▁{ ▁if ▁( ▁check ▁!= ▁arr ▁[ ▁n ▁- ▁i ▁] ▁) ▁{ ▁c out ▁<< ▁arr ▁[ ▁n ▁- ▁i ▁] ▁<< ▁" ▁" ▁; ▁check ▁= ▁arr ▁[ ▁n ▁- ▁i ▁] ▁; ▁count ▁++ ▁; ▁} ▁} ▁else ▁break ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁12 ▁, ▁45 ▁, ▁1 ▁, ▁-1 ▁, ▁45 ▁, ▁54 ▁, ▁23 ▁, ▁5 ▁, ▁0 ▁, ▁-10 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁find 3 l argest ▁( ▁arr ▁, ▁n ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print 2 Small est ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁arr _ size ▁) ▁{ ▁int ▁i ▁, ▁first ▁, ▁second ▁; ▁if ▁( ▁arr _ size ▁< ▁2 ▁) ▁{ ▁c out ▁<< ▁" ▁Invalid ▁Input ▁" ▁; ▁return ▁; ▁} ▁first ▁= ▁second ▁= ▁INT _ MAX ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁arr _ size ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁first ▁) ▁{ ▁second ▁= ▁first ▁; ▁first ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁else ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁second ▁&& ▁arr ▁[ ▁i ▁] ▁!= ▁first ▁) ▁second ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁if ▁( ▁second ▁== ▁INT _ MAX ▁) ▁c out ▁<< ▁" ▁There ▁is ▁no ▁second ▁smallest ▁element ▁STRNEWLINE ▁" ▁; ▁else ▁c out ▁<< ▁" ▁The ▁smallest ▁element ▁is ▁" ▁<< ▁first ▁<< ▁" ▁and ▁second ▁" ▁" ▁Small est ▁element ▁is ▁" ▁<< ▁second ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁12 ▁, ▁13 ▁, ▁1 ▁, ▁10 ▁, ▁34 ▁, ▁1 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁print 2 Small est ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁findFirst Missing ▁( ▁int ▁array ▁[ ▁] ▁, ▁int ▁start ▁, ▁int ▁end ▁) ▁{ ▁if ▁( ▁start ▁> ▁end ▁) ▁return ▁end ▁+ ▁1 ▁; ▁if ▁( ▁start ▁!= ▁array ▁[ ▁start ▁] ▁) ▁return ▁start ▁; ▁int ▁mid ▁= ▁( ▁start ▁+ ▁end ▁) ▁/ ▁2 ▁; ▁if ▁( ▁array ▁[ ▁mid ▁] ▁== ▁mid ▁) ▁return ▁findFirst Missing ▁( ▁array ▁, ▁mid ▁+ ▁1 ▁, ▁end ▁) ▁; ▁return ▁findFirst Missing ▁( ▁array ▁, ▁start ▁, ▁mid ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁, ▁7 ▁, ▁10 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁Small est ▁missing ▁element ▁is ▁" ▁<< ▁findFirst Missing ▁( ▁arr ▁, ▁0 ▁, ▁n ▁- ▁1 ▁) ▁<< ▁end l ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁MAX ▁1000 ▁NEW _ LINE ▁int ▁tree ▁[ ▁4 ▁* ▁MAX ▁] ▁; ▁int ▁arr ▁[ ▁MAX ▁] ▁; ▁int ▁gcd ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁if ▁( ▁a ▁== ▁0 ▁) ▁return ▁b ▁; ▁return ▁gcd ▁( ▁b ▁% ▁a ▁, ▁a ▁) ▁; ▁} ▁int ▁l cm ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁return ▁a ▁* ▁b ▁/ ▁gcd ▁( ▁a ▁, ▁b ▁) ▁; ▁} ▁void ▁build ▁( ▁int ▁node ▁, ▁int ▁start ▁, ▁int ▁end ▁) ▁{ ▁if ▁( ▁start ▁== ▁end ▁) ▁{ ▁tree ▁[ ▁node ▁] ▁= ▁arr ▁[ ▁start ▁] ▁; ▁return ▁; ▁} ▁int ▁mid ▁= ▁( ▁start ▁+ ▁end ▁) ▁/ ▁2 ▁; ▁build ▁( ▁2 ▁* ▁node ▁, ▁start ▁, ▁mid ▁) ▁; ▁build ▁( ▁2 ▁* ▁node ▁+ ▁1 ▁, ▁mid ▁+ ▁1 ▁, ▁end ▁) ▁; ▁int ▁left _ l cm ▁= ▁tree ▁[ ▁2 ▁* ▁node ▁] ▁; ▁int ▁right _ l cm ▁= ▁tree ▁[ ▁2 ▁* ▁node ▁+ ▁1 ▁] ▁; ▁tree ▁[ ▁node ▁] ▁= ▁l cm ▁( ▁left _ l cm ▁, ▁right _ l cm ▁) ▁; ▁} ▁int ▁query ▁( ▁int ▁node ▁, ▁int ▁start ▁, ▁int ▁end ▁, ▁int ▁l ▁, ▁int ▁r ▁) ▁{ ▁if ▁( ▁end ▁< ▁l ▁start ▁> ▁r ▁) ▁return ▁1 ▁; ▁if ▁( ▁l ▁<= ▁start ▁&& ▁r ▁>= ▁end ▁) ▁return ▁tree ▁[ ▁node ▁] ▁; ▁int ▁mid ▁= ▁( ▁start ▁+ ▁end ▁) ▁/ ▁2 ▁; ▁int ▁left _ l cm ▁= ▁query ▁( ▁2 ▁* ▁node ▁, ▁start ▁, ▁mid ▁, ▁l ▁, ▁r ▁) ▁; ▁int ▁right _ l cm ▁= ▁query ▁( ▁2 ▁* ▁node ▁+ ▁1 ▁, ▁mid ▁+ ▁1 ▁, ▁end ▁, ▁l ▁, ▁r ▁) ▁; ▁return ▁l cm ▁( ▁left _ l cm ▁, ▁right _ l cm ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁arr ▁[ ▁0 ▁] ▁= ▁5 ▁; ▁arr ▁[ ▁1 ▁] ▁= ▁7 ▁; ▁arr ▁[ ▁2 ▁] ▁= ▁5 ▁; ▁arr ▁[ ▁3 ▁] ▁= ▁2 ▁; ▁arr ▁[ ▁4 ▁] ▁= ▁10 ▁; ▁arr ▁[ ▁5 ▁] ▁= ▁12 ▁; ▁arr ▁[ ▁6 ▁] ▁= ▁11 ▁; ▁arr ▁[ ▁7 ▁] ▁= ▁17 ▁; ▁arr ▁[ ▁8 ▁] ▁= ▁14 ▁; ▁arr ▁[ ▁9 ▁] ▁= ▁1 ▁; ▁arr ▁[ ▁10 ▁] ▁= ▁44 ▁; ▁build ▁( ▁1 ▁, ▁0 ▁, ▁10 ▁) ▁; ▁c out ▁<< ▁query ▁( ▁1 ▁, ▁0 ▁, ▁10 ▁, ▁2 ▁, ▁5 ▁) ▁<< ▁end l ▁; ▁c out ▁<< ▁query ▁( ▁1 ▁, ▁0 ▁, ▁10 ▁, ▁5 ▁, ▁10 ▁) ▁<< ▁end l ▁; ▁c out ▁<< ▁query ▁( ▁1 ▁, ▁0 ▁, ▁10 ▁, ▁0 ▁, ▁10 ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁lower Index ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁x ▁) ▁{ ▁int ▁l ▁= ▁0 ▁, ▁h ▁= ▁n ▁- ▁1 ▁; ▁while ▁( ▁l ▁<= ▁h ▁) ▁{ ▁int ▁mid ▁= ▁( ▁l ▁+ ▁h ▁) ▁/ ▁2 ▁; ▁if ▁( ▁arr ▁[ ▁mid ▁] ▁>= ▁x ▁) ▁h ▁= ▁mid ▁- ▁1 ▁; ▁else ▁l ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁return ▁l ▁; ▁} ▁int ▁upper Index ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁y ▁) ▁{ ▁int ▁l ▁= ▁0 ▁, ▁h ▁= ▁n ▁- ▁1 ▁; ▁while ▁( ▁l ▁<= ▁h ▁) ▁{ ▁int ▁mid ▁= ▁( ▁l ▁+ ▁h ▁) ▁/ ▁2 ▁; ▁if ▁( ▁arr ▁[ ▁mid ▁] ▁<= ▁y ▁) ▁l ▁= ▁mid ▁+ ▁1 ▁; ▁else ▁h ▁= ▁mid ▁- ▁1 ▁; ▁} ▁return ▁h ▁; ▁} ▁int ▁count In Range ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁count ▁= ▁upper Index ▁( ▁arr ▁, ▁n ▁, ▁y ▁) ▁- ▁lower Index ▁( ▁arr ▁, ▁n ▁, ▁x ▁) ▁+ ▁1 ▁; ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁4 ▁, ▁4 ▁, ▁9 ▁, ▁10 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁sort ▁( ▁arr ▁, ▁arr ▁+ ▁n ▁) ▁; ▁int ▁i ▁= ▁1 ▁, ▁j ▁= ▁4 ▁; ▁c out ▁<< ▁count In Range ▁( ▁arr ▁, ▁n ▁, ▁i ▁, ▁j ▁) ▁<< ▁end l ▁; ▁i ▁= ▁9 ▁, ▁j ▁= ▁12 ▁; ▁c out ▁<< ▁count In Range ▁( ▁arr ▁, ▁n ▁, ▁i ▁, ▁j ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁type 1 ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁start ▁, ▁int ▁limit ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁start ▁; ▁i ▁<= ▁limit ▁; ▁i ▁++ ▁) ▁arr ▁[ ▁i ▁] ▁++ ▁; ▁} ▁void ▁type 2 ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁query ▁[ ▁] ▁[ ▁3 ▁] ▁, ▁int ▁start ▁, ▁int ▁limit ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁start ▁; ▁i ▁<= ▁limit ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁query ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁== ▁1 ▁) ▁type 1 ▁( ▁arr ▁, ▁query ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁, ▁query ▁[ ▁i ▁] ▁[ ▁2 ▁] ▁) ▁; ▁else ▁if ▁( ▁query ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁== ▁2 ▁) ▁type 2 ▁( ▁arr ▁, ▁query ▁, ▁query ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁, ▁query ▁[ ▁i ▁] ▁[ ▁2 ▁] ▁) ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁5 ▁, ▁m ▁= ▁5 ▁; ▁int ▁arr ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁arr ▁[ ▁i ▁] ▁= ▁0 ▁; ▁int ▁temp ▁[ ▁15 ▁] ▁= ▁{ ▁1 ▁, ▁1 ▁, ▁2 ▁, ▁1 ▁, ▁4 ▁, ▁5 ▁, ▁2 ▁, ▁1 ▁, ▁2 ▁, ▁2 ▁, ▁1 ▁, ▁3 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁query ▁[ ▁5 ▁] ▁[ ▁3 ▁] ▁; ▁int ▁j ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁m ▁; ▁i ▁++ ▁) ▁{ ▁query ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁= ▁temp ▁[ ▁j ▁++ ▁] ▁; ▁query ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁= ▁temp ▁[ ▁j ▁++ ▁] ▁; ▁query ▁[ ▁i ▁] ▁[ ▁2 ▁] ▁= ▁temp ▁[ ▁j ▁++ ▁] ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁m ▁; ▁i ▁++ ▁) ▁if ▁( ▁query ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁== ▁1 ▁) ▁type 1 ▁( ▁arr ▁, ▁query ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁, ▁query ▁[ ▁i ▁] ▁[ ▁2 ▁] ▁) ▁; ▁else ▁if ▁( ▁query ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁== ▁2 ▁) ▁type 2 ▁( ▁arr ▁, ▁query ▁, ▁query ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁, ▁query ▁[ ▁i ▁] ▁[ ▁2 ▁] ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁# include ▁< algorithm > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁swap ▁( ▁int ▁* ▁x ▁, ▁int ▁* ▁y ▁) ▁{ ▁int ▁temp ▁= ▁* ▁x ▁; ▁* ▁x ▁= ▁* ▁y ▁; ▁* ▁y ▁= ▁temp ▁; ▁} ▁void ▁sort In Wave ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁sort ▁( ▁arr ▁, ▁arr ▁+ ▁n ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁+= ▁2 ▁) ▁swap ▁( ▁& ▁arr ▁[ ▁i ▁] ▁, ▁& ▁arr ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁90 ▁, ▁49 ▁, ▁2 ▁, ▁1 ▁, ▁5 ▁, ▁23 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁sort In Wave ▁( ▁arr ▁, ▁n ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁NA ▁-1 ▁NEW _ LINE ▁void ▁moveTo End ▁( ▁int ▁m Plus N ▁[ ▁] ▁, ▁int ▁size ▁) ▁{ ▁int ▁j ▁= ▁size ▁- ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁size ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁if ▁( ▁m Plus N ▁[ ▁i ▁] ▁!= ▁NA ▁) ▁{ ▁m Plus N ▁[ ▁j ▁] ▁= ▁m Plus N ▁[ ▁i ▁] ▁; ▁j ▁-- ▁; ▁} ▁} ▁int ▁merge ▁( ▁int ▁m Plus N ▁[ ▁] ▁, ▁int ▁N ▁[ ▁] ▁, ▁int ▁m ▁, ▁int ▁n ▁) ▁{ ▁int ▁i ▁= ▁n ▁; ▁int ▁j ▁= ▁0 ▁; ▁int ▁k ▁= ▁0 ▁; ▁while ▁( ▁k ▁< ▁( ▁m ▁+ ▁n ▁) ▁) ▁{ ▁if ▁( ▁( ▁j ▁== ▁n ▁) ▁|| ▁( ▁i ▁< ▁( ▁m ▁+ ▁n ▁) ▁&& ▁m Plus N ▁[ ▁i ▁] ▁<= ▁N ▁[ ▁j ▁] ▁) ▁) ▁{ ▁m Plus N ▁[ ▁k ▁] ▁= ▁m Plus N ▁[ ▁i ▁] ▁; ▁k ▁++ ▁; ▁i ▁++ ▁; ▁} ▁else ▁{ ▁m Plus N ▁[ ▁k ▁] ▁= ▁N ▁[ ▁j ▁] ▁; ▁k ▁++ ▁; ▁j ▁++ ▁; ▁} ▁} ▁} ▁void ▁print Array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁size ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁c out ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁m Plus N ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁8 ▁, ▁NA ▁, ▁NA ▁, ▁NA ▁, ▁13 ▁, ▁NA ▁, ▁15 ▁, ▁20 ▁} ▁; ▁int ▁N ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁7 ▁, ▁9 ▁, ▁25 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁N ▁) ▁/ ▁sizeof ▁( ▁N ▁[ ▁0 ▁] ▁) ▁; ▁int ▁m ▁= ▁sizeof ▁( ▁m Plus N ▁) ▁/ ▁sizeof ▁( ▁m Plus N ▁[ ▁0 ▁] ▁) ▁- ▁n ▁; ▁moveTo End ▁( ▁m Plus N ▁, ▁m ▁+ ▁n ▁) ▁; ▁merge ▁( ▁m Plus N ▁, ▁N ▁, ▁m ▁, ▁n ▁) ▁; ▁print Array ▁( ▁m Plus N ▁, ▁m ▁+ ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁getIn v Count ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁inv _ count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁arr ▁[ ▁j ▁] ▁) ▁inv _ count ▁++ ▁; ▁return ▁inv _ count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁20 ▁, ▁6 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁Number ▁of ▁in versions ▁are ▁" ▁<< ▁getIn v Count ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# ▁include ▁< bits / std c ++. h > ▁NEW _ LINE ▁# ▁include ▁< std lib . h > ▁NEW _ LINE ▁# ▁include ▁< math . h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁min Abs Sum Pair ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁arr _ size ▁) ▁{ ▁int ▁inv _ count ▁= ▁0 ▁; ▁int ▁l ▁, ▁r ▁, ▁min _ sum ▁, ▁sum ▁, ▁min _ l ▁, ▁min _ r ▁; ▁if ▁( ▁arr _ size ▁< ▁2 ▁) ▁{ ▁c out ▁<< ▁" ▁Invalid ▁Input ▁" ▁; ▁return ▁; ▁} ▁min _ l ▁= ▁0 ▁; ▁min _ r ▁= ▁1 ▁; ▁min _ sum ▁= ▁arr ▁[ ▁0 ▁] ▁+ ▁arr ▁[ ▁1 ▁] ▁; ▁for ▁( ▁l ▁= ▁0 ▁; ▁l ▁< ▁arr _ size ▁- ▁1 ▁; ▁l ▁++ ▁) ▁{ ▁for ▁( ▁r ▁= ▁l ▁+ ▁1 ▁; ▁r ▁< ▁arr _ size ▁; ▁r ▁++ ▁) ▁{ ▁sum ▁= ▁arr ▁[ ▁l ▁] ▁+ ▁arr ▁[ ▁r ▁] ▁; ▁if ▁( ▁abs ▁( ▁min _ sum ▁) ▁> ▁abs ▁( ▁sum ▁) ▁) ▁{ ▁min _ sum ▁= ▁sum ▁; ▁min _ l ▁= ▁l ▁; ▁min _ r ▁= ▁r ▁; ▁} ▁} ▁} ▁c out ▁<< ▁" ▁The ▁two ▁elements ▁whose ▁sum ▁is ▁minimum ▁are ▁" ▁<< ▁arr ▁[ ▁min _ l ▁] ▁<< ▁" ▁and ▁" ▁<< ▁arr ▁[ ▁min _ r ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁60 ▁, ▁-10 ▁, ▁70 ▁, ▁- 80 ▁, ▁85 ▁} ▁; ▁min Abs Sum Pair ▁( ▁arr ▁, ▁6 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁sort 012 ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁arr _ size ▁) ▁{ ▁int ▁lo ▁= ▁0 ▁; ▁int ▁hi ▁= ▁arr _ size ▁- ▁1 ▁; ▁int ▁mid ▁= ▁0 ▁; ▁while ▁( ▁mid ▁<= ▁hi ▁) ▁{ ▁switch ▁( ▁a ▁[ ▁mid ▁] ▁) ▁{ ▁case ▁0 ▁: ▁swap ▁( ▁a ▁[ ▁lo ▁++ ▁] ▁, ▁a ▁[ ▁mid ▁++ ▁] ▁) ▁; ▁break ▁; ▁case ▁1 ▁: ▁mid ▁++ ▁; ▁break ▁; ▁case ▁2 ▁: ▁swap ▁( ▁a ▁[ ▁mid ▁] ▁, ▁a ▁[ ▁hi ▁-- ▁] ▁) ▁; ▁break ▁; ▁} ▁} ▁} ▁void ▁print Array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁arr _ size ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁arr _ size ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁2 ▁, ▁1 ▁, ▁2 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁sort 012 ▁( ▁arr ▁, ▁n ▁) ▁; ▁c out ▁<< ▁" ▁array ▁after ▁seg reg ation ▁" ▁; ▁print Array ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print Un sorted ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁s ▁= ▁0 ▁, ▁e ▁= ▁n ▁- ▁1 ▁, ▁i ▁, ▁max ▁, ▁min ▁; ▁for ▁( ▁s ▁= ▁0 ▁; ▁s ▁< ▁n ▁- ▁1 ▁; ▁s ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁s ▁] ▁> ▁arr ▁[ ▁s ▁+ ▁1 ▁] ▁) ▁break ▁; ▁} ▁if ▁( ▁s ▁== ▁n ▁- ▁1 ▁) ▁{ ▁c out ▁<< ▁" ▁The ▁complete ▁array ▁is ▁sorted ▁" ▁; ▁return ▁; ▁} ▁for ▁( ▁e ▁= ▁n ▁- ▁1 ▁; ▁e ▁> ▁0 ▁; ▁e ▁-- ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁e ▁] ▁< ▁arr ▁[ ▁e ▁- ▁1 ▁] ▁) ▁break ▁; ▁} ▁max ▁= ▁arr ▁[ ▁s ▁] ▁; ▁min ▁= ▁arr ▁[ ▁s ▁] ▁; ▁for ▁( ▁i ▁= ▁s ▁+ ▁1 ▁; ▁i ▁<= ▁e ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁max ▁) ▁max ▁= ▁arr ▁[ ▁i ▁] ▁; ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁min ▁) ▁min ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁min ▁) ▁{ ▁s ▁= ▁i ▁; ▁break ▁; ▁} ▁} ▁for ▁( ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁e ▁+ ▁1 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁max ▁) ▁{ ▁e ▁= ▁i ▁; ▁break ▁; ▁} ▁} ▁c out ▁<< ▁" ▁The ▁unsorted ▁sub array ▁which ▁" ▁<< ▁" ▁makes ▁the ▁given ▁array ▁" ▁<< ▁end l ▁<< ▁" ▁sorted ▁lies ▁between ▁the ▁ind ees ▁" ▁<< ▁s ▁<< ▁" ▁and ▁" ▁<< ▁e ▁; ▁return ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁12 ▁, ▁20 ▁, ▁30 ▁, ▁25 ▁, ▁40 ▁, ▁32 ▁, ▁31 ▁, ▁35 ▁, ▁50 ▁, ▁60 ▁} ▁; ▁int ▁arr _ size ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁print Un sorted ▁( ▁arr ▁, ▁arr _ size ▁) ▁; ▁get char ▁( ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁findElement ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁key ▁) ▁{ ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁key ▁) ▁return ▁i ▁; ▁return ▁-1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁12 ▁, ▁34 ▁, ▁10 ▁, ▁6 ▁, ▁40 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁key ▁= ▁40 ▁; ▁int ▁position ▁= ▁findElement ▁( ▁arr ▁, ▁n ▁, ▁key ▁) ▁; ▁if ▁( ▁position ▁== ▁- ▁1 ▁) ▁c out ▁<< ▁" ▁Element ▁not ▁found ▁" ▁; ▁else ▁c out ▁<< ▁" ▁Element ▁Found ▁at ▁Position ▁: ▁" ▁<< ▁position ▁+ ▁1 ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁binarySearch ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁low ▁, ▁int ▁high ▁, ▁int ▁key ▁) ▁{ ▁if ▁( ▁high ▁< ▁low ▁) ▁return ▁-1 ▁; ▁int ▁mid ▁= ▁( ▁low ▁+ ▁high ▁) ▁/ ▁2 ▁; ▁if ▁( ▁key ▁== ▁arr ▁[ ▁mid ▁] ▁) ▁return ▁mid ▁; ▁if ▁( ▁key ▁> ▁arr ▁[ ▁mid ▁] ▁) ▁return ▁binarySearch ▁( ▁arr ▁, ▁( ▁mid ▁+ ▁1 ▁) ▁, ▁high ▁, ▁key ▁) ▁; ▁return ▁binarySearch ▁( ▁arr ▁, ▁low ▁, ▁( ▁mid ▁- ▁1 ▁) ▁, ▁key ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁6 ▁, ▁7 ▁, ▁8 ▁, ▁9 ▁, ▁10 ▁} ▁; ▁int ▁n ▁, ▁key ▁; ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁key ▁= ▁10 ▁; ▁c out ▁<< ▁" ▁Index ▁: ▁" ▁<< ▁binarySearch ▁( ▁arr ▁, ▁0 ▁, ▁n ▁- ▁1 ▁, ▁key ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁equ il ib ri um ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁int ▁left sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁{ ▁sum ▁-= ▁arr ▁[ ▁i ▁] ▁; ▁if ▁( ▁left sum ▁== ▁sum ▁) ▁return ▁i ▁; ▁left sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁return ▁-1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁- 7 ▁, ▁1 ▁, ▁5 ▁, ▁2 ▁, ▁-4 ▁, ▁3 ▁, ▁0 ▁} ▁; ▁int ▁arr _ size ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁First ▁equ il ib ri um ▁index ▁is ▁" ▁<< ▁equ il ib ri um ▁( ▁arr ▁, ▁arr _ size ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁ceil Search ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁low ▁, ▁int ▁high ▁, ▁int ▁x ▁) ▁{ ▁int ▁mid ▁; ▁if ▁( ▁x ▁<= ▁arr ▁[ ▁low ▁] ▁) ▁return ▁low ▁; ▁if ▁( ▁x ▁> ▁arr ▁[ ▁high ▁] ▁) ▁return ▁-1 ▁; ▁mid ▁= ▁( ▁low ▁+ ▁high ▁) ▁/ ▁2 ▁; ▁if ▁( ▁arr ▁[ ▁mid ▁] ▁== ▁x ▁) ▁return ▁mid ▁; ▁else ▁if ▁( ▁arr ▁[ ▁mid ▁] ▁< ▁x ▁) ▁{ ▁if ▁( ▁mid ▁+ ▁1 ▁<= ▁high ▁&& ▁x ▁<= ▁arr ▁[ ▁mid ▁+ ▁1 ▁] ▁) ▁return ▁mid ▁+ ▁1 ▁; ▁else ▁return ▁ceil Search ▁( ▁arr ▁, ▁mid ▁+ ▁1 ▁, ▁high ▁, ▁x ▁) ▁; ▁} ▁else ▁{ ▁if ▁( ▁mid ▁- ▁1 ▁>= ▁low ▁&& ▁x ▁> ▁arr ▁[ ▁mid ▁- ▁1 ▁] ▁) ▁return ▁mid ▁; ▁else ▁return ▁ceil Search ▁( ▁arr ▁, ▁low ▁, ▁mid ▁- ▁1 ▁, ▁x ▁) ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁8 ▁, ▁10 ▁, ▁10 ▁, ▁12 ▁, ▁19 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁x ▁= ▁20 ▁; ▁int ▁index ▁= ▁ceil Search ▁( ▁arr ▁, ▁0 ▁, ▁n ▁- ▁1 ▁, ▁x ▁) ▁; ▁if ▁( ▁index ▁== ▁-1 ▁) ▁c out ▁<< ▁" ▁C e iling ▁of ▁" ▁<< ▁x ▁<< ▁" ▁doesn ▁' ▁t ▁exist ▁in ▁array ▁" ▁; ▁else ▁c out ▁<< ▁" ▁ceiling ▁of ▁" ▁<< ▁x ▁<< ▁" ▁is ▁" ▁<< ▁arr ▁[ ▁index ▁] ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁struct ▁Node ▁{ ▁int ▁data ▁; ▁struct ▁Node ▁* ▁left ▁; ▁struct ▁Node ▁* ▁right ▁; ▁} ▁; ▁int ▁getHeight ▁( ▁struct ▁Node ▁* ▁Node ▁) ▁{ ▁if ▁( ▁Node ▁== ▁NULL ▁) ▁return ▁0 ▁; ▁else ▁{ ▁int ▁l Height ▁= ▁getHeight ▁( ▁Node ▁-> ▁left ▁) ▁; ▁int ▁r Height ▁= ▁getHeight ▁( ▁Node ▁-> ▁right ▁) ▁; ▁if ▁( ▁l Height ▁> ▁r Height ▁) ▁return ▁( ▁l Height ▁+ ▁1 ▁) ▁; ▁else ▁return ▁( ▁r Height ▁+ ▁1 ▁) ▁; ▁} ▁} ▁struct ▁Node ▁* ▁newNode ▁( ▁int ▁data ▁) ▁{ ▁struct ▁Node ▁* ▁Node ▁= ▁( ▁struct ▁Node ▁* ▁) ▁m alloc ▁( ▁sizeof ▁( ▁struct ▁Node ▁) ▁) ▁; ▁Node ▁-> ▁data ▁= ▁data ▁; ▁Node ▁-> ▁left ▁= ▁NULL ▁; ▁Node ▁-> ▁right ▁= ▁NULL ▁; ▁return ▁( ▁Node ▁) ▁; ▁} ▁int ▁getTotal Height ▁( ▁struct ▁Node ▁* ▁root ▁) ▁{ ▁if ▁( ▁root ▁== ▁NULL ▁) ▁return ▁0 ▁; ▁return ▁getTotal Height ▁( ▁root ▁-> ▁left ▁) ▁+ ▁getHeight ▁( ▁root ▁) ▁+ ▁getTotal Height ▁( ▁root ▁-> ▁right ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁struct ▁Node ▁* ▁root ▁= ▁newNode ▁( ▁1 ▁) ▁; ▁root ▁-> ▁left ▁= ▁newNode ▁( ▁2 ▁) ▁; ▁root ▁-> ▁right ▁= ▁newNode ▁( ▁3 ▁) ▁; ▁root ▁-> ▁left ▁-> ▁left ▁= ▁newNode ▁( ▁4 ▁) ▁; ▁root ▁-> ▁left ▁-> ▁right ▁= ▁newNode ▁( ▁5 ▁) ▁; ▁printf ▁( ▁" ▁Sum ▁of ▁heights ▁of ▁all ▁Nodes ▁= ▁% ▁d ▁" ▁, ▁getTotal Height ▁( ▁root ▁) ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁majority Element ▁( ▁int ▁* ▁arr ▁, ▁int ▁n ▁) ▁{ ▁sort ▁( ▁arr ▁, ▁arr ▁+ ▁n ▁) ▁; ▁int ▁count ▁= ▁1 ▁, ▁max _ ele ▁= ▁-1 ▁, ▁temp ▁= ▁arr ▁[ ▁0 ▁] ▁, ▁ele ▁, ▁f ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁temp ▁== ▁arr ▁[ ▁i ▁] ▁) ▁{ ▁count ▁++ ▁; ▁} ▁else ▁{ ▁count ▁= ▁1 ▁; ▁temp ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁if ▁( ▁max _ ele ▁< ▁count ▁) ▁{ ▁max _ ele ▁= ▁count ▁; ▁ele ▁= ▁arr ▁[ ▁i ▁] ▁; ▁if ▁( ▁max _ ele ▁> ▁( ▁n ▁/ ▁2 ▁) ▁) ▁{ ▁f ▁= ▁1 ▁; ▁break ▁; ▁} ▁} ▁} ▁return ▁( ▁f ▁== ▁1 ▁? ▁ele ▁: ▁-1 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁1 ▁, ▁2 ▁, ▁1 ▁, ▁3 ▁, ▁5 ▁, ▁1 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁majority Element ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is Major ity ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁x ▁) ▁{ ▁int ▁i ▁; ▁int ▁last _ index ▁= ▁n ▁% ▁2 ▁? ▁( ▁n ▁/ ▁2 ▁+ ▁1 ▁) ▁: ▁( ▁n ▁/ ▁2 ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁last _ index ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁x ▁&& ▁arr ▁[ ▁i ▁+ ▁n ▁/ ▁2 ▁] ▁== ▁x ▁) ▁return ▁1 ▁; ▁} ▁return ▁0 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁4 ▁, ▁4 ▁, ▁4 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁x ▁= ▁4 ▁; ▁if ▁( ▁is Major ity ▁( ▁arr ▁, ▁n ▁, ▁x ▁) ▁) ▁c out ▁<< ▁x ▁<< ▁" ▁appears ▁more ▁than ▁" ▁<< ▁n ▁/ ▁2 ▁<< ▁" ▁times ▁in ▁arr ▁[ ▁] ▁" ▁<< ▁end l ▁; ▁else ▁c out ▁<< ▁x ▁<< ▁" ▁does ▁not ▁appear ▁more ▁than ▁" ▁<< ▁n ▁/ ▁2 ▁<< ▁" ▁times ▁in ▁arr ▁[ ▁] ▁" ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁struct ▁Node ▁{ ▁int ▁data ▁; ▁struct ▁Node ▁* ▁left ▁; ▁struct ▁Node ▁* ▁right ▁; ▁} ▁; ▁struct ▁Node ▁* ▁newNode ▁( ▁int ▁data ▁) ▁{ ▁struct ▁Node ▁* ▁Node ▁= ▁( ▁struct ▁Node ▁* ▁) ▁m alloc ▁( ▁sizeof ▁( ▁struct ▁Node ▁) ▁) ▁; ▁Node ▁-> ▁data ▁= ▁data ▁; ▁Node ▁-> ▁left ▁= ▁NULL ▁; ▁Node ▁-> ▁right ▁= ▁NULL ▁; ▁return ▁( ▁Node ▁) ▁; ▁} ▁int ▁getTotal Height Util ▁( ▁struct ▁Node ▁* ▁root ▁, ▁int ▁& ▁sum ▁) ▁{ ▁if ▁( ▁root ▁== ▁NULL ▁) ▁return ▁0 ▁; ▁int ▁lh ▁= ▁getTotal Height Util ▁( ▁root ▁-> ▁left ▁, ▁sum ▁) ▁; ▁int ▁rh ▁= ▁getTotal Height Util ▁( ▁root ▁-> ▁right ▁, ▁sum ▁) ▁; ▁int ▁h ▁= ▁max ▁( ▁lh ▁, ▁rh ▁) ▁+ ▁1 ▁; ▁sum ▁= ▁sum ▁+ ▁h ▁; ▁return ▁h ▁; ▁} ▁int ▁getTotal Height ▁( ▁Node ▁* ▁root ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁getTotal Height Util ▁( ▁root ▁, ▁sum ▁) ▁; ▁return ▁sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁struct ▁Node ▁* ▁root ▁= ▁newNode ▁( ▁1 ▁) ▁; ▁root ▁-> ▁left ▁= ▁newNode ▁( ▁2 ▁) ▁; ▁root ▁-> ▁right ▁= ▁newNode ▁( ▁3 ▁) ▁; ▁root ▁-> ▁left ▁-> ▁left ▁= ▁newNode ▁( ▁4 ▁) ▁; ▁root ▁-> ▁left ▁-> ▁right ▁= ▁newNode ▁( ▁5 ▁) ▁; ▁printf ▁( ▁" ▁Sum ▁of ▁heights ▁of ▁all ▁Nodes ▁= ▁% ▁d ▁" ▁, ▁getTotal Height ▁( ▁root ▁) ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁b fs ▁( ▁int ▁n ▁, ▁int ▁m ▁, ▁int ▁num ▁) ▁{ ▁queue ▁< ▁int ▁> ▁q ▁; ▁q ▁. ▁push ▁( ▁num ▁) ▁; ▁while ▁( ▁! ▁q ▁. ▁empty ▁( ▁) ▁) ▁{ ▁int ▁step Num ▁= ▁q ▁. ▁front ▁( ▁) ▁; ▁q ▁. ▁pop ▁( ▁) ▁; ▁if ▁( ▁step Num ▁<= ▁m ▁&& ▁step Num ▁>= ▁n ▁) ▁c out ▁<< ▁step Num ▁<< ▁" ▁" ▁; ▁if ▁( ▁num ▁== ▁0 ▁step Num ▁> ▁m ▁) ▁continue ▁; ▁int ▁last Digit ▁= ▁step Num ▁% ▁10 ▁; ▁int ▁step Num A ▁= ▁step Num ▁* ▁10 ▁+ ▁( ▁last Digit ▁- ▁1 ▁) ▁; ▁int ▁step Num B ▁= ▁step Num ▁* ▁10 ▁+ ▁( ▁last Digit ▁+ ▁1 ▁) ▁; ▁if ▁( ▁last Digit ▁== ▁0 ▁) ▁q ▁. ▁push ▁( ▁step Num B ▁) ▁; ▁else ▁if ▁( ▁last Digit ▁== ▁9 ▁) ▁q ▁. ▁push ▁( ▁step Num A ▁) ▁; ▁else ▁{ ▁q ▁. ▁push ▁( ▁step Num A ▁) ▁; ▁q ▁. ▁push ▁( ▁step Num B ▁) ▁; ▁} ▁} ▁} ▁void ▁display St e pping Numbers ▁( ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁9 ▁; ▁i ▁++ ▁) ▁b fs ▁( ▁n ▁, ▁m ▁, ▁i ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁0 ▁, ▁m ▁= ▁21 ▁; ▁display St e pping Numbers ▁( ▁n ▁, ▁m ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁struct ▁node ▁{ ▁struct ▁node ▁* ▁left ▁; ▁int ▁data ▁; ▁struct ▁node ▁* ▁right ▁; ▁} ▁; ▁void ▁level Order ▁( ▁node ▁* ▁root ▁) ▁{ ▁if ▁( ▁root ▁== ▁NULL ▁) ▁return ▁; ▁queue ▁< ▁node ▁* ▁> ▁q ▁; ▁node ▁* ▁curr ▁; ▁q ▁. ▁push ▁( ▁root ▁) ▁; ▁q ▁. ▁push ▁( ▁NULL ▁) ▁; ▁while ▁( ▁q ▁. ▁size ▁( ▁) ▁> ▁1 ▁) ▁{ ▁curr ▁= ▁q ▁. ▁front ▁( ▁) ▁; ▁q ▁. ▁pop ▁( ▁) ▁; ▁if ▁( ▁curr ▁== ▁NULL ▁) ▁{ ▁q ▁. ▁push ▁( ▁NULL ▁) ▁; ▁c out ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁} ▁else ▁{ ▁if ▁( ▁curr ▁-> ▁left ▁) ▁q ▁. ▁push ▁( ▁curr ▁-> ▁left ▁) ▁; ▁if ▁( ▁curr ▁-> ▁right ▁) ▁q ▁. ▁push ▁( ▁curr ▁-> ▁right ▁) ▁; ▁c out ▁<< ▁curr ▁-> ▁data ▁<< ▁" ▁" ▁; ▁} ▁} ▁} ▁node ▁* ▁newNode ▁( ▁int ▁data ▁) ▁{ ▁node ▁* ▁temp ▁= ▁new ▁node ▁; ▁temp ▁-> ▁data ▁= ▁data ▁; ▁temp ▁-> ▁left ▁= ▁NULL ▁; ▁temp ▁-> ▁right ▁= ▁NULL ▁; ▁return ▁temp ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁node ▁* ▁root ▁= ▁newNode ▁( ▁1 ▁) ▁; ▁root ▁-> ▁left ▁= ▁newNode ▁( ▁2 ▁) ▁; ▁root ▁-> ▁right ▁= ▁newNode ▁( ▁3 ▁) ▁; ▁root ▁-> ▁left ▁-> ▁left ▁= ▁newNode ▁( ▁4 ▁) ▁; ▁root ▁-> ▁left ▁-> ▁right ▁= ▁newNode ▁( ▁5 ▁) ▁; ▁root ▁-> ▁right ▁-> ▁right ▁= ▁newNode ▁( ▁6 ▁) ▁; ▁level Order ▁( ▁root ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁shortest Chain Len ▁( ▁string ▁start ▁, ▁string ▁target ▁, ▁set ▁< ▁string ▁> ▁& ▁D ▁) ▁{ ▁if ▁( ▁start ▁== ▁target ▁) ▁return ▁0 ▁; ▁if ▁( ▁D ▁. ▁find ▁( ▁target ▁) ▁== ▁D ▁. ▁end ▁( ▁) ▁) ▁return ▁0 ▁; ▁int ▁level ▁= ▁0 ▁, ▁word length ▁= ▁start ▁. ▁size ▁( ▁) ▁; ▁queue ▁< ▁string ▁> ▁Q ▁; ▁Q ▁. ▁push ▁( ▁start ▁) ▁; ▁while ▁( ▁! ▁Q ▁. ▁empty ▁( ▁) ▁) ▁{ ▁++ ▁level ▁; ▁int ▁sizeof Q ▁= ▁Q ▁. ▁size ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁sizeof Q ▁; ▁++ ▁i ▁) ▁{ ▁string ▁word ▁= ▁Q ▁. ▁front ▁( ▁) ▁; ▁Q ▁. ▁pop ▁( ▁) ▁; ▁for ▁( ▁int ▁pos ▁= ▁0 ▁; ▁pos ▁< ▁word length ▁; ▁++ ▁pos ▁) ▁{ ▁char ▁orig _ char ▁= ▁word ▁[ ▁pos ▁] ▁; ▁for ▁( ▁char ▁c ▁= ▁' ▁a ▁' ▁; ▁c ▁<= ▁' ▁z ▁' ▁; ▁++ ▁c ▁) ▁{ ▁word ▁[ ▁pos ▁] ▁= ▁c ▁; ▁if ▁( ▁word ▁== ▁target ▁) ▁return ▁level ▁+ ▁1 ▁; ▁if ▁( ▁D ▁. ▁find ▁( ▁word ▁) ▁== ▁D ▁. ▁end ▁( ▁) ▁) ▁continue ▁; ▁D ▁. ▁erase ▁( ▁word ▁) ▁; ▁Q ▁. ▁push ▁( ▁word ▁) ▁; ▁} ▁word ▁[ ▁pos ▁] ▁= ▁orig _ char ▁; ▁} ▁} ▁} ▁return ▁0 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁set ▁< ▁string ▁> ▁D ▁; ▁D ▁. ▁insert ▁( ▁" ▁po on ▁" ▁) ▁; ▁D ▁. ▁insert ▁( ▁" ▁p lee ▁" ▁) ▁; ▁D ▁. ▁insert ▁( ▁" ▁same ▁" ▁) ▁; ▁D ▁. ▁insert ▁( ▁" ▁po ie ▁" ▁) ▁; ▁D ▁. ▁insert ▁( ▁" ▁p lie ▁" ▁) ▁; ▁D ▁. ▁insert ▁( ▁" ▁p oin ▁" ▁) ▁; ▁D ▁. ▁insert ▁( ▁" ▁p le a ▁" ▁) ▁; ▁string ▁start ▁= ▁" ▁to on ▁" ▁; ▁string ▁target ▁= ▁" ▁p le a ▁" ▁; ▁c out ▁<< ▁" ▁Length ▁of ▁shortest ▁chain ▁is ▁: ▁" ▁<< ▁shortest Chain Len ▁( ▁start ▁, ▁target ▁, ▁D ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁struct ▁Node ▁{ ▁int ▁data ▁; ▁struct ▁Node ▁* ▁next ▁; ▁} ▁; ▁void ▁push ▁( ▁struct ▁Node ▁* ▁* ▁head _ ref ▁, ▁int ▁new _ data ▁) ▁{ ▁struct ▁Node ▁* ▁new _ node ▁= ▁( ▁struct ▁Node ▁* ▁) ▁m alloc ▁( ▁sizeof ▁( ▁struct ▁Node ▁) ▁) ▁; ▁new _ node ▁-> ▁data ▁= ▁new _ data ▁; ▁new _ node ▁-> ▁next ▁= ▁( ▁* ▁head _ ref ▁) ▁; ▁( ▁* ▁head _ ref ▁) ▁= ▁new _ node ▁; ▁} ▁void ▁print List ▁( ▁struct ▁Node ▁* ▁node ▁) ▁{ ▁while ▁( ▁node ▁!= ▁NULL ▁) ▁{ ▁c out ▁<< ▁node ▁-> ▁data ▁<< ▁" ▁" ▁; ▁node ▁= ▁node ▁-> ▁next ▁; ▁} ▁c out ▁<< ▁end l ▁; ▁} ▁int ▁count Nodes ▁( ▁struct ▁Node ▁* ▁s ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁while ▁( ▁s ▁!= ▁NULL ▁) ▁{ ▁count ▁++ ▁; ▁s ▁= ▁s ▁-> ▁next ▁; ▁} ▁return ▁count ▁; ▁} ▁void ▁swap K th ▁( ▁struct ▁Node ▁* ▁* ▁head _ ref ▁, ▁int ▁k ▁) ▁{ ▁int ▁n ▁= ▁count Nodes ▁( ▁* ▁head _ ref ▁) ▁; ▁if ▁( ▁n ▁< ▁k ▁) ▁return ▁; ▁if ▁( ▁2 ▁* ▁k ▁- ▁1 ▁== ▁n ▁) ▁return ▁; ▁Node ▁* ▁x ▁= ▁* ▁head _ ref ▁; ▁Node ▁* ▁x _ prev ▁= ▁NULL ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁k ▁; ▁i ▁++ ▁) ▁{ ▁x _ prev ▁= ▁x ▁; ▁x ▁= ▁x ▁-> ▁next ▁; ▁} ▁Node ▁* ▁y ▁= ▁* ▁head _ ref ▁; ▁Node ▁* ▁y _ prev ▁= ▁NULL ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁- ▁k ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁y _ prev ▁= ▁y ▁; ▁y ▁= ▁y ▁-> ▁next ▁; ▁} ▁if ▁( ▁x _ prev ▁) ▁x _ prev ▁-> ▁next ▁= ▁y ▁; ▁if ▁( ▁y _ prev ▁) ▁y _ prev ▁-> ▁next ▁= ▁x ▁; ▁Node ▁* ▁temp ▁= ▁x ▁-> ▁next ▁; ▁x ▁-> ▁next ▁= ▁y ▁-> ▁next ▁; ▁y ▁-> ▁next ▁= ▁temp ▁; ▁if ▁( ▁k ▁== ▁1 ▁) ▁* ▁head _ ref ▁= ▁y ▁; ▁if ▁( ▁k ▁== ▁n ▁) ▁* ▁head _ ref ▁= ▁x ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁struct ▁Node ▁* ▁head ▁= ▁NULL ▁; ▁for ▁( ▁int ▁i ▁= ▁8 ▁; ▁i ▁>= ▁1 ▁; ▁i ▁-- ▁) ▁push ▁( ▁& ▁head ▁, ▁i ▁) ▁; ▁c out ▁<< ▁" ▁Original ▁Linked ▁List ▁: ▁" ▁; ▁print List ▁( ▁head ▁) ▁; ▁for ▁( ▁int ▁k ▁= ▁1 ▁; ▁k ▁< ▁9 ▁; ▁k ▁++ ▁) ▁{ ▁swap K th ▁( ▁& ▁head ▁, ▁k ▁) ▁; ▁c out ▁<< ▁" ▁Modified ▁List ▁for ▁k ▁= ▁" ▁print List ▁( ▁head ▁) ▁; ▁} ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁struct ▁Node ▁{ ▁int ▁data ▁; ▁struct ▁Node ▁* ▁next ▁, ▁* ▁prev ▁; ▁} ▁; ▁int ▁count Pairs ▁( ▁struct ▁Node ▁* ▁first ▁, ▁struct ▁Node ▁* ▁second ▁, ▁int ▁value ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁while ▁( ▁first ▁!= ▁NULL ▁&& ▁second ▁!= ▁NULL ▁&& ▁first ▁!= ▁second ▁&& ▁second ▁-> ▁next ▁!= ▁first ▁) ▁{ ▁if ▁( ▁( ▁first ▁-> ▁data ▁+ ▁second ▁-> ▁data ▁) ▁== ▁value ▁) ▁{ ▁count ▁++ ▁; ▁first ▁= ▁first ▁-> ▁next ▁; ▁second ▁= ▁second ▁-> ▁prev ▁; ▁} ▁else ▁if ▁( ▁( ▁first ▁-> ▁data ▁+ ▁second ▁-> ▁data ▁) ▁> ▁value ▁) ▁second ▁= ▁second ▁-> ▁prev ▁; ▁else ▁first ▁= ▁first ▁-> ▁next ▁; ▁} ▁return ▁count ▁; ▁} ▁int ▁count Tri pl ets ▁( ▁struct ▁Node ▁* ▁head ▁, ▁int ▁x ▁) ▁{ ▁if ▁( ▁head ▁== ▁NULL ▁) ▁return ▁0 ▁; ▁struct ▁Node ▁* ▁current ▁, ▁* ▁first ▁, ▁* ▁last ▁; ▁int ▁count ▁= ▁0 ▁; ▁last ▁= ▁head ▁; ▁while ▁( ▁last ▁-> ▁next ▁!= ▁NULL ▁) ▁last ▁= ▁last ▁-> ▁next ▁; ▁for ▁( ▁current ▁= ▁head ▁; ▁current ▁!= ▁NULL ▁; ▁current ▁= ▁current ▁-> ▁next ▁) ▁{ ▁first ▁= ▁current ▁-> ▁next ▁; ▁count ▁+= ▁count Pairs ▁( ▁first ▁, ▁last ▁, ▁x ▁- ▁current ▁-> ▁data ▁) ▁; ▁} ▁return ▁count ▁; ▁} ▁void ▁insert ▁( ▁struct ▁Node ▁* ▁* ▁head ▁, ▁int ▁data ▁) ▁{ ▁struct ▁Node ▁* ▁temp ▁= ▁new ▁Node ▁( ▁) ▁; ▁temp ▁-> ▁data ▁= ▁data ▁; ▁temp ▁-> ▁next ▁= ▁temp ▁-> ▁prev ▁= ▁NULL ▁; ▁if ▁( ▁( ▁* ▁head ▁) ▁== ▁NULL ▁) ▁( ▁* ▁head ▁) ▁= ▁temp ▁; ▁else ▁{ ▁temp ▁-> ▁next ▁= ▁* ▁head ▁; ▁( ▁* ▁head ▁) ▁-> ▁prev ▁= ▁temp ▁; ▁( ▁* ▁head ▁) ▁= ▁temp ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁struct ▁Node ▁* ▁head ▁= ▁NULL ▁; ▁insert ▁( ▁& ▁head ▁, ▁9 ▁) ▁; ▁insert ▁( ▁& ▁head ▁, ▁8 ▁) ▁; ▁insert ▁( ▁& ▁head ▁, ▁6 ▁) ▁; ▁insert ▁( ▁& ▁head ▁, ▁5 ▁) ▁; ▁insert ▁( ▁& ▁head ▁, ▁4 ▁) ▁; ▁insert ▁( ▁& ▁head ▁, ▁2 ▁) ▁; ▁insert ▁( ▁& ▁head ▁, ▁1 ▁) ▁; ▁int ▁x ▁= ▁17 ▁; ▁c out ▁<< ▁" ▁Count ▁= ▁" ▁<< ▁count Tri pl ets ▁( ▁head ▁, ▁x ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁struct ▁Node ▁{ ▁char ▁data ▁; ▁struct ▁Node ▁* ▁next ▁; ▁} ▁; ▁Node ▁* ▁newNode ▁( ▁char ▁key ▁) ▁{ ▁Node ▁* ▁temp ▁= ▁new ▁Node ▁; ▁temp ▁-> ▁data ▁= ▁key ▁; ▁temp ▁-> ▁next ▁= ▁NULL ▁; ▁return ▁temp ▁; ▁} ▁void ▁print list ▁( ▁Node ▁* ▁head ▁) ▁{ ▁if ▁( ▁! ▁head ▁) ▁{ ▁c out ▁<< ▁" ▁Empty ▁List ▁STRNEWLINE ▁" ▁; ▁return ▁; ▁} ▁while ▁( ▁head ▁!= ▁NULL ▁) ▁{ ▁c out ▁<< ▁head ▁-> ▁data ▁<< ▁" ▁" ▁; ▁if ▁( ▁head ▁-> ▁next ▁) ▁c out ▁<< ▁" ▁- ▁> ▁" ▁; ▁head ▁= ▁head ▁-> ▁next ▁; ▁} ▁c out ▁<< ▁end l ▁; ▁} ▁bool ▁is V ow el ▁( ▁char ▁x ▁) ▁{ ▁return ▁( ▁x ▁== ▁' ▁a ▁' ▁x ▁== ▁' ▁e ▁' ▁x ▁== ▁' ▁i ▁' ▁x ▁== ▁' ▁o ▁' ▁x ▁== ▁' ▁u ▁' ▁) ▁; ▁} ▁Node ▁* ▁arrange ▁( ▁Node ▁* ▁head ▁) ▁{ ▁Node ▁* ▁new Head ▁= ▁head ▁; ▁Node ▁* ▁latest V ow el ▁; ▁Node ▁* ▁curr ▁= ▁head ▁; ▁if ▁( ▁head ▁== ▁NULL ▁) ▁return ▁NULL ▁; ▁if ▁( ▁is V ow el ▁( ▁head ▁-> ▁data ▁) ▁) ▁latest V ow el ▁= ▁head ▁; ▁else ▁{ ▁while ▁( ▁curr ▁-> ▁next ▁!= ▁NULL ▁&& ▁! ▁is V ow el ▁( ▁curr ▁-> ▁next ▁-> ▁data ▁) ▁) ▁curr ▁= ▁curr ▁-> ▁next ▁; ▁if ▁( ▁curr ▁-> ▁next ▁== ▁NULL ▁) ▁return ▁head ▁; ▁latest V ow el ▁= ▁new Head ▁= ▁curr ▁-> ▁next ▁; ▁curr ▁-> ▁next ▁= ▁curr ▁-> ▁next ▁-> ▁next ▁; ▁latest V ow el ▁-> ▁next ▁= ▁head ▁; ▁} ▁while ▁( ▁curr ▁!= ▁NULL ▁&& ▁curr ▁-> ▁next ▁!= ▁NULL ▁) ▁{ ▁if ▁( ▁is V ow el ▁( ▁curr ▁-> ▁next ▁-> ▁data ▁) ▁) ▁{ ▁if ▁( ▁curr ▁== ▁latest V ow el ▁) ▁{ ▁latest V ow el ▁= ▁curr ▁= ▁curr ▁-> ▁next ▁; ▁} ▁else ▁{ ▁Node ▁* ▁temp ▁= ▁latest V ow el ▁-> ▁next ▁; ▁latest V ow el ▁-> ▁next ▁= ▁curr ▁-> ▁next ▁; ▁latest V ow el ▁= ▁latest V ow el ▁-> ▁next ▁; ▁curr ▁-> ▁next ▁= ▁curr ▁-> ▁next ▁-> ▁next ▁; ▁latest V ow el ▁-> ▁next ▁= ▁temp ▁; ▁} ▁} ▁else ▁{ ▁curr ▁= ▁curr ▁-> ▁next ▁; ▁} ▁} ▁return ▁new Head ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁Node ▁* ▁head ▁= ▁newNode ▁( ▁' ▁a ▁' ▁) ▁; ▁head ▁-> ▁next ▁= ▁newNode ▁( ▁' ▁b ▁' ▁) ▁; ▁head ▁-> ▁next ▁-> ▁next ▁= ▁newNode ▁( ▁' ▁c ▁' ▁) ▁; ▁head ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁= ▁newNode ▁( ▁' ▁e ▁' ▁) ▁; ▁head ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁= ▁newNode ▁( ▁' ▁d ▁' ▁) ▁; ▁head ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁= ▁newNode ▁( ▁' ▁o ▁' ▁) ▁; ▁head ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁= ▁newNode ▁( ▁' ▁x ▁' ▁) ▁; ▁head ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁= ▁newNode ▁( ▁' ▁i ▁' ▁) ▁; ▁printf ▁( ▁" ▁Linked ▁list ▁before ▁: ▁STRNEWLINE ▁" ▁) ▁; ▁print list ▁( ▁head ▁) ▁; ▁head ▁= ▁arrange ▁( ▁head ▁) ▁; ▁printf ▁( ▁" ▁Linked ▁list ▁after ▁: ▁STRNEWLINE ▁" ▁) ▁; ▁print list ▁( ▁head ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁struct ▁Node ▁{ ▁int ▁data ▁; ▁Node ▁* ▁left ▁, ▁* ▁right ▁; ▁Node ▁( ▁int ▁x ▁) ▁{ ▁data ▁= ▁x ▁; ▁left ▁= ▁right ▁= ▁NULL ▁; ▁} ▁} ▁; ▁Node ▁* ▁insert ▁( ▁Node ▁* ▁root ▁, ▁int ▁x ▁) ▁{ ▁if ▁( ▁root ▁== ▁NULL ▁) ▁return ▁new ▁Node ▁( ▁x ▁) ▁; ▁if ▁( ▁x ▁< ▁root ▁-> ▁data ▁) ▁root ▁-> ▁left ▁= ▁insert ▁( ▁root ▁-> ▁left ▁, ▁x ▁) ▁; ▁else ▁if ▁( ▁x ▁> ▁root ▁-> ▁data ▁) ▁root ▁-> ▁right ▁= ▁insert ▁( ▁root ▁-> ▁right ▁, ▁x ▁) ▁; ▁return ▁root ▁; ▁} ▁Node ▁* ▁k th Small est ▁( ▁Node ▁* ▁root ▁, ▁int ▁& ▁k ▁) ▁{ ▁if ▁( ▁root ▁== ▁NULL ▁) ▁return ▁NULL ▁; ▁Node ▁* ▁left ▁= ▁k th Small est ▁( ▁root ▁-> ▁left ▁, ▁k ▁) ▁; ▁if ▁( ▁left ▁!= ▁NULL ▁) ▁return ▁left ▁; ▁k ▁-- ▁; ▁if ▁( ▁k ▁== ▁0 ▁) ▁return ▁root ▁; ▁return ▁k th Small est ▁( ▁root ▁-> ▁right ▁, ▁k ▁) ▁; ▁} ▁void ▁print K th Small est ▁( ▁Node ▁* ▁root ▁, ▁int ▁k ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁Node ▁* ▁res ▁= ▁k th Small est ▁( ▁root ▁, ▁k ▁) ▁; ▁if ▁( ▁res ▁== ▁NULL ▁) ▁c out ▁<< ▁" ▁There ▁are ▁less ▁than ▁k ▁nodes ▁in ▁the ▁B ST ▁" ▁; ▁else ▁c out ▁<< ▁" ▁K ▁- ▁th ▁Small est ▁Element ▁is ▁" ▁<< ▁res ▁-> ▁data ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁Node ▁* ▁root ▁= ▁NULL ▁; ▁int ▁keys ▁[ ▁] ▁= ▁{ ▁20 ▁, ▁8 ▁, ▁22 ▁, ▁4 ▁, ▁12 ▁, ▁10 ▁, ▁14 ▁} ▁; ▁for ▁( ▁int ▁x ▁: ▁keys ▁) ▁root ▁= ▁insert ▁( ▁root ▁, ▁x ▁) ▁; ▁int ▁k ▁= ▁3 ▁; ▁print K th Small est ▁( ▁root ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁struct ▁Node ▁{ ▁struct ▁Node ▁* ▁left ▁, ▁* ▁right ▁; ▁int ▁key ▁; ▁} ▁; ▁struct ▁Node ▁* ▁newNode ▁( ▁int ▁key ▁) ▁{ ▁struct ▁Node ▁* ▁ptr ▁= ▁new ▁Node ▁; ▁ptr ▁-> ▁key ▁= ▁key ▁; ▁ptr ▁-> ▁left ▁= ▁ptr ▁-> ▁right ▁= ▁NULL ▁; ▁return ▁ptr ▁; ▁} ▁struct ▁Node ▁* ▁insert ▁( ▁struct ▁Node ▁* ▁root ▁, ▁int ▁key ▁) ▁{ ▁if ▁( ▁! ▁root ▁) ▁root ▁= ▁newNode ▁( ▁key ▁) ▁; ▁else ▁if ▁( ▁root ▁-> ▁key ▁> ▁key ▁) ▁root ▁-> ▁left ▁= ▁insert ▁( ▁root ▁-> ▁left ▁, ▁key ▁) ▁; ▁else ▁if ▁( ▁root ▁-> ▁key ▁< ▁key ▁) ▁root ▁-> ▁right ▁= ▁insert ▁( ▁root ▁-> ▁right ▁, ▁key ▁) ▁; ▁return ▁root ▁; ▁} ▁int ▁distance From Root ▁( ▁struct ▁Node ▁* ▁root ▁, ▁int ▁x ▁) ▁{ ▁if ▁( ▁root ▁-> ▁key ▁== ▁x ▁) ▁return ▁0 ▁; ▁else ▁if ▁( ▁root ▁-> ▁key ▁> ▁x ▁) ▁return ▁1 ▁+ ▁distance From Root ▁( ▁root ▁-> ▁left ▁, ▁x ▁) ▁; ▁return ▁1 ▁+ ▁distance From Root ▁( ▁root ▁-> ▁right ▁, ▁x ▁) ▁; ▁} ▁int ▁distance Between 2 ▁( ▁struct ▁Node ▁* ▁root ▁, ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁if ▁( ▁! ▁root ▁) ▁return ▁0 ▁; ▁if ▁( ▁root ▁-> ▁key ▁> ▁a ▁&& ▁root ▁-> ▁key ▁> ▁b ▁) ▁return ▁distance Between 2 ▁( ▁root ▁-> ▁left ▁, ▁a ▁, ▁b ▁) ▁; ▁if ▁( ▁root ▁-> ▁key ▁< ▁a ▁&& ▁root ▁-> ▁key ▁< ▁b ▁) ▁return ▁distance Between 2 ▁( ▁root ▁-> ▁right ▁, ▁a ▁, ▁b ▁) ▁; ▁if ▁( ▁root ▁-> ▁key ▁>= ▁a ▁&& ▁root ▁-> ▁key ▁<= ▁b ▁) ▁return ▁distance From Root ▁( ▁root ▁, ▁a ▁) ▁+ ▁distance From Root ▁( ▁root ▁, ▁b ▁) ▁; ▁} ▁int ▁find Dist Wrapper ▁( ▁Node ▁* ▁root ▁, ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁if ▁( ▁a ▁> ▁b ▁) ▁swap ▁( ▁a ▁, ▁b ▁) ▁; ▁return ▁distance Between 2 ▁( ▁root ▁, ▁a ▁, ▁b ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁struct ▁Node ▁* ▁root ▁= ▁NULL ▁; ▁root ▁= ▁insert ▁( ▁root ▁, ▁20 ▁) ▁; ▁insert ▁( ▁root ▁, ▁10 ▁) ▁; ▁insert ▁( ▁root ▁, ▁5 ▁) ▁; ▁insert ▁( ▁root ▁, ▁15 ▁) ▁; ▁insert ▁( ▁root ▁, ▁30 ▁) ▁; ▁insert ▁( ▁root ▁, ▁25 ▁) ▁; ▁insert ▁( ▁root ▁, ▁35 ▁) ▁; ▁int ▁a ▁= ▁5 ▁, ▁b ▁= ▁55 ▁; ▁c out ▁<< ▁find Dist Wrapper ▁( ▁root ▁, ▁5 ▁, ▁35 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁struct ▁node ▁{ ▁int ▁data ▁; ▁struct ▁node ▁* ▁left ▁, ▁* ▁right ▁; ▁} ▁; ▁bool ▁in Range ▁( ▁node ▁* ▁root ▁, ▁int ▁low ▁, ▁int ▁high ▁) ▁{ ▁return ▁root ▁-> ▁data ▁>= ▁low ▁&& ▁root ▁-> ▁data ▁<= ▁high ▁; ▁} ▁bool ▁getCount Util ▁( ▁node ▁* ▁root ▁, ▁int ▁low ▁, ▁int ▁high ▁, ▁int ▁* ▁count ▁) ▁{ ▁if ▁( ▁root ▁== ▁NULL ▁) ▁return ▁true ▁; ▁bool ▁l ▁= ▁getCount Util ▁( ▁root ▁-> ▁left ▁, ▁low ▁, ▁high ▁, ▁count ▁) ▁; ▁bool ▁r ▁= ▁getCount Util ▁( ▁root ▁-> ▁right ▁, ▁low ▁, ▁high ▁, ▁count ▁) ▁; ▁if ▁( ▁l ▁&& ▁r ▁&& ▁in Range ▁( ▁root ▁, ▁low ▁, ▁high ▁) ▁) ▁{ ▁++ ▁* ▁count ▁; ▁return ▁true ▁; ▁} ▁return ▁false ▁; ▁} ▁int ▁getCount ▁( ▁node ▁* ▁root ▁, ▁int ▁low ▁, ▁int ▁high ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁getCount Util ▁( ▁root ▁, ▁low ▁, ▁high ▁, ▁& ▁count ▁) ▁; ▁return ▁count ▁; ▁} ▁node ▁* ▁newNode ▁( ▁int ▁data ▁) ▁{ ▁node ▁* ▁temp ▁= ▁new ▁node ▁; ▁temp ▁-> ▁data ▁= ▁data ▁; ▁temp ▁-> ▁left ▁= ▁temp ▁-> ▁right ▁= ▁NULL ▁; ▁return ▁( ▁temp ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁node ▁* ▁root ▁= ▁newNode ▁( ▁10 ▁) ▁; ▁root ▁-> ▁left ▁= ▁newNode ▁( ▁5 ▁) ▁; ▁root ▁-> ▁right ▁= ▁newNode ▁( ▁50 ▁) ▁; ▁root ▁-> ▁left ▁-> ▁left ▁= ▁newNode ▁( ▁1 ▁) ▁; ▁root ▁-> ▁right ▁-> ▁left ▁= ▁newNode ▁( ▁40 ▁) ▁; ▁root ▁-> ▁right ▁-> ▁right ▁= ▁newNode ▁( ▁100 ▁) ▁; ▁int ▁l ▁= ▁5 ▁; ▁int ▁h ▁= ▁45 ▁; ▁c out ▁<< ▁" ▁Count ▁of ▁sub trees ▁in ▁[ ▁" ▁<< ▁l ▁<< ▁" ▁, ▁" ▁<< ▁h ▁<< ▁" ▁] ▁is ▁" ▁<< ▁getCount ▁( ▁root ▁, ▁l ▁, ▁h ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print Sorted ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁start ▁, ▁int ▁end ▁) ▁{ ▁if ▁( ▁start ▁> ▁end ▁) ▁return ▁; ▁print Sorted ▁( ▁arr ▁, ▁start ▁* ▁2 ▁+ ▁1 ▁, ▁end ▁) ▁; ▁c out ▁<< ▁arr ▁[ ▁start ▁] ▁<< ▁" ▁" ▁; ▁print Sorted ▁( ▁arr ▁, ▁start ▁* ▁2 ▁+ ▁2 ▁, ▁end ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁2 ▁, ▁5 ▁, ▁1 ▁, ▁3 ▁} ▁; ▁int ▁arr _ size ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁print Sorted ▁( ▁arr ▁, ▁0 ▁, ▁arr _ size ▁- ▁1 ▁) ▁; ▁get char ▁( ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Min O pe art ion ▁( ▁int ▁matrix ▁[ ▁] ▁[ ▁2 ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁sum Row ▁[ ▁n ▁] ▁, ▁sum Col ▁[ ▁n ▁] ▁; ▁mem set ▁( ▁sum Row ▁, ▁0 ▁, ▁sizeof ▁( ▁sum Row ▁) ▁) ▁; ▁mem set ▁( ▁sum Col ▁, ▁0 ▁, ▁sizeof ▁( ▁sum Col ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁++ ▁j ▁) ▁{ ▁sum Row ▁[ ▁i ▁] ▁+= ▁matrix ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁sum Col ▁[ ▁j ▁] ▁+= ▁matrix ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁} ▁int ▁max Sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁{ ▁max Sum ▁= ▁max ▁( ▁max Sum ▁, ▁sum Row ▁[ ▁i ▁] ▁) ▁; ▁max Sum ▁= ▁max ▁( ▁max Sum ▁, ▁sum Col ▁[ ▁i ▁] ▁) ▁; ▁} ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁, ▁j ▁= ▁0 ▁; ▁i ▁< ▁n ▁&& ▁j ▁< ▁n ▁; ▁) ▁{ ▁int ▁diff ▁= ▁min ▁( ▁max Sum ▁- ▁sum Row ▁[ ▁i ▁] ▁, ▁max Sum ▁- ▁sum Col ▁[ ▁j ▁] ▁) ▁; ▁matrix ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+= ▁diff ▁; ▁sum Row ▁[ ▁i ▁] ▁+= ▁diff ▁; ▁sum Col ▁[ ▁j ▁] ▁+= ▁diff ▁; ▁count ▁+= ▁diff ▁; ▁if ▁( ▁sum Row ▁[ ▁i ▁] ▁== ▁max Sum ▁) ▁++ ▁i ▁; ▁if ▁( ▁sum Col ▁[ ▁j ▁] ▁== ▁max Sum ▁) ▁++ ▁j ▁; ▁} ▁return ▁count ▁; ▁} ▁void ▁print Matrix ▁( ▁int ▁matrix ▁[ ▁] ▁[ ▁2 ▁] ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁++ ▁j ▁) ▁c out ▁<< ▁matrix ▁[ ▁i ▁] ▁[ ▁j ▁] ▁<< ▁" ▁" ▁; ▁c out ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁matrix ▁[ ▁] ▁[ ▁2 ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁} ▁, ▁{ ▁3 ▁, ▁4 ▁} ▁} ▁; ▁c out ▁<< ▁find Min O pe art ion ▁( ▁matrix ▁, ▁2 ▁) ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁print Matrix ▁( ▁matrix ▁, ▁2 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁search ▁( ▁int ▁mat ▁[ ▁4 ▁] ▁[ ▁4 ▁] ▁, ▁int ▁n ▁, ▁int ▁x ▁) ▁{ ▁if ▁( ▁n ▁== ▁0 ▁) ▁return ▁-1 ▁; ▁int ▁smallest ▁= ▁mat ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁, ▁largest ▁= ▁mat ▁[ ▁n ▁- ▁1 ▁] ▁[ ▁n ▁- ▁1 ▁] ▁; ▁if ▁( ▁x ▁< ▁smallest ▁x ▁> ▁largest ▁) ▁return ▁-1 ▁; ▁int ▁i ▁= ▁0 ▁, ▁j ▁= ▁n ▁- ▁1 ▁; ▁while ▁( ▁i ▁< ▁n ▁&& ▁j ▁>= ▁0 ▁) ▁{ ▁if ▁( ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁== ▁x ▁) ▁{ ▁c out ▁<< ▁" ▁n ▁Found ▁at ▁" ▁<< ▁i ▁<< ▁" ▁, ▁" ▁<< ▁j ▁; ▁return ▁1 ▁; ▁} ▁if ▁( ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁> ▁x ▁) ▁j ▁-- ▁; ▁else ▁i ▁++ ▁; ▁} ▁c out ▁<< ▁" ▁n ▁Element ▁not ▁found ▁" ▁; ▁return ▁0 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁mat ▁[ ▁4 ▁] ▁[ ▁4 ▁] ▁= ▁{ ▁{ ▁10 ▁, ▁20 ▁, ▁30 ▁, ▁40 ▁} ▁, ▁{ ▁15 ▁, ▁25 ▁, ▁35 ▁, ▁45 ▁} ▁, ▁{ ▁27 ▁, ▁29 ▁, ▁37 ▁, ▁48 ▁} ▁, ▁{ ▁32 ▁, ▁33 ▁, ▁39 ▁, ▁50 ▁} ▁} ▁; ▁search ▁( ▁mat ▁, ▁4 ▁, ▁29 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁int ▁MAX ▁= ▁100 ▁; ▁bool ▁are Sum Same ▁( ▁int ▁a ▁[ ▁] ▁[ ▁MAX ▁] ▁, ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁int ▁sum 1 ▁= ▁0 ▁, ▁sum 2 ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁sum 1 ▁= ▁0 ▁, ▁sum 2 ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁m ▁; ▁j ▁++ ▁) ▁{ ▁sum 1 ▁+= ▁a ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁sum 2 ▁+= ▁a ▁[ ▁j ▁] ▁[ ▁i ▁] ▁; ▁} ▁if ▁( ▁sum 1 ▁== ▁sum 2 ▁) ▁return ▁true ▁; ▁} ▁return ▁false ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁4 ▁; ▁int ▁m ▁= ▁4 ▁; ▁int ▁M ▁[ ▁n ▁] ▁[ ▁MAX ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁, ▁{ ▁9 ▁, ▁5 ▁, ▁3 ▁, ▁1 ▁} ▁, ▁{ ▁0 ▁, ▁3 ▁, ▁5 ▁, ▁6 ▁} ▁, ▁{ ▁0 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁} ▁} ▁; ▁c out ▁<< ▁are Sum Same ▁( ▁M ▁, ▁n ▁, ▁m ▁) ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁# define ▁N ▁5 ▁NEW _ LINE ▁# define ▁M ▁5 ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁min Operation ▁( ▁bool ▁arr ▁[ ▁N ▁] ▁[ ▁M ▁] ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁N ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁M ▁- ▁1 ▁; ▁j ▁>= ▁0 ▁; ▁j ▁-- ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁[ ▁j ▁] ▁== ▁0 ▁) ▁{ ▁ans ▁++ ▁; ▁for ▁( ▁int ▁k ▁= ▁0 ▁; ▁k ▁<= ▁i ▁; ▁k ▁++ ▁) ▁{ ▁for ▁( ▁int ▁h ▁= ▁0 ▁; ▁h ▁<= ▁j ▁; ▁h ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁k ▁] ▁[ ▁h ▁] ▁== ▁1 ▁) ▁arr ▁[ ▁k ▁] ▁[ ▁h ▁] ▁= ▁0 ▁; ▁else ▁arr ▁[ ▁k ▁] ▁[ ▁h ▁] ▁= ▁1 ▁; ▁} ▁} ▁} ▁} ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁bool ▁mat ▁[ ▁N ▁] ▁[ ▁M ▁] ▁= ▁{ ▁0 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁} ▁; ▁c out ▁<< ▁min Operation ▁( ▁mat ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁sp ir al D ia Sum ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁1 ▁) ▁return ▁1 ▁; ▁return ▁( ▁4 ▁* ▁n ▁* ▁n ▁- ▁6 ▁* ▁n ▁+ ▁6 ▁+ ▁sp ir al D ia Sum ▁( ▁n ▁- ▁2 ▁) ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁7 ▁; ▁c out ▁<< ▁sp ir al D ia Sum ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁int ▁MAX ▁= ▁100 ▁; ▁void ▁print Matrix Diag onal ▁( ▁int ▁mat ▁[ ▁MAX ▁] ▁[ ▁MAX ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁i ▁= ▁0 ▁, ▁j ▁= ▁0 ▁; ▁bool ▁is Up ▁= ▁true ▁; ▁for ▁( ▁int ▁k ▁= ▁0 ▁; ▁k ▁< ▁n ▁* ▁n ▁; ▁) ▁{ ▁if ▁( ▁is Up ▁) ▁{ ▁for ▁( ▁; ▁i ▁>= ▁0 ▁&& ▁j ▁< ▁n ▁; ▁j ▁++ ▁, ▁i ▁-- ▁) ▁{ ▁c out ▁<< ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁<< ▁" ▁" ▁; ▁k ▁++ ▁; ▁} ▁if ▁( ▁i ▁< ▁0 ▁&& ▁j ▁<= ▁n ▁- ▁1 ▁) ▁i ▁= ▁0 ▁; ▁if ▁( ▁j ▁== ▁n ▁) ▁i ▁= ▁i ▁+ ▁2 ▁, ▁j ▁-- ▁; ▁} ▁else ▁{ ▁for ▁( ▁; ▁j ▁>= ▁0 ▁&& ▁i ▁< ▁n ▁; ▁i ▁++ ▁, ▁j ▁-- ▁) ▁{ ▁c out ▁<< ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁<< ▁" ▁" ▁; ▁k ▁++ ▁; ▁} ▁if ▁( ▁j ▁< ▁0 ▁&& ▁i ▁<= ▁n ▁- ▁1 ▁) ▁j ▁= ▁0 ▁; ▁if ▁( ▁i ▁== ▁n ▁) ▁j ▁= ▁j ▁+ ▁2 ▁, ▁i ▁-- ▁; ▁} ▁is Up ▁= ▁! ▁is Up ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁mat ▁[ ▁MAX ▁] ▁[ ▁MAX ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁, ▁{ ▁4 ▁, ▁5 ▁, ▁6 ▁} ▁, ▁{ ▁7 ▁, ▁8 ▁, ▁9 ▁} ▁} ▁; ▁int ▁n ▁= ▁3 ▁; ▁print Matrix Diag onal ▁( ▁mat ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁R ▁3 ▁NEW _ LINE ▁# define ▁C ▁4 ▁NEW _ LINE ▁int ▁gcd ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁if ▁( ▁b ▁== ▁0 ▁) ▁return ▁a ▁; ▁return ▁gcd ▁( ▁b ▁, ▁a ▁% ▁b ▁) ▁; ▁} ▁void ▁replace matrix ▁( ▁int ▁mat ▁[ ▁R ▁] ▁[ ▁C ▁] ▁, ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁int ▁rg cd ▁[ ▁R ▁] ▁= ▁{ ▁0 ▁} ▁, ▁cg cd ▁[ ▁C ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁m ▁; ▁j ▁++ ▁) ▁{ ▁rg cd ▁[ ▁i ▁] ▁= ▁gcd ▁( ▁rg cd ▁[ ▁i ▁] ▁, ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁; ▁cg cd ▁[ ▁j ▁] ▁= ▁gcd ▁( ▁cg cd ▁[ ▁j ▁] ▁, ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁m ▁; ▁j ▁++ ▁) ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁max ▁( ▁rg cd ▁[ ▁i ▁] ▁, ▁cg cd ▁[ ▁j ▁] ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁m ▁[ ▁R ▁] ▁[ ▁C ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁, ▁6 ▁, ▁7 ▁, ▁8 ▁, ▁9 ▁, ▁9 ▁, ▁} ▁; ▁replace matrix ▁( ▁m ▁, ▁R ▁, ▁C ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁R ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁C ▁; ▁j ▁++ ▁) ▁c out ▁<< ▁m ▁[ ▁i ▁] ▁[ ▁j ▁] ▁<< ▁" ▁" ▁; ▁c out ▁<< ▁end l ▁; ▁} ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁# define ▁MAX ▁100 ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁sorted Count ▁( ▁int ▁mat ▁[ ▁] ▁[ ▁MAX ▁] ▁, ▁int ▁r ▁, ▁int ▁c ▁) ▁{ ▁int ▁result ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁r ▁; ▁i ▁++ ▁) ▁{ ▁int ▁j ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁c ▁- ▁1 ▁; ▁j ▁++ ▁) ▁if ▁( ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁+ ▁1 ▁] ▁<= ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁break ▁; ▁if ▁( ▁j ▁== ▁c ▁- ▁1 ▁) ▁result ▁++ ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁r ▁; ▁i ▁++ ▁) ▁{ ▁int ▁j ▁; ▁for ▁( ▁j ▁= ▁c ▁- ▁1 ▁; ▁j ▁> ▁0 ▁; ▁j ▁-- ▁) ▁if ▁( ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁<= ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁break ▁; ▁if ▁( ▁c ▁> ▁1 ▁&& ▁j ▁== ▁0 ▁) ▁result ▁++ ▁; ▁} ▁return ▁result ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁m ▁= ▁4 ▁, ▁n ▁= ▁5 ▁; ▁int ▁mat ▁[ ▁] ▁[ ▁MAX ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁, ▁{ ▁4 ▁, ▁3 ▁, ▁1 ▁, ▁2 ▁, ▁6 ▁} ▁, ▁{ ▁8 ▁, ▁7 ▁, ▁6 ▁, ▁5 ▁, ▁4 ▁} ▁, ▁{ ▁5 ▁, ▁7 ▁, ▁8 ▁, ▁9 ▁, ▁10 ▁} ▁} ▁; ▁c out ▁<< ▁sorted Count ▁( ▁mat ▁, ▁m ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁N ▁5 ▁NEW _ LINE ▁int ▁find Max Value ▁( ▁int ▁mat ▁[ ▁] ▁[ ▁N ▁] ▁) ▁{ ▁int ▁maxValue ▁= ▁INT _ MIN ▁; ▁int ▁max Arr ▁[ ▁N ▁] ▁[ ▁N ▁] ▁; ▁max Arr ▁[ ▁N ▁- ▁1 ▁] ▁[ ▁N ▁- ▁1 ▁] ▁= ▁mat ▁[ ▁N ▁- ▁1 ▁] ▁[ ▁N ▁- ▁1 ▁] ▁; ▁int ▁max v ▁= ▁mat ▁[ ▁N ▁- ▁1 ▁] ▁[ ▁N ▁- ▁1 ▁] ▁; ▁for ▁( ▁int ▁j ▁= ▁N ▁- ▁2 ▁; ▁j ▁>= ▁0 ▁; ▁j ▁-- ▁) ▁{ ▁if ▁( ▁mat ▁[ ▁N ▁- ▁1 ▁] ▁[ ▁j ▁] ▁> ▁max v ▁) ▁max v ▁= ▁mat ▁[ ▁N ▁- ▁1 ▁] ▁[ ▁j ▁] ▁; ▁max Arr ▁[ ▁N ▁- ▁1 ▁] ▁[ ▁j ▁] ▁= ▁max v ▁; ▁} ▁max v ▁= ▁mat ▁[ ▁N ▁- ▁1 ▁] ▁[ ▁N ▁- ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁N ▁- ▁2 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁mat ▁[ ▁i ▁] ▁[ ▁N ▁- ▁1 ▁] ▁> ▁max v ▁) ▁max v ▁= ▁mat ▁[ ▁i ▁] ▁[ ▁N ▁- ▁1 ▁] ▁; ▁max Arr ▁[ ▁i ▁] ▁[ ▁N ▁- ▁1 ▁] ▁= ▁max v ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁N ▁- ▁2 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁N ▁- ▁2 ▁; ▁j ▁>= ▁0 ▁; ▁j ▁-- ▁) ▁{ ▁if ▁( ▁max Arr ▁[ ▁i ▁+ ▁1 ▁] ▁[ ▁j ▁+ ▁1 ▁] ▁- ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁> ▁maxValue ▁) ▁maxValue ▁= ▁max Arr ▁[ ▁i ▁+ ▁1 ▁] ▁[ ▁j ▁+ ▁1 ▁] ▁- ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁max Arr ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁max ▁( ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁, ▁max ▁( ▁max Arr ▁[ ▁i ▁] ▁[ ▁j ▁+ ▁1 ▁] ▁, ▁max Arr ▁[ ▁i ▁+ ▁1 ▁] ▁[ ▁j ▁] ▁) ▁) ▁; ▁} ▁} ▁return ▁maxValue ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁mat ▁[ ▁N ▁] ▁[ ▁N ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁, ▁-1 ▁, ▁-4 ▁, ▁- 20 ▁} ▁, ▁{ ▁- 8 ▁, ▁-3 ▁, ▁4 ▁, ▁2 ▁, ▁1 ▁} ▁, ▁{ ▁3 ▁, ▁8 ▁, ▁6 ▁, ▁1 ▁, ▁3 ▁} ▁, ▁{ ▁-4 ▁, ▁-1 ▁, ▁1 ▁, ▁7 ▁, ▁- 6 ▁} ▁, ▁{ ▁0 ▁, ▁-4 ▁, ▁10 ▁, ▁-5 ▁, ▁1 ▁} ▁} ▁; ▁c out ▁<< ▁" ▁Maximum ▁Value ▁is ▁" ▁<< ▁find Max Value ▁( ▁mat ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁ROW ▁4 ▁NEW _ LINE ▁# define ▁COL ▁5 ▁NEW _ LINE ▁void ▁find Unique Rows ▁( ▁int ▁M ▁[ ▁ROW ▁] ▁[ ▁COL ▁] ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁ROW ▁; ▁i ▁++ ▁) ▁{ ▁int ▁flag ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁i ▁; ▁j ▁++ ▁) ▁{ ▁flag ▁= ▁1 ▁; ▁for ▁( ▁int ▁k ▁= ▁0 ▁; ▁k ▁<= ▁COL ▁; ▁k ▁++ ▁) ▁if ▁( ▁M ▁[ ▁i ▁] ▁[ ▁k ▁] ▁!= ▁M ▁[ ▁j ▁] ▁[ ▁k ▁] ▁) ▁flag ▁= ▁0 ▁; ▁if ▁( ▁flag ▁== ▁1 ▁) ▁break ▁; ▁} ▁if ▁( ▁flag ▁== ▁0 ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁COL ▁; ▁j ▁++ ▁) ▁c out ▁<< ▁M ▁[ ▁i ▁] ▁[ ▁j ▁] ▁<< ▁" ▁" ▁; ▁c out ▁<< ▁end l ▁; ▁} ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁M ▁[ ▁ROW ▁] ▁[ ▁COL ▁] ▁= ▁{ ▁{ ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁0 ▁} ▁, ▁{ ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁0 ▁} ▁} ▁; ▁find Unique Rows ▁( ▁M ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁# define ▁R ▁3 ▁NEW _ LINE ▁# define ▁C ▁3 ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁struct ▁Cell ▁{ ▁int ▁r ▁; ▁int ▁c ▁; ▁} ▁; ▁void ▁print Sum s ▁( ▁int ▁mat ▁[ ▁] ▁[ ▁C ▁] ▁, ▁struct ▁Cell ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁, ▁r ▁= ▁arr ▁[ ▁i ▁] ▁. ▁r ▁, ▁c ▁= ▁arr ▁[ ▁i ▁] ▁. ▁c ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁R ▁; ▁j ▁++ ▁) ▁for ▁( ▁int ▁k ▁= ▁0 ▁; ▁k ▁< ▁C ▁; ▁k ▁++ ▁) ▁if ▁( ▁j ▁!= ▁r ▁&& ▁k ▁!= ▁c ▁) ▁sum ▁+= ▁mat ▁[ ▁j ▁] ▁[ ▁k ▁] ▁; ▁c out ▁<< ▁sum ▁<< ▁end l ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁mat ▁[ ▁] ▁[ ▁C ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁1 ▁, ▁2 ▁} ▁, ▁{ ▁3 ▁, ▁4 ▁, ▁6 ▁} ▁, ▁{ ▁5 ▁, ▁3 ▁, ▁2 ▁} ▁} ▁; ▁struct ▁Cell ▁arr ▁[ ▁] ▁= ▁{ ▁{ ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁1 ▁, ▁1 ▁} ▁, ▁{ ▁0 ▁, ▁1 ▁} ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁print Sum s ▁( ▁mat ▁, ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁n ▁5 ▁NEW _ LINE ▁void ▁print Sum Tr icky ▁( ▁int ▁mat ▁[ ▁] ▁[ ▁n ▁] ▁, ▁int ▁k ▁) ▁{ ▁if ▁( ▁k ▁> ▁n ▁) ▁return ▁; ▁int ▁strip Sum ▁[ ▁n ▁] ▁[ ▁n ▁] ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁k ▁; ▁i ▁++ ▁) ▁sum ▁+= ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁strip Sum ▁[ ▁0 ▁] ▁[ ▁j ▁] ▁= ▁sum ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁- ▁k ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁( ▁mat ▁[ ▁i ▁+ ▁k ▁- ▁1 ▁] ▁[ ▁j ▁] ▁- ▁mat ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁) ▁; ▁strip Sum ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁sum ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁k ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁k ▁; ▁j ▁++ ▁) ▁sum ▁+= ▁strip Sum ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁c out ▁<< ▁sum ▁<< ▁" ▁" ▁; ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁< ▁n ▁- ▁k ▁+ ▁1 ▁; ▁j ▁++ ▁) ▁{ ▁sum ▁+= ▁( ▁strip Sum ▁[ ▁i ▁] ▁[ ▁j ▁+ ▁k ▁- ▁1 ▁] ▁- ▁strip Sum ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁) ▁; ▁c out ▁<< ▁sum ▁<< ▁" ▁" ▁; ▁} ▁c out ▁<< ▁end l ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁mat ▁[ ▁n ▁] ▁[ ▁n ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁} ▁, ▁{ ▁2 ▁, ▁2 ▁, ▁2 ▁, ▁2 ▁, ▁2 ▁} ▁, ▁{ ▁3 ▁, ▁3 ▁, ▁3 ▁, ▁3 ▁, ▁3 ▁} ▁, ▁{ ▁4 ▁, ▁4 ▁, ▁4 ▁, ▁4 ▁, ▁4 ▁} ▁, ▁{ ▁5 ▁, ▁5 ▁, ▁5 ▁, ▁5 ▁, ▁5 ▁} ▁, ▁} ▁; ▁int ▁k ▁= ▁3 ▁; ▁print Sum Tr icky ▁( ▁mat ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁# define ▁R ▁3 ▁NEW _ LINE ▁# define ▁C ▁3 ▁NEW _ LINE ▁# define ▁MAX _ K ▁1000 ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁dp ▁[ ▁R ▁] ▁[ ▁C ▁] ▁[ ▁MAX _ K ▁] ▁; ▁int ▁path Count DP Rec DP ▁( ▁int ▁mat ▁[ ▁] ▁[ ▁C ▁] ▁, ▁int ▁m ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁if ▁( ▁m ▁< ▁0 ▁n ▁< ▁0 ▁) ▁return ▁0 ▁; ▁if ▁( ▁m ▁== ▁0 ▁&& ▁n ▁== ▁0 ▁) ▁return ▁( ▁k ▁== ▁mat ▁[ ▁m ▁] ▁[ ▁n ▁] ▁) ▁; ▁if ▁( ▁dp ▁[ ▁m ▁] ▁[ ▁n ▁] ▁[ ▁k ▁] ▁!= ▁-1 ▁) ▁return ▁dp ▁[ ▁m ▁] ▁[ ▁n ▁] ▁[ ▁k ▁] ▁; ▁dp ▁[ ▁m ▁] ▁[ ▁n ▁] ▁[ ▁k ▁] ▁= ▁path Count DP Rec DP ▁( ▁mat ▁, ▁m ▁- ▁1 ▁, ▁n ▁, ▁k ▁- ▁mat ▁[ ▁m ▁] ▁[ ▁n ▁] ▁) ▁+ ▁path Count DP Rec DP ▁( ▁mat ▁, ▁m ▁, ▁n ▁- ▁1 ▁, ▁k ▁- ▁mat ▁[ ▁m ▁] ▁[ ▁n ▁] ▁) ▁; ▁return ▁dp ▁[ ▁m ▁] ▁[ ▁n ▁] ▁[ ▁k ▁] ▁; ▁} ▁int ▁path Count DP ▁( ▁int ▁mat ▁[ ▁] ▁[ ▁C ▁] ▁, ▁int ▁k ▁) ▁{ ▁mem set ▁( ▁dp ▁, ▁-1 ▁, ▁sizeof ▁dp ▁) ▁; ▁return ▁path Count DP Rec DP ▁( ▁mat ▁, ▁R ▁- ▁1 ▁, ▁C ▁- ▁1 ▁, ▁k ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁k ▁= ▁12 ▁; ▁int ▁mat ▁[ ▁R ▁] ▁[ ▁C ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁, ▁{ ▁4 ▁, ▁6 ▁, ▁5 ▁} ▁, ▁{ ▁3 ▁, ▁2 ▁, ▁1 ▁} ▁} ▁; ▁c out ▁<< ▁path Count DP ▁( ▁mat ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁# define ▁R ▁3 ▁NEW _ LINE ▁# define ▁C ▁3 ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁x ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁-1 ▁, ▁1 ▁, ▁0 ▁, ▁-1 ▁, ▁-1 ▁} ▁; ▁int ▁y ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁-1 ▁, ▁-1 ▁, ▁0 ▁, ▁-1 ▁} ▁; ▁int ▁dp ▁[ ▁R ▁] ▁[ ▁C ▁] ▁; ▁bool ▁is valid ▁( ▁int ▁i ▁, ▁int ▁j ▁) ▁{ ▁if ▁( ▁i ▁< ▁0 ▁j ▁< ▁0 ▁i ▁> ▁= ▁R ▁j ▁> ▁= ▁C ▁) ▁return ▁false ▁; ▁return ▁true ▁; ▁} ▁bool ▁is ad jacent ▁( ▁char ▁prev ▁, ▁char ▁curr ▁) ▁{ ▁return ▁( ▁( ▁curr ▁- ▁prev ▁) ▁== ▁1 ▁) ▁; ▁} ▁int ▁getL en Util ▁( ▁char ▁mat ▁[ ▁R ▁] ▁[ ▁C ▁] ▁, ▁int ▁i ▁, ▁int ▁j ▁, ▁char ▁prev ▁) ▁{ ▁if ▁( ▁! ▁is valid ▁( ▁i ▁, ▁j ▁) ▁|| ▁! ▁is ad jacent ▁( ▁prev ▁, ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁) ▁return ▁0 ▁; ▁if ▁( ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁!= ▁-1 ▁) ▁return ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁k ▁= ▁0 ▁; ▁k ▁< ▁8 ▁; ▁k ▁++ ▁) ▁ans ▁= ▁max ▁( ▁ans ▁, ▁1 ▁+ ▁getL en Util ▁( ▁mat ▁, ▁i ▁+ ▁x ▁[ ▁k ▁] ▁, ▁j ▁+ ▁y ▁[ ▁k ▁] ▁, ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁) ▁; ▁return ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁ans ▁; ▁} ▁int ▁getL en ▁( ▁char ▁mat ▁[ ▁R ▁] ▁[ ▁C ▁] ▁, ▁char ▁s ▁) ▁{ ▁mem set ▁( ▁dp ▁, ▁-1 ▁, ▁sizeof ▁dp ▁) ▁; ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁R ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁C ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁== ▁s ▁) ▁{ ▁for ▁( ▁int ▁k ▁= ▁0 ▁; ▁k ▁< ▁8 ▁; ▁k ▁++ ▁) ▁ans ▁= ▁max ▁( ▁ans ▁, ▁1 ▁+ ▁getL en Util ▁( ▁mat ▁, ▁i ▁+ ▁x ▁[ ▁k ▁] ▁, ▁j ▁+ ▁y ▁[ ▁k ▁] ▁, ▁s ▁) ▁) ▁; ▁} ▁} ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁char ▁mat ▁[ ▁R ▁] ▁[ ▁C ▁] ▁= ▁{ ▁{ ▁' ▁a ▁' ▁, ▁' ▁c ▁' ▁, ▁' ▁d ▁' ▁} ▁, ▁{ ▁' ▁h ▁' ▁, ▁' ▁b ▁' ▁, ▁' ▁a ▁' ▁} ▁, ▁{ ▁' ▁i ▁' ▁, ▁' ▁g ▁' ▁, ▁' ▁f ▁' ▁} ▁} ▁; ▁c out ▁<< ▁getL en ▁( ▁mat ▁, ▁' ▁a ▁' ▁) ▁<< ▁end l ▁; ▁c out ▁<< ▁getL en ▁( ▁mat ▁, ▁' ▁e ▁' ▁) ▁<< ▁end l ▁; ▁c out ▁<< ▁getL en ▁( ▁mat ▁, ▁' ▁b ▁' ▁) ▁<< ▁end l ▁; ▁c out ▁<< ▁getL en ▁( ▁mat ▁, ▁' ▁f ▁' ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print Repe ating ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁size ▁) ▁{ ▁int ▁* ▁count ▁= ▁new ▁int ▁[ ▁sizeof ▁( ▁int ▁) ▁* ▁( ▁size ▁- ▁2 ▁) ▁] ▁; ▁int ▁i ▁; ▁c out ▁<< ▁" ▁Re pe ating ▁elements ▁are ▁" ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁count ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁== ▁1 ▁) ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁else ▁count ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁++ ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁2 ▁, ▁4 ▁, ▁5 ▁, ▁2 ▁, ▁3 ▁, ▁1 ▁} ▁; ▁int ▁arr _ size ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁print Repe ating ▁( ▁arr ▁, ▁arr _ size ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print Repe ating ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁size ▁) ▁{ ▁int ▁i ▁; ▁c out ▁<< ▁" ▁The ▁repeating ▁elements ▁are ▁" ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁abs ▁( ▁arr ▁[ ▁i ▁] ▁) ▁] ▁> ▁0 ▁) ▁arr ▁[ ▁abs ▁( ▁arr ▁[ ▁i ▁] ▁) ▁] ▁= ▁- ▁arr ▁[ ▁abs ▁( ▁arr ▁[ ▁i ▁] ▁) ▁] ▁; ▁else ▁c out ▁<< ▁" ▁" ▁<< ▁abs ▁( ▁arr ▁[ ▁i ▁] ▁) ▁<< ▁" ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁2 ▁, ▁4 ▁, ▁5 ▁, ▁2 ▁, ▁3 ▁, ▁1 ▁} ▁; ▁int ▁arr _ size ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁print Repe ating ▁( ▁arr ▁, ▁arr _ size ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁binarySearch ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁low ▁, ▁int ▁high ▁) ▁{ ▁if ▁( ▁high ▁>= ▁low ▁) ▁{ ▁int ▁mid ▁= ▁( ▁low ▁+ ▁high ▁) ▁/ ▁2 ▁; ▁if ▁( ▁mid ▁== ▁arr ▁[ ▁mid ▁] ▁) ▁return ▁mid ▁; ▁if ▁( ▁mid ▁> ▁arr ▁[ ▁mid ▁] ▁) ▁return ▁binarySearch ▁( ▁arr ▁, ▁( ▁mid ▁+ ▁1 ▁) ▁, ▁high ▁) ▁; ▁else ▁return ▁binarySearch ▁( ▁arr ▁, ▁low ▁, ▁( ▁mid ▁- ▁1 ▁) ▁) ▁; ▁} ▁return ▁-1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁10 ▁] ▁= ▁{ ▁-10 ▁, ▁-1 ▁, ▁0 ▁, ▁3 ▁, ▁10 ▁, ▁11 ▁, ▁30 ▁, ▁50 ▁, ▁100 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁Fixed ▁Point ▁is ▁" ▁<< ▁binarySearch ▁( ▁arr ▁, ▁0 ▁, ▁n ▁- ▁1 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁sub Array Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁sum ▁) ▁{ ▁int ▁curr _ sum ▁, ▁i ▁, ▁j ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁curr _ sum ▁= ▁arr ▁[ ▁i ▁] ▁; ▁for ▁( ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁<= ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁curr _ sum ▁== ▁sum ▁) ▁{ ▁c out ▁<< ▁" ▁Sum ▁found ▁between ▁indexes ▁" ▁<< ▁i ▁<< ▁" ▁and ▁" ▁<< ▁j ▁- ▁1 ▁; ▁return ▁1 ▁; ▁} ▁if ▁( ▁curr _ sum ▁> ▁sum ▁j ▁== ▁n ▁) ▁break ▁; ▁curr _ sum ▁= ▁curr _ sum ▁+ ▁arr ▁[ ▁j ▁] ▁; ▁} ▁} ▁c out ▁<< ▁" ▁No ▁sub array ▁found ▁" ▁; ▁return ▁0 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁15 ▁, ▁2 ▁, ▁4 ▁, ▁8 ▁, ▁9 ▁, ▁5 ▁, ▁10 ▁, ▁23 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁sum ▁= ▁23 ▁; ▁sub Array Sum ▁( ▁arr ▁, ▁n ▁, ▁sum ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁R ▁3 ▁NEW _ LINE ▁# define ▁C ▁3 ▁NEW _ LINE ▁int ▁min ▁( ▁int ▁x ▁, ▁int ▁y ▁, ▁int ▁z ▁) ▁; ▁int ▁min ▁( ▁int ▁x ▁, ▁int ▁y ▁, ▁int ▁z ▁) ▁{ ▁if ▁( ▁x ▁< ▁y ▁) ▁return ▁( ▁x ▁< ▁z ▁) ▁? ▁x ▁: ▁z ▁; ▁else ▁return ▁( ▁y ▁< ▁z ▁) ▁? ▁y ▁: ▁z ▁; ▁} ▁int ▁min Cost ▁( ▁int ▁cost ▁[ ▁R ▁] ▁[ ▁C ▁] ▁, ▁int ▁m ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁< ▁0 ▁m ▁< ▁0 ▁) ▁return ▁INT _ MAX ▁; ▁else ▁if ▁( ▁m ▁== ▁0 ▁&& ▁n ▁== ▁0 ▁) ▁return ▁cost ▁[ ▁m ▁] ▁[ ▁n ▁] ▁; ▁else ▁return ▁cost ▁[ ▁m ▁] ▁[ ▁n ▁] ▁+ ▁min ▁( ▁min Cost ▁( ▁cost ▁, ▁m ▁- ▁1 ▁, ▁n ▁- ▁1 ▁) ▁, ▁min Cost ▁( ▁cost ▁, ▁m ▁- ▁1 ▁, ▁n ▁) ▁, ▁min Cost ▁( ▁cost ▁, ▁m ▁, ▁n ▁- ▁1 ▁) ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁cost ▁[ ▁R ▁] ▁[ ▁C ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁, ▁{ ▁4 ▁, ▁8 ▁, ▁2 ▁} ▁, ▁{ ▁1 ▁, ▁5 ▁, ▁3 ▁} ▁} ▁; ▁c out ▁<< ▁min Cost ▁( ▁cost ▁, ▁2 ▁, ▁2 ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁# include ▁< limits . h > ▁NEW _ LINE ▁# define ▁R ▁3 ▁NEW _ LINE ▁# define ▁C ▁3 ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁min ▁( ▁int ▁x ▁, ▁int ▁y ▁, ▁int ▁z ▁) ▁; ▁int ▁min Cost ▁( ▁int ▁cost ▁[ ▁R ▁] ▁[ ▁C ▁] ▁, ▁int ▁m ▁, ▁int ▁n ▁) ▁{ ▁int ▁i ▁, ▁j ▁; ▁int ▁tc ▁[ ▁R ▁] ▁[ ▁C ▁] ▁; ▁tc ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁= ▁cost ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁<= ▁m ▁; ▁i ▁++ ▁) ▁tc ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁= ▁tc ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁0 ▁] ▁+ ▁cost ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁; ▁for ▁( ▁j ▁= ▁1 ▁; ▁j ▁<= ▁n ▁; ▁j ▁++ ▁) ▁tc ▁[ ▁0 ▁] ▁[ ▁j ▁] ▁= ▁tc ▁[ ▁0 ▁] ▁[ ▁j ▁- ▁1 ▁] ▁+ ▁cost ▁[ ▁0 ▁] ▁[ ▁j ▁] ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁<= ▁m ▁; ▁i ▁++ ▁) ▁for ▁( ▁j ▁= ▁1 ▁; ▁j ▁<= ▁n ▁; ▁j ▁++ ▁) ▁tc ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁min ▁( ▁tc ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁- ▁1 ▁] ▁, ▁tc ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁, ▁tc ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁) ▁+ ▁cost ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁return ▁tc ▁[ ▁m ▁] ▁[ ▁n ▁] ▁; ▁} ▁int ▁min ▁( ▁int ▁x ▁, ▁int ▁y ▁, ▁int ▁z ▁) ▁{ ▁if ▁( ▁x ▁< ▁y ▁) ▁return ▁( ▁x ▁< ▁z ▁) ▁? ▁x ▁: ▁z ▁; ▁else ▁return ▁( ▁y ▁< ▁z ▁) ▁? ▁y ▁: ▁z ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁cost ▁[ ▁R ▁] ▁[ ▁C ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁, ▁{ ▁4 ▁, ▁8 ▁, ▁2 ▁} ▁, ▁{ ▁1 ▁, ▁5 ▁, ▁3 ▁} ▁} ▁; ▁c out ▁<< ▁" ▁" ▁<< ▁min Cost ▁( ▁cost ▁, ▁2 ▁, ▁2 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁Matrix Chain Order ▁( ▁int ▁p ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁m ▁[ ▁n ▁] ▁[ ▁n ▁] ▁; ▁int ▁i ▁, ▁j ▁, ▁k ▁, ▁L ▁, ▁q ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁m ▁[ ▁i ▁] ▁[ ▁i ▁] ▁= ▁0 ▁; ▁for ▁( ▁L ▁= ▁2 ▁; ▁L ▁< ▁n ▁; ▁L ▁++ ▁) ▁{ ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁- ▁L ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁j ▁= ▁i ▁+ ▁L ▁- ▁1 ▁; ▁m ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁INT _ MAX ▁; ▁for ▁( ▁k ▁= ▁i ▁; ▁k ▁<= ▁j ▁- ▁1 ▁; ▁k ▁++ ▁) ▁{ ▁q ▁= ▁m ▁[ ▁i ▁] ▁[ ▁k ▁] ▁+ ▁m ▁[ ▁k ▁+ ▁1 ▁] ▁[ ▁j ▁] ▁+ ▁p ▁[ ▁i ▁- ▁1 ▁] ▁* ▁p ▁[ ▁k ▁] ▁* ▁p ▁[ ▁j ▁] ▁; ▁if ▁( ▁q ▁< ▁m ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁m ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁q ▁; ▁} ▁} ▁} ▁return ▁m ▁[ ▁1 ▁] ▁[ ▁n ▁- ▁1 ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁size ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁Minimum ▁number ▁of ▁multiplication s ▁is ▁" ▁<< ▁Matrix Chain Order ▁( ▁arr ▁, ▁size ▁) ▁; ▁get char ▁( ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁return ▁( ▁a ▁> ▁b ▁) ▁? ▁a ▁: ▁b ▁; ▁} ▁int ▁kn ap S ack ▁( ▁int ▁W ▁, ▁int ▁wt ▁[ ▁] ▁, ▁int ▁val ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁0 ▁W ▁== ▁0 ▁) ▁return ▁0 ▁; ▁if ▁( ▁wt ▁[ ▁n ▁- ▁1 ▁] ▁> ▁W ▁) ▁return ▁kn ap S ack ▁( ▁W ▁, ▁wt ▁, ▁val ▁, ▁n ▁- ▁1 ▁) ▁; ▁else ▁return ▁max ▁( ▁val ▁[ ▁n ▁- ▁1 ▁] ▁+ ▁kn ap S ack ▁( ▁W ▁- ▁wt ▁[ ▁n ▁- ▁1 ▁] ▁, ▁wt ▁, ▁val ▁, ▁n ▁- ▁1 ▁) ▁, ▁kn ap S ack ▁( ▁W ▁, ▁wt ▁, ▁val ▁, ▁n ▁- ▁1 ▁) ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁val ▁[ ▁] ▁= ▁{ ▁60 ▁, ▁100 ▁, ▁120 ▁} ▁; ▁int ▁wt ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁20 ▁, ▁30 ▁} ▁; ▁int ▁W ▁= ▁50 ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁val ▁) ▁/ ▁sizeof ▁( ▁val ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁kn ap S ack ▁( ▁W ▁, ▁wt ▁, ▁val ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁return ▁( ▁a ▁> ▁b ▁) ▁? ▁a ▁: ▁b ▁; ▁} ▁int ▁kn ap S ack ▁( ▁int ▁W ▁, ▁int ▁wt ▁[ ▁] ▁, ▁int ▁val ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁i ▁, ▁w ▁; ▁int ▁K ▁[ ▁n ▁+ ▁1 ▁] ▁[ ▁W ▁+ ▁1 ▁] ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁w ▁= ▁0 ▁; ▁w ▁<= ▁W ▁; ▁w ▁++ ▁) ▁{ ▁if ▁( ▁i ▁== ▁0 ▁w ▁== ▁0 ▁) ▁K ▁[ ▁i ▁] ▁[ ▁w ▁] ▁= ▁0 ▁; ▁else ▁if ▁( ▁wt ▁[ ▁i ▁- ▁1 ▁] ▁<= ▁w ▁) ▁K ▁[ ▁i ▁] ▁[ ▁w ▁] ▁= ▁max ▁( ▁val ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁K ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁w ▁- ▁wt ▁[ ▁i ▁- ▁1 ▁] ▁] ▁, ▁K ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁w ▁] ▁) ▁; ▁else ▁K ▁[ ▁i ▁] ▁[ ▁w ▁] ▁= ▁K ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁w ▁] ▁; ▁} ▁} ▁return ▁K ▁[ ▁n ▁] ▁[ ▁W ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁val ▁[ ▁] ▁= ▁{ ▁60 ▁, ▁100 ▁, ▁120 ▁} ▁; ▁int ▁wt ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁20 ▁, ▁30 ▁} ▁; ▁int ▁W ▁= ▁50 ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁val ▁) ▁/ ▁sizeof ▁( ▁val ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁kn ap S ack ▁( ▁W ▁, ▁wt ▁, ▁val ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max ▁( ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁return ▁( ▁x ▁> ▁y ▁) ▁? ▁x ▁: ▁y ▁; ▁} ▁int ▁l ps ▁( ▁char ▁* ▁seq ▁, ▁int ▁i ▁, ▁int ▁j ▁) ▁{ ▁if ▁( ▁i ▁== ▁j ▁) ▁return ▁1 ▁; ▁if ▁( ▁seq ▁[ ▁i ▁] ▁== ▁seq ▁[ ▁j ▁] ▁&& ▁i ▁+ ▁1 ▁== ▁j ▁) ▁return ▁2 ▁; ▁if ▁( ▁seq ▁[ ▁i ▁] ▁== ▁seq ▁[ ▁j ▁] ▁) ▁return ▁l ps ▁( ▁seq ▁, ▁i ▁+ ▁1 ▁, ▁j ▁- ▁1 ▁) ▁+ ▁2 ▁; ▁return ▁max ▁( ▁l ps ▁( ▁seq ▁, ▁i ▁, ▁j ▁- ▁1 ▁) ▁, ▁l ps ▁( ▁seq ▁, ▁i ▁+ ▁1 ▁, ▁j ▁) ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁char ▁seq ▁[ ▁] ▁= ▁" ▁G EEK S FOR GE EK S ▁" ▁; ▁int ▁n ▁= ▁str len ▁( ▁seq ▁) ▁; ▁c out ▁<< ▁" ▁The ▁length ▁of ▁the ▁L PS ▁is ▁" ▁<< ▁l ps ▁( ▁seq ▁, ▁0 ▁, ▁n ▁- ▁1 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< std io . h > ▁NEW _ LINE ▁# include ▁< limits . h > ▁NEW _ LINE ▁int ▁max ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁return ▁( ▁a ▁> ▁b ▁) ▁? ▁a ▁: ▁b ▁; ▁} ▁int ▁cut R od ▁( ▁int ▁price ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁val ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁val ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁int ▁i ▁, ▁j ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁max _ val ▁= ▁INT _ MIN ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁i ▁; ▁j ▁++ ▁) ▁max _ val ▁= ▁max ▁( ▁max _ val ▁, ▁price ▁[ ▁j ▁] ▁+ ▁val ▁[ ▁i ▁- ▁j ▁- ▁1 ▁] ▁) ▁; ▁val ▁[ ▁i ▁] ▁= ▁max _ val ▁; ▁} ▁return ▁val ▁[ ▁n ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁5 ▁, ▁8 ▁, ▁9 ▁, ▁10 ▁, ▁17 ▁, ▁17 ▁, ▁20 ▁} ▁; ▁int ▁size ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁printf ▁( ▁" ▁Maximum ▁Ob tain able ▁Value ▁is ▁% ▁dn ▁" ▁, ▁cut R od ▁( ▁arr ▁, ▁size ▁) ▁) ▁; ▁get char ▁( ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count ▁( ▁int ▁n ▁) ▁{ ▁int ▁table ▁[ ▁n ▁+ ▁1 ▁] ▁, ▁i ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁+ ▁1 ▁; ▁j ▁++ ▁) ▁table ▁[ ▁j ▁] ▁= ▁0 ▁; ▁table ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁for ▁( ▁i ▁= ▁3 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁table ▁[ ▁i ▁] ▁+= ▁table ▁[ ▁i ▁- ▁3 ▁] ▁; ▁for ▁( ▁i ▁= ▁5 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁table ▁[ ▁i ▁] ▁+= ▁table ▁[ ▁i ▁- ▁5 ▁] ▁; ▁for ▁( ▁i ▁= ▁10 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁table ▁[ ▁i ▁] ▁+= ▁table ▁[ ▁i ▁- ▁10 ▁] ▁; ▁return ▁table ▁[ ▁n ▁] ▁; ▁} ▁int ▁main ▁( ▁void ▁) ▁{ ▁int ▁n ▁= ▁20 ▁; ▁c out ▁<< ▁" ▁Count ▁for ▁" ▁<< ▁n ▁<< ▁" ▁is ▁" ▁<< ▁count ▁( ▁n ▁) ▁<< ▁end l ▁; ▁n ▁= ▁13 ▁; ▁c out ▁<< ▁" ▁Count ▁for ▁" ▁<< ▁n ▁<< ▁" ▁is ▁" ▁<< ▁count ▁( ▁n ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁search ▁( ▁char ▁* ▁pat ▁, ▁char ▁* ▁txt ▁) ▁{ ▁int ▁M ▁= ▁str len ▁( ▁pat ▁) ▁; ▁int ▁N ▁= ▁str len ▁( ▁txt ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁N ▁- ▁M ▁; ▁i ▁++ ▁) ▁{ ▁int ▁j ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁M ▁; ▁j ▁++ ▁) ▁if ▁( ▁txt ▁[ ▁i ▁+ ▁j ▁] ▁!= ▁pat ▁[ ▁j ▁] ▁) ▁break ▁; ▁if ▁( ▁j ▁== ▁M ▁) ▁c out ▁<< ▁" ▁Pattern ▁found ▁at ▁index ▁" ▁<< ▁i ▁<< ▁end l ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁char ▁txt ▁[ ▁] ▁= ▁" ▁A AB A AC A AD A AB AA AB AA ▁" ▁; ▁char ▁pat ▁[ ▁] ▁= ▁" ▁A AB A ▁" ▁; ▁search ▁( ▁pat ▁, ▁txt ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁d ▁256 ▁NEW _ LINE ▁void ▁search ▁( ▁char ▁pat ▁[ ▁] ▁, ▁char ▁txt ▁[ ▁] ▁, ▁int ▁q ▁) ▁{ ▁int ▁M ▁= ▁str len ▁( ▁pat ▁) ▁; ▁int ▁N ▁= ▁str len ▁( ▁txt ▁) ▁; ▁int ▁i ▁, ▁j ▁; ▁int ▁p ▁= ▁0 ▁; ▁int ▁t ▁= ▁0 ▁; ▁int ▁h ▁= ▁1 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁M ▁- ▁1 ▁; ▁i ▁++ ▁) ▁h ▁= ▁( ▁h ▁* ▁d ▁) ▁% ▁q ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁M ▁; ▁i ▁++ ▁) ▁{ ▁p ▁= ▁( ▁d ▁* ▁p ▁+ ▁pat ▁[ ▁i ▁] ▁) ▁% ▁q ▁; ▁t ▁= ▁( ▁d ▁* ▁t ▁+ ▁txt ▁[ ▁i ▁] ▁) ▁% ▁q ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁<= ▁N ▁- ▁M ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁p ▁== ▁t ▁) ▁{ ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁M ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁txt ▁[ ▁i ▁+ ▁j ▁] ▁!= ▁pat ▁[ ▁j ▁] ▁) ▁break ▁; ▁} ▁if ▁( ▁j ▁== ▁M ▁) ▁c out ▁<< ▁" ▁Pattern ▁found ▁at ▁index ▁" ▁<< ▁i ▁<< ▁end l ▁; ▁} ▁if ▁( ▁i ▁< ▁N ▁- ▁M ▁) ▁{ ▁t ▁= ▁( ▁d ▁* ▁( ▁t ▁- ▁txt ▁[ ▁i ▁] ▁* ▁h ▁) ▁+ ▁txt ▁[ ▁i ▁+ ▁M ▁] ▁) ▁% ▁q ▁; ▁if ▁( ▁t ▁< ▁0 ▁) ▁t ▁= ▁( ▁t ▁+ ▁q ▁) ▁; ▁} ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁char ▁txt ▁[ ▁] ▁= ▁" ▁G EEK S ▁FOR ▁G EEK S ▁" ▁; ▁char ▁pat ▁[ ▁] ▁= ▁" ▁G EEK ▁" ▁; ▁int ▁q ▁= ▁101 ▁; ▁search ▁( ▁pat ▁, ▁txt ▁, ▁q ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁class ▁g fg ▁{ ▁public ▁: ▁int ▁power ▁( ▁int ▁x ▁, ▁unsigned ▁int ▁y ▁) ▁{ ▁if ▁( ▁y ▁== ▁0 ▁) ▁return ▁1 ▁; ▁else ▁if ▁( ▁y ▁% ▁2 ▁== ▁0 ▁) ▁return ▁power ▁( ▁x ▁, ▁y ▁/ ▁2 ▁) ▁* ▁power ▁( ▁x ▁, ▁y ▁/ ▁2 ▁) ▁; ▁else ▁return ▁x ▁* ▁power ▁( ▁x ▁, ▁y ▁/ ▁2 ▁) ▁* ▁power ▁( ▁x ▁, ▁y ▁/ ▁2 ▁) ▁; ▁} ▁} ▁; ▁int ▁main ▁( ▁) ▁{ ▁g fg ▁g ▁; ▁int ▁x ▁= ▁2 ▁; ▁unsigned ▁int ▁y ▁= ▁3 ▁; ▁c out ▁<< ▁g ▁. ▁power ▁( ▁x ▁, ▁y ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁float ▁area ▁( ▁int ▁x 1 ▁, ▁int ▁y 1 ▁, ▁int ▁x 2 ▁, ▁int ▁y 2 ▁, ▁int ▁x 3 ▁, ▁int ▁y 3 ▁) ▁{ ▁return ▁abs ▁( ▁( ▁x 1 ▁* ▁( ▁y 2 ▁- ▁y 3 ▁) ▁+ ▁x 2 ▁* ▁( ▁y 3 ▁- ▁y 1 ▁) ▁+ ▁x 3 ▁* ▁( ▁y 1 ▁- ▁y 2 ▁) ▁) ▁/ ▁2.0 ▁) ▁; ▁} ▁bool ▁isIn side ▁( ▁int ▁x 1 ▁, ▁int ▁y 1 ▁, ▁int ▁x 2 ▁, ▁int ▁y 2 ▁, ▁int ▁x 3 ▁, ▁int ▁y 3 ▁, ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁float ▁A ▁= ▁area ▁( ▁x 1 ▁, ▁y 1 ▁, ▁x 2 ▁, ▁y 2 ▁, ▁x 3 ▁, ▁y 3 ▁) ▁; ▁float ▁A 1 ▁= ▁area ▁( ▁x ▁, ▁y ▁, ▁x 2 ▁, ▁y 2 ▁, ▁x 3 ▁, ▁y 3 ▁) ▁; ▁float ▁A 2 ▁= ▁area ▁( ▁x 1 ▁, ▁y 1 ▁, ▁x ▁, ▁y ▁, ▁x 3 ▁, ▁y 3 ▁) ▁; ▁float ▁A 3 ▁= ▁area ▁( ▁x 1 ▁, ▁y 1 ▁, ▁x 2 ▁, ▁y 2 ▁, ▁x ▁, ▁y ▁) ▁; ▁return ▁( ▁A ▁== ▁A 1 ▁+ ▁A 2 ▁+ ▁A 3 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁if ▁( ▁isIn side ▁( ▁0 ▁, ▁0 ▁, ▁20 ▁, ▁0 ▁, ▁10 ▁, ▁30 ▁, ▁10 ▁, ▁15 ▁) ▁) ▁printf ▁( ▁" ▁Inside ▁" ▁) ▁; ▁else ▁printf ▁( ▁" ▁Not ▁Inside ▁" ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁bool ▁int ▁NEW _ LINE ▁bool ▁is L uck y ▁( ▁int ▁n ▁) ▁{ ▁static ▁int ▁counter ▁= ▁2 ▁; ▁int ▁next _ position ▁= ▁n ▁; ▁if ▁( ▁counter ▁> ▁n ▁) ▁return ▁1 ▁; ▁if ▁( ▁n ▁% ▁counter ▁== ▁0 ▁) ▁return ▁0 ▁; ▁next _ position ▁-= ▁next _ position ▁/ ▁counter ▁; ▁counter ▁++ ▁; ▁return ▁is L uck y ▁( ▁next _ position ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁x ▁= ▁5 ▁; ▁if ▁( ▁is L uck y ▁( ▁x ▁) ▁) ▁c out ▁<< ▁x ▁<< ▁" ▁is ▁a ▁luck y ▁no ▁. ▁" ▁; ▁else ▁c out ▁<< ▁x ▁<< ▁" ▁is ▁not ▁a ▁luck y ▁no ▁. ▁" ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁# include ▁< string . h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁fact ▁( ▁int ▁n ▁) ▁{ ▁return ▁( ▁n ▁<= ▁1 ▁) ▁? ▁1 ▁: ▁n ▁* ▁fact ▁( ▁n ▁- ▁1 ▁) ▁; ▁} ▁int ▁find Small er In Right ▁( ▁char ▁* ▁str ▁, ▁int ▁low ▁, ▁int ▁high ▁) ▁{ ▁int ▁count Right ▁= ▁0 ▁, ▁i ▁; ▁for ▁( ▁i ▁= ▁low ▁+ ▁1 ▁; ▁i ▁<= ▁high ▁; ▁++ ▁i ▁) ▁if ▁( ▁str ▁[ ▁i ▁] ▁< ▁str ▁[ ▁low ▁] ▁) ▁++ ▁count Right ▁; ▁return ▁count Right ▁; ▁} ▁int ▁find Rank ▁( ▁char ▁* ▁str ▁) ▁{ ▁int ▁len ▁= ▁str len ▁( ▁str ▁) ▁; ▁int ▁mul ▁= ▁fact ▁( ▁len ▁) ▁; ▁int ▁rank ▁= ▁1 ▁; ▁int ▁count Right ▁; ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁len ▁; ▁++ ▁i ▁) ▁{ ▁mul ▁/= ▁len ▁- ▁i ▁; ▁count Right ▁= ▁find Small er In Right ▁( ▁str ▁, ▁i ▁, ▁len ▁- ▁1 ▁) ▁; ▁rank ▁+= ▁count Right ▁* ▁mul ▁; ▁} ▁return ▁rank ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁char ▁str ▁[ ▁] ▁= ▁" ▁string ▁" ▁; ▁c out ▁<< ▁find Rank ▁( ▁str ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁bin omial Co eff ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁res ▁= ▁1 ▁; ▁if ▁( ▁k ▁> ▁n ▁- ▁k ▁) ▁k ▁= ▁n ▁- ▁k ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁k ▁; ▁++ ▁i ▁) ▁{ ▁res ▁*= ▁( ▁n ▁- ▁i ▁) ▁; ▁res ▁/= ▁( ▁i ▁+ ▁1 ▁) ▁; ▁} ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁8 ▁, ▁k ▁= ▁2 ▁; ▁c out ▁<< ▁" ▁Value ▁of ▁C ▁( ▁" ▁<< ▁n ▁<< ▁" ▁, ▁" ▁<< ▁k ▁<< ▁" ▁) ▁is ▁" ▁<< ▁bin omial Co eff ▁( ▁n ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print P as cal ▁( ▁int ▁n ▁) ▁{ ▁int ▁arr ▁[ ▁n ▁] ▁[ ▁n ▁] ▁; ▁for ▁( ▁int ▁line ▁= ▁0 ▁; ▁line ▁< ▁n ▁; ▁line ▁++ ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁line ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁line ▁== ▁i ▁i ▁== ▁0 ▁) ▁arr ▁[ ▁line ▁] ▁[ ▁i ▁] ▁= ▁1 ▁; ▁else ▁arr ▁[ ▁line ▁] ▁[ ▁i ▁] ▁= ▁arr ▁[ ▁line ▁- ▁1 ▁] ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁arr ▁[ ▁line ▁- ▁1 ▁] ▁[ ▁i ▁] ▁; ▁c out ▁<< ▁arr ▁[ ▁line ▁] ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁} ▁c out ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁5 ▁; ▁print P as cal ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁float ▁exponential ▁( ▁int ▁n ▁, ▁float ▁x ▁) ▁{ ▁float ▁sum ▁= ▁1.0 f ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁> ▁0 ▁; ▁-- ▁i ▁) ▁sum ▁= ▁1 ▁+ ▁x ▁* ▁sum ▁/ ▁i ▁; ▁return ▁sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁10 ▁; ▁float ▁x ▁= ▁1.0 f ▁; ▁c out ▁<< ▁" ▁e ▁^ ▁x ▁= ▁" ▁<< ▁fixed ▁<< ▁set precision ▁( ▁5 ▁) ▁<< ▁exponential ▁( ▁n ▁, ▁x ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁prime Fact ors ▁( ▁int ▁n ▁) ▁{ ▁while ▁( ▁n ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁c out ▁<< ▁2 ▁<< ▁" ▁" ▁; ▁n ▁= ▁n ▁/ ▁2 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁3 ▁; ▁i ▁<= ▁sqrt ▁( ▁n ▁) ▁; ▁i ▁= ▁i ▁+ ▁2 ▁) ▁{ ▁while ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁{ ▁c out ▁<< ▁i ▁<< ▁" ▁" ▁; ▁n ▁= ▁n ▁/ ▁i ▁; ▁} ▁} ▁if ▁( ▁n ▁> ▁2 ▁) ▁c out ▁<< ▁n ▁<< ▁" ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁3 15 ▁; ▁prime Fact ors ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁combination Util ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁r ▁, ▁int ▁index ▁, ▁int ▁data ▁[ ▁] ▁, ▁int ▁i ▁) ▁; ▁void ▁print Comb ination ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁r ▁) ▁{ ▁int ▁data ▁[ ▁r ▁] ▁; ▁combination Util ▁( ▁arr ▁, ▁n ▁, ▁r ▁, ▁0 ▁, ▁data ▁, ▁0 ▁) ▁; ▁} ▁void ▁combination Util ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁r ▁, ▁int ▁index ▁, ▁int ▁data ▁[ ▁] ▁, ▁int ▁i ▁) ▁{ ▁if ▁( ▁index ▁== ▁r ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁r ▁; ▁j ▁++ ▁) ▁c out ▁<< ▁data ▁[ ▁j ▁] ▁<< ▁" ▁" ▁; ▁c out ▁<< ▁end l ▁; ▁return ▁; ▁} ▁if ▁( ▁i ▁>= ▁n ▁) ▁return ▁; ▁data ▁[ ▁index ▁] ▁= ▁arr ▁[ ▁i ▁] ▁; ▁combination Util ▁( ▁arr ▁, ▁n ▁, ▁r ▁, ▁index ▁+ ▁1 ▁, ▁data ▁, ▁i ▁+ ▁1 ▁) ▁; ▁combination Util ▁( ▁arr ▁, ▁n ▁, ▁r ▁, ▁index ▁, ▁data ▁, ▁i ▁+ ▁1 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁r ▁= ▁3 ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁print Comb ination ▁( ▁arr ▁, ▁n ▁, ▁r ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁getSingle ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁ones ▁= ▁0 ▁, ▁tw os ▁= ▁0 ▁; ▁int ▁common _ bit _ mask ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁tw os ▁= ▁tw os ▁| ▁( ▁ones ▁& ▁arr ▁[ ▁i ▁] ▁) ▁; ▁ones ▁= ▁ones ▁^ ▁arr ▁[ ▁i ▁] ▁; ▁common _ bit _ mask ▁= ▁~ ▁( ▁ones ▁& ▁tw os ▁) ▁; ▁ones ▁&= ▁common _ bit _ mask ▁; ▁tw os ▁&= ▁common _ bit _ mask ▁; ▁} ▁return ▁ones ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁3 ▁, ▁2 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁The ▁element ▁with ▁single ▁occurrence ▁is ▁" ▁<< ▁getSingle ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁INT _ SIZE ▁32 ▁NEW _ LINE ▁int ▁getSingle ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁result ▁= ▁0 ▁; ▁int ▁x ▁, ▁sum ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁INT _ SIZE ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁= ▁0 ▁; ▁x ▁= ▁( ▁1 ▁<< ▁i ▁) ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁j ▁] ▁& ▁x ▁) ▁sum ▁++ ▁; ▁} ▁if ▁( ▁( ▁sum ▁% ▁3 ▁) ▁!= ▁0 ▁) ▁result ▁|= ▁x ▁; ▁} ▁return ▁result ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁12 ▁, ▁1 ▁, ▁12 ▁, ▁3 ▁, ▁12 ▁, ▁1 ▁, ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁2 ▁, ▁2 ▁, ▁3 ▁, ▁7 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁The ▁element ▁with ▁single ▁occurrence ▁is ▁" ▁<< ▁getSingle ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Set Bits ▁( ▁int ▁n ▁) ▁{ ▁int ▁i ▁= ▁0 ▁; ▁int ▁ans ▁= ▁0 ▁; ▁while ▁( ▁( ▁1 ▁<< ▁i ▁) ▁<= ▁n ▁) ▁{ ▁bool ▁k ▁= ▁0 ▁; ▁int ▁change ▁= ▁1 ▁<< ▁i ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁<= ▁n ▁; ▁j ▁++ ▁) ▁{ ▁ans ▁+= ▁k ▁; ▁if ▁( ▁change ▁== ▁1 ▁) ▁{ ▁k ▁= ▁! ▁k ▁; ▁change ▁= ▁1 ▁<< ▁i ▁; ▁} ▁else ▁{ ▁change ▁-- ▁; ▁} ▁} ▁i ▁++ ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁17 ▁; ▁c out ▁<< ▁count Set Bits ▁( ▁n ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁Add ▁( ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁while ▁( ▁y ▁!= ▁0 ▁) ▁{ ▁int ▁carry ▁= ▁x ▁& ▁y ▁; ▁x ▁= ▁x ▁^ ▁y ▁; ▁y ▁= ▁carry ▁<< ▁1 ▁; ▁} ▁return ▁x ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁c out ▁<< ▁Add ▁( ▁15 ▁, ▁32 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁smallest ▁( ▁int ▁x ▁, ▁int ▁y ▁, ▁int ▁z ▁) ▁{ ▁int ▁c ▁= ▁0 ▁; ▁while ▁( ▁x ▁&& ▁y ▁&& ▁z ▁) ▁{ ▁x ▁-- ▁; ▁y ▁-- ▁; ▁z ▁-- ▁; ▁c ▁++ ▁; ▁} ▁return ▁c ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁x ▁= ▁12 ▁, ▁y ▁= ▁15 ▁, ▁z ▁= ▁5 ▁; ▁c out ▁<< ▁" ▁Minimum ▁of ▁3 ▁numbers ▁is ▁" ▁<< ▁smallest ▁( ▁x ▁, ▁y ▁, ▁z ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁add One ▁( ▁int ▁x ▁) ▁{ ▁int ▁m ▁= ▁1 ▁; ▁while ▁( ▁x ▁& ▁m ▁) ▁{ ▁x ▁= ▁x ▁^ ▁m ▁; ▁m ▁<<= ▁1 ▁; ▁} ▁x ▁= ▁x ▁^ ▁m ▁; ▁return ▁x ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁c out ▁<< ▁add One ▁( ▁13 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁add One ▁( ▁int ▁x ▁) ▁{ ▁return ▁( ▁- ▁( ▁~ ▁x ▁) ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁c out ▁<< ▁add One ▁( ▁13 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁bool ▁int ▁NEW _ LINE ▁class ▁G F G ▁{ ▁public ▁: ▁bool ▁is Power Of Four ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁0 ▁) ▁return ▁0 ▁; ▁while ▁( ▁n ▁!= ▁1 ▁) ▁{ ▁if ▁( ▁n ▁% ▁4 ▁!= ▁0 ▁) ▁return ▁0 ▁; ▁n ▁= ▁n ▁/ ▁4 ▁; ▁} ▁return ▁1 ▁; ▁} ▁} ▁; ▁int ▁main ▁( ▁) ▁{ ▁G F G ▁g ▁; ▁int ▁test _ no ▁= ▁64 ▁; ▁if ▁( ▁g ▁. ▁is Power Of Four ▁( ▁test _ no ▁) ▁) ▁c out ▁<< ▁test _ no ▁<< ▁" ▁is ▁a ▁power ▁of ▁4" ▁; ▁else ▁c out ▁<< ▁test _ no ▁<< ▁" ▁is ▁not ▁a ▁power ▁of ▁4" ▁; ▁get char ▁( ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁abs bit 32 ▁( ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁int ▁sub ▁= ▁x ▁- ▁y ▁; ▁int ▁mask ▁= ▁( ▁sub ▁>> ▁31 ▁) ▁; ▁return ▁( ▁sub ▁^ ▁mask ▁) ▁- ▁mask ▁; ▁} ▁int ▁max ▁( ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁int ▁abs ▁= ▁abs bit 32 ▁( ▁x ▁, ▁y ▁) ▁; ▁return ▁( ▁x ▁+ ▁y ▁+ ▁abs ▁) ▁/ ▁2 ▁; ▁} ▁int ▁min ▁( ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁int ▁abs ▁= ▁abs bit 32 ▁( ▁x ▁, ▁y ▁) ▁; ▁return ▁( ▁x ▁+ ▁y ▁- ▁abs ▁) ▁/ ▁2 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁c out ▁<< ▁max ▁( ▁2 ▁, ▁3 ▁) ▁<< ▁end l ▁; ▁c out ▁<< ▁max ▁( ▁2 ▁, ▁-3 ▁) ▁<< ▁end l ▁; ▁c out ▁<< ▁max ▁( ▁-2 ▁, ▁-3 ▁) ▁<< ▁end l ▁; ▁c out ▁<< ▁min ▁( ▁2 ▁, ▁3 ▁) ▁<< ▁end l ▁; ▁c out ▁<< ▁min ▁( ▁2 ▁, ▁-3 ▁) ▁<< ▁end l ▁; ▁c out ▁<< ▁min ▁( ▁-2 ▁, ▁-3 ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁unsigned ▁int ▁count Set Bits ▁( ▁unsigned ▁int ▁n ▁) ▁{ ▁unsigned ▁int ▁count ▁= ▁0 ▁; ▁while ▁( ▁n ▁) ▁{ ▁count ▁+= ▁n ▁& ▁1 ▁; ▁n ▁>>= ▁1 ▁; ▁} ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁i ▁= ▁9 ▁; ▁c out ▁<< ▁count Set Bits ▁( ▁i ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁Bits Set Table 256 ▁[ ▁256 ▁] ▁; ▁void ▁initialize ▁( ▁) ▁{ ▁Bits Set Table 256 ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁256 ▁; ▁i ▁++ ▁) ▁{ ▁Bits Set Table 256 ▁[ ▁i ▁] ▁= ▁( ▁i ▁& ▁1 ▁) ▁+ ▁Bits Set Table 256 ▁[ ▁i ▁/ ▁2 ▁] ▁; ▁} ▁} ▁int ▁count Set Bits ▁( ▁int ▁n ▁) ▁{ ▁return ▁( ▁Bits Set Table 256 ▁[ ▁n ▁& ▁0 xff ▁] ▁+ ▁Bits Set Table 256 ▁[ ▁( ▁n ▁>> ▁8 ▁) ▁& ▁0 xff ▁] ▁+ ▁Bits Set Table 256 ▁[ ▁( ▁n ▁>> ▁16 ▁) ▁& ▁0 xff ▁] ▁+ ▁Bits Set Table 256 ▁[ ▁n ▁>> ▁24 ▁] ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁initialize ▁( ▁) ▁; ▁int ▁n ▁= ▁9 ▁; ▁c out ▁<< ▁count Set Bits ▁( ▁n ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁unsigned ▁int ▁next Power Of 2 ▁( ▁unsigned ▁int ▁n ▁) ▁{ ▁unsigned ▁count ▁= ▁0 ▁; ▁if ▁( ▁n ▁&& ▁! ▁( ▁n ▁& ▁( ▁n ▁- ▁1 ▁) ▁) ▁) ▁return ▁n ▁; ▁while ▁( ▁n ▁!= ▁0 ▁) ▁{ ▁n ▁>>= ▁1 ▁; ▁count ▁+= ▁1 ▁; ▁} ▁return ▁1 ▁<< ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁unsigned ▁int ▁n ▁= ▁0 ▁; ▁c out ▁<< ▁next Power Of 2 ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁unsigned ▁int ▁next Power Of 2 ▁( ▁unsigned ▁int ▁n ▁) ▁{ ▁unsigned ▁int ▁p ▁= ▁1 ▁; ▁if ▁( ▁n ▁&& ▁! ▁( ▁n ▁& ▁( ▁n ▁- ▁1 ▁) ▁) ▁) ▁return ▁n ▁; ▁while ▁( ▁p ▁< ▁n ▁) ▁p ▁<<= ▁1 ▁; ▁return ▁p ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁unsigned ▁int ▁n ▁= ▁5 ▁; ▁c out ▁<< ▁next Power Of 2 ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# ▁include ▁< bits / std c ++. h > ▁NEW _ LINE ▁# ▁define ▁bool ▁int ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁get Par ity ▁( ▁unsigned ▁int ▁n ▁) ▁{ ▁bool ▁par ity ▁= ▁0 ▁; ▁while ▁( ▁n ▁) ▁{ ▁par ity ▁= ▁! ▁par ity ▁; ▁n ▁= ▁n ▁& ▁( ▁n ▁- ▁1 ▁) ▁; ▁} ▁return ▁par ity ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁unsigned ▁int ▁n ▁= ▁7 ▁; ▁c out ▁<< ▁" ▁Par ity ▁of ▁no ▁" ▁<< ▁n ▁<< ▁" ▁= ▁" ▁<< ▁( ▁get Par ity ▁( ▁n ▁) ▁? ▁" ▁odd ▁" ▁: ▁" ▁even ▁" ▁) ▁; ▁get char ▁( ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁bool ▁int ▁NEW _ LINE ▁bool ▁is Power Of Two ▁( ▁int ▁x ▁) ▁{ ▁return ▁x ▁&& ▁( ▁! ▁( ▁x ▁& ▁( ▁x ▁- ▁1 ▁) ▁) ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁is Power Of Two ▁( ▁31 ▁) ▁? ▁c out ▁<< ▁" ▁Yes ▁STRNEWLINE ▁" ▁: ▁c out ▁<< ▁" ▁No ▁STRNEWLINE ▁" ▁; ▁is Power Of Two ▁( ▁64 ▁) ▁? ▁c out ▁<< ▁" ▁Yes ▁STRNEWLINE ▁" ▁: ▁c out ▁<< ▁" ▁No ▁STRNEWLINE ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁Position Right most Set bit ▁( ▁int ▁n ▁) ▁{ ▁int ▁p ▁= ▁1 ▁; ▁while ▁( ▁n ▁> ▁0 ▁) ▁{ ▁if ▁( ▁n ▁& ▁1 ▁) ▁{ ▁return ▁p ▁; ▁} ▁p ▁++ ▁; ▁n ▁= ▁n ▁>> ▁1 ▁; ▁} ▁return ▁-1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁18 ▁; ▁int ▁pos ▁= ▁Position Right most Set bit ▁( ▁n ▁) ▁; ▁if ▁( ▁pos ▁!= ▁-1 ▁) ▁c out ▁<< ▁pos ▁; ▁else ▁c out ▁<< ▁0 ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁is Power Of Two ▁( ▁unsigned ▁n ▁) ▁{ ▁return ▁n ▁&& ▁( ▁! ▁( ▁n ▁& ▁( ▁n ▁- ▁1 ▁) ▁) ▁) ▁; ▁} ▁int ▁find Position ▁( ▁unsigned ▁n ▁) ▁{ ▁if ▁( ▁! ▁is Power Of Two ▁( ▁n ▁) ▁) ▁return ▁-1 ▁; ▁unsigned ▁i ▁= ▁1 ▁, ▁pos ▁= ▁1 ▁; ▁while ▁( ▁! ▁( ▁i ▁& ▁n ▁) ▁) ▁{ ▁i ▁= ▁i ▁<< ▁1 ▁; ▁++ ▁pos ▁; ▁} ▁return ▁pos ▁; ▁} ▁int ▁main ▁( ▁void ▁) ▁{ ▁int ▁n ▁= ▁16 ▁; ▁int ▁pos ▁= ▁find Position ▁( ▁n ▁) ▁; ▁( ▁pos ▁== ▁-1 ▁) ▁? ▁c out ▁<< ▁" ▁n ▁= ▁" ▁<< ▁n ▁<< ▁" ▁, ▁Invalid ▁number ▁" ▁<< ▁end l ▁: ▁c out ▁<< ▁" ▁n ▁= ▁" ▁<< ▁n ▁<< ▁" ▁, ▁Position ▁" ▁<< ▁pos ▁<< ▁end l ▁; ▁n ▁= ▁12 ▁; ▁pos ▁= ▁find Position ▁( ▁n ▁) ▁; ▁( ▁pos ▁== ▁-1 ▁) ▁? ▁c out ▁<< ▁" ▁n ▁= ▁" ▁<< ▁n ▁<< ▁" ▁, ▁Invalid ▁number ▁" ▁<< ▁end l ▁: ▁c out ▁<< ▁" ▁n ▁= ▁" ▁<< ▁n ▁<< ▁" ▁, ▁Position ▁" ▁<< ▁pos ▁<< ▁end l ▁; ▁n ▁= ▁128 ▁; ▁pos ▁= ▁find Position ▁( ▁n ▁) ▁; ▁( ▁pos ▁== ▁-1 ▁) ▁? ▁c out ▁<< ▁" ▁n ▁= ▁" ▁<< ▁n ▁<< ▁" ▁, ▁Invalid ▁number ▁" ▁<< ▁end l ▁: ▁c out ▁<< ▁" ▁n ▁= ▁" ▁<< ▁n ▁<< ▁" ▁, ▁Position ▁" ▁<< ▁pos ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁main ▁( ▁) ▁{ ▁int ▁x ▁= ▁10 ▁, ▁y ▁= ▁5 ▁; ▁x ▁= ▁x ▁* ▁y ▁; ▁y ▁= ▁x ▁/ ▁y ▁; ▁x ▁= ▁x ▁/ ▁y ▁; ▁c out ▁<< ▁" ▁After ▁Sw apping ▁: ▁x ▁= ▁" ▁<< ▁x ▁<< ▁" ▁, ▁y ▁= ▁" ▁<< ▁y ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁main ▁( ▁) ▁{ ▁int ▁x ▁= ▁10 ▁, ▁y ▁= ▁5 ▁; ▁x ▁= ▁x ▁^ ▁y ▁; ▁y ▁= ▁x ▁^ ▁y ▁; ▁x ▁= ▁x ▁^ ▁y ▁; ▁c out ▁<< ▁" ▁After ▁Sw apping ▁: ▁x ▁= ▁" ▁<< ▁x ▁<< ▁" ▁, ▁y ▁= ▁" ▁<< ▁y ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁swap ▁( ▁int ▁* ▁xp ▁, ▁int ▁* ▁y p ▁) ▁{ ▁* ▁xp ▁= ▁* ▁xp ▁^ ▁* ▁y p ▁; ▁* ▁y p ▁= ▁* ▁xp ▁^ ▁* ▁y p ▁; ▁* ▁xp ▁= ▁* ▁xp ▁^ ▁* ▁y p ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁x ▁= ▁10 ▁; ▁swap ▁( ▁& ▁x ▁, ▁& ▁x ▁) ▁; ▁c out ▁<< ▁" ▁After ▁swap ▁( ▁& ▁x ▁, ▁& ▁x ▁) ▁: ▁x ▁= ▁" ▁<< ▁x ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁swap ▁( ▁int ▁& ▁a ▁, ▁int ▁& ▁b ▁) ▁{ ▁a ▁= ▁( ▁a ▁& ▁b ▁) ▁+ ▁( ▁a ▁b ▁) ▁; ▁b ▁= ▁a ▁+ ▁( ▁~ ▁b ▁) ▁+ ▁1 ▁; ▁a ▁= ▁a ▁+ ▁( ▁~ ▁b ▁) ▁+ ▁1 ▁; ▁c out ▁<< ▁" ▁After ▁swapping ▁: ▁a ▁= ▁" ▁<< ▁a ▁<< ▁" ▁, ▁b ▁= ▁" ▁<< ▁b ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁= ▁5 ▁, ▁b ▁= ▁10 ▁; ▁swap ▁( ▁a ▁, ▁b ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁seg reg ate 0 and 1 ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁size ▁) ▁{ ▁int ▁left ▁= ▁0 ▁, ▁right ▁= ▁size ▁- ▁1 ▁; ▁while ▁( ▁left ▁< ▁right ▁) ▁{ ▁while ▁( ▁arr ▁[ ▁left ▁] ▁== ▁0 ▁&& ▁left ▁< ▁right ▁) ▁left ▁++ ▁; ▁while ▁( ▁arr ▁[ ▁right ▁] ▁== ▁1 ▁&& ▁left ▁< ▁right ▁) ▁right ▁-- ▁; ▁if ▁( ▁left ▁< ▁right ▁) ▁{ ▁arr ▁[ ▁left ▁] ▁= ▁0 ▁; ▁arr ▁[ ▁right ▁] ▁= ▁1 ▁; ▁left ▁++ ▁; ▁right ▁-- ▁; ▁} ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁} ▁; ▁int ▁i ▁, ▁arr _ size ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁seg reg ate 0 and 1 ▁( ▁arr ▁, ▁arr _ size ▁) ▁; ▁c out ▁<< ▁" ▁Array ▁after ▁seg reg ation ▁" ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁6 ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max Index Diff ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁max Diff ▁= ▁-1 ▁; ▁int ▁i ▁, ▁j ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁{ ▁for ▁( ▁j ▁= ▁n ▁- ▁1 ▁; ▁j ▁> ▁i ▁; ▁-- ▁j ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁j ▁] ▁> ▁arr ▁[ ▁i ▁] ▁&& ▁max Diff ▁< ▁( ▁j ▁- ▁i ▁) ▁) ▁max Diff ▁= ▁j ▁- ▁i ▁; ▁} ▁} ▁return ▁max Diff ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁9 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁, ▁7 ▁, ▁8 ▁, ▁18 ▁, ▁0 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁max Diff ▁= ▁max Index Diff ▁( ▁arr ▁, ▁n ▁) ▁; ▁c out ▁<< ▁" ▁STRNEWLINE ▁" ▁<< ▁max Diff ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁long ▁long ▁int ▁> ▁v ▁{ ▁34 ▁, ▁8 ▁, ▁10 ▁, ▁3 ▁, ▁2 ▁, ▁80 ▁, ▁30 ▁, ▁33 ▁, ▁1 ▁} ▁; ▁int ▁n ▁= ▁v ▁. ▁size ▁( ▁) ▁; ▁vector ▁< ▁long ▁long ▁int ▁> ▁max From End ▁( ▁n ▁+ ▁1 ▁, ▁INT _ MIN ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁v ▁. ▁size ▁( ▁) ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁max From End ▁[ ▁i ▁] ▁= ▁max ▁( ▁max From End ▁[ ▁i ▁+ ▁1 ▁] ▁, ▁v ▁[ ▁i ▁] ▁) ▁; ▁} ▁int ▁result ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁v ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁int ▁low ▁= ▁i ▁+ ▁1 ▁, ▁high ▁= ▁v ▁. ▁size ▁( ▁) ▁- ▁1 ▁, ▁ans ▁= ▁i ▁; ▁while ▁( ▁low ▁<= ▁high ▁) ▁{ ▁int ▁mid ▁= ▁( ▁low ▁+ ▁high ▁) ▁/ ▁2 ▁; ▁if ▁( ▁v ▁[ ▁i ▁] ▁<= ▁max From End ▁[ ▁mid ▁] ▁) ▁{ ▁ans ▁= ▁max ▁( ▁ans ▁, ▁mid ▁) ▁; ▁low ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁else ▁{ ▁high ▁= ▁mid ▁- ▁1 ▁; ▁} ▁} ▁result ▁= ▁max ▁( ▁result ▁, ▁ans ▁- ▁i ▁) ▁; ▁} ▁c out ▁<< ▁result ▁<< ▁end l ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Maximum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁low ▁, ▁int ▁high ▁) ▁{ ▁int ▁max ▁= ▁arr ▁[ ▁low ▁] ▁; ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁low ▁+ ▁1 ▁; ▁i ▁<= ▁high ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁max ▁) ▁max ▁= ▁arr ▁[ ▁i ▁] ▁; ▁else ▁break ▁; ▁} ▁return ▁max ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁30 ▁, ▁40 ▁, ▁50 ▁, ▁60 ▁, ▁70 ▁, ▁23 ▁, ▁20 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁The ▁maximum ▁element ▁is ▁" ▁<< ▁find Maximum ▁( ▁arr ▁, ▁0 ▁, ▁n ▁- ▁1 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁fun ▁( ▁int ▁x ▁) ▁{ ▁int ▁y ▁= ▁( ▁x ▁/ ▁4 ▁) ▁* ▁4 ▁; ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁y ▁; ▁i ▁<= ▁x ▁; ▁i ▁++ ▁) ▁ans ▁^= ▁i ▁; ▁return ▁ans ▁; ▁} ▁int ▁query ▁( ▁int ▁x ▁) ▁{ ▁if ▁( ▁x ▁== ▁0 ▁) ▁return ▁0 ▁; ▁int ▁k ▁= ▁( ▁x ▁+ ▁1 ▁) ▁/ ▁2 ▁; ▁return ▁( ▁x ▁% = ▁2 ▁) ▁? ▁2 ▁* ▁fun ▁( ▁k ▁) ▁: ▁( ▁( ▁fun ▁( ▁k ▁- ▁1 ▁) ▁* ▁2 ▁) ▁^ ▁( ▁k ▁& ▁1 ▁) ▁) ▁; ▁} ▁void ▁all Queries ▁( ▁int ▁q ▁, ▁int ▁l ▁[ ▁] ▁, ▁int ▁r ▁[ ▁] ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁q ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁( ▁query ▁( ▁r ▁[ ▁i ▁] ▁) ▁^ ▁query ▁( ▁l ▁[ ▁i ▁] ▁- ▁1 ▁) ▁) ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁q ▁= ▁3 ▁; ▁int ▁l ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁2 ▁, ▁5 ▁} ▁; ▁int ▁r ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁8 ▁, ▁9 ▁} ▁; ▁all Queries ▁( ▁q ▁, ▁l ▁, ▁r ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁double ▁probability ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁b ▁[ ▁] ▁, ▁int ▁size 1 ▁, ▁int ▁size 2 ▁) ▁{ ▁int ▁max 1 ▁= ▁INT _ MIN ▁, ▁count 1 ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁size 1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁> ▁max 1 ▁) ▁{ ▁max 1 ▁= ▁a ▁[ ▁i ▁] ▁; ▁count 1 ▁= ▁1 ▁; ▁} ▁else ▁if ▁( ▁a ▁[ ▁i ▁] ▁== ▁max 1 ▁) ▁{ ▁count 1 ▁++ ▁; ▁} ▁} ▁int ▁max 2 ▁= ▁INT _ MIN ▁, ▁count 2 ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁size 2 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁b ▁[ ▁i ▁] ▁> ▁max 2 ▁) ▁{ ▁max 2 ▁= ▁b ▁[ ▁i ▁] ▁; ▁count 2 ▁= ▁1 ▁; ▁} ▁else ▁if ▁( ▁b ▁[ ▁i ▁] ▁== ▁max 2 ▁) ▁{ ▁count 2 ▁++ ▁; ▁} ▁} ▁return ▁( ▁double ▁) ▁( ▁count 1 ▁* ▁count 2 ▁) ▁/ ▁( ▁size 1 ▁* ▁size 2 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁; ▁int ▁b ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁3 ▁} ▁; ▁int ▁size 1 ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁int ▁size 2 ▁= ▁sizeof ▁( ▁b ▁) ▁/ ▁sizeof ▁( ▁b ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁probability ▁( ▁a ▁, ▁b ▁, ▁size 1 ▁, ▁size 2 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁min sw aps ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁int ▁num _ un pla ced _ zeros ▁= ▁0 ▁; ▁for ▁( ▁int ▁index ▁= ▁n ▁- ▁1 ▁; ▁index ▁>= ▁0 ▁; ▁index ▁-- ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁index ▁] ▁== ▁0 ▁) ▁num _ un pla ced _ zeros ▁+= ▁1 ▁; ▁else ▁count ▁+= ▁num _ un pla ced _ zeros ▁; ▁} ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁} ▁; ▁c out ▁<< ▁min sw aps ▁( ▁arr ▁, ▁9 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁sorted Merge ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁b ▁[ ▁] ▁, ▁int ▁res ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁sort ▁( ▁a ▁, ▁a ▁+ ▁n ▁) ▁; ▁sort ▁( ▁b ▁, ▁b ▁+ ▁m ▁) ▁; ▁int ▁i ▁= ▁0 ▁, ▁j ▁= ▁0 ▁, ▁k ▁= ▁0 ▁; ▁while ▁( ▁i ▁< ▁n ▁&& ▁j ▁< ▁m ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁<= ▁b ▁[ ▁j ▁] ▁) ▁{ ▁res ▁[ ▁k ▁] ▁= ▁a ▁[ ▁i ▁] ▁; ▁i ▁+= ▁1 ▁; ▁k ▁+= ▁1 ▁; ▁} ▁else ▁{ ▁res ▁[ ▁k ▁] ▁= ▁b ▁[ ▁j ▁] ▁; ▁j ▁+= ▁1 ▁; ▁k ▁+= ▁1 ▁; ▁} ▁} ▁while ▁( ▁i ▁< ▁n ▁) ▁{ ▁res ▁[ ▁k ▁] ▁= ▁a ▁[ ▁i ▁] ▁; ▁i ▁+= ▁1 ▁; ▁k ▁+= ▁1 ▁; ▁} ▁while ▁( ▁j ▁< ▁m ▁) ▁{ ▁res ▁[ ▁k ▁] ▁= ▁b ▁[ ▁j ▁] ▁; ▁j ▁+= ▁1 ▁; ▁k ▁+= ▁1 ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁5 ▁, ▁15 ▁} ▁; ▁int ▁b ▁[ ▁] ▁= ▁{ ▁20 ▁, ▁3 ▁, ▁2 ▁, ▁12 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁int ▁m ▁= ▁sizeof ▁( ▁b ▁) ▁/ ▁sizeof ▁( ▁b ▁[ ▁0 ▁] ▁) ▁; ▁int ▁res ▁[ ▁n ▁+ ▁m ▁] ▁; ▁sorted Merge ▁( ▁a ▁, ▁b ▁, ▁res ▁, ▁n ▁, ▁m ▁) ▁; ▁c out ▁<< ▁" ▁Sorted ▁merge ▁list ▁: ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁+ ▁m ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁" ▁" ▁<< ▁res ▁[ ▁i ▁] ▁; ▁c out ▁<< ▁" ▁n ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁single element ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁low ▁= ▁0 ▁, ▁high ▁= ▁n ▁- ▁2 ▁; ▁int ▁mid ▁; ▁while ▁( ▁low ▁<= ▁high ▁) ▁{ ▁mid ▁= ▁( ▁low ▁+ ▁high ▁) ▁/ ▁2 ▁; ▁if ▁( ▁arr ▁[ ▁mid ▁] ▁== ▁arr ▁[ ▁mid ▁^ ▁1 ▁] ▁) ▁{ ▁low ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁else ▁{ ▁high ▁= ▁mid ▁- ▁1 ▁; ▁} ▁} ▁return ▁arr ▁[ ▁low ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁5 ▁, ▁4 ▁, ▁5 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁size ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁sort ▁( ▁arr ▁, ▁arr ▁+ ▁size ▁) ▁; ▁c out ▁<< ▁single element ▁( ▁arr ▁, ▁size ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁getM issing No ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁total ▁= ▁( ▁n ▁+ ▁1 ▁) ▁* ▁( ▁n ▁+ ▁2 ▁) ▁/ ▁2 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁total ▁-= ▁a ▁[ ▁i ▁] ▁; ▁return ▁total ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁miss ▁= ▁getM issing No ▁( ▁arr ▁, ▁n ▁) ▁; ▁c out ▁<< ▁miss ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁getM issing No ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁i ▁, ▁total ▁= ▁1 ▁; ▁for ▁( ▁i ▁= ▁2 ▁; ▁i ▁<= ▁( ▁n ▁+ ▁1 ▁) ▁; ▁i ▁++ ▁) ▁{ ▁total ▁+= ▁i ▁; ▁total ▁-= ▁a ▁[ ▁i ▁- ▁2 ▁] ▁; ▁} ▁return ▁total ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁5 ▁} ▁; ▁c out ▁<< ▁getM issing No ▁( ▁arr ▁, ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁getM issing No ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁n _ elements _ sum ▁= ▁n ▁* ▁( ▁n ▁+ ▁1 ▁) ▁/ ▁2 ▁; ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁sum ▁+= ▁a ▁[ ▁i ▁] ▁; ▁return ▁n _ elements _ sum ▁- ▁sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁+ ▁1 ▁; ▁int ▁miss ▁= ▁getM issing No ▁( ▁a ▁, ▁n ▁) ▁; ▁c out ▁<< ▁( ▁miss ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find Four Elements ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁X ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁3 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁- ▁2 ▁; ▁j ▁++ ▁) ▁{ ▁for ▁( ▁int ▁k ▁= ▁j ▁+ ▁1 ▁; ▁k ▁< ▁n ▁- ▁1 ▁; ▁k ▁++ ▁) ▁{ ▁for ▁( ▁int ▁l ▁= ▁k ▁+ ▁1 ▁; ▁l ▁< ▁n ▁; ▁l ▁++ ▁) ▁if ▁( ▁A ▁[ ▁i ▁] ▁+ ▁A ▁[ ▁j ▁] ▁+ ▁A ▁[ ▁k ▁] ▁+ ▁A ▁[ ▁l ▁] ▁== ▁X ▁) ▁c out ▁<< ▁A ▁[ ▁i ▁] ▁<< ▁" ▁, ▁" ▁<< ▁A ▁[ ▁j ▁] ▁<< ▁" ▁, ▁" ▁<< ▁A ▁[ ▁k ▁] ▁<< ▁" ▁, ▁" ▁<< ▁A ▁[ ▁l ▁] ▁; ▁} ▁} ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁20 ▁, ▁30 ▁, ▁40 ▁, ▁1 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁A ▁) ▁/ ▁sizeof ▁( ▁A ▁[ ▁0 ▁] ▁) ▁; ▁int ▁X ▁= ▁91 ▁; ▁find Four Elements ▁( ▁A ▁, ▁n ▁, ▁X ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Major ity ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁return ▁arr ▁[ ▁n ▁/ ▁2 ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁2 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁find Major ity ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁least F requ ent ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁sort ▁( ▁arr ▁, ▁arr ▁+ ▁n ▁) ▁; ▁int ▁min _ count ▁= ▁n ▁+ ▁1 ▁, ▁res ▁= ▁-1 ▁, ▁curr _ count ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁) ▁curr _ count ▁++ ▁; ▁else ▁{ ▁if ▁( ▁curr _ count ▁< ▁min _ count ▁) ▁{ ▁min _ count ▁= ▁curr _ count ▁; ▁res ▁= ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁; ▁} ▁curr _ count ▁= ▁1 ▁; ▁} ▁} ▁if ▁( ▁curr _ count ▁< ▁min _ count ▁) ▁{ ▁min _ count ▁= ▁curr _ count ▁; ▁res ▁= ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁; ▁} ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁2 ▁, ▁1 ▁, ▁2 ▁, ▁2 ▁, ▁3 ▁, ▁1 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁least F requ ent ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print missing k ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁map ▁< ▁int ▁, ▁int ▁> ▁d ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁d ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁= ▁arr ▁[ ▁i ▁] ▁; ▁int ▁cnt ▁= ▁1 ▁; ▁int ▁fl ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁( ▁n ▁+ ▁k ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁d ▁. ▁find ▁( ▁cnt ▁) ▁== ▁d ▁. ▁end ▁( ▁) ▁) ▁{ ▁fl ▁+= ▁1 ▁; ▁c out ▁<< ▁cnt ▁<< ▁" ▁" ▁; ▁if ▁( ▁fl ▁== ▁k ▁) ▁break ▁; ▁} ▁cnt ▁+= ▁1 ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁4 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁k ▁= ▁3 ▁; ▁; ▁print missing k ▁( ▁arr ▁, ▁n ▁, ▁k ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁min Product Subset ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁1 ▁) ▁return ▁a ▁[ ▁0 ▁] ▁; ▁int ▁max _ neg ▁= ▁INT _ MIN ▁; ▁int ▁min _ pos ▁= ▁INT _ MAX ▁; ▁int ▁count _ neg ▁= ▁0 ▁, ▁count _ zero ▁= ▁0 ▁; ▁int ▁prod ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁count _ zero ▁++ ▁; ▁continue ▁; ▁} ▁if ▁( ▁a ▁[ ▁i ▁] ▁< ▁0 ▁) ▁{ ▁count _ neg ▁++ ▁; ▁max _ neg ▁= ▁max ▁( ▁max _ neg ▁, ▁a ▁[ ▁i ▁] ▁) ▁; ▁} ▁if ▁( ▁a ▁[ ▁i ▁] ▁> ▁0 ▁) ▁min _ pos ▁= ▁min ▁( ▁min _ pos ▁, ▁a ▁[ ▁i ▁] ▁) ▁; ▁prod ▁= ▁prod ▁* ▁a ▁[ ▁i ▁] ▁; ▁} ▁if ▁( ▁count _ zero ▁== ▁n ▁|| ▁( ▁count _ neg ▁== ▁0 ▁&& ▁count _ zero ▁> ▁0 ▁) ▁) ▁return ▁0 ▁; ▁if ▁( ▁count _ neg ▁== ▁0 ▁) ▁return ▁min _ pos ▁; ▁if ▁( ▁! ▁( ▁count _ neg ▁& ▁1 ▁) ▁&& ▁count _ neg ▁!= ▁0 ▁) ▁{ ▁prod ▁= ▁prod ▁/ ▁max _ neg ▁; ▁} ▁return ▁prod ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁-1 ▁, ▁-1 ▁, ▁-2 ▁, ▁4 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁min Product Subset ▁( ▁a ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁struct ▁Node ▁{ ▁int ▁data ▁; ▁struct ▁Node ▁* ▁next ▁; ▁} ▁; ▁int ▁count Common ▁( ▁Node ▁* ▁a ▁, ▁Node ▁* ▁b ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁; ▁a ▁&& ▁b ▁; ▁a ▁= ▁a ▁-> ▁next ▁, ▁b ▁= ▁b ▁-> ▁next ▁) ▁if ▁( ▁a ▁-> ▁data ▁== ▁b ▁-> ▁data ▁) ▁++ ▁count ▁; ▁else ▁break ▁; ▁return ▁count ▁; ▁} ▁int ▁max Pal indrome ▁( ▁Node ▁* ▁head ▁) ▁{ ▁int ▁result ▁= ▁0 ▁; ▁Node ▁* ▁prev ▁= ▁NULL ▁, ▁* ▁curr ▁= ▁head ▁; ▁while ▁( ▁curr ▁) ▁{ ▁Node ▁* ▁next ▁= ▁curr ▁-> ▁next ▁; ▁curr ▁-> ▁next ▁= ▁prev ▁; ▁result ▁= ▁max ▁( ▁result ▁, ▁2 ▁* ▁count Common ▁( ▁prev ▁, ▁next ▁) ▁+ ▁1 ▁) ▁; ▁result ▁= ▁max ▁( ▁result ▁, ▁2 ▁* ▁count Common ▁( ▁curr ▁, ▁next ▁) ▁) ▁; ▁prev ▁= ▁curr ▁; ▁curr ▁= ▁next ▁; ▁} ▁return ▁result ▁; ▁} ▁Node ▁* ▁newNode ▁( ▁int ▁key ▁) ▁{ ▁Node ▁* ▁temp ▁= ▁new ▁Node ▁; ▁temp ▁-> ▁data ▁= ▁key ▁; ▁temp ▁-> ▁next ▁= ▁NULL ▁; ▁return ▁temp ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁Node ▁* ▁head ▁= ▁newNode ▁( ▁2 ▁) ▁; ▁head ▁-> ▁next ▁= ▁newNode ▁( ▁4 ▁) ▁; ▁head ▁-> ▁next ▁-> ▁next ▁= ▁newNode ▁( ▁3 ▁) ▁; ▁head ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁= ▁newNode ▁( ▁4 ▁) ▁; ▁head ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁= ▁newNode ▁( ▁2 ▁) ▁; ▁head ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁= ▁newNode ▁( ▁15 ▁) ▁; ▁c out ▁<< ▁max Pal indrome ▁( ▁head ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁struct ▁Node ▁{ ▁int ▁data ▁; ▁struct ▁Node ▁* ▁next ▁; ▁} ▁; ▁void ▁free List ▁( ▁Node ▁* ▁node ▁) ▁{ ▁while ▁( ▁node ▁!= ▁NULL ▁) ▁{ ▁Node ▁* ▁next ▁= ▁node ▁-> ▁next ▁; ▁delete ▁( ▁node ▁) ▁; ▁node ▁= ▁next ▁; ▁} ▁} ▁Node ▁* ▁delete K th Node ▁( ▁struct ▁Node ▁* ▁head ▁, ▁int ▁k ▁) ▁{ ▁if ▁( ▁head ▁== ▁NULL ▁) ▁return ▁NULL ▁; ▁if ▁( ▁k ▁== ▁1 ▁) ▁{ ▁free List ▁( ▁head ▁) ▁; ▁return ▁NULL ▁; ▁} ▁struct ▁Node ▁* ▁ptr ▁= ▁head ▁, ▁* ▁prev ▁= ▁NULL ▁; ▁int ▁count ▁= ▁0 ▁; ▁while ▁( ▁ptr ▁!= ▁NULL ▁) ▁{ ▁count ▁++ ▁; ▁if ▁( ▁k ▁== ▁count ▁) ▁{ ▁delete ▁( ▁prev ▁-> ▁next ▁) ▁; ▁prev ▁-> ▁next ▁= ▁ptr ▁-> ▁next ▁; ▁count ▁= ▁0 ▁; ▁} ▁if ▁( ▁count ▁!= ▁0 ▁) ▁prev ▁= ▁ptr ▁; ▁ptr ▁= ▁prev ▁-> ▁next ▁; ▁} ▁return ▁head ▁; ▁} ▁void ▁display List ▁( ▁struct ▁Node ▁* ▁head ▁) ▁{ ▁struct ▁Node ▁* ▁temp ▁= ▁head ▁; ▁while ▁( ▁temp ▁!= ▁NULL ▁) ▁{ ▁c out ▁<< ▁temp ▁-> ▁data ▁<< ▁" ▁" ▁; ▁temp ▁= ▁temp ▁-> ▁next ▁; ▁} ▁} ▁struct ▁Node ▁* ▁newNode ▁( ▁int ▁x ▁) ▁{ ▁Node ▁* ▁temp ▁= ▁new ▁Node ▁; ▁temp ▁-> ▁data ▁= ▁x ▁; ▁temp ▁-> ▁next ▁= ▁NULL ▁; ▁return ▁temp ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁struct ▁Node ▁* ▁head ▁= ▁newNode ▁( ▁1 ▁) ▁; ▁head ▁-> ▁next ▁= ▁newNode ▁( ▁2 ▁) ▁; ▁head ▁-> ▁next ▁-> ▁next ▁= ▁newNode ▁( ▁3 ▁) ▁; ▁head ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁= ▁newNode ▁( ▁4 ▁) ▁; ▁head ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁= ▁newNode ▁( ▁5 ▁) ▁; ▁head ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁= ▁newNode ▁( ▁6 ▁) ▁; ▁head ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁= ▁newNode ▁( ▁7 ▁) ▁; ▁head ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁= ▁newNode ▁( ▁8 ▁) ▁; ▁int ▁k ▁= ▁3 ▁; ▁head ▁= ▁delete K th Node ▁( ▁head ▁, ▁k ▁) ▁; ▁display List ▁( ▁head ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁struct ▁Node ▁{ ▁int ▁data ▁; ▁struct ▁Node ▁* ▁next ▁; ▁} ▁; ▁void ▁push ▁( ▁struct ▁Node ▁* ▁* ▁head _ ref ▁, ▁int ▁new _ data ▁) ▁{ ▁struct ▁Node ▁* ▁new _ node ▁= ▁new ▁Node ▁; ▁new _ node ▁-> ▁data ▁= ▁new _ data ▁; ▁new _ node ▁-> ▁next ▁= ▁( ▁* ▁head _ ref ▁) ▁; ▁( ▁* ▁head _ ref ▁) ▁= ▁new _ node ▁; ▁} ▁void ▁sum Of Last N _ Nodes ▁( ▁struct ▁Node ▁* ▁head ▁, ▁int ▁* ▁n ▁, ▁int ▁* ▁sum ▁) ▁{ ▁if ▁( ▁! ▁head ▁) ▁return ▁; ▁sum Of Last N _ Nodes ▁( ▁head ▁-> ▁next ▁, ▁n ▁, ▁sum ▁) ▁; ▁if ▁( ▁* ▁n ▁> ▁0 ▁) ▁{ ▁* ▁sum ▁= ▁* ▁sum ▁+ ▁head ▁-> ▁data ▁; ▁-- ▁* ▁n ▁; ▁} ▁} ▁int ▁sum Of Last N _ Nodes Util ▁( ▁struct ▁Node ▁* ▁head ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁<= ▁0 ▁) ▁return ▁0 ▁; ▁int ▁sum ▁= ▁0 ▁; ▁sum Of Last N _ Nodes ▁( ▁head ▁, ▁& ▁n ▁, ▁& ▁sum ▁) ▁; ▁return ▁sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁struct ▁Node ▁* ▁head ▁= ▁NULL ▁; ▁push ▁( ▁& ▁head ▁, ▁12 ▁) ▁; ▁push ▁( ▁& ▁head ▁, ▁4 ▁) ▁; ▁push ▁( ▁& ▁head ▁, ▁8 ▁) ▁; ▁push ▁( ▁& ▁head ▁, ▁6 ▁) ▁; ▁push ▁( ▁& ▁head ▁, ▁10 ▁) ▁; ▁int ▁n ▁= ▁2 ▁; ▁c out ▁<< ▁" ▁Sum ▁of ▁last ▁" ▁<< ▁n ▁<< ▁" ▁nodes ▁= ▁" ▁<< ▁sum Of Last N _ Nodes Util ▁( ▁head ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁struct ▁Node ▁{ ▁char ▁data ▁; ▁struct ▁Node ▁* ▁next ▁; ▁struct ▁Node ▁* ▁prev ▁; ▁} ▁; ▁void ▁push ▁( ▁struct ▁Node ▁* ▁* ▁head _ ref ▁, ▁char ▁new _ data ▁) ▁{ ▁struct ▁Node ▁* ▁new _ node ▁= ▁new ▁Node ▁; ▁new _ node ▁-> ▁data ▁= ▁new _ data ▁; ▁new _ node ▁-> ▁next ▁= ▁( ▁* ▁head _ ref ▁) ▁; ▁new _ node ▁-> ▁prev ▁= ▁NULL ▁; ▁if ▁( ▁( ▁* ▁head _ ref ▁) ▁!= ▁NULL ▁) ▁( ▁* ▁head _ ref ▁) ▁-> ▁prev ▁= ▁new _ node ▁; ▁( ▁* ▁head _ ref ▁) ▁= ▁new _ node ▁; ▁} ▁bool ▁isP al indrome ▁( ▁struct ▁Node ▁* ▁left ▁) ▁{ ▁if ▁( ▁left ▁== ▁NULL ▁) ▁return ▁true ▁; ▁struct ▁Node ▁* ▁right ▁= ▁left ▁; ▁while ▁( ▁right ▁-> ▁next ▁!= ▁NULL ▁) ▁right ▁= ▁right ▁-> ▁next ▁; ▁while ▁( ▁left ▁!= ▁right ▁) ▁{ ▁if ▁( ▁left ▁-> ▁data ▁!= ▁right ▁-> ▁data ▁) ▁return ▁false ▁; ▁left ▁= ▁left ▁-> ▁next ▁; ▁right ▁= ▁right ▁-> ▁prev ▁; ▁} ▁return ▁true ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁struct ▁Node ▁* ▁head ▁= ▁NULL ▁; ▁push ▁( ▁& ▁head ▁, ▁' ▁l ▁' ▁) ▁; ▁push ▁( ▁& ▁head ▁, ▁' ▁e ▁' ▁) ▁; ▁push ▁( ▁& ▁head ▁, ▁' ▁v ▁' ▁) ▁; ▁push ▁( ▁& ▁head ▁, ▁' ▁e ▁' ▁) ▁; ▁push ▁( ▁& ▁head ▁, ▁' ▁l ▁' ▁) ▁; ▁if ▁( ▁isP al indrome ▁( ▁head ▁) ▁) ▁printf ▁( ▁" ▁It ▁is ▁P al indrome ▁" ▁) ▁; ▁else ▁printf ▁( ▁" ▁Not ▁P al indrome ▁" ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁struct ▁Node ▁{ ▁int ▁data ▁; ▁struct ▁Node ▁* ▁left ▁, ▁* ▁right ▁; ▁} ▁; ▁void ▁print Leaf Nodes ▁( ▁Node ▁* ▁root ▁) ▁{ ▁if ▁( ▁! ▁root ▁) ▁return ▁; ▁if ▁( ▁! ▁root ▁-> ▁left ▁&& ▁! ▁root ▁-> ▁right ▁) ▁{ ▁c out ▁<< ▁root ▁-> ▁data ▁<< ▁" ▁" ▁; ▁return ▁; ▁} ▁if ▁( ▁root ▁-> ▁left ▁) ▁print Leaf Nodes ▁( ▁root ▁-> ▁left ▁) ▁; ▁if ▁( ▁root ▁-> ▁right ▁) ▁print Leaf Nodes ▁( ▁root ▁-> ▁right ▁) ▁; ▁} ▁Node ▁* ▁newNode ▁( ▁int ▁data ▁) ▁{ ▁Node ▁* ▁temp ▁= ▁new ▁Node ▁; ▁temp ▁-> ▁data ▁= ▁data ▁; ▁temp ▁-> ▁left ▁= ▁temp ▁-> ▁right ▁= ▁NULL ▁; ▁return ▁temp ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁Node ▁* ▁root ▁= ▁newNode ▁( ▁1 ▁) ▁; ▁root ▁-> ▁left ▁= ▁newNode ▁( ▁2 ▁) ▁; ▁root ▁-> ▁right ▁= ▁newNode ▁( ▁3 ▁) ▁; ▁root ▁-> ▁left ▁-> ▁left ▁= ▁newNode ▁( ▁4 ▁) ▁; ▁root ▁-> ▁right ▁-> ▁left ▁= ▁newNode ▁( ▁5 ▁) ▁; ▁root ▁-> ▁right ▁-> ▁right ▁= ▁newNode ▁( ▁8 ▁) ▁; ▁root ▁-> ▁right ▁-> ▁left ▁-> ▁left ▁= ▁newNode ▁( ▁6 ▁) ▁; ▁root ▁-> ▁right ▁-> ▁left ▁-> ▁right ▁= ▁newNode ▁( ▁7 ▁) ▁; ▁root ▁-> ▁right ▁-> ▁right ▁-> ▁left ▁= ▁newNode ▁( ▁9 ▁) ▁; ▁root ▁-> ▁right ▁-> ▁right ▁-> ▁right ▁= ▁newNode ▁( ▁10 ▁) ▁; ▁print Leaf Nodes ▁( ▁root ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁struct ▁node ▁{ ▁int ▁data ▁; ▁struct ▁node ▁* ▁left ▁, ▁* ▁right ▁; ▁} ▁; ▁void ▁print k distance Node Down ▁( ▁node ▁* ▁root ▁, ▁int ▁k ▁) ▁{ ▁if ▁( ▁root ▁== ▁NULL ▁k ▁< ▁0 ▁) ▁return ▁; ▁if ▁( ▁k ▁== ▁0 ▁) ▁{ ▁c out ▁<< ▁root ▁-> ▁data ▁<< ▁end l ▁; ▁return ▁; ▁} ▁print k distance Node Down ▁( ▁root ▁-> ▁left ▁, ▁k ▁- ▁1 ▁) ▁; ▁print k distance Node Down ▁( ▁root ▁-> ▁right ▁, ▁k ▁- ▁1 ▁) ▁; ▁} ▁int ▁print k distance Node ▁( ▁node ▁* ▁root ▁, ▁node ▁* ▁target ▁, ▁int ▁k ▁) ▁{ ▁if ▁( ▁root ▁== ▁NULL ▁) ▁return ▁-1 ▁; ▁if ▁( ▁root ▁== ▁target ▁) ▁{ ▁print k distance Node Down ▁( ▁root ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁} ▁int ▁dl ▁= ▁print k distance Node ▁( ▁root ▁-> ▁left ▁, ▁target ▁, ▁k ▁) ▁; ▁if ▁( ▁dl ▁!= ▁-1 ▁) ▁{ ▁if ▁( ▁dl ▁+ ▁1 ▁== ▁k ▁) ▁c out ▁<< ▁root ▁-> ▁data ▁<< ▁end l ▁; ▁else ▁print k distance Node Down ▁( ▁root ▁-> ▁right ▁, ▁k ▁- ▁dl ▁- ▁2 ▁) ▁; ▁return ▁1 ▁+ ▁dl ▁; ▁} ▁int ▁dr ▁= ▁print k distance Node ▁( ▁root ▁-> ▁right ▁, ▁target ▁, ▁k ▁) ▁; ▁if ▁( ▁dr ▁!= ▁-1 ▁) ▁{ ▁if ▁( ▁dr ▁+ ▁1 ▁== ▁k ▁) ▁c out ▁<< ▁root ▁-> ▁data ▁<< ▁end l ▁; ▁else ▁print k distance Node Down ▁( ▁root ▁-> ▁left ▁, ▁k ▁- ▁dr ▁- ▁2 ▁) ▁; ▁return ▁1 ▁+ ▁dr ▁; ▁} ▁return ▁-1 ▁; ▁} ▁node ▁* ▁newnode ▁( ▁int ▁data ▁) ▁{ ▁node ▁* ▁temp ▁= ▁new ▁node ▁; ▁temp ▁-> ▁data ▁= ▁data ▁; ▁temp ▁-> ▁left ▁= ▁temp ▁-> ▁right ▁= ▁NULL ▁; ▁return ▁temp ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁node ▁* ▁root ▁= ▁newnode ▁( ▁20 ▁) ▁; ▁root ▁-> ▁left ▁= ▁newnode ▁( ▁8 ▁) ▁; ▁root ▁-> ▁right ▁= ▁newnode ▁( ▁22 ▁) ▁; ▁root ▁-> ▁left ▁-> ▁left ▁= ▁newnode ▁( ▁4 ▁) ▁; ▁root ▁-> ▁left ▁-> ▁right ▁= ▁newnode ▁( ▁12 ▁) ▁; ▁root ▁-> ▁left ▁-> ▁right ▁-> ▁left ▁= ▁newnode ▁( ▁10 ▁) ▁; ▁root ▁-> ▁left ▁-> ▁right ▁-> ▁right ▁= ▁newnode ▁( ▁14 ▁) ▁; ▁node ▁* ▁target ▁= ▁root ▁-> ▁left ▁-> ▁right ▁; ▁print k distance Node ▁( ▁root ▁, ▁target ▁, ▁2 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁N ▁3 ▁NEW _ LINE ▁int ▁find Maximum Diag onal Sum OM atrix f ▁( ▁int ▁A ▁[ ▁] ▁[ ▁N ▁] ▁) ▁{ ▁int ▁max Diag onal Sum ▁= ▁INT _ MIN ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁int ▁curr ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁curr ▁+= ▁A ▁[ ▁j ▁] ▁[ ▁( ▁i ▁+ ▁j ▁) ▁% ▁N ▁] ▁; ▁} ▁max Diag onal Sum ▁= ▁max ▁( ▁max Diag onal Sum ▁, ▁curr ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁int ▁curr ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁curr ▁+= ▁A ▁[ ▁( ▁i ▁+ ▁j ▁) ▁% ▁N ▁] ▁[ ▁j ▁] ▁; ▁} ▁max Diag onal Sum ▁= ▁max ▁( ▁max Diag onal Sum ▁, ▁curr ▁) ▁; ▁} ▁return ▁max Diag onal Sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁mat ▁[ ▁N ▁] ▁[ ▁N ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁1 ▁, ▁2 ▁} ▁, ▁{ ▁2 ▁, ▁1 ▁, ▁2 ▁} ▁, ▁{ ▁1 ▁, ▁2 ▁, ▁2 ▁} ▁} ▁; ▁c out ▁<< ▁find Maximum Diag onal Sum OM atrix f ▁( ▁mat ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁left _ rotate ▁( ▁int ▁arr ▁[ ▁] ▁) ▁{ ▁int ▁last ▁= ▁arr ▁[ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁3 ▁; ▁i ▁< ▁6 ▁; ▁i ▁= ▁i ▁+ ▁2 ▁) ▁{ ▁arr ▁[ ▁i ▁- ▁2 ▁] ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁arr ▁[ ▁6 ▁- ▁1 ▁] ▁= ▁last ▁; ▁} ▁void ▁right _ rotate ▁( ▁int ▁arr ▁[ ▁] ▁) ▁{ ▁int ▁start ▁= ▁arr ▁[ ▁6 ▁- ▁2 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁6 ▁- ▁4 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁= ▁i ▁- ▁2 ▁) ▁{ ▁arr ▁[ ▁i ▁+ ▁2 ▁] ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁arr ▁[ ▁0 ▁] ▁= ▁start ▁; ▁} ▁void ▁rotate ▁( ▁int ▁arr ▁[ ▁] ▁) ▁{ ▁left _ rotate ▁( ▁arr ▁) ▁; ▁right _ rotate ▁( ▁arr ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁6 ▁; ▁i ▁++ ▁) ▁{ ▁c out ▁<< ▁( ▁arr ▁[ ▁i ▁] ▁) ▁<< ▁" ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁rotate ▁( ▁arr ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Rotation ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁low ▁, ▁int ▁high ▁) ▁{ ▁if ▁( ▁low ▁> ▁high ▁) ▁{ ▁return ▁0 ▁; ▁} ▁int ▁mid ▁= ▁low ▁+ ▁( ▁high ▁- ▁low ▁) ▁/ ▁2 ▁; ▁if ▁( ▁mid ▁< ▁high ▁&& ▁arr ▁[ ▁mid ▁] ▁> ▁arr ▁[ ▁mid ▁+ ▁1 ▁] ▁) ▁{ ▁return ▁mid ▁+ ▁1 ▁; ▁} ▁if ▁( ▁mid ▁> ▁low ▁&& ▁arr ▁[ ▁mid ▁] ▁< ▁arr ▁[ ▁mid ▁- ▁1 ▁] ▁) ▁{ ▁return ▁mid ▁; ▁} ▁if ▁( ▁arr ▁[ ▁mid ▁] ▁> ▁arr ▁[ ▁low ▁] ▁) ▁{ ▁return ▁count Rotation ▁( ▁arr ▁, ▁mid ▁+ ▁1 ▁, ▁high ▁) ▁; ▁} ▁if ▁( ▁arr ▁[ ▁mid ▁] ▁< ▁arr ▁[ ▁high ▁] ▁) ▁{ ▁return ▁count Rotation ▁( ▁arr ▁, ▁low ▁, ▁mid ▁- ▁1 ▁) ▁; ▁} ▁else ▁{ ▁int ▁right Index ▁= ▁count Rotation ▁( ▁arr ▁, ▁mid ▁+ ▁1 ▁, ▁high ▁) ▁; ▁int ▁left Index ▁= ▁count Rotation ▁( ▁arr ▁, ▁low ▁, ▁mid ▁- ▁1 ▁) ▁; ▁if ▁( ▁right Index ▁== ▁0 ▁) ▁{ ▁return ▁left Index ▁; ▁} ▁return ▁right Index ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr 1 ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁5 ▁, ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr 1 ▁) ▁/ ▁sizeof ▁( ▁arr 1 ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁count Rotation ▁( ▁arr 1 ▁, ▁0 ▁, ▁N ▁- ▁1 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁const ▁int ▁MAX ▁= ▁10000 5 ▁; ▁using ▁namespace ▁std ▁; ▁int ▁seg ▁[ ▁4 ▁* ▁MAX ▁] ▁; ▁void ▁build ▁( ▁int ▁node ▁, ▁int ▁l ▁, ▁int ▁r ▁, ▁int ▁a ▁[ ▁] ▁) ▁{ ▁if ▁( ▁l ▁== ▁r ▁) ▁seg ▁[ ▁node ▁] ▁= ▁a ▁[ ▁l ▁] ▁; ▁else ▁{ ▁int ▁mid ▁= ▁( ▁l ▁+ ▁r ▁) ▁/ ▁2 ▁; ▁build ▁( ▁2 ▁* ▁node ▁, ▁l ▁, ▁mid ▁, ▁a ▁) ▁; ▁build ▁( ▁2 ▁* ▁node ▁+ ▁1 ▁, ▁mid ▁+ ▁1 ▁, ▁r ▁, ▁a ▁) ▁; ▁seg ▁[ ▁node ▁] ▁= ▁( ▁seg ▁[ ▁2 ▁* ▁node ▁] ▁seg ▁[ ▁2 ▁* ▁node ▁+ ▁1 ▁] ▁) ▁; ▁} ▁} ▁int ▁query ▁( ▁int ▁node ▁, ▁int ▁l ▁, ▁int ▁r ▁, ▁int ▁start ▁, ▁int ▁end ▁, ▁int ▁a ▁[ ▁] ▁) ▁{ ▁if ▁( ▁l ▁> ▁end ▁or ▁r ▁< ▁start ▁) ▁return ▁0 ▁; ▁if ▁( ▁start ▁<= ▁l ▁and ▁r ▁<= ▁end ▁) ▁return ▁seg ▁[ ▁node ▁] ▁; ▁int ▁mid ▁= ▁( ▁l ▁+ ▁r ▁) ▁/ ▁2 ▁; ▁return ▁( ▁( ▁query ▁( ▁2 ▁* ▁node ▁, ▁l ▁, ▁mid ▁, ▁start ▁, ▁end ▁, ▁a ▁) ▁) ▁| ▁( ▁query ▁( ▁2 ▁* ▁node ▁+ ▁1 ▁, ▁mid ▁+ ▁1 ▁, ▁r ▁, ▁start ▁, ▁end ▁, ▁a ▁) ▁) ▁) ▁; ▁} ▁void ▁or sum ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁q ▁, ▁int ▁k ▁[ ▁] ▁) ▁{ ▁build ▁( ▁1 ▁, ▁0 ▁, ▁n ▁- ▁1 ▁, ▁a ▁) ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁q ▁; ▁j ▁++ ▁) ▁{ ▁int ▁i ▁= ▁k ▁[ ▁j ▁] ▁% ▁( ▁n ▁/ ▁2 ▁) ▁; ▁int ▁sec ▁= ▁query ▁( ▁1 ▁, ▁0 ▁, ▁n ▁- ▁1 ▁, ▁n ▁/ ▁2 ▁- ▁i ▁, ▁n ▁- ▁i ▁- ▁1 ▁, ▁a ▁) ▁; ▁int ▁first ▁= ▁( ▁query ▁( ▁1 ▁, ▁0 ▁, ▁n ▁- ▁1 ▁, ▁0 ▁, ▁n ▁/ ▁2 ▁- ▁1 ▁- ▁i ▁, ▁a ▁) ▁| ▁query ▁( ▁1 ▁, ▁0 ▁, ▁n ▁- ▁1 ▁, ▁n ▁- ▁i ▁, ▁n ▁- ▁1 ▁, ▁a ▁) ▁) ▁; ▁int ▁temp ▁= ▁sec ▁+ ▁first ▁; ▁c out ▁<< ▁temp ▁<< ▁end l ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁7 ▁, ▁44 ▁, ▁19 ▁, ▁86 ▁, ▁65 ▁, ▁39 ▁, ▁75 ▁, ▁101 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁int ▁q ▁= ▁2 ▁; ▁int ▁k ▁[ ▁q ▁] ▁= ▁{ ▁4 ▁, ▁2 ▁} ▁; ▁or sum ▁( ▁a ▁, ▁n ▁, ▁q ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁maximum Equal ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁b ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁vector ▁< ▁int ▁> ▁store ▁( ▁1 e 5 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁store ▁[ ▁b ▁[ ▁i ▁] ▁] ▁= ▁i ▁+ ▁1 ▁; ▁} ▁vector ▁< ▁int ▁> ▁ans ▁( ▁1 e 5 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁d ▁= ▁abs ▁( ▁store ▁[ ▁a ▁[ ▁i ▁] ▁] ▁- ▁( ▁i ▁+ ▁1 ▁) ▁) ▁; ▁if ▁( ▁store ▁[ ▁a ▁[ ▁i ▁] ▁] ▁< ▁i ▁+ ▁1 ▁) ▁{ ▁d ▁= ▁n ▁- ▁d ▁; ▁} ▁ans ▁[ ▁d ▁] ▁++ ▁; ▁} ▁int ▁final ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁1 e 5 ▁; ▁i ▁++ ▁) ▁final ans ▁= ▁max ▁( ▁final ans ▁, ▁ans ▁[ ▁i ▁] ▁) ▁; ▁c out ▁<< ▁final ans ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁6 ▁, ▁7 ▁, ▁3 ▁, ▁9 ▁, ▁5 ▁} ▁; ▁int ▁B ▁[ ▁] ▁= ▁{ ▁7 ▁, ▁3 ▁, ▁9 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁int ▁size ▁= ▁sizeof ▁( ▁A ▁) ▁/ ▁sizeof ▁( ▁A ▁[ ▁0 ▁] ▁) ▁; ▁maximum Equal ▁( ▁A ▁, ▁B ▁, ▁size ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Rotation ▁( ▁int ▁n ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁do ▁{ ▁int ▁digit ▁= ▁n ▁% ▁10 ▁; ▁if ▁( ▁digit ▁== ▁0 ▁) ▁count ▁++ ▁; ▁n ▁= ▁n ▁/ ▁10 ▁; ▁} ▁while ▁( ▁n ▁!= ▁0 ▁) ▁; ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁10 203 ▁; ▁c out ▁<< ▁count Rotation ▁( ▁n ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁isP ossible ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁<= ▁2 ▁) ▁return ▁true ▁; ▁int ▁flag ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁! ▁( ▁a ▁[ ▁i ▁] ▁> ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁and ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁> ▁a ▁[ ▁i ▁+ ▁2 ▁] ▁) ▁) ▁{ ▁flag ▁= ▁1 ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁flag ▁== ▁0 ▁) ▁return ▁true ▁; ▁flag ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁! ▁( ▁a ▁[ ▁i ▁] ▁< ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁and ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁< ▁a ▁[ ▁i ▁+ ▁2 ▁] ▁) ▁) ▁{ ▁flag ▁= ▁1 ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁flag ▁== ▁0 ▁) ▁return ▁true ▁; ▁int ▁val 1 ▁= ▁INT _ MAX ▁, ▁mini ▁= ▁-1 ▁, ▁val 2 ▁= ▁INT _ MIN ▁, ▁max i ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁< ▁val 1 ▁) ▁{ ▁mini ▁= ▁i ▁; ▁val 1 ▁= ▁a ▁[ ▁i ▁] ▁; ▁} ▁if ▁( ▁a ▁[ ▁i ▁] ▁> ▁val 2 ▁) ▁{ ▁max i ▁= ▁i ▁; ▁val 2 ▁= ▁a ▁[ ▁i ▁] ▁; ▁} ▁} ▁flag ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁max i ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁> ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁{ ▁flag ▁= ▁0 ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁flag ▁== ▁1 ▁and ▁max i ▁+ ▁1 ▁== ▁mini ▁) ▁{ ▁flag ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁mini ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁> ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁{ ▁flag ▁= ▁0 ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁flag ▁== ▁1 ▁) ▁return ▁true ▁; ▁} ▁flag ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁mini ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁< ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁{ ▁flag ▁= ▁0 ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁flag ▁== ▁1 ▁and ▁max i ▁- ▁1 ▁== ▁mini ▁) ▁{ ▁flag ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁max i ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁< ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁{ ▁flag ▁= ▁0 ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁flag ▁== ▁1 ▁) ▁return ▁true ▁; ▁} ▁return ▁false ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁5 ▁, ▁6 ▁, ▁2 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁if ▁( ▁isP ossible ▁( ▁a ▁, ▁n ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁numberOf Digits ▁( ▁int ▁n ▁) ▁{ ▁int ▁cnt ▁= ▁0 ▁; ▁while ▁( ▁n ▁> ▁0 ▁) ▁{ ▁cnt ▁++ ▁; ▁n ▁/= ▁10 ▁; ▁} ▁return ▁cnt ▁; ▁} ▁void ▁cal ▁( ▁int ▁num ▁) ▁{ ▁int ▁digits ▁= ▁numberOf Digits ▁( ▁num ▁) ▁; ▁int ▁pow Ten ▁= ▁pow ▁( ▁10 ▁, ▁digits ▁- ▁1 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁digits ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁int ▁first Digit ▁= ▁num ▁/ ▁pow Ten ▁; ▁int ▁left ▁= ▁( ▁( ▁num ▁* ▁10 ▁) ▁+ ▁first Digit ▁) ▁- ▁( ▁first Digit ▁* ▁pow Ten ▁* ▁10 ▁) ▁; ▁c out ▁<< ▁left ▁<< ▁" ▁" ▁; ▁num ▁= ▁left ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁num ▁= ▁14 45 ▁; ▁cal ▁( ▁num ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁Check K C ycles ▁( ▁int ▁n ▁, ▁string ▁s ▁) ▁{ ▁bool ▁ff ▁= ▁true ▁; ▁int ▁x ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁x ▁= ▁( ▁s ▁. ▁substr ▁( ▁i ▁) ▁+ ▁s ▁. ▁substr ▁( ▁0 ▁, ▁i ▁) ▁) ▁. ▁length ▁( ▁) ▁; ▁if ▁( ▁x ▁>= ▁s ▁. ▁length ▁( ▁) ▁) ▁{ ▁continue ▁; ▁} ▁ff ▁= ▁false ▁; ▁break ▁; ▁} ▁if ▁( ▁ff ▁) ▁{ ▁c out ▁<< ▁( ▁" ▁Yes ▁" ▁) ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁( ▁" ▁No ▁" ▁) ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁3 ▁; ▁string ▁s ▁= ▁"123" ▁; ▁Check K C ycles ▁( ▁n ▁, ▁s ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁generate Numbers ▁( ▁int ▁m ▁) ▁{ ▁vector ▁< ▁int ▁> ▁numbers ▁; ▁int ▁k _ max ▁, ▁x ▁; ▁for ▁( ▁int ▁y ▁= ▁0 ▁; ▁y ▁< ▁10 ▁; ▁y ▁++ ▁) ▁{ ▁k _ max ▁= ▁( ▁int ▁) ▁( ▁pow ▁( ▁10 ▁, ▁m ▁- ▁2 ▁) ▁* ▁( ▁10 ▁* ▁y ▁+ ▁1 ▁) ▁) ▁/ ▁( ▁int ▁) ▁( ▁pow ▁( ▁10 ▁, ▁m ▁- ▁1 ▁) ▁+ ▁y ▁) ▁; ▁for ▁( ▁int ▁k ▁= ▁1 ▁; ▁k ▁<= ▁k _ max ▁; ▁k ▁++ ▁) ▁{ ▁x ▁= ▁( ▁int ▁) ▁( ▁y ▁* ▁( ▁pow ▁( ▁10 ▁, ▁m ▁- ▁1 ▁) ▁- ▁k ▁) ▁) ▁/ ▁( ▁10 ▁* ▁k ▁- ▁1 ▁) ▁; ▁if ▁( ▁( ▁int ▁) ▁( ▁y ▁* ▁( ▁pow ▁( ▁10 ▁, ▁m ▁- ▁1 ▁) ▁- ▁k ▁) ▁) ▁% ▁( ▁10 ▁* ▁k ▁- ▁1 ▁) ▁== ▁0 ▁) ▁numbers ▁. ▁push _ back ▁( ▁10 ▁* ▁x ▁+ ▁y ▁) ▁; ▁} ▁} ▁sort ▁( ▁numbers ▁. ▁begin ▁( ▁) ▁, ▁numbers ▁. ▁end ▁( ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁numbers ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁( ▁numbers ▁[ ▁i ▁] ▁) ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁m ▁= ▁3 ▁; ▁generate Numbers ▁( ▁m ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁N ▁4 ▁NEW _ LINE ▁void ▁rotate 90 Clock wise ▁( ▁int ▁arr ▁[ ▁N ▁] ▁[ ▁N ▁] ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁N ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁[ ▁j ▁] ▁<< ▁" ▁" ▁; ▁c out ▁<< ▁' ▁' ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁N ▁] ▁[ ▁N ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁, ▁{ ▁5 ▁, ▁6 ▁, ▁7 ▁, ▁8 ▁} ▁, ▁{ ▁9 ▁, ▁10 ▁, ▁11 ▁, ▁12 ▁} ▁, ▁{ ▁13 ▁, ▁14 ▁, ▁15 ▁, ▁16 ▁} ▁} ▁; ▁rotate 90 Clock wise ▁( ▁arr ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Start IndexOf Array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁low ▁, ▁int ▁high ▁) ▁{ ▁if ▁( ▁low ▁> ▁high ▁) ▁{ ▁return ▁-1 ▁; ▁} ▁if ▁( ▁low ▁== ▁high ▁) ▁{ ▁return ▁low ▁; ▁} ▁int ▁mid ▁= ▁low ▁+ ▁( ▁high ▁- ▁low ▁) ▁/ ▁2 ▁; ▁if ▁( ▁arr ▁[ ▁mid ▁] ▁> ▁arr ▁[ ▁mid ▁+ ▁1 ▁] ▁) ▁return ▁mid ▁+ ▁1 ▁; ▁if ▁( ▁arr ▁[ ▁mid ▁- ▁1 ▁] ▁> ▁arr ▁[ ▁mid ▁] ▁) ▁return ▁mid ▁; ▁if ▁( ▁arr ▁[ ▁low ▁] ▁> ▁arr ▁[ ▁mid ▁] ▁) ▁return ▁find Start IndexOf Array ▁( ▁arr ▁, ▁low ▁, ▁mid ▁- ▁1 ▁) ▁; ▁else ▁return ▁find Start IndexOf Array ▁( ▁arr ▁, ▁mid ▁+ ▁1 ▁, ▁high ▁) ▁; ▁} ▁void ▁restore Sorted Array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁0 ▁] ▁< ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁) ▁return ▁; ▁int ▁start ▁= ▁find Start IndexOf Array ▁( ▁arr ▁, ▁0 ▁, ▁n ▁- ▁1 ▁) ▁; ▁reverse ▁( ▁arr ▁, ▁arr ▁+ ▁start ▁) ▁; ▁reverse ▁( ▁arr ▁+ ▁start ▁, ▁arr ▁+ ▁n ▁) ▁; ▁reverse ▁( ▁arr ▁, ▁arr ▁+ ▁n ▁) ▁; ▁} ▁void ▁print Array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁size ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁restore Sorted Array ▁( ▁arr ▁, ▁n ▁) ▁; ▁print Array ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁class ▁Node ▁{ ▁public ▁: ▁int ▁data ▁; ▁Node ▁* ▁next ▁; ▁} ▁;
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁struct ▁Node ▁{ ▁int ▁data ▁; ▁struct ▁Node ▁* ▁next ▁; ▁} ▁; ▁void ▁push ▁( ▁struct ▁Node ▁* ▁* ▁head _ ref ▁, ▁int ▁data ▁) ▁{ ▁struct ▁Node ▁* ▁ptr 1 ▁= ▁( ▁struct ▁Node ▁* ▁) ▁m alloc ▁( ▁sizeof ▁( ▁struct ▁Node ▁) ▁) ▁; ▁struct ▁Node ▁* ▁temp ▁= ▁* ▁head _ ref ▁; ▁ptr 1 ▁-> ▁data ▁= ▁data ▁; ▁ptr 1 ▁-> ▁next ▁= ▁* ▁head _ ref ▁; ▁if ▁( ▁* ▁head _ ref ▁!= ▁NULL ▁) ▁{ ▁while ▁( ▁temp ▁-> ▁next ▁!= ▁* ▁head _ ref ▁) ▁temp ▁= ▁temp ▁-> ▁next ▁; ▁temp ▁-> ▁next ▁= ▁ptr 1 ▁; ▁} ▁else ▁ptr 1 ▁-> ▁next ▁= ▁ptr 1 ▁; ▁* ▁head _ ref ▁= ▁ptr 1 ▁; ▁} ▁void ▁delete Node ▁( ▁Node ▁* ▁& ▁head _ ref ▁, ▁Node ▁* ▁del ▁) ▁{ ▁if ▁( ▁head _ ref ▁== ▁del ▁) ▁head _ ref ▁= ▁del ▁-> ▁next ▁; ▁struct ▁Node ▁* ▁temp ▁= ▁head _ ref ▁; ▁while ▁( ▁temp ▁-> ▁next ▁!= ▁del ▁) ▁{ ▁temp ▁= ▁temp ▁-> ▁next ▁; ▁} ▁temp ▁-> ▁next ▁= ▁del ▁-> ▁next ▁; ▁free ▁( ▁del ▁) ▁; ▁return ▁; ▁} ▁bool ▁is Even Par ity ▁( ▁int ▁x ▁) ▁{ ▁int ▁par ity ▁= ▁0 ▁; ▁while ▁( ▁x ▁!= ▁0 ▁) ▁{ ▁if ▁( ▁x ▁& ▁1 ▁) ▁par ity ▁++ ▁; ▁x ▁= ▁x ▁>> ▁1 ▁; ▁} ▁if ▁( ▁par ity ▁% ▁2 ▁== ▁0 ▁) ▁return ▁true ▁; ▁else ▁return ▁false ▁; ▁} ▁void ▁delete Even Par ity Nodes ▁( ▁Node ▁* ▁& ▁head ▁) ▁{ ▁if ▁( ▁head ▁== ▁NULL ▁) ▁return ▁; ▁if ▁( ▁head ▁== ▁head ▁-> ▁next ▁) ▁{ ▁if ▁( ▁is Even Par ity ▁( ▁head ▁-> ▁data ▁) ▁) ▁head ▁= ▁NULL ▁; ▁return ▁; ▁} ▁struct ▁Node ▁* ▁ptr ▁= ▁head ▁; ▁struct ▁Node ▁* ▁next ▁; ▁do ▁{ ▁next ▁= ▁ptr ▁-> ▁next ▁; ▁if ▁( ▁is Even Par ity ▁( ▁ptr ▁-> ▁data ▁) ▁) ▁delete Node ▁( ▁head ▁, ▁ptr ▁) ▁; ▁ptr ▁= ▁next ▁; ▁} ▁while ▁( ▁ptr ▁!= ▁head ▁) ▁; ▁if ▁( ▁head ▁== ▁head ▁-> ▁next ▁) ▁{ ▁if ▁( ▁is Even Par ity ▁( ▁head ▁-> ▁data ▁) ▁) ▁head ▁= ▁NULL ▁; ▁return ▁; ▁} ▁} ▁void ▁print List ▁( ▁struct ▁Node ▁* ▁head ▁) ▁{ ▁if ▁( ▁head ▁== ▁NULL ▁) ▁{ ▁c out ▁<< ▁" ▁Empty ▁List ▁STRNEWLINE ▁" ▁; ▁return ▁; ▁} ▁struct ▁Node ▁* ▁temp ▁= ▁head ▁; ▁if ▁( ▁head ▁!= ▁NULL ▁) ▁{ ▁do ▁{ ▁printf ▁( ▁" ▁% ▁d ▁" ▁, ▁temp ▁-> ▁data ▁) ▁; ▁temp ▁= ▁temp ▁-> ▁next ▁; ▁} ▁while ▁( ▁temp ▁!= ▁head ▁) ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁struct ▁Node ▁* ▁head ▁= ▁NULL ▁; ▁push ▁( ▁& ▁head ▁, ▁21 ▁) ▁; ▁push ▁( ▁& ▁head ▁, ▁13 ▁) ▁; ▁push ▁( ▁& ▁head ▁, ▁6 ▁) ▁; ▁push ▁( ▁& ▁head ▁, ▁34 ▁) ▁; ▁push ▁( ▁& ▁head ▁, ▁9 ▁) ▁; ▁push ▁( ▁& ▁head ▁, ▁11 ▁) ▁; ▁delete Even Par ity Nodes ▁( ▁head ▁) ▁; ▁print List ▁( ▁head ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁struct ▁Node ▁{ ▁int ▁data ▁; ▁struct ▁Node ▁* ▁next ▁; ▁} ▁; ▁void ▁push ▁( ▁struct ▁Node ▁* ▁* ▁head _ ref ▁, ▁int ▁data ▁) ▁{ ▁struct ▁Node ▁* ▁ptr 1 ▁= ▁( ▁struct ▁Node ▁* ▁) ▁m alloc ▁( ▁sizeof ▁( ▁struct ▁Node ▁) ▁) ▁; ▁struct ▁Node ▁* ▁temp ▁= ▁* ▁head _ ref ▁; ▁ptr 1 ▁-> ▁data ▁= ▁data ▁; ▁ptr 1 ▁-> ▁next ▁= ▁* ▁head _ ref ▁; ▁if ▁( ▁* ▁head _ ref ▁!= ▁NULL ▁) ▁{ ▁while ▁( ▁temp ▁-> ▁next ▁!= ▁* ▁head _ ref ▁) ▁temp ▁= ▁temp ▁-> ▁next ▁; ▁temp ▁-> ▁next ▁= ▁ptr 1 ▁; ▁} ▁else ▁ptr 1 ▁-> ▁next ▁= ▁ptr 1 ▁; ▁* ▁head _ ref ▁= ▁ptr 1 ▁; ▁} ▁void ▁delete Node ▁( ▁Node ▁* ▁head _ ref ▁, ▁Node ▁* ▁del ▁) ▁{ ▁struct ▁Node ▁* ▁temp ▁= ▁head _ ref ▁; ▁if ▁( ▁head _ ref ▁== ▁del ▁) ▁head _ ref ▁= ▁del ▁-> ▁next ▁; ▁while ▁( ▁temp ▁-> ▁next ▁!= ▁del ▁) ▁{ ▁temp ▁= ▁temp ▁-> ▁next ▁; ▁} ▁temp ▁-> ▁next ▁= ▁del ▁-> ▁next ▁; ▁free ▁( ▁del ▁) ▁; ▁return ▁; ▁} ▁int ▁digit Sum ▁( ▁int ▁num ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁while ▁( ▁num ▁) ▁{ ▁sum ▁+= ▁( ▁num ▁% ▁10 ▁) ▁; ▁num ▁/= ▁10 ▁; ▁} ▁return ▁sum ▁; ▁} ▁void ▁delete Even Digit Sum Nodes ▁( ▁Node ▁* ▁head ▁) ▁{ ▁struct ▁Node ▁* ▁ptr ▁= ▁head ▁; ▁struct ▁Node ▁* ▁next ▁; ▁do ▁{ ▁if ▁( ▁! ▁( ▁digit Sum ▁( ▁ptr ▁-> ▁data ▁) ▁& ▁1 ▁) ▁) ▁delete Node ▁( ▁head ▁, ▁ptr ▁) ▁; ▁next ▁= ▁ptr ▁-> ▁next ▁; ▁ptr ▁= ▁next ▁; ▁} ▁while ▁( ▁ptr ▁!= ▁head ▁) ▁; ▁} ▁void ▁print List ▁( ▁struct ▁Node ▁* ▁head ▁) ▁{ ▁struct ▁Node ▁* ▁temp ▁= ▁head ▁; ▁if ▁( ▁head ▁!= ▁NULL ▁) ▁{ ▁do ▁{ ▁printf ▁( ▁" ▁% ▁d ▁" ▁, ▁temp ▁-> ▁data ▁) ▁; ▁temp ▁= ▁temp ▁-> ▁next ▁; ▁} ▁while ▁( ▁temp ▁!= ▁head ▁) ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁struct ▁Node ▁* ▁head ▁= ▁NULL ▁; ▁push ▁( ▁& ▁head ▁, ▁21 ▁) ▁; ▁push ▁( ▁& ▁head ▁, ▁13 ▁) ▁; ▁push ▁( ▁& ▁head ▁, ▁6 ▁) ▁; ▁push ▁( ▁& ▁head ▁, ▁34 ▁) ▁; ▁push ▁( ▁& ▁head ▁, ▁11 ▁) ▁; ▁push ▁( ▁& ▁head ▁, ▁9 ▁) ▁; ▁delete Even Digit Sum Nodes ▁( ▁head ▁) ▁; ▁print List ▁( ▁head ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁struct ▁Node ▁{ ▁int ▁data ▁; ▁struct ▁Node ▁* ▁next ▁; ▁struct ▁Node ▁* ▁prev ▁; ▁} ▁; ▁void ▁insert Node ▁( ▁struct ▁Node ▁* ▁* ▁start ▁, ▁int ▁value ▁) ▁{ ▁if ▁( ▁* ▁start ▁== ▁NULL ▁) ▁{ ▁struct ▁Node ▁* ▁new _ node ▁= ▁new ▁Node ▁; ▁new _ node ▁-> ▁data ▁= ▁value ▁; ▁new _ node ▁-> ▁next ▁= ▁new _ node ▁-> ▁prev ▁= ▁new _ node ▁; ▁* ▁start ▁= ▁new _ node ▁; ▁return ▁; ▁} ▁Node ▁* ▁last ▁= ▁( ▁* ▁start ▁) ▁-> ▁prev ▁; ▁struct ▁Node ▁* ▁new _ node ▁= ▁new ▁Node ▁; ▁new _ node ▁-> ▁data ▁= ▁value ▁; ▁new _ node ▁-> ▁next ▁= ▁* ▁start ▁; ▁( ▁* ▁start ▁) ▁-> ▁prev ▁= ▁new _ node ▁; ▁new _ node ▁-> ▁prev ▁= ▁last ▁; ▁last ▁-> ▁next ▁= ▁new _ node ▁; ▁} ▁void ▁display List ▁( ▁struct ▁Node ▁* ▁start ▁) ▁{ ▁struct ▁Node ▁* ▁temp ▁= ▁start ▁; ▁while ▁( ▁temp ▁-> ▁next ▁!= ▁start ▁) ▁{ ▁printf ▁( ▁" ▁% ▁d ▁" ▁, ▁temp ▁-> ▁data ▁) ▁; ▁temp ▁= ▁temp ▁-> ▁next ▁; ▁} ▁printf ▁( ▁" ▁% ▁d ▁" ▁, ▁temp ▁-> ▁data ▁) ▁; ▁} ▁int ▁search List ▁( ▁struct ▁Node ▁* ▁start ▁, ▁int ▁search ▁) ▁{ ▁struct ▁Node ▁* ▁temp ▁= ▁start ▁; ▁int ▁count ▁= ▁0 ▁, ▁flag ▁= ▁0 ▁, ▁value ▁; ▁if ▁( ▁temp ▁== ▁NULL ▁) ▁return ▁-1 ▁; ▁else ▁{ ▁while ▁( ▁temp ▁-> ▁next ▁!= ▁start ▁) ▁{ ▁count ▁++ ▁; ▁if ▁( ▁temp ▁-> ▁data ▁== ▁search ▁) ▁{ ▁flag ▁= ▁1 ▁; ▁count ▁-- ▁; ▁break ▁; ▁} ▁temp ▁= ▁temp ▁-> ▁next ▁; ▁} ▁if ▁( ▁temp ▁-> ▁data ▁== ▁search ▁) ▁{ ▁count ▁++ ▁; ▁flag ▁= ▁1 ▁; ▁} ▁if ▁( ▁flag ▁== ▁1 ▁) ▁c out ▁<< ▁" ▁STRNEWLINE ▁" ▁<< ▁search ▁<< ▁" ▁found ▁at ▁location ▁" ▁<< ▁count ▁<< ▁end l ▁; ▁else ▁c out ▁<< ▁" ▁STRNEWLINE ▁" ▁<< ▁search ▁<< ▁" ▁not ▁found ▁" ▁<< ▁end l ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁struct ▁Node ▁* ▁start ▁= ▁NULL ▁; ▁insert Node ▁( ▁& ▁start ▁, ▁4 ▁) ▁; ▁insert Node ▁( ▁& ▁start ▁, ▁5 ▁) ▁; ▁insert Node ▁( ▁& ▁start ▁, ▁7 ▁) ▁; ▁insert Node ▁( ▁& ▁start ▁, ▁8 ▁) ▁; ▁insert Node ▁( ▁& ▁start ▁, ▁6 ▁) ▁; ▁printf ▁( ▁" ▁Created ▁circular ▁doub ly ▁linked ▁list ▁is ▁: ▁" ▁) ▁; ▁display List ▁( ▁start ▁) ▁; ▁search List ▁( ▁start ▁, ▁5 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁MAX ▁1000 ▁NEW _ LINE ▁int ▁weight ▁[ ▁MAX ▁] ▁; ▁int ▁level ▁[ ▁MAX ▁] ▁; ▁int ▁par ▁[ ▁MAX ▁] ▁; ▁bool ▁prime ▁[ ▁MAX ▁+ ▁1 ▁] ▁; ▁vector ▁< ▁int ▁> ▁graph ▁[ ▁MAX ▁] ▁; ▁void ▁S ieve Of E rat ost hen es ▁( ▁) ▁{ ▁mem set ▁( ▁prime ▁, ▁true ▁, ▁sizeof ▁( ▁prime ▁) ▁) ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁* ▁p ▁<= ▁MAX ▁; ▁p ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁p ▁] ▁== ▁true ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁p ▁* ▁p ▁; ▁i ▁<= ▁MAX ▁; ▁i ▁+= ▁p ▁) ▁prime ▁[ ▁i ▁] ▁= ▁false ▁; ▁} ▁} ▁} ▁void ▁dfs ▁( ▁int ▁node ▁, ▁int ▁parent ▁, ▁int ▁h ▁) ▁{ ▁par ▁[ ▁node ▁] ▁= ▁parent ▁; ▁level ▁[ ▁node ▁] ▁= ▁h ▁; ▁for ▁( ▁int ▁child ▁: ▁graph ▁[ ▁node ▁] ▁) ▁{ ▁if ▁( ▁child ▁== ▁parent ▁) ▁continue ▁; ▁dfs ▁( ▁child ▁, ▁node ▁, ▁h ▁+ ▁1 ▁) ▁; ▁} ▁} ▁int ▁find Prime On Path ▁( ▁int ▁u ▁, ▁int ▁v ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁if ▁( ▁level ▁[ ▁u ▁] ▁> ▁level ▁[ ▁v ▁] ▁) ▁swap ▁( ▁u ▁, ▁v ▁) ▁; ▁int ▁d ▁= ▁level ▁[ ▁v ▁] ▁- ▁level ▁[ ▁u ▁] ▁; ▁while ▁( ▁d ▁-- ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁weight ▁[ ▁v ▁] ▁] ▁) ▁count ▁++ ▁; ▁v ▁= ▁par ▁[ ▁v ▁] ▁; ▁} ▁if ▁( ▁v ▁== ▁u ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁weight ▁[ ▁v ▁] ▁] ▁) ▁count ▁++ ▁; ▁return ▁count ▁; ▁} ▁while ▁( ▁v ▁!= ▁u ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁weight ▁[ ▁v ▁] ▁] ▁) ▁count ▁++ ▁; ▁if ▁( ▁prime ▁[ ▁weight ▁[ ▁u ▁] ▁] ▁) ▁count ▁++ ▁; ▁u ▁= ▁par ▁[ ▁u ▁] ▁; ▁v ▁= ▁par ▁[ ▁v ▁] ▁; ▁} ▁if ▁( ▁prime ▁[ ▁weight ▁[ ▁v ▁] ▁] ▁) ▁count ▁++ ▁; ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁S ieve Of E rat ost hen es ▁( ▁) ▁; ▁weight ▁[ ▁1 ▁] ▁= ▁5 ▁; ▁weight ▁[ ▁2 ▁] ▁= ▁10 ▁; ▁weight ▁[ ▁3 ▁] ▁= ▁11 ▁; ▁weight ▁[ ▁4 ▁] ▁= ▁8 ▁; ▁weight ▁[ ▁5 ▁] ▁= ▁6 ▁; ▁graph ▁[ ▁1 ▁] ▁. ▁push _ back ▁( ▁2 ▁) ▁; ▁graph ▁[ ▁2 ▁] ▁. ▁push _ back ▁( ▁3 ▁) ▁; ▁graph ▁[ ▁2 ▁] ▁. ▁push _ back ▁( ▁4 ▁) ▁; ▁graph ▁[ ▁1 ▁] ▁. ▁push _ back ▁( ▁5 ▁) ▁; ▁dfs ▁( ▁1 ▁, ▁-1 ▁, ▁0 ▁) ▁; ▁int ▁u ▁= ▁3 ▁, ▁v ▁= ▁5 ▁; ▁c out ▁<< ▁find Prime On Path ▁( ▁u ▁, ▁v ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁struct ▁Node ▁{ ▁Node ▁* ▁left ▁; ▁Node ▁* ▁right ▁; ▁int ▁data ▁; ▁} ▁; ▁Node ▁* ▁newNode ▁( ▁int ▁key ▁) ▁{ ▁Node ▁* ▁node ▁= ▁new ▁Node ▁( ▁) ▁; ▁node ▁-> ▁left ▁= ▁node ▁-> ▁right ▁= ▁NULL ▁; ▁node ▁-> ▁data ▁= ▁key ▁; ▁return ▁node ▁; ▁} ▁bool ▁Find Path ▁( ▁Node ▁* ▁root ▁, ▁vector ▁< ▁int ▁> ▁& ▁path ▁, ▁int ▁key ▁) ▁{ ▁if ▁( ▁root ▁== ▁NULL ▁) ▁return ▁false ▁; ▁path ▁. ▁push _ back ▁( ▁root ▁-> ▁data ▁) ▁; ▁if ▁( ▁root ▁-> ▁data ▁== ▁key ▁) ▁return ▁true ▁; ▁if ▁( ▁Find Path ▁( ▁root ▁-> ▁left ▁, ▁path ▁, ▁key ▁) ▁|| ▁Find Path ▁( ▁root ▁-> ▁right ▁, ▁path ▁, ▁key ▁) ▁) ▁return ▁true ▁; ▁path ▁. ▁pop _ back ▁( ▁) ▁; ▁return ▁false ▁; ▁} ▁int ▁min Max Node In Path ▁( ▁Node ▁* ▁root ▁, ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁vector ▁< ▁int ▁> ▁Path 1 ▁; ▁vector ▁< ▁int ▁> ▁Path 2 ▁; ▁int ▁min 1 ▁= ▁INT _ MAX ▁; ▁int ▁max 1 ▁= ▁INT _ MIN ▁; ▁int ▁min 2 ▁= ▁INT _ MAX ▁; ▁int ▁max 2 ▁= ▁INT _ MIN ▁; ▁int ▁i ▁= ▁0 ▁; ▁int ▁j ▁= ▁0 ▁; ▁if ▁( ▁Find Path ▁( ▁root ▁, ▁Path 1 ▁, ▁a ▁) ▁&& ▁Find Path ▁( ▁root ▁, ▁Path 2 ▁, ▁b ▁) ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁Path 1 ▁. ▁size ▁( ▁) ▁&& ▁Path 2 ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁if ▁( ▁Path 1 ▁[ ▁i ▁] ▁!= ▁Path 2 ▁[ ▁i ▁] ▁) ▁break ▁; ▁i ▁-- ▁; ▁j ▁= ▁i ▁; ▁for ▁( ▁; ▁i ▁< ▁Path 1 ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁min 1 ▁> ▁Path 1 ▁[ ▁i ▁] ▁) ▁min 1 ▁= ▁Path 1 ▁[ ▁i ▁] ▁; ▁if ▁( ▁max 1 ▁< ▁Path 1 ▁[ ▁i ▁] ▁) ▁max 1 ▁= ▁Path 1 ▁[ ▁i ▁] ▁; ▁} ▁for ▁( ▁; ▁j ▁< ▁Path 2 ▁. ▁size ▁( ▁) ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁min 2 ▁> ▁Path 2 ▁[ ▁j ▁] ▁) ▁min 2 ▁= ▁Path 2 ▁[ ▁j ▁] ▁; ▁if ▁( ▁max 2 ▁< ▁Path 2 ▁[ ▁j ▁] ▁) ▁max 2 ▁= ▁Path 2 ▁[ ▁j ▁] ▁; ▁} ▁c out ▁<< ▁" ▁Min ▁= ▁" ▁<< ▁min ▁( ▁min 1 ▁, ▁min 2 ▁) ▁<< ▁end l ▁; ▁c out ▁<< ▁" ▁Max ▁= ▁" ▁<< ▁max ▁( ▁max 1 ▁, ▁max 2 ▁) ▁; ▁} ▁else ▁c out ▁<< ▁" ▁Max ▁= ▁-1 ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁Node ▁* ▁root ▁= ▁newNode ▁( ▁20 ▁) ▁; ▁root ▁-> ▁left ▁= ▁newNode ▁( ▁8 ▁) ▁; ▁root ▁-> ▁right ▁= ▁newNode ▁( ▁22 ▁) ▁; ▁root ▁-> ▁left ▁-> ▁left ▁= ▁newNode ▁( ▁5 ▁) ▁; ▁root ▁-> ▁left ▁-> ▁right ▁= ▁newNode ▁( ▁3 ▁) ▁; ▁root ▁-> ▁right ▁-> ▁left ▁= ▁newNode ▁( ▁4 ▁) ▁; ▁root ▁-> ▁right ▁-> ▁right ▁= ▁newNode ▁( ▁25 ▁) ▁; ▁root ▁-> ▁left ▁-> ▁right ▁-> ▁left ▁= ▁newNode ▁( ▁10 ▁) ▁; ▁root ▁-> ▁left ▁-> ▁right ▁-> ▁right ▁= ▁newNode ▁( ▁14 ▁) ▁; ▁int ▁a ▁= ▁5 ▁; ▁int ▁b ▁= ▁145 4 ▁; ▁min Max Node In Path ▁( ▁root ▁, ▁a ▁, ▁b ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁MAX N ▁10000 1 ▁NEW _ LINE ▁vector ▁< ▁int ▁> ▁tree ▁[ ▁MAX N ▁] ▁; ▁int ▁path ▁[ ▁3 ▁] ▁[ ▁MAX N ▁] ▁; ▁void ▁dfs ▁( ▁int ▁cur ▁, ▁int ▁prev ▁, ▁int ▁path Number ▁, ▁int ▁ptr ▁, ▁int ▁node ▁, ▁bool ▁& ▁flag ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁tree ▁[ ▁cur ▁] ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁tree ▁[ ▁cur ▁] ▁[ ▁i ▁] ▁!= ▁prev ▁and ▁! ▁flag ▁) ▁{ ▁path ▁[ ▁path Number ▁] ▁[ ▁ptr ▁] ▁= ▁tree ▁[ ▁cur ▁] ▁[ ▁i ▁] ▁; ▁if ▁( ▁tree ▁[ ▁cur ▁] ▁[ ▁i ▁] ▁== ▁node ▁) ▁{ ▁flag ▁= ▁true ▁; ▁path ▁[ ▁path Number ▁] ▁[ ▁ptr ▁+ ▁1 ▁] ▁= ▁-1 ▁; ▁return ▁; ▁} ▁dfs ▁( ▁tree ▁[ ▁cur ▁] ▁[ ▁i ▁] ▁, ▁cur ▁, ▁path Number ▁, ▁ptr ▁+ ▁1 ▁, ▁node ▁, ▁flag ▁) ▁; ▁} ▁} ▁} ▁int ▁L CA ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁if ▁( ▁a ▁== ▁b ▁) ▁return ▁a ▁; ▁path ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁= ▁path ▁[ ▁2 ▁] ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁bool ▁flag ▁= ▁false ▁; ▁dfs ▁( ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁a ▁, ▁flag ▁) ▁; ▁flag ▁= ▁false ▁; ▁dfs ▁( ▁1 ▁, ▁0 ▁, ▁2 ▁, ▁1 ▁, ▁b ▁, ▁flag ▁) ▁; ▁int ▁i ▁= ▁0 ▁; ▁while ▁( ▁path ▁[ ▁1 ▁] ▁[ ▁i ▁] ▁== ▁path ▁[ ▁2 ▁] ▁[ ▁i ▁] ▁) ▁i ▁++ ▁; ▁return ▁path ▁[ ▁1 ▁] ▁[ ▁i ▁- ▁1 ▁] ▁; ▁} ▁void ▁addEdge ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁tree ▁[ ▁a ▁] ▁. ▁push _ back ▁( ▁b ▁) ▁; ▁tree ▁[ ▁b ▁] ▁. ▁push _ back ▁( ▁a ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁8 ▁; ▁addEdge ▁( ▁1 ▁, ▁2 ▁) ▁; ▁addEdge ▁( ▁1 ▁, ▁3 ▁) ▁; ▁addEdge ▁( ▁2 ▁, ▁4 ▁) ▁; ▁addEdge ▁( ▁2 ▁, ▁5 ▁) ▁; ▁addEdge ▁( ▁2 ▁, ▁6 ▁) ▁; ▁addEdge ▁( ▁3 ▁, ▁7 ▁) ▁; ▁addEdge ▁( ▁3 ▁, ▁8 ▁) ▁; ▁c out ▁<< ▁" ▁L CA ▁( ▁4 ▁, ▁7 ▁) ▁= ▁" ▁<< ▁L CA ▁( ▁4 ▁, ▁7 ▁) ▁<< ▁end l ▁; ▁c out ▁<< ▁" ▁L CA ▁( ▁4 ▁, ▁6 ▁) ▁= ▁" ▁<< ▁L CA ▁( ▁4 ▁, ▁6 ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁checkIf Div isible ▁( ▁string ▁str ▁, ▁long ▁long ▁int ▁num ▁) ▁{ ▁long ▁long ▁int ▁power Of 2 ▁= ▁log 2 ▁( ▁num ▁) ▁; ▁if ▁( ▁str ▁. ▁length ▁( ▁) ▁< ▁power Of 2 ▁) ▁return ▁false ▁; ▁if ▁( ▁power Of 2 ▁== ▁0 ▁) ▁return ▁true ▁; ▁long ▁long ▁int ▁i ▁, ▁number ▁= ▁0 ▁; ▁int ▁len ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁for ▁( ▁i ▁= ▁len ▁- ▁power Of 2 ▁; ▁i ▁< ▁len ▁; ▁i ▁++ ▁) ▁{ ▁number ▁+= ▁( ▁str ▁[ ▁i ▁] ▁- ▁'0' ▁) ▁* ▁pow ▁( ▁10 ▁, ▁power Of 2 ▁- ▁1 ▁) ▁; ▁power Of 2 ▁-- ▁; ▁} ▁if ▁( ▁number ▁% ▁num ▁) ▁return ▁false ▁; ▁else ▁return ▁true ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" 21 346 77 565 64" ▁; ▁long ▁long ▁int ▁num ▁= ▁4 ▁; ▁if ▁( ▁checkIf Div isible ▁( ▁str ▁, ▁num ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁longest _ sub array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁d ▁) ▁{ ▁int ▁i ▁= ▁0 ▁, ▁j ▁= ▁1 ▁, ▁e ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁d ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁arr ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁{ ▁j ▁= ▁j ▁+ ▁1 ▁; ▁} ▁else ▁{ ▁j ▁= ▁1 ▁; ▁} ▁if ▁( ▁e ▁< ▁j ▁) ▁{ ▁e ▁= ▁j ▁; ▁} ▁} ▁return ▁e ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁longest _ sub array ▁( ▁arr ▁, ▁N ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁n ▁= ▁1000 5 ▁; ▁vector ▁< ▁bool ▁> ▁Prime ▁( ▁n ▁+ ▁1 ▁, ▁true ▁) ▁; ▁void ▁S ieve Of E rat ost hen es ▁( ▁) ▁{ ▁int ▁i ▁, ▁j ▁; ▁Prime ▁[ ▁0 ▁] ▁= ▁Prime ▁[ ▁1 ▁] ▁= ▁false ▁; ▁for ▁( ▁i ▁= ▁2 ▁; ▁i ▁* ▁i ▁<= ▁1000 5 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁Prime ▁[ ▁i ▁] ▁) ▁{ ▁for ▁( ▁j ▁= ▁2 ▁* ▁i ▁; ▁j ▁< ▁1000 5 ▁; ▁j ▁+= ▁i ▁) ▁{ ▁Prime ▁[ ▁j ▁] ▁= ▁false ▁; ▁} ▁} ▁} ▁} ▁void ▁prime Degree Nodes ▁( ▁int ▁N ▁, ▁int ▁M ▁, ▁int ▁edges ▁[ ▁] ▁[ ▁2 ▁] ▁) ▁{ ▁vector ▁< ▁int ▁> ▁Ad j ▁[ ▁N ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁M ▁; ▁i ▁++ ▁) ▁{ ▁int ▁x ▁= ▁edges ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁; ▁int ▁y ▁= ▁edges ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁; ▁Ad j ▁[ ▁x ▁] ▁. ▁push _ back ▁( ▁y ▁) ▁; ▁Ad j ▁[ ▁y ▁] ▁. ▁push _ back ▁( ▁x ▁) ▁; ▁} ▁S ieve Of E rat ost hen es ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁int ▁x ▁= ▁Ad j ▁[ ▁i ▁] ▁. ▁size ▁( ▁) ▁; ▁if ▁( ▁Prime ▁[ ▁x ▁] ▁) ▁c out ▁<< ▁i ▁<< ▁' ▁' ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁4 ▁, ▁M ▁= ▁6 ▁; ▁int ▁edges ▁[ ▁M ▁] ▁[ ▁2 ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁} ▁, ▁{ ▁1 ▁, ▁3 ▁} ▁, ▁{ ▁1 ▁, ▁4 ▁} ▁, ▁{ ▁2 ▁, ▁3 ▁} ▁, ▁{ ▁2 ▁, ▁4 ▁} ▁, ▁{ ▁3 ▁, ▁4 ▁} ▁} ▁; ▁prime Degree Nodes ▁( ▁N ▁, ▁M ▁, ▁edges ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁int ▁mod ▁= ▁100 000000 7 ▁; ▁int ▁count W ays ▁( ▁int ▁colored ▁[ ▁] ▁, ▁int ▁count ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁count ▁== ▁n ▁) ▁{ ▁return ▁1 ▁; ▁} ▁int ▁answer ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁colored ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁if ▁( ▁colored ▁[ ▁i ▁- ▁1 ▁] ▁== ▁1 ▁colored ▁[ ▁i ▁+ ▁1 ▁] ▁== ▁1 ▁) ▁{ ▁colored ▁[ ▁i ▁] ▁= ▁1 ▁; ▁answer ▁= ▁( ▁answer ▁+ ▁count W ays ▁( ▁colored ▁, ▁count ▁+ ▁1 ▁, ▁n ▁) ▁) ▁% ▁mod ▁; ▁colored ▁[ ▁i ▁] ▁= ▁0 ▁; ▁} ▁} ▁} ▁return ▁answer ▁; ▁} ▁int ▁ways To Color ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁colored ▁[ ▁n ▁+ ▁2 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁k ▁; ▁i ▁++ ▁) ▁{ ▁colored ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁= ▁1 ▁; ▁} ▁return ▁count W ays ▁( ▁colored ▁, ▁k ▁, ▁n ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁6 ▁; ▁int ▁K ▁= ▁3 ▁; ▁int ▁arr ▁[ ▁K ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁6 ▁} ▁; ▁c out ▁<< ▁ways To Color ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁check Perm utation ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁long ▁long ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁long ▁long ▁prefix ▁[ ▁n ▁+ ▁1 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁prefix ▁[ ▁0 ▁] ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁prefix ▁[ ▁i ▁] ▁= ▁prefix ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁arr ▁[ ▁i ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁long ▁long ▁l sum ▁= ▁prefix ▁[ ▁i ▁] ▁; ▁long ▁long ▁r sum ▁= ▁sum ▁- ▁prefix ▁[ ▁i ▁] ▁; ▁long ▁long ▁l _ len ▁= ▁i ▁+ ▁1 ▁, ▁r _ len ▁= ▁n ▁- ▁i ▁- ▁1 ▁; ▁if ▁( ▁( ▁( ▁2 ▁* ▁l sum ▁) ▁== ▁( ▁l _ len ▁* ▁( ▁l _ len ▁+ ▁1 ▁) ▁) ▁) ▁&& ▁( ▁( ▁2 ▁* ▁r sum ▁) ▁== ▁( ▁r _ len ▁* ▁( ▁r _ len ▁+ ▁1 ▁) ▁) ▁) ▁) ▁return ▁true ▁; ▁} ▁return ▁false ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁5 ▁, ▁3 ▁, ▁4 ▁, ▁1 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁if ▁( ▁check Perm utation ▁( ▁arr ▁, ▁n ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁STRNEWLINE ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁STRNEWLINE ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find Next Number ▁( ▁int ▁n ▁) ▁{ ▁int ▁h ▁[ ▁10 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁int ▁i ▁= ▁0 ▁, ▁ms b ▁= ▁n ▁, ▁rem ▁= ▁0 ▁; ▁int ▁next _ num ▁= ▁-1 ▁, ▁count ▁= ▁0 ▁; ▁while ▁( ▁ms b ▁> ▁9 ▁) ▁{ ▁rem ▁= ▁ms b ▁% ▁10 ▁; ▁h ▁[ ▁rem ▁] ▁= ▁1 ▁; ▁ms b ▁/= ▁10 ▁; ▁count ▁++ ▁; ▁} ▁h ▁[ ▁ms b ▁] ▁= ▁1 ▁; ▁count ▁++ ▁; ▁for ▁( ▁i ▁= ▁ms b ▁+ ▁1 ▁; ▁i ▁< ▁10 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁h ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁next _ num ▁= ▁i ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁next _ num ▁== ▁-1 ▁) ▁{ ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁ms b ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁h ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁next _ num ▁= ▁i ▁; ▁count ▁++ ▁; ▁break ▁; ▁} ▁} ▁} ▁if ▁( ▁next _ num ▁> ▁0 ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁10 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁h ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁ms b ▁= ▁i ▁; ▁break ▁; ▁} ▁} ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁count ▁; ▁i ▁++ ▁) ▁{ ▁next _ num ▁= ▁( ▁( ▁next _ num ▁* ▁10 ▁) ▁+ ▁ms b ▁) ▁; ▁} ▁if ▁( ▁next _ num ▁> ▁n ▁) ▁c out ▁<< ▁next _ num ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁else ▁c out ▁<< ▁" ▁Not ▁Possible ▁STRNEWLINE ▁" ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁" ▁Not ▁Possible ▁STRNEWLINE ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁2019 ▁; ▁find Next Number ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find The Number ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁1 ▁) ▁{ ▁c out ▁<< ▁" ▁Imp ossible ▁" ▁<< ▁end l ▁; ▁return ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁c out ▁<< ▁"5" ▁; ▁} ▁c out ▁<< ▁"4" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁12 ▁; ▁find The Number ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁int ▁MAX N ▁= ▁100000 5 ▁; ▁int ▁even ▁[ ▁MAX N ▁] ▁, ▁odd ▁[ ▁MAX N ▁] ▁; ▁void ▁pre compute ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁% ▁2 ▁== ▁1 ▁) ▁odd ▁[ ▁i ▁] ▁= ▁1 ▁; ▁if ▁( ▁arr ▁[ ▁i ▁] ▁% ▁2 ▁== ▁0 ▁) ▁even ▁[ ▁i ▁] ▁= ▁1 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁even ▁[ ▁i ▁] ▁= ▁even ▁[ ▁i ▁] ▁+ ▁even ▁[ ▁i ▁- ▁1 ▁] ▁; ▁odd ▁[ ▁i ▁] ▁= ▁odd ▁[ ▁i ▁] ▁+ ▁odd ▁[ ▁i ▁- ▁1 ▁] ▁; ▁} ▁} ▁bool ▁is Odd ▁( ▁int ▁L ▁, ▁int ▁R ▁) ▁{ ▁int ▁cnt ▁= ▁odd ▁[ ▁R ▁] ▁; ▁if ▁( ▁L ▁> ▁0 ▁) ▁cnt ▁-= ▁odd ▁[ ▁L ▁- ▁1 ▁] ▁; ▁if ▁( ▁cnt ▁== ▁R ▁- ▁L ▁+ ▁1 ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁void ▁perform Queries ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁q ▁[ ▁] ▁[ ▁2 ▁] ▁, ▁int ▁m ▁) ▁{ ▁pre compute ▁( ▁a ▁, ▁n ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁m ▁; ▁i ▁++ ▁) ▁{ ▁int ▁L ▁= ▁q ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁, ▁R ▁= ▁q ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁; ▁if ▁( ▁is Odd ▁( ▁L ▁, ▁R ▁) ▁) ▁c out ▁<< ▁" ▁O dd ▁STRNEWLINE ▁" ▁; ▁else ▁c out ▁<< ▁" ▁Even ▁STRNEWLINE ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁1 ▁, ▁5 ▁, ▁7 ▁, ▁6 ▁, ▁8 ▁, ▁9 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁int ▁q ▁[ ▁] ▁[ ▁2 ▁] ▁= ▁{ ▁{ ▁0 ▁, ▁2 ▁} ▁, ▁{ ▁1 ▁, ▁2 ▁} ▁, ▁{ ▁2 ▁, ▁3 ▁} ▁, ▁{ ▁3 ▁, ▁6 ▁} ▁} ▁; ▁int ▁m ▁= ▁sizeof ▁( ▁q ▁) ▁/ ▁sizeof ▁( ▁q ▁[ ▁0 ▁] ▁) ▁; ▁perform Queries ▁( ▁a ▁, ▁n ▁, ▁q ▁, ▁m ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁string ▁getW inner ▁( ▁string ▁str ▁, ▁int ▁len ▁) ▁{ ▁int ▁total ▁= ▁0 ▁; ▁if ▁( ▁str ▁[ ▁0 ▁] ▁== ▁' ▁G ▁' ▁str ▁[ ▁len ▁- ▁1 ▁] ▁== ▁' ▁G ▁' ▁) ▁return ▁" ▁First ▁" ▁; ▁else ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁len ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁str ▁[ ▁i ▁] ▁== ▁' ▁S ▁' ▁) ▁{ ▁total ▁++ ▁; ▁} ▁} ▁if ▁( ▁( ▁total ▁% ▁2 ▁) ▁== ▁1 ▁) ▁return ▁" ▁First ▁" ▁; ▁return ▁" ▁Second ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁GSS S ▁" ▁; ▁int ▁len ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁c out ▁<< ▁getW inner ▁( ▁str ▁, ▁len ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print Arr ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁} ▁void ▁find Arr angement ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁< ▁2 ▁) ▁{ ▁c out ▁<< ▁" ▁- ▁1" ▁; ▁return ▁; ▁} ▁int ▁min Val ▁= ▁* ▁min _ element ▁( ▁arr ▁, ▁arr ▁+ ▁n ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁min Val ▁) ▁{ ▁swap ▁( ▁arr ▁[ ▁i ▁] ▁, ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁) ▁; ▁break ▁; ▁} ▁} ▁int ▁and Val ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁and Val ▁&= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁if ▁( ▁and Val ▁== ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁) ▁print Arr ▁( ▁arr ▁, ▁n ▁) ▁; ▁else ▁c out ▁<< ▁" ▁- ▁1" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁5 ▁, ▁3 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁find Arr angement ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max Operations ▁( ▁int ▁X ▁, ▁int ▁Y ▁) ▁{ ▁if ▁( ▁X ▁> ▁Y ▁) ▁return ▁-1 ▁; ▁int ▁diff ▁= ▁Y ▁- ▁X ▁; ▁if ▁( ▁diff ▁== ▁1 ▁) ▁return ▁-1 ▁; ▁if ▁( ▁diff ▁% ▁2 ▁== ▁0 ▁) ▁return ▁( ▁diff ▁/ ▁2 ▁) ▁; ▁return ▁( ▁1 ▁+ ▁( ▁( ▁diff ▁- ▁3 ▁) ▁/ ▁2 ▁) ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁X ▁= ▁5 ▁, ▁Y ▁= ▁16 ▁; ▁c out ▁<< ▁max Operations ▁( ▁X ▁, ▁Y ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print Arr ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁} ▁void ▁random List ▁( ▁int ▁m ▁, ▁int ▁n ▁) ▁{ ▁int ▁arr ▁[ ▁m ▁] ▁= ▁{ ▁0 ▁} ▁; ▁sr and ▁( ▁time ▁( ▁0 ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁arr ▁[ ▁rand ▁( ▁) ▁% ▁m ▁] ▁++ ▁; ▁} ▁print Arr ▁( ▁arr ▁, ▁m ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁m ▁= ▁4 ▁, ▁n ▁= ▁8 ▁; ▁random List ▁( ▁m ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find _ maximum _ value ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁int ▁minimum ▁= ▁INT _ MAX ▁; ▁int ▁pos ▁= ▁0 ▁, ▁neg ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁minimum ▁= ▁min ▁( ▁minimum ▁, ▁abs ▁( ▁a ▁[ ▁i ▁] ▁) ▁) ▁; ▁sum ▁+= ▁abs ▁( ▁a ▁[ ▁i ▁] ▁) ▁; ▁if ▁( ▁a ▁[ ▁i ▁] ▁>= ▁0 ▁) ▁pos ▁+= ▁1 ▁; ▁else ▁neg ▁+= ▁1 ▁; ▁} ▁if ▁( ▁pos ▁> ▁0 ▁&& ▁neg ▁> ▁0 ▁) ▁return ▁sum ▁; ▁return ▁( ▁sum ▁- ▁2 ▁* ▁minimum ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁4 ▁, ▁6 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁find _ maximum _ value ▁( ▁a ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁getMin Val ▁( ▁int ▁p ▁, ▁int ▁q ▁) ▁{ ▁if ▁( ▁q ▁% ▁p ▁== ▁0 ▁) ▁return ▁p ▁; ▁return ▁-1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁p ▁= ▁24 ▁, ▁q ▁= ▁48 ▁; ▁c out ▁<< ▁getMin Val ▁( ▁p ▁, ▁q ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is _ prefix ▁( ▁string ▁temp ▁, ▁string ▁str ▁) ▁{ ▁if ▁( ▁temp ▁. ▁length ▁( ▁) ▁< ▁str ▁. ▁length ▁( ▁) ▁) ▁return ▁0 ▁; ▁else ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁str ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁str ▁[ ▁i ▁] ▁!= ▁temp ▁[ ▁i ▁] ▁) ▁return ▁0 ▁; ▁} ▁return ▁1 ▁; ▁} ▁} ▁string ▁lex ic ograph ically String ▁( ▁string ▁input ▁[ ▁] ▁, ▁int ▁n ▁, ▁string ▁str ▁) ▁{ ▁sort ▁( ▁input ▁, ▁input ▁+ ▁n ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁string ▁temp ▁= ▁input ▁[ ▁i ▁] ▁; ▁if ▁( ▁is _ prefix ▁( ▁temp ▁, ▁str ▁) ▁) ▁{ ▁return ▁temp ▁; ▁} ▁} ▁return ▁" ▁- ▁1" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁arr ▁[ ▁] ▁= ▁{ ▁" ▁apple ▁" ▁, ▁" ▁appe ▁" ▁, ▁" ▁a pl ▁" ▁, ▁" ▁a ap l ▁" ▁, ▁" ▁app ax ▁" ▁} ▁; ▁string ▁S ▁= ▁" ▁app ▁" ▁; ▁int ▁N ▁= ▁5 ▁; ▁c out ▁<< ▁lex ic ograph ically String ▁( ▁arr ▁, ▁N ▁, ▁S ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁min Sum Pair ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁if ▁( ▁N ▁< ▁5 ▁) ▁{ ▁return ▁-1 ▁; ▁} ▁int ▁prefix Min ▁[ ▁N ▁] ▁; ▁prefix Min ▁[ ▁0 ▁] ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁prefix Min ▁[ ▁i ▁] ▁= ▁min ▁( ▁arr ▁[ ▁i ▁] ▁, ▁prefix Min ▁[ ▁i ▁- ▁1 ▁] ▁) ▁; ▁} ▁int ▁ans ▁= ▁INT _ MAX ▁; ▁for ▁( ▁int ▁i ▁= ▁3 ▁; ▁i ▁< ▁N ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁ans ▁= ▁min ▁( ▁ans ▁, ▁arr ▁[ ▁i ▁] ▁+ ▁prefix Min ▁[ ▁i ▁- ▁2 ▁] ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁2 ▁, ▁4 ▁, ▁6 ▁, ▁3 ▁, ▁7 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁c out ▁<< ▁min Sum Pair ▁( ▁arr ▁, ▁N ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find Count ▁( ▁string ▁number ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁number ▁. ▁length ▁( ▁) ▁; ▁++ ▁i ▁) ▁{ ▁sum ▁+= ▁number ▁[ ▁i ▁] ▁- ▁48 ▁; ▁} ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁number ▁. ▁length ▁( ▁) ▁; ▁++ ▁i ▁) ▁{ ▁int ▁remaining _ sum ▁= ▁sum ▁- ▁( ▁number ▁[ ▁i ▁] ▁- ▁48 ▁) ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁<= ▁9 ▁; ▁++ ▁j ▁) ▁{ ▁if ▁( ▁( ▁remaining _ sum ▁+ ▁j ▁) ▁% ▁3 ▁== ▁0 ▁&& ▁j ▁!= ▁number ▁[ ▁i ▁] ▁- ▁48 ▁) ▁{ ▁++ ▁count ▁; ▁} ▁} ▁} ▁c out ▁<< ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁number ▁= ▁"2 35 " ▁; ▁find Count ▁( ▁number ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁ll ▁long ▁long ▁NEW _ LINE ▁ll ▁n ▁, ▁m ▁, ▁k ▁, ▁l ▁, ▁r ▁, ▁i ▁; ▁ll ▁check ▁( ▁ll ▁v ▁, ▁vector ▁< ▁ll ▁> ▁& ▁a ▁) ▁{ ▁ll ▁t ec ▁= ▁0 ▁, ▁ans ▁= ▁0 ▁; ▁vector ▁< ▁ll ▁> ▁b ▁( ▁n ▁+ ▁k ▁+ ▁1 ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁t ec ▁-= ▁b ▁[ ▁i ▁] ▁; ▁if ▁( ▁a ▁[ ▁i ▁] ▁+ ▁t ec ▁< ▁v ▁) ▁{ ▁ll ▁mov ▁= ▁v ▁- ▁a ▁[ ▁i ▁] ▁- ▁t ec ▁; ▁ans ▁= ▁ans ▁+ ▁mov ▁; ▁t ec ▁+= ▁mov ▁; ▁b ▁[ ▁i ▁+ ▁k ▁] ▁= ▁mov ▁; ▁} ▁} ▁return ▁( ▁ans ▁<= ▁m ▁) ▁; ▁} ▁ll ▁Find L argest ▁( ▁vector ▁< ▁ll ▁> ▁a ▁) ▁{ ▁l ▁= ▁1 ▁; ▁r ▁= ▁pow ▁( ▁10 ▁, ▁10 ▁) ▁; ▁while ▁( ▁r ▁- ▁l ▁> ▁0 ▁) ▁{ ▁ll ▁tm ▁= ▁( ▁l ▁+ ▁r ▁+ ▁1 ▁) ▁/ ▁2 ▁; ▁if ▁( ▁check ▁( ▁tm ▁, ▁a ▁) ▁) ▁l ▁= ▁tm ▁; ▁else ▁r ▁= ▁tm ▁- ▁1 ▁; ▁} ▁return ▁l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁ll ▁> ▁a ▁{ ▁2 ▁, ▁2 ▁, ▁2 ▁, ▁2 ▁, ▁1 ▁, ▁1 ▁} ▁; ▁m ▁= ▁2 ▁; ▁k ▁= ▁3 ▁; ▁n ▁= ▁a ▁. ▁size ▁( ▁) ▁; ▁c out ▁<< ▁Find L argest ▁( ▁a ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁number of Boxes ▁( ▁int ▁W ▁, ▁int ▁B ▁, ▁int ▁O ▁) ▁{ ▁int ▁low ▁= ▁0 ▁, ▁high ▁= ▁min ▁( ▁W ▁, ▁B ▁) ▁; ▁int ▁ans ▁= ▁0 ▁; ▁while ▁( ▁low ▁<= ▁high ▁) ▁{ ▁int ▁mid ▁= ▁low ▁+ ▁( ▁high ▁- ▁low ▁) ▁/ ▁2 ▁; ▁if ▁( ▁( ▁( ▁W ▁>= ▁mid ▁) ▁and ▁( ▁B ▁>= ▁mid ▁) ▁) ▁and ▁( ▁( ▁W ▁- ▁mid ▁) ▁+ ▁( ▁B ▁- ▁mid ▁) ▁+ ▁O ▁) ▁>= ▁mid ▁) ▁{ ▁ans ▁= ▁mid ▁; ▁low ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁else ▁high ▁= ▁mid ▁- ▁1 ▁; ▁} ▁c out ▁<< ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁W ▁= ▁3 ▁, ▁B ▁= ▁3 ▁, ▁O ▁= ▁1 ▁; ▁number of Boxes ▁( ▁W ▁, ▁B ▁, ▁O ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find Pairs ▁( ▁int ▁A ▁, ▁int ▁B ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁B ▁; ▁i ▁++ ▁) ▁{ ▁int ▁y ▁= ▁A ▁^ ▁i ▁; ▁if ▁( ▁y ▁> ▁0 ▁and ▁( ▁i ▁y ▁) ▁== ▁B ▁) ▁{ ▁c out ▁<< ▁i ▁<< ▁" ▁" ▁<< ▁y ▁<< ▁end l ▁; ▁} ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁= ▁8 ▁, ▁B ▁= ▁10 ▁; ▁find Pairs ▁( ▁A ▁, ▁B ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is char ▁( ▁char ▁x ▁) ▁{ ▁if ▁( ▁( ▁x ▁>= ▁' ▁A ▁' ▁&& ▁x ▁<= ▁' ▁Z ▁' ▁) ▁|| ▁( ▁x ▁>= ▁' ▁a ▁' ▁&& ▁x ▁<= ▁' ▁z ▁' ▁) ▁) ▁{ ▁return ▁1 ▁; ▁} ▁return ▁0 ▁; ▁} ▁bool ▁is num ▁( ▁char ▁x ▁) ▁{ ▁if ▁( ▁x ▁>= ▁'0' ▁&& ▁x ▁<= ▁'9' ▁) ▁return ▁1 ▁; ▁return ▁0 ▁; ▁} ▁void ▁find Id and Domain ▁( ▁string ▁S ▁, ▁int ▁N ▁) ▁{ ▁string ▁ID ▁, ▁Domain ▁; ▁vector ▁< ▁string ▁> ▁words ▁; ▁string ▁curr ▁= ▁" ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁S ▁[ ▁i ▁] ▁== ▁' ▁' ▁) ▁{ ▁words ▁. ▁push _ back ▁( ▁curr ▁) ▁; ▁curr ▁= ▁" ▁" ▁; ▁} ▁else ▁{ ▁if ▁( ▁S ▁[ ▁i ▁] ▁== ▁' ▁. ▁' ▁) ▁{ ▁if ▁( ▁i ▁+ ▁1 ▁== ▁N ▁|| ▁( ▁i ▁+ ▁1 ▁< ▁N ▁&& ▁S ▁[ ▁i ▁+ ▁1 ▁] ▁== ▁' ▁' ▁) ▁) ▁continue ▁; ▁} ▁curr ▁+= ▁S ▁[ ▁i ▁] ▁; ▁} ▁} ▁if ▁( ▁curr ▁. ▁length ▁( ▁) ▁) ▁words ▁. ▁push _ back ▁( ▁curr ▁) ▁; ▁for ▁( ▁string ▁ss ▁: ▁words ▁) ▁{ ▁if ▁( ▁ss ▁. ▁size ▁( ▁) ▁== ▁10 ▁) ▁{ ▁bool ▁flag ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁<= ▁9 ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁j ▁>= ▁5 ▁&& ▁j ▁< ▁9 ▁) ▁{ ▁if ▁( ▁is num ▁( ▁ss ▁[ ▁j ▁] ▁) ▁== ▁0 ▁) ▁flag ▁= ▁1 ▁; ▁} ▁else ▁{ ▁if ▁( ▁is char ▁( ▁ss ▁[ ▁j ▁] ▁) ▁== ▁0 ▁) ▁flag ▁= ▁1 ▁; ▁} ▁} ▁if ▁( ▁! ▁flag ▁) ▁{ ▁ID ▁= ▁ss ▁; ▁} ▁} ▁if ▁( ▁ss ▁. ▁substr ▁( ▁0 ▁, ▁3 ▁) ▁== ▁" ▁www ▁" ▁&& ▁ss ▁. ▁substr ▁( ▁ss ▁. ▁length ▁( ▁) ▁- ▁3 ▁, ▁3 ▁) ▁== ▁" ▁com ▁" ▁) ▁{ ▁Domain ▁= ▁ss ▁. ▁substr ▁( ▁4 ▁, ▁ss ▁. ▁size ▁( ▁) ▁- ▁4 ▁) ▁; ▁} ▁} ▁c out ▁<< ▁" ▁ID ▁= ▁" ▁<< ▁ID ▁<< ▁end l ▁; ▁c out ▁<< ▁" ▁Domain ▁= ▁" ▁<< ▁Domain ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁S ▁= ▁" ▁We ▁thank ▁ABC DE 1234 F ▁for ▁visiting ▁" ▁" ▁us ▁and ▁bu ying ▁" ▁" ▁products ▁item ▁AM Z rr ▁@ ▁! ▁k ▁. ▁For ▁more ▁" ▁" ▁offers ▁, ▁visit ▁" ▁" ▁us ▁at ▁www ▁. ▁amazon ▁. ▁com ▁" ▁; ▁int ▁N ▁= ▁S ▁. ▁length ▁( ▁) ▁; ▁find Id and Domain ▁( ▁S ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Tri pl ets ▁( ▁int ▁D ▁, ▁vector ▁< ▁int ▁> ▁& ▁arr ▁) ▁{ ▁unordered _ map ▁< ▁int ▁, ▁int ▁> ▁freq ▁; ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁arr ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁freq ▁. ▁find ▁( ▁arr ▁[ ▁i ▁] ▁- ▁D ▁) ▁!= ▁freq ▁. ▁end ▁( ▁) ▁&& ▁freq ▁. ▁find ▁( ▁arr ▁[ ▁i ▁] ▁- ▁2 ▁* ▁D ▁) ▁!= ▁freq ▁. ▁end ▁( ▁) ▁) ▁{ ▁ans ▁+= ▁freq ▁[ ▁arr ▁[ ▁i ▁] ▁- ▁D ▁] ▁* ▁freq ▁[ ▁arr ▁[ ▁i ▁] ▁- ▁2 ▁* ▁D ▁] ▁; ▁} ▁freq ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁++ ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁int ▁> ▁arr ▁{ ▁1 ▁, ▁2 ▁, ▁4 ▁, ▁5 ▁, ▁7 ▁, ▁8 ▁, ▁10 ▁} ▁; ▁int ▁D ▁= ▁1 ▁; ▁c out ▁<< ▁count Tri pl ets ▁( ▁D ▁, ▁arr ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁bound ▁( ▁int ▁w ▁, ▁int ▁h ▁, ▁int ▁N ▁, ▁int ▁x ▁) ▁{ ▁int ▁val ▁= ▁( ▁x ▁/ ▁w ▁) ▁* ▁( ▁x ▁/ ▁h ▁) ▁; ▁if ▁( ▁val ▁>= ▁N ▁) ▁return ▁true ▁; ▁else ▁return ▁false ▁; ▁} ▁int ▁Find Square ▁( ▁int ▁N ▁, ▁int ▁W ▁, ▁int ▁H ▁) ▁{ ▁int ▁i ▁= ▁1 ▁; ▁int ▁j ▁= ▁W ▁* ▁H ▁* ▁N ▁; ▁while ▁( ▁i ▁< ▁j ▁) ▁{ ▁int ▁mid ▁= ▁i ▁+ ▁( ▁j ▁- ▁i ▁) ▁/ ▁2 ▁; ▁if ▁( ▁bound ▁( ▁W ▁, ▁H ▁, ▁N ▁, ▁mid ▁) ▁) ▁j ▁= ▁mid ▁; ▁else ▁i ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁return ▁j ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁W ▁= ▁2 ▁; ▁int ▁H ▁= ▁3 ▁; ▁int ▁N ▁= ▁10 ▁; ▁c out ▁<< ▁Find Square ▁( ▁N ▁, ▁W ▁, ▁H ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁S ieve Of E rat ost hen es ▁( ▁bool ▁prime ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁prime ▁[ ▁0 ▁] ▁= ▁false ▁; ▁prime ▁[ ▁1 ▁] ▁= ▁false ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁* ▁p ▁<= ▁n ▁; ▁p ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁p ▁] ▁== ▁true ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁p ▁* ▁p ▁; ▁i ▁<= ▁n ▁; ▁i ▁+= ▁p ▁) ▁{ ▁prime ▁[ ▁i ▁] ▁= ▁false ▁; ▁} ▁} ▁} ▁} ▁void ▁sum Of Prime Square ▁( ▁int ▁n ▁) ▁{ ▁bool ▁flag ▁= ▁false ▁; ▁bool ▁prime ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁mem set ▁( ▁prime ▁, ▁true ▁, ▁sizeof ▁( ▁prime ▁) ▁) ▁; ▁S ieve Of E rat ost hen es ▁( ▁prime ▁, ▁n ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁! ▁prime ▁[ ▁i ▁] ▁) ▁continue ▁; ▁int ▁dif ▁= ▁n ▁- ▁i ▁; ▁if ▁( ▁ceil ▁( ▁( ▁double ▁) ▁sqrt ▁( ▁dif ▁) ▁) ▁== ▁floor ▁( ▁( ▁double ▁) ▁sqrt ▁( ▁dif ▁) ▁) ▁) ▁{ ▁flag ▁= ▁true ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁flag ▁) ▁{ ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁} ▁else ▁c out ▁<< ▁" ▁No ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁27 ▁; ▁sum Of Prime Square ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁check ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁M ▁, ▁int ▁K ▁, ▁int ▁ind ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁M ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁< ▁K ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁ind ▁+ ▁i ▁] ▁!= ▁arr ▁[ ▁ind ▁+ ▁i ▁+ ▁j ▁* ▁M ▁] ▁) ▁{ ▁return ▁false ▁; ▁} ▁} ▁} ▁return ▁true ▁; ▁} ▁bool ▁Sub array Repe ats K or More ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁M ▁, ▁int ▁K ▁) ▁{ ▁for ▁( ▁int ▁ind ▁= ▁0 ▁; ▁ind ▁<= ▁N ▁- ▁M ▁* ▁K ▁; ▁ind ▁++ ▁) ▁{ ▁if ▁( ▁check ▁( ▁arr ▁, ▁M ▁, ▁K ▁, ▁ind ▁) ▁) ▁{ ▁return ▁true ▁; ▁} ▁} ▁return ▁false ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁1 ▁, ▁2 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁3 ▁} ▁; ▁int ▁M ▁= ▁2 ▁, ▁K ▁= ▁2 ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁if ▁( ▁Sub array Repe ats K or More ▁( ▁arr ▁, ▁N ▁, ▁M ▁, ▁K ▁) ▁) ▁{ ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁" ▁No ▁" ▁; ▁} ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁minimum Number ▁( ▁int ▁K ▁, ▁int ▁X ▁) ▁{ ▁if ▁( ▁K ▁> ▁X ▁) ▁{ ▁c out ▁<< ▁" ▁- ▁1" ▁; ▁return ▁; ▁} ▁int ▁ans ▁= ▁0 ▁; ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁K ▁; ▁i ▁<= ▁X ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁i ▁; ▁if ▁( ▁sum ▁>= ▁X ▁) ▁{ ▁ans ▁= ▁i ▁; ▁break ▁; ▁} ▁} ▁c out ▁<< ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁K ▁= ▁5 ▁, ▁X ▁= ▁13 ▁; ▁minimum Number ▁( ▁K ▁, ▁X ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁peak Index ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁if ▁( ▁N ▁< ▁3 ▁) ▁return ▁-1 ▁; ▁int ▁i ▁= ▁0 ▁; ▁while ▁( ▁i ▁+ ▁1 ▁< ▁N ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁+ ▁1 ▁] ▁< ▁arr ▁[ ▁i ▁] ▁arr ▁[ ▁i ▁] ▁== ▁arr ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁break ▁; ▁i ▁++ ▁; ▁} ▁if ▁( ▁i ▁== ▁0 ▁i ▁== ▁N ▁- ▁1 ▁) ▁return ▁-1 ▁; ▁int ▁ans ▁= ▁i ▁; ▁while ▁( ▁i ▁< ▁N ▁- ▁1 ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁arr ▁[ ▁i ▁+ ▁1 ▁] ▁arr ▁[ ▁i ▁] ▁== ▁arr ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁break ▁; ▁i ▁++ ▁; ▁} ▁if ▁( ▁i ▁== ▁N ▁- ▁1 ▁) ▁return ▁ans ▁; ▁return ▁-1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁1 ▁, ▁0 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁peak Index ▁( ▁arr ▁, ▁N ▁) ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find Pairs ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁arr ▁[ ▁i ▁] ▁= ▁abs ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁sort ▁( ▁arr ▁, ▁arr ▁+ ▁N ▁) ▁; ▁int ▁left ▁= ▁0 ▁; ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁right ▁= ▁0 ▁; ▁right ▁< ▁N ▁; ▁right ▁++ ▁) ▁{ ▁while ▁( ▁2 ▁* ▁arr ▁[ ▁left ▁] ▁< ▁arr ▁[ ▁right ▁] ▁) ▁left ▁++ ▁; ▁ans ▁+= ▁( ▁right ▁- ▁left ▁) ▁; ▁} ▁c out ▁<< ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁5 ▁, ▁7 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁find Pairs ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁even product ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁length ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁length ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁int ▁product ▁= ▁1 ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁< ▁length ▁+ ▁1 ▁; ▁j ▁++ ▁) ▁{ ▁product ▁*= ▁arr ▁[ ▁j ▁] ▁; ▁if ▁( ▁product ▁% ▁2 ▁== ▁0 ▁) ▁++ ▁count ▁; ▁} ▁} ▁c out ▁<< ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁7 ▁, ▁5 ▁, ▁4 ▁, ▁9 ▁} ▁; ▁int ▁length ▁= ▁( ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁) ▁- ▁1 ▁; ▁even product ▁( ▁arr ▁, ▁length ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁total W ays ▁( ▁int ▁n ▁, ▁string ▁str ▁) ▁{ ▁vector ▁< ▁int ▁> ▁Id x Of 0 s ▁; ▁int ▁cnt W ays ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁str ▁[ ▁i ▁] ▁== ▁'0' ▁) ▁{ ▁Id x Of 0 s ▁. ▁push _ back ▁( ▁i ▁) ▁; ▁} ▁} ▁int ▁M ▁= ▁Id x Of 0 s ▁. ▁size ▁( ▁) ▁; ▁if ▁( ▁M ▁== ▁0 ▁or ▁M ▁% ▁2 ▁) ▁{ ▁return ▁0 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁< ▁M ▁; ▁i ▁+= ▁2 ▁) ▁{ ▁cnt W ays ▁= ▁cnt W ays ▁* ▁( ▁Id x Of 0 s ▁[ ▁i ▁] ▁- ▁Id x Of 0 s ▁[ ▁i ▁- ▁1 ▁] ▁) ▁; ▁} ▁return ▁cnt W ays ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁"00 100 " ▁; ▁int ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁c out ▁<< ▁total W ays ▁( ▁n ▁, ▁str ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁Count Sub array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁temp ▁= ▁k ▁, ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁temp ▁) ▁{ ▁if ▁( ▁temp ▁== ▁1 ▁) ▁{ ▁count ▁++ ▁; ▁temp ▁= ▁k ▁; ▁} ▁else ▁temp ▁-- ▁; ▁} ▁else ▁{ ▁temp ▁= ▁k ▁; ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁k ▁) ▁i ▁-- ▁; ▁} ▁} ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁7 ▁, ▁9 ▁, ▁3 ▁, ▁2 ▁, ▁1 ▁, ▁8 ▁, ▁3 ▁, ▁2 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁K ▁= ▁3 ▁; ▁c out ▁<< ▁Count Sub array ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁count Div is ors ▁( ▁long ▁long ▁int ▁n ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁vector ▁< ▁long ▁long ▁int ▁> ▁divisor ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁sqrt ▁( ▁n ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁{ ▁if ▁( ▁n ▁/ ▁i ▁== ▁i ▁) ▁divisor ▁. ▁push _ back ▁( ▁i ▁) ▁; ▁else ▁{ ▁divisor ▁. ▁push _ back ▁( ▁i ▁) ▁; ▁divisor ▁. ▁push _ back ▁( ▁n ▁/ ▁i ▁) ▁; ▁} ▁} ▁} ▁divisor ▁. ▁push _ back ▁( ▁n ▁) ▁; ▁for ▁( ▁auto ▁x ▁: ▁divisor ▁) ▁{ ▁x ▁-= ▁1 ▁; ▁if ▁( ▁( ▁n ▁/ ▁x ▁) ▁== ▁( ▁n ▁% ▁x ▁) ▁) ▁count ▁++ ▁; ▁} ▁c out ▁<< ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁long ▁long ▁int ▁N ▁= ▁1000000 000000 ▁; ▁count Div is ors ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Max Length ▁( ▁int ▁N ▁, ▁vector ▁< ▁int ▁> ▁arr ▁) ▁{ ▁vector ▁< ▁int ▁> ▁dp ▁( ▁N ▁+ ▁1 ▁, ▁1 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁2 ▁* ▁i ▁; ▁j ▁<= ▁N ▁; ▁j ▁+= ▁i ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁< ▁arr ▁[ ▁j ▁- ▁1 ▁] ▁) ▁{ ▁dp ▁[ ▁j ▁] ▁= ▁max ▁( ▁dp ▁[ ▁j ▁] ▁, ▁dp ▁[ ▁i ▁] ▁+ ▁1 ▁) ▁; ▁} ▁} ▁} ▁return ▁* ▁max _ element ▁( ▁dp ▁. ▁begin ▁( ▁) ▁, ▁dp ▁. ▁end ▁( ▁) ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁int ▁> ▁arr ▁{ ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁, ▁7 ▁, ▁8 ▁, ▁9 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁size ▁( ▁) ▁; ▁c out ▁<< ▁find Max Length ▁( ▁N ▁, ▁arr ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁long ▁long ▁power ▁( ▁long ▁long ▁x ▁, ▁long ▁long ▁N ▁) ▁{ ▁long ▁long ▁res ▁= ▁1 ▁; ▁while ▁( ▁N ▁> ▁0 ▁) ▁{ ▁if ▁( ▁N ▁& ▁1 ▁) ▁{ ▁res ▁= ▁( ▁res ▁* ▁x ▁) ▁; ▁} ▁x ▁= ▁( ▁x ▁* ▁x ▁) ▁; ▁N ▁= ▁N ▁>> ▁1 ▁; ▁} ▁return ▁res ▁; ▁} ▁void ▁find Val X _ Y ▁( ▁long ▁long ▁N ▁) ▁{ ▁if ▁( ▁N ▁<= ▁1 ▁) ▁{ ▁c out ▁<< ▁-1 ▁<< ▁end l ▁; ▁return ▁; ▁} ▁int ▁x Max ▁; ▁x Max ▁= ▁log 2 ▁( ▁N ▁) ▁; ▁int ▁y Max ▁; ▁y Max ▁= ▁( ▁log 2 ▁( ▁N ▁) ▁/ ▁log 2 ▁( ▁5.0 ▁) ▁) ▁; ▁for ▁( ▁long ▁long ▁i ▁= ▁1 ▁; ▁i ▁<= ▁x Max ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁long ▁long ▁j ▁= ▁1 ▁; ▁j ▁<= ▁y Max ▁; ▁j ▁++ ▁) ▁{ ▁long ▁long ▁a ▁= ▁power ▁( ▁2 ▁, ▁i ▁) ▁; ▁long ▁long ▁b ▁= ▁power ▁( ▁5 ▁, ▁j ▁) ▁; ▁if ▁( ▁a ▁+ ▁b ▁== ▁N ▁) ▁{ ▁c out ▁<< ▁i ▁<< ▁" ▁" ▁<< ▁j ▁<< ▁end l ▁; ▁return ▁; ▁} ▁} ▁} ▁c out ▁<< ▁-1 ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁long ▁long ▁N ▁= ▁12 9 ▁; ▁find Val X _ Y ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁string ▁toggle Query ▁( ▁string ▁str ▁, ▁int ▁Q ▁[ ▁] ▁[ ▁2 ▁] ▁, ▁int ▁M ▁) ▁{ ▁int ▁N ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁int ▁prefix Cnt ▁[ ▁N ▁+ ▁1 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁M ▁; ▁i ▁++ ▁) ▁{ ▁prefix Cnt ▁[ ▁Q ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁] ▁+= ▁1 ▁; ▁prefix Cnt ▁[ ▁Q ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁+ ▁1 ▁] ▁-= ▁1 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁prefix Cnt ▁[ ▁i ▁] ▁+= ▁prefix Cnt ▁[ ▁i ▁- ▁1 ▁] ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁prefix Cnt ▁[ ▁i ▁] ▁% ▁2 ▁) ▁{ ▁str ▁[ ▁i ▁] ▁= ▁'1' ▁- ▁str ▁[ ▁i ▁] ▁+ ▁'0' ▁; ▁} ▁} ▁return ▁str ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁"1 0101 0" ▁; ▁int ▁Q ▁[ ▁] ▁[ ▁2 ▁] ▁= ▁{ ▁{ ▁0 ▁, ▁1 ▁} ▁, ▁{ ▁2 ▁, ▁5 ▁} ▁, ▁{ ▁2 ▁, ▁3 ▁} ▁, ▁{ ▁1 ▁, ▁4 ▁} ▁, ▁{ ▁0 ▁, ▁5 ▁} ▁} ▁; ▁int ▁M ▁= ▁sizeof ▁( ▁Q ▁) ▁/ ▁sizeof ▁( ▁Q ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁toggle Query ▁( ▁str ▁, ▁Q ▁, ▁M ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max i Con secutive Sub array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁max i ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁int ▁cnt ▁= ▁1 ▁, ▁j ▁; ▁for ▁( ▁j ▁= ▁i ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁j ▁+ ▁1 ▁] ▁== ▁arr ▁[ ▁j ▁] ▁+ ▁1 ▁) ▁{ ▁cnt ▁++ ▁; ▁} ▁else ▁{ ▁break ▁; ▁} ▁} ▁max i ▁= ▁max ▁( ▁max i ▁, ▁cnt ▁) ▁; ▁i ▁= ▁j ▁; ▁} ▁return ▁max i ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁11 ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁4 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁2 ▁, ▁3 ▁, ▁5 ▁, ▁6 ▁, ▁7 ▁} ▁; ▁c out ▁<< ▁max i Con secutive Sub array ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁count Rem ov able Elem ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁hash ▁[ ▁N ▁+ ▁1 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁int ▁m ex ▁= ▁N ▁+ ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁<= ▁N ▁) ▁hash ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁= ▁1 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁hash ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁m ex ▁= ▁i ▁; ▁break ▁; ▁} ▁} ▁c out ▁<< ▁N ▁- ▁( ▁m ex ▁- ▁1 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁5 ▁, ▁1 ▁, ▁6 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁count Rem ov able Elem ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print Indexes ▁( ▁string ▁str ▁) ▁{ ▁int ▁N ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁int ▁cnt Freq ▁[ ▁256 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁cnt Freq ▁[ ▁str ▁[ ▁i ▁] ▁] ▁++ ▁; ▁} ▁int ▁cnt Left Freq ▁[ ▁256 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁int ▁cnt Left ▁= ▁0 ▁; ▁int ▁cnt Right ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁str ▁[ ▁i ▁] ▁- ▁1 ▁; ▁j ▁>= ▁0 ▁; ▁j ▁-- ▁) ▁{ ▁cnt Left ▁+= ▁cnt Left Freq ▁[ ▁j ▁] ▁; ▁cnt Right ▁+= ▁cnt Freq ▁[ ▁j ▁] ▁- ▁cnt Left Freq ▁[ ▁j ▁] ▁; ▁} ▁cnt Left Freq ▁[ ▁str ▁[ ▁i ▁] ▁] ▁++ ▁; ▁if ▁( ▁cnt Left ▁== ▁cnt Right ▁&& ▁cnt Left ▁!= ▁0 ▁) ▁{ ▁c out ▁<< ▁i ▁<< ▁" ▁" ▁; ▁} ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁a ab ac d ab bb ▁" ▁; ▁print Indexes ▁( ▁str ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁check Concat ▁( ▁string ▁str 1 ▁, ▁string ▁str 2 ▁) ▁{ ▁int ▁N ▁= ▁str 1 ▁. ▁length ▁( ▁) ▁; ▁int ▁M ▁= ▁str 2 ▁. ▁length ▁( ▁) ▁; ▁if ▁( ▁N ▁% ▁M ▁!= ▁0 ▁) ▁{ ▁return ▁false ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁str 1 ▁[ ▁i ▁] ▁!= ▁str 2 ▁[ ▁i ▁% ▁M ▁] ▁) ▁{ ▁return ▁false ▁; ▁} ▁} ▁return ▁true ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str 1 ▁= ▁" ▁abc abc abc ▁" ▁; ▁string ▁str 2 ▁= ▁" ▁abc ▁" ▁; ▁if ▁( ▁check Concat ▁( ▁str 1 ▁, ▁str 2 ▁) ▁) ▁{ ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁" ▁No ▁" ▁; ▁} ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Position ▁( ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁mat ▁) ▁{ ▁int ▁n ▁= ▁mat ▁. ▁size ▁( ▁) ▁; ▁int ▁m ▁= ▁mat ▁[ ▁0 ▁] ▁. ▁size ▁( ▁) ▁; ▁vector ▁< ▁int ▁> ▁row ▁( ▁n ▁) ▁; ▁vector ▁< ▁int ▁> ▁col ▁( ▁m ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁m ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁== ▁1 ▁) ▁{ ▁col ▁[ ▁j ▁] ▁++ ▁; ▁row ▁[ ▁i ▁] ▁++ ▁; ▁} ▁} ▁} ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁m ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁row ▁[ ▁i ▁] ▁== ▁col ▁[ ▁j ▁] ▁) ▁{ ▁count ▁++ ▁; ▁} ▁} ▁} ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁mat ▁= ▁{ ▁{ ▁0 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁1 ▁} ▁} ▁; ▁c out ▁<< ▁( ▁count Position ▁( ▁mat ▁) ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁position ▁( ▁int ▁arr ▁[ ▁] ▁[ ▁2 ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁pos ▁= ▁-1 ▁; ▁int ▁count ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁<= ▁arr ▁[ ▁j ▁] ▁[ ▁0 ▁] ▁&& ▁arr ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁>= ▁arr ▁[ ▁j ▁] ▁[ ▁1 ▁] ▁) ▁{ ▁count ▁++ ▁; ▁} ▁} ▁if ▁( ▁count ▁== ▁N ▁) ▁{ ▁pos ▁= ▁i ▁; ▁} ▁} ▁if ▁( ▁pos ▁== ▁-1 ▁) ▁{ ▁c out ▁<< ▁pos ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁pos ▁+ ▁1 ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁[ ▁2 ▁] ▁= ▁{ ▁{ ▁3 ▁, ▁3 ▁} ▁, ▁{ ▁1 ▁, ▁3 ▁} ▁, ▁{ ▁2 ▁, ▁2 ▁} ▁, ▁{ ▁2 ▁, ▁3 ▁} ▁, ▁{ ▁1 ▁, ▁2 ▁} ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁position ▁( ▁arr ▁, ▁N ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁mini ▁= ▁105 ▁, ▁ans ▁, ▁n ▁; ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁g ▁( ▁100 ▁) ▁; ▁int ▁size ▁[ ▁100 ▁] ▁; ▁void ▁create _ graph ▁( ▁) ▁{ ▁g ▁[ ▁1 ▁] ▁. ▁push _ back ▁( ▁2 ▁) ▁; ▁g ▁[ ▁2 ▁] ▁. ▁push _ back ▁( ▁1 ▁) ▁; ▁g ▁[ ▁1 ▁] ▁. ▁push _ back ▁( ▁3 ▁) ▁; ▁g ▁[ ▁3 ▁] ▁. ▁push _ back ▁( ▁1 ▁) ▁; ▁g ▁[ ▁1 ▁] ▁. ▁push _ back ▁( ▁4 ▁) ▁; ▁g ▁[ ▁4 ▁] ▁. ▁push _ back ▁( ▁1 ▁) ▁; ▁g ▁[ ▁2 ▁] ▁. ▁push _ back ▁( ▁5 ▁) ▁; ▁g ▁[ ▁5 ▁] ▁. ▁push _ back ▁( ▁2 ▁) ▁; ▁g ▁[ ▁2 ▁] ▁. ▁push _ back ▁( ▁6 ▁) ▁; ▁g ▁[ ▁6 ▁] ▁. ▁push _ back ▁( ▁2 ▁) ▁; ▁} ▁void ▁dfs ▁( ▁int ▁node ▁, ▁int ▁parent ▁) ▁{ ▁size ▁[ ▁node ▁] ▁= ▁1 ▁; ▁int ▁mx ▁= ▁0 ▁; ▁for ▁( ▁int ▁y ▁: ▁g ▁[ ▁node ▁] ▁) ▁{ ▁if ▁( ▁y ▁== ▁parent ▁) ▁continue ▁; ▁dfs ▁( ▁y ▁, ▁node ▁) ▁; ▁size ▁[ ▁node ▁] ▁+= ▁size ▁[ ▁y ▁] ▁; ▁mx ▁= ▁max ▁( ▁mx ▁, ▁size ▁[ ▁y ▁] ▁) ▁; ▁} ▁mx ▁= ▁max ▁( ▁mx ▁, ▁n ▁- ▁size ▁[ ▁node ▁] ▁) ▁; ▁if ▁( ▁mx ▁< ▁mini ▁) ▁{ ▁mini ▁= ▁mx ▁; ▁ans ▁= ▁node ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁n ▁= ▁6 ▁; ▁create _ graph ▁( ▁) ▁; ▁dfs ▁( ▁1 ▁, ▁-1 ▁) ▁; ▁c out ▁<< ▁ans ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁isP ossible ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁mn ▁= ▁INT _ MAX ▁; ▁int ▁B ▁[ ▁N ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁mn ▁= ▁min ▁( ▁mn ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁B ▁[ ▁i ▁] ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁sort ▁( ▁arr ▁, ▁arr ▁+ ▁N ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁!= ▁B ▁[ ▁i ▁] ▁) ▁{ ▁if ▁( ▁B ▁[ ▁i ▁] ▁% ▁mn ▁!= ▁0 ▁) ▁{ ▁c out ▁<< ▁" ▁No ▁" ▁; ▁return ▁; ▁} ▁} ▁} ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁return ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁6 ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁3 ▁, ▁6 ▁, ▁6 ▁, ▁2 ▁, ▁9 ▁} ▁; ▁isP ossible ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁check Arr In Stack ▁( ▁stack ▁< ▁int ▁> ▁s ▁, ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁map ▁< ▁int ▁, ▁int ▁> ▁freq ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁freq ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁++ ▁; ▁while ▁( ▁! ▁s ▁. ▁empty ▁( ▁) ▁) ▁{ ▁int ▁po pped Ele ▁= ▁s ▁. ▁top ▁( ▁) ▁; ▁s ▁. ▁pop ▁( ▁) ▁; ▁if ▁( ▁freq ▁[ ▁po pped Ele ▁] ▁) ▁freq ▁[ ▁po pped Ele ▁] ▁-= ▁1 ▁; ▁} ▁if ▁( ▁freq ▁. ▁size ▁( ▁) ▁== ▁0 ▁) ▁return ▁0 ▁; ▁return ▁1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁stack ▁< ▁int ▁> ▁s ▁; ▁s ▁. ▁push ▁( ▁10 ▁) ▁; ▁s ▁. ▁push ▁( ▁20 ▁) ▁; ▁s ▁. ▁push ▁( ▁30 ▁) ▁; ▁s ▁. ▁push ▁( ▁40 ▁) ▁; ▁s ▁. ▁push ▁( ▁50 ▁) ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁20 ▁, ▁30 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁arr ▁/ ▁sizeof ▁arr ▁[ ▁0 ▁] ▁; ▁if ▁( ▁check Arr In Stack ▁( ▁s ▁, ▁arr ▁, ▁n ▁) ▁) ▁c out ▁<< ▁" ▁YES ▁STRNEWLINE ▁" ▁; ▁else ▁c out ▁<< ▁" ▁NO ▁STRNEWLINE ▁" ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁string ▁pal indrome Prefix ▁( ▁string ▁S ▁) ▁{ ▁int ▁n ▁= ▁S ▁. ▁size ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁string ▁curr ▁= ▁S ▁. ▁substr ▁( ▁0 ▁, ▁i ▁+ ▁1 ▁) ▁; ▁int ▁l ▁= ▁0 ▁, ▁r ▁= ▁curr ▁. ▁size ▁( ▁) ▁- ▁1 ▁; ▁bool ▁is _ pal indrome ▁= ▁1 ▁; ▁while ▁( ▁l ▁< ▁r ▁) ▁{ ▁if ▁( ▁curr ▁[ ▁l ▁] ▁!= ▁curr ▁[ ▁r ▁] ▁) ▁{ ▁is _ pal indrome ▁= ▁0 ▁; ▁break ▁; ▁} ▁l ▁++ ▁; ▁r ▁-- ▁; ▁} ▁if ▁( ▁is _ pal indrome ▁) ▁return ▁curr ▁; ▁} ▁return ▁" ▁" ▁; ▁} ▁string ▁max Pal indrome ▁( ▁string ▁S ▁) ▁{ ▁int ▁n ▁= ▁S ▁. ▁size ▁( ▁) ▁; ▁if ▁( ▁n ▁<= ▁1 ▁) ▁{ ▁return ▁S ▁; ▁} ▁string ▁pre ▁= ▁" ▁" ▁, ▁suff ▁= ▁" ▁" ▁; ▁int ▁i ▁= ▁0 ▁, ▁j ▁= ▁n ▁- ▁1 ▁; ▁while ▁( ▁S ▁[ ▁i ▁] ▁== ▁S ▁[ ▁j ▁] ▁&& ▁i ▁< ▁j ▁) ▁{ ▁i ▁++ ▁; ▁j ▁-- ▁; ▁} ▁i ▁-- ▁; ▁j ▁++ ▁; ▁pre ▁= ▁S ▁. ▁substr ▁( ▁0 ▁, ▁i ▁+ ▁1 ▁) ▁; ▁suff ▁= ▁S ▁. ▁substr ▁( ▁j ▁) ▁; ▁if ▁( ▁j ▁- ▁i ▁== ▁1 ▁) ▁{ ▁return ▁pre ▁+ ▁suff ▁; ▁} ▁if ▁( ▁j ▁- ▁i ▁== ▁2 ▁) ▁{ ▁string ▁mid _ char ▁= ▁S ▁. ▁substr ▁( ▁i ▁+ ▁1 ▁, ▁1 ▁) ▁; ▁return ▁pre ▁+ ▁mid _ char ▁+ ▁suff ▁; ▁} ▁string ▁rem _ str ▁= ▁S ▁. ▁substr ▁( ▁i ▁+ ▁1 ▁, ▁j ▁- ▁i ▁- ▁1 ▁) ▁; ▁string ▁pre _ of _ rem _ str ▁= ▁pal indrome Prefix ▁( ▁rem _ str ▁) ▁; ▁reverse ▁( ▁rem _ str ▁. ▁begin ▁( ▁) ▁, ▁rem _ str ▁. ▁end ▁( ▁) ▁) ▁; ▁string ▁suff _ of _ rem _ str ▁= ▁pal indrome Prefix ▁( ▁rem _ str ▁) ▁; ▁if ▁( ▁pre _ of _ rem _ str ▁. ▁size ▁( ▁) ▁>= ▁suff _ of _ rem _ str ▁. ▁size ▁( ▁) ▁) ▁{ ▁return ▁pre ▁+ ▁pre _ of _ rem _ str ▁+ ▁suff ▁; ▁} ▁else ▁{ ▁return ▁pre ▁+ ▁suff _ of _ rem _ str ▁+ ▁suff ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁S ▁= ▁" ▁g eek s for s ke eg ▁" ▁; ▁c out ▁<< ▁max Pal indrome ▁( ▁S ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Sum ▁( ▁string ▁s ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁s ▁. ▁size ▁( ▁) ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁s ▁[ ▁i ▁] ▁== ▁s ▁[ ▁j ▁] ▁) ▁{ ▁sum ▁+= ▁( ▁j ▁- ▁i ▁) ▁; ▁} ▁} ▁} ▁return ▁sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁" ▁tt t ▁" ▁; ▁c out ▁<< ▁find Sum ▁( ▁s ▁) ▁<< ▁end l ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁min _ f lips ▁( ▁string ▁& ▁str ▁, ▁int ▁k ▁) ▁{ ▁if ▁( ▁str ▁. ▁size ▁( ▁) ▁== ▁0 ▁) ▁return ▁0 ▁; ▁int ▁ans ▁= ▁0 ▁; ▁int ▁cnt _ zeros ▁= ▁0 ▁; ▁for ▁( ▁char ▁ch ▁: ▁str ▁) ▁{ ▁if ▁( ▁ch ▁== ▁'0' ▁) ▁{ ▁++ ▁cnt _ zeros ▁; ▁} ▁else ▁{ ▁cnt _ zeros ▁= ▁0 ▁; ▁} ▁if ▁( ▁cnt _ zeros ▁== ▁k ▁) ▁{ ▁++ ▁ans ▁; ▁cnt _ zeros ▁= ▁0 ▁; ▁} ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" 111 000000 11" ▁; ▁int ▁k ▁= ▁3 ▁; ▁c out ▁<< ▁min _ f lips ▁( ▁str ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁count ▁( ▁int ▁N ▁) ▁{ ▁if ▁( ▁N ▁== ▁1 ▁) ▁{ ▁c out ▁<< ▁( ▁10 ▁) ▁<< ▁end l ▁; ▁return ▁; ▁} ▁int ▁dp ▁[ ▁N ▁] ▁[ ▁10 ▁] ▁; ▁mem set ▁( ▁dp ▁, ▁0 ▁, ▁sizeof ▁( ▁dp ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁10 ▁; ▁i ▁++ ▁) ▁dp ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁int ▁temp ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁10 ▁; ▁j ▁++ ▁) ▁temp ▁+= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁10 ▁; ▁j ▁++ ▁) ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁temp ▁- ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁; ▁} ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁10 ▁; ▁i ▁++ ▁) ▁ans ▁+= ▁dp ▁[ ▁N ▁- ▁1 ▁] ▁[ ▁i ▁] ▁; ▁c out ▁<< ▁ans ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁2 ▁; ▁count ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁ctr ▁= ▁0 ▁; ▁int ▁find ▁( ▁vector ▁< ▁int ▁> ▁& ▁parent ▁, ▁int ▁x ▁) ▁{ ▁if ▁( ▁parent ▁[ ▁x ▁] ▁== ▁x ▁) ▁return ▁x ▁; ▁parent ▁[ ▁x ▁] ▁= ▁find ▁( ▁parent ▁, ▁parent ▁[ ▁x ▁] ▁) ▁; ▁return ▁parent ▁[ ▁x ▁] ▁; ▁} ▁void ▁set Union ▁( ▁vector ▁< ▁int ▁> ▁& ▁parent ▁, ▁vector ▁< ▁int ▁> ▁& ▁rank ▁, ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁int ▁parent x ▁= ▁find ▁( ▁parent ▁, ▁x ▁) ▁; ▁int ▁parent y ▁= ▁find ▁( ▁parent ▁, ▁y ▁) ▁; ▁if ▁( ▁parent y ▁== ▁parent x ▁) ▁return ▁; ▁ctr ▁-- ▁; ▁if ▁( ▁rank ▁[ ▁parent x ▁] ▁< ▁rank ▁[ ▁parent y ▁] ▁) ▁{ ▁parent ▁[ ▁parent x ▁] ▁= ▁parent y ▁; ▁} ▁else ▁if ▁( ▁rank ▁[ ▁parent x ▁] ▁> ▁rank ▁[ ▁parent y ▁] ▁) ▁{ ▁parent ▁[ ▁parent y ▁] ▁= ▁parent x ▁; ▁} ▁else ▁{ ▁parent ▁[ ▁parent x ▁] ▁= ▁parent y ▁; ▁rank ▁[ ▁parent y ▁] ▁++ ▁; ▁} ▁} ▁vector ▁< ▁int ▁> ▁solve ▁( ▁int ▁n ▁, ▁int ▁m ▁, ▁vector ▁< ▁pair ▁< ▁int ▁, ▁int ▁> ▁> ▁& ▁query ▁) ▁{ ▁vector ▁< ▁int ▁> ▁result ▁( ▁query ▁. ▁size ▁( ▁) ▁) ▁; ▁vector ▁< ▁int ▁> ▁parent ▁( ▁n ▁* ▁m ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁* ▁m ▁; ▁i ▁++ ▁) ▁parent ▁[ ▁i ▁] ▁= ▁i ▁; ▁vector ▁< ▁int ▁> ▁rank ▁( ▁n ▁* ▁m ▁, ▁1 ▁) ▁; ▁vector ▁< ▁bool ▁> ▁grid ▁( ▁n ▁* ▁m ▁, ▁0 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁query ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁int ▁x ▁= ▁query ▁[ ▁i ▁] ▁. ▁first ▁; ▁int ▁y ▁= ▁query ▁[ ▁i ▁] ▁. ▁second ▁; ▁if ▁( ▁grid ▁[ ▁m ▁* ▁x ▁+ ▁y ▁] ▁== ▁1 ▁) ▁{ ▁result ▁[ ▁i ▁] ▁= ▁ctr ▁; ▁continue ▁; ▁} ▁grid ▁[ ▁m ▁* ▁x ▁+ ▁y ▁] ▁= ▁1 ▁; ▁ctr ▁++ ▁; ▁if ▁( ▁x ▁> ▁0 ▁and ▁grid ▁[ ▁m ▁* ▁( ▁x ▁- ▁1 ▁) ▁+ ▁y ▁] ▁== ▁1 ▁) ▁set Union ▁( ▁parent ▁, ▁rank ▁, ▁m ▁* ▁x ▁+ ▁y ▁, ▁m ▁* ▁( ▁x ▁- ▁1 ▁) ▁+ ▁y ▁) ▁; ▁if ▁( ▁y ▁> ▁0 ▁and ▁grid ▁[ ▁m ▁* ▁( ▁x ▁) ▁+ ▁y ▁- ▁1 ▁] ▁== ▁1 ▁) ▁set Union ▁( ▁parent ▁, ▁rank ▁, ▁m ▁* ▁x ▁+ ▁y ▁, ▁m ▁* ▁( ▁x ▁) ▁+ ▁y ▁- ▁1 ▁) ▁; ▁if ▁( ▁x ▁< ▁n ▁- ▁1 ▁and ▁grid ▁[ ▁m ▁* ▁( ▁x ▁+ ▁1 ▁) ▁+ ▁y ▁] ▁== ▁1 ▁) ▁set Union ▁( ▁parent ▁, ▁rank ▁, ▁m ▁* ▁x ▁+ ▁y ▁, ▁m ▁* ▁( ▁x ▁+ ▁1 ▁) ▁+ ▁y ▁) ▁; ▁if ▁( ▁y ▁< ▁m ▁- ▁1 ▁and ▁grid ▁[ ▁m ▁* ▁( ▁x ▁) ▁+ ▁y ▁+ ▁1 ▁] ▁== ▁1 ▁) ▁set Union ▁( ▁parent ▁, ▁rank ▁, ▁m ▁* ▁x ▁+ ▁y ▁, ▁m ▁* ▁( ▁x ▁) ▁+ ▁y ▁+ ▁1 ▁) ▁; ▁result ▁[ ▁i ▁] ▁= ▁ctr ▁; ▁} ▁return ▁result ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁3 ▁, ▁M ▁= ▁3 ▁, ▁K ▁= ▁4 ▁; ▁vector ▁< ▁pair ▁< ▁int ▁, ▁int ▁> ▁> ▁query ▁= ▁{ ▁{ ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁1 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁0 ▁} ▁, ▁{ ▁1 ▁, ▁2 ▁} ▁} ▁; ▁vector ▁< ▁int ▁> ▁result ▁= ▁solve ▁( ▁N ▁, ▁M ▁, ▁query ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁K ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁result ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁cnt ▁= ▁0 ▁; ▁void ▁dfs ▁( ▁int ▁* ▁val ▁, ▁int ▁* ▁cost ▁, ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁& ▁tr ▁, ▁int ▁u ▁, ▁int ▁s ▁) ▁{ ▁s ▁= ▁s ▁+ ▁cost ▁[ ▁u ▁] ▁; ▁if ▁( ▁s ▁< ▁0 ▁) ▁s ▁= ▁0 ▁; ▁if ▁( ▁s ▁> ▁val ▁[ ▁u ▁] ▁) ▁return ▁; ▁cnt ▁++ ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁tr ▁[ ▁u ▁] ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁dfs ▁( ▁val ▁, ▁cost ▁, ▁tr ▁, ▁tr ▁[ ▁u ▁] ▁[ ▁i ▁] ▁, ▁s ▁) ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁9 ▁; ▁int ▁val ▁[ ▁] ▁= ▁{ ▁88 ▁, ▁22 ▁, ▁83 ▁, ▁14 ▁, ▁95 ▁, ▁91 ▁, ▁98 ▁, ▁53 ▁, ▁11 ▁} ▁; ▁int ▁cost ▁[ ▁] ▁= ▁{ ▁-1 ▁, ▁24 ▁, ▁- 8 ▁, ▁67 ▁, ▁64 ▁, ▁65 ▁, ▁12 ▁, ▁- 80 ▁, ▁8 ▁} ▁; ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁tr ▁( ▁n ▁+ ▁1 ▁) ▁; ▁tr ▁[ ▁0 ▁] ▁. ▁push _ back ▁( ▁3 ▁) ▁; ▁tr ▁[ ▁0 ▁] ▁. ▁push _ back ▁( ▁4 ▁) ▁; ▁tr ▁[ ▁4 ▁] ▁. ▁push _ back ▁( ▁6 ▁) ▁; ▁tr ▁[ ▁6 ▁] ▁. ▁push _ back ▁( ▁2 ▁) ▁; ▁tr ▁[ ▁2 ▁] ▁. ▁push _ back ▁( ▁1 ▁) ▁; ▁tr ▁[ ▁2 ▁] ▁. ▁push _ back ▁( ▁8 ▁) ▁; ▁tr ▁[ ▁8 ▁] ▁. ▁push _ back ▁( ▁5 ▁) ▁; ▁tr ▁[ ▁5 ▁] ▁. ▁push _ back ▁( ▁7 ▁) ▁; ▁dfs ▁( ▁val ▁, ▁cost ▁, ▁tr ▁, ▁0 ▁, ▁0 ▁) ▁; ▁c out ▁<< ▁n ▁- ▁cnt ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁vector ▁< ▁int ▁> ▁find L argest ▁( ▁int ▁beg ▁, ▁int ▁end ▁, ▁vector ▁< ▁int ▁> ▁arr ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁beg ▁== ▁end ▁) ▁{ ▁vector ▁< ▁int ▁> ▁compared ▁( ▁n ▁, ▁0 ▁) ▁; ▁compared ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁compared ▁[ ▁1 ▁] ▁= ▁arr ▁[ ▁beg ▁] ▁; ▁return ▁compared ▁; ▁} ▁vector ▁< ▁int ▁> ▁compared 1 ▁= ▁find L argest ▁( ▁beg ▁, ▁( ▁beg ▁+ ▁end ▁) ▁/ ▁2 ▁, ▁arr ▁, ▁n ▁) ▁; ▁vector ▁< ▁int ▁> ▁compared 2 ▁= ▁find L argest ▁( ▁( ▁beg ▁+ ▁end ▁) ▁/ ▁2 ▁+ ▁1 ▁, ▁end ▁, ▁arr ▁, ▁n ▁) ▁; ▁if ▁( ▁compared 1 ▁[ ▁1 ▁] ▁> ▁compared 2 ▁[ ▁1 ▁] ▁) ▁{ ▁int ▁k ▁= ▁compared 1 ▁[ ▁0 ▁] ▁+ ▁1 ▁; ▁compared 1 ▁[ ▁0 ▁] ▁= ▁k ▁; ▁compared 1 ▁[ ▁k ▁] ▁= ▁compared 2 ▁[ ▁1 ▁] ▁; ▁return ▁compared 1 ▁; ▁} ▁else ▁{ ▁int ▁k ▁= ▁compared 2 ▁[ ▁0 ▁] ▁+ ▁1 ▁; ▁compared 2 ▁[ ▁0 ▁] ▁= ▁k ▁; ▁compared 2 ▁[ ▁k ▁] ▁= ▁compared 1 ▁[ ▁1 ▁] ▁; ▁return ▁compared 2 ▁; ▁} ▁} ▁void ▁find Second L argest ▁( ▁int ▁end ▁, ▁vector ▁< ▁int ▁> ▁arr ▁) ▁{ ▁vector ▁< ▁int ▁> ▁compared 1 ▁= ▁find L argest ▁( ▁0 ▁, ▁end ▁- ▁1 ▁, ▁arr ▁, ▁end ▁) ▁; ▁vector ▁< ▁int ▁> ▁compared 2 ▁= ▁find L argest ▁( ▁2 ▁, ▁compared 1 ▁[ ▁0 ▁] ▁+ ▁2 ▁, ▁compared 1 ▁, ▁compared 1 ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁compared 2 ▁[ ▁1 ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁10 ▁; ▁vector ▁< ▁int ▁> ▁arr ▁{ ▁20 ▁, ▁199 0 ▁, ▁12 ▁, ▁11 10 ▁, ▁1 ▁, ▁59 ▁, ▁12 ▁, ▁15 ▁, ▁120 ▁, ▁11 10 ▁} ▁; ▁find Second L argest ▁( ▁N ▁, ▁arr ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁Count sub String ▁( ▁char ▁str ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁c ▁= ▁0 ▁; ▁for ▁( ▁int ▁len ▁= ▁1 ▁; ▁len ▁<= ▁n ▁; ▁len ▁++ ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁n ▁- ▁len ▁; ▁i ▁++ ▁) ▁{ ▁int ▁j ▁= ▁i ▁+ ▁len ▁- ▁1 ▁; ▁char ▁temp ▁= ▁str ▁[ ▁i ▁] ▁, ▁f ▁= ▁0 ▁; ▁if ▁( ▁j ▁== ▁i ▁) ▁{ ▁c ▁++ ▁; ▁continue ▁; ▁} ▁int ▁k ▁= ▁i ▁+ ▁1 ▁; ▁while ▁( ▁temp ▁> ▁str ▁[ ▁k ▁] ▁&& ▁k ▁<= ▁j ▁) ▁{ ▁temp ▁= ▁str ▁[ ▁k ▁] ▁; ▁k ▁++ ▁; ▁} ▁if ▁( ▁k ▁> ▁j ▁) ▁{ ▁c ▁++ ▁; ▁f ▁= ▁2 ▁; ▁} ▁while ▁( ▁temp ▁< ▁str ▁[ ▁k ▁] ▁&& ▁k ▁<= ▁j ▁&& ▁f ▁!= ▁2 ▁) ▁{ ▁temp ▁= ▁str ▁[ ▁k ▁] ▁; ▁k ▁++ ▁; ▁} ▁if ▁( ▁k ▁> ▁j ▁&& ▁f ▁!= ▁2 ▁) ▁{ ▁c ▁++ ▁; ▁f ▁= ▁0 ▁; ▁} ▁} ▁} ▁return ▁c ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁char ▁str ▁[ ▁] ▁= ▁" ▁b ade ▁" ▁; ▁c out ▁<< ▁Count sub String ▁( ▁str ▁, ▁str len ▁( ▁str ▁) ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁vector ▁< ▁int ▁> ▁generate Sequence ▁( ▁int ▁* ▁freq ▁, ▁int ▁n ▁) ▁{ ▁map ▁< ▁int ▁, ▁int ▁> ▁m ▁; ▁int ▁total ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁m ▁[ ▁i ▁] ▁= ▁freq ▁[ ▁i ▁] ▁; ▁total ▁+= ▁freq ▁[ ▁i ▁] ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁m ▁[ ▁i ▁] ▁) ▁{ ▁vector ▁< ▁int ▁> ▁sequence ▁; ▁auto ▁m copy ▁= ▁m ▁; ▁m copy ▁[ ▁i ▁] ▁-- ▁; ▁sequence ▁. ▁push _ back ▁( ▁i ▁) ▁; ▁int ▁last ▁= ▁i ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁total ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁m copy ▁[ ▁last ▁- ▁1 ▁] ▁) ▁{ ▁m copy ▁[ ▁last ▁- ▁1 ▁] ▁-- ▁; ▁sequence ▁. ▁push _ back ▁( ▁last ▁- ▁1 ▁) ▁; ▁last ▁-- ▁; ▁} ▁else ▁if ▁( ▁m copy ▁[ ▁last ▁+ ▁1 ▁] ▁) ▁{ ▁m copy ▁[ ▁last ▁+ ▁1 ▁] ▁-- ▁; ▁sequence ▁. ▁push _ back ▁( ▁last ▁+ ▁1 ▁) ▁; ▁last ▁++ ▁; ▁} ▁else ▁break ▁; ▁} ▁if ▁( ▁sequence ▁. ▁size ▁( ▁) ▁== ▁total ▁) ▁{ ▁return ▁sequence ▁; ▁} ▁} ▁} ▁vector ▁< ▁int ▁> ▁empty ▁; ▁return ▁empty ▁; ▁} ▁void ▁Print Sequence ▁( ▁int ▁freq ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁vector ▁< ▁int ▁> ▁sequence ▁= ▁generate Sequence ▁( ▁freq ▁, ▁n ▁) ▁; ▁if ▁( ▁sequence ▁. ▁size ▁( ▁) ▁== ▁0 ▁) ▁{ ▁c out ▁<< ▁" ▁- ▁1" ▁; ▁} ▁else ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁sequence ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁c out ▁<< ▁sequence ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁} ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁freq ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁2 ▁, ▁2 ▁, ▁3 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁5 ▁; ▁Print Sequence ▁( ▁freq ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁median Change ▁( ▁vector ▁< ▁int ▁> ▁& ▁arr 1 ▁, ▁vector ▁< ▁int ▁> ▁& ▁arr 2 ▁) ▁{ ▁int ▁N ▁= ▁arr 1 ▁. ▁size ▁( ▁) ▁; ▁vector ▁< ▁float ▁> ▁median ▁; ▁if ▁( ▁N ▁& ▁1 ▁) ▁{ ▁median ▁. ▁push _ back ▁( ▁arr 1 ▁[ ▁N ▁/ ▁2 ▁] ▁* ▁1.0 ▁) ▁; ▁} ▁else ▁{ ▁median ▁. ▁push _ back ▁( ▁( ▁arr 1 ▁[ ▁N ▁/ ▁2 ▁] ▁+ ▁arr 1 ▁[ ▁( ▁N ▁- ▁1 ▁) ▁/ ▁2 ▁] ▁) ▁/ ▁2.0 ▁) ▁; ▁} ▁for ▁( ▁auto ▁& ▁x ▁: ▁arr 2 ▁) ▁{ ▁auto ▁it ▁= ▁find ▁( ▁arr 1 ▁. ▁begin ▁( ▁) ▁, ▁arr 1 ▁. ▁end ▁( ▁) ▁, ▁x ▁) ▁; ▁arr 1 ▁. ▁erase ▁( ▁it ▁) ▁; ▁N ▁-- ▁; ▁if ▁( ▁N ▁& ▁1 ▁) ▁{ ▁median ▁. ▁push _ back ▁( ▁arr 1 ▁[ ▁N ▁/ ▁2 ▁] ▁* ▁1.0 ▁) ▁; ▁} ▁else ▁{ ▁median ▁. ▁push _ back ▁( ▁( ▁arr 1 ▁[ ▁N ▁/ ▁2 ▁] ▁+ ▁arr 1 ▁[ ▁( ▁N ▁- ▁1 ▁) ▁/ ▁2 ▁] ▁) ▁/ ▁2.0 ▁) ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁median ▁. ▁size ▁( ▁) ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁c out ▁<< ▁median ▁[ ▁i ▁+ ▁1 ▁] ▁- ▁median ▁[ ▁i ▁] ▁<< ▁' ▁' ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁int ▁> ▁arr 1 ▁= ▁{ ▁2 ▁, ▁4 ▁, ▁6 ▁, ▁8 ▁, ▁10 ▁} ▁; ▁vector ▁< ▁int ▁> ▁arr 2 ▁= ▁{ ▁4 ▁, ▁6 ▁} ▁; ▁median Change ▁( ▁arr 1 ▁, ▁arr 2 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Fac ▁( ▁int ▁n ▁) ▁{ ▁int ▁m ▁= ▁n ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁( ▁i ▁* ▁i ▁) ▁<= ▁m ▁; ▁++ ▁i ▁) ▁{ ▁int ▁total ▁= ▁0 ▁; ▁while ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁{ ▁n ▁/= ▁i ▁; ▁++ ▁total ▁; ▁} ▁int ▁temp ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁( ▁temp ▁+ ▁j ▁) ▁<= ▁total ▁; ▁++ ▁j ▁) ▁{ ▁temp ▁+= ▁j ▁; ▁++ ▁count ▁; ▁} ▁} ▁if ▁( ▁n ▁!= ▁1 ▁) ▁++ ▁count ▁; ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁24 ▁; ▁c out ▁<< ▁count Fac ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Missing ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁left ▁, ▁int ▁right ▁, ▁int ▁diff ▁) ▁{ ▁if ▁( ▁right ▁<= ▁left ▁) ▁return ▁INT _ MAX ▁; ▁int ▁mid ▁= ▁left ▁+ ▁( ▁right ▁- ▁left ▁) ▁/ ▁2 ▁; ▁if ▁( ▁arr ▁[ ▁mid ▁+ ▁1 ▁] ▁- ▁arr ▁[ ▁mid ▁] ▁!= ▁diff ▁) ▁return ▁( ▁arr ▁[ ▁mid ▁] ▁+ ▁diff ▁) ▁; ▁if ▁( ▁mid ▁> ▁0 ▁&& ▁arr ▁[ ▁mid ▁] ▁- ▁arr ▁[ ▁mid ▁- ▁1 ▁] ▁!= ▁diff ▁) ▁return ▁( ▁arr ▁[ ▁mid ▁- ▁1 ▁] ▁+ ▁diff ▁) ▁; ▁if ▁( ▁arr ▁[ ▁mid ▁] ▁== ▁arr ▁[ ▁0 ▁] ▁+ ▁mid ▁* ▁diff ▁) ▁return ▁find Missing ▁( ▁arr ▁, ▁mid ▁+ ▁1 ▁, ▁right ▁, ▁diff ▁) ▁; ▁return ▁find Missing ▁( ▁arr ▁, ▁left ▁, ▁mid ▁- ▁1 ▁, ▁diff ▁) ▁; ▁} ▁int ▁missing Element ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁sort ▁( ▁arr ▁, ▁arr ▁+ ▁n ▁) ▁; ▁int ▁diff ▁= ▁( ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁- ▁arr ▁[ ▁0 ▁] ▁) ▁/ ▁n ▁; ▁return ▁find Missing ▁( ▁arr ▁, ▁0 ▁, ▁n ▁- ▁1 ▁, ▁diff ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁8 ▁, ▁6 ▁, ▁10 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁missing Element ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁naive _ find _ x ▁( ▁int ▁N ▁) ▁{ ▁int ▁c ▁= ▁0 ▁, ▁i ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁c ▁+= ▁i ▁* ▁i ▁* ▁i ▁; ▁if ▁( ▁c ▁>= ▁N ▁) ▁break ▁; ▁} ▁return ▁i ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁100 ▁; ▁c out ▁<< ▁naive _ find _ x ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁xor Of Sum ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁answer ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁answer ▁^= ▁( ▁a ▁[ ▁i ▁] ▁+ ▁a ▁[ ▁j ▁] ▁) ▁; ▁} ▁return ▁answer ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁3 ▁; ▁int ▁A ▁[ ▁n ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁; ▁c out ▁<< ▁xor Of Sum ▁( ▁A ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁create Hash ▁( ▁set ▁< ▁int ▁> ▁& ▁hash ▁, ▁int ▁max Element ▁) ▁{ ▁int ▁prev ▁= ▁0 ▁, ▁curr ▁= ▁1 ▁; ▁hash ▁. ▁insert ▁( ▁prev ▁) ▁; ▁hash ▁. ▁insert ▁( ▁curr ▁) ▁; ▁while ▁( ▁curr ▁<= ▁max Element ▁) ▁{ ▁int ▁temp ▁= ▁curr ▁+ ▁prev ▁; ▁hash ▁. ▁insert ▁( ▁temp ▁) ▁; ▁prev ▁= ▁curr ▁; ▁curr ▁= ▁temp ▁; ▁} ▁} ▁void ▁fib onacci ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁max _ val ▁= ▁* ▁max _ element ▁( ▁arr ▁, ▁arr ▁+ ▁n ▁) ▁; ▁set ▁< ▁int ▁> ▁hash ▁; ▁create Hash ▁( ▁hash ▁, ▁max _ val ▁) ▁; ▁int ▁minimum ▁= ▁INT _ MAX ▁; ▁int ▁maximum ▁= ▁INT _ MIN ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁hash ▁. ▁find ▁( ▁arr ▁[ ▁i ▁] ▁) ▁!= ▁hash ▁. ▁end ▁( ▁) ▁) ▁{ ▁minimum ▁= ▁min ▁( ▁minimum ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁maximum ▁= ▁max ▁( ▁maximum ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁} ▁c out ▁<< ▁minimum ▁<< ▁" ▁, ▁" ▁<< ▁maximum ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁, ▁7 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁fib onacci ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁permutation ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁set ▁< ▁int ▁> ▁hash ▁; ▁int ▁max Ele ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁hash ▁. ▁insert ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁max Ele ▁= ▁max ▁( ▁max Ele ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁if ▁( ▁max Ele ▁!= ▁n ▁) ▁return ▁false ▁; ▁if ▁( ▁hash ▁. ▁size ▁( ▁) ▁== ▁n ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁5 ▁, ▁3 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁if ▁( ▁permutation ▁( ▁arr ▁, ▁n ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁<< ▁end l ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁check ▁( ▁int ▁m ▁, ▁int ▁n ▁, ▁int ▁arr ▁[ ▁] ▁) ▁{ ▁int ▁desired ▁[ ▁n ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁desired ▁[ ▁i ▁] ▁= ▁m ▁; ▁m ▁-- ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁desired ▁[ ▁i ▁] ▁desired ▁[ ▁i ▁] ▁< ▁1 ▁) ▁{ ▁return ▁false ▁; ▁} ▁} ▁return ▁true ▁; ▁} ▁int ▁min Operations ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁start ▁= ▁( ▁int ▁) ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁; ▁int ▁end ▁= ▁* ▁( ▁max _ element ▁( ▁arr ▁, ▁arr ▁+ ▁n ▁) ▁) ▁+ ▁n ▁; ▁int ▁max _ arr ▁= ▁0 ▁; ▁while ▁( ▁start ▁<= ▁end ▁) ▁{ ▁int ▁mid ▁= ▁( ▁start ▁+ ▁end ▁) ▁/ ▁2 ▁; ▁if ▁( ▁check ▁( ▁mid ▁, ▁n ▁, ▁arr ▁) ▁) ▁{ ▁max _ arr ▁= ▁mid ▁; ▁end ▁= ▁mid ▁- ▁1 ▁; ▁} ▁else ▁{ ▁start ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁} ▁int ▁desired ▁[ ▁n ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁desired ▁[ ▁i ▁] ▁= ▁max _ arr ▁; ▁max _ arr ▁-- ▁; ▁} ▁int ▁operations ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁operations ▁+= ▁( ▁desired ▁[ ▁i ▁] ▁- ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁return ▁operations ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁4 ▁, ▁5 ▁, ▁5 ▁, ▁7 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁min Operations ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁cost To P anag ram ▁( ▁string ▁str ▁, ▁int ▁cost ▁[ ▁] ▁) ▁{ ▁int ▁i ▁, ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁int ▁occurrences ▁[ ▁26 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁occurrences ▁[ ▁str ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁int ▁gain ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁26 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁occurrences ▁[ ▁i ▁] ▁== ▁0 ▁) ▁gain ▁-= ▁( ▁2 ▁* ▁cost ▁[ ▁i ▁] ▁) ▁; ▁else ▁if ▁( ▁occurrences ▁[ ▁i ▁] ▁> ▁1 ▁) ▁gain ▁+= ▁( ▁cost ▁[ ▁i ▁] ▁* ▁( ▁occurrences ▁[ ▁i ▁] ▁- ▁1 ▁) ▁) ▁; ▁} ▁if ▁( ▁gain ▁>= ▁0 ▁) ▁return ▁0 ▁; ▁return ▁( ▁gain ▁* ▁-1 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁cost ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁} ▁; ▁string ▁str ▁= ▁" ▁g eek s forge ek s ▁" ▁; ▁c out ▁<< ▁cost To P anag ram ▁( ▁str ▁, ▁cost ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁str Score ▁( ▁string ▁str ▁[ ▁] ▁, ▁string ▁s ▁, ▁int ▁n ▁) ▁{ ▁unordered _ map ▁< ▁string ▁, ▁int ▁> ▁m ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁m ▁[ ▁str ▁[ ▁i ▁] ▁] ▁= ▁i ▁+ ▁1 ▁; ▁if ▁( ▁m ▁. ▁find ▁( ▁s ▁) ▁== ▁m ▁. ▁end ▁( ▁) ▁) ▁return ▁0 ▁; ▁int ▁score ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁score ▁+= ▁s ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁+ ▁1 ▁; ▁score ▁= ▁score ▁* ▁m ▁[ ▁s ▁] ▁; ▁return ▁score ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁[ ▁] ▁= ▁{ ▁" ▁g eek s forge ek s ▁" ▁, ▁" ▁algorithms ▁" ▁, ▁" ▁stack ▁" ▁} ▁; ▁string ▁s ▁= ▁" ▁algorithms ▁" ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁str ▁) ▁/ ▁sizeof ▁( ▁str ▁[ ▁0 ▁] ▁) ▁; ▁int ▁score ▁= ▁str Score ▁( ▁str ▁, ▁s ▁, ▁n ▁) ▁; ▁c out ▁<< ▁score ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁string ▁replace Pi ▁( ▁string ▁input ▁) ▁{ ▁string ▁output ▁; ▁int ▁size ▁= ▁input ▁. ▁length ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁i ▁+ ▁1 ▁< ▁size ▁and ▁input ▁[ ▁i ▁] ▁== ▁' ▁p ▁' ▁and ▁input ▁[ ▁i ▁+ ▁1 ▁] ▁== ▁' ▁i ▁' ▁) ▁{ ▁output ▁+= ▁" 3.1 4" ▁; ▁i ▁++ ▁; ▁} ▁else ▁{ ▁output ▁+= ▁input ▁[ ▁i ▁] ▁; ▁} ▁} ▁return ▁output ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁input ▁= ▁"2 ▁* ▁pi ▁+ ▁3 ▁* ▁pi ▁= ▁5 ▁* ▁pi ▁" ▁; ▁c out ▁<< ▁replace Pi ▁( ▁input ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁numberOf Elements ▁( ▁int ▁height ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁max _ so _ far ▁= ▁0 ▁; ▁int ▁c oun ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁height ▁[ ▁i ▁] ▁> ▁max _ so _ far ▁) ▁{ ▁max _ so _ far ▁= ▁height ▁[ ▁i ▁] ▁; ▁c oun ▁++ ▁; ▁} ▁} ▁return ▁c oun ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁6 ▁; ▁int ▁height ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁8 ▁, ▁2 ▁, ▁0 ▁, ▁0 ▁, ▁5 ▁} ▁; ▁c out ▁<< ▁numberOf Elements ▁( ▁height ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁getMin ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁res ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁res ▁= ▁min ▁( ▁res ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁return ▁res ▁; ▁} ▁int ▁getMax ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁res ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁res ▁= ▁max ▁( ▁res ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁return ▁res ▁; ▁} ▁int ▁find Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁min ▁= ▁getMin ▁( ▁arr ▁, ▁n ▁) ▁; ▁int ▁max ▁= ▁getMax ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁min ▁+ ▁max ▁; ▁} ▁int ▁find Product ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁min ▁= ▁getMin ▁( ▁arr ▁, ▁n ▁) ▁; ▁int ▁max ▁= ▁getMax ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁min ▁* ▁max ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁12 ▁, ▁1234 ▁, ▁45 ▁, ▁67 ▁, ▁1 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁Sum ▁= ▁" ▁<< ▁find Sum ▁( ▁arr ▁, ▁n ▁) ▁<< ▁end l ▁; ▁c out ▁<< ▁" ▁Product ▁= ▁" ▁<< ▁find Product ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁string ▁sort String ▁( ▁string ▁str ▁, ▁int ▁n ▁) ▁{ ▁string ▁new _ str ▁= ▁" ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁' ▁a ▁' ▁; ▁i ▁<= ▁' ▁z ▁' ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁if ▁( ▁str ▁[ ▁j ▁] ▁== ▁i ▁) ▁new _ str ▁+= ▁str ▁[ ▁j ▁] ▁; ▁return ▁new _ str ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁g eek s forge ek s ▁" ▁; ▁int ▁n ▁= ▁str ▁. ▁size ▁( ▁) ▁; ▁c out ▁<< ▁sort String ▁( ▁str ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁occurrence Days ▁( ▁int ▁n ▁, ▁string ▁first day ▁) ▁{ ▁string ▁days ▁[ ▁] ▁= ▁{ ▁" ▁Monday ▁" ▁, ▁" ▁T uesday ▁" ▁, ▁" ▁Wed nesday ▁" ▁, ▁" ▁Th ursday ▁" ▁, ▁" ▁F riday ▁" ▁, ▁" ▁S aturday ▁" ▁, ▁" ▁Sunday ▁" ▁} ▁; ▁int ▁count ▁[ ▁7 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁7 ▁; ▁i ▁++ ▁) ▁count ▁[ ▁i ▁] ▁= ▁4 ▁; ▁int ▁pos ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁7 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁first day ▁== ▁days ▁[ ▁i ▁] ▁) ▁{ ▁pos ▁= ▁i ▁; ▁break ▁; ▁} ▁} ▁int ▁inc ▁= ▁n ▁- ▁28 ▁; ▁for ▁( ▁int ▁i ▁= ▁pos ▁; ▁i ▁< ▁pos ▁+ ▁inc ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁> ▁6 ▁) ▁count ▁[ ▁i ▁% ▁7 ▁] ▁= ▁5 ▁; ▁else ▁count ▁[ ▁i ▁] ▁= ▁5 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁7 ▁; ▁i ▁++ ▁) ▁{ ▁c out ▁<< ▁days ▁[ ▁i ▁] ▁<< ▁" ▁" ▁<< ▁count ▁[ ▁i ▁] ▁<< ▁end l ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁31 ▁; ▁string ▁first day ▁= ▁" ▁T uesday ▁" ▁; ▁occurrence Days ▁( ▁n ▁, ▁first day ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁# include ▁< ctime > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁getRandom ▁( ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁sr and ▁( ▁time ▁( ▁NULL ▁) ▁) ▁; ▁return ▁( ▁x ▁+ ▁rand ▁( ▁) ▁% ▁( ▁y ▁- ▁x ▁+ ▁1 ▁) ▁) ▁; ▁} ▁int ▁random ized Binary Search ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁l ▁, ▁int ▁r ▁, ▁int ▁x ▁) ▁{ ▁while ▁( ▁l ▁<= ▁r ▁) ▁{ ▁int ▁m ▁= ▁getRandom ▁( ▁l ▁, ▁r ▁) ▁; ▁if ▁( ▁arr ▁[ ▁m ▁] ▁== ▁x ▁) ▁return ▁m ▁; ▁if ▁( ▁arr ▁[ ▁m ▁] ▁< ▁x ▁) ▁l ▁= ▁m ▁+ ▁1 ▁; ▁else ▁r ▁= ▁m ▁- ▁1 ▁; ▁} ▁return ▁-1 ▁; ▁} ▁int ▁main ▁( ▁void ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁10 ▁, ▁40 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁x ▁= ▁10 ▁; ▁int ▁result ▁= ▁random ized Binary Search ▁( ▁arr ▁, ▁0 ▁, ▁n ▁- ▁1 ▁, ▁x ▁) ▁; ▁( ▁result ▁== ▁-1 ▁) ▁? ▁printf ▁( ▁" ▁Element ▁is ▁not ▁present ▁in ▁array ▁" ▁) ▁: ▁printf ▁( ▁" ▁Element ▁is ▁present ▁at ▁index ▁% ▁d ▁" ▁, ▁result ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is Sorted ▁( ▁pair ▁< ▁int ▁, ▁int ▁> ▁* ▁arr ▁, ▁int ▁N ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁. ▁first ▁> ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁. ▁first ▁) ▁{ ▁return ▁false ▁; ▁} ▁} ▁return ▁true ▁; ▁} ▁string ▁isP ossible To Sort ▁( ▁pair ▁< ▁int ▁, ▁int ▁> ▁* ▁arr ▁, ▁int ▁N ▁) ▁{ ▁int ▁group ▁= ▁arr ▁[ ▁0 ▁] ▁. ▁second ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁. ▁second ▁!= ▁group ▁) ▁{ ▁return ▁" ▁Yes ▁" ▁; ▁} ▁} ▁if ▁( ▁is Sorted ▁( ▁arr ▁, ▁N ▁) ▁) ▁{ ▁return ▁" ▁Yes ▁" ▁; ▁} ▁else ▁{ ▁return ▁" ▁No ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁pair ▁< ▁int ▁, ▁int ▁> ▁arr ▁[ ▁] ▁= ▁{ ▁{ ▁34 0000 ▁, ▁2 ▁} ▁, ▁{ ▁45 000 ▁, ▁1 ▁} ▁, ▁{ ▁30000 ▁, ▁2 ▁} ▁, ▁{ ▁50000 ▁, ▁4 ▁} ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁isP ossible To Sort ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁max Len Subset ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁sort ▁( ▁a ▁, ▁a ▁+ ▁n ▁) ▁; ▁int ▁index ▁= ▁0 ▁, ▁maxlen ▁= ▁-1 ▁; ▁int ▁i ▁= ▁0 ▁; ▁while ▁( ▁i ▁< ▁n ▁) ▁{ ▁int ▁j ▁= ▁i ▁; ▁int ▁len ▁= ▁1 ▁; ▁while ▁( ▁j ▁< ▁n ▁- ▁1 ▁) ▁{ ▁if ▁( ▁2 ▁* ▁a ▁[ ▁j ▁] ▁>= ▁a ▁[ ▁j ▁+ ▁1 ▁] ▁) ▁{ ▁len ▁++ ▁; ▁} ▁else ▁break ▁; ▁j ▁++ ▁; ▁} ▁if ▁( ▁maxlen ▁< ▁len ▁) ▁{ ▁maxlen ▁= ▁len ▁; ▁index ▁= ▁i ▁; ▁} ▁j ▁++ ▁; ▁i ▁= ▁j ▁; ▁} ▁i ▁= ▁index ▁; ▁while ▁( ▁maxlen ▁> ▁0 ▁) ▁{ ▁c out ▁<< ▁a ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁maxlen ▁-- ▁; ▁i ▁++ ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁1 ▁, ▁5 ▁, ▁11 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁max Len Subset ▁( ▁a ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁maximum Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁sum ▁; ▁sort ▁( ▁arr ▁, ▁arr ▁+ ▁N ▁) ▁; ▁sum ▁= ▁( ▁arr ▁[ ▁N ▁- ▁1 ▁] ▁- ▁arr ▁[ ▁0 ▁] ▁) ▁+ ▁( ▁arr ▁[ ▁N ▁- ▁2 ▁] ▁- ▁arr ▁[ ▁0 ▁] ▁) ▁+ ▁( ▁arr ▁[ ▁N ▁- ▁1 ▁] ▁- ▁arr ▁[ ▁N ▁- ▁2 ▁] ▁) ▁; ▁c out ▁<< ▁sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁4 ▁, ▁2 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁maximum Sum ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁min Operation ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁tot Ops ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁tot Ops ▁+= ▁abs ▁( ▁a ▁[ ▁i ▁] ▁- ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁; ▁} ▁int ▁max Ops ▁= ▁max ▁( ▁abs ▁( ▁a ▁[ ▁0 ▁] ▁- ▁a ▁[ ▁1 ▁] ▁) ▁, ▁abs ▁( ▁a ▁[ ▁N ▁- ▁1 ▁] ▁- ▁a ▁[ ▁N ▁- ▁2 ▁] ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁max Ops ▁= ▁max ▁( ▁max Ops ▁, ▁abs ▁( ▁a ▁[ ▁i ▁] ▁- ▁a ▁[ ▁i ▁- ▁1 ▁] ▁) ▁+ ▁abs ▁( ▁a ▁[ ▁i ▁] ▁- ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁- ▁abs ▁( ▁a ▁[ ▁i ▁- ▁1 ▁] ▁- ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁) ▁; ▁} ▁c out ▁<< ▁tot Ops ▁- ▁max Ops ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁-1 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁min Operation ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁num Operation ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁D ▁) ▁{ ▁sort ▁( ▁arr ▁, ▁arr ▁+ ▁N ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁arr ▁[ ▁i ▁+ ▁1 ▁] ▁- ▁arr ▁[ ▁i ▁] ▁) ▁% ▁D ▁!= ▁0 ▁) ▁{ ▁c out ▁<< ▁" ▁- ▁1" ▁; ▁return ▁; ▁} ▁} ▁int ▁count ▁= ▁0 ▁; ▁int ▁mid ▁= ▁arr ▁[ ▁N ▁/ ▁2 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁count ▁+= ▁abs ▁( ▁mid ▁- ▁arr ▁[ ▁i ▁] ▁) ▁/ ▁D ▁; ▁} ▁c out ▁<< ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁4 ▁, ▁D ▁= ▁2 ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁4 ▁, ▁6 ▁, ▁8 ▁} ▁; ▁num Operation ▁( ▁arr ▁, ▁N ▁, ▁D ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find Sum ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁sort ▁( ▁A ▁, ▁A ▁+ ▁N ▁) ▁; ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁N ▁/ ▁K ▁; ▁i ▁< ▁N ▁; ▁i ▁+= ▁K ▁- ▁1 ▁) ▁{ ▁sum ▁+= ▁A ▁[ ▁i ▁] ▁; ▁} ▁c out ▁<< ▁sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁K ▁= ▁4 ▁; ▁int ▁A ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁1 ▁, ▁4 ▁, ▁7 ▁, ▁5 ▁, ▁6 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁A ▁) ▁/ ▁sizeof ▁( ▁A ▁[ ▁0 ▁] ▁) ▁; ▁find Sum ▁( ▁A ▁, ▁N ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁merge ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁temp ▁[ ▁] ▁, ▁int ▁l ▁, ▁int ▁m ▁, ▁int ▁r ▁, ▁int ▁K ▁) ▁{ ▁int ▁i ▁= ▁l ▁; ▁int ▁j ▁= ▁m ▁+ ▁1 ▁; ▁int ▁cnt ▁= ▁0 ▁; ▁for ▁( ▁int ▁l ▁= ▁0 ▁; ▁i ▁<= ▁m ▁; ▁i ▁++ ▁) ▁{ ▁bool ▁found ▁= ▁false ▁; ▁while ▁( ▁j ▁<= ▁r ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁>= ▁K ▁* ▁arr ▁[ ▁j ▁] ▁) ▁{ ▁found ▁= ▁true ▁; ▁} ▁else ▁break ▁; ▁j ▁++ ▁; ▁} ▁if ▁( ▁found ▁) ▁{ ▁cnt ▁+= ▁j ▁- ▁( ▁m ▁+ ▁1 ▁) ▁; ▁j ▁-- ▁; ▁} ▁} ▁int ▁k ▁= ▁l ▁; ▁i ▁= ▁l ▁; ▁j ▁= ▁m ▁+ ▁1 ▁; ▁while ▁( ▁i ▁<= ▁m ▁&& ▁j ▁<= ▁r ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁<= ▁arr ▁[ ▁j ▁] ▁) ▁temp ▁[ ▁k ▁++ ▁] ▁= ▁arr ▁[ ▁i ▁++ ▁] ▁; ▁else ▁temp ▁[ ▁k ▁++ ▁] ▁= ▁arr ▁[ ▁j ▁++ ▁] ▁; ▁} ▁while ▁( ▁i ▁<= ▁m ▁) ▁temp ▁[ ▁k ▁++ ▁] ▁= ▁arr ▁[ ▁i ▁++ ▁] ▁; ▁while ▁( ▁j ▁<= ▁r ▁) ▁temp ▁[ ▁k ▁++ ▁] ▁= ▁arr ▁[ ▁j ▁++ ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁l ▁; ▁i ▁<= ▁r ▁; ▁i ▁++ ▁) ▁arr ▁[ ▁i ▁] ▁= ▁temp ▁[ ▁i ▁] ▁; ▁return ▁cnt ▁; ▁} ▁int ▁merge Sort Util ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁temp ▁[ ▁] ▁, ▁int ▁l ▁, ▁int ▁r ▁, ▁int ▁K ▁) ▁{ ▁int ▁cnt ▁= ▁0 ▁; ▁if ▁( ▁l ▁< ▁r ▁) ▁{ ▁int ▁m ▁= ▁( ▁l ▁+ ▁r ▁) ▁/ ▁2 ▁; ▁cnt ▁+= ▁merge Sort Util ▁( ▁arr ▁, ▁temp ▁, ▁l ▁, ▁m ▁, ▁K ▁) ▁; ▁cnt ▁+= ▁merge Sort Util ▁( ▁arr ▁, ▁temp ▁, ▁m ▁+ ▁1 ▁, ▁r ▁, ▁K ▁) ▁; ▁cnt ▁+= ▁merge ▁( ▁arr ▁, ▁temp ▁, ▁l ▁, ▁m ▁, ▁r ▁, ▁K ▁) ▁; ▁} ▁return ▁cnt ▁; ▁} ▁int ▁merge Sort ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁int ▁temp ▁[ ▁N ▁] ▁; ▁c out ▁<< ▁merge Sort Util ▁( ▁arr ▁, ▁temp ▁, ▁0 ▁, ▁N ▁- ▁1 ▁, ▁K ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁6 ▁, ▁2 ▁, ▁5 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁K ▁= ▁2 ▁; ▁merge Sort ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁B ubble _ Sort ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁bool ▁flag ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁{ ▁flag ▁= ▁false ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁<= ▁( ▁n ▁- ▁i ▁- ▁1 ▁) ▁; ▁++ ▁j ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁j ▁] ▁> ▁arr ▁[ ▁j ▁+ ▁1 ▁] ▁) ▁{ ▁swap ▁( ▁arr ▁[ ▁j ▁] ▁, ▁arr ▁[ ▁j ▁+ ▁1 ▁] ▁) ▁; ▁flag ▁= ▁true ▁; ▁} ▁} ▁if ▁( ▁flag ▁== ▁false ▁) ▁break ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁5 ▁; ▁int ▁arr ▁[ ▁5 ▁] ▁= ▁{ ▁2 ▁, ▁0 ▁, ▁1 ▁, ▁4 ▁, ▁3 ▁} ▁; ▁B ubble _ Sort ▁( ▁arr ▁, ▁n ▁) ▁; ▁c out ▁<< ▁" ▁The ▁Sorted ▁Array ▁by ▁using ▁B ubble ▁Sort ▁is ▁: ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁min Rem ovals ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁sort ▁( ▁A ▁, ▁A ▁+ ▁N ▁) ▁; ▁int ▁mx ▁= ▁A ▁[ ▁N ▁- ▁1 ▁] ▁; ▁int ▁sum ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁A ▁[ ▁i ▁] ▁; ▁} ▁if ▁( ▁sum ▁- ▁mx ▁>= ▁mx ▁) ▁{ ▁c out ▁<< ▁0 ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁2 ▁* ▁mx ▁- ▁sum ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁3 ▁, ▁2 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁A ▁) ▁/ ▁sizeof ▁( ▁A ▁[ ▁0 ▁] ▁) ▁; ▁min Rem ovals ▁( ▁A ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max Rectangle ▁( ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁sequence ▁, ▁int ▁size ▁) ▁{ ▁long ▁long ▁int ▁X _ C ord ▁[ ▁size ▁] ▁, ▁Y _ C ord ▁[ ▁size ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁{ ▁X _ C ord ▁[ ▁i ▁] ▁= ▁sequence ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁; ▁Y _ C ord ▁[ ▁i ▁] ▁= ▁sequence ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁; ▁} ▁sort ▁( ▁X _ C ord ▁, ▁X _ C ord ▁+ ▁size ▁) ▁; ▁sort ▁( ▁Y _ C ord ▁, ▁Y _ C ord ▁+ ▁size ▁) ▁; ▁long ▁long ▁int ▁X _ Max ▁= ▁0 ▁, ▁Y _ Max ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁X _ Max ▁= ▁max ▁( ▁X _ Max ▁, ▁X _ C ord ▁[ ▁i ▁+ ▁1 ▁] ▁- ▁X _ C ord ▁[ ▁i ▁] ▁) ▁; ▁Y _ Max ▁= ▁max ▁( ▁Y _ Max ▁, ▁Y _ C ord ▁[ ▁i ▁+ ▁1 ▁] ▁- ▁Y _ C ord ▁[ ▁i ▁] ▁) ▁; ▁} ▁return ▁X _ Max ▁* ▁Y _ Max ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁point ▁= ▁{ ▁{ ▁-2 ▁, ▁0 ▁} ▁, ▁{ ▁2 ▁, ▁0 ▁} ▁, ▁{ ▁4 ▁, ▁0 ▁} ▁, ▁{ ▁4 ▁, ▁2 ▁} ▁} ▁; ▁int ▁n ▁= ▁point ▁. ▁size ▁( ▁) ▁; ▁c out ▁<< ▁max Rectangle ▁( ▁point ▁, ▁n ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁check Arr angement ▁( ▁int ▁A 1 ▁[ ▁] ▁, ▁int ▁A 2 ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁sort ▁( ▁A 1 ▁, ▁A 1 ▁+ ▁n ▁) ▁; ▁sort ▁( ▁A 2 ▁, ▁A 2 ▁+ ▁n ▁, ▁greater ▁< ▁int ▁> ▁( ▁) ▁) ▁; ▁int ▁flag ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁A 1 ▁[ ▁i ▁] ▁+ ▁A 2 ▁[ ▁i ▁] ▁> ▁k ▁) ▁|| ▁( ▁A 1 ▁[ ▁i ▁] ▁+ ▁A 2 ▁[ ▁i ▁] ▁< ▁k ▁/ ▁2 ▁) ▁) ▁{ ▁flag ▁= ▁1 ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁flag ▁== ▁1 ▁) ▁c out ▁<< ▁" ▁No ▁" ▁; ▁else ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr 1 ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁arr 2 ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁} ▁; ▁int ▁K ▁= ▁6 ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr 1 ▁) ▁/ ▁sizeof ▁( ▁arr 1 ▁[ ▁0 ▁] ▁) ▁; ▁check Arr angement ▁( ▁arr 1 ▁, ▁arr 2 ▁, ▁N ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁sort array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁if ▁( ▁N ▁== ▁3 ▁) ▁c out ▁<< ▁" ▁NO ▁" ▁<< ▁end l ▁; ▁else ▁if ▁( ▁N ▁% ▁4 ▁== ▁0 ▁N ▁% ▁4 ▁== ▁1 ▁) ▁{ ▁c out ▁<< ▁" ▁YES ▁" ▁<< ▁end l ▁; ▁c out ▁<< ▁( ▁N ▁/ ▁2 ▁) ▁<< ▁end l ▁; ▁int ▁k ▁= ▁1 ▁; ▁for ▁( ▁int ▁l ▁= ▁0 ▁; ▁l ▁< ▁( ▁N ▁/ ▁4 ▁) ▁; ▁l ▁++ ▁) ▁{ ▁c out ▁<< ▁k ▁<< ▁" ▁" ▁<< ▁k ▁+ ▁1 ▁<< ▁" ▁" ▁<< ▁N ▁<< ▁end l ▁; ▁c out ▁<< ▁k ▁+ ▁1 ▁<< ▁" ▁" ▁<< ▁N ▁<< ▁" ▁" ▁<< ▁N ▁- ▁1 ▁<< ▁end l ▁; ▁k ▁= ▁k ▁+ ▁2 ▁; ▁N ▁= ▁N ▁- ▁2 ▁; ▁} ▁} ▁else ▁c out ▁<< ▁" ▁NO ▁" ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁5 ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁4 ▁, ▁3 ▁, ▁2 ▁, ▁1 ▁} ▁; ▁sort array ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Min Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁K ▁, ▁int ▁L ▁, ▁int ▁size ▁) ▁{ ▁if ▁( ▁K ▁* ▁L ▁> ▁size ▁) ▁return ▁-1 ▁; ▁int ▁min sum ▁= ▁0 ▁; ▁sort ▁( ▁arr ▁, ▁arr ▁+ ▁size ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁K ▁; ▁i ▁++ ▁) ▁min sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁return ▁min sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁15 ▁, ▁5 ▁, ▁1 ▁, ▁35 ▁, ▁16 ▁, ▁67 ▁, ▁10 ▁} ▁; ▁int ▁K ▁= ▁3 ▁; ▁int ▁L ▁= ▁2 ▁; ▁int ▁length ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁find Min Sum ▁( ▁arr ▁, ▁K ▁, ▁L ▁, ▁length ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find K th Small est ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁max ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁max ▁) ▁max ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁int ▁counter ▁[ ▁max ▁+ ▁1 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁int ▁smallest ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁counter ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁++ ▁; ▁} ▁for ▁( ▁int ▁num ▁= ▁1 ▁; ▁num ▁<= ▁max ▁; ▁num ▁++ ▁) ▁{ ▁if ▁( ▁counter ▁[ ▁num ▁] ▁> ▁0 ▁) ▁{ ▁smallest ▁+= ▁counter ▁[ ▁num ▁] ▁; ▁} ▁if ▁( ▁smallest ▁>= ▁k ▁) ▁{ ▁return ▁num ▁; ▁} ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁7 ▁, ▁1 ▁, ▁4 ▁, ▁4 ▁, ▁20 ▁, ▁15 ▁, ▁8 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁K ▁= ▁5 ▁; ▁c out ▁<< ▁find K th Small est ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< std io . h > ▁NEW _ LINE ▁# define ▁N ▁4 ▁NEW _ LINE ▁void ▁func ▁( ▁int ▁a ▁[ ▁] ▁[ ▁N ▁] ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁for ▁( ▁int ▁k ▁= ▁j ▁+ ▁1 ▁; ▁k ▁< ▁N ▁; ▁++ ▁k ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁[ ▁j ▁] ▁> ▁a ▁[ ▁i ▁] ▁[ ▁k ▁] ▁) ▁{ ▁int ▁temp ▁= ▁a ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁a ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁a ▁[ ▁i ▁] ▁[ ▁k ▁] ▁; ▁a ▁[ ▁i ▁] ▁[ ▁k ▁] ▁= ▁temp ▁; ▁} ▁} ▁} ▁} ▁else ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁for ▁( ▁int ▁k ▁= ▁j ▁+ ▁1 ▁; ▁k ▁< ▁N ▁; ▁++ ▁k ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁[ ▁j ▁] ▁< ▁a ▁[ ▁i ▁] ▁[ ▁k ▁] ▁) ▁{ ▁int ▁temp ▁= ▁a ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁a ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁a ▁[ ▁i ▁] ▁[ ▁k ▁] ▁; ▁a ▁[ ▁i ▁] ▁[ ▁k ▁] ▁= ▁temp ▁; ▁} ▁} ▁} ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁printf ▁( ▁" ▁% ▁d ▁" ▁, ▁a ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁; ▁} ▁printf ▁( ▁" ▁STRNEWLINE ▁" ▁) ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁N ▁] ▁[ ▁N ▁] ▁= ▁{ ▁{ ▁5 ▁, ▁7 ▁, ▁3 ▁, ▁4 ▁} ▁, ▁{ ▁9 ▁, ▁5 ▁, ▁8 ▁, ▁2 ▁} ▁, ▁{ ▁6 ▁, ▁3 ▁, ▁8 ▁, ▁1 ▁} ▁, ▁{ ▁5 ▁, ▁8 ▁, ▁9 ▁, ▁3 ▁} ▁} ▁; ▁func ▁( ▁a ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁map ▁< ▁int ▁, ▁int ▁> ▁g ▁[ ▁20000 5 ▁] ▁; ▁set ▁< ▁int ▁> ▁s ▁, ▁ns ▁; ▁void ▁dfs ▁( ▁int ▁x ▁) ▁{ ▁vector ▁< ▁int ▁> ▁v ▁; ▁v ▁. ▁clear ▁( ▁) ▁; ▁ns ▁. ▁clear ▁( ▁) ▁; ▁for ▁( ▁int ▁it ▁: ▁s ▁) ▁{ ▁if ▁( ▁! ▁g ▁[ ▁x ▁] ▁[ ▁it ▁] ▁) ▁{ ▁v ▁. ▁push _ back ▁( ▁it ▁) ▁; ▁} ▁else ▁{ ▁ns ▁. ▁insert ▁( ▁it ▁) ▁; ▁} ▁} ▁s ▁= ▁ns ▁; ▁for ▁( ▁int ▁i ▁: ▁v ▁) ▁{ ▁dfs ▁( ▁i ▁) ▁; ▁} ▁} ▁void ▁weight Of M ST ▁( ▁int ▁N ▁) ▁{ ▁int ▁cnt ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁N ▁; ▁++ ▁i ▁) ▁{ ▁s ▁. ▁insert ▁( ▁i ▁) ▁; ▁} ▁for ▁( ▁; ▁s ▁. ▁size ▁( ▁) ▁; ▁) ▁{ ▁++ ▁cnt ▁; ▁int ▁t ▁= ▁* ▁s ▁. ▁begin ▁( ▁) ▁; ▁s ▁. ▁erase ▁( ▁t ▁) ▁; ▁dfs ▁( ▁t ▁) ▁; ▁} ▁c out ▁<< ▁cnt ▁- ▁1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁6 ▁, ▁M ▁= ▁11 ▁; ▁int ▁edges ▁[ ▁] ▁[ ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁3 ▁} ▁, ▁{ ▁1 ▁, ▁4 ▁} ▁, ▁{ ▁1 ▁, ▁5 ▁} ▁, ▁{ ▁1 ▁, ▁6 ▁} ▁, ▁{ ▁2 ▁, ▁3 ▁} ▁, ▁{ ▁2 ▁, ▁4 ▁} ▁, ▁{ ▁2 ▁, ▁5 ▁} ▁, ▁{ ▁2 ▁, ▁6 ▁} ▁, ▁{ ▁3 ▁, ▁4 ▁} ▁, ▁{ ▁3 ▁, ▁5 ▁} ▁, ▁{ ▁3 ▁, ▁6 ▁} ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁M ▁; ▁++ ▁i ▁) ▁{ ▁int ▁u ▁= ▁edges ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁; ▁int ▁v ▁= ▁edges ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁; ▁g ▁[ ▁u ▁] ▁[ ▁v ▁] ▁= ▁1 ▁; ▁g ▁[ ▁v ▁] ▁[ ▁u ▁] ▁= ▁1 ▁; ▁} ▁weight Of M ST ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁sort Diff ▁( ▁vector ▁< ▁int ▁> ▁arr ▁, ▁int ▁n ▁) ▁{ ▁sort ▁( ▁arr ▁. ▁begin ▁( ▁) ▁, ▁arr ▁. ▁end ▁( ▁) ▁) ▁; ▁vector ▁< ▁int ▁> ▁out ▁; ▁while ▁( ▁n ▁> ▁0 ▁) ▁{ ▁out ▁. ▁push _ back ▁( ▁arr ▁[ ▁n ▁/ ▁2 ▁] ▁) ▁; ▁arr ▁. ▁erase ▁( ▁arr ▁. ▁begin ▁( ▁) ▁+ ▁n ▁/ ▁2 ▁) ▁; ▁n ▁= ▁n ▁- ▁1 ▁; ▁} ▁for ▁( ▁auto ▁i ▁: ▁out ▁) ▁c out ▁<< ▁i ▁<< ▁" ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁int ▁> ▁a ▁= ▁{ ▁8 ▁, ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁0 ▁} ▁; ▁int ▁n ▁= ▁5 ▁; ▁sort Diff ▁( ▁a ▁, ▁n ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Pairs ▁( ▁vector ▁< ▁int ▁> ▁A ▁, ▁vector ▁< ▁int ▁> ▁B ▁) ▁{ ▁int ▁n ▁= ▁A ▁. ▁size ▁( ▁) ▁; ▁sort ▁( ▁A ▁. ▁begin ▁( ▁) ▁, ▁A ▁. ▁end ▁( ▁) ▁) ▁; ▁sort ▁( ▁B ▁. ▁begin ▁( ▁) ▁, ▁B ▁. ▁end ▁( ▁) ▁) ▁; ▁int ▁ans ▁= ▁0 ▁, ▁i ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁A ▁[ ▁i ▁] ▁> ▁B ▁[ ▁ans ▁] ▁) ▁{ ▁ans ▁++ ▁; ▁} ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁int ▁> ▁A ▁= ▁{ ▁30 ▁, ▁28 ▁, ▁45 ▁, ▁22 ▁} ▁; ▁vector ▁< ▁int ▁> ▁B ▁= ▁{ ▁35 ▁, ▁25 ▁, ▁22 ▁, ▁48 ▁} ▁; ▁c out ▁<< ▁count Pairs ▁( ▁A ▁, ▁B ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁re vers Digits ▁( ▁int ▁num ▁) ▁{ ▁int ▁rev _ num ▁= ▁0 ▁; ▁while ▁( ▁num ▁> ▁0 ▁) ▁{ ▁rev _ num ▁= ▁rev _ num ▁* ▁10 ▁+ ▁num ▁% ▁10 ▁; ▁num ▁= ▁num ▁/ ▁10 ▁; ▁} ▁return ▁rev _ num ▁; ▁} ▁void ▁sort Arr ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁vector ▁< ▁pair ▁< ▁int ▁, ▁int ▁> ▁> ▁vp ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁vp ▁. ▁push _ back ▁( ▁make _ pair ▁( ▁re vers Digits ▁( ▁arr ▁[ ▁i ▁] ▁) ▁, ▁arr ▁[ ▁i ▁] ▁) ▁) ▁; ▁} ▁sort ▁( ▁vp ▁. ▁begin ▁( ▁) ▁, ▁vp ▁. ▁end ▁( ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁vp ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁vp ▁[ ▁i ▁] ▁. ▁second ▁<< ▁" ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁12 ▁, ▁10 ▁, ▁102 ▁, ▁31 ▁, ▁15 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁sort Arr ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁vector ▁< ▁int ▁> ▁org az ine InOrder ▁( ▁vector ▁< ▁int ▁> ▁vec ▁, ▁vector ▁< ▁int ▁> ▁op ▁, ▁int ▁n ▁) ▁{ ▁vector ▁< ▁int ▁> ▁result ▁( ▁n ▁) ▁; ▁sort ▁( ▁vec ▁. ▁begin ▁( ▁) ▁, ▁vec ▁. ▁end ▁( ▁) ▁) ▁; ▁int ▁i ▁= ▁0 ▁, ▁j ▁= ▁n ▁- ▁1 ▁, ▁k ▁= ▁0 ▁; ▁while ▁( ▁i ▁<= ▁j ▁&& ▁k ▁<= ▁n ▁- ▁2 ▁) ▁{ ▁if ▁( ▁op ▁[ ▁k ▁] ▁== ▁' ▁< ▁' ▁) ▁{ ▁result ▁[ ▁k ▁] ▁= ▁vec ▁[ ▁i ▁++ ▁] ▁; ▁} ▁else ▁{ ▁result ▁[ ▁k ▁] ▁= ▁vec ▁[ ▁j ▁-- ▁] ▁; ▁} ▁k ▁++ ▁; ▁} ▁result ▁[ ▁n ▁- ▁1 ▁] ▁= ▁vec ▁[ ▁i ▁] ▁; ▁return ▁result ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁int ▁> ▁vec ▁( ▁{ ▁8 ▁, ▁2 ▁, ▁7 ▁, ▁1 ▁, ▁5 ▁, ▁9 ▁} ▁) ▁; ▁vector ▁< ▁int ▁> ▁op ▁( ▁{ ▁' ▁> ▁' ▁, ▁' ▁> ▁' ▁, ▁' ▁< ▁' ▁, ▁' ▁> ▁' ▁, ▁' ▁< ▁' ▁} ▁) ▁; ▁vector ▁< ▁int ▁> ▁result ▁= ▁org az ine InOrder ▁( ▁vec ▁, ▁op ▁, ▁vec ▁. ▁size ▁( ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁result ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁c out ▁<< ▁result ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁} ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁int ▁MAX ▁= ▁1000 ▁; ▁bool ▁line Exists ▁( ▁int ▁x ▁[ ▁] ▁, ▁int ▁y ▁[ ▁] ▁, ▁int ▁v ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁size ▁= ▁( ▁2 ▁* ▁MAX ▁) ▁+ ▁1 ▁; ▁long ▁arr ▁[ ▁size ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁arr ▁[ ▁x ▁[ ▁i ▁] ▁+ ▁MAX ▁] ▁+= ▁v ▁[ ▁i ▁] ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁arr ▁[ ▁i ▁] ▁+= ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁; ▁if ▁( ▁arr ▁[ ▁size ▁- ▁1 ▁] ▁== ▁0 ▁) ▁return ▁true ▁; ▁if ▁( ▁arr ▁[ ▁size ▁- ▁1 ▁] ▁- ▁arr ▁[ ▁0 ▁] ▁== ▁0 ▁) ▁return ▁true ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁size ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁== ▁arr ▁[ ▁size ▁- ▁1 ▁] ▁- ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁) ▁return ▁true ▁; ▁if ▁( ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁== ▁arr ▁[ ▁size ▁- ▁1 ▁] ▁- ▁arr ▁[ ▁i ▁] ▁) ▁return ▁true ▁; ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁arr ▁[ ▁size ▁- ▁1 ▁] ▁- ▁arr ▁[ ▁i ▁] ▁) ▁return ▁true ▁; ▁} ▁if ▁( ▁arr ▁[ ▁size ▁- ▁2 ▁] ▁== ▁0 ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁x ▁[ ▁] ▁= ▁{ ▁-3 ▁, ▁5 ▁, ▁8 ▁} ▁; ▁int ▁y ▁[ ▁] ▁= ▁{ ▁8 ▁, ▁7 ▁, ▁9 ▁} ▁; ▁int ▁v ▁[ ▁] ▁= ▁{ ▁8 ▁, ▁2 ▁, ▁10 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁x ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁if ▁( ▁line Exists ▁( ▁x ▁, ▁y ▁, ▁v ▁, ▁n ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max Sum ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁sort ▁( ▁a ▁, ▁a ▁+ ▁n ▁) ▁; ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁+= ▁2 ▁) ▁{ ▁sum ▁+= ▁a ▁[ ▁i ▁] ▁; ▁} ▁return ▁sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁2 ▁, ▁1 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁max Sum ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁min Operations ▁( ▁vector ▁< ▁int ▁> ▁ar ▁, ▁int ▁k ▁) ▁{ ▁sort ▁( ▁ar ▁. ▁begin ▁( ▁) ▁, ▁ar ▁. ▁end ▁( ▁) ▁) ▁; ▁int ▁ops Needed ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁k ▁; ▁i ▁++ ▁) ▁{ ▁ops Needed ▁+= ▁ar ▁[ ▁k ▁- ▁1 ▁] ▁- ▁ar ▁[ ▁i ▁] ▁; ▁} ▁int ▁ans ▁= ▁ops Needed ▁; ▁for ▁( ▁int ▁i ▁= ▁k ▁; ▁i ▁< ▁ar ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁ops Needed ▁= ▁ops Needed ▁- ▁( ▁ar ▁[ ▁i ▁- ▁1 ▁] ▁- ▁ar ▁[ ▁i ▁- ▁k ▁] ▁) ▁; ▁ops Needed ▁+= ▁( ▁k ▁- ▁1 ▁) ▁* ▁( ▁ar ▁[ ▁i ▁] ▁- ▁ar ▁[ ▁i ▁- ▁1 ▁] ▁) ▁; ▁ans ▁= ▁min ▁( ▁ans ▁, ▁ops Needed ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁int ▁> ▁arr ▁= ▁{ ▁3 ▁, ▁1 ▁, ▁9 ▁, ▁100 ▁} ▁; ▁int ▁n ▁= ▁arr ▁. ▁size ▁( ▁) ▁; ▁int ▁k ▁= ▁3 ▁; ▁c out ▁<< ▁min Operations ▁( ▁arr ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁float ▁kn ap S ack ▁( ▁int ▁W ▁, ▁float ▁wt ▁[ ▁] ▁, ▁float ▁val ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁float ▁max ratio ▁= ▁INT _ MIN ▁; ▁int ▁max index ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁val ▁[ ▁i ▁] ▁/ ▁wt ▁[ ▁i ▁] ▁) ▁> ▁max ratio ▁) ▁{ ▁max ratio ▁= ▁( ▁val ▁[ ▁i ▁] ▁/ ▁wt ▁[ ▁i ▁] ▁) ▁; ▁max index ▁= ▁i ▁; ▁} ▁} ▁return ▁( ▁W ▁* ▁max ratio ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁float ▁val ▁[ ▁] ▁= ▁{ ▁14 ▁, ▁27 ▁, ▁44 ▁, ▁19 ▁} ▁; ▁float ▁wt ▁[ ▁] ▁= ▁{ ▁6 ▁, ▁7 ▁, ▁9 ▁, ▁8 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁val ▁) ▁/ ▁sizeof ▁( ▁val ▁[ ▁0 ▁] ▁) ▁; ▁int ▁W ▁= ▁50 ▁; ▁c out ▁<< ▁kn ap S ack ▁( ▁W ▁, ▁wt ▁, ▁val ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁class ▁Node ▁{ ▁public ▁: ▁int ▁data ▁; ▁Node ▁* ▁left ▁; ▁Node ▁* ▁right ▁; ▁Node ▁( ▁int ▁x ▁) ▁{ ▁data ▁= ▁x ▁; ▁left ▁= ▁right ▁= ▁NULL ▁; ▁} ▁} ▁; ▁void ▁in order ▁( ▁Node ▁* ▁root ▁) ▁{ ▁if ▁( ▁root ▁!= ▁NULL ▁) ▁{ ▁in order ▁( ▁root ▁-> ▁left ▁) ▁; ▁c out ▁<< ▁root ▁-> ▁data ▁<< ▁" ▁" ▁; ▁in order ▁( ▁root ▁-> ▁right ▁) ▁; ▁} ▁} ▁void ▁merge ▁( ▁Node ▁* ▁root 1 ▁, ▁Node ▁* ▁root 2 ▁) ▁{ ▁if ▁( ▁! ▁root 1 ▁&& ▁! ▁root 2 ▁) ▁return ▁; ▁if ▁( ▁! ▁root 1 ▁) ▁{ ▁in order ▁( ▁root 2 ▁) ▁; ▁return ▁; ▁} ▁if ▁( ▁! ▁root 2 ▁) ▁{ ▁in order ▁( ▁root 1 ▁) ▁; ▁return ▁; ▁} ▁Node ▁* ▁temp 1 ▁= ▁root 1 ▁; ▁Node ▁* ▁prev 1 ▁= ▁NULL ▁; ▁while ▁( ▁temp 1 ▁-> ▁left ▁) ▁{ ▁prev 1 ▁= ▁temp 1 ▁; ▁temp 1 ▁= ▁temp 1 ▁-> ▁left ▁; ▁} ▁Node ▁* ▁temp 2 ▁= ▁root 2 ▁; ▁Node ▁* ▁prev 2 ▁= ▁NULL ▁; ▁while ▁( ▁temp 2 ▁-> ▁left ▁) ▁{ ▁prev 2 ▁= ▁temp 2 ▁; ▁temp 2 ▁= ▁temp 2 ▁-> ▁left ▁; ▁} ▁if ▁( ▁temp 1 ▁-> ▁data ▁<= ▁temp 2 ▁-> ▁data ▁) ▁{ ▁c out ▁<< ▁temp 1 ▁-> ▁data ▁<< ▁" ▁" ▁; ▁if ▁( ▁prev 1 ▁== ▁NULL ▁) ▁{ ▁merge ▁( ▁root 1 ▁-> ▁right ▁, ▁root 2 ▁) ▁; ▁} ▁else ▁{ ▁prev 1 ▁-> ▁left ▁= ▁temp 1 ▁-> ▁right ▁; ▁merge ▁( ▁root 1 ▁, ▁root 2 ▁) ▁; ▁} ▁} ▁else ▁{ ▁c out ▁<< ▁temp 2 ▁-> ▁data ▁<< ▁" ▁" ▁; ▁if ▁( ▁prev 2 ▁== ▁NULL ▁) ▁{ ▁merge ▁( ▁root 1 ▁, ▁root 2 ▁-> ▁right ▁) ▁; ▁} ▁else ▁{ ▁prev 2 ▁-> ▁left ▁= ▁temp 2 ▁-> ▁right ▁; ▁merge ▁( ▁root 1 ▁, ▁root 2 ▁) ▁; ▁} ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁Node ▁* ▁root 1 ▁= ▁NULL ▁, ▁* ▁root 2 ▁= ▁NULL ▁; ▁root 1 ▁= ▁new ▁Node ▁( ▁3 ▁) ▁; ▁root 1 ▁-> ▁left ▁= ▁new ▁Node ▁( ▁1 ▁) ▁; ▁root 1 ▁-> ▁right ▁= ▁new ▁Node ▁( ▁5 ▁) ▁; ▁root 2 ▁= ▁new ▁Node ▁( ▁4 ▁) ▁; ▁root 2 ▁-> ▁left ▁= ▁new ▁Node ▁( ▁2 ▁) ▁; ▁root 2 ▁-> ▁right ▁= ▁new ▁Node ▁( ▁6 ▁) ▁; ▁merge ▁( ▁root 1 ▁, ▁root 2 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< algorithm > ▁NEW _ LINE ▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁long ▁long ▁mod ▁= ▁100 000000 7 ▁; ▁long ▁long ▁arr ▁[ ▁1001 ▁] ▁[ ▁1001 ▁] ▁; ▁void ▁Pre process ▁( ▁) ▁{ ▁arr ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁1000 ▁; ▁++ ▁i ▁) ▁{ ▁arr ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁< ▁i ▁; ▁++ ▁j ▁) ▁{ ▁arr ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁( ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁- ▁1 ▁] ▁+ ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁) ▁% ▁mod ▁; ▁} ▁arr ▁[ ▁i ▁] ▁[ ▁i ▁] ▁= ▁1 ▁; ▁} ▁} ▁long ▁long ▁pow mod ▁( ▁long ▁long ▁a ▁, ▁long ▁long ▁n ▁) ▁{ ▁if ▁( ▁! ▁n ▁) ▁return ▁1 ▁; ▁long ▁long ▁pt ▁= ▁pow mod ▁( ▁a ▁, ▁n ▁/ ▁2 ▁) ▁; ▁pt ▁= ▁( ▁pt ▁* ▁pt ▁) ▁% ▁mod ▁; ▁if ▁( ▁n ▁% ▁2 ▁) ▁return ▁( ▁pt ▁* ▁a ▁) ▁% ▁mod ▁; ▁else ▁return ▁pt ▁; ▁} ▁long ▁long ▁Count Subset ▁( ▁int ▁* ▁val ▁, ▁int ▁n ▁) ▁{ ▁long ▁long ▁ans ▁= ▁pow mod ▁( ▁2 ▁, ▁n ▁- ▁1 ▁) ▁; ▁sort ▁( ▁val ▁, ▁val ▁+ ▁n ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁{ ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁while ▁( ▁j ▁< ▁n ▁&& ▁val ▁[ ▁j ▁] ▁== ▁val ▁[ ▁i ▁] ▁) ▁{ ▁int ▁r ▁= ▁n ▁- ▁1 ▁- ▁j ▁; ▁int ▁l ▁= ▁i ▁; ▁ans ▁= ▁( ▁ans ▁+ ▁arr ▁[ ▁l ▁+ ▁r ▁] ▁[ ▁l ▁] ▁) ▁% ▁mod ▁; ▁j ▁++ ▁; ▁} ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁Pre process ▁( ▁) ▁; ▁int ▁val ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁val ▁) ▁/ ▁sizeof ▁( ▁val ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁Count Subset ▁( ▁val ▁, ▁n ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁re Ar range ▁( ▁string ▁words ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁map ▁< ▁string ▁, ▁int ▁> ▁mp ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁mp ▁[ ▁words ▁[ ▁i ▁] ▁] ▁= ▁i ▁+ ▁1 ▁; ▁sort ▁( ▁words ▁, ▁words ▁+ ▁n ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁mp ▁[ ▁words ▁[ ▁i ▁] ▁] ▁<< ▁" ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁words ▁[ ▁] ▁= ▁{ ▁" ▁live ▁" ▁, ▁" ▁place ▁" ▁, ▁" ▁travel ▁" ▁, ▁" ▁word ▁" ▁, ▁" ▁sky ▁" ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁words ▁) ▁/ ▁sizeof ▁( ▁words ▁[ ▁0 ▁] ▁) ▁; ▁re Ar range ▁( ▁words ▁, ▁n ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁Min im iz el eft Over Sum ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁vector ▁< ▁int ▁> ▁v 1 ▁, ▁v 2 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁% ▁2 ▁) ▁v 1 ▁. ▁push _ back ▁( ▁a ▁[ ▁i ▁] ▁) ▁; ▁else ▁v 2 ▁. ▁push _ back ▁( ▁a ▁[ ▁i ▁] ▁) ▁; ▁} ▁if ▁( ▁v 1 ▁. ▁size ▁( ▁) ▁> ▁v 2 ▁. ▁size ▁( ▁) ▁) ▁{ ▁sort ▁( ▁v 1 ▁. ▁begin ▁( ▁) ▁, ▁v 1 ▁. ▁end ▁( ▁) ▁) ▁; ▁sort ▁( ▁v 2 ▁. ▁begin ▁( ▁) ▁, ▁v 2 ▁. ▁end ▁( ▁) ▁) ▁; ▁int ▁x ▁= ▁v 1 ▁. ▁size ▁( ▁) ▁- ▁v 2 ▁. ▁size ▁( ▁) ▁- ▁1 ▁; ▁int ▁sum ▁= ▁0 ▁; ▁int ▁i ▁= ▁0 ▁; ▁while ▁( ▁i ▁< ▁x ▁) ▁{ ▁sum ▁+= ▁v 1 ▁[ ▁i ▁++ ▁] ▁; ▁} ▁return ▁sum ▁; ▁} ▁else ▁if ▁( ▁v 2 ▁. ▁size ▁( ▁) ▁> ▁v 1 ▁. ▁size ▁( ▁) ▁) ▁{ ▁sort ▁( ▁v 1 ▁. ▁begin ▁( ▁) ▁, ▁v 1 ▁. ▁end ▁( ▁) ▁) ▁; ▁sort ▁( ▁v 2 ▁. ▁begin ▁( ▁) ▁, ▁v 2 ▁. ▁end ▁( ▁) ▁) ▁; ▁int ▁x ▁= ▁v 2 ▁. ▁size ▁( ▁) ▁- ▁v 1 ▁. ▁size ▁( ▁) ▁- ▁1 ▁; ▁int ▁sum ▁= ▁0 ▁; ▁int ▁i ▁= ▁0 ▁; ▁while ▁( ▁i ▁< ▁x ▁) ▁{ ▁sum ▁+= ▁v 2 ▁[ ▁i ▁++ ▁] ▁; ▁} ▁return ▁sum ▁; ▁} ▁else ▁return ▁0 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁2 ▁, ▁2 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁Min im iz el eft Over Sum ▁( ▁a ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print Numbers ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁sort ▁( ▁arr ▁, ▁arr ▁+ ▁n ▁) ▁; ▁int ▁A ▁= ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁, ▁B ▁= ▁-1 ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁2 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁A ▁% ▁arr ▁[ ▁i ▁] ▁!= ▁0 ▁) ▁{ ▁B ▁= ▁arr ▁[ ▁i ▁] ▁; ▁break ▁; ▁} ▁if ▁( ▁i ▁- ▁1 ▁>= ▁0 ▁&& ▁arr ▁[ ▁i ▁] ▁== ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁) ▁{ ▁B ▁= ▁arr ▁[ ▁i ▁] ▁; ▁break ▁; ▁} ▁} ▁c out ▁<< ▁" ▁A ▁= ▁" ▁<< ▁A ▁<< ▁" ▁, ▁B ▁= ▁" ▁<< ▁B ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁4 ▁, ▁8 ▁, ▁16 ▁, ▁1 ▁, ▁2 ▁, ▁4 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁print Numbers ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print Array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁} ▁void ▁remove Min ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁i ▁, ▁min Val ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁min Val ▁= ▁min ▁( ▁min Val ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁arr ▁[ ▁i ▁] ▁= ▁arr ▁[ ▁i ▁] ▁- ▁min Val ▁; ▁} ▁void ▁removeFrom Max ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁i ▁, ▁max Val ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁max Val ▁= ▁max ▁( ▁max Val ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁arr ▁[ ▁i ▁] ▁= ▁max Val ▁- ▁arr ▁[ ▁i ▁] ▁; ▁} ▁void ▁modify Array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁if ▁( ▁k ▁% ▁2 ▁== ▁0 ▁) ▁remove Min ▁( ▁arr ▁, ▁n ▁) ▁; ▁else ▁removeFrom Max ▁( ▁arr ▁, ▁n ▁) ▁; ▁print Array ▁( ▁arr ▁, ▁n ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁8 ▁, ▁12 ▁, ▁16 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁k ▁= ▁2 ▁; ▁modify Array ▁( ▁arr ▁, ▁n ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Product ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁sort ▁( ▁arr ▁, ▁arr ▁+ ▁n ▁) ▁; ▁int ▁prod ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁!= ▁arr ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁prod ▁= ▁prod ▁* ▁arr ▁[ ▁i ▁] ▁; ▁} ▁return ▁prod ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁1 ▁, ▁1 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁c out ▁<< ▁find Product ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< algorithm > ▁NEW _ LINE ▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁12 ▁, ▁5 ▁} ▁; ▁sort ▁( ▁a ▁, ▁a ▁+ ▁3 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁3 ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁a ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁ll ▁long ▁long ▁int ▁NEW _ LINE ▁void ▁operations ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁sort ▁( ▁arr ▁, ▁arr ▁+ ▁n ▁) ▁; ▁ll ▁i ▁= ▁0 ▁, ▁sum ▁= ▁0 ▁; ▁while ▁( ▁k ▁-- ▁) ▁{ ▁while ▁( ▁i ▁< ▁n ▁&& ▁arr ▁[ ▁i ▁] ▁- ▁sum ▁== ▁0 ▁) ▁i ▁++ ▁; ▁if ▁( ▁i ▁< ▁n ▁&& ▁arr ▁[ ▁i ▁] ▁- ▁sum ▁> ▁0 ▁) ▁{ ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁- ▁sum ▁<< ▁" ▁" ▁; ▁sum ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁else ▁c out ▁<< ▁0 ▁<< ▁end l ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁k ▁= ▁5 ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁6 ▁, ▁4 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁operations ▁( ▁arr ▁, ▁n ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁min Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁vector ▁< ▁int ▁> ▁even Arr ▁; ▁vector ▁< ▁int ▁> ▁odd Arr ▁; ▁sort ▁( ▁arr ▁, ▁arr ▁+ ▁n ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁< ▁n ▁/ ▁2 ▁) ▁odd Arr ▁. ▁push _ back ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁else ▁even Arr ▁. ▁push _ back ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁sort ▁( ▁even Arr ▁. ▁begin ▁( ▁) ▁, ▁even Arr ▁. ▁end ▁( ▁) ▁, ▁greater ▁< ▁int ▁> ▁( ▁) ▁) ▁; ▁int ▁i ▁= ▁0 ▁, ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁even Arr ▁. ▁size ▁( ▁) ▁; ▁j ▁++ ▁) ▁{ ▁arr ▁[ ▁i ▁++ ▁] ▁= ▁even Arr ▁[ ▁j ▁] ▁; ▁arr ▁[ ▁i ▁++ ▁] ▁= ▁odd Arr ▁[ ▁j ▁] ▁; ▁sum ▁+= ▁even Arr ▁[ ▁j ▁] ▁* ▁odd Arr ▁[ ▁j ▁] ▁; ▁} ▁return ▁sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁5 ▁, ▁8 ▁, ▁9 ▁, ▁6 ▁, ▁7 ▁, ▁3 ▁, ▁4 ▁, ▁2 ▁, ▁0 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁Minimum ▁required ▁sum ▁= ▁" ▁<< ▁min Sum ▁( ▁arr ▁, ▁n ▁) ▁; ▁c out ▁<< ▁" ▁Sorted ▁array ▁in ▁required ▁format ▁: ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁bit onic Generator ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁vector ▁< ▁int ▁> ▁even Arr ▁; ▁vector ▁< ▁int ▁> ▁odd Arr ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁! ▁( ▁i ▁% ▁2 ▁) ▁) ▁even Arr ▁. ▁push _ back ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁else ▁odd Arr ▁. ▁push _ back ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁sort ▁( ▁even Arr ▁. ▁begin ▁( ▁) ▁, ▁even Arr ▁. ▁end ▁( ▁) ▁) ▁; ▁sort ▁( ▁odd Arr ▁. ▁begin ▁( ▁) ▁, ▁odd Arr ▁. ▁end ▁( ▁) ▁, ▁greater ▁< ▁int ▁> ▁( ▁) ▁) ▁; ▁int ▁i ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁even Arr ▁. ▁size ▁( ▁) ▁; ▁j ▁++ ▁) ▁arr ▁[ ▁i ▁++ ▁] ▁= ▁even Arr ▁[ ▁j ▁] ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁odd Arr ▁. ▁size ▁( ▁) ▁; ▁j ▁++ ▁) ▁arr ▁[ ▁i ▁++ ▁] ▁= ▁odd Arr ▁[ ▁j ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁5 ▁, ▁8 ▁, ▁9 ▁, ▁6 ▁, ▁7 ▁, ▁3 ▁, ▁4 ▁, ▁2 ▁, ▁0 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁bit onic Generator ▁( ▁arr ▁, ▁n ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Bits ▁( ▁int ▁a ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁while ▁( ▁a ▁) ▁{ ▁if ▁( ▁a ▁& ▁1 ▁) ▁count ▁+= ▁1 ▁; ▁a ▁= ▁a ▁>> ▁1 ▁; ▁} ▁return ▁count ▁; ▁} ▁void ▁sortBy Set Bit Count ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁count ▁( ▁32 ▁) ▁; ▁int ▁set bit count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁set bit count ▁= ▁count Bits ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁count ▁[ ▁set bit count ▁] ▁. ▁push _ back ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁31 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁vector ▁< ▁int ▁> ▁v 1 ▁= ▁count ▁[ ▁i ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁v 1 ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁arr ▁[ ▁j ▁++ ▁] ▁= ▁v 1 ▁[ ▁i ▁] ▁; ▁} ▁} ▁void ▁print Arr ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁sortBy Set Bit Count ▁( ▁arr ▁, ▁n ▁) ▁; ▁print Arr ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁solve ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁sort ▁( ▁arr ▁, ▁arr ▁+ ▁n ▁) ▁; ▁int ▁a ▁= ▁0 ▁, ▁b ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁& ▁1 ▁) ▁a ▁= ▁a ▁* ▁10 ▁+ ▁arr ▁[ ▁i ▁] ▁; ▁else ▁b ▁= ▁b ▁* ▁10 ▁+ ▁arr ▁[ ▁i ▁] ▁; ▁} ▁return ▁a ▁+ ▁b ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁6 ▁, ▁8 ▁, ▁4 ▁, ▁5 ▁, ▁2 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁Sum ▁is ▁" ▁<< ▁solve ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁long ▁long ▁K th Solution ▁( ▁long ▁long ▁X ▁, ▁long ▁long ▁K ▁) ▁{ ▁long ▁long ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁64 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁! ▁( ▁X ▁& ▁( ▁1 LL ▁<< ▁i ▁) ▁) ▁) ▁{ ▁if ▁( ▁K ▁& ▁1 ▁) ▁{ ▁ans ▁|= ▁( ▁1 LL ▁<< ▁i ▁) ▁; ▁} ▁K ▁>>= ▁1 ▁; ▁if ▁( ▁! ▁K ▁) ▁{ ▁break ▁; ▁} ▁} ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁long ▁long ▁X ▁= ▁5 ▁, ▁K ▁= ▁5 ▁; ▁c out ▁<< ▁K th Solution ▁( ▁X ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find An agram ▁( ▁string ▁s ▁) ▁{ ▁string ▁check ▁= ▁s ▁; ▁int ▁i ▁= ▁0 ▁, ▁j ▁= ▁s ▁. ▁length ▁( ▁) ▁- ▁1 ▁; ▁while ▁( ▁i ▁< ▁s ▁. ▁length ▁( ▁) ▁&& ▁j ▁>= ▁0 ▁) ▁{ ▁if ▁( ▁s ▁[ ▁i ▁] ▁!= ▁s ▁[ ▁j ▁] ▁&& ▁check ▁[ ▁i ▁] ▁!= ▁s ▁[ ▁j ▁] ▁&& ▁check ▁[ ▁j ▁] ▁!= ▁s ▁[ ▁i ▁] ▁) ▁{ ▁swap ▁( ▁s ▁[ ▁i ▁] ▁, ▁s ▁[ ▁j ▁] ▁) ▁; ▁i ▁++ ▁; ▁j ▁= ▁s ▁. ▁length ▁( ▁) ▁- ▁1 ▁; ▁} ▁else ▁{ ▁j ▁-- ▁; ▁} ▁} ▁if ▁( ▁s ▁. ▁length ▁( ▁) ▁% ▁2 ▁!= ▁0 ▁) ▁{ ▁int ▁mid ▁= ▁s ▁. ▁length ▁( ▁) ▁/ ▁2 ▁; ▁if ▁( ▁check ▁[ ▁mid ▁] ▁== ▁s ▁[ ▁mid ▁] ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁check ▁[ ▁i ▁] ▁!= ▁s ▁[ ▁mid ▁] ▁&& ▁s ▁[ ▁i ▁] ▁!= ▁s ▁[ ▁mid ▁] ▁) ▁{ ▁swap ▁( ▁s ▁[ ▁i ▁] ▁, ▁s ▁[ ▁mid ▁] ▁) ▁; ▁break ▁; ▁} ▁} ▁} ▁} ▁bool ▁ok ▁= ▁true ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁check ▁[ ▁i ▁] ▁== ▁s ▁[ ▁i ▁] ▁) ▁{ ▁ok ▁= ▁false ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁ok ▁) ▁c out ▁<< ▁s ▁; ▁else ▁c out ▁<< ▁-1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁S ▁= ▁" ▁g eek ▁" ▁; ▁find An agram ▁( ▁S ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁min Time ▁( ▁string ▁word ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁int ▁curr ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁word ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁int ▁k ▁= ▁word ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁; ▁int ▁a ▁= ▁abs ▁( ▁curr ▁- ▁k ▁) ▁; ▁int ▁b ▁= ▁26 ▁- ▁abs ▁( ▁curr ▁- ▁k ▁) ▁; ▁ans ▁+= ▁min ▁( ▁a ▁, ▁b ▁) ▁; ▁ans ▁++ ▁; ▁curr ▁= ▁word ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁; ▁} ▁c out ▁<< ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁z j pc ▁" ▁; ▁min Time ▁( ▁str ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁maximum Sum Array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁vector ▁< ▁int ▁> ▁arr A ▁( ▁N ▁) ▁, ▁ans ▁( ▁N ▁) ▁; ▁int ▁max Sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁arr A ▁[ ▁i ▁] ▁= ▁arr ▁[ ▁i ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁vector ▁< ▁int ▁> ▁arr B ▁( ▁N ▁) ▁; ▁int ▁maximum ▁= ▁arr A ▁[ ▁i ▁] ▁; ▁arr B ▁[ ▁i ▁] ▁= ▁maximum ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁- ▁1 ▁; ▁j ▁>= ▁0 ▁; ▁j ▁-- ▁) ▁{ ▁arr B ▁[ ▁j ▁] ▁= ▁min ▁( ▁maximum ▁, ▁arr A ▁[ ▁j ▁] ▁) ▁; ▁maximum ▁= ▁arr B ▁[ ▁j ▁] ▁; ▁} ▁maximum ▁= ▁arr A ▁[ ▁i ▁] ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁arr B ▁[ ▁j ▁] ▁= ▁min ▁( ▁maximum ▁, ▁arr A ▁[ ▁j ▁] ▁) ▁; ▁maximum ▁= ▁arr B ▁[ ▁j ▁] ▁; ▁} ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁sum ▁+= ▁arr B ▁[ ▁j ▁] ▁; ▁if ▁( ▁sum ▁> ▁max Sum ▁) ▁{ ▁max Sum ▁= ▁sum ▁; ▁ans ▁= ▁arr B ▁; ▁} ▁} ▁for ▁( ▁int ▁val ▁: ▁ans ▁) ▁{ ▁c out ▁<< ▁val ▁<< ▁" ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁6 ▁, ▁8 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁A ▁) ▁/ ▁sizeof ▁( ▁A ▁[ ▁0 ▁] ▁) ▁; ▁maximum Sum Array ▁( ▁A ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁string ▁largest Merge ▁( ▁string ▁word 1 ▁, ▁string ▁word 2 ▁) ▁{ ▁string ▁merge ▁= ▁" ▁" ▁; ▁while ▁( ▁word 1 ▁. ▁size ▁( ▁) ▁!= ▁0 ▁|| ▁word 2 ▁. ▁size ▁( ▁) ▁!= ▁0 ▁) ▁{ ▁if ▁( ▁word 1 ▁>= ▁word 2 ▁) ▁{ ▁merge ▁= ▁merge ▁+ ▁word 1 ▁[ ▁0 ▁] ▁; ▁word 1 ▁. ▁erase ▁( ▁word 1 ▁. ▁begin ▁( ▁) ▁+ ▁0 ▁) ▁; ▁} ▁else ▁{ ▁merge ▁= ▁merge ▁+ ▁word 2 ▁[ ▁0 ▁] ▁; ▁word 2 ▁. ▁erase ▁( ▁word 2 ▁. ▁begin ▁( ▁) ▁+ ▁0 ▁) ▁; ▁} ▁} ▁return ▁merge ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁S 1 ▁= ▁" ▁xyz xyz ▁" ▁; ▁string ▁S 2 ▁= ▁" ▁xy w z xy x ▁" ▁; ▁c out ▁<< ▁largest Merge ▁( ▁S 1 ▁, ▁S 2 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁sum Of Comb ination Of 4 OR 5 ▁( ▁vector ▁< ▁int ▁> ▁arr ▁, ▁int ▁N ▁) ▁{ ▁vector ▁< ▁int ▁> ▁ans ▁( ▁N ▁, ▁-1 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁4 ▁) ▁{ ▁continue ▁; ▁} ▁int ▁sum ▁= ▁INT _ MAX ▁, ▁cnt ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁<= ▁arr ▁[ ▁i ▁] ▁; ▁j ▁+= ▁4 ▁) ▁{ ▁if ▁( ▁( ▁arr ▁[ ▁i ▁] ▁- ▁j ▁) ▁% ▁5 ▁== ▁0 ▁) ▁{ ▁sum ▁= ▁min ▁( ▁sum ▁, ▁cnt ▁+ ▁( ▁arr ▁[ ▁i ▁] ▁- ▁j ▁) ▁/ ▁5 ▁) ▁; ▁} ▁cnt ▁++ ▁; ▁} ▁if ▁( ▁sum ▁!= ▁INT _ MAX ▁) ▁ans ▁[ ▁i ▁] ▁= ▁sum ▁; ▁} ▁for ▁( ▁auto ▁num ▁: ▁ans ▁) ▁c out ▁<< ▁num ▁<< ▁" ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁int ▁> ▁arr ▁= ▁{ ▁7 ▁, ▁15 ▁, ▁17 ▁, ▁22 ▁} ▁; ▁int ▁N ▁= ▁arr ▁. ▁size ▁( ▁) ▁; ▁sum Of Comb ination Of 4 OR 5 ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁string ▁largest String ▁( ▁string ▁s ▁, ▁int ▁k ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁[ ▁i ▁] ▁!= ▁' ▁z ▁' ▁&& ▁k ▁> ▁0 ▁) ▁{ ▁s ▁[ ▁i ▁] ▁= ▁' ▁z ▁' ▁; ▁k ▁-- ▁; ▁} ▁} ▁return ▁s ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁" ▁db za ▁" ▁; ▁int ▁k ▁= ▁1 ▁; ▁c out ▁<< ▁largest String ▁( ▁s ▁, ▁k ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁Remove One Char ▁( ▁string ▁A ▁, ▁string ▁B ▁, ▁int ▁N ▁, ▁int ▁M ▁) ▁{ ▁int ▁X ▁= ▁0 ▁; ▁int ▁Y ▁= ▁N ▁- ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁M ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁A ▁[ ▁X ▁] ▁!= ▁B ▁[ ▁i ▁] ▁) ▁break ▁; ▁X ▁++ ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁M ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁A ▁[ ▁Y ▁] ▁!= ▁B ▁[ ▁i ▁] ▁) ▁break ▁; ▁Y ▁-- ▁; ▁} ▁if ▁( ▁N ▁- ▁M ▁== ▁1 ▁&& ▁Y ▁< ▁X ▁) ▁{ ▁c out ▁<< ▁X ▁- ▁Y ▁+ ▁1 ▁<< ▁end l ▁; ▁for ▁( ▁int ▁i ▁= ▁Y ▁; ▁i ▁<= ▁X ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁i ▁+ ▁1 ▁<< ▁" ▁" ▁; ▁c out ▁<< ▁end l ▁; ▁} ▁else ▁c out ▁<< ▁-1 ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁A ▁= ▁" ▁ab a ac ▁" ▁; ▁string ▁B ▁= ▁" ▁ab ac ▁" ▁; ▁int ▁N ▁= ▁A ▁. ▁length ▁( ▁) ▁; ▁int ▁M ▁= ▁B ▁. ▁length ▁( ▁) ▁; ▁Remove One Char ▁( ▁A ▁, ▁B ▁, ▁N ▁, ▁M ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁count Of Pairs ▁( ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁k ▁= ▁1 ▁; ▁k ▁* ▁k ▁<= ▁x ▁; ▁++ ▁k ▁) ▁{ ▁count ▁+= ▁max ▁( ▁0 ▁, ▁min ▁( ▁y ▁, ▁x ▁/ ▁k ▁- ▁1 ▁) ▁- ▁k ▁) ▁; ▁} ▁c out ▁<< ▁count ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁x ▁= ▁4 ▁; ▁int ▁y ▁= ▁5 ▁; ▁count Of Pairs ▁( ▁x ▁, ▁y ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁getDate ▁( ▁int ▁d ▁, ▁string ▁m ▁) ▁{ ▁int ▁days ▁[ ▁] ▁= ▁{ ▁31 ▁, ▁29 ▁, ▁31 ▁, ▁30 ▁, ▁31 ▁, ▁30 ▁, ▁31 ▁, ▁31 ▁, ▁30 ▁, ▁31 ▁, ▁30 ▁, ▁31 ▁} ▁; ▁string ▁month ▁[ ▁] ▁= ▁{ ▁" ▁January ▁" ▁, ▁" ▁Feb ruary ▁" ▁, ▁" ▁March ▁" ▁, ▁" ▁Apr il ▁" ▁, ▁" ▁May ▁" ▁, ▁" ▁J une ▁" ▁, ▁" ▁J uly ▁" ▁, ▁" ▁Aug ust ▁" ▁, ▁" ▁Se pt ember ▁" ▁, ▁" ▁Oct ober ▁" ▁, ▁" ▁Nov ember ▁" ▁, ▁" ▁De cember ▁" ▁} ▁; ▁int ▁cnt ▁= ▁18 3 ▁; ▁int ▁cur _ month ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁12 ▁; ▁i ▁++ ▁) ▁if ▁( ▁m ▁== ▁month ▁[ ▁i ▁] ▁) ▁cur _ month ▁= ▁i ▁; ▁int ▁cur _ date ▁= ▁d ▁; ▁while ▁( ▁1 ▁) ▁{ ▁while ▁( ▁cnt ▁> ▁0 ▁&& ▁cur _ date ▁<= ▁days ▁[ ▁cur _ month ▁] ▁) ▁{ ▁cnt ▁-= ▁1 ▁; ▁cur _ date ▁+= ▁1 ▁; ▁} ▁if ▁( ▁cnt ▁== ▁0 ▁) ▁break ▁; ▁cur _ month ▁= ▁( ▁cur _ month ▁+ ▁1 ▁) ▁% ▁12 ▁; ▁cur _ date ▁= ▁1 ▁; ▁} ▁c out ▁<< ▁cur _ date ▁<< ▁" ▁" ▁<< ▁month ▁[ ▁cur _ month ▁] ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁D ▁= ▁15 ▁; ▁string ▁M ▁= ▁" ▁January ▁" ▁; ▁getDate ▁( ▁D ▁, ▁M ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print Last Element ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁bool ▁left Turn ▁= ▁true ▁; ▁int ▁remain Elements ▁= ▁N ▁; ▁int ▁step ▁= ▁1 ▁; ▁int ▁head ▁= ▁1 ▁; ▁while ▁( ▁remain Elements ▁> ▁1 ▁) ▁{ ▁if ▁( ▁left Turn ▁) ▁{ ▁head ▁= ▁head ▁+ ▁step ▁; ▁} ▁else ▁{ ▁if ▁( ▁remain Elements ▁% ▁2 ▁== ▁1 ▁) ▁head ▁= ▁head ▁+ ▁step ▁; ▁} ▁remain Elements ▁= ▁remain Elements ▁/ ▁2 ▁; ▁step ▁= ▁step ▁* ▁2 ▁; ▁left Turn ▁= ▁! ▁left Turn ▁; ▁} ▁c out ▁<< ▁arr ▁[ ▁head ▁- ▁1 ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁print Last Element ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁string ▁freq Check ▁( ▁string ▁S ▁, ▁int ▁N ▁) ▁{ ▁int ▁hash ▁[ ▁26 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁hash ▁[ ▁S ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁26 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁hash ▁[ ▁i ▁] ▁> ▁2 ▁) ▁{ ▁return ▁" ▁Yes ▁" ▁; ▁} ▁} ▁return ▁" ▁No ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁S ▁= ▁" ▁g eek seek forge ek s ▁" ▁; ▁int ▁N ▁= ▁S ▁. ▁length ▁( ▁) ▁; ▁c out ▁<< ▁freq Check ▁( ▁S ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁min steps ▁( ▁vector ▁< ▁int ▁> ▁& ▁A ▁) ▁{ ▁int ▁n ▁= ▁A ▁. ▁size ▁( ▁) ▁; ▁vector ▁< ▁int ▁> ▁left ▁( ▁n ▁, ▁0 ▁) ▁, ▁right ▁( ▁n ▁, ▁0 ▁) ▁, ▁res ▁( ▁n ▁, ▁0 ▁) ▁; ▁int ▁count ▁= ▁A ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁left ▁[ ▁i ▁] ▁= ▁left ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁count ▁; ▁count ▁+= ▁A ▁[ ▁i ▁] ▁; ▁} ▁count ▁= ▁A ▁[ ▁n ▁- ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁2 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁right ▁[ ▁i ▁] ▁= ▁right ▁[ ▁i ▁+ ▁1 ▁] ▁+ ▁count ▁; ▁count ▁+= ▁A ▁[ ▁i ▁] ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁res ▁[ ▁i ▁] ▁= ▁left ▁[ ▁i ▁] ▁+ ▁right ▁[ ▁i ▁] ▁; ▁c out ▁<< ▁res ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁} ▁c out ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁int ▁> ▁A ▁= ▁{ ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁} ▁; ▁min steps ▁( ▁A ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁minimum Operations ▁( ▁vector ▁< ▁int ▁> ▁& ▁A ▁, ▁int ▁K ▁) ▁{ ▁vector ▁< ▁int ▁> ▁is fli pped ▁( ▁A ▁. ▁size ▁( ▁) ▁, ▁0 ▁) ▁; ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁A ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁> ▁0 ▁) ▁{ ▁is fli pped ▁[ ▁i ▁] ▁+= ▁is fli pped ▁[ ▁i ▁- ▁1 ▁] ▁; ▁is fli pped ▁[ ▁i ▁] ▁% = ▁2 ▁; ▁} ▁if ▁( ▁A ▁[ ▁i ▁] ▁== ▁0 ▁&& ▁! ▁is fli pped ▁[ ▁i ▁] ▁) ▁{ ▁if ▁( ▁( ▁A ▁. ▁size ▁( ▁) ▁- ▁i ▁+ ▁1 ▁) ▁<= ▁K ▁) ▁{ ▁c out ▁<< ▁-1 ▁; ▁return ▁; ▁} ▁ans ▁++ ▁; ▁is fli pped ▁[ ▁i ▁] ▁++ ▁; ▁is fli pped ▁[ ▁i ▁+ ▁K ▁] ▁-- ▁; ▁} ▁else ▁if ▁( ▁A ▁[ ▁i ▁] ▁== ▁1 ▁&& ▁is fli pped ▁[ ▁i ▁] ▁) ▁{ ▁if ▁( ▁( ▁A ▁. ▁size ▁( ▁) ▁- ▁i ▁+ ▁1 ▁) ▁<= ▁K ▁) ▁{ ▁c out ▁<< ▁-1 ▁; ▁return ▁; ▁} ▁ans ▁++ ▁; ▁is fli pped ▁[ ▁i ▁] ▁++ ▁; ▁is fli pped ▁[ ▁i ▁+ ▁K ▁] ▁-- ▁; ▁} ▁} ▁c out ▁<< ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁int ▁> ▁arr ▁= ▁{ ▁0 ▁, ▁1 ▁, ▁0 ▁} ▁; ▁int ▁K ▁= ▁1 ▁; ▁minimum Operations ▁( ▁arr ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁Convert Array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁if ▁( ▁N ▁== ▁1 ▁) ▁{ ▁c out ▁<< ▁" ▁Operation ▁1 ▁: ▁" ▁<< ▁1 ▁<< ▁" ▁" ▁<< ▁1 ▁<< ▁end l ▁; ▁c out ▁<< ▁" ▁Added ▁elements ▁: ▁" ▁<< ▁-1 ▁* ▁arr ▁[ ▁0 ▁] ▁<< ▁end l ▁; ▁c out ▁<< ▁end l ▁; ▁c out ▁<< ▁" ▁Operation ▁2 ▁: ▁" ▁<< ▁1 ▁<< ▁" ▁" ▁<< ▁1 ▁<< ▁end l ▁; ▁c out ▁<< ▁" ▁Added ▁elements ▁: ▁" ▁<< ▁1 ▁* ▁arr ▁[ ▁0 ▁] ▁<< ▁end l ▁; ▁c out ▁<< ▁end l ▁; ▁c out ▁<< ▁" ▁Operation ▁3 ▁: ▁" ▁<< ▁1 ▁<< ▁" ▁" ▁<< ▁1 ▁<< ▁end l ▁; ▁c out ▁<< ▁" ▁Added ▁elements ▁: ▁" ▁<< ▁-1 ▁* ▁arr ▁[ ▁0 ▁] ▁<< ▁end l ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁" ▁Operation ▁1 ▁: ▁" ▁<< ▁1 ▁<< ▁" ▁" ▁<< ▁N ▁<< ▁end l ▁; ▁c out ▁<< ▁" ▁Added ▁elements ▁: ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁c out ▁<< ▁-1 ▁* ▁arr ▁[ ▁i ▁] ▁* ▁N ▁<< ▁" ▁" ▁; ▁} ▁c out ▁<< ▁end l ▁; ▁c out ▁<< ▁end l ▁; ▁c out ▁<< ▁" ▁Operation ▁2 ▁: ▁" ▁<< ▁1 ▁<< ▁" ▁" ▁<< ▁N ▁- ▁1 ▁<< ▁end l ▁; ▁c out ▁<< ▁" ▁Added ▁elements ▁: ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁* ▁( ▁N ▁- ▁1 ▁) ▁<< ▁" ▁" ▁; ▁} ▁c out ▁<< ▁end l ▁; ▁c out ▁<< ▁end l ▁; ▁c out ▁<< ▁" ▁Operation ▁3 ▁: ▁" ▁<< ▁N ▁<< ▁" ▁" ▁<< ▁N ▁<< ▁end l ▁; ▁c out ▁<< ▁" ▁Added ▁elements ▁: ▁" ▁; ▁c out ▁<< ▁arr ▁[ ▁N ▁- ▁1 ▁] ▁* ▁( ▁N ▁- ▁1 ▁) ▁<< ▁end l ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁2 ▁, ▁4 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁Convert Array ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁MAX ▁1000000 ▁NEW _ LINE ▁void ▁count Of Pr im ef act ors ▁( ▁vector ▁< ▁int ▁> ▁& ▁Count Distinct ▁) ▁{ ▁bool ▁prime ▁[ ▁MAX ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁MAX ▁; ▁i ▁++ ▁) ▁{ ▁Count Distinct ▁[ ▁i ▁] ▁= ▁0 ▁; ▁prime ▁[ ▁i ▁] ▁= ▁true ▁; ▁} ▁for ▁( ▁long ▁long ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁MAX ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁i ▁] ▁== ▁true ▁) ▁{ ▁Count Distinct ▁[ ▁i ▁] ▁= ▁1 ▁; ▁for ▁( ▁long ▁long ▁int ▁j ▁= ▁i ▁* ▁2 ▁; ▁j ▁<= ▁MAX ▁; ▁j ▁+= ▁i ▁) ▁{ ▁Count Distinct ▁[ ▁j ▁] ▁++ ▁; ▁prime ▁[ ▁j ▁] ▁= ▁false ▁; ▁} ▁} ▁} ▁} ▁int ▁Count Even Pair ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁B ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁M ▁) ▁{ ▁vector ▁< ▁int ▁> ▁count Distinct ▁( ▁MAX ▁+ ▁1 ▁) ▁; ▁count Of Pr im ef act ors ▁( ▁count Distinct ▁) ▁; ▁int ▁even Count ▁= ▁0 ▁; ▁int ▁odd Count ▁= ▁0 ▁; ▁int ▁even Pairs ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁M ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁count Distinct ▁[ ▁B ▁[ ▁i ▁] ▁] ▁== ▁0 ▁) ▁continue ▁; ▁if ▁( ▁count Distinct ▁[ ▁B ▁[ ▁i ▁] ▁] ▁& ▁1 ▁) ▁{ ▁odd Count ▁++ ▁; ▁} ▁else ▁{ ▁even Count ▁++ ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁count Distinct ▁[ ▁A ▁[ ▁i ▁] ▁] ▁== ▁0 ▁) ▁continue ▁; ▁if ▁( ▁count Distinct ▁[ ▁A ▁[ ▁i ▁] ▁] ▁& ▁1 ▁) ▁{ ▁even Pairs ▁+= ▁( ▁even Count ▁) ▁; ▁} ▁else ▁{ ▁even Pairs ▁+= ▁even Count ▁+ ▁odd Count ▁; ▁} ▁} ▁return ▁even Pairs ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁; ▁int ▁B ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁A ▁) ▁/ ▁sizeof ▁( ▁A ▁[ ▁0 ▁] ▁) ▁; ▁int ▁M ▁= ▁sizeof ▁( ▁B ▁) ▁/ ▁sizeof ▁( ▁B ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁Count Even Pair ▁( ▁A ▁, ▁B ▁, ▁N ▁, ▁M ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁longest Sub array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁unordered _ map ▁< ▁int ▁, ▁int ▁> ▁um ▁; ▁int ▁sum ▁= ▁0 ▁, ▁max Len ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁if ▁( ▁sum ▁== ▁K ▁) ▁max Len ▁= ▁i ▁+ ▁1 ▁; ▁if ▁( ▁um ▁. ▁find ▁( ▁sum ▁) ▁== ▁um ▁. ▁end ▁( ▁) ▁) ▁um ▁[ ▁sum ▁] ▁= ▁i ▁; ▁if ▁( ▁um ▁. ▁find ▁( ▁sum ▁- ▁K ▁) ▁!= ▁um ▁. ▁end ▁( ▁) ▁) ▁{ ▁if ▁( ▁max Len ▁< ▁( ▁i ▁- ▁um ▁[ ▁sum ▁- ▁K ▁] ▁) ▁) ▁max Len ▁= ▁i ▁- ▁um ▁[ ▁sum ▁- ▁K ▁] ▁; ▁} ▁} ▁return ▁max Len ▁; ▁} ▁void ▁min Required Operation ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁int ▁Total Sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁Total Sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁int ▁max Len ▁= ▁longest Sub array ▁( ▁arr ▁, ▁N ▁, ▁Total Sum ▁- ▁K ▁) ▁; ▁if ▁( ▁max Len ▁== ▁-1 ▁) ▁{ ▁c out ▁<< ▁-1 ▁; ▁} ▁else ▁c out ▁<< ▁N ▁- ▁max Len ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁1 ▁, ▁1 ▁, ▁2 ▁} ▁; ▁int ▁K ▁= ▁4 ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁min Required Operation ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁count Even Odd ▁( ▁int ▁L ▁, ▁int ▁R ▁) ▁{ ▁int ▁range ▁= ▁R ▁- ▁L ▁+ ▁1 ▁; ▁int ▁even ▁= ▁( ▁range ▁/ ▁4 ▁) ▁* ▁2 ▁; ▁if ▁( ▁( ▁L ▁& ▁1 ▁) ▁&& ▁( ▁range ▁% ▁4 ▁== ▁3 ▁) ▁) ▁{ ▁even ▁++ ▁; ▁} ▁else ▁if ▁( ▁! ▁( ▁L ▁& ▁1 ▁) ▁&& ▁( ▁range ▁% ▁4 ▁) ▁) ▁{ ▁even ▁++ ▁; ▁} ▁c out ▁<< ▁" ▁Even ▁= ▁" ▁<< ▁even ▁<< ▁" ▁, ▁O dd ▁= ▁" ▁<< ▁range ▁- ▁even ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁L ▁= ▁2 ▁, ▁R ▁= ▁7 ▁; ▁count Even Odd ▁( ▁L ▁, ▁R ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁maximum C and y ▁( ▁int ▁cand ies ▁[ ▁] ▁, ▁int ▁safety ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁M ▁) ▁{ ▁int ▁total ▁= ▁0 ▁; ▁int ▁ans ▁= ▁INT _ MAX ▁; ▁bool ▁all _ safe ▁= ▁true ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁cand ies ▁[ ▁i ▁] ▁+ ▁M ▁> ▁safety ▁[ ▁i ▁] ▁) ▁{ ▁all _ safe ▁= ▁false ▁; ▁ans ▁= ▁min ▁( ▁ans ▁, ▁safety ▁[ ▁i ▁] ▁) ▁; ▁} ▁else ▁{ ▁ans ▁= ▁min ▁( ▁ans ▁, ▁cand ies ▁[ ▁i ▁] ▁+ ▁M ▁) ▁; ▁} ▁total ▁+= ▁cand ies ▁[ ▁i ▁] ▁; ▁} ▁if ▁( ▁all _ safe ▁) ▁return ▁total ▁; ▁else ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁4 ▁, ▁1 ▁, ▁9 ▁, ▁6 ▁} ▁; ▁int ▁B ▁[ ▁] ▁= ▁{ ▁8 ▁, ▁7 ▁, ▁3 ▁, ▁12 ▁, ▁7 ▁} ▁; ▁int ▁M ▁= ▁0 ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁A ▁) ▁/ ▁sizeof ▁( ▁A ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁maximum C and y ▁( ▁A ▁, ▁B ▁, ▁N ▁, ▁M ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁construct _ Array ▁( ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁c out ▁<< ▁K ▁* ▁i ▁<< ▁" ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁3 ▁, ▁K ▁= ▁3 ▁; ▁construct _ Array ▁( ▁N ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁Print ▁( ▁int ▁N ▁) ▁{ ▁if ▁( ▁( ▁N ▁/ ▁2 ▁) ▁% ▁2 ▁== ▁1 ▁|| ▁( ▁N ▁% ▁2 ▁== ▁1 ▁) ▁) ▁{ ▁c out ▁<< ▁-1 ▁<< ▁end l ▁; ▁return ▁; ▁} ▁int ▁Cur Even ▁= ▁2 ▁, ▁Cur Odd ▁= ▁1 ▁; ▁int ▁Sum Odd ▁= ▁0 ▁, ▁Sum Even ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁( ▁N ▁/ ▁2 ▁) ▁; ▁i ▁++ ▁) ▁{ ▁c out ▁<< ▁Cur Even ▁<< ▁" ▁" ▁; ▁Sum Even ▁+= ▁Cur Even ▁; ▁Cur Even ▁+= ▁2 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁/ ▁2 ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁c out ▁<< ▁Cur Odd ▁<< ▁" ▁" ▁; ▁Sum Odd ▁+= ▁Cur Odd ▁; ▁Cur Odd ▁+= ▁2 ▁; ▁} ▁Cur Odd ▁= ▁Sum Even ▁- ▁Sum Odd ▁; ▁c out ▁<< ▁Cur Odd ▁<< ▁' ▁' ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁12 ▁; ▁Print ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁Minimum M oves ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁B ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁total Operations ▁= ▁0 ▁; ▁int ▁carry ▁= ▁0 ▁; ▁int ▁K ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁N ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁int ▁nearest Multiple ▁= ▁ceil ▁( ▁( ▁double ▁) ▁( ▁A ▁[ ▁i ▁] ▁+ ▁carry ▁) ▁/ ▁( ▁double ▁) ▁( ▁B ▁[ ▁i ▁] ▁) ▁) ▁* ▁B ▁[ ▁i ▁] ▁; ▁K ▁= ▁nearest Multiple ▁- ▁( ▁A ▁[ ▁i ▁] ▁+ ▁carry ▁) ▁; ▁total Operations ▁+= ▁K ▁; ▁carry ▁+= ▁K ▁; ▁} ▁return ▁total Operations ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁2 ▁, ▁5 ▁, ▁5 ▁, ▁9 ▁} ▁; ▁int ▁B ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁1 ▁, ▁9 ▁, ▁6 ▁, ▁3 ▁, ▁8 ▁, ▁7 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁A ▁) ▁/ ▁sizeof ▁( ▁A ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁Minimum M oves ▁( ▁A ▁, ▁B ▁, ▁N ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁minimum Dev iation ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁set ▁< ▁int ▁> ▁s ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁A ▁[ ▁i ▁] ▁% ▁2 ▁== ▁0 ▁) ▁s ▁. ▁insert ▁( ▁A ▁[ ▁i ▁] ▁) ▁; ▁else ▁s ▁. ▁insert ▁( ▁2 ▁* ▁A ▁[ ▁i ▁] ▁) ▁; ▁} ▁int ▁diff ▁= ▁* ▁s ▁. ▁rb egin ▁( ▁) ▁- ▁* ▁s ▁. ▁begin ▁( ▁) ▁; ▁while ▁( ▁( ▁int ▁) ▁s ▁. ▁size ▁( ▁) ▁&& ▁* ▁s ▁. ▁rb egin ▁( ▁) ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁int ▁max El ▁= ▁* ▁s ▁. ▁rb egin ▁( ▁) ▁; ▁s ▁. ▁erase ▁( ▁max El ▁) ▁; ▁s ▁. ▁insert ▁( ▁max El ▁/ ▁2 ▁) ▁; ▁diff ▁= ▁min ▁( ▁diff ▁, ▁* ▁s ▁. ▁rb egin ▁( ▁) ▁- ▁* ▁s ▁. ▁begin ▁( ▁) ▁) ▁; ▁} ▁c out ▁<< ▁diff ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁1 ▁, ▁5 ▁, ▁20 ▁, ▁3 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁A ▁) ▁/ ▁sizeof ▁( ▁A ▁[ ▁0 ▁] ▁) ▁; ▁minimum Dev iation ▁( ▁A ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁Find w inner Of Game ▁( ▁string ▁& ▁S ▁) ▁{ ▁int ▁cnt Zero ▁= ▁0 ▁; ▁int ▁cnt Con One ▁= ▁0 ▁; ▁int ▁nim Sum ▁= ▁0 ▁; ▁int ▁N ▁= ▁S ▁. ▁length ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁S ▁[ ▁i ▁] ▁== ▁'1' ▁) ▁{ ▁cnt Con One ▁+= ▁1 ▁; ▁} ▁else ▁{ ▁nim Sum ▁^= ▁cnt Con One ▁; ▁cnt Con One ▁= ▁0 ▁; ▁cnt Zero ▁++ ▁; ▁} ▁} ▁nim Sum ▁^= ▁cnt Con One ▁; ▁if ▁( ▁cnt Zero ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁c out ▁<< ▁" ▁T ie ▁" ▁; ▁} ▁else ▁if ▁( ▁nim Sum ▁) ▁{ ▁c out ▁<< ▁" ▁player ▁1" ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁" ▁player ▁2" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁S ▁= ▁"01 100 11" ▁; ▁Find w inner Of Game ▁( ▁S ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁min M oves ▁( ▁vector ▁< ▁int ▁> ▁arr ▁) ▁{ ▁int ▁N ▁= ▁arr ▁. ▁size ▁( ▁) ▁; ▁if ▁( ▁N ▁<= ▁2 ▁) ▁return ▁0 ▁; ▁int ▁ans ▁= ▁INT _ MAX ▁; ▁for ▁( ▁int ▁i ▁= ▁-1 ▁; ▁i ▁<= ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁-1 ▁; ▁j ▁<= ▁1 ▁; ▁j ▁++ ▁) ▁{ ▁int ▁num 1 ▁= ▁arr ▁[ ▁0 ▁] ▁+ ▁i ▁; ▁int ▁num 2 ▁= ▁arr ▁[ ▁1 ▁] ▁+ ▁j ▁; ▁int ▁flag ▁= ▁1 ▁; ▁int ▁moves ▁= ▁abs ▁( ▁i ▁) ▁+ ▁abs ▁( ▁j ▁) ▁; ▁for ▁( ▁int ▁idx ▁= ▁2 ▁; ▁idx ▁< ▁N ▁; ▁idx ▁++ ▁) ▁{ ▁int ▁num ▁= ▁num 1 ▁+ ▁num 2 ▁; ▁if ▁( ▁abs ▁( ▁arr ▁[ ▁idx ▁] ▁- ▁num ▁) ▁> ▁1 ▁) ▁flag ▁= ▁0 ▁; ▁else ▁moves ▁+= ▁abs ▁( ▁arr ▁[ ▁idx ▁] ▁- ▁num ▁) ▁; ▁num 1 ▁= ▁num 2 ▁; ▁num 2 ▁= ▁num ▁; ▁} ▁if ▁( ▁flag ▁) ▁ans ▁= ▁min ▁( ▁ans ▁, ▁moves ▁) ▁; ▁} ▁} ▁if ▁( ▁ans ▁== ▁INT _ MAX ▁) ▁return ▁-1 ▁; ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁int ▁> ▁arr ▁= ▁{ ▁4 ▁, ▁8 ▁, ▁9 ▁, ▁17 ▁, ▁27 ▁} ▁; ▁c out ▁<< ▁min M oves ▁( ▁arr ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁max k sum ▁( ▁int ▁L ▁, ▁int ▁R ▁, ▁int ▁K ▁) ▁{ ▁int ▁N ▁= ▁( ▁R ▁/ ▁10 ▁- ▁L ▁/ ▁10 ▁) ▁+ ▁1 ▁; ▁if ▁( ▁K ▁> ▁N ▁) ▁{ ▁c out ▁<< ▁-1 ▁; ▁return ▁; ▁} ▁R ▁= ▁R ▁/ ▁10 ▁; ▁int ▁X ▁= ▁R ▁- ▁K ▁; ▁int ▁sum ▁= ▁10 ▁* ▁( ▁( ▁R ▁* ▁( ▁R ▁+ ▁1 ▁) ▁) ▁/ ▁2 ▁- ▁( ▁X ▁* ▁( ▁X ▁+ ▁1 ▁) ▁) ▁/ ▁2 ▁) ▁; ▁c out ▁<< ▁sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁L ▁= ▁16 ▁, ▁R ▁= ▁60 ▁, ▁K ▁= ▁4 ▁; ▁max k sum ▁( ▁L ▁, ▁R ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Long est Non Dec re asing ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁res ▁= ▁0 ▁; ▁int ▁start ▁= ▁0 ▁; ▁int ▁end ▁= ▁N ▁- ▁1 ▁; ▁int ▁prev ▁= ▁-1 ▁; ▁while ▁( ▁start ▁<= ▁end ▁) ▁{ ▁if ▁( ▁A ▁[ ▁start ▁] ▁<= ▁A ▁[ ▁end ▁] ▁) ▁{ ▁if ▁( ▁prev ▁== ▁-1 ▁) ▁{ ▁prev ▁= ▁A ▁[ ▁start ▁] ▁; ▁res ▁++ ▁; ▁start ▁++ ▁; ▁} ▁else ▁{ ▁if ▁( ▁A ▁[ ▁start ▁] ▁>= ▁prev ▁) ▁{ ▁res ▁++ ▁; ▁prev ▁= ▁A ▁[ ▁start ▁] ▁; ▁start ▁++ ▁; ▁} ▁else ▁if ▁( ▁A ▁[ ▁end ▁] ▁>= ▁prev ▁) ▁{ ▁res ▁++ ▁; ▁prev ▁= ▁A ▁[ ▁end ▁] ▁; ▁end ▁-- ▁; ▁} ▁else ▁{ ▁break ▁; ▁} ▁} ▁} ▁else ▁{ ▁if ▁( ▁prev ▁== ▁-1 ▁) ▁{ ▁prev ▁= ▁A ▁[ ▁end ▁] ▁; ▁res ▁++ ▁; ▁end ▁-- ▁; ▁} ▁else ▁{ ▁if ▁( ▁A ▁[ ▁end ▁] ▁>= ▁prev ▁) ▁{ ▁res ▁++ ▁; ▁prev ▁= ▁A ▁[ ▁end ▁] ▁; ▁end ▁-- ▁; ▁} ▁else ▁if ▁( ▁A ▁[ ▁start ▁] ▁>= ▁prev ▁) ▁{ ▁res ▁++ ▁; ▁prev ▁= ▁A ▁[ ▁start ▁] ▁; ▁start ▁++ ▁; ▁} ▁else ▁{ ▁break ▁; ▁} ▁} ▁} ▁} ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁1 ▁, ▁3 ▁, ▁5 ▁, ▁4 ▁, ▁3 ▁, ▁6 ▁, ▁2 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁A ▁) ▁/ ▁sizeof ▁( ▁A ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁find Long est Non Dec re asing ▁( ▁A ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find Pairs ▁( ▁int ▁N ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁c out ▁<< ▁" ▁( ▁" ▁<< ▁i ▁<< ▁" ▁, ▁" ▁<< ▁N ▁- ▁i ▁<< ▁" ▁) ▁, ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁5 ▁; ▁find Pairs ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁Min Operation ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁int ▁cnt O pe ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁K ▁> ▁arr ▁[ ▁i ▁] ▁) ▁{ ▁if ▁( ▁( ▁K ▁- ▁arr ▁[ ▁i ▁] ▁) ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁cnt O pe ▁+= ▁2 ▁; ▁} ▁else ▁{ ▁cnt O pe ▁+= ▁1 ▁; ▁} ▁} ▁else ▁if ▁( ▁K ▁< ▁arr ▁[ ▁i ▁] ▁) ▁{ ▁if ▁( ▁( ▁K ▁- ▁arr ▁[ ▁i ▁] ▁) ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁cnt O pe ▁+= ▁1 ▁; ▁} ▁else ▁{ ▁cnt O pe ▁+= ▁2 ▁; ▁} ▁} ▁} ▁return ▁cnt O pe ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁8 ▁, ▁7 ▁, ▁2 ▁, ▁1 ▁, ▁3 ▁} ▁; ▁int ▁K ▁= ▁5 ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁Min Operation ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁cl st Num ▁( ▁int ▁N ▁) ▁{ ▁return ▁( ▁N ▁- ▁1 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁11 ▁; ▁c out ▁<< ▁cl st Num ▁( ▁N ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁float ▁pair Product Mean ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁vector ▁< ▁int ▁> ▁pair Array ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁int ▁pair Product ▁= ▁arr ▁[ ▁i ▁] ▁* ▁arr ▁[ ▁j ▁] ▁; ▁pair Array ▁. ▁push _ back ▁( ▁pair Product ▁) ▁; ▁} ▁} ▁int ▁length ▁= ▁pair Array ▁. ▁size ▁( ▁) ▁; ▁float ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁length ▁; ▁i ▁++ ▁) ▁sum ▁+= ▁pair Array ▁[ ▁i ▁] ▁; ▁float ▁mean ▁; ▁if ▁( ▁length ▁!= ▁0 ▁) ▁mean ▁= ▁sum ▁/ ▁length ▁; ▁else ▁mean ▁= ▁0 ▁; ▁return ▁mean ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁4 ▁, ▁8 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁fixed ▁<< ▁set precision ▁( ▁2 ▁) ▁<< ▁pair Product Mean ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁min Prod ▁( ▁int ▁X ▁, ▁int ▁Y ▁, ▁int ▁N ▁) ▁{ ▁if ▁( ▁X ▁<= ▁Y ▁) ▁{ ▁if ▁( ▁N ▁< ▁X ▁) ▁return ▁( ▁X ▁- ▁N ▁) ▁* ▁Y ▁; ▁else ▁{ ▁return ▁max ▁( ▁Y ▁- ▁( ▁N ▁- ▁X ▁+ ▁1 ▁) ▁, ▁1 ▁) ▁; ▁} ▁} ▁if ▁( ▁Y ▁>= ▁N ▁) ▁return ▁( ▁Y ▁- ▁N ▁) ▁* ▁X ▁; ▁return ▁max ▁( ▁X ▁- ▁( ▁N ▁- ▁Y ▁+ ▁1 ▁) ▁, ▁1 ▁) ▁; ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁X ▁= ▁47 ▁, ▁Y ▁= ▁42 ▁, ▁N ▁= ▁16 7 ▁; ▁c out ▁<< ▁min Prod ▁( ▁X ▁, ▁Y ▁, ▁N ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁factors Of 3 ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁a ▁= ▁0 ▁, ▁b ▁= ▁0 ▁, ▁c ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁% ▁3 ▁== ▁0 ▁) ▁a ▁++ ▁; ▁else ▁if ▁( ▁arr ▁[ ▁i ▁] ▁% ▁3 ▁== ▁1 ▁) ▁b ▁++ ▁; ▁else ▁if ▁( ▁arr ▁[ ▁i ▁] ▁% ▁3 ▁== ▁2 ▁) ▁c ▁++ ▁; ▁} ▁if ▁( ▁a ▁>= ▁1 ▁&& ▁a ▁<= ▁b ▁+ ▁c ▁+ ▁1 ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁<< ▁end l ▁; ▁else ▁if ▁( ▁a ▁== ▁0 ▁&& ▁b ▁== ▁0 ▁&& ▁c ▁> ▁0 ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁<< ▁end l ▁; ▁else ▁if ▁( ▁a ▁== ▁0 ▁&& ▁c ▁== ▁0 ▁&& ▁b ▁> ▁0 ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁<< ▁end l ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁3 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁factors Of 3 ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max B ott les ▁( ▁int ▁n ▁, ▁int ▁e ▁) ▁{ ▁int ▁s ▁= ▁0 ▁, ▁b ▁= ▁0 ▁; ▁int ▁a ▁= ▁n ▁; ▁while ▁( ▁a ▁!= ▁0 ▁) ▁{ ▁s ▁= ▁s ▁+ ▁a ▁; ▁a ▁= ▁( ▁a ▁+ ▁b ▁) ▁/ ▁e ▁; ▁b ▁= ▁n ▁- ▁( ▁a ▁* ▁e ▁) ▁; ▁n ▁= ▁a ▁+ ▁b ▁; ▁} ▁return ▁s ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁9 ▁, ▁e ▁= ▁3 ▁; ▁int ▁s ▁= ▁max B ott les ▁( ▁n ▁, ▁e ▁) ▁; ▁c out ▁<< ▁s ▁<< ▁end l ▁; ▁}
▁# include ▁< std io . h > ▁NEW _ LINE ▁# define ▁ll ▁long ▁long ▁NEW _ LINE ▁ll ▁power ▁( ▁ll ▁x ▁, ▁ll ▁n ▁) ▁{ ▁ll ▁temp ▁; ▁if ▁( ▁n ▁== ▁0 ▁) ▁return ▁1 ▁; ▁temp ▁= ▁power ▁( ▁x ▁, ▁n ▁/ ▁2 ▁) ▁; ▁if ▁( ▁n ▁% ▁2 ▁== ▁0 ▁) ▁return ▁temp ▁* ▁temp ▁; ▁else ▁return ▁x ▁* ▁temp ▁* ▁temp ▁; ▁} ▁ll ▁count _ Total _ Numbers ▁( ▁ll ▁n ▁, ▁ll ▁x ▁) ▁{ ▁ll ▁total ▁, ▁multiples ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁10 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁% ▁x ▁== ▁0 ▁) ▁multiples ▁++ ▁; ▁} ▁if ▁( ▁n ▁== ▁1 ▁) ▁return ▁multiples ▁; ▁total ▁= ▁( ▁multiples ▁- ▁1 ▁) ▁* ▁power ▁( ▁multiples ▁, ▁n ▁- ▁1 ▁) ▁; ▁return ▁total ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁ll ▁N ▁= ▁1 ▁, ▁X ▁= ▁3 ▁; ▁printf ▁( ▁" ▁% ▁l ld ▁" ▁, ▁count _ Total _ Numbers ▁( ▁N ▁, ▁X ▁) ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁min Length ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁elem ▁= ▁A ▁[ ▁0 ▁] ▁, ▁count ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁A ▁[ ▁i ▁] ▁== ▁elem ▁) ▁{ ▁count ▁++ ▁; ▁} ▁else ▁{ ▁break ▁; ▁} ▁} ▁if ▁( ▁count ▁== ▁N ▁) ▁return ▁N ▁; ▁else ▁return ▁1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁1 ▁, ▁3 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁min Length ▁( ▁arr ▁, ▁N ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁min Sub arrays ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁right ▁= ▁n ▁- ▁1 ▁; ▁int ▁left ▁= ▁0 ▁; ▁int ▁sub arrays ▁= ▁0 ▁; ▁while ▁( ▁right ▁>= ▁0 ▁) ▁{ ▁for ▁( ▁left ▁= ▁0 ▁; ▁left ▁<= ▁right ▁; ▁left ▁+= ▁1 ▁) ▁{ ▁if ▁( ▁__ g cd ▁( ▁arr ▁[ ▁left ▁] ▁, ▁arr ▁[ ▁right ▁] ▁) ▁> ▁1 ▁) ▁{ ▁sub arrays ▁+= ▁1 ▁; ▁right ▁= ▁left ▁- ▁1 ▁; ▁break ▁; ▁} ▁if ▁( ▁left ▁== ▁right ▁&& ▁__ g cd ▁( ▁arr ▁[ ▁left ▁] ▁, ▁arr ▁[ ▁right ▁] ▁) ▁== ▁1 ▁) ▁{ ▁return ▁0 ▁; ▁} ▁} ▁} ▁return ▁sub arrays ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁6 ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁4 ▁, ▁4 ▁, ▁3 ▁} ▁; ▁c out ▁<< ▁min Sub arrays ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print Missing Elements ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁diff ▁= ▁arr ▁[ ▁0 ▁] ▁- ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁- ▁i ▁!= ▁diff ▁) ▁{ ▁while ▁( ▁diff ▁< ▁arr ▁[ ▁i ▁] ▁- ▁i ▁) ▁{ ▁c out ▁<< ▁i ▁+ ▁diff ▁<< ▁" ▁" ▁; ▁diff ▁++ ▁; ▁} ▁} ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁6 ▁, ▁7 ▁, ▁10 ▁, ▁11 ▁, ▁13 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁print Missing Elements ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print Missing Elements ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁b ▁[ ▁arr ▁[ ▁N ▁- ▁1 ▁] ▁+ ▁1 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁b ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁= ▁1 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁i ▁<= ▁arr ▁[ ▁N ▁- ▁1 ▁] ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁b ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁c out ▁<< ▁i ▁<< ▁" ▁" ▁; ▁} ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁6 ▁, ▁7 ▁, ▁10 ▁, ▁11 ▁, ▁13 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁print Missing Elements ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁int ▁mod ▁= ▁1 e 9 ▁+ ▁7 ▁; ▁int ▁power ▁( ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁if ▁( ▁y ▁== ▁0 ▁) ▁return ▁1 ▁; ▁int ▁p ▁= ▁power ▁( ▁x ▁, ▁y ▁/ ▁2 ▁) ▁% ▁mod ▁; ▁p ▁= ▁( ▁p ▁* ▁p ▁) ▁% ▁mod ▁; ▁if ▁( ▁y ▁& ▁1 ▁) ▁p ▁= ▁( ▁x ▁* ▁p ▁) ▁% ▁mod ▁; ▁return ▁p ▁; ▁} ▁int ▁Number Of Trees ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁max Element ▁= ▁* ▁max _ element ▁( ▁arr ▁, ▁arr ▁+ ▁N ▁) ▁; ▁int ▁level ▁[ ▁max Element ▁+ ▁1 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁level ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁++ ▁; ▁} ▁if ▁( ▁arr ▁[ ▁0 ▁] ▁!= ▁0 ▁level ▁[ ▁0 ▁] ▁!= ▁1 ▁) ▁{ ▁return ▁0 ▁; ▁} ▁int ▁ans ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁max Element ▁; ▁i ▁++ ▁) ▁{ ▁ans ▁= ▁( ▁ans ▁* ▁power ▁( ▁level ▁[ ▁i ▁] ▁, ▁level ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁) ▁% ▁mod ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁7 ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁3 ▁, ▁2 ▁, ▁1 ▁, ▁2 ▁, ▁2 ▁, ▁1 ▁} ▁; ▁c out ▁<< ▁Number Of Trees ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁carry Count ▁( ▁int ▁num 1 ▁, ▁int ▁num 2 ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁while ▁( ▁num 2 ▁!= ▁0 ▁) ▁{ ▁int ▁carry ▁= ▁num 1 ▁& ▁num 2 ▁; ▁num 1 ▁= ▁num 1 ▁^ ▁num 2 ▁; ▁num 2 ▁= ▁carry ▁<< ▁1 ▁; ▁count ▁+= ▁__ builtin _ pop count ▁( ▁num 2 ▁) ▁; ▁} ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁= ▁15 ▁, ▁B ▁= ▁10 ▁; ▁c out ▁<< ▁carry Count ▁( ▁15 ▁, ▁10 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁calculate Pro fit ▁( ▁int ▁n ▁, ▁int ▁* ▁e arning s ▁, ▁int ▁* ▁cost ▁, ▁int ▁e ▁) ▁{ ▁int ▁profit ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁e arning _ per _ day ▁= ▁0 ▁; ▁int ▁daily _ sp ent _ food ▁= ▁0 ▁; ▁if ▁( ▁i ▁== ▁( ▁n ▁- ▁1 ▁) ▁) ▁{ ▁e arning _ per _ day ▁= ▁e arning s ▁[ ▁i ▁] ▁* ▁e ▁; ▁profit ▁= ▁profit ▁+ ▁e arning _ per _ day ▁; ▁break ▁; ▁} ▁if ▁( ▁cost ▁[ ▁i ▁] ▁< ▁e arning s ▁[ ▁i ▁] ▁) ▁{ ▁e arning _ per _ day ▁= ▁e arning s ▁[ ▁i ▁] ▁* ▁e ▁; ▁daily _ sp ent _ food ▁= ▁cost ▁[ ▁i ▁] ▁* ▁e ▁; ▁profit ▁= ▁profit ▁+ ▁e arning _ per _ day ▁- ▁daily _ sp ent _ food ▁; ▁} ▁} ▁c out ▁<< ▁profit ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁4 ▁; ▁int ▁e arning s ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁8 ▁, ▁6 ▁, ▁7 ▁} ▁; ▁int ▁cost ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁4 ▁, ▁1 ▁} ▁; ▁int ▁e ▁= ▁5 ▁; ▁calculate Pro fit ▁( ▁n ▁, ▁e arning s ▁, ▁cost ▁, ▁e ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find Pair ▁( ▁int ▁A ▁, ▁int ▁B ▁, ▁int ▁N ▁) ▁{ ▁int ▁X ▁, ▁Y ▁; ▁X ▁= ▁N ▁- ▁B ▁+ ▁A ▁; ▁if ▁( ▁X ▁% ▁2 ▁!= ▁0 ▁) ▁{ ▁c out ▁<< ▁" ▁- ▁1" ▁; ▁} ▁else ▁{ ▁X ▁= ▁X ▁/ ▁2 ▁; ▁Y ▁= ▁N ▁- ▁X ▁; ▁c out ▁<< ▁X ▁<< ▁" ▁" ▁<< ▁Y ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁= ▁1 ▁; ▁int ▁B ▁= ▁3 ▁; ▁int ▁N ▁= ▁4 ▁; ▁find Pair ▁( ▁A ▁, ▁B ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁check ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁ma ▁= ▁a ▁[ ▁1 ▁] ▁- ▁a ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁a ▁[ ▁i ▁] ▁> ▁a ▁[ ▁i ▁- ▁1 ▁] ▁&& ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁< ▁a ▁[ ▁i ▁] ▁) ▁|| ▁( ▁a ▁[ ▁i ▁] ▁< ▁a ▁[ ▁i ▁- ▁1 ▁] ▁&& ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁> ▁a ▁[ ▁i ▁] ▁) ▁) ▁ma ▁= ▁max ▁( ▁ma ▁, ▁abs ▁( ▁a ▁[ ▁i ▁] ▁- ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁) ▁; ▁else ▁return ▁false ▁; ▁} ▁c out ▁<< ▁" ▁Am plitude ▁= ▁" ▁<< ▁ma ▁; ▁c out ▁<< ▁end l ▁; ▁return ▁true ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁1 ▁, ▁5 ▁, ▁0 ▁, ▁7 ▁, ▁- 6 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁a ▁/ ▁sizeof ▁a ▁[ ▁0 ▁] ▁; ▁int ▁wave ▁= ▁( ▁n ▁- ▁1 ▁) ▁/ ▁2 ▁; ▁if ▁( ▁check ▁( ▁a ▁, ▁n ▁) ▁) ▁c out ▁<< ▁" ▁W aves ▁= ▁" ▁<< ▁wave ▁; ▁else ▁c out ▁<< ▁" ▁- ▁1" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁string ▁Construct Binary String ▁( ▁int ▁N ▁, ▁int ▁M ▁, ▁int ▁K ▁) ▁{ ▁if ▁( ▁M ▁< ▁( ▁N ▁- ▁1 ▁) ▁|| ▁M ▁> ▁K ▁* ▁( ▁N ▁+ ▁1 ▁) ▁) ▁return ▁" ▁- ▁1" ▁; ▁string ▁ans ▁= ▁" ▁" ▁; ▁int ▁l ▁= ▁min ▁( ▁K ▁, ▁M ▁/ ▁( ▁N ▁- ▁1 ▁) ▁) ▁; ▁int ▁temp ▁= ▁N ▁; ▁while ▁( ▁temp ▁-- ▁) ▁{ ▁ans ▁+= ▁'0' ▁; ▁if ▁( ▁temp ▁== ▁0 ▁) ▁break ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁l ▁; ▁i ▁++ ▁) ▁{ ▁ans ▁+= ▁'1' ▁; ▁} ▁} ▁M ▁-= ▁( ▁N ▁- ▁1 ▁) ▁* ▁l ▁; ▁if ▁( ▁M ▁== ▁0 ▁) ▁return ▁ans ▁; ▁l ▁= ▁min ▁( ▁M ▁, ▁K ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁l ▁; ▁i ▁++ ▁) ▁ans ▁+= ▁'1' ▁; ▁M ▁-= ▁l ▁; ▁while ▁( ▁M ▁> ▁0 ▁) ▁{ ▁ans ▁= ▁'1' ▁+ ▁ans ▁; ▁M ▁-- ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁5 ▁, ▁M ▁= ▁9 ▁, ▁K ▁= ▁2 ▁; ▁c out ▁<< ▁Construct Binary String ▁( ▁N ▁, ▁M ▁, ▁K ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁no Of Fact ors ▁( ▁int ▁N ▁) ▁{ ▁if ▁( ▁N ▁== ▁1 ▁) ▁return ▁1 ▁; ▁int ▁count ▁= ▁0 ▁; ▁int ▁ans ▁= ▁1 ▁; ▁while ▁( ▁N ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁count ▁++ ▁; ▁N ▁= ▁N ▁/ ▁2 ▁; ▁} ▁ans ▁*= ▁( ▁count ▁/ ▁2 ▁+ ▁1 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁3 ▁; ▁i ▁* ▁i ▁<= ▁N ▁; ▁i ▁= ▁i ▁+ ▁2 ▁) ▁{ ▁count ▁= ▁0 ▁; ▁while ▁( ▁N ▁% ▁i ▁== ▁0 ▁) ▁{ ▁count ▁++ ▁; ▁N ▁= ▁N ▁/ ▁i ▁; ▁} ▁ans ▁*= ▁( ▁count ▁/ ▁2 ▁+ ▁1 ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁100 ▁; ▁c out ▁<< ▁no Of Fact ors ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print _ path ▁( ▁int ▁N ▁, ▁int ▁jump ▁, ▁int ▁coin ▁) ▁{ ▁if ▁( ▁jump ▁> ▁coin ▁|| ▁jump ▁* ▁( ▁N ▁- ▁1 ▁) ▁< ▁coin ▁) ▁{ ▁c out ▁<< ▁" ▁- ▁1" ▁<< ▁end l ▁; ▁} ▁else ▁{ ▁int ▁pos ▁= ▁1 ▁; ▁while ▁( ▁jump ▁> ▁0 ▁) ▁{ ▁int ▁tmp ▁= ▁min ▁( ▁N ▁- ▁1 ▁, ▁coin ▁- ▁( ▁jump ▁- ▁1 ▁) ▁) ▁; ▁if ▁( ▁pos ▁+ ▁tmp ▁<= ▁N ▁) ▁{ ▁pos ▁+= ▁tmp ▁; ▁} ▁else ▁{ ▁pos ▁-= ▁tmp ▁; ▁} ▁c out ▁<< ▁pos ▁<< ▁" ▁" ▁; ▁coin ▁-= ▁tmp ▁; ▁jump ▁-= ▁1 ▁; ▁} ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁5 ▁, ▁K ▁= ▁4 ▁, ▁M ▁= ▁12 ▁; ▁print _ path ▁( ▁N ▁, ▁K ▁, ▁M ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁min Changes ▁( ▁string ▁str ▁, ▁int ▁N ▁) ▁{ ▁int ▁res ▁; ▁int ▁count 0 ▁= ▁0 ▁, ▁count 1 ▁= ▁0 ▁; ▁for ▁( ▁char ▁x ▁: ▁str ▁) ▁{ ▁count 0 ▁+= ▁( ▁x ▁== ▁'0' ▁) ▁; ▁} ▁res ▁= ▁count 0 ▁; ▁for ▁( ▁char ▁x ▁: ▁str ▁) ▁{ ▁count 0 ▁-= ▁( ▁x ▁== ▁'0' ▁) ▁; ▁count 1 ▁+= ▁( ▁x ▁== ▁'1' ▁) ▁; ▁res ▁= ▁min ▁( ▁res ▁, ▁count 1 ▁+ ▁count 0 ▁) ▁; ▁} ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁9 ▁; ▁string ▁str ▁= ▁" 0001 0100 1" ▁; ▁c out ▁<< ▁min Changes ▁( ▁str ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count _ tri angles ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁int ▁c ▁, ▁int ▁d ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁x ▁= ▁a ▁; ▁x ▁<= ▁b ▁; ▁++ ▁x ▁) ▁{ ▁int ▁num _ greater _ than _ d ▁= ▁max ▁( ▁d ▁, ▁c ▁+ ▁x ▁) ▁- ▁max ▁( ▁d ▁, ▁b ▁+ ▁x ▁- ▁1 ▁) ▁; ▁ans ▁+= ▁num _ greater _ than _ d ▁* ▁( ▁d ▁- ▁c ▁+ ▁1 ▁) ▁; ▁int ▁r ▁= ▁min ▁( ▁max ▁( ▁c ▁, ▁c ▁+ ▁x ▁) ▁, ▁d ▁) ▁- ▁c ▁; ▁int ▁l ▁= ▁min ▁( ▁max ▁( ▁c ▁, ▁b ▁+ ▁x ▁- ▁1 ▁) ▁, ▁d ▁) ▁- ▁c ▁; ▁int ▁x 1 ▁= ▁( ▁r ▁* ▁( ▁r ▁+ ▁1 ▁) ▁) ▁/ ▁2 ▁; ▁int ▁x 2 ▁= ▁( ▁l ▁* ▁( ▁l ▁+ ▁1 ▁) ▁) ▁/ ▁2 ▁; ▁ans ▁+= ▁x 1 ▁- ▁x 2 ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁= ▁2 ▁, ▁b ▁= ▁3 ▁, ▁c ▁= ▁4 ▁, ▁d ▁= ▁5 ▁; ▁c out ▁<< ▁count _ tri angles ▁( ▁a ▁, ▁b ▁, ▁c ▁, ▁d ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print K Parts ▁( ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁if ▁( ▁N ▁% ▁K ▁== ▁0 ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁K ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁"1 ▁, ▁" ▁; ▁c out ▁<< ▁N ▁- ▁( ▁K ▁- ▁1 ▁) ▁<< ▁end l ▁; ▁} ▁else ▁{ ▁if ▁( ▁K ▁== ▁2 ▁) ▁{ ▁c out ▁<< ▁" ▁Not ▁Possible ▁" ▁<< ▁end l ▁; ▁return ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁K ▁- ▁1 ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁1 ▁<< ▁" ▁, ▁" ▁; ▁c out ▁<< ▁2 ▁<< ▁" ▁, ▁" ▁<< ▁N ▁- ▁K ▁<< ▁end l ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁18 ▁, ▁K ▁= ▁5 ▁; ▁print K Parts ▁( ▁N ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁getL argest Sum ▁( ▁int ▁N ▁) ▁{ ▁int ▁max _ sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁<= ▁N ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁i ▁* ▁j ▁% ▁( ▁i ▁+ ▁j ▁) ▁== ▁0 ▁) ▁max _ sum ▁= ▁max ▁( ▁max _ sum ▁, ▁i ▁+ ▁j ▁) ▁; ▁} ▁} ▁return ▁max _ sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁25 ▁; ▁int ▁max _ sum ▁= ▁getL argest Sum ▁( ▁N ▁) ▁; ▁c out ▁<< ▁max _ sum ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁getP airs ▁( ▁vector ▁< ▁int ▁> ▁A ▁, ▁vector ▁< ▁int ▁> ▁B ▁, ▁int ▁n ▁) ▁{ ▁vector ▁< ▁int ▁> ▁D ▁( ▁n ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁D ▁[ ▁i ▁] ▁= ▁A ▁[ ▁i ▁] ▁- ▁B ▁[ ▁i ▁] ▁; ▁} ▁sort ▁( ▁D ▁. ▁begin ▁( ▁) ▁, ▁D ▁. ▁end ▁( ▁) ▁) ▁; ▁long ▁long ▁total ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁D ▁[ ▁i ▁] ▁> ▁0 ▁) ▁{ ▁total ▁+= ▁n ▁- ▁i ▁- ▁1 ▁; ▁} ▁else ▁{ ▁int ▁k ▁= ▁upper _ bound ▁( ▁D ▁. ▁begin ▁( ▁) ▁, ▁D ▁. ▁end ▁( ▁) ▁, ▁- ▁D ▁[ ▁i ▁] ▁) ▁- ▁D ▁. ▁begin ▁( ▁) ▁; ▁total ▁+= ▁n ▁- ▁k ▁; ▁} ▁} ▁return ▁total ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁5 ▁; ▁vector ▁< ▁int ▁> ▁A ▁; ▁vector ▁< ▁int ▁> ▁B ▁; ▁A ▁. ▁push _ back ▁( ▁4 ▁) ▁; ▁A ▁. ▁push _ back ▁( ▁8 ▁) ▁; ▁A ▁. ▁push _ back ▁( ▁2 ▁) ▁; ▁A ▁. ▁push _ back ▁( ▁6 ▁) ▁; ▁A ▁. ▁push _ back ▁( ▁2 ▁) ▁; ▁B ▁. ▁push _ back ▁( ▁4 ▁) ▁; ▁B ▁. ▁push _ back ▁( ▁5 ▁) ▁; ▁B ▁. ▁push _ back ▁( ▁4 ▁) ▁; ▁B ▁. ▁push _ back ▁( ▁1 ▁) ▁; ▁B ▁. ▁push _ back ▁( ▁3 ▁) ▁; ▁c out ▁<< ▁getP airs ▁( ▁A ▁, ▁B ▁, ▁n ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁# define ▁ll ▁long ▁long ▁int ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁ll ▁fact ▁[ ▁14 ▁] ▁; ▁int ▁size ▁= ▁1 ▁; ▁void ▁pre Compute ▁( ▁int ▁N ▁) ▁{ ▁fact ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁fact ▁[ ▁i ▁- ▁1 ▁] ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁fact ▁[ ▁i ▁] ▁= ▁( ▁fact ▁[ ▁i ▁- ▁1 ▁] ▁* ▁i ▁) ▁; ▁size ▁++ ▁; ▁} ▁} ▁void ▁find Min ▁( ▁int ▁N ▁) ▁{ ▁pre Compute ▁( ▁N ▁) ▁; ▁int ▁original N ▁= ▁N ▁; ▁vector ▁< ▁int ▁> ▁ans ▁; ▁for ▁( ▁int ▁i ▁= ▁size ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁while ▁( ▁N ▁>= ▁fact ▁[ ▁i ▁] ▁) ▁{ ▁N ▁-= ▁fact ▁[ ▁i ▁] ▁; ▁ans ▁. ▁push _ back ▁( ▁fact ▁[ ▁i ▁] ▁) ▁; ▁} ▁} ▁c out ▁<< ▁ans ▁. ▁size ▁( ▁) ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁ans ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁ans ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁27 ▁; ▁find Min ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁k _ sum ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁r ▁= ▁0 ▁, ▁sum ▁= ▁0 ▁; ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁l ▁= ▁0 ▁; ▁l ▁< ▁n ▁; ▁l ▁++ ▁) ▁{ ▁while ▁( ▁sum ▁< ▁k ▁) ▁{ ▁if ▁( ▁r ▁== ▁n ▁) ▁break ▁; ▁else ▁{ ▁sum ▁+= ▁a ▁[ ▁r ▁] ▁; ▁r ▁++ ▁; ▁} ▁} ▁if ▁( ▁sum ▁< ▁k ▁) ▁break ▁; ▁ans ▁+= ▁n ▁- ▁r ▁+ ▁1 ▁; ▁sum ▁-= ▁a ▁[ ▁l ▁] ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁6 ▁, ▁1 ▁, ▁2 ▁, ▁7 ▁} ▁, ▁k ▁= ▁10 ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁k _ sum ▁( ▁a ▁, ▁n ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max Sum ▁( ▁int ▁arr 1 ▁[ ▁] ▁, ▁int ▁arr 2 ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁initial Par ity ▁= ▁0 ▁, ▁final Par ity ▁= ▁0 ▁; ▁int ▁sum ▁= ▁0 ▁, ▁min Positive ▁= ▁INT _ MAX ▁, ▁max Negative ▁= ▁INT _ MIN ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁initial Par ity ▁+= ▁arr 2 ▁[ ▁i ▁] ▁; ▁if ▁( ▁arr 1 ▁[ ▁i ▁] ▁>= ▁0 ▁) ▁{ ▁final Par ity ▁+= ▁1 ▁; ▁sum ▁+= ▁arr 1 ▁[ ▁i ▁] ▁; ▁min Positive ▁= ▁min ▁( ▁min Positive ▁, ▁arr 1 ▁[ ▁i ▁] ▁) ▁; ▁} ▁else ▁{ ▁max Negative ▁= ▁max ▁( ▁max Negative ▁, ▁arr 1 ▁[ ▁i ▁] ▁) ▁; ▁} ▁} ▁if ▁( ▁initial Par ity ▁% ▁2 ▁== ▁final Par ity ▁% ▁2 ▁) ▁{ ▁return ▁sum ▁; ▁} ▁else ▁{ ▁if ▁( ▁min Positive ▁+ ▁max Negative ▁>= ▁0 ▁) ▁{ ▁return ▁sum ▁+ ▁max Negative ▁; ▁} ▁else ▁{ ▁return ▁sum ▁- ▁min Positive ▁; ▁} ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr 1 ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁-4 ▁, ▁5 ▁, ▁3 ▁} ▁; ▁int ▁arr 2 ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr 1 ▁) ▁/ ▁sizeof ▁( ▁arr 1 ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁max Sum ▁( ▁arr 1 ▁, ▁arr 2 ▁, ▁n ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁min Capacity ▁( ▁int ▁enter ▁[ ▁] ▁, ▁int ▁exit ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁min Cap ▁= ▁0 ▁; ▁int ▁curr Cap ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁curr Cap ▁= ▁curr Cap ▁+ ▁enter ▁[ ▁i ▁] ▁- ▁exit ▁[ ▁i ▁] ▁; ▁min Cap ▁= ▁max ▁( ▁min Cap ▁, ▁curr Cap ▁) ▁; ▁} ▁return ▁min Cap ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁enter ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁5 ▁, ▁2 ▁, ▁0 ▁} ▁; ▁int ▁exit ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁2 ▁, ▁4 ▁, ▁4 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁enter ▁) ▁/ ▁sizeof ▁( ▁enter ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁min Capacity ▁( ▁enter ▁, ▁exit ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁getMin ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁min Val ▁= ▁* ▁min _ element ▁( ▁arr ▁, ▁arr ▁+ ▁n ▁) ▁; ▁return ▁min Val ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁3 ▁, ▁1 ▁, ▁6 ▁, ▁9 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁getMin ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁longest Sub array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁max Mean ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁max Mean ▁= ▁max ▁( ▁max Mean ▁, ▁( ▁arr ▁[ ▁i ▁] ▁+ ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁) ▁/ ▁2 ▁) ▁; ▁int ▁ans ▁= ▁0 ▁; ▁int ▁sub array Length ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁arr ▁[ ▁i ▁] ▁>= ▁max Mean ▁) ▁ans ▁= ▁max ▁( ▁ans ▁, ▁++ ▁sub array Length ▁) ▁; ▁else ▁sub array Length ▁= ▁0 ▁; ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁3 ▁, ▁3 ▁, ▁2 ▁, ▁1 ▁, ▁4 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁longest Sub array ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁int ▁MAX ▁= ▁24 ▁; ▁int ▁count Op ▁( ▁int ▁x ▁) ▁{ ▁int ▁arr ▁[ ▁MAX ▁] ▁; ▁arr ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁MAX ▁; ▁i ▁++ ▁) ▁arr ▁[ ▁i ▁] ▁= ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁* ▁2 ▁; ▁int ▁temp ▁= ▁x ▁; ▁bool ▁flag ▁= ▁true ▁; ▁int ▁ans ▁; ▁int ▁operations ▁= ▁0 ▁; ▁bool ▁flag 2 ▁= ▁false ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁MAX ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁- ▁1 ▁== ▁x ▁) ▁flag 2 ▁= ▁true ▁; ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁x ▁) ▁{ ▁ans ▁= ▁i ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁flag 2 ▁) ▁return ▁0 ▁; ▁while ▁( ▁flag ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁ans ▁] ▁< ▁x ▁) ▁ans ▁++ ▁; ▁operations ▁++ ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁MAX ▁; ▁i ▁++ ▁) ▁{ ▁int ▁take ▁= ▁x ▁^ ▁( ▁arr ▁[ ▁i ▁] ▁- ▁1 ▁) ▁; ▁if ▁( ▁take ▁<= ▁arr ▁[ ▁ans ▁] ▁- ▁1 ▁) ▁{ ▁if ▁( ▁take ▁> ▁temp ▁) ▁temp ▁= ▁take ▁; ▁} ▁} ▁if ▁( ▁temp ▁== ▁arr ▁[ ▁ans ▁] ▁- ▁1 ▁) ▁{ ▁flag ▁= ▁false ▁; ▁break ▁; ▁} ▁temp ▁++ ▁; ▁operations ▁++ ▁; ▁x ▁= ▁temp ▁; ▁if ▁( ▁x ▁== ▁arr ▁[ ▁ans ▁] ▁- ▁1 ▁) ▁flag ▁= ▁false ▁; ▁} ▁return ▁operations ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁x ▁= ▁39 ▁; ▁c out ▁<< ▁count Op ▁( ▁x ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max Coin s ▁( ▁int ▁X ▁, ▁int ▁Y ▁) ▁{ ▁if ▁( ▁X ▁< ▁Y ▁) ▁swap ▁( ▁X ▁, ▁Y ▁) ▁; ▁int ▁coins ▁= ▁X ▁; ▁X ▁-- ▁; ▁coins ▁+= ▁max ▁( ▁X ▁, ▁Y ▁) ▁; ▁return ▁coins ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁X ▁= ▁7 ▁, ▁Y ▁= ▁5 ▁; ▁c out ▁<< ▁max Coin s ▁( ▁X ▁, ▁Y ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print Array ▁( ▁int ▁N ▁, ▁int ▁arr ▁[ ▁] ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁c out ▁<< ▁end l ▁; ▁} ▁void ▁replaced Array ▁( ▁int ▁N ▁, ▁int ▁arr ▁[ ▁] ▁) ▁{ ▁int ▁pos _ sum ▁, ▁neg _ sum ▁, ▁i ▁, ▁j ▁, ▁diff ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁pos _ sum ▁= ▁0 ▁; ▁neg _ sum ▁= ▁0 ▁; ▁for ▁( ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁j ▁] ▁> ▁0 ▁) ▁pos _ sum ▁+= ▁arr ▁[ ▁j ▁] ▁; ▁else ▁neg _ sum ▁+= ▁arr ▁[ ▁j ▁] ▁; ▁} ▁diff ▁= ▁abs ▁( ▁pos _ sum ▁) ▁- ▁abs ▁( ▁neg _ sum ▁) ▁; ▁arr ▁[ ▁i ▁] ▁= ▁abs ▁( ▁diff ▁) ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁5 ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁-1 ▁, ▁2 ▁, ▁3 ▁, ▁-2 ▁} ▁; ▁replaced Array ▁( ▁N ▁, ▁arr ▁) ▁; ▁print Array ▁( ▁N ▁, ▁arr ▁) ▁; ▁N ▁= ▁6 ▁; ▁int ▁arr 1 ▁[ ▁] ▁= ▁{ ▁-3 ▁, ▁-4 ▁, ▁-2 ▁, ▁5 ▁, ▁1 ▁, ▁-2 ▁} ▁; ▁replaced Array ▁( ▁N ▁, ▁arr 1 ▁) ▁; ▁print Array ▁( ▁N ▁, ▁arr 1 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁long ▁long ▁int ▁max ▁( ▁long ▁long ▁a ▁, ▁long ▁long ▁b ▁) ▁{ ▁if ▁( ▁a ▁> ▁b ▁) ▁return ▁a ▁; ▁else ▁return ▁b ▁; ▁} ▁long ▁long ▁int ▁smallest Side ▁( ▁long ▁long ▁int ▁a ▁[ ▁] ▁) ▁{ ▁sort ▁( ▁a ▁, ▁a ▁+ ▁4 ▁) ▁; ▁long ▁long ▁side 1 ▁, ▁side 2 ▁, ▁side 3 ▁, ▁side 4 ▁, ▁side 11 ▁, ▁side 12 ▁, ▁side Of Square ▁; ▁side 1 ▁= ▁a ▁[ ▁0 ▁] ▁+ ▁a ▁[ ▁3 ▁] ▁; ▁side 2 ▁= ▁a ▁[ ▁1 ▁] ▁+ ▁a ▁[ ▁2 ▁] ▁; ▁side 3 ▁= ▁a ▁[ ▁0 ▁] ▁+ ▁a ▁[ ▁1 ▁] ▁; ▁side 4 ▁= ▁a ▁[ ▁2 ▁] ▁+ ▁a ▁[ ▁3 ▁] ▁; ▁side 11 ▁= ▁max ▁( ▁side 1 ▁, ▁side 2 ▁) ▁; ▁side 12 ▁= ▁max ▁( ▁side 3 ▁, ▁side 4 ▁) ▁; ▁side Of Square ▁= ▁max ▁( ▁side 11 ▁, ▁side 12 ▁) ▁; ▁return ▁side Of Square ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁long ▁long ▁int ▁side ▁[ ▁4 ▁] ▁; ▁c out ▁<< ▁" ▁Test ▁Case ▁1 ▁STRNEWLINE ▁" ▁; ▁side ▁[ ▁0 ▁] ▁= ▁2 ▁; ▁side ▁[ ▁1 ▁] ▁= ▁2 ▁; ▁side ▁[ ▁2 ▁] ▁= ▁2 ▁; ▁side ▁[ ▁3 ▁] ▁= ▁2 ▁; ▁c out ▁<< ▁smallest Side ▁( ▁side ▁) ▁<< ▁end l ▁; ▁c out ▁<< ▁" ▁Test ▁Case ▁2 ▁" ▁side ▁[ ▁0 ▁] ▁= ▁100 000000000000 ▁; ▁side ▁[ ▁1 ▁] ▁= ▁12345 0000000000 ▁; ▁side ▁[ ▁2 ▁] ▁= ▁98 765 0000000000 ▁; ▁side ▁[ ▁3 ▁] ▁= ▁98 7654 321 000000 ▁; ▁c out ▁<< ▁smallest Side ▁( ▁side ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max Sub Array Sum ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁size ▁) ▁{ ▁int ▁max _ so _ far ▁= ▁INT _ MIN ▁, ▁max _ ending _ here ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁{ ▁max _ ending _ here ▁= ▁max _ ending _ here ▁+ ▁a ▁[ ▁i ▁] ▁; ▁if ▁( ▁max _ so _ far ▁< ▁max _ ending _ here ▁) ▁max _ so _ far ▁= ▁max _ ending _ here ▁; ▁if ▁( ▁max _ ending _ here ▁< ▁0 ▁) ▁max _ ending _ here ▁= ▁0 ▁; ▁} ▁return ▁max _ so _ far ▁; ▁} ▁int ▁max Sum ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁S ▁= ▁0 ▁; ▁int ▁S 1 ▁= ▁max Sub Array Sum ▁( ▁a ▁, ▁n ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁S ▁+= ▁a ▁[ ▁i ▁] ▁; ▁return ▁( ▁2 ▁* ▁S 1 ▁- ▁S ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁- 35 ▁, ▁32 ▁, ▁- 24 ▁, ▁0 ▁, ▁27 ▁, ▁-10 ▁, ▁0 ▁, ▁- 19 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁max Sum ▁( ▁a ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁int ▁n ▁= ▁3 ▁; ▁const ▁int ▁m ▁= ▁4 ▁; ▁int ▁max Matrix Score ▁( ▁int ▁A ▁[ ▁n ▁] ▁[ ▁m ▁] ▁, ▁int ▁K ▁) ▁{ ▁map ▁< ▁int ▁, ▁int ▁> ▁update ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁A ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁== ▁0 ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁< ▁m ▁; ▁++ ▁j ▁) ▁ans ▁= ▁ans ▁+ ▁A ▁[ ▁i ▁] ▁[ ▁j ▁] ▁* ▁pow ▁( ▁2 ▁, ▁m ▁- ▁j ▁- ▁1 ▁) ▁; ▁update ▁[ ▁ans ▁] ▁= ▁i ▁; ▁} ▁} ▁map ▁< ▁int ▁, ▁int ▁> ▁:: ▁iterator ▁it ▁= ▁update ▁. ▁begin ▁( ▁) ▁; ▁while ▁( ▁K ▁> ▁0 ▁&& ▁it ▁!= ▁update ▁. ▁end ▁( ▁) ▁) ▁{ ▁int ▁idx ▁= ▁it ▁-> ▁second ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁m ▁; ▁++ ▁j ▁) ▁A ▁[ ▁idx ▁] ▁[ ▁j ▁] ▁= ▁( ▁A ▁[ ▁idx ▁] ▁[ ▁j ▁] ▁+ ▁1 ▁) ▁% ▁2 ▁; ▁it ▁++ ▁; ▁K ▁-- ▁; ▁} ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁m ▁; ▁++ ▁j ▁) ▁{ ▁int ▁zero ▁= ▁0 ▁, ▁one ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁{ ▁A ▁[ ▁i ▁] ▁[ ▁j ▁] ▁== ▁0 ▁? ▁zero ▁++ ▁: ▁one ▁++ ▁; ▁} ▁if ▁( ▁K ▁> ▁0 ▁&& ▁zero ▁> ▁one ▁) ▁{ ▁ans ▁+= ▁zero ▁* ▁pow ▁( ▁2 ▁, ▁m ▁- ▁j ▁- ▁1 ▁) ▁; ▁K ▁-- ▁; ▁} ▁else ▁ans ▁+= ▁one ▁* ▁pow ▁( ▁2 ▁, ▁m ▁- ▁j ▁- ▁1 ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁[ ▁n ▁] ▁[ ▁m ▁] ▁= ▁{ ▁{ ▁0 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁} ▁, ▁{ ▁1 ▁, ▁1 ▁, ▁0 ▁, ▁0 ▁} ▁} ▁; ▁int ▁K ▁= ▁2 ▁; ▁c out ▁<< ▁max Matrix Score ▁( ▁A ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max imize And ▁( ▁int ▁i ▁, ▁int ▁mask ▁, ▁int ▁* ▁A ▁, ▁int ▁* ▁B ▁, ▁int ▁N ▁, ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁& ▁dp ▁) ▁{ ▁if ▁( ▁i ▁== ▁N ▁) ▁return ▁0 ▁; ▁if ▁( ▁dp ▁[ ▁i ▁] ▁[ ▁mask ▁] ▁!= ▁-1 ▁) ▁return ▁dp ▁[ ▁i ▁] ▁[ ▁mask ▁] ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁N ▁; ▁++ ▁j ▁) ▁{ ▁if ▁( ▁! ▁( ▁mask ▁& ▁( ▁1 ▁<< ▁j ▁) ▁) ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁mask ▁] ▁= ▁max ▁( ▁dp ▁[ ▁i ▁] ▁[ ▁mask ▁] ▁, ▁( ▁A ▁[ ▁i ▁] ▁& ▁B ▁[ ▁j ▁] ▁) ▁+ ▁max imize And ▁( ▁i ▁+ ▁1 ▁, ▁mask ▁| ▁( ▁1 ▁<< ▁j ▁) ▁, ▁A ▁, ▁B ▁, ▁N ▁, ▁dp ▁) ▁) ▁; ▁} ▁} ▁return ▁dp ▁[ ▁i ▁] ▁[ ▁mask ▁] ▁; ▁} ▁int ▁max imize And Util ▁( ▁int ▁* ▁A ▁, ▁int ▁* ▁B ▁, ▁int ▁N ▁) ▁{ ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁dp ▁( ▁N ▁, ▁vector ▁< ▁int ▁> ▁( ▁1 ▁<< ▁N ▁+ ▁1 ▁, ▁-1 ▁) ▁) ▁; ▁return ▁max imize And ▁( ▁0 ▁, ▁0 ▁, ▁A ▁, ▁B ▁, ▁N ▁, ▁dp ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁5 ▁, ▁7 ▁, ▁11 ▁} ▁; ▁int ▁B ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁6 ▁, ▁10 ▁, ▁12 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁A ▁/ ▁sizeof ▁A ▁[ ▁0 ▁] ▁; ▁c out ▁<< ▁max imize And Util ▁( ▁A ▁, ▁B ▁, ▁N ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁lis O tim ised ▁( ▁string ▁s ▁) ▁{ ▁int ▁dp ▁[ ▁30 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁int ▁N ▁= ▁s ▁. ▁size ▁( ▁) ▁; ▁int ▁lis ▁= ▁INT _ MIN ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁int ▁val ▁= ▁s ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁; ▁int ▁curr ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁val ▁; ▁j ▁++ ▁) ▁{ ▁curr ▁= ▁max ▁( ▁curr ▁, ▁dp ▁[ ▁j ▁] ▁) ▁; ▁} ▁curr ▁++ ▁; ▁lis ▁= ▁max ▁( ▁lis ▁, ▁curr ▁) ▁; ▁dp ▁[ ▁val ▁] ▁= ▁max ▁( ▁dp ▁[ ▁val ▁] ▁, ▁curr ▁) ▁; ▁} ▁return ▁lis ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁" ▁fd ry ut iag h f se ▁" ▁; ▁c out ▁<< ▁lis O tim ised ▁( ▁s ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁int ▁MAX ▁= ▁1 e 9 ▁; ▁int ▁Minimum Length ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁sort ▁( ▁A ▁, ▁A ▁+ ▁N ▁) ▁; ▁int ▁suffix ▁[ ▁N ▁+ ▁1 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁N ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁suffix ▁[ ▁i ▁] ▁= ▁suffix ▁[ ▁i ▁+ ▁1 ▁] ▁+ ▁A ▁[ ▁i ▁] ▁; ▁int ▁dp ▁[ ▁N ▁+ ▁1 ▁] ▁[ ▁K ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁<= ▁K ▁; ▁j ▁++ ▁) ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁MAX ▁; ▁dp ▁[ ▁N ▁] ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁N ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁K ▁; ▁j ▁>= ▁0 ▁; ▁j ▁-- ▁) ▁{ ▁if ▁( ▁j ▁<= ▁A ▁[ ▁i ▁] ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁A ▁[ ▁i ▁] ▁; ▁continue ▁; ▁} ▁if ▁( ▁dp ▁[ ▁i ▁+ ▁1 ▁] ▁[ ▁j ▁- ▁A ▁[ ▁i ▁] ▁] ▁== ▁MAX ▁) ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁MAX ▁; ▁else ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁min ▁( ▁dp ▁[ ▁i ▁+ ▁1 ▁] ▁[ ▁j ▁] ▁, ▁dp ▁[ ▁i ▁+ ▁1 ▁] ▁[ ▁j ▁- ▁A ▁[ ▁i ▁] ▁] ▁+ ▁A ▁[ ▁i ▁] ▁) ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁N ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁suffix ▁[ ▁i ▁] ▁- ▁dp ▁[ ▁i ▁] ▁[ ▁K ▁] ▁>= ▁K ▁) ▁{ ▁return ▁N ▁- ▁i ▁; ▁} ▁} ▁return ▁-1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁7 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁, ▁8 ▁} ▁; ▁int ▁K ▁= ▁13 ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁Minimum Length ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁float ▁dp ▁[ ▁105 ▁] ▁[ ▁60 5 ▁] ▁; ▁float ▁find ▁( ▁int ▁N ▁, ▁int ▁sum ▁) ▁{ ▁if ▁( ▁dp ▁[ ▁N ▁] ▁[ ▁sum ▁] ▁) ▁return ▁dp ▁[ ▁N ▁] ▁[ ▁sum ▁] ▁; ▁if ▁( ▁sum ▁> ▁6 ▁* ▁N ▁sum ▁< ▁N ▁) ▁return ▁0 ▁; ▁if ▁( ▁N ▁== ▁1 ▁) ▁{ ▁if ▁( ▁sum ▁>= ▁1 ▁&& ▁sum ▁<= ▁6 ▁) ▁return ▁1.0 ▁/ ▁6 ▁; ▁else ▁return ▁0 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁6 ▁; ▁i ▁++ ▁) ▁dp ▁[ ▁N ▁] ▁[ ▁sum ▁] ▁= ▁dp ▁[ ▁N ▁] ▁[ ▁sum ▁] ▁+ ▁find ▁( ▁N ▁- ▁1 ▁, ▁sum ▁- ▁i ▁) ▁/ ▁6 ▁; ▁return ▁dp ▁[ ▁N ▁] ▁[ ▁sum ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁4 ▁, ▁a ▁= ▁13 ▁, ▁b ▁= ▁17 ▁; ▁float ▁probability ▁= ▁0.0 ▁; ▁for ▁( ▁int ▁sum ▁= ▁a ▁; ▁sum ▁<= ▁b ▁; ▁sum ▁++ ▁) ▁probability ▁= ▁probability ▁+ ▁find ▁( ▁N ▁, ▁sum ▁) ▁; ▁c out ▁<< ▁fixed ▁<< ▁set precision ▁( ▁6 ▁) ▁<< ▁probability ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁double ▁find Med X OR ▁( ▁int ▁mat ▁[ ▁] ▁[ ▁2 ▁] ▁, ▁int ▁N ▁, ▁int ▁M ▁) ▁{ ▁int ▁dp ▁[ ▁N ▁] ▁[ ▁M ▁] ▁; ▁int ▁med ▁[ ▁N ▁* ▁M ▁] ▁; ▁dp ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁= ▁mat ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁; ▁med ▁[ ▁0 ▁] ▁= ▁dp ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁; ▁int ▁len ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁0 ▁] ▁^ ▁mat ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁; ▁med ▁[ ▁len ▁++ ▁] ▁= ▁dp ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁M ▁; ▁i ▁++ ▁) ▁{ ▁dp ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁= ▁dp ▁[ ▁0 ▁] ▁[ ▁i ▁- ▁1 ▁] ▁^ ▁mat ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁; ▁med ▁[ ▁len ▁++ ▁] ▁= ▁dp ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁< ▁M ▁; ▁j ▁++ ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁^ ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁^ ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁- ▁1 ▁] ▁^ ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁med ▁[ ▁len ▁++ ▁] ▁= ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁} ▁} ▁sort ▁( ▁med ▁, ▁med ▁+ ▁len ▁) ▁; ▁if ▁( ▁len ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁return ▁( ▁med ▁[ ▁( ▁len ▁/ ▁2 ▁) ▁] ▁+ ▁med ▁[ ▁( ▁len ▁/ ▁2 ▁) ▁- ▁1 ▁] ▁) ▁/ ▁2.0 ▁; ▁} ▁return ▁med ▁[ ▁len ▁/ ▁2 ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁mat ▁[ ▁] ▁[ ▁2 ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁} ▁, ▁{ ▁2 ▁, ▁3 ▁} ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁mat ▁) ▁/ ▁sizeof ▁( ▁mat ▁[ ▁0 ▁] ▁) ▁; ▁int ▁M ▁= ▁2 ▁; ▁c out ▁<< ▁find Med X OR ▁( ▁mat ▁, ▁N ▁, ▁M ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁map ▁< ▁string ▁, ▁int ▁> ▁dp ▁; ▁int ▁check Equal Sum Util ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁sm 1 ▁, ▁int ▁sm 2 ▁, ▁int ▁sm 3 ▁, ▁int ▁j ▁) ▁{ ▁string ▁s ▁= ▁to _ string ▁( ▁sm 1 ▁) ▁+ ▁" ▁_ ▁" ▁+ ▁to _ string ▁( ▁sm 2 ▁) ▁+ ▁to _ string ▁( ▁j ▁) ▁; ▁if ▁( ▁j ▁== ▁N ▁) ▁{ ▁if ▁( ▁sm 1 ▁== ▁sm 2 ▁&& ▁sm 2 ▁== ▁sm 3 ▁) ▁return ▁1 ▁; ▁else ▁return ▁0 ▁; ▁} ▁if ▁( ▁dp ▁. ▁find ▁( ▁s ▁) ▁!= ▁dp ▁. ▁end ▁( ▁) ▁) ▁return ▁dp ▁[ ▁s ▁] ▁; ▁else ▁{ ▁int ▁l ▁= ▁check Equal Sum Util ▁( ▁arr ▁, ▁N ▁, ▁sm 1 ▁+ ▁arr ▁[ ▁j ▁] ▁, ▁sm 2 ▁, ▁sm 3 ▁, ▁j ▁+ ▁1 ▁) ▁; ▁int ▁m ▁= ▁check Equal Sum Util ▁( ▁arr ▁, ▁N ▁, ▁sm 1 ▁, ▁sm 2 ▁+ ▁arr ▁[ ▁j ▁] ▁, ▁sm 3 ▁, ▁j ▁+ ▁1 ▁) ▁; ▁int ▁r ▁= ▁check Equal Sum Util ▁( ▁arr ▁, ▁N ▁, ▁sm 1 ▁, ▁sm 2 ▁, ▁sm 3 ▁+ ▁arr ▁[ ▁j ▁] ▁, ▁j ▁+ ▁1 ▁) ▁; ▁return ▁dp ▁[ ▁s ▁] ▁= ▁max ▁( ▁max ▁( ▁l ▁, ▁m ▁) ▁, ▁r ▁) ▁; ▁} ▁} ▁void ▁check Equal Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁sum 1 ▁, ▁sum 2 ▁, ▁sum 3 ▁; ▁sum 1 ▁= ▁sum 2 ▁= ▁sum 3 ▁= ▁0 ▁; ▁if ▁( ▁check Equal Sum Util ▁( ▁arr ▁, ▁N ▁, ▁sum 1 ▁, ▁sum 2 ▁, ▁sum 3 ▁, ▁0 ▁) ▁== ▁1 ▁) ▁{ ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁" ▁No ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁17 ▁, ▁34 ▁, ▁59 ▁, ▁23 ▁, ▁17 ▁, ▁67 ▁, ▁57 ▁, ▁2 ▁, ▁18 ▁, ▁59 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁check Equal Sum ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁manipulation ▁( ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁& ▁matrix ▁, ▁vector ▁< ▁int ▁> ▁& ▁q ▁) ▁{ ▁int ▁x 1 ▁= ▁q ▁[ ▁0 ▁] ▁, ▁y 1 ▁= ▁q ▁[ ▁1 ▁] ▁, ▁x 2 ▁= ▁q ▁[ ▁2 ▁] ▁, ▁y 2 ▁= ▁q ▁[ ▁3 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁x 1 ▁- ▁1 ▁; ▁i ▁< ▁x 2 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁y 1 ▁- ▁1 ▁; ▁j ▁< ▁y 2 ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁matrix ▁[ ▁i ▁] ▁[ ▁j ▁] ▁== ▁1 ▁) ▁matrix ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁0 ▁; ▁else ▁matrix ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁1 ▁; ▁} ▁} ▁} ▁void ▁queries _ fx n ▁( ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁& ▁matrix ▁, ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁& ▁queries ▁) ▁{ ▁for ▁( ▁auto ▁q ▁: ▁queries ▁) ▁manipulation ▁( ▁matrix ▁, ▁q ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁matrix ▁= ▁{ ▁{ ▁0 ▁, ▁1 ▁, ▁0 ▁} ▁, ▁{ ▁1 ▁, ▁1 ▁, ▁0 ▁} ▁} ▁; ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁queries ▁= ▁{ ▁{ ▁1 ▁, ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁, ▁{ ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁2 ▁, ▁2 ▁, ▁3 ▁} ▁} ▁; ▁queries _ fx n ▁( ▁matrix ▁, ▁queries ▁) ▁; ▁c out ▁<< ▁" ▁[ ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁matrix ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁c out ▁<< ▁" ▁[ ▁" ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁matrix ▁[ ▁i ▁] ▁. ▁size ▁( ▁) ▁; ▁j ▁++ ▁) ▁c out ▁<< ▁matrix ▁[ ▁i ▁] ▁[ ▁j ▁] ▁<< ▁" ▁" ▁; ▁if ▁( ▁i ▁== ▁matrix ▁. ▁size ▁( ▁) ▁- ▁1 ▁) ▁c out ▁<< ▁" ▁] ▁" ▁; ▁else ▁c out ▁<< ▁" ▁] ▁, ▁" ▁; ▁} ▁c out ▁<< ▁" ▁] ▁" ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁long ▁long ▁fib ▁[ ▁101 ▁] ▁, ▁dp 1 ▁[ ▁101 ▁] ▁; ▁long ▁long ▁dp 2 ▁[ ▁101 ▁] ▁, ▁v ▁[ ▁101 ▁] ▁; ▁void ▁fib onacci ▁( ▁) ▁{ ▁fib ▁[ ▁1 ▁] ▁= ▁1 ▁; ▁fib ▁[ ▁2 ▁] ▁= ▁2 ▁; ▁for ▁( ▁int ▁i ▁= ▁3 ▁; ▁i ▁<= ▁87 ▁; ▁i ▁++ ▁) ▁{ ▁fib ▁[ ▁i ▁] ▁= ▁fib ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁fib ▁[ ▁i ▁- ▁2 ▁] ▁; ▁} ▁} ▁int ▁find ▁( ▁int ▁num ▁) ▁{ ▁int ▁cnt ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁87 ▁; ▁i ▁> ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁num ▁>= ▁fib ▁[ ▁i ▁] ▁) ▁{ ▁v ▁[ ▁cnt ▁++ ▁] ▁= ▁i ▁; ▁num ▁-= ▁fib ▁[ ▁i ▁] ▁; ▁} ▁} ▁reverse ▁( ▁v ▁, ▁v ▁+ ▁cnt ▁) ▁; ▁dp 1 ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁dp 2 ▁[ ▁0 ▁] ▁= ▁( ▁v ▁[ ▁0 ▁] ▁- ▁1 ▁) ▁/ ▁2 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁cnt ▁; ▁i ▁++ ▁) ▁{ ▁dp 1 ▁[ ▁i ▁] ▁= ▁dp 1 ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁dp 2 ▁[ ▁i ▁- ▁1 ▁] ▁; ▁dp 2 ▁[ ▁i ▁] ▁= ▁( ▁( ▁v ▁[ ▁i ▁] ▁- ▁v ▁[ ▁i ▁- ▁1 ▁] ▁) ▁/ ▁2 ▁) ▁* ▁dp 2 ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁( ▁( ▁v ▁[ ▁i ▁] ▁- ▁v ▁[ ▁i ▁- ▁1 ▁] ▁- ▁1 ▁) ▁/ ▁2 ▁) ▁* ▁dp 1 ▁[ ▁i ▁- ▁1 ▁] ▁; ▁} ▁return ▁( ▁dp 1 ▁[ ▁cnt ▁- ▁1 ▁] ▁+ ▁dp 2 ▁[ ▁cnt ▁- ▁1 ▁] ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁fib onacci ▁( ▁) ▁; ▁int ▁num ▁= ▁13 ▁; ▁c out ▁<< ▁find ▁( ▁num ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁count Num s ▁( ▁int ▁N ▁) ▁{ ▁int ▁l ▁= ▁( ▁int ▁) ▁pow ▁( ▁10 ▁, ▁N ▁- ▁1 ▁) ▁; ▁int ▁r ▁= ▁( ▁int ▁) ▁pow ▁( ▁10 ▁, ▁N ▁) ▁- ▁1 ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁l ▁; ▁i ▁<= ▁r ▁; ▁i ▁++ ▁) ▁{ ▁int ▁xor r ▁= ▁0 ▁, ▁temp ▁= ▁i ▁; ▁while ▁( ▁temp ▁> ▁0 ▁) ▁{ ▁xor r ▁= ▁xor r ▁^ ▁( ▁temp ▁% ▁10 ▁) ▁; ▁temp ▁/= ▁10 ▁; ▁} ▁if ▁( ▁xor r ▁<= ▁9 ▁) ▁count ▁++ ▁; ▁} ▁c out ▁<< ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁2 ▁; ▁count Num s ▁( ▁N ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁long ▁long ▁getCount ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁if ▁( ▁n ▁== ▁1 ▁) ▁return ▁10 ▁; ▁long ▁long ▁dp ▁[ ▁n ▁+ ▁1 ▁] ▁[ ▁11 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁11 ▁; ▁j ▁++ ▁) ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁0 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁9 ▁; ▁i ▁++ ▁) ▁dp ▁[ ▁1 ▁] ▁[ ▁i ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁<= ▁9 ▁; ▁j ▁++ ▁) ▁{ ▁int ▁l ▁= ▁max ▁( ▁0 ▁, ▁j ▁- ▁k ▁) ▁; ▁int ▁r ▁= ▁min ▁( ▁9 ▁, ▁j ▁+ ▁k ▁) ▁; ▁dp ▁[ ▁i ▁] ▁[ ▁l ▁] ▁+= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁; ▁dp ▁[ ▁i ▁] ▁[ ▁r ▁+ ▁1 ▁] ▁-= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁; ▁} ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁<= ▁9 ▁; ▁j ▁++ ▁) ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+= ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁; ▁} ▁long ▁long ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁9 ▁; ▁i ▁++ ▁) ▁count ▁+= ▁dp ▁[ ▁n ▁] ▁[ ▁i ▁] ▁; ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁2 ▁, ▁K ▁= ▁1 ▁; ▁c out ▁<< ▁getCount ▁( ▁N ▁, ▁K ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁X ▁6 ▁NEW _ LINE ▁# define ▁Z ▁2 ▁NEW _ LINE ▁bool ▁exist Path ▁( ▁int ▁V ▁, ▁int ▁edges ▁[ ▁X ▁] ▁[ ▁Z ▁] ▁, ▁int ▁u ▁, ▁int ▁v ▁) ▁{ ▁bool ▁mat ▁[ ▁V ▁] ▁[ ▁V ▁] ▁; ▁mem set ▁( ▁mat ▁, ▁false ▁, ▁sizeof ▁( ▁mat ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁X ▁; ▁i ▁++ ▁) ▁mat ▁[ ▁edges ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁] ▁[ ▁edges ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁] ▁= ▁true ▁; ▁for ▁( ▁int ▁k ▁= ▁0 ▁; ▁k ▁< ▁V ▁; ▁k ▁++ ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁V ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁V ▁; ▁j ▁++ ▁) ▁{ ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁|| ▁mat ▁[ ▁i ▁] ▁[ ▁k ▁] ▁&& ▁mat ▁[ ▁k ▁] ▁[ ▁j ▁] ▁; ▁} ▁} ▁} ▁if ▁( ▁u ▁>= ▁V ▁v ▁>= ▁V ▁) ▁{ ▁return ▁false ▁; ▁} ▁if ▁( ▁mat ▁[ ▁u ▁] ▁[ ▁v ▁] ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁V ▁= ▁4 ▁; ▁int ▁edges ▁[ ▁X ▁] ▁[ ▁Z ▁] ▁= ▁{ ▁{ ▁0 ▁, ▁2 ▁} ▁, ▁{ ▁0 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁2 ▁} ▁, ▁{ ▁2 ▁, ▁3 ▁} ▁, ▁{ ▁2 ▁, ▁0 ▁} ▁, ▁{ ▁3 ▁, ▁3 ▁} ▁} ▁; ▁int ▁u ▁= ▁1 ▁, ▁v ▁= ▁3 ▁; ▁if ▁( ▁exist Path ▁( ▁V ▁, ▁edges ▁, ▁u ▁, ▁v ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁STRNEWLINE ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁STRNEWLINE ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁calculate _ maximum _ splits ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁pre ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁-1 ▁, ▁-1 ▁} ▁; ▁int ▁dp ▁[ ▁N ▁] ▁; ▁mem set ▁( ▁dp ▁, ▁0 ▁, ▁sizeof ▁( ▁dp ▁) ▁) ▁; ▁int ▁C ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁C ▁= ▁C ▁+ ▁arr ▁[ ▁i ▁] ▁; ▁C ▁= ▁C ▁% ▁3 ▁; ▁if ▁( ▁pre ▁[ ▁C ▁] ▁== ▁-1 ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁; ▁} ▁else ▁{ ▁dp ▁[ ▁i ▁] ▁= ▁max ▁( ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁, ▁dp ▁[ ▁pre ▁[ ▁C ▁] ▁] ▁+ ▁1 ▁) ▁; ▁} ▁pre ▁[ ▁C ▁] ▁= ▁i ▁; ▁} ▁return ▁dp ▁[ ▁N ▁- ▁1 ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁36 ▁, ▁1 ▁, ▁9 ▁, ▁2 ▁, ▁0 ▁, ▁1 ▁, ▁8 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁( ▁calculate _ maximum _ splits ▁( ▁arr ▁, ▁N ▁) ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁pre compute ▁( ▁int ▁next pos ▁[ ▁] ▁, ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁next pos ▁[ ▁N ▁- ▁1 ▁] ▁= ▁N ▁; ▁for ▁( ▁int ▁i ▁= ▁N ▁- ▁2 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁arr ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁next pos ▁[ ▁i ▁] ▁= ▁next pos ▁[ ▁i ▁+ ▁1 ▁] ▁; ▁else ▁next pos ▁[ ▁i ▁] ▁= ▁i ▁+ ▁1 ▁; ▁} ▁} ▁void ▁find Index ▁( ▁int ▁query ▁[ ▁] ▁[ ▁3 ▁] ▁, ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁Q ▁) ▁{ ▁int ▁next pos ▁[ ▁N ▁] ▁; ▁pre compute ▁( ▁next pos ▁, ▁arr ▁, ▁N ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁Q ▁; ▁i ▁++ ▁) ▁{ ▁int ▁l ▁, ▁r ▁, ▁x ▁; ▁l ▁= ▁query ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁; ▁r ▁= ▁query ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁; ▁x ▁= ▁query ▁[ ▁i ▁] ▁[ ▁2 ▁] ▁; ▁int ▁ans ▁= ▁-1 ▁; ▁if ▁( ▁arr ▁[ ▁l ▁] ▁!= ▁x ▁) ▁ans ▁= ▁l ▁; ▁else ▁{ ▁int ▁d ▁= ▁next pos ▁[ ▁l ▁] ▁; ▁if ▁( ▁d ▁<= ▁r ▁) ▁ans ▁= ▁d ▁; ▁} ▁c out ▁<< ▁ans ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁, ▁Q ▁; ▁N ▁= ▁6 ▁; ▁Q ▁= ▁3 ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁1 ▁, ▁1 ▁, ▁3 ▁, ▁5 ▁} ▁; ▁int ▁query ▁[ ▁Q ▁] ▁[ ▁3 ▁] ▁= ▁{ ▁{ ▁0 ▁, ▁3 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁5 ▁, ▁2 ▁} ▁, ▁{ ▁2 ▁, ▁3 ▁, ▁1 ▁} ▁} ▁; ▁find Index ▁( ▁query ▁, ▁arr ▁, ▁N ▁, ▁Q ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁two Strings Equality ▁( ▁string ▁s ▁, ▁string ▁t ▁) ▁{ ▁int ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁dp ▁( ▁n ▁, ▁vector ▁< ▁int ▁> ▁( ▁n ▁+ ▁1 ▁, ▁0 ▁) ▁) ▁; ▁if ▁( ▁s ▁[ ▁n ▁- ▁1 ▁] ▁== ▁t ▁[ ▁0 ▁] ▁) ▁dp ▁[ ▁n ▁- ▁1 ▁] ▁[ ▁1 ▁] ▁= ▁1 ▁; ▁if ▁( ▁s ▁[ ▁n ▁- ▁1 ▁] ▁== ▁t ▁[ ▁n ▁- ▁1 ▁] ▁) ▁dp ▁[ ▁n ▁- ▁1 ▁] ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁> ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁<= ▁n ▁- ▁i ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁{ ▁if ▁( ▁s ▁[ ▁i ▁- ▁1 ▁] ▁== ▁t ▁[ ▁j ▁] ▁) ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁+ ▁1 ▁] ▁= ▁1 ▁; ▁if ▁( ▁s ▁[ ▁i ▁- ▁1 ▁] ▁== ▁t ▁[ ▁i ▁+ ▁j ▁- ▁1 ▁] ▁) ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁= ▁1 ▁; ▁} ▁} ▁} ▁bool ▁ans ▁= ▁false ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁dp ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁== ▁1 ▁) ▁{ ▁ans ▁= ▁true ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁ans ▁== ▁true ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁S ▁= ▁" ▁ab ab ▁" ▁; ▁string ▁T ▁= ▁" ▁ba ab ▁" ▁; ▁two Strings Equality ▁( ▁S ▁, ▁T ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁has Square Of Zero es ▁( ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁& ▁matrix ▁, ▁int ▁r 1 ▁, ▁int ▁c 1 ▁, ▁int ▁r 2 ▁, ▁int ▁c 2 ▁, ▁unordered _ map ▁< ▁string ▁, ▁bool ▁> ▁& ▁cache ▁) ▁; ▁bool ▁is Square Of Zero es ▁( ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁& ▁matrix ▁, ▁int ▁r 1 ▁, ▁int ▁c 1 ▁, ▁int ▁r 2 ▁, ▁int ▁c 2 ▁) ▁; ▁bool ▁square Of Zero es ▁( ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁matrix ▁) ▁{ ▁int ▁last Idx ▁= ▁matrix ▁. ▁size ▁( ▁) ▁- ▁1 ▁; ▁unordered _ map ▁< ▁string ▁, ▁bool ▁> ▁cache ▁; ▁return ▁has Square Of Zero es ▁( ▁matrix ▁, ▁0 ▁, ▁0 ▁, ▁last Idx ▁, ▁last Idx ▁, ▁cache ▁) ▁; ▁} ▁bool ▁has Square Of Zero es ▁( ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁& ▁matrix ▁, ▁int ▁r 1 ▁, ▁int ▁c 1 ▁, ▁int ▁r 2 ▁, ▁int ▁c 2 ▁, ▁unordered _ map ▁< ▁string ▁, ▁bool ▁> ▁& ▁cache ▁) ▁{ ▁if ▁( ▁r 1 ▁>= ▁r 2 ▁c 1 ▁>= ▁c 2 ▁) ▁return ▁false ▁; ▁string ▁key ▁= ▁to _ string ▁( ▁r 1 ▁) ▁+ ▁' ▁- ▁' ▁+ ▁to _ string ▁( ▁c 1 ▁) ▁+ ▁' ▁- ▁' ▁+ ▁to _ string ▁( ▁r 2 ▁) ▁+ ▁' ▁- ▁' ▁+ ▁to _ string ▁( ▁c 2 ▁) ▁; ▁if ▁( ▁cache ▁. ▁find ▁( ▁key ▁) ▁!= ▁cache ▁. ▁end ▁( ▁) ▁) ▁return ▁cache ▁[ ▁key ▁] ▁; ▁cache ▁[ ▁key ▁] ▁= ▁is Square Of Zero es ▁( ▁matrix ▁, ▁r 1 ▁, ▁c 1 ▁, ▁r 2 ▁, ▁c 2 ▁) ▁|| ▁has Square Of Zero es ▁( ▁matrix ▁, ▁r 1 ▁+ ▁1 ▁, ▁c 1 ▁+ ▁1 ▁, ▁r 2 ▁- ▁1 ▁, ▁c 2 ▁- ▁1 ▁, ▁cache ▁) ▁|| ▁has Square Of Zero es ▁( ▁matrix ▁, ▁r 1 ▁, ▁c 1 ▁+ ▁1 ▁, ▁r 2 ▁- ▁1 ▁, ▁c 2 ▁, ▁cache ▁) ▁|| ▁has Square Of Zero es ▁( ▁matrix ▁, ▁r 1 ▁+ ▁1 ▁, ▁c 1 ▁, ▁r 2 ▁, ▁c 2 ▁- ▁1 ▁, ▁cache ▁) ▁|| ▁has Square Of Zero es ▁( ▁matrix ▁, ▁r 1 ▁+ ▁1 ▁, ▁c 1 ▁+ ▁1 ▁, ▁r 2 ▁, ▁c 2 ▁, ▁cache ▁) ▁|| ▁has Square Of Zero es ▁( ▁matrix ▁, ▁r 1 ▁, ▁c 1 ▁, ▁r 2 ▁- ▁1 ▁, ▁c 2 ▁- ▁1 ▁, ▁cache ▁) ▁; ▁return ▁cache ▁[ ▁key ▁] ▁; ▁} ▁bool ▁is Square Of Zero es ▁( ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁& ▁matrix ▁, ▁int ▁r 1 ▁, ▁int ▁c 1 ▁, ▁int ▁r 2 ▁, ▁int ▁c 2 ▁) ▁{ ▁for ▁( ▁int ▁row ▁= ▁r 1 ▁; ▁row ▁< ▁r 2 ▁+ ▁1 ▁; ▁row ▁++ ▁) ▁{ ▁if ▁( ▁matrix ▁[ ▁row ▁] ▁[ ▁c 1 ▁] ▁!= ▁0 ▁matrix ▁[ ▁row ▁] ▁[ ▁c 2 ▁] ▁!= ▁0 ▁) ▁return ▁false ▁; ▁} ▁for ▁( ▁int ▁col ▁= ▁c 1 ▁; ▁col ▁< ▁c 2 ▁+ ▁1 ▁; ▁col ▁++ ▁) ▁{ ▁if ▁( ▁matrix ▁[ ▁r 1 ▁] ▁[ ▁col ▁] ▁!= ▁0 ▁matrix ▁[ ▁r 2 ▁] ▁[ ▁col ▁] ▁!= ▁0 ▁) ▁return ▁false ▁; ▁} ▁return ▁true ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁matrix ▁{ ▁{ ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁} ▁, ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁} ▁, ▁{ ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁} ▁, ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁} ▁, ▁{ ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁} ▁, ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁} ▁} ▁; ▁int ▁ans ▁; ▁ans ▁= ▁square Of Zero es ▁( ▁matrix ▁) ▁; ▁if ▁( ▁ans ▁== ▁1 ▁) ▁{ ▁c out ▁<< ▁" ▁True ▁" ▁<< ▁end l ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁" ▁False ▁" ▁<< ▁end l ▁; ▁} ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁can Make Pal i Queries ▁( ▁string ▁str ▁, ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁& ▁Q ▁) ▁{ ▁int ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁dp ▁( ▁26 ▁, ▁vector ▁< ▁int ▁> ▁( ▁n ▁, ▁0 ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁26 ▁; ▁i ▁++ ▁) ▁{ ▁char ▁current Char ▁= ▁i ▁+ ▁' ▁a ▁' ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁j ▁== ▁0 ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁( ▁str ▁[ ▁j ▁] ▁== ▁current Char ▁) ▁; ▁} ▁else ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁+ ▁( ▁str ▁[ ▁j ▁] ▁== ▁current Char ▁) ▁; ▁} ▁} ▁} ▁for ▁( ▁auto ▁query ▁: ▁Q ▁) ▁{ ▁int ▁left ▁= ▁query ▁[ ▁0 ▁] ▁; ▁int ▁right ▁= ▁query ▁[ ▁1 ▁] ▁; ▁int ▁k ▁= ▁query ▁[ ▁2 ▁] ▁; ▁int ▁un Matched Count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁26 ▁; ▁i ▁++ ▁) ▁{ ▁int ▁occurrence ▁= ▁dp ▁[ ▁i ▁] ▁[ ▁right ▁] ▁- ▁dp ▁[ ▁i ▁] ▁[ ▁left ▁] ▁+ ▁( ▁str ▁[ ▁left ▁] ▁== ▁( ▁i ▁+ ▁' ▁a ▁' ▁) ▁) ▁; ▁if ▁( ▁occurrence ▁& ▁1 ▁) ▁un Matched Count ▁++ ▁; ▁} ▁int ▁ans ▁= ▁un Matched Count ▁/ ▁2 ▁; ▁if ▁( ▁ans ▁<= ▁k ▁) ▁{ ▁c out ▁<< ▁" ▁YES ▁STRNEWLINE ▁" ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁" ▁NO ▁STRNEWLINE ▁" ▁; ▁} ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁G eek s for G eek s ▁" ▁; ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁Q ▁; ▁Q ▁= ▁{ ▁{ ▁1 ▁, ▁5 ▁, ▁3 ▁} ▁, ▁{ ▁5 ▁, ▁7 ▁, ▁0 ▁} ▁, ▁{ ▁8 ▁, ▁11 ▁, ▁3 ▁} ▁, ▁{ ▁3 ▁, ▁10 ▁, ▁5 ▁} ▁, ▁{ ▁0 ▁, ▁9 ▁, ▁5 ▁} ▁} ▁; ▁can Make Pal i Queries ▁( ▁str ▁, ▁Q ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁Maximum Sum ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁dp ▁[ ▁n ▁+ ▁1 ▁] ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁+ ▁1 ▁; ▁j ▁++ ▁) ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁INT _ MIN ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁dp ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁<= ▁i ▁; ▁j ▁++ ▁) ▁{ ▁int ▁val ▁= ▁INT _ MIN ▁; ▁if ▁( ▁( ▁i ▁- ▁2 ▁>= ▁0 ▁&& ▁dp ▁[ ▁i ▁- ▁2 ▁] ▁[ ▁j ▁- ▁1 ▁] ▁!= ▁INT _ MIN ▁) ▁i ▁- ▁2 ▁< ▁0 ▁) ▁{ ▁val ▁= ▁a ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁( ▁i ▁- ▁2 ▁>= ▁0 ▁? ▁dp ▁[ ▁i ▁- ▁2 ▁] ▁[ ▁j ▁- ▁1 ▁] ▁: ▁0 ▁) ▁; ▁} ▁if ▁( ▁i ▁- ▁1 ▁>= ▁j ▁) ▁{ ▁val ▁= ▁max ▁( ▁val ▁, ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁) ▁; ▁} ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁val ▁; ▁} ▁} ▁return ▁dp ▁[ ▁n ▁] ▁[ ▁n ▁/ ▁2 ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁A ▁) ▁/ ▁sizeof ▁( ▁A ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁Maximum Sum ▁( ▁A ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁dp ▁[ ▁500 ▁] ▁[ ▁500 ▁] ▁[ ▁500 ▁] ▁; ▁int ▁calculate ▁( ▁int ▁pos ▁, ▁int ▁prev ▁, ▁int ▁left ▁, ▁int ▁k ▁) ▁{ ▁if ▁( ▁pos ▁== ▁k ▁) ▁{ ▁if ▁( ▁left ▁== ▁0 ▁) ▁return ▁1 ▁; ▁else ▁return ▁0 ▁; ▁} ▁if ▁( ▁left ▁== ▁0 ▁) ▁return ▁0 ▁; ▁if ▁( ▁dp ▁[ ▁pos ▁] ▁[ ▁prev ▁] ▁[ ▁left ▁] ▁!= ▁-1 ▁) ▁return ▁dp ▁[ ▁pos ▁] ▁[ ▁prev ▁] ▁[ ▁left ▁] ▁; ▁int ▁answer ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁prev ▁; ▁i ▁<= ▁left ▁; ▁i ▁++ ▁) ▁{ ▁answer ▁+= ▁calculate ▁( ▁pos ▁+ ▁1 ▁, ▁i ▁, ▁left ▁- ▁i ▁, ▁k ▁) ▁; ▁} ▁return ▁dp ▁[ ▁pos ▁] ▁[ ▁prev ▁] ▁[ ▁left ▁] ▁= ▁answer ▁; ▁} ▁int ▁count Way sto Div ide ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁mem set ▁( ▁dp ▁, ▁-1 ▁, ▁sizeof ▁( ▁dp ▁) ▁) ▁; ▁return ▁calculate ▁( ▁0 ▁, ▁1 ▁, ▁n ▁, ▁k ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁8 ▁; ▁int ▁K ▁= ▁4 ▁; ▁c out ▁<< ▁count Way sto Div ide ▁( ▁N ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁int ▁MAX ▁= ▁100000 ▁; ▁int ▁div is ors ▁[ ▁MAX ▁] ▁; ▁int ▁generate Div is ors ▁( ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁sqrt ▁( ▁n ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁{ ▁if ▁( ▁n ▁/ ▁i ▁== ▁i ▁) ▁{ ▁div is ors ▁[ ▁i ▁] ▁++ ▁; ▁} ▁else ▁{ ▁div is ors ▁[ ▁i ▁] ▁++ ▁; ▁div is ors ▁[ ▁n ▁/ ▁i ▁] ▁++ ▁; ▁} ▁} ▁} ▁} ▁int ▁find Max Multi ples ▁( ▁int ▁* ▁arr ▁, ▁int ▁n ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁ans ▁= ▁max ▁( ▁div is ors ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁, ▁ans ▁) ▁; ▁generate Div is ors ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁8 ▁, ▁1 ▁, ▁28 ▁, ▁4 ▁, ▁2 ▁, ▁6 ▁, ▁7 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁c out ▁<< ▁find Max Multi ples ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁egg Drop ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁dp ▁( ▁k ▁+ ▁1 ▁, ▁vector ▁< ▁int ▁> ▁( ▁n ▁+ ▁1 ▁, ▁0 ▁) ▁) ▁; ▁int ▁x ▁= ▁0 ▁; ▁while ▁( ▁dp ▁[ ▁x ▁] ▁[ ▁n ▁] ▁< ▁k ▁) ▁{ ▁x ▁++ ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁dp ▁[ ▁x ▁] ▁[ ▁i ▁] ▁= ▁dp ▁[ ▁x ▁- ▁1 ▁] ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁dp ▁[ ▁x ▁- ▁1 ▁] ▁[ ▁i ▁] ▁+ ▁1 ▁; ▁} ▁return ▁x ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁2 ▁, ▁k ▁= ▁36 ▁; ▁c out ▁<< ▁egg Drop ▁( ▁n ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁n ▁3 ▁NEW _ LINE ▁# define ▁m ▁3 ▁NEW _ LINE ▁int ▁count Square Mat rices ▁( ▁int ▁a ▁[ ▁] ▁[ ▁m ▁] ▁, ▁int ▁N ▁, ▁int ▁M ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁< ▁M ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁[ ▁j ▁] ▁== ▁0 ▁) ▁continue ▁; ▁a ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁min ▁( ▁min ▁( ▁a ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁, ▁a ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁) ▁, ▁a ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁- ▁1 ▁] ▁) ▁+ ▁1 ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁M ▁; ▁j ▁++ ▁) ▁count ▁+= ▁a ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁[ ▁m ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁0 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁1 ▁, ▁0 ▁} ▁, ▁{ ▁1 ▁, ▁1 ▁, ▁0 ▁} ▁} ▁; ▁c out ▁<< ▁count Square Mat rices ▁( ▁arr ▁, ▁n ▁, ▁m ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁V _ SUM _ MAX ▁1000 ▁NEW _ LINE ▁# define ▁N _ MAX ▁100 ▁NEW _ LINE ▁# define ▁W _ MAX ▁10000 000 ▁NEW _ LINE ▁int ▁dp ▁[ ▁V _ SUM _ MAX ▁+ ▁1 ▁] ▁[ ▁N _ MAX ▁] ▁; ▁bool ▁v ▁[ ▁V _ SUM _ MAX ▁+ ▁1 ▁] ▁[ ▁N _ MAX ▁] ▁; ▁int ▁solve D p ▁( ▁int ▁r ▁, ▁int ▁i ▁, ▁int ▁* ▁w ▁, ▁int ▁* ▁val ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁r ▁<= ▁0 ▁) ▁return ▁0 ▁; ▁if ▁( ▁i ▁== ▁n ▁) ▁return ▁W _ MAX ▁; ▁if ▁( ▁v ▁[ ▁r ▁] ▁[ ▁i ▁] ▁) ▁return ▁dp ▁[ ▁r ▁] ▁[ ▁i ▁] ▁; ▁v ▁[ ▁r ▁] ▁[ ▁i ▁] ▁= ▁1 ▁; ▁dp ▁[ ▁r ▁] ▁[ ▁i ▁] ▁= ▁min ▁( ▁solve D p ▁( ▁r ▁, ▁i ▁+ ▁1 ▁, ▁w ▁, ▁val ▁, ▁n ▁) ▁, ▁w ▁[ ▁i ▁] ▁+ ▁solve D p ▁( ▁r ▁- ▁val ▁[ ▁i ▁] ▁, ▁i ▁+ ▁1 ▁, ▁w ▁, ▁val ▁, ▁n ▁) ▁) ▁; ▁return ▁dp ▁[ ▁r ▁] ▁[ ▁i ▁] ▁; ▁} ▁int ▁max Weight ▁( ▁int ▁* ▁w ▁, ▁int ▁* ▁val ▁, ▁int ▁n ▁, ▁int ▁c ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁V _ SUM _ MAX ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁solve D p ▁( ▁i ▁, ▁0 ▁, ▁w ▁, ▁val ▁, ▁n ▁) ▁<= ▁c ▁) ▁{ ▁return ▁i ▁; ▁} ▁} ▁return ▁0 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁w ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁val ▁[ ▁] ▁= ▁{ ▁30 ▁, ▁50 ▁, ▁60 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁w ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁int ▁C ▁= ▁8 ▁; ▁c out ▁<< ▁max Weight ▁( ▁w ▁, ▁val ▁, ▁n ▁, ▁C ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁max N ▁20 ▁NEW _ LINE ▁# define ▁max M ▁64 ▁NEW _ LINE ▁int ▁dp 1 ▁[ ▁max N ▁] ▁[ ▁max M ▁] ▁; ▁bool ▁v 1 ▁[ ▁max N ▁] ▁[ ▁max M ▁] ▁; ▁int ▁find Cnt ▁( ▁int ▁* ▁arr ▁, ▁int ▁i ▁, ▁int ▁curr ▁, ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁if ▁( ▁i ▁== ▁n ▁) ▁{ ▁return ▁( ▁curr ▁== ▁m ▁) ▁; ▁} ▁if ▁( ▁v 1 ▁[ ▁i ▁] ▁[ ▁curr ▁] ▁) ▁return ▁dp 1 ▁[ ▁i ▁] ▁[ ▁curr ▁] ▁; ▁v 1 ▁[ ▁i ▁] ▁[ ▁curr ▁] ▁= ▁1 ▁; ▁dp 1 ▁[ ▁i ▁] ▁[ ▁curr ▁] ▁= ▁find Cnt ▁( ▁arr ▁, ▁i ▁+ ▁1 ▁, ▁curr ▁, ▁n ▁, ▁m ▁) ▁+ ▁find Cnt ▁( ▁arr ▁, ▁i ▁+ ▁1 ▁, ▁( ▁curr ▁& ▁arr ▁[ ▁i ▁] ▁) ▁, ▁n ▁, ▁m ▁) ▁; ▁return ▁dp 1 ▁[ ▁i ▁] ▁[ ▁curr ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁int ▁m ▁= ▁0 ▁; ▁c out ▁<< ▁find Cnt ▁( ▁arr ▁, ▁0 ▁, ▁( ▁( ▁1 ▁<< ▁6 ▁) ▁- ▁1 ▁) ▁, ▁n ▁, ▁m ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁mod ▁100 000000 7 ▁NEW _ LINE ▁int ▁dp ▁[ ▁55 ▁] ▁[ ▁55 ▁] ▁; ▁int ▁N oof W ays ▁( ▁int ▁face ▁, ▁int ▁throws ▁, ▁int ▁sum ▁) ▁{ ▁if ▁( ▁sum ▁== ▁0 ▁&& ▁throws ▁== ▁0 ▁) ▁return ▁1 ▁; ▁if ▁( ▁sum ▁< ▁0 ▁throws ▁== ▁0 ▁) ▁return ▁0 ▁; ▁if ▁( ▁dp ▁[ ▁throws ▁] ▁[ ▁sum ▁] ▁!= ▁-1 ▁) ▁return ▁dp ▁[ ▁throws ▁] ▁[ ▁sum ▁] ▁; ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁face ▁; ▁i ▁++ ▁) ▁{ ▁ans ▁+= ▁N oof W ays ▁( ▁face ▁, ▁throws ▁- ▁1 ▁, ▁sum ▁- ▁i ▁) ▁; ▁} ▁return ▁dp ▁[ ▁throws ▁] ▁[ ▁sum ▁] ▁= ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁faces ▁= ▁6 ▁, ▁throws ▁= ▁3 ▁, ▁sum ▁= ▁12 ▁; ▁mem set ▁( ▁dp ▁, ▁-1 ▁, ▁sizeof ▁dp ▁) ▁; ▁c out ▁<< ▁N oof W ays ▁( ▁faces ▁, ▁throws ▁, ▁sum ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁# define ▁bits count ▁32 ▁NEW _ LINE ▁# define ▁n ▁3 ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁prefix _ count ▁[ ▁bits count ▁] ▁[ ▁n ▁] ▁[ ▁n ▁] ▁; ▁void ▁find Prefix Count ▁( ▁int ▁arr ▁[ ▁] ▁[ ▁n ▁] ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁bits count ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁prefix _ count ▁[ ▁i ▁] ▁[ ▁j ▁] ▁[ ▁0 ▁] ▁= ▁( ▁( ▁arr ▁[ ▁j ▁] ▁[ ▁0 ▁] ▁>> ▁i ▁) ▁& ▁1 ▁) ▁; ▁for ▁( ▁int ▁k ▁= ▁1 ▁; ▁k ▁< ▁n ▁; ▁k ▁++ ▁) ▁{ ▁prefix _ count ▁[ ▁i ▁] ▁[ ▁j ▁] ▁[ ▁k ▁] ▁= ▁( ▁( ▁arr ▁[ ▁j ▁] ▁[ ▁k ▁] ▁>> ▁i ▁) ▁& ▁1 ▁) ▁; ▁prefix _ count ▁[ ▁i ▁] ▁[ ▁j ▁] ▁[ ▁k ▁] ▁+= ▁prefix _ count ▁[ ▁i ▁] ▁[ ▁j ▁] ▁[ ▁k ▁- ▁1 ▁] ▁; ▁} ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁bits count ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁for ▁( ▁int ▁k ▁= ▁0 ▁; ▁k ▁< ▁n ▁; ▁k ▁++ ▁) ▁prefix _ count ▁[ ▁i ▁] ▁[ ▁j ▁] ▁[ ▁k ▁] ▁+= ▁prefix _ count ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁[ ▁k ▁] ▁; ▁} ▁int ▁range And ▁( ▁int ▁x 1 ▁, ▁int ▁y 1 ▁, ▁int ▁x 2 ▁, ▁int ▁y 2 ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁bits count ▁; ▁i ▁++ ▁) ▁{ ▁int ▁p ▁; ▁if ▁( ▁x 1 ▁== ▁0 ▁and ▁y 1 ▁== ▁0 ▁) ▁p ▁= ▁prefix _ count ▁[ ▁i ▁] ▁[ ▁x 2 ▁] ▁[ ▁y 2 ▁] ▁; ▁else ▁if ▁( ▁x 1 ▁== ▁0 ▁) ▁p ▁= ▁prefix _ count ▁[ ▁i ▁] ▁[ ▁x 2 ▁] ▁[ ▁y 2 ▁] ▁- ▁prefix _ count ▁[ ▁i ▁] ▁[ ▁x 2 ▁] ▁[ ▁y 1 ▁- ▁1 ▁] ▁; ▁else ▁if ▁( ▁y 1 ▁== ▁0 ▁) ▁p ▁= ▁prefix _ count ▁[ ▁i ▁] ▁[ ▁x 2 ▁] ▁[ ▁y 2 ▁] ▁- ▁prefix _ count ▁[ ▁i ▁] ▁[ ▁x 1 ▁- ▁1 ▁] ▁[ ▁y 2 ▁] ▁; ▁else ▁p ▁= ▁prefix _ count ▁[ ▁i ▁] ▁[ ▁x 2 ▁] ▁[ ▁y 2 ▁] ▁- ▁prefix _ count ▁[ ▁i ▁] ▁[ ▁x 1 ▁- ▁1 ▁] ▁[ ▁y 2 ▁] ▁- ▁prefix _ count ▁[ ▁i ▁] ▁[ ▁x 2 ▁] ▁[ ▁y 1 ▁- ▁1 ▁] ▁+ ▁prefix _ count ▁[ ▁i ▁] ▁[ ▁x 1 ▁- ▁1 ▁] ▁[ ▁y 1 ▁- ▁1 ▁] ▁; ▁if ▁( ▁p ▁== ▁( ▁x 2 ▁- ▁x 1 ▁+ ▁1 ▁) ▁* ▁( ▁y 2 ▁- ▁y 1 ▁+ ▁1 ▁) ▁) ▁ans ▁= ▁( ▁ans ▁| ▁( ▁1 ▁<< ▁i ▁) ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁[ ▁n ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁, ▁{ ▁4 ▁, ▁5 ▁, ▁6 ▁} ▁, ▁{ ▁7 ▁, ▁8 ▁, ▁9 ▁} ▁} ▁; ▁find Prefix Count ▁( ▁arr ▁) ▁; ▁int ▁queries ▁[ ▁] ▁[ ▁4 ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁2 ▁, ▁2 ▁, ▁2 ▁} ▁} ▁; ▁int ▁q ▁= ▁sizeof ▁( ▁queries ▁) ▁/ ▁sizeof ▁( ▁queries ▁[ ▁0 ▁] ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁q ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁range And ▁( ▁queries ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁, ▁queries ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁, ▁queries ▁[ ▁i ▁] ▁[ ▁2 ▁] ▁, ▁queries ▁[ ▁i ▁] ▁[ ▁3 ▁] ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁n ▁; ▁int ▁solve ▁( ▁int ▁i ▁, ▁int ▁x ▁, ▁int ▁dp ▁[ ▁] ▁[ ▁4 ▁] ▁) ▁{ ▁if ▁( ▁i ▁< ▁0 ▁) ▁return ▁x ▁== ▁3 ▁; ▁if ▁( ▁dp ▁[ ▁i ▁] ▁[ ▁x ▁] ▁!= ▁-1 ▁) ▁return ▁dp ▁[ ▁i ▁] ▁[ ▁x ▁] ▁; ▁dp ▁[ ▁i ▁] ▁[ ▁x ▁] ▁= ▁solve ▁( ▁i ▁- ▁1 ▁, ▁0 ▁, ▁dp ▁) ▁; ▁dp ▁[ ▁i ▁] ▁[ ▁x ▁] ▁+= ▁solve ▁( ▁i ▁- ▁1 ▁, ▁x ▁+ ▁1 ▁, ▁dp ▁) ▁; ▁return ▁dp ▁[ ▁i ▁] ▁[ ▁x ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁n ▁= ▁4 ▁; ▁int ▁dp ▁[ ▁n ▁] ▁[ ▁4 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁4 ▁; ▁j ▁++ ▁) ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁-1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁3 ▁] ▁= ▁( ▁1 ▁<< ▁( ▁i ▁+ ▁1 ▁) ▁) ▁; ▁} ▁c out ▁<< ▁solve ▁( ▁n ▁- ▁1 ▁, ▁0 ▁, ▁dp ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max Sub Array Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁size ▁) ▁{ ▁int ▁max _ so _ far ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁int ▁curr _ max ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁{ ▁curr _ max ▁= ▁max ▁( ▁arr ▁[ ▁i ▁] ▁, ▁curr _ max ▁+ ▁arr ▁[ ▁i ▁] ▁) ▁; ▁max _ so _ far ▁= ▁max ▁( ▁max _ so _ far ▁, ▁curr _ max ▁) ▁; ▁} ▁return ▁max _ so _ far ▁; ▁} ▁int ▁len Of Long Sub arr With Given Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁unordered _ map ▁< ▁int ▁, ▁int ▁> ▁um ▁; ▁int ▁sum ▁= ▁0 ▁, ▁max Len ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁if ▁( ▁sum ▁== ▁k ▁) ▁max Len ▁= ▁i ▁+ ▁1 ▁; ▁if ▁( ▁um ▁. ▁find ▁( ▁sum ▁) ▁== ▁um ▁. ▁end ▁( ▁) ▁) ▁um ▁[ ▁sum ▁] ▁= ▁i ▁; ▁if ▁( ▁um ▁. ▁find ▁( ▁sum ▁- ▁k ▁) ▁!= ▁um ▁. ▁end ▁( ▁) ▁) ▁{ ▁if ▁( ▁max Len ▁< ▁( ▁i ▁- ▁um ▁[ ▁sum ▁- ▁k ▁] ▁) ▁) ▁max Len ▁= ▁i ▁- ▁um ▁[ ▁sum ▁- ▁k ▁] ▁; ▁} ▁} ▁return ▁max Len ▁; ▁} ▁int ▁len Long Sub arr With Max Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁max Sum ▁= ▁max Sub Array Sum ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁len Of Long Sub arr With Given Sum ▁( ▁arr ▁, ▁n ▁, ▁max Sum ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁-2 ▁, ▁-1 ▁, ▁3 ▁, ▁-4 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁Length ▁of ▁longest ▁sub array ▁having ▁maximum ▁sum ▁= ▁" ▁<< ▁len Long Sub arr With Max Sum ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁struct ▁data ▁{ ▁int ▁element ▁; ▁int ▁position ▁; ▁} ▁; ▁struct ▁data ▁find Min Element ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁struct ▁data ▁result ▁; ▁int ▁prefix Sum ▁[ ▁n ▁] ▁= ▁{ ▁0 ▁} ▁; ▁int ▁suffix Sum ▁[ ▁n ▁] ▁= ▁{ ▁0 ▁} ▁; ▁prefix Sum ▁[ ▁0 ▁] ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁prefix Sum ▁[ ▁i ▁] ▁= ▁prefix Sum ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁arr ▁[ ▁i ▁] ▁; ▁} ▁suffix Sum ▁[ ▁n ▁- ▁1 ▁] ▁= ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁2 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁suffix Sum ▁[ ▁i ▁] ▁= ▁suffix Sum ▁[ ▁i ▁+ ▁1 ▁] ▁+ ▁arr ▁[ ▁i ▁] ▁; ▁} ▁int ▁min ▁= ▁suffix Sum ▁[ ▁0 ▁] ▁; ▁int ▁pos ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁abs ▁( ▁suffix Sum ▁[ ▁i ▁+ ▁1 ▁] ▁- ▁prefix Sum ▁[ ▁i ▁] ▁) ▁< ▁min ▁) ▁{ ▁min ▁= ▁abs ▁( ▁suffix Sum ▁[ ▁i ▁+ ▁1 ▁] ▁- ▁prefix Sum ▁[ ▁i ▁] ▁) ▁; ▁if ▁( ▁suffix Sum ▁[ ▁i ▁+ ▁1 ▁] ▁< ▁prefix Sum ▁[ ▁i ▁] ▁) ▁pos ▁= ▁i ▁+ ▁1 ▁; ▁else ▁pos ▁= ▁i ▁; ▁} ▁} ▁result ▁. ▁element ▁= ▁min ▁; ▁result ▁. ▁position ▁= ▁pos ▁; ▁return ▁result ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁struct ▁data ▁values ▁; ▁values ▁= ▁find Min Element ▁( ▁arr ▁, ▁n ▁) ▁; ▁c out ▁<< ▁" ▁Minimum ▁element ▁: ▁" ▁<< ▁values ▁. ▁element ▁<< ▁end l ▁<< ▁" ▁Position ▁: ▁" ▁<< ▁values ▁. ▁position ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Ind ▁( ▁int ▁key ▁, ▁int ▁i ▁, ▁int ▁n ▁, ▁int ▁k ▁, ▁int ▁arr ▁[ ▁] ▁) ▁{ ▁int ▁start ▁, ▁end ▁, ▁mid ▁, ▁ind ▁= ▁-1 ▁; ▁start ▁= ▁i ▁+ ▁1 ▁; ▁end ▁= ▁n ▁- ▁1 ▁; ▁while ▁( ▁start ▁< ▁end ▁) ▁{ ▁mid ▁= ▁start ▁+ ▁( ▁end ▁- ▁start ▁) ▁/ ▁2 ▁; ▁if ▁( ▁arr ▁[ ▁mid ▁] ▁- ▁key ▁<= ▁k ▁) ▁{ ▁ind ▁= ▁mid ▁; ▁start ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁else ▁{ ▁end ▁= ▁mid ▁; ▁} ▁} ▁return ▁ind ▁; ▁} ▁int ▁rem ovals ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁i ▁, ▁j ▁, ▁ans ▁= ▁n ▁- ▁1 ▁; ▁sort ▁( ▁arr ▁, ▁arr ▁+ ▁n ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁j ▁= ▁find Ind ▁( ▁arr ▁[ ▁i ▁] ▁, ▁i ▁, ▁n ▁, ▁k ▁, ▁arr ▁) ▁; ▁if ▁( ▁j ▁!= ▁-1 ▁) ▁{ ▁ans ▁= ▁min ▁( ▁ans ▁, ▁n ▁- ▁( ▁j ▁- ▁i ▁+ ▁1 ▁) ▁) ▁; ▁} ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁4 ▁, ▁9 ▁, ▁10 ▁, ▁11 ▁, ▁12 ▁, ▁17 ▁, ▁20 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁int ▁k ▁= ▁4 ▁; ▁c out ▁<< ▁rem ovals ▁( ▁a ▁, ▁n ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁maxLength ▁( ▁char ▁s ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁invalid Open Bra ces ▁= ▁0 ▁; ▁int ▁invalid Close Bra ces ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁[ ▁i ▁] ▁== ▁' ▁( ▁' ▁) ▁{ ▁invalid Open Bra ces ▁++ ▁; ▁} ▁else ▁{ ▁if ▁( ▁invalid Open Bra ces ▁== ▁0 ▁) ▁{ ▁invalid Close Bra ces ▁++ ▁; ▁} ▁else ▁{ ▁invalid Open Bra ces ▁-- ▁; ▁} ▁} ▁} ▁return ▁( ▁n ▁- ▁( ▁invalid Open Bra ces ▁+ ▁invalid Close Bra ces ▁) ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁char ▁s ▁[ ▁] ▁= ▁" ▁( ▁) ▁( ▁( ▁( ▁( ▁( ▁( ▁) ▁" ▁; ▁int ▁n ▁= ▁str len ▁( ▁s ▁) ▁; ▁c out ▁<< ▁maxLength ▁( ▁s ▁, ▁n ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁MAX ▁10 ▁NEW _ LINE ▁int ▁l cs ▁( ▁int ▁dp ▁[ ▁MAX ▁] ▁[ ▁MAX ▁] ▁[ ▁MAX ▁] ▁, ▁int ▁arr 1 ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁arr 2 ▁[ ▁] ▁, ▁int ▁m ▁, ▁int ▁k ▁) ▁{ ▁if ▁( ▁k ▁< ▁0 ▁) ▁return ▁-1 e 7 ▁; ▁if ▁( ▁n ▁< ▁0 ▁m ▁< ▁0 ▁) ▁return ▁0 ▁; ▁int ▁& ▁ans ▁= ▁dp ▁[ ▁n ▁] ▁[ ▁m ▁] ▁[ ▁k ▁] ▁; ▁if ▁( ▁ans ▁!= ▁-1 ▁) ▁return ▁ans ▁; ▁ans ▁= ▁max ▁( ▁l cs ▁( ▁dp ▁, ▁arr 1 ▁, ▁n ▁- ▁1 ▁, ▁arr 2 ▁, ▁m ▁, ▁k ▁) ▁, ▁l cs ▁( ▁dp ▁, ▁arr 1 ▁, ▁n ▁, ▁arr 2 ▁, ▁m ▁- ▁1 ▁, ▁k ▁) ▁) ▁; ▁if ▁( ▁arr 1 ▁[ ▁n ▁- ▁1 ▁] ▁== ▁arr 2 ▁[ ▁m ▁- ▁1 ▁] ▁) ▁ans ▁= ▁max ▁( ▁ans ▁, ▁1 ▁+ ▁l cs ▁( ▁dp ▁, ▁arr 1 ▁, ▁n ▁- ▁1 ▁, ▁arr 2 ▁, ▁m ▁- ▁1 ▁, ▁k ▁) ▁) ▁; ▁ans ▁= ▁max ▁( ▁ans ▁, ▁1 ▁+ ▁l cs ▁( ▁dp ▁, ▁arr 1 ▁, ▁n ▁- ▁1 ▁, ▁arr 2 ▁, ▁m ▁- ▁1 ▁, ▁k ▁- ▁1 ▁) ▁) ▁; ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁k ▁= ▁1 ▁; ▁int ▁arr 1 ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁arr 2 ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁3 ▁, ▁1 ▁, ▁4 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr 1 ▁) ▁/ ▁sizeof ▁( ▁arr 1 ▁[ ▁0 ▁] ▁) ▁; ▁int ▁m ▁= ▁sizeof ▁( ▁arr 2 ▁) ▁/ ▁sizeof ▁( ▁arr 2 ▁[ ▁0 ▁] ▁) ▁; ▁int ▁dp ▁[ ▁MAX ▁] ▁[ ▁MAX ▁] ▁[ ▁MAX ▁] ▁; ▁mem set ▁( ▁dp ▁, ▁-1 ▁, ▁sizeof ▁( ▁dp ▁) ▁) ▁; ▁c out ▁<< ▁l cs ▁( ▁dp ▁, ▁arr 1 ▁, ▁n ▁, ▁arr 2 ▁, ▁m ▁, ▁k ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max Len Sub ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁m ls ▁[ ▁n ▁] ▁, ▁max ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁m ls ▁[ ▁i ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁i ▁; ▁j ▁++ ▁) ▁if ▁( ▁abs ▁( ▁arr ▁[ ▁i ▁] ▁- ▁arr ▁[ ▁j ▁] ▁) ▁<= ▁1 ▁&& ▁m ls ▁[ ▁i ▁] ▁< ▁m ls ▁[ ▁j ▁] ▁+ ▁1 ▁) ▁m ls ▁[ ▁i ▁] ▁= ▁m ls ▁[ ▁j ▁] ▁+ ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁max ▁< ▁m ls ▁[ ▁i ▁] ▁) ▁max ▁= ▁m ls ▁[ ▁i ▁] ▁; ▁return ▁max ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁5 ▁, ▁6 ▁, ▁3 ▁, ▁7 ▁, ▁6 ▁, ▁5 ▁, ▁8 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁Maximum ▁length ▁sub sequence ▁= ▁" ▁<< ▁max Len Sub ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁max ▁100000 ▁NEW _ LINE ▁int ▁base conversion ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁num ▁, ▁int ▁base ▁) ▁{ ▁int ▁i ▁= ▁0 ▁, ▁rem ▁, ▁j ▁; ▁if ▁( ▁num ▁== ▁0 ▁) ▁{ ▁return ▁0 ▁; ▁} ▁while ▁( ▁num ▁> ▁0 ▁) ▁{ ▁rem ▁= ▁num ▁% ▁base ▁; ▁arr ▁[ ▁i ▁++ ▁] ▁= ▁rem ▁; ▁num ▁/= ▁base ▁; ▁} ▁return ▁i ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁max ▁] ▁= ▁{ ▁0 ▁} ▁; ▁int ▁n ▁= ▁10 ▁; ▁int ▁size ▁= ▁base conversion ▁( ▁arr ▁, ▁n ▁- ▁1 ▁, ▁6 ▁) ▁; ▁if ▁( ▁size ▁== ▁0 ▁) ▁c out ▁<< ▁size ▁; ▁for ▁( ▁int ▁i ▁= ▁size ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁; ▁} ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁# define ▁MAX ▁1000 ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁num of Array ▁( ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁int ▁dp ▁[ ▁MAX ▁] ▁[ ▁MAX ▁] ▁; ▁vector ▁< ▁int ▁> ▁di ▁[ ▁MAX ▁] ▁; ▁vector ▁< ▁int ▁> ▁mu ▁[ ▁MAX ▁] ▁; ▁mem set ▁( ▁dp ▁, ▁0 ▁, ▁sizeof ▁dp ▁) ▁; ▁mem set ▁( ▁di ▁, ▁0 ▁, ▁sizeof ▁di ▁) ▁; ▁mem set ▁( ▁mu ▁, ▁0 ▁, ▁sizeof ▁mu ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁m ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁2 ▁* ▁i ▁; ▁j ▁<= ▁m ▁; ▁j ▁+= ▁i ▁) ▁{ ▁di ▁[ ▁j ▁] ▁. ▁push _ back ▁( ▁i ▁) ▁; ▁mu ▁[ ▁i ▁] ▁. ▁push _ back ▁( ▁j ▁) ▁; ▁} ▁di ▁[ ▁i ▁] ▁. ▁push _ back ▁( ▁i ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁m ▁; ▁i ▁++ ▁) ▁dp ▁[ ▁1 ▁] ▁[ ▁i ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁<= ▁m ▁; ▁j ▁++ ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁0 ▁; ▁for ▁( ▁auto ▁x ▁: ▁di ▁[ ▁j ▁] ▁) ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁x ▁] ▁; ▁for ▁( ▁auto ▁x ▁: ▁mu ▁[ ▁j ▁] ▁) ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁x ▁] ▁; ▁} ▁} ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁m ▁; ▁i ▁++ ▁) ▁{ ▁ans ▁+= ▁dp ▁[ ▁n ▁] ▁[ ▁i ▁] ▁; ▁di ▁[ ▁i ▁] ▁. ▁clear ▁( ▁) ▁; ▁mu ▁[ ▁i ▁] ▁. ▁clear ▁( ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁3 ▁, ▁m ▁= ▁3 ▁; ▁c out ▁<< ▁num of Array ▁( ▁n ▁, ▁m ▁) ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁# define ▁Row ▁6 ▁NEW _ LINE ▁# define ▁Col ▁6 ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁largest K Sub matrix ▁( ▁int ▁a ▁[ ▁] ▁[ ▁Col ▁] ▁) ▁{ ▁int ▁dp ▁[ ▁Row ▁] ▁[ ▁Col ▁] ▁; ▁mem set ▁( ▁dp ▁, ▁sizeof ▁( ▁dp ▁) ▁, ▁0 ▁) ▁; ▁int ▁result ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁Row ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁Col ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁i ▁== ▁0 ▁j ▁== ▁0 ▁) ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁1 ▁; ▁else ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁[ ▁j ▁] ▁== ▁a ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁&& ▁a ▁[ ▁i ▁] ▁[ ▁j ▁] ▁== ▁a ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁&& ▁a ▁[ ▁i ▁] ▁[ ▁j ▁] ▁== ▁a ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁- ▁1 ▁] ▁) ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁min ▁( ▁min ▁( ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁, ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁) ▁, ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁- ▁1 ▁] ▁) ▁+ ▁1 ▁; ▁else ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁1 ▁; ▁} ▁result ▁= ▁max ▁( ▁result ▁, ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁; ▁} ▁} ▁return ▁result ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁Row ▁] ▁[ ▁Col ▁] ▁= ▁{ ▁2 ▁, ▁2 ▁, ▁3 ▁, ▁3 ▁, ▁4 ▁, ▁4 ▁, ▁5 ▁, ▁5 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁4 ▁, ▁1 ▁, ▁2 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁4 ▁, ▁4 ▁, ▁4 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁4 ▁, ▁5 ▁, ▁5 ▁, ▁5 ▁, ▁1 ▁, ▁2 ▁, ▁7 ▁, ▁8 ▁, ▁7 ▁, ▁9 ▁, ▁4 ▁, ▁4 ▁, ▁4 ▁} ▁; ▁c out ▁<< ▁largest K Sub matrix ▁( ▁a ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Div isible Sub seq ▁( ▁string ▁str ▁, ▁int ▁n ▁) ▁{ ▁int ▁len ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁int ▁dp ▁[ ▁len ▁] ▁[ ▁n ▁] ▁; ▁mem set ▁( ▁dp ▁, ▁0 ▁, ▁sizeof ▁( ▁dp ▁) ▁) ▁; ▁dp ▁[ ▁0 ▁] ▁[ ▁( ▁str ▁[ ▁0 ▁] ▁- ▁'0' ▁) ▁% ▁n ▁] ▁++ ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁len ▁; ▁i ▁++ ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁( ▁str ▁[ ▁i ▁] ▁- ▁'0' ▁) ▁% ▁n ▁] ▁++ ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁; ▁dp ▁[ ▁i ▁] ▁[ ▁( ▁j ▁* ▁10 ▁+ ▁( ▁str ▁[ ▁i ▁] ▁- ▁'0' ▁) ▁) ▁% ▁n ▁] ▁+= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁; ▁} ▁} ▁return ▁dp ▁[ ▁len ▁- ▁1 ▁] ▁[ ▁0 ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁"1234 " ▁; ▁int ▁n ▁= ▁4 ▁; ▁c out ▁<< ▁count Div isible Sub seq ▁( ▁str ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁N ▁100 ▁NEW _ LINE ▁int ▁L ▁[ ▁N ▁] ▁[ ▁N ▁] ▁; ▁set ▁< ▁string ▁> ▁find L CS ▁( ▁string ▁X ▁, ▁string ▁Y ▁, ▁int ▁m ▁, ▁int ▁n ▁) ▁{ ▁set ▁< ▁string ▁> ▁s ▁; ▁if ▁( ▁m ▁== ▁0 ▁n ▁== ▁0 ▁) ▁{ ▁s ▁. ▁insert ▁( ▁" ▁" ▁) ▁; ▁return ▁s ▁; ▁} ▁if ▁( ▁X ▁[ ▁m ▁- ▁1 ▁] ▁== ▁Y ▁[ ▁n ▁- ▁1 ▁] ▁) ▁{ ▁set ▁< ▁string ▁> ▁tmp ▁= ▁find L CS ▁( ▁X ▁, ▁Y ▁, ▁m ▁- ▁1 ▁, ▁n ▁- ▁1 ▁) ▁; ▁for ▁( ▁string ▁str ▁: ▁tmp ▁) ▁s ▁. ▁insert ▁( ▁str ▁+ ▁X ▁[ ▁m ▁- ▁1 ▁] ▁) ▁; ▁} ▁else ▁{ ▁if ▁( ▁L ▁[ ▁m ▁- ▁1 ▁] ▁[ ▁n ▁] ▁>= ▁L ▁[ ▁m ▁] ▁[ ▁n ▁- ▁1 ▁] ▁) ▁s ▁= ▁find L CS ▁( ▁X ▁, ▁Y ▁, ▁m ▁- ▁1 ▁, ▁n ▁) ▁; ▁if ▁( ▁L ▁[ ▁m ▁] ▁[ ▁n ▁- ▁1 ▁] ▁>= ▁L ▁[ ▁m ▁- ▁1 ▁] ▁[ ▁n ▁] ▁) ▁{ ▁set ▁< ▁string ▁> ▁tmp ▁= ▁find L CS ▁( ▁X ▁, ▁Y ▁, ▁m ▁, ▁n ▁- ▁1 ▁) ▁; ▁s ▁. ▁insert ▁( ▁tmp ▁. ▁begin ▁( ▁) ▁, ▁tmp ▁. ▁end ▁( ▁) ▁) ▁; ▁} ▁} ▁return ▁s ▁; ▁} ▁int ▁L CS ▁( ▁string ▁X ▁, ▁string ▁Y ▁, ▁int ▁m ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁m ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁<= ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁i ▁== ▁0 ▁j ▁== ▁0 ▁) ▁L ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁0 ▁; ▁else ▁if ▁( ▁X ▁[ ▁i ▁- ▁1 ▁] ▁== ▁Y ▁[ ▁j ▁- ▁1 ▁] ▁) ▁L ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁L ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁- ▁1 ▁] ▁+ ▁1 ▁; ▁else ▁L ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁max ▁( ▁L ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁, ▁L ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁) ▁; ▁} ▁} ▁return ▁L ▁[ ▁m ▁] ▁[ ▁n ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁X ▁= ▁" ▁A GT G AT G ▁" ▁; ▁string ▁Y ▁= ▁" ▁GT TAG ▁" ▁; ▁int ▁m ▁= ▁X ▁. ▁length ▁( ▁) ▁; ▁int ▁n ▁= ▁Y ▁. ▁length ▁( ▁) ▁; ▁c out ▁<< ▁" ▁L CS ▁length ▁is ▁" ▁<< ▁L CS ▁( ▁X ▁, ▁Y ▁, ▁m ▁, ▁n ▁) ▁<< ▁end l ▁; ▁set ▁< ▁string ▁> ▁s ▁= ▁find L CS ▁( ▁X ▁, ▁Y ▁, ▁m ▁, ▁n ▁) ▁; ▁for ▁( ▁string ▁str ▁: ▁s ▁) ▁c out ▁<< ▁str ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Integ ral Solution s ▁( ▁int ▁n ▁) ▁{ ▁return ▁( ▁( ▁n ▁+ ▁1 ▁) ▁* ▁( ▁n ▁+ ▁2 ▁) ▁) ▁/ ▁2 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁3 ▁; ▁c out ▁<< ▁count Integ ral Solution s ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is Subset Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁sum ▁) ▁{ ▁if ▁( ▁sum ▁== ▁0 ▁) ▁return ▁true ▁; ▁if ▁( ▁n ▁== ▁0 ▁&& ▁sum ▁!= ▁0 ▁) ▁return ▁false ▁; ▁if ▁( ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁> ▁sum ▁) ▁return ▁is Subset Sum ▁( ▁arr ▁, ▁n ▁- ▁1 ▁, ▁sum ▁) ▁; ▁return ▁is Subset Sum ▁( ▁arr ▁, ▁n ▁- ▁1 ▁, ▁sum ▁) ▁|| ▁is Subset Sum ▁( ▁arr ▁, ▁n ▁- ▁1 ▁, ▁sum ▁- ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁) ▁; ▁} ▁bool ▁find Part i ion ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁if ▁( ▁sum ▁% ▁2 ▁!= ▁0 ▁) ▁return ▁false ▁; ▁return ▁is Subset Sum ▁( ▁arr ▁, ▁n ▁, ▁sum ▁/ ▁2 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁1 ▁, ▁5 ▁, ▁9 ▁, ▁12 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁if ▁( ▁find Part i ion ▁( ▁arr ▁, ▁n ▁) ▁== ▁true ▁) ▁c out ▁<< ▁" ▁Can ▁be ▁divided ▁into ▁two ▁subsets ▁" ▁" ▁of ▁equal ▁sum ▁" ▁; ▁else ▁c out ▁<< ▁" ▁Can ▁not ▁be ▁divided ▁into ▁two ▁subsets ▁" ▁" ▁of ▁equal ▁sum ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find ▁( ▁int ▁N ▁, ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁Arr ▁) ▁{ ▁int ▁amount ▁= ▁0 ▁; ▁vector ▁< ▁int ▁> ▁mid _ odd ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁int ▁s iz ▁= ▁Arr ▁[ ▁i ▁] ▁. ▁size ▁( ▁) ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁s iz ▁/ ▁2 ▁; ▁j ▁++ ▁) ▁amount ▁= ▁amount ▁+ ▁Arr ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁if ▁( ▁s iz ▁% ▁2 ▁== ▁1 ▁) ▁mid _ odd ▁. ▁push _ back ▁( ▁Arr ▁[ ▁i ▁] ▁[ ▁s iz ▁/ ▁2 ▁] ▁) ▁; ▁} ▁sort ▁( ▁mid _ odd ▁. ▁begin ▁( ▁) ▁, ▁mid _ odd ▁. ▁end ▁( ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁mid _ odd ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁if ▁( ▁i ▁% ▁2 ▁== ▁0 ▁) ▁amount ▁= ▁amount ▁+ ▁mid _ odd ▁[ ▁i ▁] ▁; ▁c out ▁<< ▁amount ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁2 ▁; ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁Arr ▁{ ▁{ ▁5 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁, ▁{ ▁1 ▁, ▁6 ▁} ▁} ▁; ▁find ▁( ▁N ▁, ▁Arr ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print Diag onal Traversal ▁( ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁& ▁nums ▁) ▁{ ▁int ▁max _ size ▁= ▁nums ▁. ▁size ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁nums ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁max _ size ▁< ▁nums ▁[ ▁i ▁] ▁. ▁size ▁( ▁) ▁) ▁{ ▁max _ size ▁= ▁nums ▁[ ▁i ▁] ▁. ▁size ▁( ▁) ▁; ▁} ▁} ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁v ▁( ▁2 ▁* ▁max _ size ▁- ▁1 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁nums ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁nums ▁[ ▁i ▁] ▁. ▁size ▁( ▁) ▁; ▁j ▁++ ▁) ▁{ ▁v ▁[ ▁i ▁+ ▁j ▁] ▁. ▁push _ back ▁( ▁nums ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁v ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁reverse ▁( ▁v ▁[ ▁i ▁] ▁. ▁begin ▁( ▁) ▁, ▁v ▁[ ▁i ▁] ▁. ▁end ▁( ▁) ▁) ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁v ▁[ ▁i ▁] ▁. ▁size ▁( ▁) ▁; ▁j ▁++ ▁) ▁c out ▁<< ▁v ▁[ ▁i ▁] ▁[ ▁j ▁] ▁<< ▁" ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁arr ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁, ▁{ ▁4 ▁, ▁5 ▁, ▁6 ▁} ▁, ▁{ ▁7 ▁, ▁8 ▁, ▁9 ▁} ▁} ▁; ▁print Diag onal Traversal ▁( ▁arr ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁O dd Length Sum ▁( ▁vector ▁< ▁int ▁> ▁& ▁arr ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁int ▁l ▁= ▁arr ▁. ▁size ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁l ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁< ▁l ▁; ▁j ▁+= ▁2 ▁) ▁{ ▁for ▁( ▁int ▁k ▁= ▁i ▁; ▁k ▁<= ▁j ▁; ▁k ▁++ ▁) ▁{ ▁sum ▁+= ▁arr ▁[ ▁k ▁] ▁; ▁} ▁} ▁} ▁return ▁sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁int ▁> ▁arr ▁= ▁{ ▁1 ▁, ▁5 ▁, ▁3 ▁, ▁1 ▁, ▁2 ▁} ▁; ▁c out ▁<< ▁O dd Length Sum ▁( ▁arr ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁long ▁long ▁N _ bon acci ▁[ ▁100 ▁] ▁; ▁void ▁N _ bon acci _ nums ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁N _ bon acci ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁50 ▁; ▁++ ▁i ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁- ▁1 ▁; ▁j ▁>= ▁i ▁- ▁k ▁and ▁j ▁>= ▁0 ▁; ▁-- ▁j ▁) ▁N _ bon acci ▁[ ▁i ▁] ▁+= ▁N _ bon acci ▁[ ▁j ▁] ▁; ▁} ▁vector ▁< ▁long ▁long ▁> ▁ans ▁; ▁for ▁( ▁int ▁i ▁= ▁50 ▁; ▁i ▁>= ▁0 ▁; ▁-- ▁i ▁) ▁if ▁( ▁n ▁- ▁N _ bon acci ▁[ ▁i ▁] ▁>= ▁0 ▁) ▁{ ▁ans ▁. ▁push _ back ▁( ▁N _ bon acci ▁[ ▁i ▁] ▁) ▁; ▁n ▁-= ▁N _ bon acci ▁[ ▁i ▁] ▁; ▁} ▁if ▁( ▁ans ▁. ▁size ▁( ▁) ▁== ▁1 ▁) ▁ans ▁. ▁push _ back ▁( ▁0 ▁) ▁; ▁c out ▁<< ▁ans ▁. ▁size ▁( ▁) ▁<< ▁end l ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁ans ▁. ▁size ▁( ▁) ▁; ▁++ ▁i ▁) ▁c out ▁<< ▁ans ▁[ ▁i ▁] ▁<< ▁" ▁, ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁21 ▁, ▁k ▁= ▁5 ▁; ▁N _ bon acci _ nums ▁( ▁n ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁check Bit onic ▁( ▁string ▁s ▁) ▁{ ▁int ▁i ▁, ▁j ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁s ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁[ ▁i ▁] ▁> ▁s ▁[ ▁i ▁- ▁1 ▁] ▁) ▁continue ▁; ▁if ▁( ▁s ▁[ ▁i ▁] ▁<= ▁s ▁[ ▁i ▁- ▁1 ▁] ▁) ▁break ▁; ▁} ▁if ▁( ▁i ▁== ▁s ▁. ▁size ▁( ▁) ▁- ▁1 ▁) ▁return ▁1 ▁; ▁for ▁( ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁s ▁. ▁size ▁( ▁) ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁s ▁[ ▁j ▁] ▁< ▁s ▁[ ▁j ▁- ▁1 ▁] ▁) ▁continue ▁; ▁if ▁( ▁s ▁[ ▁j ▁] ▁>= ▁s ▁[ ▁j ▁- ▁1 ▁] ▁) ▁break ▁; ▁} ▁i ▁= ▁j ▁; ▁if ▁( ▁i ▁!= ▁s ▁. ▁size ▁( ▁) ▁) ▁return ▁0 ▁; ▁return ▁1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁" ▁abc df g cb a ▁" ▁; ▁( ▁check Bit onic ▁( ▁s ▁) ▁== ▁1 ▁) ▁? ▁c out ▁<< ▁" ▁YES ▁" ▁: ▁c out ▁<< ▁" ▁NO ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁make Array ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁i ▁* ▁n ▁<< ▁" ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁6 ▁; ▁int ▁arr ▁[ ▁N ▁] ▁; ▁make Array ▁( ▁arr ▁, ▁N ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁check Q w erty Row ▁( ▁char ▁x ▁) ▁{ ▁set ▁< ▁char ▁> ▁first _ row ▁= ▁{ ▁'1' ▁, ▁'2' ▁, ▁'3' ▁, ▁'4' ▁, ▁'5' ▁, ▁'6' ▁, ▁'7' ▁, ▁'8' ▁, ▁'9' ▁, ▁'0' ▁, ▁' ▁- ▁' ▁, ▁' ▁= ▁' ▁} ▁; ▁set ▁< ▁char ▁> ▁second _ row ▁= ▁{ ▁' ▁Q ▁' ▁, ▁' ▁W ▁' ▁, ▁' ▁E ▁' ▁, ▁' ▁R ▁' ▁, ▁' ▁T ▁' ▁, ▁' ▁Y ▁' ▁, ▁' ▁U ▁' ▁, ▁' ▁I ▁' ▁, ▁' ▁O ▁' ▁, ▁' ▁P ▁' ▁, ▁' ▁[ ▁' ▁, ▁' ▁] ▁' ▁, ▁' ▁q ▁' ▁, ▁' ▁w ▁' ▁, ▁' ▁e ▁' ▁, ▁' ▁r ▁' ▁, ▁' ▁t ▁' ▁, ▁' ▁y ▁' ▁, ▁' ▁u ▁' ▁, ▁' ▁i ▁' ▁, ▁' ▁o ▁' ▁, ▁' ▁p ▁' ▁} ▁; ▁set ▁< ▁char ▁> ▁third _ row ▁= ▁{ ▁' ▁A ▁' ▁, ▁' ▁S ▁' ▁, ▁' ▁D ▁' ▁, ▁' ▁F ▁' ▁, ▁' ▁G ▁' ▁, ▁' ▁H ▁' ▁, ▁' ▁J ▁' ▁, ▁' ▁K ▁' ▁, ▁' ▁L ▁' ▁, ▁' ▁; ▁' ▁, ▁' ▁: ▁' ▁, ▁' ▁a ▁' ▁, ▁' ▁s ▁' ▁, ▁' ▁d ▁' ▁, ▁' ▁f ▁' ▁, ▁' ▁g ▁' ▁, ▁' ▁h ▁' ▁, ▁' ▁j ▁' ▁, ▁' ▁k ▁' ▁, ▁' ▁l ▁' ▁} ▁; ▁set ▁< ▁char ▁> ▁fourth _ row ▁= ▁{ ▁' ▁Z ▁' ▁, ▁' ▁X ▁' ▁, ▁' ▁C ▁' ▁, ▁' ▁V ▁' ▁, ▁' ▁B ▁' ▁, ▁' ▁N ▁' ▁, ▁' ▁M ▁' ▁, ▁' ▁, ▁' ▁, ▁' ▁. ▁' ▁, ▁' ▁/ ▁' ▁, ▁' ▁z ▁' ▁, ▁' ▁x ▁' ▁, ▁' ▁c ▁' ▁, ▁' ▁v ▁' ▁, ▁' ▁b ▁' ▁, ▁' ▁n ▁' ▁, ▁' ▁m ▁' ▁} ▁; ▁if ▁( ▁first _ row ▁. ▁count ▁( ▁x ▁) ▁> ▁0 ▁) ▁{ ▁return ▁1 ▁; ▁} ▁else ▁if ▁( ▁second _ row ▁. ▁count ▁( ▁x ▁) ▁> ▁0 ▁) ▁{ ▁return ▁2 ▁; ▁} ▁else ▁if ▁( ▁third _ row ▁. ▁count ▁( ▁x ▁) ▁> ▁0 ▁) ▁{ ▁return ▁3 ▁; ▁} ▁else ▁if ▁( ▁fourth _ row ▁. ▁count ▁( ▁x ▁) ▁> ▁0 ▁) ▁{ ▁return ▁4 ▁; ▁} ▁return ▁0 ▁; ▁} ▁bool ▁check Validity ▁( ▁string ▁str ▁) ▁{ ▁char ▁x ▁= ▁str ▁[ ▁0 ▁] ▁; ▁int ▁row ▁= ▁check Q w erty Row ▁( ▁x ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁str ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁x ▁= ▁str ▁[ ▁i ▁] ▁; ▁if ▁( ▁row ▁!= ▁check Q w erty Row ▁( ▁x ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁} ▁return ▁true ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁G eek s for G eek s ▁" ▁; ▁if ▁( ▁check Validity ▁( ▁str ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁; ▁return ▁( ▁0 ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁long ▁long ▁fib ▁( ▁long ▁long ▁n ▁) ▁{ ▁long ▁long ▁f 0 ▁= ▁0 ▁; ▁long ▁long ▁f 1 ▁= ▁1 ▁; ▁if ▁( ▁n ▁== ▁0 ▁) ▁return ▁0 ▁; ▁if ▁( ▁n ▁== ▁1 ▁) ▁return ▁1 ▁; ▁else ▁{ ▁long ▁long ▁rem ▁= ▁n ▁% ▁60 ▁; ▁if ▁( ▁rem ▁== ▁0 ▁) ▁return ▁0 ▁; ▁for ▁( ▁long ▁long ▁i ▁= ▁2 ▁; ▁i ▁< ▁rem ▁+ ▁3 ▁; ▁i ▁++ ▁) ▁{ ▁long ▁long ▁f ▁= ▁( ▁f 0 ▁+ ▁f 1 ▁) ▁% ▁60 ▁; ▁f 0 ▁= ▁f 1 ▁; ▁f 1 ▁= ▁f ▁; ▁} ▁long ▁long ▁s ▁= ▁f 1 ▁- ▁1 ▁; ▁return ▁s ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁long ▁long ▁m ▁= ▁100 8 78 87 ▁; ▁long ▁long ▁n ▁= ▁2 98 309 78 99 ▁; ▁long ▁long ▁final ▁= ▁abs ▁( ▁fib ▁( ▁n ▁) ▁- ▁fib ▁( ▁m ▁- ▁1 ▁) ▁) ▁; ▁c out ▁<< ▁final ▁% ▁10 ▁<< ▁end l ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁print Pattern ▁( ▁int ▁i ▁, ▁int ▁j ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁j ▁>= ▁n ▁) ▁{ ▁return ▁0 ▁; ▁} ▁if ▁( ▁i ▁>= ▁n ▁) ▁{ ▁return ▁1 ▁; ▁} ▁if ▁( ▁j ▁== ▁i ▁j ▁== ▁n ▁- ▁1 ▁- ▁i ▁) ▁{ ▁if ▁( ▁i ▁== ▁n ▁- ▁1 ▁- ▁j ▁) ▁{ ▁c out ▁<< ▁" ▁/ ▁" ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁" ▁\ ▁\" ▁; ▁} ▁} ▁else ▁{ ▁c out ▁<< ▁" ▁* ▁" ▁; ▁} ▁if ▁( ▁print Pattern ▁( ▁i ▁, ▁j ▁+ ▁1 ▁, ▁n ▁) ▁== ▁1 ▁) ▁{ ▁return ▁1 ▁; ▁} ▁c out ▁<< ▁end l ▁; ▁return ▁print Pattern ▁( ▁i ▁+ ▁1 ▁, ▁0 ▁, ▁n ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁9 ▁; ▁print Pattern ▁( ▁0 ▁, ▁0 ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁reverse Str ▁( ▁string ▁& ▁str ▁, ▁int ▁l ▁, ▁int ▁h ▁) ▁{ ▁int ▁n ▁= ▁h ▁- ▁l ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁/ ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁swap ▁( ▁str ▁[ ▁i ▁+ ▁l ▁] ▁, ▁str ▁[ ▁n ▁- ▁i ▁- ▁1 ▁+ ▁l ▁] ▁) ▁; ▁} ▁} ▁void ▁reverse String ▁( ▁string ▁& ▁s ▁, ▁int ▁A ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁reverse Str ▁( ▁s ▁, ▁0 ▁, ▁A ▁[ ▁0 ▁] ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁reverse Str ▁( ▁s ▁, ▁A ▁[ ▁i ▁- ▁1 ▁] ▁, ▁A ▁[ ▁i ▁] ▁) ▁; ▁reverse Str ▁( ▁s ▁, ▁A ▁[ ▁n ▁- ▁1 ▁] ▁, ▁s ▁. ▁length ▁( ▁) ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁" ▁abcdef gh ▁" ▁; ▁int ▁A ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁4 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁A ▁) ▁/ ▁sizeof ▁( ▁A ▁[ ▁0 ▁] ▁) ▁; ▁reverse String ▁( ▁s ▁, ▁A ▁, ▁n ▁) ▁; ▁c out ▁<< ▁s ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁getElement ▁( ▁int ▁N ▁, ▁int ▁r ▁, ▁int ▁c ▁) ▁{ ▁if ▁( ▁r ▁> ▁c ▁) ▁return ▁0 ▁; ▁if ▁( ▁r ▁== ▁1 ▁) ▁{ ▁return ▁c ▁; ▁} ▁int ▁a ▁= ▁( ▁r ▁+ ▁1 ▁) ▁* ▁pow ▁( ▁2 ▁, ▁r ▁- ▁2 ▁) ▁; ▁int ▁d ▁= ▁pow ▁( ▁2 ▁, ▁r ▁- ▁1 ▁) ▁; ▁c ▁= ▁c ▁- ▁r ▁; ▁int ▁element ▁= ▁a ▁+ ▁d ▁* ▁c ▁; ▁return ▁element ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁4 ▁, ▁R ▁= ▁3 ▁, ▁C ▁= ▁4 ▁; ▁c out ▁<< ▁getElement ▁( ▁N ▁, ▁R ▁, ▁C ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁check ▁( ▁string ▁S 1 ▁, ▁string ▁S 2 ▁) ▁{ ▁int ▁n 1 ▁= ▁S 1 ▁. ▁size ▁( ▁) ▁; ▁int ▁n 2 ▁= ▁S 2 ▁. ▁size ▁( ▁) ▁; ▁unordered _ map ▁< ▁int ▁, ▁int ▁> ▁mp ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n 1 ▁; ▁i ▁++ ▁) ▁{ ▁mp ▁[ ▁S 1 ▁[ ▁i ▁] ▁] ▁++ ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n 2 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁mp ▁[ ▁S 2 ▁[ ▁i ▁] ▁] ▁) ▁{ ▁mp ▁[ ▁S 2 ▁[ ▁i ▁] ▁] ▁-- ▁; ▁} ▁else ▁if ▁( ▁mp ▁[ ▁S 2 ▁[ ▁i ▁] ▁- ▁1 ▁] ▁&& ▁mp ▁[ ▁S 2 ▁[ ▁i ▁] ▁- ▁2 ▁] ▁) ▁{ ▁mp ▁[ ▁S 2 ▁[ ▁i ▁] ▁- ▁1 ▁] ▁-- ▁; ▁mp ▁[ ▁S 2 ▁[ ▁i ▁] ▁- ▁2 ▁] ▁-- ▁; ▁} ▁else ▁{ ▁return ▁false ▁; ▁} ▁} ▁return ▁true ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁S 1 ▁= ▁" ▁ab bat ▁" ▁; ▁string ▁S 2 ▁= ▁" ▁cat ▁" ▁; ▁if ▁( ▁check ▁( ▁S 1 ▁, ▁S 2 ▁) ▁) ▁c out ▁<< ▁" ▁YES ▁" ▁; ▁else ▁c out ▁<< ▁" ▁NO ▁" ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁length N Pal indrome ▁( ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁int ▁half ▁= ▁N ▁/ ▁2 ▁; ▁if ▁( ▁N ▁& ▁1 ▁) ▁{ ▁half ▁+= ▁1 ▁; ▁} ▁int ▁ans ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁half ▁; ▁i ▁++ ▁) ▁{ ▁ans ▁*= ▁K ▁; ▁K ▁-- ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁pal ind rom ic Strings ▁( ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁if ▁( ▁N ▁== ▁1 ▁) ▁{ ▁return ▁K ▁; ▁} ▁if ▁( ▁N ▁== ▁2 ▁) ▁{ ▁return ▁2 ▁* ▁K ▁; ▁} ▁int ▁ans ▁= ▁0 ▁; ▁ans ▁+= ▁( ▁2 ▁* ▁K ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁3 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁ans ▁+= ▁length N Pal indrome ▁( ▁i ▁, ▁K ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁4 ▁, ▁K ▁= ▁3 ▁; ▁c out ▁<< ▁pal ind rom ic Strings ▁( ▁N ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁" ▁bits ▁/ ▁std c ▁+ ▁+ ▁. ▁h ▁" ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁L CS ▁( ▁string ▁& ▁S ▁, ▁int ▁N ▁, ▁string ▁& ▁T ▁, ▁int ▁M ▁, ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁& ▁dp ▁) ▁{ ▁if ▁( ▁N ▁== ▁0 ▁or ▁M ▁== ▁0 ▁) ▁return ▁0 ▁; ▁if ▁( ▁dp ▁[ ▁N ▁] ▁[ ▁M ▁] ▁!= ▁-1 ▁) ▁return ▁dp ▁[ ▁N ▁] ▁[ ▁M ▁] ▁; ▁if ▁( ▁S ▁[ ▁N ▁- ▁1 ▁] ▁== ▁T ▁[ ▁M ▁- ▁1 ▁] ▁) ▁{ ▁return ▁dp ▁[ ▁N ▁] ▁[ ▁M ▁] ▁= ▁1 ▁+ ▁L CS ▁( ▁S ▁, ▁N ▁- ▁1 ▁, ▁T ▁, ▁M ▁- ▁1 ▁, ▁dp ▁) ▁; ▁} ▁return ▁dp ▁[ ▁N ▁] ▁[ ▁M ▁] ▁= ▁max ▁( ▁L CS ▁( ▁S ▁, ▁N ▁- ▁1 ▁, ▁T ▁, ▁M ▁, ▁dp ▁) ▁, ▁L CS ▁( ▁S ▁, ▁N ▁, ▁T ▁, ▁M ▁- ▁1 ▁, ▁dp ▁) ▁) ▁; ▁} ▁int ▁minimum Character ▁( ▁string ▁& ▁S ▁) ▁{ ▁string ▁T ▁= ▁" ▁abcdef ghijklmnop qrstuvwxyz ▁" ▁; ▁int ▁N ▁= ▁S ▁. ▁length ▁( ▁) ▁, ▁M ▁= ▁T ▁. ▁length ▁( ▁) ▁; ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁dp ▁( ▁N ▁+ ▁1 ▁, ▁vector ▁< ▁int ▁> ▁( ▁M ▁+ ▁1 ▁, ▁-1 ▁) ▁) ▁; ▁return ▁( ▁26 ▁- ▁L CS ▁( ▁S ▁, ▁N ▁, ▁T ▁, ▁M ▁, ▁dp ▁) ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁S ▁= ▁" ▁abcd ad c ▁" ▁; ▁c out ▁<< ▁minimum Character ▁( ▁S ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁string ▁Min Value ▁( ▁string ▁N ▁, ▁int ▁X ▁) ▁{ ▁int ▁len ▁= ▁N ▁. ▁size ▁( ▁) ▁; ▁int ▁position ▁= ▁len ▁+ ▁1 ▁; ▁if ▁( ▁N ▁[ ▁0 ▁] ▁== ▁' ▁- ▁' ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁len ▁- ▁1 ▁; ▁i ▁>= ▁1 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁( ▁N ▁[ ▁i ▁] ▁- ▁'0' ▁) ▁< ▁X ▁) ▁{ ▁position ▁= ▁i ▁; ▁} ▁} ▁} ▁else ▁{ ▁for ▁( ▁int ▁i ▁= ▁len ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁( ▁N ▁[ ▁i ▁] ▁- ▁'0' ▁) ▁> ▁X ▁) ▁{ ▁position ▁= ▁i ▁; ▁} ▁} ▁} ▁N ▁. ▁insert ▁( ▁N ▁. ▁begin ▁( ▁) ▁+ ▁position ▁, ▁X ▁+ ▁'0' ▁) ▁; ▁return ▁N ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁N ▁= ▁" 89 " ▁; ▁int ▁X ▁= ▁1 ▁; ▁c out ▁<< ▁Min Value ▁( ▁N ▁, ▁X ▁) ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁count Operations ▁( ▁string ▁S ▁) ▁{ ▁int ▁n ▁= ▁S ▁. ▁length ▁( ▁) ▁; ▁int ▁ans ▁= ▁0 ▁; ▁int ▁cnt ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁S ▁[ ▁i ▁] ▁== ▁'0' ▁) ▁{ ▁cnt ▁++ ▁; ▁} ▁else ▁{ ▁if ▁( ▁cnt ▁> ▁0 ▁) ▁{ ▁cnt ▁-- ▁; ▁ans ▁++ ▁; ▁} ▁} ▁} ▁c out ▁<< ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁S ▁= ▁"11 00 11 01 0" ▁; ▁count Operations ▁( ▁S ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is Prime ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁<= ▁1 ▁) ▁return ▁false ▁; ▁else ▁if ▁( ▁n ▁== ▁2 ▁) ▁return ▁true ▁; ▁else ▁if ▁( ▁n ▁% ▁2 ▁== ▁0 ▁) ▁return ▁false ▁; ▁for ▁( ▁int ▁i ▁= ▁3 ▁; ▁i ▁<= ▁sqrt ▁( ▁n ▁) ▁; ▁i ▁+= ▁2 ▁) ▁{ ▁if ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁return ▁false ▁; ▁} ▁return ▁true ▁; ▁} ▁void ▁check Perm utation ▁( ▁string ▁s 1 ▁, ▁string ▁s 2 ▁) ▁{ ▁int ▁freq ▁[ ▁26 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁char ▁ch ▁: ▁s 1 ▁) ▁{ ▁freq ▁[ ▁ch ▁- ▁' ▁a ▁' ▁] ▁-- ▁; ▁} ▁for ▁( ▁char ▁ch ▁: ▁s 2 ▁) ▁{ ▁freq ▁[ ▁ch ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁} ▁bool ▁is All Changes Prime ▁= ▁true ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁26 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁freq ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁continue ▁; ▁} ▁else ▁if ▁( ▁! ▁is Prime ▁( ▁abs ▁( ▁freq ▁[ ▁i ▁] ▁) ▁) ▁) ▁{ ▁is All Changes Prime ▁= ▁false ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁is All Changes Prime ▁) ▁{ ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁" ▁No ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁S 1 ▁= ▁" ▁g ek for g k ▁" ▁; ▁string ▁S 2 ▁= ▁" ▁g eek s forge ek s ▁" ▁; ▁check Perm utation ▁( ▁S 1 ▁, ▁S 2 ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁minimum Operations ▁( ▁string ▁S ▁, ▁int ▁N ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁int ▁cnt One ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁N ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁S ▁[ ▁i ▁] ▁== ▁'0' ▁) ▁{ ▁ans ▁+= ▁cnt One ▁; ▁cnt One ▁*= ▁2 ▁; ▁} ▁else ▁cnt One ▁++ ▁; ▁} ▁c out ▁<< ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁S ▁= ▁"00 1" ▁; ▁int ▁N ▁= ▁S ▁. ▁length ▁( ▁) ▁; ▁minimum Operations ▁( ▁S ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is Prime ▁( ▁int ▁num ▁) ▁{ ▁bool ▁flag ▁= ▁false ▁; ▁if ▁( ▁num ▁> ▁1 ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁< ▁num ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁num ▁% ▁i ▁) ▁== ▁0 ▁) ▁{ ▁flag ▁= ▁true ▁; ▁break ▁; ▁} ▁} ▁} ▁if ▁( ▁flag ▁) ▁return ▁false ▁; ▁else ▁return ▁true ▁; ▁} ▁int ▁order ▁( ▁int ▁x ▁) ▁{ ▁int ▁n ▁= ▁0 ▁; ▁while ▁( ▁x ▁!= ▁0 ▁) ▁{ ▁n ▁= ▁n ▁+ ▁1 ▁; ▁x ▁= ▁x ▁/ ▁10 ▁; ▁} ▁return ▁n ▁; ▁} ▁bool ▁is Ar m strong ▁( ▁int ▁x ▁) ▁{ ▁int ▁n ▁= ▁order ▁( ▁x ▁) ▁; ▁int ▁temp ▁= ▁x ▁; ▁int ▁sum 1 ▁= ▁0 ▁; ▁while ▁( ▁temp ▁!= ▁0 ▁) ▁{ ▁int ▁r ▁= ▁temp ▁% ▁10 ▁; ▁sum 1 ▁= ▁sum 1 ▁+ ▁pow ▁( ▁r ▁, ▁n ▁) ▁; ▁temp ▁= ▁temp ▁/ ▁10 ▁; ▁} ▁return ▁( ▁sum 1 ▁== ▁x ▁) ▁; ▁} ▁int ▁count _ arm strong ▁( ▁vector ▁< ▁string ▁> ▁li ▁) ▁{ ▁int ▁c ▁= ▁0 ▁; ▁for ▁( ▁string ▁ele ▁: ▁li ▁) ▁{ ▁int ▁val ▁= ▁0 ▁; ▁for ▁( ▁char ▁che ▁: ▁ele ▁) ▁val ▁+= ▁che ▁; ▁if ▁( ▁is Ar m strong ▁( ▁val ▁) ▁) ▁c ▁+= ▁1 ▁; ▁} ▁return ▁c ▁; ▁} ▁int ▁count _ prime ▁( ▁vector ▁< ▁string ▁> ▁li ▁) ▁{ ▁int ▁c ▁= ▁0 ▁; ▁for ▁( ▁string ▁ele ▁: ▁li ▁) ▁{ ▁int ▁val ▁= ▁0 ▁; ▁for ▁( ▁char ▁che ▁: ▁ele ▁) ▁val ▁+= ▁che ▁; ▁if ▁( ▁is Prime ▁( ▁val ▁) ▁) ▁c ▁+= ▁1 ▁; ▁} ▁return ▁c ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁string ▁> ▁arr ▁= ▁{ ▁" ▁g eek s forge ek s ▁" ▁, ▁" ▁a ▁" ▁, ▁" ▁computer ▁" ▁, ▁" ▁sc ience ▁" ▁, ▁" ▁portal ▁" ▁, ▁" ▁for ▁" ▁, ▁" ▁g eek s ▁" ▁} ▁; ▁c out ▁<< ▁" ▁Number ▁of ▁Ar m strong ▁Strings ▁are ▁: ▁" ▁<< ▁count _ arm strong ▁( ▁arr ▁) ▁<< ▁end l ▁; ▁c out ▁<< ▁" ▁Number ▁of ▁Prime ▁Strings ▁are ▁: ▁" ▁<< ▁count _ prime ▁( ▁arr ▁) ▁<< ▁end l ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count ▁( ▁string ▁S ▁, ▁int ▁X ▁, ▁int ▁Y ▁) ▁{ ▁int ▁N ▁= ▁S ▁. ▁length ▁( ▁) ▁; ▁int ▁temp _ x ▁= ▁0 ▁, ▁temp _ y ▁= ▁0 ▁; ▁int ▁count ▁= ▁0 ▁; ▁set ▁< ▁pair ▁< ▁int ▁, ▁int ▁> ▁> ▁s ▁; ▁s ▁. ▁insert ▁( ▁{ ▁X ▁, ▁Y ▁} ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁temp _ x ▁= ▁X ▁; ▁temp _ y ▁= ▁Y ▁; ▁if ▁( ▁S ▁[ ▁i ▁] ▁== ▁' ▁U ▁' ▁) ▁{ ▁X ▁++ ▁; ▁} ▁else ▁if ▁( ▁S ▁[ ▁i ▁] ▁== ▁' ▁D ▁' ▁) ▁{ ▁X ▁-- ▁; ▁} ▁else ▁if ▁( ▁S ▁[ ▁i ▁] ▁== ▁' ▁R ▁' ▁) ▁{ ▁Y ▁++ ▁; ▁} ▁else ▁{ ▁Y ▁-- ▁; ▁} ▁if ▁( ▁s ▁. ▁find ▁( ▁{ ▁temp _ x ▁+ ▁X ▁, ▁temp _ y ▁+ ▁Y ▁} ▁) ▁!= ▁s ▁. ▁end ▁( ▁) ▁) ▁{ ▁count ▁++ ▁; ▁} ▁else ▁{ ▁s ▁. ▁insert ▁( ▁{ ▁temp _ x ▁+ ▁X ▁, ▁temp _ y ▁+ ▁Y ▁} ▁) ▁; ▁} ▁} ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁S ▁= ▁" ▁RDD U DL ▁" ▁; ▁int ▁X ▁= ▁0 ▁, ▁Y ▁= ▁0 ▁; ▁c out ▁<< ▁count ▁( ▁S ▁, ▁X ▁, ▁Y ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁count Min M oves ▁( ▁string ▁str ▁) ▁{ ▁int ▁n ▁= ▁str ▁. ▁size ▁( ▁) ▁; ▁int ▁a ▁[ ▁n ▁] ▁= ▁{ ▁0 ▁} ▁; ▁int ▁j ▁, ▁ans ▁= ▁0 ▁, ▁i ▁, ▁sum ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁str ▁[ ▁i ▁] ▁== ▁' ▁) ▁' ▁) ▁{ ▁a ▁[ ▁i ▁] ▁+= ▁sum ▁- ▁1 ▁; ▁} ▁else ▁{ ▁a ▁[ ▁i ▁] ▁+= ▁sum ▁+ ▁1 ▁; ▁} ▁sum ▁= ▁a ▁[ ▁i ▁] ▁; ▁} ▁if ▁( ▁sum ▁== ▁0 ▁) ▁{ ▁i ▁= ▁1 ▁; ▁while ▁( ▁i ▁< ▁n ▁) ▁{ ▁j ▁= ▁i ▁- ▁1 ▁; ▁while ▁( ▁i ▁< ▁n ▁&& ▁a ▁[ ▁i ▁] ▁!= ▁0 ▁) ▁i ▁++ ▁; ▁if ▁( ▁i ▁< ▁n ▁&& ▁a ▁[ ▁i ▁- ▁1 ▁] ▁< ▁0 ▁) ▁{ ▁ans ▁+= ▁i ▁- ▁j ▁; ▁if ▁( ▁j ▁== ▁0 ▁) ▁ans ▁++ ▁; ▁} ▁i ▁++ ▁; ▁} ▁c out ▁<< ▁ans ▁<< ▁end l ▁; ▁} ▁else ▁c out ▁<< ▁" ▁- ▁1 ▁STRNEWLINE ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁) ▁( ▁( ▁) ▁" ▁; ▁count Min M oves ▁( ▁str ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁Print Stack ▁( ▁stack ▁< ▁char ▁> ▁s ▁) ▁{ ▁if ▁( ▁s ▁. ▁empty ▁( ▁) ▁) ▁return ▁; ▁char ▁x ▁= ▁s ▁. ▁top ▁( ▁) ▁; ▁s ▁. ▁pop ▁( ▁) ▁; ▁Print Stack ▁( ▁s ▁) ▁; ▁c out ▁<< ▁x ▁; ▁s ▁. ▁push ▁( ▁x ▁) ▁; ▁} ▁void ▁min String ▁( ▁string ▁s ▁) ▁{ ▁stack ▁< ▁char ▁> ▁Stack ▁; ▁Stack ▁. ▁push ▁( ▁s ▁[ ▁0 ▁] ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁s ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁Stack ▁. ▁empty ▁( ▁) ▁) ▁{ ▁Stack ▁. ▁push ▁( ▁s ▁[ ▁i ▁] ▁) ▁; ▁} ▁else ▁{ ▁if ▁( ▁Stack ▁. ▁top ▁( ▁) ▁== ▁s ▁[ ▁i ▁] ▁) ▁{ ▁Stack ▁. ▁pop ▁( ▁) ▁; ▁} ▁else ▁{ ▁Stack ▁. ▁push ▁( ▁s ▁[ ▁i ▁] ▁) ▁; ▁} ▁} ▁} ▁Print Stack ▁( ▁Stack ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁"1 0100 1" ▁; ▁min String ▁( ▁str ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁string ▁Short en String ▁( ▁string ▁str 1 ▁) ▁{ ▁stack ▁< ▁char ▁> ▁st ▁; ▁int ▁i ▁= ▁0 ▁; ▁while ▁( ▁i ▁< ▁str 1 ▁. ▁length ▁( ▁) ▁) ▁{ ▁if ▁( ▁st ▁. ▁empty ▁( ▁) ▁|| ▁str 1 ▁[ ▁i ▁] ▁!= ▁st ▁. ▁top ▁( ▁) ▁) ▁{ ▁st ▁. ▁push ▁( ▁str 1 ▁[ ▁i ▁] ▁) ▁; ▁i ▁++ ▁; ▁} ▁else ▁{ ▁st ▁. ▁pop ▁( ▁) ▁; ▁i ▁++ ▁; ▁} ▁} ▁if ▁( ▁st ▁. ▁empty ▁( ▁) ▁) ▁{ ▁return ▁( ▁" ▁Empty ▁String ▁" ▁) ▁; ▁} ▁else ▁{ ▁string ▁short _ string ▁= ▁" ▁" ▁; ▁while ▁( ▁! ▁st ▁. ▁empty ▁( ▁) ▁) ▁{ ▁short _ string ▁= ▁st ▁. ▁top ▁( ▁) ▁+ ▁short _ string ▁; ▁st ▁. ▁pop ▁( ▁) ▁; ▁} ▁return ▁( ▁short _ string ▁) ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str 1 ▁= ▁" ▁a zz x zy ▁" ▁; ▁c out ▁<< ▁Short en String ▁( ▁str 1 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print Rev ▁( ▁string ▁str ▁) ▁{ ▁stack ▁< ▁string ▁> ▁st ▁; ▁string stream ▁ss ▁( ▁str ▁) ▁; ▁string ▁temp ▁; ▁while ▁( ▁get line ▁( ▁ss ▁, ▁temp ▁, ▁' ▁' ▁) ▁) ▁{ ▁st ▁. ▁push ▁( ▁temp ▁) ▁; ▁} ▁while ▁( ▁! ▁st ▁. ▁empty ▁( ▁) ▁) ▁{ ▁c out ▁<< ▁st ▁. ▁top ▁( ▁) ▁<< ▁" ▁" ▁; ▁st ▁. ▁pop ▁( ▁) ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁; ▁str ▁= ▁" ▁g eek s ▁quiz ▁practice ▁code ▁" ▁; ▁print Rev ▁( ▁str ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max Set Bit Count ▁( ▁string ▁s ▁, ▁int ▁k ▁) ▁{ ▁int ▁max Count ▁= ▁0 ▁, ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁k ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁[ ▁i ▁] ▁== ▁'1' ▁) ▁count ▁++ ▁; ▁} ▁max Count ▁= ▁count ▁; ▁for ▁( ▁int ▁i ▁= ▁k ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁[ ▁i ▁- ▁k ▁] ▁== ▁'1' ▁) ▁count ▁-- ▁; ▁if ▁( ▁s ▁[ ▁i ▁] ▁== ▁'1' ▁) ▁count ▁++ ▁; ▁max Count ▁= ▁max ▁( ▁max Count ▁, ▁count ▁) ▁; ▁} ▁return ▁max Count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁"100 11 101 0" ▁; ▁int ▁k ▁= ▁3 ▁; ▁c out ▁<< ▁( ▁max Set Bit Count ▁( ▁s ▁, ▁k ▁) ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁check ▁( ▁string ▁s ▁) ▁{ ▁bool ▁ok ▁= ▁true ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁+ ▁1 ▁< ▁s ▁. ▁size ▁( ▁) ▁; ▁++ ▁i ▁) ▁ok ▁&= ▁( ▁abs ▁( ▁s ▁[ ▁i ▁] ▁- ▁s ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁!= ▁1 ▁) ▁; ▁return ▁ok ▁; ▁} ▁string ▁mon ot on ous String ▁( ▁string ▁s ▁) ▁{ ▁string ▁odd ▁= ▁" ▁" ▁, ▁even ▁= ▁" ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁size ▁( ▁) ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁s ▁[ ▁i ▁] ▁% ▁2 ▁== ▁0 ▁) ▁odd ▁+= ▁s ▁[ ▁i ▁] ▁; ▁else ▁even ▁+= ▁s ▁[ ▁i ▁] ▁; ▁} ▁sort ▁( ▁odd ▁. ▁begin ▁( ▁) ▁, ▁odd ▁. ▁end ▁( ▁) ▁) ▁; ▁sort ▁( ▁even ▁. ▁begin ▁( ▁) ▁, ▁even ▁. ▁end ▁( ▁) ▁) ▁; ▁if ▁( ▁check ▁( ▁odd ▁+ ▁even ▁) ▁) ▁return ▁" ▁Yes ▁" ▁; ▁else ▁if ▁( ▁check ▁( ▁even ▁+ ▁odd ▁) ▁) ▁return ▁" ▁Yes ▁" ▁; ▁return ▁" ▁No ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁abcd ▁" ▁; ▁string ▁ans ▁; ▁ans ▁= ▁mon ot on ous String ▁( ▁str ▁) ▁; ▁c out ▁<< ▁ans ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁string ▁find Str ▁( ▁string ▁S ▁) ▁{ ▁int ▁n ▁= ▁S ▁. ▁size ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁/ ▁2 ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁S ▁[ ▁i ▁] ▁!= ▁' ▁a ▁' ▁) ▁{ ▁S ▁[ ▁i ▁] ▁= ▁' ▁a ▁' ▁; ▁return ▁S ▁; ▁} ▁} ▁S ▁[ ▁n ▁- ▁1 ▁] ▁= ▁' ▁b ▁' ▁; ▁return ▁n ▁< ▁2 ▁? ▁" ▁- ▁1 ▁" ▁: ▁S ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁a ▁" ▁; ▁c out ▁<< ▁find Str ▁( ▁str ▁) ▁<< ▁end l ▁; ▁string ▁str 1 ▁= ▁" ▁ab cc ba ▁" ▁; ▁c out ▁<< ▁find Str ▁( ▁str 1 ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁convert String ▁( ▁string ▁str 1 ▁, ▁string ▁str 2 ▁, ▁string ▁str 3 ▁) ▁{ ▁map ▁< ▁char ▁, ▁int ▁> ▁freq ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁str 3 ▁[ ▁i ▁] ▁; ▁i ▁++ ▁) ▁{ ▁freq ▁[ ▁str 3 ▁[ ▁i ▁] ▁] ▁++ ▁; ▁} ▁int ▁ptr 1 ▁= ▁0 ▁; ▁int ▁ptr 2 ▁= ▁0 ▁; ▁bool ▁flag ▁= ▁true ▁; ▁while ▁( ▁ptr 1 ▁< ▁str 1 ▁. ▁length ▁( ▁) ▁&& ▁ptr 2 ▁< ▁str 2 ▁. ▁length ▁( ▁) ▁) ▁{ ▁if ▁( ▁str 1 ▁[ ▁ptr 1 ▁] ▁== ▁str 2 ▁[ ▁ptr 2 ▁] ▁) ▁{ ▁ptr 1 ▁++ ▁; ▁ptr 2 ▁++ ▁; ▁} ▁else ▁{ ▁if ▁( ▁freq ▁[ ▁str 3 ▁[ ▁ptr 2 ▁] ▁] ▁> ▁0 ▁) ▁{ ▁freq ▁[ ▁str 3 ▁[ ▁ptr 2 ▁] ▁] ▁-- ▁; ▁ptr 2 ▁++ ▁; ▁} ▁else ▁{ ▁flag ▁= ▁false ▁; ▁break ▁; ▁} ▁} ▁} ▁if ▁( ▁flag ▁&& ▁ptr 1 ▁== ▁str 1 ▁. ▁length ▁( ▁) ▁&& ▁ptr 2 ▁== ▁str 2 ▁. ▁length ▁( ▁) ▁) ▁{ ▁c out ▁<< ▁" ▁YES ▁" ▁<< ▁end l ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁" ▁NO ▁" ▁<< ▁end l ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str 1 ▁= ▁" ▁ab yz fe ▁" ▁; ▁string ▁str 2 ▁= ▁" ▁abcd ey z f ▁" ▁; ▁string ▁str 3 ▁= ▁" ▁pop ode ▁" ▁; ▁convert String ▁( ▁str 1 ▁, ▁str 2 ▁, ▁str 3 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁# include ▁< set > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁distinct ▁( ▁string ▁S ▁[ ▁] ▁, ▁int ▁M ▁, ▁int ▁n ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁set ▁< ▁char ▁> ▁set 1 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁S ▁[ ▁i ▁] ▁. ▁length ▁( ▁) ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁set 1 ▁. ▁find ▁( ▁S ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁== ▁set 1 ▁. ▁end ▁( ▁) ▁) ▁set 1 ▁. ▁insert ▁( ▁S ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁; ▁} ▁int ▁c ▁= ▁set 1 ▁. ▁size ▁( ▁) ▁; ▁if ▁( ▁c ▁<= ▁M ▁) ▁count ▁+= ▁1 ▁; ▁} ▁c out ▁<< ▁( ▁count ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁S ▁[ ▁] ▁= ▁{ ▁" ▁H ER BI VO RES ▁" ▁, ▁" ▁A ER OP LA NE ▁" ▁, ▁" ▁G EEK S FOR GE EK S ▁" ▁} ▁; ▁int ▁M ▁= ▁7 ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁S ▁) ▁/ ▁sizeof ▁( ▁S ▁[ ▁0 ▁] ▁) ▁; ▁distinct ▁( ▁S ▁, ▁M ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁String ▁( ▁int ▁l ▁, ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁int ▁p ▁= ▁97 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁l ▁; ▁j ▁++ ▁) ▁{ ▁char ▁ans ▁= ▁( ▁char ▁) ▁( ▁p ▁+ ▁( ▁j ▁% ▁y ▁) ▁) ▁; ▁c out ▁<< ▁ans ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁l ▁= ▁6 ▁; ▁int ▁x ▁= ▁5 ▁; ▁int ▁y ▁= ▁3 ▁; ▁String ▁( ▁l ▁, ▁x ▁, ▁y ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find Period ic String ▁( ▁string ▁S ▁) ▁{ ▁int ▁l ▁= ▁2 ▁* ▁S ▁. ▁length ▁( ▁) ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁S ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁S ▁[ ▁i ▁] ▁== ▁'1' ▁) ▁count ▁++ ▁; ▁} ▁if ▁( ▁count ▁== ▁S ▁. ▁length ▁( ▁) ▁count ▁== ▁0 ▁) ▁c out ▁<< ▁S ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁else ▁{ ▁char ▁arr ▁[ ▁l ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁l ▁; ▁i ▁+= ▁2 ▁) ▁{ ▁arr ▁[ ▁i ▁] ▁= ▁'1' ▁; ▁arr ▁[ ▁i ▁+ ▁1 ▁] ▁= ▁'0' ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁l ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁; ▁c out ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁S ▁= ▁" 1111 00 1" ▁; ▁find Period ic String ▁( ▁S ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁group _ formed ▁( ▁string ▁S ▁) ▁{ ▁int ▁count ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁S ▁. ▁size ▁( ▁) ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁S ▁[ ▁i ▁] ▁!= ▁S ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁count ▁+= ▁1 ▁; ▁} ▁c out ▁<< ▁( ▁count ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁S ▁= ▁" ▁TT WW W ▁" ▁; ▁group _ formed ▁( ▁S ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁string ▁Reverse Com plement ▁( ▁string ▁s ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁rev ▁= ▁( ▁k ▁+ ▁1 ▁) ▁/ ▁2 ▁; ▁int ▁complement ▁= ▁k ▁- ▁rev ▁; ▁if ▁( ▁rev ▁% ▁2 ▁) ▁reverse ▁( ▁s ▁. ▁begin ▁( ▁) ▁, ▁s ▁. ▁end ▁( ▁) ▁) ▁; ▁if ▁( ▁complement ▁% ▁2 ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁[ ▁i ▁] ▁== ▁'0' ▁) ▁s ▁[ ▁i ▁] ▁= ▁'1' ▁; ▁else ▁s ▁[ ▁i ▁] ▁= ▁'0' ▁; ▁} ▁} ▁return ▁s ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁"100 11" ▁; ▁int ▁k ▁= ▁5 ▁; ▁int ▁n ▁= ▁str ▁. ▁size ▁( ▁) ▁; ▁c out ▁<< ▁Reverse Com plement ▁( ▁str ▁, ▁n ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁repeating String ▁( ▁string ▁s ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁if ▁( ▁n ▁% ▁k ▁!= ▁0 ▁) ▁{ ▁return ▁false ▁; ▁} ▁int ▁frequency ▁[ ▁123 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁123 ▁; ▁i ▁++ ▁) ▁{ ▁frequency ▁[ ▁i ▁] ▁= ▁0 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁frequency ▁[ ▁s ▁[ ▁i ▁] ▁] ▁++ ▁; ▁} ▁int ▁repeat ▁= ▁n ▁/ ▁k ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁123 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁frequency ▁[ ▁i ▁] ▁% ▁repeat ▁!= ▁0 ▁) ▁{ ▁return ▁false ▁; ▁} ▁} ▁return ▁true ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁" ▁abcd cb a ▁" ▁; ▁int ▁n ▁= ▁s ▁. ▁size ▁( ▁) ▁; ▁int ▁k ▁= ▁3 ▁; ▁if ▁( ▁repeating String ▁( ▁s ▁, ▁n ▁, ▁k ▁) ▁) ▁{ ▁c out ▁<< ▁" ▁Yes ▁" ▁<< ▁end l ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁" ▁No ▁" ▁<< ▁end l ▁; ▁} ▁return ▁0 ▁; ▁}
▁# include ▁" ▁bits ▁/ ▁std c ▁+ ▁+ ▁. ▁h ▁" ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print Value ▁( ▁char ▁digit ▁) ▁{ ▁switch ▁( ▁digit ▁) ▁{ ▁case ▁'0' ▁: ▁c out ▁<< ▁" ▁Zero ▁" ▁; ▁break ▁; ▁case ▁'1' ▁: ▁c out ▁<< ▁" ▁One ▁" ▁; ▁break ▁; ▁case ▁'2' ▁: ▁c out ▁<< ▁" ▁Two ▁" ▁; ▁break ▁; ▁case ▁'3' ▁: ▁c out ▁<< ▁" ▁Three ▁" ▁; ▁break ▁; ▁case ▁'4' ▁: ▁c out ▁<< ▁" ▁Four ▁" ▁; ▁break ▁; ▁case ▁'5' ▁: ▁c out ▁<< ▁" ▁F ive ▁" ▁; ▁break ▁; ▁case ▁'6' ▁: ▁c out ▁<< ▁" ▁S ix ▁" ▁; ▁break ▁; ▁case ▁'7' ▁: ▁c out ▁<< ▁" ▁S even ▁" ▁; ▁break ▁; ▁case ▁'8' ▁: ▁c out ▁<< ▁" ▁E ight ▁" ▁; ▁break ▁; ▁case ▁'9' ▁: ▁c out ▁<< ▁" ▁N ine ▁" ▁; ▁break ▁; ▁} ▁} ▁void ▁print Word ▁( ▁string ▁N ▁) ▁{ ▁int ▁i ▁, ▁length ▁= ▁N ▁. ▁length ▁( ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁length ▁; ▁i ▁++ ▁) ▁{ ▁print Value ▁( ▁N ▁[ ▁i ▁] ▁) ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁N ▁= ▁"123" ▁; ▁print Word ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁double ▁jar o _ distance ▁( ▁string ▁s 1 ▁, ▁string ▁s 2 ▁) ▁{ ▁if ▁( ▁s 1 ▁== ▁s 2 ▁) ▁return ▁1.0 ▁; ▁int ▁len 1 ▁= ▁s 1 ▁. ▁length ▁( ▁) ▁, ▁len 2 ▁= ▁s 2 ▁. ▁length ▁( ▁) ▁; ▁int ▁max _ dist ▁= ▁floor ▁( ▁max ▁( ▁len 1 ▁, ▁len 2 ▁) ▁/ ▁2 ▁) ▁- ▁1 ▁; ▁int ▁match ▁= ▁0 ▁; ▁int ▁hash _ s 1 ▁[ ▁s 1 ▁. ▁length ▁( ▁) ▁] ▁= ▁{ ▁0 ▁} ▁, ▁hash _ s 2 ▁[ ▁s 2 ▁. ▁length ▁( ▁) ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁len 1 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁max ▁( ▁0 ▁, ▁i ▁- ▁max _ dist ▁) ▁; ▁j ▁< ▁min ▁( ▁len 2 ▁, ▁i ▁+ ▁max _ dist ▁+ ▁1 ▁) ▁; ▁j ▁++ ▁) ▁if ▁( ▁s 1 ▁[ ▁i ▁] ▁== ▁s 2 ▁[ ▁j ▁] ▁&& ▁hash _ s 2 ▁[ ▁j ▁] ▁== ▁0 ▁) ▁{ ▁hash _ s 1 ▁[ ▁i ▁] ▁= ▁1 ▁; ▁hash _ s 2 ▁[ ▁j ▁] ▁= ▁1 ▁; ▁match ▁++ ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁match ▁== ▁0 ▁) ▁return ▁0.0 ▁; ▁double ▁t ▁= ▁0 ▁; ▁int ▁point ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁len 1 ▁; ▁i ▁++ ▁) ▁if ▁( ▁hash _ s 1 ▁[ ▁i ▁] ▁) ▁{ ▁while ▁( ▁hash _ s 2 ▁[ ▁point ▁] ▁== ▁0 ▁) ▁point ▁++ ▁; ▁if ▁( ▁s 1 ▁[ ▁i ▁] ▁!= ▁s 2 ▁[ ▁point ▁++ ▁] ▁) ▁t ▁++ ▁; ▁} ▁t ▁/= ▁2 ▁; ▁return ▁( ▁( ▁( ▁double ▁) ▁match ▁) ▁/ ▁( ▁( ▁double ▁) ▁len 1 ▁) ▁+ ▁( ▁( ▁double ▁) ▁match ▁) ▁/ ▁( ▁( ▁double ▁) ▁len 2 ▁) ▁+ ▁( ▁( ▁double ▁) ▁match ▁- ▁t ▁) ▁/ ▁( ▁( ▁double ▁) ▁match ▁) ▁) ▁/ ▁3.0 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s 1 ▁= ▁" ▁CR ATE ▁" ▁, ▁s 2 ▁= ▁" ▁TRACE ▁" ▁; ▁c out ▁<< ▁jar o _ distance ▁( ▁s 1 ▁, ▁s 2 ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Min Sw aps ▁( ▁string ▁s ▁, ▁int ▁k ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁int ▁c _ one ▁= ▁0 ▁, ▁c _ zero ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁s ▁. ▁size ▁( ▁) ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁s ▁[ ▁i ▁] ▁== ▁'1' ▁) ▁c _ one ▁++ ▁; ▁if ▁( ▁s ▁[ ▁i ▁] ▁== ▁'0' ▁) ▁c _ zero ▁++ ▁, ▁ans ▁+= ▁c _ one ▁; ▁if ▁( ▁c _ zero ▁== ▁k ▁) ▁break ▁; ▁} ▁if ▁( ▁c _ zero ▁< ▁k ▁) ▁return ▁-1 ▁; ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁"100 11 1" ▁; ▁int ▁k ▁= ▁2 ▁; ▁c out ▁<< ▁find Min Sw aps ▁( ▁s ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁struct ▁Node ▁{ ▁char ▁data ▁; ▁Node ▁* ▁left ▁, ▁* ▁right ▁; ▁Node ▁( ▁char ▁_ val ▁) ▁{ ▁data ▁= ▁_ val ▁; ▁left ▁= ▁right ▁= ▁NULL ▁; ▁} ▁} ▁; ▁Node ▁* ▁add in BT ▁( ▁Node ▁* ▁root ▁, ▁char ▁data ▁) ▁{ ▁if ▁( ▁root ▁== ▁NULL ▁) ▁{ ▁root ▁= ▁new ▁Node ▁( ▁data ▁) ▁; ▁} ▁else ▁{ ▁queue ▁< ▁Node ▁* ▁> ▁Q ▁; ▁Q ▁. ▁push ▁( ▁root ▁) ▁; ▁while ▁( ▁! ▁Q ▁. ▁empty ▁( ▁) ▁) ▁{ ▁Node ▁* ▁temp ▁= ▁Q ▁. ▁front ▁( ▁) ▁; ▁Q ▁. ▁pop ▁( ▁) ▁; ▁if ▁( ▁temp ▁-> ▁left ▁== ▁NULL ▁) ▁{ ▁temp ▁-> ▁left ▁= ▁new ▁Node ▁( ▁data ▁) ▁; ▁break ▁; ▁} ▁else ▁Q ▁. ▁push ▁( ▁temp ▁-> ▁left ▁) ▁; ▁if ▁( ▁temp ▁-> ▁right ▁== ▁NULL ▁) ▁{ ▁temp ▁-> ▁right ▁= ▁new ▁Node ▁( ▁data ▁) ▁; ▁break ▁; ▁} ▁else ▁Q ▁. ▁push ▁( ▁temp ▁-> ▁right ▁) ▁; ▁} ▁} ▁return ▁root ▁; ▁} ▁void ▁print ▁( ▁Node ▁* ▁root ▁) ▁{ ▁queue ▁< ▁Node ▁* ▁> ▁Q ▁; ▁Q ▁. ▁push ▁( ▁root ▁) ▁; ▁while ▁( ▁Q ▁. ▁size ▁( ▁) ▁) ▁{ ▁Node ▁* ▁temp ▁= ▁Q ▁. ▁front ▁( ▁) ▁; ▁Q ▁. ▁pop ▁( ▁) ▁; ▁c out ▁<< ▁temp ▁-> ▁data ▁; ▁if ▁( ▁temp ▁-> ▁left ▁) ▁Q ▁. ▁push ▁( ▁temp ▁-> ▁left ▁) ▁; ▁if ▁( ▁temp ▁-> ▁right ▁) ▁Q ▁. ▁push ▁( ▁temp ▁-> ▁right ▁) ▁; ▁} ▁} ▁bool ▁check v ow el ▁( ▁char ▁ch ▁) ▁{ ▁ch ▁= ▁to lower ▁( ▁ch ▁) ▁; ▁if ▁( ▁ch ▁== ▁' ▁a ▁' ▁ch ▁== ▁' ▁e ▁' ▁ch ▁== ▁' ▁i ▁' ▁ch ▁== ▁' ▁o ▁' ▁ch ▁== ▁' ▁u ▁' ▁) ▁{ ▁return ▁true ▁; ▁} ▁else ▁{ ▁return ▁false ▁; ▁} ▁} ▁Node ▁* ▁remove v ow els ▁( ▁Node ▁* ▁root ▁) ▁{ ▁queue ▁< ▁Node ▁* ▁> ▁Q ▁; ▁Q ▁. ▁push ▁( ▁root ▁) ▁; ▁Node ▁* ▁root 1 ▁= ▁NULL ▁; ▁while ▁( ▁! ▁Q ▁. ▁empty ▁( ▁) ▁) ▁{ ▁Node ▁* ▁temp ▁= ▁Q ▁. ▁front ▁( ▁) ▁; ▁Q ▁. ▁pop ▁( ▁) ▁; ▁if ▁( ▁! ▁check v ow el ▁( ▁temp ▁-> ▁data ▁) ▁) ▁{ ▁root 1 ▁= ▁add in BT ▁( ▁root 1 ▁, ▁temp ▁-> ▁data ▁) ▁; ▁} ▁if ▁( ▁temp ▁-> ▁left ▁) ▁{ ▁Q ▁. ▁push ▁( ▁temp ▁-> ▁left ▁) ▁; ▁} ▁if ▁( ▁temp ▁-> ▁right ▁) ▁{ ▁Q ▁. ▁push ▁( ▁temp ▁-> ▁right ▁) ▁; ▁} ▁} ▁return ▁root 1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁" ▁g eek s ▁" ▁; ▁Node ▁* ▁root ▁= ▁NULL ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁root ▁= ▁add in BT ▁( ▁root ▁, ▁s ▁[ ▁i ▁] ▁) ▁; ▁} ▁root ▁= ▁remove v ow els ▁( ▁root ▁) ▁; ▁print ▁( ▁root ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁N ▁2 ▁NEW _ LINE ▁bool ▁is V ow el ▁( ▁char ▁ch ▁) ▁{ ▁return ▁( ▁ch ▁== ▁' ▁a ▁' ▁ch ▁== ▁' ▁e ▁' ▁ch ▁== ▁' ▁i ▁' ▁ch ▁== ▁' ▁o ▁' ▁ch ▁== ▁' ▁u ▁' ▁) ▁; ▁} ▁void ▁perform Queries ▁( ▁string ▁str ▁, ▁int ▁len ▁, ▁int ▁queries ▁[ ▁] ▁[ ▁N ▁] ▁, ▁int ▁q ▁) ▁{ ▁int ▁pre ▁[ ▁len ▁] ▁; ▁if ▁( ▁is V ow el ▁( ▁str ▁[ ▁0 ▁] ▁) ▁) ▁pre ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁else ▁pre ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁len ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁is V ow el ▁( ▁str ▁[ ▁i ▁] ▁) ▁) ▁pre ▁[ ▁i ▁] ▁= ▁1 ▁+ ▁pre ▁[ ▁i ▁- ▁1 ▁] ▁; ▁else ▁pre ▁[ ▁i ▁] ▁= ▁pre ▁[ ▁i ▁- ▁1 ▁] ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁q ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁queries ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁== ▁0 ▁) ▁{ ▁c out ▁<< ▁pre ▁[ ▁queries ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁] ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁( ▁pre ▁[ ▁queries ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁] ▁- ▁pre ▁[ ▁queries ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁- ▁1 ▁] ▁) ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁} ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁g eek s forge ek s ▁" ▁; ▁int ▁len ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁int ▁queries ▁[ ▁] ▁[ ▁N ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁3 ▁} ▁, ▁{ ▁2 ▁, ▁4 ▁} ▁, ▁{ ▁1 ▁, ▁9 ▁} ▁} ▁; ▁int ▁q ▁= ▁( ▁sizeof ▁( ▁queries ▁) ▁/ ▁sizeof ▁( ▁queries ▁[ ▁0 ▁] ▁) ▁) ▁; ▁perform Queries ▁( ▁str ▁, ▁len ▁, ▁queries ▁, ▁q ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁max N ▁20 ▁NEW _ LINE ▁# define ▁max M ▁64 ▁NEW _ LINE ▁int ▁cnt Splits ▁( ▁string ▁s ▁) ▁{ ▁if ▁( ▁s ▁[ ▁s ▁. ▁size ▁( ▁) ▁- ▁1 ▁] ▁== ▁'1' ▁) ▁return ▁0 ▁; ▁int ▁c _ zero ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁c _ zero ▁+= ▁( ▁s ▁[ ▁i ▁] ▁== ▁'0' ▁) ▁; ▁return ▁( ▁int ▁) ▁pow ▁( ▁2 ▁, ▁c _ zero ▁- ▁1 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁"100 10" ▁; ▁c out ▁<< ▁cnt Splits ▁( ▁s ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁string ▁dec To Binary ▁( ▁int ▁n ▁) ▁{ ▁int ▁binary Num ▁[ ▁32 ▁] ▁; ▁int ▁i ▁= ▁0 ▁; ▁while ▁( ▁n ▁> ▁0 ▁) ▁{ ▁binary Num ▁[ ▁i ▁] ▁= ▁n ▁% ▁2 ▁; ▁n ▁= ▁n ▁/ ▁2 ▁; ▁i ▁++ ▁; ▁} ▁string ▁binary ▁= ▁" ▁" ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁- ▁1 ▁; ▁j ▁>= ▁0 ▁; ▁j ▁-- ▁) ▁binary ▁+= ▁to _ string ▁( ▁binary Num ▁[ ▁j ▁] ▁) ▁; ▁return ▁binary ▁; ▁} ▁int ▁count Freq ▁( ▁string ▁& ▁pat ▁, ▁string ▁& ▁txt ▁) ▁{ ▁int ▁M ▁= ▁pat ▁. ▁length ▁( ▁) ▁; ▁int ▁N ▁= ▁txt ▁. ▁length ▁( ▁) ▁; ▁int ▁res ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁N ▁- ▁M ▁; ▁i ▁++ ▁) ▁{ ▁int ▁j ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁M ▁; ▁j ▁++ ▁) ▁if ▁( ▁txt ▁[ ▁i ▁+ ▁j ▁] ▁!= ▁pat ▁[ ▁j ▁] ▁) ▁break ▁; ▁if ▁( ▁j ▁== ▁M ▁) ▁{ ▁res ▁++ ▁; ▁j ▁= ▁0 ▁; ▁} ▁} ▁return ▁res ▁; ▁} ▁void ▁find Occurrence ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁string ▁pattern ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁string ▁binary ▁= ▁dec To Binary ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁c out ▁<< ▁count Freq ▁( ▁pattern ▁, ▁binary ▁) ▁<< ▁" ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁106 ▁, ▁7 ▁, ▁8 ▁} ▁; ▁string ▁pattern ▁= ▁"10" ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁find Occurrence ▁( ▁arr ▁, ▁n ▁, ▁pattern ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find _ w inner ▁( ▁string ▁str ▁, ▁int ▁n ▁) ▁{ ▁string ▁str 1 ▁= ▁" ▁" ▁, ▁str 2 ▁= ▁" ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁str 1 ▁+= ▁str ▁[ ▁i ▁] ▁; ▁} ▁else ▁{ ▁str 2 ▁+= ▁str ▁[ ▁i ▁] ▁; ▁} ▁} ▁sort ▁( ▁str 1 ▁. ▁begin ▁( ▁) ▁, ▁str 1 ▁. ▁end ▁( ▁) ▁) ▁; ▁sort ▁( ▁str 2 ▁. ▁begin ▁( ▁) ▁, ▁str 2 ▁. ▁end ▁( ▁) ▁) ▁; ▁if ▁( ▁str 1 ▁< ▁str 2 ▁) ▁c out ▁<< ▁" ▁A ▁" ▁; ▁else ▁if ▁( ▁str 2 ▁< ▁str 1 ▁) ▁c out ▁<< ▁" ▁B ▁" ▁; ▁else ▁c out ▁<< ▁" ▁T ie ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁g eek s forge ek s ▁" ▁; ▁int ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁find _ w inner ▁( ▁str ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is V ow el ▁( ▁char ▁ch ▁) ▁{ ▁ch ▁= ▁t ou pper ▁( ▁ch ▁) ▁; ▁return ▁( ▁ch ▁== ▁' ▁A ▁' ▁ch ▁== ▁' ▁E ▁' ▁ch ▁== ▁' ▁I ▁' ▁ch ▁== ▁' ▁O ▁' ▁ch ▁== ▁' ▁U ▁' ▁) ▁; ▁} ▁string ▁duplicate V ow els ▁( ▁string ▁str ▁) ▁{ ▁int ▁t ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁string ▁res ▁= ▁" ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁t ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁is V ow el ▁( ▁str ▁[ ▁i ▁] ▁) ▁) ▁{ ▁res ▁+= ▁str ▁[ ▁i ▁] ▁; ▁} ▁res ▁+= ▁str ▁[ ▁i ▁] ▁; ▁} ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁hel loworld ▁" ▁; ▁c out ▁<< ▁" ▁Original ▁String ▁: ▁" ▁<< ▁str ▁<< ▁end l ▁; ▁string ▁res ▁= ▁duplicate V ow els ▁( ▁str ▁) ▁; ▁c out ▁<< ▁" ▁String ▁with ▁V ow els ▁duplicated ▁: ▁" ▁<< ▁res ▁<< ▁end l ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁string ▁replace Pi ▁( ▁string ▁s ▁) ▁{ ▁if ▁( ▁s ▁. ▁length ▁( ▁) ▁== ▁0 ▁|| ▁s ▁. ▁length ▁( ▁) ▁== ▁1 ▁) ▁return ▁s ▁; ▁if ▁( ▁s ▁[ ▁0 ▁] ▁== ▁' ▁p ▁' ▁&& ▁s ▁[ ▁1 ▁] ▁== ▁' ▁i ▁' ▁) ▁{ ▁string ▁small Output ▁= ▁replace Pi ▁( ▁s ▁. ▁substr ▁( ▁2 ▁) ▁) ▁; ▁return ▁" 3.1 4" ▁+ ▁small Output ▁; ▁} ▁else ▁{ ▁return ▁s ▁[ ▁0 ▁] ▁+ ▁replace Pi ▁( ▁s ▁. ▁substr ▁( ▁1 ▁) ▁) ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁" ▁pi pp pi i ip i ▁" ▁; ▁string ▁result ▁= ▁replace Pi ▁( ▁s ▁) ▁; ▁c out ▁<< ▁result ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁MAX ▁26 ▁NEW _ LINE ▁int ▁largest Sub Seq ▁( ▁string ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁count ▁[ ▁MAX ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁string ▁str ▁= ▁arr ▁[ ▁i ▁] ▁; ▁bool ▁hash ▁[ ▁MAX ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁str ▁. ▁length ▁( ▁) ▁; ▁j ▁++ ▁) ▁{ ▁hash ▁[ ▁str ▁[ ▁j ▁] ▁- ▁' ▁a ▁' ▁] ▁= ▁true ▁; ▁} ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁MAX ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁hash ▁[ ▁j ▁] ▁) ▁count ▁[ ▁j ▁] ▁++ ▁; ▁} ▁} ▁return ▁* ▁( ▁max _ element ▁( ▁count ▁, ▁count ▁+ ▁MAX ▁) ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁arr ▁[ ▁] ▁= ▁{ ▁" ▁ab ▁" ▁, ▁" ▁bc ▁" ▁, ▁" ▁de ▁" ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁string ▁) ▁; ▁c out ▁<< ▁largest Sub Seq ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁set ▁< ▁string ▁> ▁string Set ▁; ▁void ▁find _ perm utation ▁( ▁string ▁& ▁str 1 ▁, ▁string ▁& ▁str 2 ▁, ▁int ▁len 1 ▁, ▁int ▁len 2 ▁, ▁int ▁i ▁, ▁int ▁j ▁, ▁string ▁res ▁) ▁{ ▁if ▁( ▁res ▁. ▁length ▁( ▁) ▁== ▁len 1 ▁+ ▁len 2 ▁) ▁{ ▁string Set ▁. ▁insert ▁( ▁res ▁) ▁; ▁return ▁; ▁} ▁if ▁( ▁i ▁< ▁len 1 ▁) ▁find _ perm utation ▁( ▁str 1 ▁, ▁str 2 ▁, ▁len 1 ▁, ▁len 2 ▁, ▁i ▁+ ▁1 ▁, ▁j ▁, ▁res ▁+ ▁str 1 ▁[ ▁i ▁] ▁) ▁; ▁if ▁( ▁j ▁< ▁len 2 ▁) ▁find _ perm utation ▁( ▁str 1 ▁, ▁str 2 ▁, ▁len 1 ▁, ▁len 2 ▁, ▁i ▁, ▁j ▁+ ▁1 ▁, ▁res ▁+ ▁str 2 ▁[ ▁j ▁] ▁) ▁; ▁} ▁void ▁print _ set ▁( ▁) ▁{ ▁set ▁< ▁string ▁> ▁:: ▁iterator ▁itr ▁; ▁for ▁( ▁itr ▁= ▁string Set ▁. ▁begin ▁( ▁) ▁; ▁itr ▁!= ▁string Set ▁. ▁end ▁( ▁) ▁; ▁itr ▁++ ▁) ▁c out ▁<< ▁( ▁* ▁itr ▁) ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str 1 ▁= ▁" ▁aa ▁" ▁, ▁str 2 ▁= ▁" ▁ab ▁" ▁; ▁int ▁len 1 ▁= ▁str 1 ▁. ▁length ▁( ▁) ▁; ▁int ▁len 2 ▁= ▁str 2 ▁. ▁length ▁( ▁) ▁; ▁find _ perm utation ▁( ▁str 1 ▁, ▁str 2 ▁, ▁len 1 ▁, ▁len 2 ▁, ▁0 ▁, ▁0 ▁, ▁" ▁" ▁) ▁; ▁print _ set ▁( ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Sub Str ▁( ▁string ▁s ▁, ▁int ▁n ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁2 ▁; ▁) ▁{ ▁if ▁( ▁s ▁[ ▁i ▁] ▁== ▁'0' ▁&& ▁s ▁[ ▁i ▁+ ▁1 ▁] ▁== ▁'1' ▁&& ▁s ▁[ ▁i ▁+ ▁2 ▁] ▁== ▁'0' ▁) ▁{ ▁count ▁++ ▁; ▁i ▁+= ▁3 ▁; ▁} ▁else ▁if ▁( ▁s ▁[ ▁i ▁] ▁== ▁'1' ▁&& ▁s ▁[ ▁i ▁+ ▁1 ▁] ▁== ▁'0' ▁&& ▁s ▁[ ▁i ▁+ ▁2 ▁] ▁== ▁'1' ▁) ▁{ ▁count ▁++ ▁; ▁i ▁+= ▁3 ▁; ▁} ▁else ▁{ ▁i ▁++ ▁; ▁} ▁} ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁"1 0101 0101 01" ▁; ▁int ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁c out ▁<< ▁count Sub Str ▁( ▁s ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Total Distinct ▁( ▁string ▁str ▁) ▁{ ▁int ▁cnt ▁= ▁0 ▁; ▁set ▁< ▁string ▁> ▁items ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁str ▁. ▁length ▁( ▁) ▁; ▁++ ▁i ▁) ▁{ ▁string ▁temp ▁= ▁" ▁" ▁; ▁set ▁< ▁char ▁> ▁ans ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁< ▁str ▁. ▁length ▁( ▁) ▁; ▁++ ▁j ▁) ▁{ ▁temp ▁= ▁temp ▁+ ▁str ▁[ ▁j ▁] ▁; ▁ans ▁. ▁insert ▁( ▁str ▁[ ▁j ▁] ▁) ▁; ▁if ▁( ▁items ▁. ▁find ▁( ▁temp ▁) ▁== ▁items ▁. ▁end ▁( ▁) ▁) ▁{ ▁items ▁. ▁insert ▁( ▁temp ▁) ▁; ▁cnt ▁+= ▁ans ▁. ▁size ▁( ▁) ▁; ▁} ▁} ▁} ▁return ▁cnt ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁AB CA ▁" ▁; ▁c out ▁<< ▁count Total Distinct ▁( ▁str ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁reverse ▁( ▁char ▁k ▁[ ▁] ▁) ▁{ ▁stack ▁< ▁char ▁* ▁> ▁s ▁; ▁char ▁* ▁token ▁= ▁str tok ▁( ▁k ▁, ▁" ▁" ▁) ▁; ▁while ▁( ▁token ▁!= ▁NULL ▁) ▁{ ▁s ▁. ▁push ▁( ▁token ▁) ▁; ▁token ▁= ▁str tok ▁( ▁NULL ▁, ▁" ▁" ▁) ▁; ▁} ▁while ▁( ▁! ▁s ▁. ▁empty ▁( ▁) ▁) ▁{ ▁c out ▁<< ▁s ▁. ▁top ▁( ▁) ▁<< ▁" ▁" ▁; ▁s ▁. ▁pop ▁( ▁) ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁char ▁k ▁[ ▁] ▁= ▁" ▁g eek s ▁for ▁g eek s ▁" ▁; ▁reverse ▁( ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁isP al in ▁( ▁int ▁i ▁, ▁int ▁j ▁, ▁int ▁k ▁, ▁int ▁l ▁, ▁int ▁p ▁, ▁int ▁q ▁, ▁string ▁s ▁) ▁{ ▁int ▁start ▁= ▁i ▁, ▁end ▁= ▁q ▁; ▁while ▁( ▁start ▁< ▁end ▁) ▁{ ▁if ▁( ▁s ▁[ ▁start ▁] ▁!= ▁s ▁[ ▁end ▁] ▁) ▁return ▁false ▁; ▁start ▁++ ▁; ▁if ▁( ▁start ▁== ▁j ▁+ ▁1 ▁) ▁start ▁= ▁k ▁; ▁end ▁-- ▁; ▁if ▁( ▁end ▁== ▁p ▁- ▁1 ▁) ▁end ▁= ▁l ▁; ▁} ▁return ▁true ▁; ▁} ▁int ▁count Sub Str ▁( ▁string ▁s ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁int ▁n ▁= ▁s ▁. ▁size ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁< ▁n ▁- ▁2 ▁; ▁j ▁++ ▁) ▁{ ▁for ▁( ▁int ▁k ▁= ▁j ▁+ ▁1 ▁; ▁k ▁< ▁n ▁- ▁1 ▁; ▁k ▁++ ▁) ▁{ ▁for ▁( ▁int ▁l ▁= ▁k ▁; ▁l ▁< ▁n ▁- ▁1 ▁; ▁l ▁++ ▁) ▁{ ▁for ▁( ▁int ▁p ▁= ▁l ▁+ ▁1 ▁; ▁p ▁< ▁n ▁; ▁p ▁++ ▁) ▁{ ▁for ▁( ▁int ▁q ▁= ▁p ▁; ▁q ▁< ▁n ▁; ▁q ▁++ ▁) ▁{ ▁if ▁( ▁isP al in ▁( ▁i ▁, ▁j ▁, ▁k ▁, ▁l ▁, ▁p ▁, ▁q ▁, ▁s ▁) ▁) ▁{ ▁count ▁++ ▁; ▁} ▁} ▁} ▁} ▁} ▁} ▁} ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁" ▁ab ca ▁" ▁; ▁c out ▁<< ▁count Sub Str ▁( ▁s ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁int ▁MAX ▁= ▁256 ▁; ▁static ▁string ▁last Non Repe ating ▁( ▁string ▁str ▁, ▁int ▁n ▁) ▁{ ▁int ▁freq ▁[ ▁MAX ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁freq ▁[ ▁str ▁. ▁at ▁( ▁i ▁) ▁] ▁++ ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁char ▁ch ▁= ▁str ▁. ▁at ▁( ▁i ▁) ▁; ▁if ▁( ▁freq ▁[ ▁ch ▁] ▁== ▁1 ▁) ▁{ ▁string ▁res ▁; ▁res ▁+= ▁ch ▁; ▁return ▁res ▁; ▁} ▁} ▁return ▁" ▁- ▁1" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁G eek s For G eek s ▁" ▁; ▁int ▁n ▁= ▁str ▁. ▁size ▁( ▁) ▁; ▁c out ▁<< ▁last Non Repe ating ▁( ▁str ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁N ▁4 ▁NEW _ LINE ▁int ▁perform Queries ▁( ▁int ▁l ▁, ▁int ▁r ▁, ▁int ▁prefix ▁[ ▁N ▁] ▁[ ▁26 ▁] ▁) ▁{ ▁l ▁-- ▁; ▁r ▁-- ▁; ▁bool ▁flag ▁= ▁false ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁26 ▁; ▁i ▁++ ▁) ▁{ ▁int ▁cnt ▁= ▁prefix ▁[ ▁r ▁] ▁[ ▁i ▁] ▁; ▁if ▁( ▁l ▁> ▁0 ▁) ▁cnt ▁-= ▁prefix ▁[ ▁l ▁- ▁1 ▁] ▁[ ▁i ▁] ▁; ▁if ▁( ▁cnt ▁% ▁2 ▁== ▁1 ▁) ▁{ ▁flag ▁= ▁true ▁; ▁count ▁+= ▁cnt ▁- ▁1 ▁; ▁} ▁else ▁count ▁+= ▁cnt ▁; ▁} ▁if ▁( ▁flag ▁) ▁count ▁+= ▁1 ▁; ▁return ▁count ▁; ▁} ▁void ▁pre Calculate ▁( ▁string ▁s ▁, ▁int ▁prefix ▁[ ▁N ▁] ▁[ ▁26 ▁] ▁) ▁{ ▁int ▁n ▁= ▁s ▁. ▁size ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁prefix ▁[ ▁i ▁] ▁[ ▁s ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁26 ▁; ▁j ▁++ ▁) ▁prefix ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+= ▁prefix ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁" ▁am im ▁" ▁; ▁int ▁prefix ▁[ ▁N ▁] ▁[ ▁26 ▁] ▁; ▁mem set ▁( ▁prefix ▁, ▁0 ▁, ▁sizeof ▁prefix ▁) ▁; ▁pre Calculate ▁( ▁s ▁, ▁prefix ▁) ▁; ▁int ▁queries ▁[ ▁] ▁[ ▁2 ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁4 ▁} ▁, ▁{ ▁3 ▁, ▁4 ▁} ▁} ▁; ▁int ▁q ▁= ▁sizeof ▁( ▁queries ▁) ▁/ ▁sizeof ▁( ▁queries ▁[ ▁0 ▁] ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁q ▁; ▁i ▁++ ▁) ▁{ ▁c out ▁<< ▁perform Queries ▁( ▁queries ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁, ▁queries ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁, ▁prefix ▁) ▁<< ▁end l ▁; ▁} ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁string ▁First And Last ▁( ▁string ▁str ▁) ▁{ ▁string ▁ch ▁= ▁str ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁ch ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁int ▁k ▁= ▁i ▁; ▁while ▁( ▁i ▁< ▁ch ▁. ▁length ▁( ▁) ▁&& ▁ch ▁[ ▁i ▁] ▁!= ▁' ▁' ▁) ▁i ▁++ ▁; ▁ch ▁[ ▁k ▁] ▁= ▁( ▁char ▁) ▁( ▁ch ▁[ ▁k ▁] ▁>= ▁' ▁a ▁' ▁&& ▁ch ▁[ ▁k ▁] ▁<= ▁' ▁z ▁' ▁? ▁( ▁( ▁int ▁) ▁ch ▁[ ▁k ▁] ▁- ▁32 ▁) ▁: ▁( ▁int ▁) ▁ch ▁[ ▁k ▁] ▁) ▁; ▁ch ▁[ ▁i ▁- ▁1 ▁] ▁= ▁( ▁char ▁) ▁( ▁ch ▁[ ▁i ▁- ▁1 ▁] ▁>= ▁' ▁a ▁' ▁&& ▁ch ▁[ ▁i ▁- ▁1 ▁] ▁<= ▁' ▁z ▁' ▁? ▁( ▁( ▁int ▁) ▁ch ▁[ ▁i ▁- ▁1 ▁] ▁- ▁32 ▁) ▁: ▁( ▁int ▁) ▁ch ▁[ ▁i ▁- ▁1 ▁] ▁) ▁; ▁} ▁return ▁ch ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁G eek s ▁for ▁G eek s ▁" ▁; ▁c out ▁<< ▁str ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁c out ▁<< ▁First And Last ▁( ▁str ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁vector ▁< ▁int ▁> ▁compute _ l ps ▁( ▁string ▁s ▁) ▁{ ▁int ▁n ▁= ▁s ▁. ▁size ▁( ▁) ▁; ▁vector ▁< ▁int ▁> ▁l ps ▁( ▁n ▁) ▁; ▁int ▁len ▁= ▁0 ▁; ▁l ps ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁int ▁i ▁= ▁1 ▁; ▁while ▁( ▁i ▁< ▁n ▁) ▁{ ▁if ▁( ▁s ▁[ ▁i ▁] ▁== ▁s ▁[ ▁len ▁] ▁) ▁{ ▁len ▁++ ▁; ▁l ps ▁[ ▁i ▁] ▁= ▁len ▁; ▁i ▁++ ▁; ▁} ▁else ▁{ ▁if ▁( ▁len ▁!= ▁0 ▁) ▁len ▁= ▁l ps ▁[ ▁len ▁- ▁1 ▁] ▁; ▁else ▁{ ▁l ps ▁[ ▁i ▁] ▁= ▁0 ▁; ▁i ▁++ ▁; ▁} ▁} ▁} ▁return ▁l ps ▁; ▁} ▁void ▁Long est substring ▁( ▁string ▁s ▁) ▁{ ▁vector ▁< ▁int ▁> ▁l ps ▁= ▁compute _ l ps ▁( ▁s ▁) ▁; ▁int ▁n ▁= ▁s ▁. ▁size ▁( ▁) ▁; ▁if ▁( ▁l ps ▁[ ▁n ▁- ▁1 ▁] ▁== ▁0 ▁) ▁{ ▁c out ▁<< ▁-1 ▁; ▁return ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁l ps ▁[ ▁i ▁] ▁== ▁l ps ▁[ ▁n ▁- ▁1 ▁] ▁) ▁{ ▁c out ▁<< ▁s ▁. ▁substr ▁( ▁0 ▁, ▁l ps ▁[ ▁i ▁] ▁) ▁; ▁return ▁; ▁} ▁} ▁if ▁( ▁l ps ▁[ ▁l ps ▁[ ▁n ▁- ▁1 ▁] ▁- ▁1 ▁] ▁== ▁0 ▁) ▁c out ▁<< ▁-1 ▁; ▁else ▁c out ▁<< ▁s ▁. ▁substr ▁( ▁0 ▁, ▁l ps ▁[ ▁l ps ▁[ ▁n ▁- ▁1 ▁] ▁- ▁1 ▁] ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁" ▁fix prefix suffix ▁" ▁; ▁Long est substring ▁( ▁s ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁string ▁find Max Len Even ▁( ▁string ▁str ▁) ▁{ ▁int ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁int ▁i ▁= ▁0 ▁; ▁int ▁cur rl en ▁= ▁0 ▁; ▁int ▁maxlen ▁= ▁0 ▁; ▁int ▁st ▁= ▁-1 ▁; ▁while ▁( ▁i ▁< ▁n ▁) ▁{ ▁if ▁( ▁str ▁[ ▁i ▁] ▁== ▁' ▁' ▁) ▁{ ▁if ▁( ▁cur rl en ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁if ▁( ▁maxlen ▁< ▁cur rl en ▁) ▁{ ▁maxlen ▁= ▁cur rl en ▁; ▁st ▁= ▁i ▁- ▁cur rl en ▁; ▁} ▁} ▁cur rl en ▁= ▁0 ▁; ▁} ▁else ▁{ ▁cur rl en ▁++ ▁; ▁} ▁i ▁++ ▁; ▁} ▁if ▁( ▁cur rl en ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁if ▁( ▁maxlen ▁< ▁cur rl en ▁) ▁{ ▁maxlen ▁= ▁cur rl en ▁; ▁st ▁= ▁i ▁- ▁cur rl en ▁; ▁} ▁} ▁if ▁( ▁st ▁== ▁-1 ▁) ▁return ▁" ▁- ▁1" ▁; ▁return ▁str ▁. ▁substr ▁( ▁st ▁, ▁maxlen ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁this ▁is ▁a ▁test ▁string ▁" ▁; ▁c out ▁<< ▁find Max Len Even ▁( ▁str ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁string ▁find Min Len Str ▁( ▁string ▁str ▁, ▁int ▁k ▁) ▁{ ▁int ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁int ▁st ▁= ▁0 ▁; ▁int ▁end ▁= ▁0 ▁; ▁int ▁cnt ▁[ ▁26 ▁] ▁; ▁mem set ▁( ▁cnt ▁, ▁0 ▁, ▁sizeof ▁( ▁cnt ▁) ▁) ▁; ▁int ▁dist Ele ▁= ▁0 ▁; ▁int ▁cur rl en ▁; ▁int ▁min len ▁= ▁n ▁; ▁int ▁start Ind ▁= ▁-1 ▁; ▁while ▁( ▁end ▁< ▁n ▁) ▁{ ▁cnt ▁[ ▁str ▁[ ▁end ▁] ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁if ▁( ▁cnt ▁[ ▁str ▁[ ▁end ▁] ▁- ▁' ▁a ▁' ▁] ▁== ▁1 ▁) ▁dist Ele ▁++ ▁; ▁if ▁( ▁dist Ele ▁> ▁k ▁) ▁{ ▁while ▁( ▁st ▁< ▁end ▁&& ▁dist Ele ▁> ▁k ▁) ▁{ ▁if ▁( ▁cnt ▁[ ▁str ▁[ ▁st ▁] ▁- ▁' ▁a ▁' ▁] ▁== ▁1 ▁) ▁dist Ele ▁-- ▁; ▁cnt ▁[ ▁str ▁[ ▁st ▁] ▁- ▁' ▁a ▁' ▁] ▁-- ▁; ▁st ▁++ ▁; ▁} ▁} ▁if ▁( ▁dist Ele ▁== ▁k ▁) ▁{ ▁while ▁( ▁st ▁< ▁end ▁&& ▁cnt ▁[ ▁str ▁[ ▁st ▁] ▁- ▁' ▁a ▁' ▁] ▁> ▁1 ▁) ▁{ ▁cnt ▁[ ▁str ▁[ ▁st ▁] ▁- ▁' ▁a ▁' ▁] ▁-- ▁; ▁st ▁++ ▁; ▁} ▁cur rl en ▁= ▁end ▁- ▁st ▁+ ▁1 ▁; ▁if ▁( ▁cur rl en ▁< ▁min len ▁) ▁{ ▁min len ▁= ▁cur rl en ▁; ▁start Ind ▁= ▁st ▁; ▁} ▁} ▁end ▁++ ▁; ▁} ▁return ▁str ▁. ▁substr ▁( ▁start Ind ▁, ▁min len ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁ef ec f ef d ▁" ▁; ▁int ▁k ▁= ▁4 ▁; ▁c out ▁<< ▁find Min Len Str ▁( ▁str ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁total Pairs ▁( ▁string ▁s 1 ▁, ▁string ▁s 2 ▁) ▁{ ▁int ▁a 1 ▁= ▁0 ▁, ▁b 1 ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s 1 ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁int ▁( ▁s 1 ▁[ ▁i ▁] ▁) ▁% ▁2 ▁!= ▁0 ▁) ▁a 1 ▁++ ▁; ▁else ▁b 1 ▁++ ▁; ▁} ▁int ▁a 2 ▁= ▁0 ▁, ▁b 2 ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s 2 ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁int ▁( ▁s 2 ▁[ ▁i ▁] ▁) ▁% ▁2 ▁!= ▁0 ▁) ▁a 2 ▁++ ▁; ▁else ▁b 2 ▁++ ▁; ▁} ▁return ▁( ▁( ▁a 1 ▁* ▁a 2 ▁) ▁+ ▁( ▁b 1 ▁* ▁b 2 ▁) ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s 1 ▁= ▁" ▁g eek s ▁" ▁, ▁s 2 ▁= ▁" ▁for ▁" ▁; ▁c out ▁<< ▁total Pairs ▁( ▁s 1 ▁, ▁s 2 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁Pre process ▁( ▁string ▁A ▁, ▁string ▁B ▁) ▁{ ▁int ▁n ▁= ▁A ▁. ▁size ▁( ▁) ▁; ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁/ ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁map ▁< ▁char ▁, ▁int ▁> ▁mp ▁; ▁mp ▁[ ▁A ▁[ ▁i ▁] ▁] ▁++ ▁; ▁mp ▁[ ▁A ▁[ ▁n ▁- ▁i ▁- ▁1 ▁] ▁] ▁++ ▁; ▁mp ▁[ ▁B ▁[ ▁i ▁] ▁] ▁++ ▁; ▁mp ▁[ ▁B ▁[ ▁n ▁- ▁i ▁- ▁1 ▁] ▁] ▁++ ▁; ▁int ▁sz ▁= ▁mp ▁. ▁size ▁( ▁) ▁; ▁if ▁( ▁sz ▁== ▁4 ▁) ▁ans ▁+= ▁2 ▁; ▁else ▁if ▁( ▁sz ▁== ▁3 ▁) ▁ans ▁+= ▁1 ▁+ ▁( ▁A ▁[ ▁i ▁] ▁== ▁A ▁[ ▁n ▁- ▁i ▁- ▁1 ▁] ▁) ▁; ▁else ▁if ▁( ▁sz ▁== ▁2 ▁) ▁ans ▁+= ▁mp ▁[ ▁A ▁[ ▁i ▁] ▁] ▁!= ▁2 ▁; ▁} ▁if ▁( ▁n ▁% ▁2 ▁== ▁1 ▁&& ▁A ▁[ ▁n ▁/ ▁2 ▁] ▁!= ▁B ▁[ ▁n ▁/ ▁2 ▁] ▁) ▁ans ▁++ ▁; ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁A ▁= ▁" ▁ab ac aba ▁" ▁, ▁B ▁= ▁" ▁b ac ab aa ▁" ▁; ▁c out ▁<< ▁Pre process ▁( ▁A ▁, ▁B ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print Pattern ▁( ▁char ▁s ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁c out ▁<< ▁s ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁int ▁i ▁= ▁0 ▁, ▁j ▁= ▁n ▁- ▁2 ▁; ▁while ▁( ▁i ▁< ▁j ▁) ▁{ ▁char ▁c ▁= ▁s ▁[ ▁i ▁] ▁; ▁s ▁[ ▁i ▁] ▁= ▁s ▁[ ▁j ▁] ▁; ▁s ▁[ ▁j ▁] ▁= ▁c ▁; ▁i ▁++ ▁; ▁j ▁-- ▁; ▁} ▁i ▁= ▁0 ▁; ▁j ▁= ▁n ▁- ▁2 ▁; ▁while ▁( ▁j ▁- ▁i ▁> ▁1 ▁) ▁{ ▁s ▁[ ▁i ▁] ▁= ▁s ▁[ ▁j ▁] ▁= ▁' ▁* ▁' ▁; ▁c out ▁<< ▁s ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁i ▁++ ▁; ▁j ▁-- ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁char ▁s ▁[ ▁] ▁= ▁" ▁g eek s ▁" ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁s ▁) ▁/ ▁sizeof ▁( ▁s ▁[ ▁0 ▁] ▁) ▁; ▁print Pattern ▁( ▁s ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁char ▁bit ToBe F li pped ▁( ▁string ▁s ▁) ▁{ ▁char ▁last ▁= ▁s ▁[ ▁s ▁. ▁length ▁( ▁) ▁- ▁1 ▁] ▁; ▁char ▁first ▁= ▁s ▁[ ▁0 ▁] ▁; ▁if ▁( ▁last ▁== ▁first ▁) ▁{ ▁if ▁( ▁last ▁== ▁'0' ▁) ▁{ ▁return ▁'1' ▁; ▁} ▁else ▁{ ▁return ▁'0' ▁; ▁} ▁} ▁else ▁if ▁( ▁last ▁!= ▁first ▁) ▁{ ▁return ▁last ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁"11 0101 1000 " ▁; ▁c out ▁<< ▁bit ToBe F li pped ▁( ▁s ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁check ▁( ▁string ▁s ▁) ▁{ ▁int ▁freq ▁[ ▁26 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁int ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁freq ▁[ ▁s ▁[ ▁i ▁] ▁- ▁97 ▁] ▁++ ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁26 ▁; ▁i ▁++ ▁) ▁if ▁( ▁freq ▁[ ▁i ▁] ▁% ▁2 ▁== ▁1 ▁) ▁return ▁false ▁; ▁return ▁true ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁" ▁ab acc aba ▁" ▁; ▁check ▁( ▁s ▁) ▁? ▁c out ▁<< ▁" ▁Yes ▁" ▁<< ▁end l ▁: ▁c out ▁<< ▁" ▁No ▁" ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁solve ▁( ▁string ▁s ▁) ▁{ ▁unordered _ map ▁< ▁char ▁, ▁int ▁> ▁m ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁m ▁[ ▁s ▁[ ▁i ▁] ▁] ▁++ ▁; ▁} ▁string ▁new _ string ▁= ▁" ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁m ▁[ ▁s ▁[ ▁i ▁] ▁] ▁% ▁2 ▁== ▁0 ▁) ▁continue ▁; ▁new _ string ▁+= ▁s ▁[ ▁i ▁] ▁; ▁} ▁c out ▁<< ▁new _ string ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁" ▁a ab bb dd ee ec c ▁" ▁; ▁solve ▁( ▁s ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁minimum Length ▁( ▁string ▁s ▁) ▁{ ▁int ▁max Occ ▁= ▁0 ▁, ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁int ▁arr ▁[ ▁26 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁arr ▁[ ▁s ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁26 ▁; ▁i ▁++ ▁) ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁max Occ ▁) ▁max Occ ▁= ▁arr ▁[ ▁i ▁] ▁; ▁return ▁( ▁n ▁- ▁max Occ ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁af dd ew q d ▁" ▁; ▁c out ▁<< ▁minimum Length ▁( ▁str ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁int ▁MAX ▁= ▁INT _ MAX ▁; ▁int ▁min Operation ▁( ▁string ▁& ▁s ▁, ▁int ▁i ▁, ▁int ▁j ▁, ▁int ▁count ▁) ▁{ ▁if ▁( ▁( ▁i ▁>= ▁s ▁. ▁size ▁( ▁) ▁&& ▁j ▁< ▁0 ▁) ▁|| ▁( ▁i ▁== ▁j ▁) ▁) ▁return ▁MAX ▁; ▁if ▁( ▁s ▁[ ▁i ▁] ▁== ▁s ▁[ ▁j ▁] ▁) ▁return ▁count ▁; ▁if ▁( ▁i ▁>= ▁s ▁. ▁size ▁( ▁) ▁) ▁return ▁min Operation ▁( ▁s ▁, ▁i ▁, ▁j ▁- ▁1 ▁, ▁count ▁+ ▁1 ▁) ▁; ▁else ▁if ▁( ▁j ▁< ▁0 ▁) ▁return ▁min Operation ▁( ▁s ▁, ▁i ▁+ ▁1 ▁, ▁j ▁, ▁count ▁+ ▁1 ▁) ▁; ▁else ▁return ▁min ▁( ▁min Operation ▁( ▁s ▁, ▁i ▁, ▁j ▁- ▁1 ▁, ▁count ▁+ ▁1 ▁) ▁, ▁min Operation ▁( ▁s ▁, ▁i ▁+ ▁1 ▁, ▁j ▁, ▁count ▁+ ▁1 ▁) ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁" ▁b ac def gh ip al op ▁" ▁; ▁int ▁ans ▁= ▁min Operation ▁( ▁s ▁, ▁0 ▁, ▁s ▁. ▁size ▁( ▁) ▁- ▁1 ▁, ▁0 ▁) ▁; ▁if ▁( ▁ans ▁== ▁MAX ▁) ▁c out ▁<< ▁-1 ▁; ▁else ▁c out ▁<< ▁ans ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁int ▁MAX _ CHAR ▁= ▁26 ▁; ▁void ▁frequency ▁( ▁int ▁fre ▁[ ▁] ▁[ ▁MAX _ CHAR ▁] ▁, ▁string ▁s ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁string ▁str ▁= ▁s ▁[ ▁i ▁] ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁str ▁. ▁size ▁( ▁) ▁; ▁j ▁++ ▁) ▁fre ▁[ ▁i ▁] ▁[ ▁str ▁[ ▁j ▁] ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁} ▁} ▁void ▁Long est Sequence ▁( ▁int ▁fre ▁[ ▁] ▁[ ▁MAX _ CHAR ▁] ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁MAX _ CHAR ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁int ▁mi ▁= ▁fre ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁; ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁mi ▁= ▁min ▁( ▁fre ▁[ ▁j ▁] ▁[ ▁i ▁] ▁, ▁mi ▁) ▁; ▁while ▁( ▁mi ▁-- ▁) ▁c out ▁<< ▁( ▁char ▁) ▁( ▁' ▁a ▁' ▁+ ▁i ▁) ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁[ ▁] ▁= ▁{ ▁" ▁loo ▁" ▁, ▁" ▁lol ▁" ▁, ▁" ▁o live ▁" ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁s ▁) ▁/ ▁sizeof ▁( ▁s ▁[ ▁0 ▁] ▁) ▁; ▁int ▁fre ▁[ ▁n ▁] ▁[ ▁26 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁frequency ▁( ▁fre ▁, ▁s ▁, ▁n ▁) ▁; ▁Long est Sequence ▁( ▁fre ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁minimum F lip ▁( ▁string ▁s ▁, ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁s ▁= ▁s ▁+ ▁s ▁; ▁bool ▁is O pp osite ▁= ▁false ▁; ▁if ▁( ▁x ▁> ▁y ▁) ▁{ ▁swap ▁( ▁x ▁, ▁y ▁) ▁; ▁is O pp osite ▁= ▁true ▁; ▁} ▁int ▁val Clock wise ▁= ▁0 ▁; ▁char ▁cur ▁= ▁s ▁[ ▁x ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁x ▁; ▁i ▁<= ▁y ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁[ ▁i ▁] ▁!= ▁cur ▁) ▁{ ▁cur ▁= ▁s ▁[ ▁i ▁] ▁; ▁val Clock wise ▁++ ▁; ▁} ▁} ▁int ▁val Ant ic lock wise ▁= ▁0 ▁; ▁cur ▁= ▁s ▁[ ▁y ▁] ▁; ▁x ▁+= ▁s ▁. ▁length ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁y ▁; ▁i ▁<= ▁x ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁[ ▁i ▁] ▁!= ▁cur ▁) ▁{ ▁cur ▁= ▁s ▁[ ▁i ▁] ▁; ▁val Ant ic lock wise ▁++ ▁; ▁} ▁} ▁if ▁( ▁val Clock wise ▁<= ▁val Ant ic lock wise ▁) ▁{ ▁if ▁( ▁! ▁is O pp osite ▁) ▁c out ▁<< ▁" ▁Clock wise ▁" ▁<< ▁val Clock wise ▁<< ▁end l ▁; ▁else ▁c out ▁<< ▁" ▁Ant i ▁- ▁clock wise ▁" ▁<< ▁val Ant ic lock wise ▁<< ▁end l ▁; ▁} ▁else ▁{ ▁if ▁( ▁! ▁is O pp osite ▁) ▁c out ▁<< ▁" ▁Ant i ▁- ▁clock wise ▁" ▁<< ▁val Ant ic lock wise ▁<< ▁end l ▁; ▁else ▁c out ▁<< ▁" ▁Clock wise ▁" ▁<< ▁val Clock wise ▁<< ▁end l ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁x ▁= ▁0 ▁, ▁y ▁= ▁8 ▁; ▁string ▁s ▁= ▁" 0001 10" ▁; ▁minimum F lip ▁( ▁s ▁, ▁x ▁, ▁y ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁string ▁Lex ic ograph ical Max String ▁( ▁string ▁str ▁) ▁{ ▁char ▁max char ▁= ▁' ▁a ▁' ▁; ▁vector ▁< ▁int ▁> ▁index ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁str ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁str ▁[ ▁i ▁] ▁>= ▁max char ▁) ▁{ ▁max char ▁= ▁str ▁[ ▁i ▁] ▁; ▁index ▁. ▁push _ back ▁( ▁i ▁) ▁; ▁} ▁} ▁string ▁max string ▁= ▁" ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁index ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁str ▁. ▁substr ▁( ▁index ▁[ ▁i ▁] ▁, ▁str ▁. ▁length ▁( ▁) ▁) ▁> ▁max string ▁) ▁{ ▁max string ▁= ▁str ▁. ▁substr ▁( ▁index ▁[ ▁i ▁] ▁, ▁str ▁. ▁length ▁( ▁) ▁) ▁; ▁} ▁} ▁return ▁max string ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁ac b ac bc ▁" ▁; ▁c out ▁<< ▁Lex ic ograph ical Max String ▁( ▁str ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁struct ▁Node ▁{ ▁string ▁c ▁; ▁struct ▁Node ▁* ▁next ▁; ▁} ▁; ▁struct ▁Node ▁* ▁newNode ▁( ▁string ▁c ▁) ▁{ ▁Node ▁* ▁temp ▁= ▁new ▁Node ▁; ▁temp ▁-> ▁c ▁= ▁c ▁; ▁temp ▁-> ▁next ▁= ▁NULL ▁; ▁return ▁temp ▁; ▁} ▁; ▁void ▁reverse _ word ▁( ▁string ▁& ▁str ▁) ▁{ ▁reverse ▁( ▁str ▁. ▁begin ▁( ▁) ▁, ▁str ▁. ▁end ▁( ▁) ▁) ▁; ▁} ▁void ▁reverse ▁( ▁struct ▁Node ▁* ▁head ▁) ▁{ ▁struct ▁Node ▁* ▁ptr ▁= ▁head ▁; ▁while ▁( ▁ptr ▁!= ▁NULL ▁) ▁{ ▁reverse _ word ▁( ▁ptr ▁-> ▁c ▁) ▁; ▁ptr ▁= ▁ptr ▁-> ▁next ▁; ▁} ▁} ▁void ▁print List ▁( ▁struct ▁Node ▁* ▁head ▁) ▁{ ▁while ▁( ▁head ▁!= ▁NULL ▁) ▁{ ▁c out ▁<< ▁head ▁-> ▁c ▁<< ▁" ▁" ▁; ▁head ▁= ▁head ▁-> ▁next ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁Node ▁* ▁head ▁= ▁newNode ▁( ▁" ▁G eek s forge ek s ▁" ▁) ▁; ▁head ▁-> ▁next ▁= ▁newNode ▁( ▁" ▁a ▁" ▁) ▁; ▁head ▁-> ▁next ▁-> ▁next ▁= ▁newNode ▁( ▁" ▁computer ▁" ▁) ▁; ▁head ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁= ▁newNode ▁( ▁" ▁sc ience ▁" ▁) ▁; ▁head ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁= ▁newNode ▁( ▁" ▁portal ▁" ▁) ▁; ▁head ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁= ▁newNode ▁( ▁" ▁for ▁" ▁) ▁; ▁head ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁-> ▁next ▁= ▁newNode ▁( ▁" ▁g eek s ▁" ▁) ▁; ▁c out ▁<< ▁" ▁List ▁before ▁reverse ▁: ▁STRNEWLINE ▁" ▁; ▁print List ▁( ▁head ▁) ▁; ▁reverse ▁( ▁head ▁) ▁; ▁c out ▁<< ▁" ▁List ▁after ▁reverse ▁: ▁" ▁; ▁print List ▁( ▁head ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁binary _ conversion ▁( ▁string ▁& ▁s ▁, ▁int ▁m ▁) ▁{ ▁while ▁( ▁m ▁) ▁{ ▁int ▁tmp ▁= ▁m ▁% ▁2 ▁; ▁s ▁+= ▁tmp ▁+ ▁'0' ▁; ▁m ▁= ▁m ▁/ ▁2 ▁; ▁} ▁reverse ▁( ▁s ▁. ▁begin ▁( ▁) ▁, ▁s ▁. ▁end ▁( ▁) ▁) ▁; ▁} ▁int ▁find _ character ▁( ▁int ▁n ▁, ▁int ▁m ▁, ▁int ▁i ▁) ▁{ ▁string ▁s ▁; ▁binary _ conversion ▁( ▁s ▁, ▁m ▁) ▁; ▁string ▁s 1 ▁= ▁" ▁" ▁; ▁for ▁( ▁int ▁x ▁= ▁0 ▁; ▁x ▁< ▁n ▁; ▁x ▁++ ▁) ▁{ ▁for ▁( ▁int ▁y ▁= ▁0 ▁; ▁y ▁< ▁s ▁. ▁length ▁( ▁) ▁; ▁y ▁++ ▁) ▁{ ▁if ▁( ▁s ▁[ ▁y ▁] ▁== ▁'1' ▁) ▁s 1 ▁+= ▁"10" ▁; ▁else ▁s 1 ▁+= ▁" 01" ▁; ▁} ▁s ▁= ▁s 1 ▁; ▁s 1 ▁= ▁" ▁" ▁; ▁} ▁return ▁s ▁[ ▁i ▁] ▁- ▁'0' ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁m ▁= ▁5 ▁, ▁n ▁= ▁2 ▁, ▁i ▁= ▁8 ▁; ▁c out ▁<< ▁find _ character ▁( ▁n ▁, ▁m ▁, ▁i ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Sub Sequence ▁( ▁string ▁s ▁, ▁int ▁num ▁) ▁{ ▁int ▁res ▁= ▁0 ▁; ▁int ▁i ▁= ▁0 ▁; ▁while ▁( ▁num ▁) ▁{ ▁if ▁( ▁num ▁& ▁1 ▁) ▁res ▁+= ▁s ▁[ ▁i ▁] ▁- ▁'0' ▁; ▁i ▁++ ▁; ▁num ▁= ▁num ▁>> ▁1 ▁; ▁} ▁return ▁res ▁; ▁} ▁int ▁combined Sum ▁( ▁string ▁s ▁) ▁{ ▁int ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁int ▁c _ sum ▁= ▁0 ▁; ▁int ▁range ▁= ▁( ▁1 ▁<< ▁n ▁) ▁- ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁range ▁; ▁i ▁++ ▁) ▁c _ sum ▁+= ▁find Sub Sequence ▁( ▁s ▁, ▁i ▁) ▁; ▁return ▁c _ sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁"123" ▁; ▁c out ▁<< ▁combined Sum ▁( ▁s ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁solve ▁( ▁string ▁s ▁) ▁{ ▁int ▁l ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁int ▁x ▁= ▁l ▁/ ▁2 ▁; ▁int ▁y ▁= ▁l ▁; ▁string ▁p ▁= ▁" ▁" ▁; ▁while ▁( ▁x ▁> ▁0 ▁&& ▁y ▁> ▁l ▁/ ▁2 ▁) ▁{ ▁p ▁+= ▁s ▁[ ▁x ▁- ▁1 ▁] ▁; ▁x ▁-- ▁; ▁p ▁+= ▁s ▁[ ▁y ▁- ▁1 ▁] ▁; ▁y ▁-- ▁; ▁} ▁if ▁( ▁y ▁> ▁l ▁/ ▁2 ▁) ▁{ ▁p ▁+= ▁s ▁[ ▁y ▁- ▁1 ▁] ▁; ▁y ▁-- ▁; ▁} ▁c out ▁<< ▁p ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁" ▁sun sh ine ▁" ▁; ▁solve ▁( ▁s ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁MAX ▁26 ▁NEW _ LINE ▁void ▁print An agram And Changes ▁( ▁string ▁X ▁, ▁string ▁Y ▁) ▁{ ▁int ▁count x ▁[ ▁MAX ▁] ▁= ▁{ ▁0 ▁} ▁, ▁county ▁[ ▁MAX ▁] ▁= ▁{ ▁0 ▁} ▁, ▁ctr x ▁[ ▁MAX ▁] ▁= ▁{ ▁0 ▁} ▁, ▁c try ▁[ ▁MAX ▁] ▁= ▁{ ▁0 ▁} ▁; ▁int ▁change ▁= ▁0 ▁; ▁int ▁l ▁= ▁X ▁. ▁length ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁l ▁; ▁i ▁++ ▁) ▁{ ▁count x ▁[ ▁X ▁[ ▁i ▁] ▁- ▁' ▁A ▁' ▁] ▁++ ▁; ▁county ▁[ ▁Y ▁[ ▁i ▁] ▁- ▁' ▁A ▁' ▁] ▁++ ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁MAX ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁count x ▁[ ▁i ▁] ▁> ▁county ▁[ ▁i ▁] ▁) ▁ctr x ▁[ ▁i ▁] ▁+= ▁( ▁count x ▁[ ▁i ▁] ▁- ▁county ▁[ ▁i ▁] ▁) ▁; ▁else ▁if ▁( ▁count x ▁[ ▁i ▁] ▁< ▁county ▁[ ▁i ▁] ▁) ▁c try ▁[ ▁i ▁] ▁+= ▁( ▁county ▁[ ▁i ▁] ▁- ▁count x ▁[ ▁i ▁] ▁) ▁; ▁change ▁+= ▁abs ▁( ▁county ▁[ ▁i ▁] ▁- ▁count x ▁[ ▁i ▁] ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁l ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁ctr x ▁[ ▁X ▁[ ▁i ▁] ▁- ▁' ▁A ▁' ▁] ▁== ▁0 ▁) ▁continue ▁; ▁int ▁j ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁MAX ▁; ▁j ▁++ ▁) ▁if ▁( ▁( ▁c try ▁[ ▁j ▁] ▁) ▁> ▁0 ▁) ▁break ▁; ▁if ▁( ▁count x ▁[ ▁X ▁[ ▁i ▁] ▁- ▁' ▁A ▁' ▁] ▁== ▁ctr x ▁[ ▁X ▁[ ▁i ▁] ▁- ▁' ▁A ▁' ▁] ▁X ▁[ ▁i ▁] ▁- ▁' ▁A ▁' ▁> ▁j ▁) ▁{ ▁count x ▁[ ▁X ▁[ ▁i ▁] ▁- ▁' ▁A ▁' ▁] ▁-- ▁; ▁ctr x ▁[ ▁X ▁[ ▁i ▁] ▁- ▁' ▁A ▁' ▁] ▁-- ▁; ▁c try ▁[ ▁j ▁] ▁-- ▁; ▁X ▁[ ▁i ▁] ▁= ▁' ▁A ▁' ▁+ ▁j ▁; ▁} ▁else ▁count x ▁[ ▁X ▁[ ▁i ▁] ▁- ▁' ▁A ▁' ▁] ▁-- ▁; ▁} ▁c out ▁<< ▁" ▁An agram ▁: ▁" ▁<< ▁X ▁<< ▁end l ▁; ▁c out ▁<< ▁" ▁Number ▁of ▁changes ▁made ▁: ▁" ▁<< ▁change ▁/ ▁2 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁x ▁= ▁" ▁C DB ABC ▁" ▁, ▁y ▁= ▁" ▁AD C AB D ▁" ▁; ▁print An agram And Changes ▁( ▁x ▁, ▁y ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Occurrences ▁( ▁char ▁* ▁str ▁, ▁string ▁word ▁) ▁{ ▁char ▁* ▁p ▁; ▁vector ▁< ▁string ▁> ▁a ▁; ▁p ▁= ▁str tok ▁( ▁str ▁, ▁" ▁" ▁) ▁; ▁while ▁( ▁p ▁!= ▁NULL ▁) ▁{ ▁a ▁. ▁push _ back ▁( ▁p ▁) ▁; ▁p ▁= ▁str tok ▁( ▁NULL ▁, ▁" ▁" ▁) ▁; ▁} ▁int ▁c ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁a ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁if ▁( ▁word ▁== ▁a ▁[ ▁i ▁] ▁) ▁c ▁++ ▁; ▁return ▁c ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁char ▁str ▁[ ▁] ▁= ▁" ▁G eek s for G eek s ▁A ▁computer ▁sc ience ▁portal ▁for ▁g eek s ▁" ▁; ▁string ▁word ▁= ▁" ▁portal ▁" ▁; ▁c out ▁<< ▁count Occurrences ▁( ▁str ▁, ▁word ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁vector ▁< ▁string ▁> ▁split Strings ▁( ▁string ▁str ▁, ▁char ▁dl ▁) ▁{ ▁string ▁word ▁= ▁" ▁" ▁; ▁int ▁num ▁= ▁0 ▁; ▁str ▁= ▁str ▁+ ▁dl ▁; ▁int ▁l ▁= ▁str ▁. ▁size ▁( ▁) ▁; ▁vector ▁< ▁string ▁> ▁substr _ list ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁l ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁str ▁[ ▁i ▁] ▁!= ▁dl ▁) ▁word ▁= ▁word ▁+ ▁str ▁[ ▁i ▁] ▁; ▁else ▁{ ▁if ▁( ▁( ▁int ▁) ▁word ▁. ▁size ▁( ▁) ▁!= ▁0 ▁) ▁substr _ list ▁. ▁push _ back ▁( ▁word ▁) ▁; ▁word ▁= ▁" ▁" ▁; ▁} ▁} ▁return ▁substr _ list ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁g eek s ▁; ▁for ▁; ▁g eek s ▁" ▁; ▁char ▁dl ▁= ▁' ▁; ▁' ▁; ▁vector ▁< ▁string ▁> ▁res ▁= ▁split Strings ▁( ▁str ▁, ▁dl ▁) ▁; ▁for ▁( ▁auto ▁x ▁: ▁res ▁) ▁c out ▁<< ▁x ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁longest Sub seq ▁( ▁string ▁s ▁) ▁{ ▁int ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁int ▁pre _ count _0 ▁[ ▁n ▁+ ▁2 ▁] ▁; ▁int ▁pre _ count _1 ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁int ▁post _ count _0 ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁pre _ count _0 ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁post _ count _0 ▁[ ▁n ▁+ ▁1 ▁] ▁= ▁0 ▁; ▁pre _ count _1 ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁<= ▁n ▁; ▁j ▁++ ▁) ▁{ ▁pre _ count _0 ▁[ ▁j ▁] ▁= ▁pre _ count _0 ▁[ ▁j ▁- ▁1 ▁] ▁; ▁pre _ count _1 ▁[ ▁j ▁] ▁= ▁pre _ count _1 ▁[ ▁j ▁- ▁1 ▁] ▁; ▁post _ count _0 ▁[ ▁n ▁- ▁j ▁+ ▁1 ▁] ▁= ▁post _ count _0 ▁[ ▁n ▁- ▁j ▁+ ▁2 ▁] ▁; ▁if ▁( ▁s ▁[ ▁j ▁- ▁1 ▁] ▁== ▁'0' ▁) ▁pre _ count _0 ▁[ ▁j ▁] ▁++ ▁; ▁else ▁pre _ count _1 ▁[ ▁j ▁] ▁++ ▁; ▁if ▁( ▁s ▁[ ▁n ▁- ▁j ▁] ▁== ▁'0' ▁) ▁post _ count _0 ▁[ ▁n ▁- ▁j ▁+ ▁1 ▁] ▁++ ▁; ▁} ▁if ▁( ▁pre _ count _0 ▁[ ▁n ▁] ▁== ▁n ▁pre _ count _0 ▁[ ▁n ▁] ▁== ▁0 ▁) ▁return ▁n ▁; ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁<= ▁n ▁; ▁j ▁++ ▁) ▁ans ▁= ▁max ▁( ▁pre _ count _0 ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁pre _ count _1 ▁[ ▁j ▁] ▁- ▁pre _ count _1 ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁post _ count _0 ▁[ ▁j ▁+ ▁1 ▁] ▁, ▁ans ▁) ▁; ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁" 0000 11 100 000" ▁; ▁c out ▁<< ▁longest Sub seq ▁( ▁s ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁should Swap ▁( ▁char ▁str ▁[ ▁] ▁, ▁int ▁start ▁, ▁int ▁curr ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁start ▁; ▁i ▁< ▁curr ▁; ▁i ▁++ ▁) ▁if ▁( ▁str ▁[ ▁i ▁] ▁== ▁str ▁[ ▁curr ▁] ▁) ▁return ▁0 ▁; ▁return ▁1 ▁; ▁} ▁void ▁find Perm utations ▁( ▁char ▁str ▁[ ▁] ▁, ▁int ▁index ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁index ▁>= ▁n ▁) ▁{ ▁c out ▁<< ▁str ▁<< ▁end l ▁; ▁return ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁index ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁bool ▁check ▁= ▁should Swap ▁( ▁str ▁, ▁index ▁, ▁i ▁) ▁; ▁if ▁( ▁check ▁) ▁{ ▁swap ▁( ▁str ▁[ ▁index ▁] ▁, ▁str ▁[ ▁i ▁] ▁) ▁; ▁find Perm utations ▁( ▁str ▁, ▁index ▁+ ▁1 ▁, ▁n ▁) ▁; ▁swap ▁( ▁str ▁[ ▁index ▁] ▁, ▁str ▁[ ▁i ▁] ▁) ▁; ▁} ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁char ▁str ▁[ ▁] ▁= ▁" ▁AB CA ▁" ▁; ▁int ▁n ▁= ▁str len ▁( ▁str ▁) ▁; ▁find Perm utations ▁( ▁str ▁, ▁0 ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁int ▁MAX _ CHAR ▁= ▁256 ▁; ▁int ▁maximum Chars ▁( ▁string ▁& ▁str ▁) ▁{ ▁int ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁int ▁res ▁= ▁-1 ▁; ▁int ▁first Ind ▁[ ▁MAX _ CHAR ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁MAX _ CHAR ▁; ▁i ▁++ ▁) ▁first Ind ▁[ ▁i ▁] ▁= ▁-1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁first _ ind ▁= ▁first Ind ▁[ ▁str ▁[ ▁i ▁] ▁] ▁; ▁if ▁( ▁first _ ind ▁== ▁-1 ▁) ▁first Ind ▁[ ▁str ▁[ ▁i ▁] ▁] ▁= ▁i ▁; ▁else ▁res ▁= ▁max ▁( ▁res ▁, ▁abs ▁( ▁i ▁- ▁first _ ind ▁- ▁1 ▁) ▁) ▁; ▁} ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁ab ba ▁" ▁; ▁c out ▁<< ▁maximum Chars ▁( ▁str ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁isValid ▁( ▁string ▁p ▁) ▁{ ▁int ▁n ▁= ▁p ▁. ▁length ▁( ▁) ▁; ▁int ▁c 1 ▁= ▁0 ▁, ▁c 0 ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁p ▁[ ▁i ▁] ▁== ▁'0' ▁) ▁c 0 ▁++ ▁; ▁if ▁( ▁p ▁[ ▁i ▁] ▁== ▁'1' ▁) ▁c 1 ▁++ ▁; ▁} ▁return ▁( ▁c 0 ▁== ▁c 1 ▁) ▁? ▁true ▁: ▁false ▁; ▁} ▁int ▁longest Sub ▁( ▁string ▁s ▁) ▁{ ▁int ▁max _ len ▁= ▁0 ▁; ▁int ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁isValid ▁( ▁s ▁. ▁substr ▁( ▁i ▁, ▁j ▁- ▁i ▁+ ▁1 ▁) ▁) ▁&& ▁max _ len ▁< ▁j ▁- ▁i ▁+ ▁1 ▁) ▁max _ len ▁= ▁j ▁- ▁i ▁+ ▁1 ▁; ▁} ▁} ▁return ▁max _ len ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁"1 01 001 000" ▁; ▁c out ▁<< ▁longest Sub ▁( ▁s ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁int ▁MAX _ CHAR ▁= ▁256 ▁; ▁void ▁print D u o ▁( ▁string ▁& ▁str ▁) ▁{ ▁int ▁count Char ▁[ ▁MAX _ CHAR ▁] ▁= ▁{ ▁0 ▁} ▁; ▁int ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁count Char ▁[ ▁str ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁string ▁str 1 ▁= ▁" ▁" ▁, ▁str 2 ▁= ▁" ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁MAX _ CHAR ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁count Char ▁[ ▁i ▁] ▁> ▁1 ▁) ▁str 2 ▁= ▁str 2 ▁+ ▁( ▁char ▁) ▁( ▁i ▁+ ▁' ▁a ▁' ▁) ▁; ▁else ▁if ▁( ▁count Char ▁[ ▁i ▁] ▁== ▁1 ▁) ▁str 1 ▁= ▁str 1 ▁+ ▁( ▁char ▁) ▁( ▁i ▁+ ▁' ▁a ▁' ▁) ▁; ▁} ▁c out ▁<< ▁" ▁String ▁with ▁characters ▁occurring ▁" ▁<< ▁" ▁once ▁: ▁STRNEWLINE ▁" ▁; ▁c out ▁<< ▁str 1 ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁c out ▁<< ▁" ▁String ▁with ▁characters ▁occurring ▁" ▁<< ▁" ▁multiple ▁times ▁: ▁STRNEWLINE ▁" ▁; ▁c out ▁<< ▁str 2 ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁lo v et ocode ▁" ▁; ▁print D u o ▁( ▁str ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁# include ▁< string . h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Repeat First N 2 ▁( ▁char ▁* ▁s ▁) ▁{ ▁int ▁p ▁= ▁-1 ▁, ▁i ▁, ▁j ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁str len ▁( ▁s ▁) ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁str len ▁( ▁s ▁) ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁s ▁[ ▁i ▁] ▁== ▁s ▁[ ▁j ▁] ▁) ▁{ ▁p ▁= ▁i ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁p ▁!= ▁-1 ▁) ▁break ▁; ▁} ▁return ▁p ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁char ▁str ▁[ ▁] ▁= ▁" ▁g eek s forge ek s ▁" ▁; ▁int ▁pos ▁= ▁find Repeat First N 2 ▁( ▁str ▁) ▁; ▁if ▁( ▁pos ▁== ▁-1 ▁) ▁c out ▁<< ▁" ▁Not ▁found ▁" ▁; ▁else ▁c out ▁<< ▁str ▁[ ▁pos ▁] ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁int ▁MAX _ CHAR ▁= ▁26 ▁; ▁char ▁string Pal indrome ▁( ▁string ▁A ▁, ▁string ▁B ▁) ▁{ ▁int ▁count A ▁[ ▁MAX _ CHAR ▁] ▁= ▁{ ▁0 ▁} ▁; ▁int ▁count B ▁[ ▁MAX _ CHAR ▁] ▁= ▁{ ▁0 ▁} ▁; ▁int ▁l 1 ▁= ▁A ▁. ▁length ▁( ▁) ▁, ▁l 2 ▁= ▁B ▁. ▁length ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁l 1 ▁; ▁i ▁++ ▁) ▁count A ▁[ ▁A ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁l 2 ▁; ▁i ▁++ ▁) ▁count B ▁[ ▁B ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁] ▁++ ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁26 ▁; ▁i ▁++ ▁) ▁if ▁( ▁( ▁count A ▁[ ▁i ▁] ▁> ▁1 ▁&& ▁count B ▁[ ▁i ▁] ▁== ▁0 ▁) ▁) ▁return ▁' ▁A ▁' ▁; ▁return ▁' ▁B ▁' ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁a ▁= ▁" ▁abc de a ▁" ▁; ▁string ▁b ▁= ▁" ▁bc des g ▁" ▁; ▁c out ▁<< ▁string Pal indrome ▁( ▁a ▁, ▁b ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Len ▁( ▁string ▁& ▁A ▁, ▁int ▁n ▁, ▁int ▁k ▁, ▁char ▁ch ▁) ▁{ ▁int ▁maxlen ▁= ▁1 ▁; ▁int ▁cnt ▁= ▁0 ▁; ▁int ▁l ▁= ▁0 ▁, ▁r ▁= ▁0 ▁; ▁while ▁( ▁r ▁< ▁n ▁) ▁{ ▁if ▁( ▁A ▁[ ▁r ▁] ▁!= ▁ch ▁) ▁++ ▁cnt ▁; ▁while ▁( ▁cnt ▁> ▁k ▁) ▁{ ▁if ▁( ▁A ▁[ ▁l ▁] ▁!= ▁ch ▁) ▁-- ▁cnt ▁; ▁++ ▁l ▁; ▁} ▁maxlen ▁= ▁max ▁( ▁maxlen ▁, ▁r ▁- ▁l ▁+ ▁1 ▁) ▁; ▁++ ▁r ▁; ▁} ▁return ▁maxlen ▁; ▁} ▁int ▁answer ▁( ▁string ▁& ▁A ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁maxlen ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁26 ▁; ▁++ ▁i ▁) ▁{ ▁maxlen ▁= ▁max ▁( ▁maxlen ▁, ▁find Len ▁( ▁A ▁, ▁n ▁, ▁k ▁, ▁i ▁+ ▁' ▁A ▁' ▁) ▁) ▁; ▁maxlen ▁= ▁max ▁( ▁maxlen ▁, ▁find Len ▁( ▁A ▁, ▁n ▁, ▁k ▁, ▁i ▁+ ▁' ▁a ▁' ▁) ▁) ▁; ▁} ▁return ▁maxlen ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁5 ▁, ▁k ▁= ▁2 ▁; ▁string ▁A ▁= ▁" ▁AB AB A ▁" ▁; ▁c out ▁<< ▁" ▁Maximum ▁length ▁= ▁" ▁<< ▁answer ▁( ▁A ▁, ▁n ▁, ▁k ▁) ▁<< ▁end l ▁; ▁n ▁= ▁6 ▁, ▁k ▁= ▁4 ▁; ▁string ▁B ▁= ▁" ▁HH HH HH ▁" ▁; ▁c out ▁<< ▁" ▁Maximum ▁length ▁= ▁" ▁<< ▁answer ▁( ▁B ▁, ▁n ▁, ▁k ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁replace Dig ▁( ▁int ▁x ▁, ▁int ▁from ▁, ▁int ▁to ▁) ▁{ ▁int ▁result ▁= ▁0 ▁; ▁int ▁multiply ▁= ▁1 ▁; ▁while ▁( ▁x ▁> ▁0 ▁) ▁{ ▁int ▁reminder ▁= ▁x ▁% ▁10 ▁; ▁if ▁( ▁reminder ▁== ▁from ▁) ▁result ▁= ▁result ▁+ ▁to ▁* ▁multiply ▁; ▁else ▁result ▁= ▁result ▁+ ▁reminder ▁* ▁multiply ▁; ▁multiply ▁*= ▁10 ▁; ▁x ▁= ▁x ▁/ ▁10 ▁; ▁} ▁return ▁result ▁; ▁} ▁void ▁calculate Min Max Sum ▁( ▁int ▁x 1 ▁, ▁int ▁x 2 ▁) ▁{ ▁int ▁min Sum ▁= ▁replace Dig ▁( ▁x 1 ▁, ▁6 ▁, ▁5 ▁) ▁+ ▁replace Dig ▁( ▁x 2 ▁, ▁6 ▁, ▁5 ▁) ▁; ▁int ▁max Sum ▁= ▁replace Dig ▁( ▁x 1 ▁, ▁5 ▁, ▁6 ▁) ▁+ ▁replace Dig ▁( ▁x 2 ▁, ▁5 ▁, ▁6 ▁) ▁; ▁c out ▁<< ▁" ▁Minimum ▁sum ▁= ▁" ▁<< ▁min Sum ▁; ▁c out ▁<< ▁" ▁n Maximum ▁sum ▁= ▁" ▁<< ▁max Sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁x 1 ▁= ▁54 66 ▁, ▁x 2 ▁= ▁4 555 ▁; ▁calculate Min Max Sum ▁( ▁x 1 ▁, ▁x 2 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁string ▁find Tw os com plement ▁( ▁string ▁str ▁) ▁{ ▁int ▁n ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁if ▁( ▁str ▁[ ▁i ▁] ▁== ▁'1' ▁) ▁break ▁; ▁if ▁( ▁i ▁== ▁-1 ▁) ▁return ▁'1' ▁+ ▁str ▁; ▁for ▁( ▁int ▁k ▁= ▁i ▁- ▁1 ▁; ▁k ▁>= ▁0 ▁; ▁k ▁-- ▁) ▁{ ▁if ▁( ▁str ▁[ ▁k ▁] ▁== ▁'1' ▁) ▁str ▁[ ▁k ▁] ▁= ▁'0' ▁; ▁else ▁str ▁[ ▁k ▁] ▁= ▁'1' ▁; ▁} ▁return ▁str ▁; ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" 000001 01" ▁; ▁c out ▁<< ▁find Tw os com plement ▁( ▁str ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁is Perf ect ▁( ▁int ▁x ▁) ▁{ ▁int ▁sum _ div ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁x ▁/ ▁2 ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁x ▁% ▁i ▁== ▁0 ▁) ▁{ ▁sum _ div ▁+= ▁i ▁; ▁} ▁} ▁if ▁( ▁sum _ div ▁== ▁x ▁) ▁{ ▁return ▁1 ▁; ▁} ▁else ▁return ▁0 ▁; ▁} ▁void ▁subset Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁long ▁long ▁total ▁= ▁1 ▁<< ▁n ▁; ▁for ▁( ▁long ▁long ▁i ▁= ▁0 ▁; ▁i ▁< ▁total ▁; ▁i ▁++ ▁) ▁{ ▁long ▁long ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁if ▁( ▁i ▁& ▁( ▁1 ▁<< ▁j ▁) ▁) ▁sum ▁+= ▁arr ▁[ ▁j ▁] ▁; ▁if ▁( ▁is Perf ect ▁( ▁sum ▁) ▁) ▁{ ▁c out ▁<< ▁sum ▁<< ▁" ▁" ▁; ▁} ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁4 ▁, ▁6 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁subset Sum ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁check Until ▁( ▁int ▁num ▁, ▁int ▁K ▁, ▁int ▁N ▁, ▁vector ▁< ▁int ▁> ▁& ▁ans ▁) ▁{ ▁if ▁( ▁N ▁== ▁1 ▁) ▁{ ▁ans ▁. ▁push _ back ▁( ▁num ▁) ▁; ▁return ▁; ▁} ▁if ▁( ▁( ▁num ▁% ▁10 ▁+ ▁K ▁) ▁<= ▁9 ▁) ▁check Until ▁( ▁10 ▁* ▁num ▁+ ▁( ▁num ▁% ▁10 ▁+ ▁K ▁) ▁, ▁K ▁, ▁N ▁- ▁1 ▁, ▁ans ▁) ▁; ▁if ▁( ▁K ▁) ▁{ ▁if ▁( ▁( ▁num ▁% ▁10 ▁- ▁K ▁) ▁>= ▁0 ▁) ▁check Until ▁( ▁10 ▁* ▁num ▁+ ▁num ▁% ▁10 ▁- ▁K ▁, ▁K ▁, ▁N ▁- ▁1 ▁, ▁ans ▁) ▁; ▁} ▁} ▁void ▁check ▁( ▁int ▁K ▁, ▁int ▁N ▁, ▁vector ▁< ▁int ▁> ▁& ▁ans ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁9 ▁; ▁i ▁++ ▁) ▁{ ▁check Until ▁( ▁i ▁, ▁K ▁, ▁N ▁, ▁ans ▁) ▁; ▁} ▁} ▁void ▁print ▁( ▁vector ▁< ▁int ▁> ▁& ▁ans ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁ans ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁c out ▁<< ▁ans ▁[ ▁i ▁] ▁<< ▁" ▁, ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁4 ▁, ▁K ▁= ▁8 ▁; ▁vector ▁< ▁int ▁> ▁ans ▁; ▁check ▁( ▁K ▁, ▁N ▁, ▁ans ▁) ▁; ▁print ▁( ▁ans ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< std io . h > ▁NEW _ LINE ▁# define ▁N ▁4 ▁NEW _ LINE ▁bool ▁solve M aze Util ▁( ▁int ▁maze ▁[ ▁N ▁] ▁[ ▁N ▁] ▁, ▁int ▁x ▁, ▁int ▁y ▁, ▁int ▁sol ▁[ ▁N ▁] ▁[ ▁N ▁] ▁) ▁; ▁void ▁print Solution ▁( ▁int ▁sol ▁[ ▁N ▁] ▁[ ▁N ▁] ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁printf ▁( ▁" ▁% ▁d ▁" ▁, ▁sol ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁; ▁printf ▁( ▁" ▁STRNEWLINE ▁" ▁) ▁; ▁} ▁} ▁bool ▁is Safe ▁( ▁int ▁maze ▁[ ▁N ▁] ▁[ ▁N ▁] ▁, ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁if ▁( ▁x ▁>= ▁0 ▁&& ▁x ▁< ▁N ▁&& ▁y ▁>= ▁0 ▁&& ▁y ▁< ▁N ▁&& ▁maze ▁[ ▁x ▁] ▁[ ▁y ▁] ▁!= ▁0 ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁bool ▁solve M aze ▁( ▁int ▁maze ▁[ ▁N ▁] ▁[ ▁N ▁] ▁) ▁{ ▁int ▁sol ▁[ ▁N ▁] ▁[ ▁N ▁] ▁= ▁{ ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁} ▁} ▁; ▁if ▁( ▁solve M aze Util ▁( ▁maze ▁, ▁0 ▁, ▁0 ▁, ▁sol ▁) ▁== ▁false ▁) ▁{ ▁printf ▁( ▁" ▁Solution ▁doesn ▁' ▁t ▁exist ▁" ▁) ▁; ▁return ▁false ▁; ▁} ▁print Solution ▁( ▁sol ▁) ▁; ▁return ▁true ▁; ▁} ▁bool ▁solve M aze Util ▁( ▁int ▁maze ▁[ ▁N ▁] ▁[ ▁N ▁] ▁, ▁int ▁x ▁, ▁int ▁y ▁, ▁int ▁sol ▁[ ▁N ▁] ▁[ ▁N ▁] ▁) ▁{ ▁if ▁( ▁x ▁== ▁N ▁- ▁1 ▁&& ▁y ▁== ▁N ▁- ▁1 ▁) ▁{ ▁sol ▁[ ▁x ▁] ▁[ ▁y ▁] ▁= ▁1 ▁; ▁return ▁true ▁; ▁} ▁if ▁( ▁is Safe ▁( ▁maze ▁, ▁x ▁, ▁y ▁) ▁== ▁true ▁) ▁{ ▁sol ▁[ ▁x ▁] ▁[ ▁y ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁maze ▁[ ▁x ▁] ▁[ ▁y ▁] ▁&& ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁solve M aze Util ▁( ▁maze ▁, ▁x ▁+ ▁i ▁, ▁y ▁, ▁sol ▁) ▁== ▁true ▁) ▁return ▁true ▁; ▁if ▁( ▁solve M aze Util ▁( ▁maze ▁, ▁x ▁, ▁y ▁+ ▁i ▁, ▁sol ▁) ▁== ▁true ▁) ▁return ▁true ▁; ▁} ▁sol ▁[ ▁x ▁] ▁[ ▁y ▁] ▁= ▁0 ▁; ▁return ▁false ▁; ▁} ▁return ▁false ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁maze ▁[ ▁N ▁] ▁[ ▁N ▁] ▁= ▁{ ▁{ ▁2 ▁, ▁1 ▁, ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁3 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁} ▁, ▁{ ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁} ▁, ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁} ▁} ▁; ▁solve M aze ▁( ▁maze ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁# define ▁maxSize ▁50 ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁vector ▁< ▁vector ▁< ▁double ▁> ▁> ▁matrix _ product ▁( ▁vector ▁< ▁vector ▁< ▁double ▁> ▁> ▁a ▁, ▁vector ▁< ▁vector ▁< ▁double ▁> ▁> ▁b ▁) ▁{ ▁vector ▁< ▁vector ▁< ▁double ▁> ▁> ▁c ▁( ▁7 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁7 ▁; ▁i ▁++ ▁) ▁c ▁[ ▁i ▁] ▁. ▁resize ▁( ▁7 ▁, ▁0 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁7 ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁7 ▁; ▁j ▁++ ▁) ▁for ▁( ▁int ▁k ▁= ▁0 ▁; ▁k ▁< ▁7 ▁; ▁k ▁++ ▁) ▁c ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+= ▁a ▁[ ▁i ▁] ▁[ ▁k ▁] ▁* ▁b ▁[ ▁k ▁] ▁[ ▁j ▁] ▁; ▁return ▁c ▁; ▁} ▁vector ▁< ▁vector ▁< ▁double ▁> ▁> ▁mul _ exp o ▁( ▁vector ▁< ▁vector ▁< ▁double ▁> ▁> ▁mul ▁, ▁int ▁p ▁) ▁{ ▁vector ▁< ▁vector ▁< ▁double ▁> ▁> ▁s ▁= ▁{ ▁{ ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁0 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁} ▁, ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁} ▁} ▁; ▁while ▁( ▁p ▁!= ▁1 ▁) ▁{ ▁if ▁( ▁p ▁% ▁2 ▁== ▁1 ▁) ▁s ▁= ▁matrix _ product ▁( ▁s ▁, ▁mul ▁) ▁; ▁mul ▁= ▁matrix _ product ▁( ▁mul ▁, ▁mul ▁) ▁; ▁p ▁/= ▁2 ▁; ▁} ▁return ▁matrix _ product ▁( ▁mul ▁, ▁s ▁) ▁; ▁} ▁double ▁expected Steps ▁( ▁int ▁x ▁) ▁{ ▁if ▁( ▁x ▁== ▁0 ▁) ▁return ▁0 ▁; ▁if ▁( ▁x ▁<= ▁6 ▁) ▁return ▁6 ▁; ▁vector ▁< ▁vector ▁< ▁double ▁> ▁> ▁mul ▁= ▁{ ▁{ ▁( ▁double ▁) ▁7 ▁/ ▁6 ▁, ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁0 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁} ▁, ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁} ▁, ▁{ ▁( ▁double ▁) ▁-1 ▁/ ▁6 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁} ▁} ▁; ▁mul ▁= ▁mul _ exp o ▁( ▁mul ▁, ▁x ▁- ▁6 ▁) ▁; ▁return ▁( ▁mul ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁+ ▁mul ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁+ ▁mul ▁[ ▁2 ▁] ▁[ ▁0 ▁] ▁+ ▁mul ▁[ ▁3 ▁] ▁[ ▁0 ▁] ▁+ ▁mul ▁[ ▁4 ▁] ▁[ ▁0 ▁] ▁+ ▁mul ▁[ ▁5 ▁] ▁[ ▁0 ▁] ▁) ▁* ▁6 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁10 ▁; ▁c out ▁<< ▁expected Steps ▁( ▁n ▁- ▁1 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁ll ▁long ▁long ▁NEW _ LINE ▁ll ▁F ▁( ▁ll ▁A ▁, ▁ll ▁B ▁) ▁{ ▁if ▁( ▁A ▁== ▁1 ▁) ▁return ▁( ▁4 ▁% ▁B ▁) ▁; ▁else ▁{ ▁ll ▁temp ▁= ▁F ▁( ▁A ▁- ▁1 ▁, ▁B ▁) ▁; ▁return ▁( ▁temp ▁* ▁temp ▁) ▁% ▁B ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁ll ▁A ▁= ▁25 ▁, ▁B ▁= ▁50 ▁; ▁c out ▁<< ▁F ▁( ▁A ▁, ▁B ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁binarySearch ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁left ▁, ▁int ▁right ▁) ▁{ ▁if ▁( ▁left ▁<= ▁right ▁) ▁{ ▁int ▁mid ▁= ▁( ▁left ▁+ ▁right ▁) ▁/ ▁2 ▁; ▁if ▁( ▁arr ▁[ ▁mid ▁- ▁1 ▁] ▁< ▁arr ▁[ ▁mid ▁] ▁&& ▁arr ▁[ ▁mid ▁] ▁> ▁arr ▁[ ▁mid ▁+ ▁1 ▁] ▁) ▁return ▁mid ▁; ▁if ▁( ▁arr ▁[ ▁mid ▁] ▁< ▁arr ▁[ ▁mid ▁+ ▁1 ▁] ▁) ▁return ▁binarySearch ▁( ▁arr ▁, ▁mid ▁+ ▁1 ▁, ▁right ▁) ▁; ▁else ▁return ▁binarySearch ▁( ▁arr ▁, ▁left ▁, ▁mid ▁- ▁1 ▁) ▁; ▁} ▁return ▁-1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁6 ▁, ▁7 ▁, ▁8 ▁, ▁11 ▁, ▁9 ▁, ▁5 ▁, ▁2 ▁, ▁1 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁index ▁= ▁binarySearch ▁( ▁arr ▁, ▁1 ▁, ▁n ▁- ▁2 ▁) ▁; ▁if ▁( ▁index ▁!= ▁-1 ▁) ▁c out ▁<< ▁arr ▁[ ▁index ▁] ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁isP ossible To Re ach ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁X ▁, ▁int ▁Y ▁) ▁{ ▁double ▁distance ▁= ▁sqrt ▁( ▁double ▁( ▁X ▁* ▁X ▁+ ▁Y ▁* ▁Y ▁) ▁) ▁; ▁double ▁mx ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁mx ▁+= ▁double ▁( ▁A ▁[ ▁i ▁] ▁) ▁; ▁} ▁if ▁( ▁mx ▁< ▁distance ▁) ▁{ ▁c out ▁<< ▁" ▁NO ▁" ▁; ▁return ▁0 ▁; ▁} ▁if ▁( ▁( ▁mx ▁- ▁distance ▁) ▁< ▁0. 000001 ▁) ▁{ ▁c out ▁<< ▁" ▁YES ▁" ▁; ▁return ▁0 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁distance ▁+ ▁mx ▁< ▁double ▁( ▁2 ▁) ▁* ▁double ▁( ▁A ▁[ ▁i ▁] ▁) ▁) ▁{ ▁c out ▁<< ▁" ▁No ▁" ▁; ▁return ▁0 ▁; ▁} ▁} ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁return ▁0 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁5 ▁} ▁; ▁int ▁X ▁= ▁5 ▁, ▁Y ▁= ▁4 ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁A ▁) ▁/ ▁sizeof ▁( ▁A ▁[ ▁0 ▁] ▁) ▁; ▁isP ossible To Re ach ▁( ▁A ▁, ▁N ▁, ▁X ▁, ▁Y ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< cm ath > ▁NEW _ LINE ▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁double ▁point _ distance ▁( ▁int ▁x 1 ▁, ▁int ▁y 1 ▁, ▁int ▁x 2 ▁, ▁int ▁y 2 ▁) ▁{ ▁int ▁p ▁= ▁( ▁x 2 ▁- ▁x 1 ▁) ▁; ▁int ▁q ▁= ▁( ▁y 2 ▁- ▁y 1 ▁) ▁; ▁double ▁distance ▁= ▁sqrt ▁( ▁p ▁* ▁p ▁+ ▁q ▁* ▁q ▁) ▁; ▁return ▁distance ▁; ▁} ▁void ▁tang ent Angle ▁( ▁int ▁x 1 ▁, ▁int ▁y 1 ▁, ▁int ▁x 2 ▁, ▁int ▁y 2 ▁, ▁double ▁radius ▁) ▁{ ▁double ▁distance ▁= ▁point _ distance ▁( ▁x 1 ▁, ▁y 1 ▁, ▁x 2 ▁, ▁y 2 ▁) ▁; ▁if ▁( ▁radius ▁/ ▁distance ▁> ▁1 ▁radius ▁/ ▁distance ▁< ▁-1 ▁) ▁{ ▁c out ▁<< ▁-1 ▁; ▁} ▁double ▁result ▁= ▁2 ▁* ▁as in ▁( ▁radius ▁/ ▁distance ▁) ▁* ▁180 ▁/ ▁3.14 15 ▁; ▁c out ▁<< ▁result ▁<< ▁" ▁degrees ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁radius ▁= ▁4 ▁; ▁int ▁x 1 ▁= ▁7 ▁, ▁y 1 ▁= ▁12 ▁; ▁int ▁x 2 ▁= ▁3 ▁, ▁y 2 ▁= ▁4 ▁; ▁tang ent Angle ▁( ▁x 1 ▁, ▁y 1 ▁, ▁x 2 ▁, ▁y 2 ▁, ▁radius ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁RAD IAN ▁0.0 17 45 329 252 ▁NEW _ LINE ▁float ▁Area _ of _ R h omb us ▁( ▁int ▁a ▁, ▁int ▁theta ▁) ▁{ ▁float ▁area ▁= ▁( ▁a ▁* ▁a ▁) ▁* ▁sin ▁( ▁( ▁RAD IAN ▁* ▁theta ▁) ▁) ▁; ▁return ▁area ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁= ▁4 ▁; ▁int ▁theta ▁= ▁60 ▁; ▁float ▁ans ▁= ▁Area _ of _ R h omb us ▁( ▁a ▁, ▁theta ▁) ▁; ▁printf ▁( ▁" ▁% ▁0.2 f ▁" ▁, ▁ans ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁PI ▁3.1 47 ▁NEW _ LINE ▁double ▁Length _ Diag onal ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁double ▁theta ▁) ▁{ ▁double ▁diagonal ▁= ▁sqrt ▁( ▁( ▁pow ▁( ▁a ▁, ▁2 ▁) ▁+ ▁pow ▁( ▁b ▁, ▁2 ▁) ▁) ▁- ▁2 ▁* ▁a ▁* ▁b ▁* ▁cos ▁( ▁theta ▁* ▁( ▁PI ▁/ ▁180 ▁) ▁) ▁) ▁; ▁return ▁diagonal ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁= ▁3 ▁; ▁int ▁b ▁= ▁5 ▁; ▁double ▁theta ▁= ▁45 ▁; ▁double ▁ans ▁= ▁Length _ Diag onal ▁( ▁a ▁, ▁b ▁, ▁theta ▁) ▁; ▁printf ▁( ▁" ▁% ▁.2 f ▁" ▁, ▁ans ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁maximum Tiles ▁( ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁c out ▁<< ▁( ▁m ▁* ▁n ▁) ▁/ ▁2 ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁M ▁= ▁3 ▁; ▁int ▁N ▁= ▁4 ▁; ▁maximum Tiles ▁( ▁N ▁, ▁M ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁double ▁find ▁( ▁double ▁x ▁, ▁double ▁y ▁, ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁& ▁p ▁) ▁{ ▁double ▁mind ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁p ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁double ▁a ▁= ▁p ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁, ▁b ▁= ▁p ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁; ▁mind ▁+= ▁sqrt ▁( ▁( ▁x ▁- ▁a ▁) ▁* ▁( ▁x ▁- ▁a ▁) ▁+ ▁( ▁y ▁- ▁b ▁) ▁* ▁( ▁y ▁- ▁b ▁) ▁) ▁; ▁} ▁return ▁mind ▁; ▁} ▁double ▁getMin Dist Sum ▁( ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁& ▁p ▁) ▁{ ▁double ▁x ▁= ▁0 ▁, ▁y ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁p ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁x ▁+= ▁p ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁; ▁y ▁+= ▁p ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁; ▁} ▁x ▁= ▁x ▁/ ▁p ▁. ▁size ▁( ▁) ▁; ▁y ▁= ▁y ▁/ ▁p ▁. ▁size ▁( ▁) ▁; ▁double ▁mind ▁= ▁find ▁( ▁x ▁, ▁y ▁, ▁p ▁) ▁; ▁return ▁mind ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁vec ▁= ▁{ ▁{ ▁0 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁0 ▁} ▁, ▁{ ▁1 ▁, ▁2 ▁} ▁, ▁{ ▁2 ▁, ▁1 ▁} ▁} ▁; ▁double ▁d ▁= ▁getMin Dist Sum ▁( ▁vec ▁) ▁; ▁c out ▁<< ▁d ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁fact ▁( ▁int ▁n ▁) ▁{ ▁int ▁res ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁< ▁n ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁res ▁= ▁res ▁* ▁i ▁; ▁return ▁res ▁; ▁} ▁int ▁n Cr ▁( ▁int ▁n ▁, ▁int ▁r ▁) ▁{ ▁return ▁( ▁fact ▁( ▁n ▁) ▁/ ▁( ▁fact ▁( ▁r ▁) ▁* ▁fact ▁( ▁n ▁- ▁r ▁) ▁) ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁5 ▁; ▁c out ▁<< ▁( ▁n Cr ▁( ▁n ▁, ▁4 ▁) ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁area Square ▁( ▁int ▁L ▁, ▁int ▁B ▁) ▁{ ▁int ▁large ▁= ▁max ▁( ▁L ▁, ▁B ▁) ▁; ▁int ▁small ▁= ▁min ▁( ▁L ▁, ▁B ▁) ▁; ▁if ▁( ▁large ▁>= ▁2 ▁* ▁small ▁) ▁return ▁large ▁* ▁large ▁; ▁else ▁return ▁( ▁2 ▁* ▁small ▁) ▁* ▁( ▁2 ▁* ▁small ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁L ▁= ▁7 ▁; ▁int ▁B ▁= ▁4 ▁; ▁c out ▁<< ▁area Square ▁( ▁L ▁, ▁B ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁double ▁pie ▁= ▁3.14 159 265 35 89 7 ▁; ▁double ▁finds olution ▁( ▁double ▁d ▁, ▁double ▁h ▁, ▁double ▁m ▁, ▁double ▁n ▁) ▁{ ▁double ▁k ▁= ▁( ▁4 ▁* ▁m ▁) ▁/ ▁( ▁pie ▁* ▁d ▁* ▁d ▁) ▁; ▁if ▁( ▁n ▁> ▁k ▁) ▁return ▁-1 ▁; ▁double ▁ans ▁= ▁( ▁h ▁/ ▁( ▁k ▁- ▁n ▁) ▁) ▁; ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁double ▁d ▁= ▁1 ▁, ▁h ▁= ▁1 ▁, ▁m ▁= ▁1 ▁, ▁n ▁= ▁1 ▁; ▁c out ▁<< ▁finds olution ▁( ▁d ▁, ▁h ▁, ▁m ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁angle ▁( ▁int ▁n ▁) ▁{ ▁return ▁2 ▁* ▁n ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁30 ▁; ▁c out ▁<< ▁angle ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁Valid ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁int ▁c ▁, ▁int ▁d ▁) ▁{ ▁if ▁( ▁a ▁+ ▁b ▁+ ▁c ▁+ ▁d ▁== ▁360 ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁= ▁80 ▁, ▁b ▁= ▁70 ▁, ▁c ▁= ▁100 ▁, ▁d ▁= ▁110 ▁; ▁if ▁( ▁Valid ▁( ▁a ▁, ▁b ▁, ▁c ▁, ▁d ▁) ▁) ▁c out ▁<< ▁" ▁Valid ▁quad r il ater al ▁" ▁; ▁else ▁c out ▁<< ▁" ▁Invalid ▁quad r il ater al ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁len g ch ord ▁( ▁int ▁z ▁) ▁{ ▁c out ▁<< ▁" ▁The ▁length ▁is ▁" ▁<< ▁z ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁z ▁= ▁48 ▁; ▁len g ch ord ▁( ▁z ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Pairs ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁map ▁< ▁double ▁, ▁int ▁> ▁mp ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁y ▁= ▁a ▁[ ▁i ▁] ▁; ▁if ▁( ▁y ▁!= ▁0 ▁&& ▁y ▁!= ▁1 ▁) ▁{ ▁double ▁x ▁= ▁( ▁( ▁y ▁* ▁1.0 ▁) ▁/ ▁( ▁1 ▁- ▁y ▁) ▁) ▁* ▁y ▁; ▁count ▁+= ▁mp ▁[ ▁x ▁] ▁; ▁} ▁mp ▁[ ▁y ▁] ▁++ ▁; ▁} ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁-4 ▁, ▁-3 ▁, ▁0 ▁, ▁2 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁count Pairs ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁contains ▁( ▁int ▁num ▁, ▁int ▁K ▁, ▁int ▁base ▁) ▁{ ▁bool ▁is There ▁= ▁0 ▁; ▁while ▁( ▁num ▁) ▁{ ▁int ▁remainder ▁= ▁num ▁% ▁base ▁; ▁if ▁( ▁remainder ▁== ▁K ▁) ▁{ ▁is There ▁= ▁1 ▁; ▁} ▁num ▁/= ▁base ▁; ▁} ▁return ▁is There ▁; ▁} ▁void ▁count ▁( ▁int ▁n ▁, ▁int ▁k ▁, ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁v ▁) ▁{ ▁int ▁pref ▁[ ▁100000 5 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁1 e 6 ▁+ ▁5 ▁; ▁i ▁++ ▁) ▁{ ▁bool ▁present ▁= ▁contains ▁( ▁i ▁, ▁k ▁, ▁10 ▁) ▁|| ▁contains ▁( ▁i ▁, ▁k ▁, ▁8 ▁) ▁; ▁pref ▁[ ▁i ▁] ▁+= ▁pref ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁present ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁{ ▁c out ▁<< ▁v ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁- ▁v ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁+ ▁1 ▁- ▁( ▁pref ▁[ ▁v ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁] ▁- ▁pref ▁[ ▁v ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁- ▁1 ▁] ▁) ▁<< ▁' ▁' ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁K ▁= ▁7 ▁; ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁Q ▁= ▁{ ▁{ ▁2 ▁, ▁5 ▁} ▁, ▁{ ▁1 ▁, ▁15 ▁} ▁} ▁; ▁int ▁N ▁= ▁Q ▁. ▁size ▁( ▁) ▁; ▁count ▁( ▁N ▁, ▁K ▁, ▁Q ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁pr onic ▁( ▁int ▁num ▁) ▁{ ▁int ▁N ▁= ▁( ▁int ▁) ▁sqrt ▁( ▁num ▁) ▁; ▁if ▁( ▁N ▁* ▁( ▁N ▁+ ▁1 ▁) ▁<= ▁num ▁) ▁{ ▁return ▁N ▁; ▁} ▁return ▁N ▁- ▁1 ▁; ▁} ▁int ▁count P ron ic ▁( ▁int ▁A ▁, ▁int ▁B ▁) ▁{ ▁return ▁pr onic ▁( ▁B ▁) ▁- ▁pr onic ▁( ▁A ▁- ▁1 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁= ▁3 ▁; ▁int ▁B ▁= ▁20 ▁; ▁c out ▁<< ▁count P ron ic ▁( ▁A ▁, ▁B ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁minimum M oves ▁( ▁int ▁* ▁a ▁, ▁int ▁n ▁) ▁{ ▁int ▁min _ element ▁= ▁INT _ MAX ▁; ▁int ▁max _ element ▁= ▁INT _ MIN ▁; ▁int ▁min _ ind ▁= ▁-1 ▁; ▁int ▁max _ ind ▁= ▁-1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁<= ▁min _ element ▁) ▁{ ▁min _ element ▁= ▁a ▁[ ▁i ▁] ▁; ▁min _ ind ▁= ▁i ▁; ▁} ▁if ▁( ▁a ▁[ ▁i ▁] ▁> ▁max _ element ▁) ▁{ ▁max _ element ▁= ▁a ▁[ ▁i ▁] ▁; ▁max _ ind ▁= ▁i ▁; ▁} ▁} ▁if ▁( ▁max _ ind ▁== ▁min _ ind ▁) ▁{ ▁return ▁0 ▁; ▁} ▁else ▁if ▁( ▁max _ ind ▁> ▁min _ ind ▁) ▁{ ▁return ▁max _ ind ▁+ ▁( ▁n ▁- ▁min _ ind ▁- ▁2 ▁) ▁; ▁} ▁else ▁{ ▁return ▁max _ ind ▁+ ▁n ▁- ▁min _ ind ▁- ▁1 ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁35 ▁, ▁46 ▁, ▁17 ▁, ▁23 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁minimum M oves ▁( ▁arr ▁, ▁N ▁) ▁<< ▁end l ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Index ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁K ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁int ▁res ▁= ▁-1 ▁; ▁int ▁mini ▁= ▁1 e 9 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁temp ▁= ▁sum ▁- ▁arr ▁[ ▁i ▁] ▁; ▁if ▁( ▁temp ▁% ▁K ▁== ▁0 ▁) ▁{ ▁if ▁( ▁res ▁== ▁-1 ▁mini ▁> ▁arr ▁[ ▁i ▁] ▁) ▁{ ▁res ▁= ▁i ▁+ ▁1 ▁; ▁mini ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁} ▁} ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁14 ▁, ▁7 ▁, ▁8 ▁, ▁2 ▁, ▁4 ▁} ▁; ▁int ▁K ▁= ▁7 ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁find Index ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁# include ▁< math . h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Set Bits ▁( ▁int ▁N ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁while ▁( ▁N ▁) ▁{ ▁N ▁= ▁N ▁& ▁( ▁N ▁- ▁1 ▁) ▁; ▁count ▁++ ▁; ▁} ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁4 ▁; ▁int ▁bits ▁= ▁count Set Bits ▁( ▁N ▁) ▁; ▁c out ▁<< ▁" ▁O dd ▁" ▁<< ▁" ▁: ▁" ▁<< ▁pow ▁( ▁2 ▁, ▁bits ▁) ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁c out ▁<< ▁" ▁Even ▁" ▁<< ▁" ▁: ▁" ▁<< ▁N ▁+ ▁1 ▁- ▁pow ▁( ▁2 ▁, ▁bits ▁) ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁long ▁double ▁find _ V ariance ▁( ▁int ▁n ▁) ▁{ ▁long ▁long ▁int ▁numerator ▁= ▁n ▁* ▁n ▁- ▁1 ▁; ▁long ▁double ▁ans ▁= ▁( ▁numerator ▁* ▁1.0 ▁) ▁/ ▁12 ▁; ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁5 ▁; ▁c out ▁<< ▁fixed ▁<< ▁set precision ▁( ▁6 ▁) ▁<< ▁find _ V ariance ▁( ▁N ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁unordered _ map ▁< ▁int ▁, ▁int ▁> ▁mp ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁mp ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁++ ▁; ▁} ▁int ▁sum _ odd ▁= ▁0 ▁, ▁sum _ even ▁= ▁0 ▁; ▁for ▁( ▁auto ▁itr ▁= ▁mp ▁. ▁begin ▁( ▁) ▁; ▁itr ▁!= ▁mp ▁. ▁end ▁( ▁) ▁; ▁itr ▁++ ▁) ▁{ ▁if ▁( ▁itr ▁-> ▁second ▁% ▁2 ▁!= ▁0 ▁) ▁sum _ odd ▁+= ▁( ▁itr ▁-> ▁first ▁) ▁* ▁( ▁itr ▁-> ▁second ▁) ▁; ▁if ▁( ▁itr ▁-> ▁second ▁% ▁2 ▁== ▁0 ▁) ▁sum _ even ▁+= ▁( ▁itr ▁-> ▁first ▁) ▁* ▁( ▁itr ▁-> ▁second ▁) ▁; ▁} ▁int ▁diff ▁= ▁sum _ even ▁- ▁sum _ odd ▁; ▁return ▁diff ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁5 ▁, ▁5 ▁, ▁2 ▁, ▁4 ▁, ▁3 ▁, ▁3 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁find Sum ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find Sum ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁1 ▁) ▁{ ▁c out ▁<< ▁a ▁; ▁return ▁; ▁} ▁int ▁s ▁= ▁a ▁+ ▁b ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁int ▁x ▁= ▁a ▁xor ▁b ▁; ▁s ▁+= ▁x ▁; ▁a ▁= ▁b ▁; ▁b ▁= ▁x ▁; ▁} ▁c out ▁<< ▁s ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁= ▁2 ▁, ▁b ▁= ▁5 ▁, ▁N ▁= ▁8 ▁; ▁find Sum ▁( ▁a ▁, ▁b ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁unsigned ▁int ▁ones Com plement ▁( ▁unsigned ▁int ▁n ▁, ▁int ▁max Element ▁) ▁{ ▁int ▁bits ▁= ▁floor ▁( ▁log 2 ▁( ▁max Element ▁) ▁) ▁+ ▁1 ▁; ▁return ▁( ▁( ▁1 ▁<< ▁bits ▁) ▁- ▁1 ▁) ▁^ ▁n ▁; ▁} ▁int ▁find Number ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁unsigned ▁int ▁res ▁= ▁0 ▁; ▁int ▁max Element ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁res ▁= ▁res ▁^ ▁arr ▁[ ▁i ▁] ▁; ▁if ▁( ▁max Element ▁< ▁arr ▁[ ▁i ▁] ▁) ▁max Element ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁res ▁= ▁ones Com plement ▁( ▁res ▁, ▁max Element ▁) ▁; ▁return ▁( ▁res ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁find Number ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find The Gre at est X ▁( ▁int ▁P ▁, ▁int ▁Q ▁) ▁{ ▁map ▁< ▁int ▁, ▁int ▁> ▁div isi ors ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁* ▁i ▁<= ▁Q ▁; ▁i ▁++ ▁) ▁{ ▁while ▁( ▁Q ▁% ▁i ▁== ▁0 ▁and ▁Q ▁> ▁1 ▁) ▁{ ▁Q ▁/= ▁i ▁; ▁div isi ors ▁[ ▁i ▁] ▁++ ▁; ▁} ▁} ▁if ▁( ▁Q ▁> ▁1 ▁) ▁div isi ors ▁[ ▁Q ▁] ▁++ ▁; ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁auto ▁i ▁: ▁div isi ors ▁) ▁{ ▁int ▁frequency ▁= ▁i ▁. ▁second ▁; ▁int ▁temp ▁= ▁P ▁; ▁int ▁cur ▁= ▁0 ▁; ▁while ▁( ▁temp ▁% ▁i ▁. ▁first ▁== ▁0 ▁) ▁{ ▁temp ▁/= ▁i ▁. ▁first ▁; ▁cur ▁++ ▁; ▁} ▁if ▁( ▁cur ▁< ▁frequency ▁) ▁{ ▁ans ▁= ▁P ▁; ▁break ▁; ▁} ▁temp ▁= ▁P ▁; ▁for ▁( ▁int ▁j ▁= ▁cur ▁; ▁j ▁>= ▁frequency ▁; ▁j ▁-- ▁) ▁{ ▁temp ▁/= ▁i ▁. ▁first ▁; ▁} ▁ans ▁= ▁max ▁( ▁temp ▁, ▁ans ▁) ▁; ▁} ▁c out ▁<< ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁P ▁= ▁10 ▁, ▁Q ▁= ▁4 ▁; ▁find The Gre at est X ▁( ▁P ▁, ▁Q ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count X OR Set Bits Adj Elem Range 1_ N ▁( ▁int ▁N ▁) ▁{ ▁int ▁total _ set _ bits ▁= ▁0 ▁; ▁int ▁bit _ Position ▁= ▁1 ▁; ▁while ▁( ▁N ▁) ▁{ ▁total _ set _ bits ▁+= ▁( ▁( ▁N ▁+ ▁1 ▁) ▁/ ▁2 ▁* ▁bit _ Position ▁) ▁; ▁N ▁-= ▁( ▁N ▁+ ▁1 ▁) ▁/ ▁2 ▁; ▁bit _ Position ▁++ ▁; ▁} ▁return ▁total _ set _ bits ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁4 ▁; ▁c out ▁<< ▁count X OR Set Bits Adj Elem Range 1_ N ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁size _ int ▁32 ▁NEW _ LINE ▁int ▁function Max ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁vector ▁< ▁int ▁> ▁set Bit ▁[ ▁32 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁size _ int ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁& ▁( ▁1 ▁<< ▁j ▁) ▁) ▁set Bit ▁[ ▁j ▁] ▁. ▁push _ back ▁( ▁i ▁) ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁size _ int ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁set Bit ▁[ ▁i ▁] ▁. ▁size ▁( ▁) ▁== ▁1 ▁) ▁{ ▁swap ▁( ▁arr ▁[ ▁0 ▁] ▁, ▁arr ▁[ ▁set Bit ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁] ▁) ▁; ▁break ▁; ▁} ▁} ▁int ▁max And ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁max And ▁= ▁max And ▁& ▁( ▁~ ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁return ▁max And ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁4 ▁, ▁8 ▁, ▁16 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁arr ▁/ ▁sizeof ▁arr ▁[ ▁0 ▁] ▁; ▁c out ▁<< ▁function Max ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁highest Power ▁( ▁int ▁n ▁) ▁{ ▁return ▁log ▁( ▁n ▁) ▁/ ▁log ▁( ▁2 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁15 ▁; ▁c out ▁<< ▁highest Power ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print ▁( ▁int ▁N ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁100000 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁pow ▁( ▁i ▁+ ▁1 ▁, ▁3 ▁) ▁- ▁pow ▁( ▁i ▁, ▁3 ▁) ▁== ▁N ▁) ▁{ ▁c out ▁<< ▁i ▁<< ▁' ▁' ▁<< ▁i ▁+ ▁1 ▁; ▁return ▁; ▁} ▁} ▁} ▁bool ▁is Perf ect Square ▁( ▁long ▁double ▁x ▁) ▁{ ▁long ▁double ▁sr ▁= ▁sqrt ▁( ▁x ▁) ▁; ▁return ▁( ▁( ▁sr ▁- ▁floor ▁( ▁sr ▁) ▁) ▁== ▁0 ▁) ▁; ▁} ▁bool ▁diff Cube ▁( ▁int ▁N ▁) ▁{ ▁return ▁is Perf ect Square ▁( ▁12 ▁* ▁N ▁- ▁3 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁19 ▁; ▁if ▁( ▁diff Cube ▁( ▁N ▁) ▁) ▁{ ▁c out ▁<< ▁" ▁Yes ▁STRNEWLINE ▁" ▁; ▁print ▁( ▁N ▁) ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁" ▁No ▁STRNEWLINE ▁" ▁; ▁} ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is _ possible ▁( ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁if ▁( ▁x ▁< ▁2 ▁&& ▁y ▁!= ▁0 ▁) ▁return ▁false ▁; ▁y ▁= ▁y ▁- ▁x ▁+ ▁1 ▁; ▁if ▁( ▁y ▁% ▁2 ▁== ▁0 ▁&& ▁y ▁>= ▁0 ▁) ▁return ▁true ▁; ▁else ▁return ▁false ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁x ▁= ▁5 ▁, ▁y ▁= ▁2 ▁; ▁if ▁( ▁is _ possible ▁( ▁x ▁, ▁y ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁class ▁Node ▁{ ▁public ▁: ▁int ▁data ▁; ▁Node ▁* ▁left ▁, ▁* ▁right ▁; ▁Node ▁( ▁int ▁data ▁, ▁Node ▁* ▁left ▁, ▁Node ▁* ▁right ▁) ▁{ ▁this ▁-> ▁data ▁= ▁data ▁; ▁this ▁-> ▁left ▁= ▁left ▁; ▁this ▁-> ▁right ▁= ▁right ▁; ▁} ▁} ▁; ▁Node ▁* ▁newNode ▁( ▁int ▁data ▁) ▁{ ▁Node ▁* ▁tmp ▁= ▁new ▁Node ▁( ▁data ▁, ▁NULL ▁, ▁NULL ▁) ▁; ▁return ▁tmp ▁; ▁} ▁void ▁in order ▁( ▁Node ▁* ▁node ▁) ▁{ ▁if ▁( ▁node ▁== ▁NULL ▁) ▁return ▁; ▁in order ▁( ▁node ▁-> ▁left ▁) ▁; ▁c out ▁<< ▁node ▁-> ▁data ▁<< ▁" ▁" ▁; ▁in order ▁( ▁node ▁-> ▁right ▁) ▁; ▁} ▁Node ▁* ▁Maximum Binary Tree ▁( ▁Node ▁* ▁t 1 ▁, ▁Node ▁* ▁t 2 ▁) ▁{ ▁if ▁( ▁t 1 ▁== ▁NULL ▁) ▁return ▁t 2 ▁; ▁if ▁( ▁t 2 ▁== ▁NULL ▁) ▁return ▁t 1 ▁; ▁t 1 ▁-> ▁data ▁= ▁max ▁( ▁t 1 ▁-> ▁data ▁, ▁t 2 ▁-> ▁data ▁) ▁; ▁t 1 ▁-> ▁left ▁= ▁Maximum Binary Tree ▁( ▁t 1 ▁-> ▁left ▁, ▁t 2 ▁-> ▁left ▁) ▁; ▁t 1 ▁-> ▁right ▁= ▁Maximum Binary Tree ▁( ▁t 1 ▁-> ▁right ▁, ▁t 2 ▁-> ▁right ▁) ▁; ▁return ▁t 1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁Node ▁* ▁root 1 ▁= ▁newNode ▁( ▁3 ▁) ▁; ▁root 1 ▁-> ▁left ▁= ▁newNode ▁( ▁2 ▁) ▁; ▁root 1 ▁-> ▁right ▁= ▁newNode ▁( ▁6 ▁) ▁; ▁root 1 ▁-> ▁left ▁-> ▁left ▁= ▁newNode ▁( ▁20 ▁) ▁; ▁Node ▁* ▁root 2 ▁= ▁newNode ▁( ▁5 ▁) ▁; ▁root 2 ▁-> ▁left ▁= ▁newNode ▁( ▁1 ▁) ▁; ▁root 2 ▁-> ▁right ▁= ▁newNode ▁( ▁8 ▁) ▁; ▁root 2 ▁-> ▁left ▁-> ▁right ▁= ▁newNode ▁( ▁2 ▁) ▁; ▁root 2 ▁-> ▁right ▁-> ▁right ▁= ▁newNode ▁( ▁8 ▁) ▁; ▁Node ▁* ▁root 3 ▁= ▁Maximum Binary Tree ▁( ▁root 1 ▁, ▁root 2 ▁) ▁; ▁in order ▁( ▁root 3 ▁) ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁power Opt im ised ▁( ▁int ▁a ▁, ▁int ▁n ▁) ▁{ ▁int ▁ans ▁= ▁1 ▁; ▁while ▁( ▁n ▁> ▁0 ▁) ▁{ ▁int ▁last _ bit ▁= ▁( ▁n ▁& ▁1 ▁) ▁; ▁if ▁( ▁last _ bit ▁) ▁{ ▁ans ▁= ▁ans ▁* ▁a ▁; ▁} ▁a ▁= ▁a ▁* ▁a ▁; ▁n ▁= ▁n ▁>> ▁1 ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁= ▁3 ▁, ▁n ▁= ▁5 ▁; ▁c out ▁<< ▁power Opt im ised ▁( ▁a ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁gcd ▁( ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁if ▁( ▁x ▁== ▁0 ▁) ▁return ▁y ▁; ▁return ▁gcd ▁( ▁y ▁% ▁x ▁, ▁x ▁) ▁; ▁} ▁int ▁find Distinct ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁maximum ▁= ▁* ▁max _ element ▁( ▁arr ▁, ▁arr ▁+ ▁n ▁) ▁; ▁if ▁( ▁n ▁== ▁1 ▁) ▁return ▁1 ▁; ▁if ▁( ▁n ▁== ▁2 ▁) ▁{ ▁return ▁( ▁maximum ▁/ ▁gcd ▁( ▁arr ▁[ ▁0 ▁] ▁, ▁arr ▁[ ▁1 ▁] ▁) ▁) ▁; ▁} ▁int ▁k ▁= ▁gcd ▁( ▁arr ▁[ ▁0 ▁] ▁, ▁arr ▁[ ▁1 ▁] ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁k ▁= ▁gcd ▁( ▁k ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁return ▁( ▁maximum ▁/ ▁k ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁find Distinct ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁l li ▁long ▁long ▁int ▁NEW _ LINE ▁void ▁isEqual Fact ors ▁( ▁l li ▁N ▁) ▁{ ▁l li ▁ev _ count ▁= ▁0 ▁, ▁od _ count ▁= ▁0 ▁; ▁for ▁( ▁l li ▁i ▁= ▁1 ▁; ▁i ▁<= ▁sqrt ▁( ▁N ▁) ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁N ▁% ▁i ▁== ▁0 ▁) ▁{ ▁if ▁( ▁i ▁== ▁N ▁/ ▁i ▁) ▁{ ▁if ▁( ▁i ▁% ▁2 ▁== ▁0 ▁) ▁ev _ count ▁+= ▁1 ▁; ▁else ▁od _ count ▁+= ▁1 ▁; ▁} ▁else ▁{ ▁if ▁( ▁i ▁% ▁2 ▁== ▁0 ▁) ▁ev _ count ▁+= ▁1 ▁; ▁else ▁od _ count ▁+= ▁1 ▁; ▁if ▁( ▁( ▁N ▁/ ▁i ▁) ▁% ▁2 ▁== ▁0 ▁) ▁ev _ count ▁+= ▁1 ▁; ▁else ▁od _ count ▁+= ▁1 ▁; ▁} ▁} ▁} ▁if ▁( ▁ev _ count ▁== ▁od _ count ▁) ▁c out ▁<< ▁" ▁YES ▁" ▁<< ▁end l ▁; ▁else ▁c out ▁<< ▁" ▁NO ▁" ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁l li ▁N ▁= ▁10 ▁; ▁isEqual Fact ors ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max OR ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁max _ value ▁= ▁* ▁max _ element ▁( ▁arr ▁, ▁arr ▁+ ▁n ▁) ▁; ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁ans ▁= ▁max ▁( ▁ans ▁, ▁( ▁max _ value ▁arr ▁[ ▁i ▁] ▁) ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁6 ▁, ▁8 ▁, ▁16 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁max OR ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁getSum ▁( ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁sqrt ▁( ▁n ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁{ ▁if ▁( ▁n ▁/ ▁i ▁== ▁i ▁) ▁sum ▁= ▁sum ▁+ ▁i ▁; ▁{ ▁sum ▁= ▁sum ▁+ ▁i ▁; ▁sum ▁= ▁sum ▁+ ▁( ▁n ▁/ ▁i ▁) ▁; ▁} ▁} ▁} ▁return ▁sum ▁; ▁} ▁bool ▁check Ab undant ▁( ▁int ▁n ▁) ▁{ ▁return ▁( ▁getSum ▁( ▁n ▁) ▁- ▁n ▁> ▁n ▁) ▁; ▁} ▁bool ▁is Def icient ▁( ▁int ▁n ▁) ▁{ ▁return ▁( ▁getSum ▁( ▁n ▁) ▁< ▁( ▁2 ▁* ▁n ▁) ▁) ▁; ▁} ▁bool ▁check Primitive Ab undant ▁( ▁int ▁num ▁) ▁{ ▁if ▁( ▁! ▁check Ab undant ▁( ▁num ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁sqrt ▁( ▁num ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁num ▁% ▁i ▁== ▁0 ▁&& ▁i ▁!= ▁num ▁) ▁{ ▁if ▁( ▁i ▁* ▁i ▁== ▁num ▁) ▁{ ▁if ▁( ▁! ▁is Def icient ▁( ▁i ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁} ▁else ▁if ▁( ▁! ▁is Def icient ▁( ▁i ▁) ▁|| ▁! ▁is Def icient ▁( ▁num ▁/ ▁i ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁} ▁} ▁return ▁true ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁20 ▁; ▁if ▁( ▁check Primitive Ab undant ▁( ▁n ▁) ▁) ▁{ ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁" ▁No ▁" ▁; ▁} ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁div Sum ▁( ▁int ▁num ▁) ▁{ ▁int ▁result ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁sqrt ▁( ▁num ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁num ▁% ▁i ▁== ▁0 ▁) ▁{ ▁if ▁( ▁i ▁== ▁( ▁num ▁/ ▁i ▁) ▁) ▁result ▁+= ▁i ▁; ▁else ▁result ▁+= ▁( ▁i ▁+ ▁num ▁/ ▁i ▁) ▁; ▁} ▁} ▁return ▁( ▁result ▁- ▁1 ▁- ▁num ▁) ▁; ▁} ▁int ▁getSum ▁( ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁while ▁( ▁n ▁!= ▁0 ▁) ▁{ ▁int ▁r ▁= ▁n ▁% ▁10 ▁; ▁sum ▁= ▁sum ▁+ ▁r ▁* ▁r ▁; ▁n ▁= ▁n ▁/ ▁10 ▁; ▁} ▁return ▁sum ▁; ▁} ▁bool ▁is Can ada ▁( ▁int ▁n ▁) ▁{ ▁return ▁div Sum ▁( ▁n ▁) ▁== ▁getSum ▁( ▁n ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁125 ▁; ▁if ▁( ▁is Can ada ▁( ▁n ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Ele ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁len ▁= ▁0 ▁; ▁unordered _ map ▁< ▁int ▁, ▁int ▁> ▁h map ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁len ▁= ▁max ▁( ▁len ▁, ▁a ▁[ ▁i ▁] ▁) ▁; ▁h map ▁[ ▁a ▁[ ▁i ▁] ▁] ▁++ ▁; ▁} ▁bool ▁v ▁[ ▁len ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁len ▁; ▁i ▁++ ▁) ▁{ ▁v ▁[ ▁i ▁] ▁= ▁true ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁v ▁[ ▁a ▁[ ▁i ▁] ▁] ▁== ▁false ▁) ▁continue ▁; ▁for ▁( ▁int ▁j ▁= ▁2 ▁* ▁a ▁[ ▁i ▁] ▁; ▁j ▁<= ▁len ▁; ▁j ▁+= ▁a ▁[ ▁i ▁] ▁) ▁{ ▁v ▁[ ▁j ▁] ▁= ▁false ▁; ▁} ▁} ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁len ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁v ▁[ ▁i ▁] ▁== ▁true ▁&& ▁h map ▁. ▁count ▁( ▁i ▁) ▁== ▁1 ▁&& ▁h map ▁[ ▁i ▁] ▁== ▁1 ▁) ▁{ ▁count ▁+= ▁1 ▁; ▁} ▁} ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁86 ▁, ▁45 ▁, ▁18 ▁, ▁4 ▁, ▁8 ▁, ▁28 ▁, ▁19 ▁, ▁33 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁c out ▁<< ▁count Ele ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max Ad jacent Difference ▁( ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁if ▁( ▁N ▁== ▁1 ▁) ▁{ ▁return ▁0 ▁; ▁} ▁if ▁( ▁N ▁== ▁2 ▁) ▁{ ▁return ▁K ▁; ▁} ▁return ▁2 ▁* ▁K ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁6 ▁; ▁int ▁K ▁= ▁11 ▁; ▁c out ▁<< ▁max Ad jacent Difference ▁( ▁N ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁isP al ▁( ▁int ▁a ▁[ ▁3 ▁] ▁[ ▁3 ▁] ▁, ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁/ ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁m ▁- ▁1 ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁[ ▁j ▁] ▁!= ▁a ▁[ ▁n ▁- ▁1 ▁- ▁i ▁] ▁[ ▁m ▁- ▁1 ▁- ▁j ▁] ▁) ▁return ▁false ▁; ▁} ▁} ▁return ▁true ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁3 ▁, ▁m ▁= ▁3 ▁; ▁int ▁a ▁[ ▁3 ▁] ▁[ ▁3 ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁, ▁{ ▁4 ▁, ▁5 ▁, ▁4 ▁} ▁, ▁{ ▁3 ▁, ▁2 ▁, ▁1 ▁} ▁} ▁; ▁if ▁( ▁isP al ▁( ▁a ▁, ▁n ▁, ▁m ▁) ▁) ▁{ ▁c out ▁<< ▁" ▁YES ▁" ▁<< ▁end l ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁" ▁NO ▁" ▁<< ▁end l ▁; ▁} ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁div Sum ▁( ▁int ▁num ▁) ▁{ ▁int ▁result ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁sqrt ▁( ▁num ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁num ▁% ▁i ▁== ▁0 ▁) ▁{ ▁if ▁( ▁i ▁== ▁( ▁num ▁/ ▁i ▁) ▁) ▁result ▁+= ▁i ▁; ▁else ▁result ▁+= ▁( ▁i ▁+ ▁num ▁/ ▁i ▁) ▁; ▁} ▁} ▁return ▁( ▁result ▁+ ▁1 ▁) ▁; ▁} ▁bool ▁is U nt ouch able ▁( ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁2 ▁* ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁div Sum ▁( ▁i ▁) ▁== ▁n ▁) ▁return ▁false ▁; ▁} ▁return ▁true ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁52 ▁; ▁if ▁( ▁is U nt ouch able ▁( ▁n ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁gon Num 120 ▁( ▁int ▁n ▁) ▁{ ▁return ▁( ▁118 ▁* ▁n ▁* ▁n ▁- ▁116 ▁* ▁n ▁) ▁/ ▁2 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁3 ▁; ▁c out ▁<< ▁gon Num 120 ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁construct Array ▁( ▁int ▁N ▁) ▁{ ▁int ▁arr ▁[ ▁N ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁= ▁i ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁<< ▁" ▁, ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁6 ▁; ▁construct Array ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find Pair ▁( ▁int ▁x ▁) ▁{ ▁int ▁lim ▁= ▁120 ▁; ▁for ▁( ▁int ▁i ▁= ▁- ▁lim ▁; ▁i ▁<= ▁lim ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁- ▁lim ▁; ▁j ▁<= ▁lim ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁pow ▁( ▁i ▁, ▁5 ▁) ▁- ▁pow ▁( ▁j ▁, ▁5 ▁) ▁== ▁x ▁) ▁{ ▁c out ▁<< ▁i ▁<< ▁' ▁' ▁<< ▁j ▁<< ▁end l ▁; ▁return ▁; ▁} ▁} ▁} ▁c out ▁<< ▁" ▁- ▁1" ▁; ▁} ▁signed ▁main ▁( ▁) ▁{ ▁int ▁X ▁= ▁33 ▁; ▁find Pair ▁( ▁X ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is Perf ect Square ▁( ▁int ▁x ▁) ▁{ ▁int ▁s ▁= ▁sqrt ▁( ▁x ▁) ▁; ▁return ▁( ▁s ▁* ▁s ▁== ▁x ▁) ▁; ▁} ▁bool ▁isF ib onacci ▁( ▁int ▁n ▁) ▁{ ▁return ▁is Perf ect Square ▁( ▁5 ▁* ▁n ▁* ▁n ▁+ ▁4 ▁) ▁|| ▁is Perf ect Square ▁( ▁5 ▁* ▁n ▁* ▁n ▁- ▁4 ▁) ▁; ▁} ▁bool ▁check Digits ▁( ▁int ▁n ▁) ▁{ ▁while ▁( ▁n ▁) ▁{ ▁int ▁dig ▁= ▁n ▁% ▁10 ▁; ▁if ▁( ▁dig ▁== ▁4 ▁&& ▁dig ▁== ▁6 ▁&& ▁dig ▁== ▁7 ▁&& ▁dig ▁== ▁9 ▁) ▁return ▁false ▁; ▁n ▁/= ▁10 ▁; ▁} ▁return ▁true ▁; ▁} ▁int ▁is Full f ib onacci ▁( ▁int ▁n ▁) ▁{ ▁return ▁( ▁check Digits ▁( ▁n ▁) ▁&& ▁isF ib onacci ▁( ▁n ▁) ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁13 ▁; ▁if ▁( ▁is Full f ib onacci ▁( ▁n ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁longest Even Odd Sub array ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁longest ▁= ▁1 ▁; ▁int ▁cnt ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁a ▁[ ▁i ▁] ▁+ ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁% ▁2 ▁== ▁1 ▁) ▁{ ▁cnt ▁++ ▁; ▁} ▁else ▁{ ▁longest ▁= ▁max ▁( ▁longest ▁, ▁cnt ▁) ▁; ▁cnt ▁= ▁1 ▁; ▁} ▁} ▁if ▁( ▁longest ▁== ▁1 ▁) ▁return ▁0 ▁; ▁return ▁max ▁( ▁cnt ▁, ▁longest ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁7 ▁, ▁8 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁longest Even Odd Sub array ▁( ▁a ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Min Div isor ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁limit ▁) ▁{ ▁int ▁low ▁= ▁0 ▁, ▁high ▁= ▁1 e 9 ▁; ▁while ▁( ▁low ▁< ▁high ▁) ▁{ ▁int ▁mid ▁= ▁( ▁low ▁+ ▁high ▁) ▁/ ▁2 ▁; ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁ceil ▁( ▁( ▁double ▁) ▁arr ▁[ ▁i ▁] ▁/ ▁( ▁double ▁) ▁mid ▁) ▁; ▁} ▁if ▁( ▁sum ▁<= ▁limit ▁) ▁high ▁= ▁mid ▁; ▁else ▁low ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁return ▁low ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁9 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁K ▁= ▁6 ▁; ▁c out ▁<< ▁find Min Div isor ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁int ▁sz ▁= ▁1 e 3 ▁; ▁bool ▁is Even Par ity ▁( ▁int ▁x ▁) ▁{ ▁int ▁par ity ▁= ▁0 ▁; ▁while ▁( ▁x ▁!= ▁0 ▁) ▁{ ▁if ▁( ▁x ▁& ▁1 ▁) ▁par ity ▁++ ▁; ▁x ▁= ▁x ▁>> ▁1 ▁; ▁} ▁if ▁( ▁par ity ▁% ▁2 ▁== ▁0 ▁) ▁return ▁true ▁; ▁else ▁return ▁false ▁; ▁} ▁void ▁print Array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁len ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁len ▁; ▁i ▁++ ▁) ▁{ ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁<< ▁' ▁' ▁; ▁} ▁} ▁void ▁find Pair Even Par ity ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁len ▁) ▁{ ▁int ▁first Maximum ▁= ▁INT _ MIN ▁; ▁int ▁second Maximum ▁= ▁INT _ MIN ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁len ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁is Even Par ity ▁( ▁arr ▁[ ▁i ▁] ▁) ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁>= ▁first Maximum ▁) ▁{ ▁second Maximum ▁= ▁first Maximum ▁; ▁first Maximum ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁else ▁if ▁( ▁arr ▁[ ▁i ▁] ▁>= ▁second Maximum ▁) ▁{ ▁second Maximum ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁} ▁} ▁c out ▁<< ▁first Maximum ▁<< ▁" ▁" ▁<< ▁second Maximum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁18 ▁, ▁15 ▁, ▁8 ▁, ▁9 ▁, ▁14 ▁} ▁; ▁int ▁len ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁find Pair Even Par ity ▁( ▁arr ▁, ▁len ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is Hex ag onal ▁( ▁int ▁N ▁) ▁{ ▁float ▁val ▁= ▁8 ▁* ▁N ▁+ ▁1 ▁; ▁float ▁x ▁= ▁1 ▁+ ▁sqrt ▁( ▁val ▁) ▁; ▁float ▁n ▁= ▁( ▁x ▁) ▁/ ▁4 ▁; ▁if ▁( ▁( ▁n ▁- ▁( ▁int ▁) ▁n ▁) ▁== ▁0 ▁) ▁return ▁true ▁; ▁else ▁return ▁false ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁14 ▁; ▁if ▁( ▁is Hex ag onal ▁( ▁N ▁) ▁== ▁true ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁<< ▁end l ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁S olve ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁temp ▁= ▁0 ▁, ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁temp ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁temp ▁+= ▁arr ▁[ ▁j ▁] ▁; ▁if ▁( ▁( ▁temp ▁+ ▁2 ▁) ▁% ▁4 ▁!= ▁0 ▁) ▁count ▁++ ▁; ▁} ▁} ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁, ▁7 ▁, ▁8 ▁, ▁9 ▁, ▁10 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁c out ▁<< ▁S olve ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁prod Square ▁( ▁int ▁n ▁) ▁{ ▁for ▁( ▁long ▁i ▁= ▁2 ▁; ▁i ▁* ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁for ▁( ▁long ▁j ▁= ▁2 ▁; ▁j ▁<= ▁n ▁; ▁j ▁++ ▁) ▁if ▁( ▁i ▁* ▁i ▁* ▁j ▁* ▁j ▁== ▁n ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁25 ▁; ▁if ▁( ▁prod Square ▁( ▁n ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find Numbers ▁( ▁int ▁N ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁N ▁/ ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁c out ▁<< ▁i ▁<< ▁" ▁, ▁" ▁<< ▁- ▁i ▁<< ▁" ▁, ▁" ▁; ▁} ▁if ▁( ▁N ▁% ▁2 ▁== ▁1 ▁) ▁c out ▁<< ▁0 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁10 ▁; ▁find Numbers ▁( ▁N ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Values ▁( ▁int ▁N ▁) ▁{ ▁vector ▁< ▁int ▁> ▁div ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁* ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁N ▁% ▁i ▁== ▁0 ▁) ▁{ ▁div ▁. ▁push _ back ▁( ▁i ▁) ▁; ▁if ▁( ▁N ▁!= ▁i ▁* ▁i ▁) ▁{ ▁div ▁. ▁push _ back ▁( ▁N ▁/ ▁i ▁) ▁; ▁} ▁} ▁} ▁int ▁answer ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁* ▁i ▁<= ▁N ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁N ▁- ▁1 ▁) ▁% ▁i ▁== ▁0 ▁) ▁{ ▁if ▁( ▁i ▁* ▁i ▁== ▁N ▁- ▁1 ▁) ▁answer ▁++ ▁; ▁else ▁answer ▁+= ▁2 ▁; ▁} ▁} ▁for ▁( ▁auto ▁d ▁: ▁div ▁) ▁{ ▁int ▁K ▁= ▁N ▁; ▁while ▁( ▁K ▁% ▁d ▁== ▁0 ▁) ▁K ▁/= ▁d ▁; ▁if ▁( ▁( ▁K ▁- ▁1 ▁) ▁% ▁d ▁== ▁0 ▁) ▁answer ▁++ ▁; ▁} ▁return ▁answer ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁6 ▁; ▁c out ▁<< ▁count Values ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁S olve ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁size ▁, ▁int ▁n ▁) ▁{ ▁vector ▁< ▁int ▁> ▁v ▁( ▁n ▁+ ▁1 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁v ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁++ ▁; ▁int ▁max 1 ▁= ▁( ▁max _ element ▁( ▁v ▁. ▁begin ▁( ▁) ▁, ▁v ▁. ▁end ▁( ▁) ▁) ▁- ▁v ▁. ▁begin ▁( ▁) ▁) ▁; ▁int ▁diff 1 ▁= ▁n ▁+ ▁1 ▁- ▁count ▁( ▁v ▁. ▁begin ▁( ▁) ▁, ▁v ▁. ▁end ▁( ▁) ▁, ▁0 ▁) ▁; ▁int ▁max _ size ▁= ▁max ▁( ▁min ▁( ▁v ▁[ ▁max 1 ▁] ▁- ▁1 ▁, ▁diff 1 ▁) ▁, ▁min ▁( ▁v ▁[ ▁max 1 ▁] ▁, ▁diff 1 ▁- ▁1 ▁) ▁) ▁; ▁c out ▁<< ▁" ▁Maximum ▁size ▁is ▁: ▁" ▁<< ▁max _ size ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁c out ▁<< ▁" ▁The ▁First ▁Array ▁Is ▁: ▁STRNEWLINE ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁max _ size ▁; ▁i ▁++ ▁) ▁{ ▁c out ▁<< ▁max 1 ▁<< ▁" ▁" ▁; ▁v ▁[ ▁max 1 ▁] ▁-= ▁1 ▁; ▁} ▁c out ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁c out ▁<< ▁" ▁The ▁Second ▁Array ▁Is ▁: ▁STRNEWLINE ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁( ▁n ▁+ ▁1 ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁v ▁[ ▁i ▁] ▁> ▁0 ▁) ▁{ ▁c out ▁<< ▁i ▁<< ▁" ▁" ▁; ▁max _ size ▁-- ▁; ▁} ▁if ▁( ▁max _ size ▁< ▁1 ▁) ▁break ▁; ▁} ▁c out ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁7 ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁1 ▁, ▁5 ▁, ▁1 ▁, ▁6 ▁, ▁7 ▁, ▁2 ▁} ▁; ▁int ▁size ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁S olve ▁( ▁arr ▁, ▁size ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find unique ▁( ▁vector ▁< ▁int ▁> ▁& ▁a ▁, ▁int ▁k ▁) ▁{ ▁int ▁res ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁32 ▁; ▁i ▁++ ▁) ▁{ ▁int ▁p ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁a ▁. ▁size ▁( ▁) ▁; ▁j ▁++ ▁) ▁{ ▁p ▁+= ▁( ▁abs ▁( ▁a ▁[ ▁j ▁] ▁) ▁& ▁( ▁1 ▁<< ▁i ▁) ▁) ▁!= ▁0 ▁? ▁1 ▁: ▁0 ▁; ▁} ▁p ▁% = ▁k ▁; ▁res ▁+= ▁pow ▁( ▁2 ▁, ▁i ▁) ▁* ▁p ▁; ▁} ▁int ▁c ▁= ▁0 ▁; ▁for ▁( ▁auto ▁x ▁: ▁a ▁) ▁if ▁( ▁x ▁== ▁res ▁) ▁{ ▁c ▁= ▁1 ▁; ▁break ▁; ▁} ▁return ▁c ▁== ▁1 ▁? ▁res ▁: ▁- ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁int ▁> ▁a ▁= ▁{ ▁12 ▁, ▁12 ▁, ▁2 ▁, ▁2 ▁, ▁3 ▁} ▁; ▁int ▁k ▁= ▁2 ▁; ▁c out ▁<< ▁find unique ▁( ▁a ▁, ▁k ▁) ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁float ▁Volume _ of _ c one ▁( ▁float ▁R ▁) ▁{ ▁float ▁V ▁= ▁( ▁1 ▁/ ▁3.0 ▁) ▁* ▁( ▁3.14 ▁) ▁* ▁( ▁2 ▁* ▁( ▁R ▁* ▁R ▁) ▁) ▁* ▁( ▁4 ▁* ▁R ▁) ▁; ▁return ▁V ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁float ▁R ▁= ▁10.0 ▁; ▁c out ▁<< ▁Volume _ of _ c one ▁( ▁R ▁) ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find _ volume ▁( ▁float ▁area ▁, ▁float ▁h ▁) ▁{ ▁float ▁Volume ▁= ▁( ▁area ▁* ▁h ▁) ▁; ▁c out ▁<< ▁" ▁Volume ▁: ▁" ▁<< ▁Volume ▁<< ▁end l ▁; ▁} ▁void ▁find _ Surface _ area ▁( ▁float ▁area ▁, ▁float ▁a ▁, ▁float ▁h ▁) ▁{ ▁float ▁Surface _ area ▁= ▁( ▁2 ▁* ▁area ▁) ▁+ ▁( ▁8 ▁* ▁a ▁* ▁h ▁) ▁; ▁c out ▁<< ▁" ▁Surface ▁area ▁: ▁" ▁<< ▁Surface _ area ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁float ▁h ▁= ▁1 ▁; ▁float ▁a ▁= ▁6 ▁; ▁float ▁d ▁= ▁2 ▁; ▁float ▁area ▁= ▁2 ▁* ▁a ▁* ▁d ▁; ▁find _ Surface _ area ▁( ▁area ▁, ▁a ▁, ▁h ▁) ▁; ▁find _ volume ▁( ▁area ▁, ▁h ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁ll ▁long ▁long ▁NEW _ LINE ▁double ▁nth Root ▁( ▁ll ▁A ▁, ▁ll ▁N ▁) ▁{ ▁double ▁x Pre ▁= ▁7 ▁; ▁double ▁eps ▁= ▁1 e -3 ▁; ▁double ▁del X ▁= ▁INT _ MAX ▁; ▁double ▁x K ▁; ▁while ▁( ▁del X ▁> ▁eps ▁) ▁{ ▁x K ▁= ▁( ▁( ▁N ▁- ▁1.0 ▁) ▁* ▁x Pre ▁+ ▁( ▁double ▁) ▁A ▁/ ▁pow ▁( ▁x Pre ▁, ▁N ▁- ▁1 ▁) ▁) ▁/ ▁( ▁double ▁) ▁N ▁; ▁del X ▁= ▁abs ▁( ▁x K ▁- ▁x Pre ▁) ▁; ▁x Pre ▁= ▁x K ▁; ▁} ▁return ▁x K ▁; ▁} ▁bool ▁check ▁( ▁ll ▁no ▁, ▁int ▁k ▁) ▁{ ▁double ▁k th _ root ▁= ▁nth Root ▁( ▁no ▁, ▁k ▁) ▁; ▁ll ▁num ▁= ▁k th _ root ▁; ▁if ▁( ▁abs ▁( ▁num ▁- ▁k th _ root ▁) ▁< ▁1 e -4 ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁void ▁print Exp o ▁( ▁ll ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁check ▁( ▁arr ▁[ ▁i ▁] ▁, ▁k ▁) ▁) ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁K ▁= ▁6 ▁; ▁ll ▁arr ▁[ ▁] ▁= ▁{ ▁4 66 56 ▁, ▁64 ▁, ▁256 ▁, ▁7 29 ▁, ▁16 ▁, ▁1000 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁print Exp o ▁( ▁arr ▁, ▁n ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁C nt cont Sub s ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁c ▁= ▁0 ▁, ▁d ▁= ▁0 ▁, ▁i ▁, ▁sum ▁= ▁1 ▁, ▁j ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁% ▁2 ▁!= ▁0 ▁a ▁[ ▁i ▁] ▁% ▁4 ▁== ▁0 ▁) ▁d ▁++ ▁; ▁sum ▁= ▁a ▁[ ▁i ▁] ▁; ▁for ▁( ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁sum ▁= ▁sum ▁* ▁a ▁[ ▁j ▁] ▁; ▁if ▁( ▁sum ▁% ▁2 ▁!= ▁0 ▁sum ▁% ▁4 ▁== ▁0 ▁) ▁c ▁++ ▁; ▁} ▁sum ▁= ▁1 ▁; ▁} ▁return ▁c ▁+ ▁d ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁4 ▁, ▁2 ▁, ▁9 ▁, ▁8 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁C nt cont Sub s ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁# define ▁ll ▁int ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁long ▁long ▁pref ▁[ ▁100 010 ▁] ▁; ▁int ▁is Perf ect ▁( ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁* ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁{ ▁if ▁( ▁i ▁* ▁i ▁!= ▁n ▁) ▁sum ▁= ▁sum ▁+ ▁i ▁+ ▁n ▁/ ▁i ▁; ▁else ▁sum ▁= ▁sum ▁+ ▁i ▁; ▁} ▁} ▁if ▁( ▁sum ▁== ▁n ▁&& ▁n ▁!= ▁1 ▁) ▁return ▁n ▁; ▁return ▁0 ▁; ▁} ▁void ▁pre com putation ▁( ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁100000 ▁; ▁++ ▁i ▁) ▁{ ▁pref ▁[ ▁i ▁] ▁= ▁pref ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁is Perf ect ▁( ▁i ▁) ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁L ▁= ▁6 ▁, ▁R ▁= ▁28 ▁; ▁pre com putation ▁( ▁) ▁; ▁c out ▁<< ▁pref ▁[ ▁R ▁] ▁- ▁pref ▁[ ▁L ▁- ▁1 ▁] ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁E uler T ot ient Function ▁( ▁int ▁limit ▁) ▁{ ▁int ▁copy ▁= ▁limit ▁; ▁vector ▁< ▁int ▁> ▁primes ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁* ▁i ▁<= ▁limit ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁limit ▁% ▁i ▁== ▁0 ▁) ▁{ ▁while ▁( ▁limit ▁% ▁i ▁== ▁0 ▁) ▁{ ▁limit ▁/= ▁i ▁; ▁} ▁primes ▁. ▁push _ back ▁( ▁i ▁) ▁; ▁} ▁} ▁if ▁( ▁limit ▁>= ▁2 ▁) ▁{ ▁primes ▁. ▁push _ back ▁( ▁limit ▁) ▁; ▁} ▁int ▁ans ▁= ▁copy ▁; ▁for ▁( ▁auto ▁it ▁: ▁primes ▁) ▁{ ▁ans ▁= ▁( ▁ans ▁/ ▁it ▁) ▁* ▁( ▁it ▁- ▁1 ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁void ▁Count G CD ▁( ▁int ▁m ▁, ▁int ▁k ▁) ▁{ ▁if ▁( ▁m ▁% ▁k ▁!= ▁0 ▁) ▁{ ▁c out ▁<< ▁0 ▁<< ▁end l ▁; ▁return ▁; ▁} ▁if ▁( ▁m ▁== ▁k ▁) ▁{ ▁c out ▁<< ▁2 ▁<< ▁end l ▁; ▁return ▁; ▁} ▁int ▁limit ▁= ▁m ▁/ ▁k ▁; ▁int ▁ans ▁= ▁E uler T ot ient Function ▁( ▁limit ▁) ▁; ▁c out ▁<< ▁ans ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁M ▁= ▁9 ▁; ▁int ▁K ▁= ▁1 ▁; ▁Count G CD ▁( ▁M ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁MAX ▁1000000 ▁NEW _ LINE ▁int ▁fib ▁( ▁int ▁n ▁) ▁{ ▁double ▁phi ▁= ▁( ▁1 ▁+ ▁sqrt ▁( ▁5 ▁) ▁) ▁/ ▁2 ▁; ▁return ▁round ▁( ▁pow ▁( ▁phi ▁, ▁n ▁) ▁/ ▁sqrt ▁( ▁5 ▁) ▁) ▁; ▁} ▁int ▁calculate Sum ▁( ▁int ▁l ▁, ▁int ▁r ▁) ▁{ ▁int ▁sum ▁= ▁fib ▁( ▁r ▁+ ▁2 ▁) ▁- ▁fib ▁( ▁l ▁+ ▁1 ▁) ▁; ▁return ▁sum ▁; ▁} ▁int ▁sum F ib onacci ▁( ▁int ▁k ▁) ▁{ ▁int ▁l ▁= ▁( ▁k ▁* ▁( ▁k ▁- ▁1 ▁) ▁) ▁/ ▁2 ▁; ▁int ▁r ▁= ▁l ▁+ ▁k ▁; ▁int ▁sum ▁= ▁calculate Sum ▁( ▁l ▁, ▁r ▁- ▁1 ▁) ▁; ▁return ▁sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁k ▁= ▁3 ▁; ▁c out ▁<< ▁sum F ib onacci ▁( ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁sum Of Prev K ▁( ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁int ▁arr ▁[ ▁N ▁] ▁; ▁arr ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁int ▁j ▁= ▁i ▁- ▁1 ▁, ▁count ▁= ▁0 ▁, ▁sum ▁= ▁0 ▁; ▁while ▁( ▁j ▁>= ▁0 ▁&& ▁count ▁< ▁K ▁) ▁{ ▁sum ▁+= ▁arr ▁[ ▁j ▁] ▁; ▁j ▁-- ▁; ▁count ▁++ ▁; ▁} ▁arr ▁[ ▁i ▁] ▁= ▁sum ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁10 ▁, ▁K ▁= ▁4 ▁; ▁sum Of Prev K ▁( ▁N ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find Real And Im ag ▁( ▁string ▁s ▁) ▁{ ▁int ▁l ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁int ▁i ▁; ▁if ▁( ▁s ▁. ▁find ▁( ▁' ▁+ ▁' ▁) ▁< ▁l ▁) ▁{ ▁i ▁= ▁s ▁. ▁find ▁( ▁' ▁+ ▁' ▁) ▁; ▁} ▁else ▁{ ▁i ▁= ▁s ▁. ▁find ▁( ▁' ▁- ▁' ▁) ▁; ▁} ▁string ▁real ▁= ▁s ▁. ▁substr ▁( ▁0 ▁, ▁i ▁) ▁; ▁string ▁imag inary ▁= ▁s ▁. ▁substr ▁( ▁i ▁+ ▁1 ▁, ▁l ▁- ▁i ▁- ▁2 ▁) ▁; ▁c out ▁<< ▁" ▁Real ▁part ▁: ▁" ▁<< ▁real ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁c out ▁<< ▁" ▁Imag inary ▁part ▁: ▁" ▁<< ▁imag inary ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁"3 ▁+ ▁4 i ▁" ▁; ▁find Real And Im ag ▁( ▁s ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁reverse ▁( ▁int ▁num ▁) ▁{ ▁int ▁rev _ num ▁= ▁0 ▁; ▁while ▁( ▁num ▁> ▁0 ▁) ▁{ ▁rev _ num ▁= ▁rev _ num ▁* ▁10 ▁+ ▁num ▁% ▁10 ▁; ▁num ▁= ▁num ▁/ ▁10 ▁; ▁} ▁return ▁rev _ num ▁; ▁} ▁int ▁count Reverse ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁res ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁if ▁( ▁reverse ▁( ▁arr ▁[ ▁i ▁] ▁) ▁== ▁arr ▁[ ▁j ▁] ▁) ▁{ ▁res ▁++ ▁; ▁} ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁16 ▁, ▁61 ▁, ▁12 ▁, ▁21 ▁, ▁25 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁count Reverse ▁( ▁a ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print Series Sum ▁( ▁int ▁N ▁) ▁{ ▁double ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁& ▁1 ▁) ▁{ ▁sum ▁+= ▁( ▁double ▁) ▁i ▁/ ▁( ▁i ▁+ ▁1 ▁) ▁; ▁} ▁else ▁{ ▁sum ▁-= ▁( ▁double ▁) ▁i ▁/ ▁( ▁i ▁+ ▁1 ▁) ▁; ▁} ▁} ▁c out ▁<< ▁sum ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁10 ▁; ▁print Series Sum ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁string ▁sum Base B ▁( ▁string ▁a ▁, ▁string ▁b ▁, ▁int ▁base ▁) ▁{ ▁int ▁len _ a ▁, ▁len _ b ▁; ▁len _ a ▁= ▁a ▁. ▁size ▁( ▁) ▁; ▁len _ b ▁= ▁b ▁. ▁size ▁( ▁) ▁; ▁string ▁sum ▁, ▁s ▁; ▁s ▁= ▁" ▁" ▁; ▁sum ▁= ▁" ▁" ▁; ▁int ▁diff ▁; ▁diff ▁= ▁abs ▁( ▁len _ a ▁- ▁len _ b ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁diff ▁; ▁i ▁++ ▁) ▁s ▁+= ▁"0" ▁; ▁if ▁( ▁len _ a ▁< ▁len _ b ▁) ▁a ▁= ▁s ▁+ ▁a ▁; ▁else ▁b ▁= ▁s ▁+ ▁b ▁; ▁int ▁curr ▁, ▁carry ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁max ▁( ▁len _ a ▁, ▁len _ b ▁) ▁- ▁1 ▁; ▁i ▁> ▁-1 ▁; ▁i ▁-- ▁) ▁{ ▁curr ▁= ▁carry ▁+ ▁( ▁a ▁[ ▁i ▁] ▁- ▁'0' ▁) ▁+ ▁( ▁b ▁[ ▁i ▁] ▁- ▁'0' ▁) ▁; ▁carry ▁= ▁curr ▁/ ▁base ▁; ▁curr ▁= ▁curr ▁% ▁base ▁; ▁sum ▁= ▁( ▁char ▁) ▁( ▁curr ▁+ ▁'0' ▁) ▁+ ▁sum ▁; ▁} ▁if ▁( ▁carry ▁> ▁0 ▁) ▁sum ▁= ▁( ▁char ▁) ▁( ▁carry ▁+ ▁'0' ▁) ▁+ ▁sum ▁; ▁return ▁sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁a ▁, ▁b ▁, ▁sum ▁; ▁int ▁base ▁; ▁a ▁= ▁"123" ▁; ▁b ▁= ▁" 234 " ▁; ▁base ▁= ▁6 ▁; ▁sum ▁= ▁sum Base B ▁( ▁a ▁, ▁b ▁, ▁base ▁) ▁; ▁c out ▁<< ▁sum ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁create Hash ▁( ▁set ▁< ▁int ▁> ▁& ▁hash ▁, ▁int ▁max Element ▁) ▁{ ▁int ▁prev ▁= ▁0 ▁, ▁curr ▁= ▁1 ▁; ▁hash ▁. ▁insert ▁( ▁prev ▁) ▁; ▁hash ▁. ▁insert ▁( ▁curr ▁) ▁; ▁while ▁( ▁curr ▁<= ▁max Element ▁) ▁{ ▁int ▁temp ▁= ▁curr ▁+ ▁prev ▁; ▁hash ▁. ▁insert ▁( ▁temp ▁) ▁; ▁prev ▁= ▁curr ▁; ▁curr ▁= ▁temp ▁; ▁} ▁} ▁int ▁count F ib onacci Div is ors ▁( ▁int ▁n ▁) ▁{ ▁set ▁< ▁int ▁> ▁hash ▁; ▁create Hash ▁( ▁hash ▁, ▁n ▁) ▁; ▁int ▁cnt ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁sqrt ▁( ▁n ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁{ ▁if ▁( ▁( ▁n ▁/ ▁i ▁== ▁i ▁) ▁&& ▁( ▁hash ▁. ▁find ▁( ▁n ▁/ ▁i ▁) ▁!= ▁hash ▁. ▁end ▁( ▁) ▁) ▁) ▁cnt ▁++ ▁; ▁else ▁{ ▁if ▁( ▁hash ▁. ▁find ▁( ▁n ▁/ ▁i ▁) ▁!= ▁hash ▁. ▁end ▁( ▁) ▁) ▁cnt ▁++ ▁; ▁if ▁( ▁hash ▁. ▁find ▁( ▁n ▁/ ▁( ▁n ▁/ ▁i ▁) ▁) ▁!= ▁hash ▁. ▁end ▁( ▁) ▁) ▁cnt ▁++ ▁; ▁} ▁} ▁} ▁return ▁cnt ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁12 ▁; ▁c out ▁<< ▁count F ib onacci Div is ors ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is Perf ect Cube ▁( ▁int ▁x ▁) ▁{ ▁long ▁double ▁cr ▁= ▁round ▁( ▁c br t ▁( ▁x ▁) ▁) ▁; ▁return ▁( ▁cr ▁* ▁cr ▁* ▁cr ▁== ▁x ▁) ▁; ▁} ▁void ▁check Cube ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁string ▁s 1 ▁= ▁to _ string ▁( ▁a ▁) ▁; ▁string ▁s 2 ▁= ▁to _ string ▁( ▁b ▁) ▁; ▁int ▁c ▁= ▁sto i ▁( ▁s 1 ▁+ ▁s 2 ▁) ▁; ▁if ▁( ▁is Perf ect Cube ▁( ▁c ▁) ▁) ▁{ ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁" ▁No ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁= ▁6 ▁; ▁int ▁b ▁= ▁4 ▁; ▁check Cube ▁( ▁a ▁, ▁b ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is Perf ect Square ▁( ▁int ▁x ▁) ▁{ ▁int ▁s ▁= ▁sqrt ▁( ▁x ▁) ▁; ▁return ▁( ▁s ▁* ▁s ▁== ▁x ▁) ▁; ▁} ▁bool ▁isF ib onacci ▁( ▁int ▁N ▁) ▁{ ▁return ▁is Perf ect Square ▁( ▁5 ▁* ▁N ▁* ▁N ▁+ ▁4 ▁) ▁|| ▁is Perf ect Square ▁( ▁5 ▁* ▁N ▁* ▁N ▁- ▁4 ▁) ▁; ▁} ▁int ▁next Non F ib onacci ▁( ▁int ▁N ▁) ▁{ ▁if ▁( ▁N ▁<= ▁3 ▁) ▁return ▁4 ▁; ▁if ▁( ▁isF ib onacci ▁( ▁N ▁+ ▁1 ▁) ▁) ▁return ▁N ▁+ ▁2 ▁; ▁else ▁return ▁N ▁+ ▁1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁3 ▁; ▁c out ▁<< ▁next Non F ib onacci ▁( ▁N ▁) ▁<< ▁end l ▁; ▁N ▁= ▁5 ▁; ▁c out ▁<< ▁next Non F ib onacci ▁( ▁N ▁) ▁<< ▁end l ▁; ▁N ▁= ▁7 ▁; ▁c out ▁<< ▁next Non F ib onacci ▁( ▁N ▁) ▁<< ▁end l ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Digit ▁( ▁int ▁n ▁) ▁{ ▁bool ▁prime ▁[ ▁10 ▁] ▁; ▁mem set ▁( ▁prime ▁, ▁false ▁, ▁sizeof ▁( ▁prime ▁) ▁) ▁; ▁prime ▁[ ▁2 ▁] ▁= ▁prime ▁[ ▁3 ▁] ▁= ▁true ▁; ▁prime ▁[ ▁5 ▁] ▁= ▁prime ▁[ ▁7 ▁] ▁= ▁true ▁; ▁int ▁temp ▁= ▁n ▁, ▁count ▁= ▁0 ▁; ▁while ▁( ▁temp ▁!= ▁0 ▁) ▁{ ▁int ▁d ▁= ▁temp ▁% ▁10 ▁; ▁temp ▁/= ▁10 ▁; ▁if ▁( ▁d ▁> ▁0 ▁&& ▁n ▁% ▁d ▁== ▁0 ▁&& ▁prime ▁[ ▁d ▁] ▁) ▁count ▁++ ▁; ▁} ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁10 32 ▁; ▁c out ▁<< ▁count Digit ▁( ▁n ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find Roots ▁( ▁int ▁b ▁, ▁int ▁c ▁) ▁{ ▁int ▁a ▁= ▁1 ▁; ▁int ▁d ▁= ▁b ▁* ▁b ▁- ▁4 ▁* ▁a ▁* ▁c ▁; ▁double ▁sqrt _ val ▁= ▁sqrt ▁( ▁abs ▁( ▁d ▁) ▁) ▁; ▁if ▁( ▁d ▁> ▁0 ▁) ▁{ ▁double ▁x ▁= ▁- ▁b ▁+ ▁sqrt _ val ▁; ▁double ▁y ▁= ▁- ▁b ▁- ▁sqrt _ val ▁; ▁int ▁root 1 ▁= ▁( ▁x ▁) ▁/ ▁( ▁2 ▁* ▁a ▁) ▁; ▁int ▁root 2 ▁= ▁( ▁y ▁) ▁/ ▁( ▁2 ▁* ▁a ▁) ▁; ▁if ▁( ▁root 1 ▁+ ▁root 2 ▁== ▁-1 ▁* ▁b ▁&& ▁root 1 ▁* ▁root 2 ▁== ▁c ▁) ▁c out ▁<< ▁root 1 ▁<< ▁" ▁, ▁" ▁<< ▁root 2 ▁; ▁else ▁c out ▁<< ▁-1 ▁; ▁} ▁else ▁if ▁( ▁d ▁== ▁0 ▁) ▁{ ▁int ▁root ▁= ▁- ▁b ▁/ ▁( ▁2 ▁* ▁a ▁) ▁; ▁if ▁( ▁root ▁+ ▁root ▁== ▁-1 ▁* ▁b ▁&& ▁root ▁* ▁root ▁== ▁c ▁) ▁c out ▁<< ▁root ▁<< ▁" ▁, ▁" ▁<< ▁root ▁; ▁else ▁c out ▁<< ▁-1 ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁-1 ▁; ▁} ▁c out ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁S ▁= ▁5 ▁, ▁P ▁= ▁6 ▁; ▁find Roots ▁( ▁- ▁S ▁, ▁P ▁) ▁; ▁S ▁= ▁5 ▁, ▁P ▁= ▁9 ▁; ▁find Roots ▁( ▁- ▁S ▁, ▁P ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find Numbers ▁( ▁int ▁N ▁) ▁{ ▁int ▁i ▁= ▁1 ▁; ▁while ▁( ▁i ▁<= ▁N ▁) ▁{ ▁c out ▁<< ▁( ▁i ▁* ▁i ▁* ▁i ▁) ▁<< ▁" ▁" ▁; ▁i ▁++ ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁4 ▁; ▁find Numbers ▁( ▁N ▁) ▁; ▁}
▁# include ▁" ▁bits ▁/ ▁std c ▁+ ▁+ ▁. ▁h ▁" ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁get numbers ▁( ▁int ▁n ▁) ▁{ ▁vector ▁< ▁int ▁> ▁divisor ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁* ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁while ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁{ ▁divisor ▁. ▁push _ back ▁( ▁i ▁) ▁; ▁n ▁/= ▁i ▁; ▁} ▁} ▁if ▁( ▁n ▁!= ▁1 ▁) ▁{ ▁divisor ▁. ▁push _ back ▁( ▁n ▁) ▁; ▁} ▁int ▁a ▁, ▁b ▁, ▁c ▁, ▁size ▁; ▁a ▁= ▁b ▁= ▁c ▁= ▁1 ▁; ▁size ▁= ▁divisor ▁. ▁size ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁== ▁1 ▁) ▁{ ▁a ▁= ▁a ▁* ▁divisor ▁[ ▁i ▁] ▁; ▁} ▁else ▁if ▁( ▁b ▁== ▁1 ▁b ▁== ▁a ▁) ▁{ ▁b ▁= ▁b ▁* ▁divisor ▁[ ▁i ▁] ▁; ▁} ▁else ▁{ ▁c ▁= ▁c ▁* ▁divisor ▁[ ▁i ▁] ▁; ▁} ▁} ▁if ▁( ▁a ▁== ▁1 ▁b ▁== ▁1 ▁c ▁== ▁1 ▁a ▁== ▁b ▁b ▁== ▁c ▁a ▁== ▁c ▁) ▁{ ▁c out ▁<< ▁" ▁- ▁1" ▁<< ▁end l ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁a ▁<< ▁' ▁' ▁<< ▁b ▁<< ▁' ▁' ▁<< ▁c ▁<< ▁end l ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁64 ▁; ▁get numbers ▁( ▁n ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁vector ▁< ▁int ▁> ▁prime Fact ors ▁( ▁int ▁n ▁) ▁{ ▁int ▁i ▁, ▁j ▁; ▁vector ▁< ▁int ▁> ▁Prime ▁; ▁if ▁( ▁n ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁Prime ▁. ▁push _ back ▁( ▁2 ▁) ▁; ▁} ▁while ▁( ▁n ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁n ▁= ▁n ▁/ ▁2 ▁; ▁} ▁for ▁( ▁i ▁= ▁3 ▁; ▁i ▁<= ▁sqrt ▁( ▁n ▁) ▁; ▁i ▁= ▁i ▁+ ▁2 ▁) ▁{ ▁if ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁{ ▁Prime ▁. ▁push _ back ▁( ▁i ▁) ▁; ▁} ▁while ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁{ ▁n ▁= ▁n ▁/ ▁i ▁; ▁} ▁} ▁if ▁( ▁n ▁> ▁2 ▁) ▁{ ▁Prime ▁. ▁push _ back ▁( ▁n ▁) ▁; ▁} ▁return ▁Prime ▁; ▁} ▁void ▁check Distinct Prime ▁( ▁int ▁n ▁) ▁{ ▁vector ▁< ▁int ▁> ▁Prime ▁= ▁prime Fact ors ▁( ▁n ▁) ▁; ▁int ▁product ▁= ▁1 ▁; ▁for ▁( ▁auto ▁i ▁: ▁Prime ▁) ▁{ ▁product ▁*= ▁i ▁; ▁} ▁if ▁( ▁product ▁== ▁n ▁) ▁c out ▁<< ▁" ▁YES ▁" ▁; ▁else ▁c out ▁<< ▁" ▁NO ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁30 ▁; ▁check Distinct Prime ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find Sum ▁( ▁int ▁N ▁) ▁{ ▁int ▁sum ▁= ▁( ▁N ▁) ▁* ▁( ▁N ▁+ ▁1 ▁) ▁/ ▁2 ▁; ▁int ▁r ▁= ▁log 2 ▁( ▁N ▁) ▁+ ▁1 ▁; ▁int ▁exp Sum ▁= ▁pow ▁( ▁2 ▁, ▁r ▁) ▁- ▁1 ▁; ▁c out ▁<< ▁sum ▁- ▁exp Sum ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁2 ▁; ▁find Sum ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁remaining Area ▁( ▁int ▁N ▁, ▁int ▁M ▁, ▁int ▁K ▁) ▁{ ▁while ▁( ▁K ▁-- ▁&& ▁N ▁&& ▁M ▁) ▁{ ▁if ▁( ▁N ▁> ▁M ▁) ▁N ▁= ▁N ▁- ▁M ▁; ▁else ▁M ▁= ▁M ▁- ▁N ▁; ▁} ▁if ▁( ▁N ▁> ▁0 ▁&& ▁M ▁> ▁0 ▁) ▁return ▁N ▁* ▁M ▁; ▁else ▁return ▁0 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁5 ▁, ▁M ▁= ▁3 ▁, ▁K ▁= ▁2 ▁; ▁c out ▁<< ▁remaining Area ▁( ▁N ▁, ▁M ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁isP ossible ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁, ▁max S ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁a ▁[ ▁i ▁] ▁; ▁max S ▁= ▁max ▁( ▁a ▁[ ▁i ▁] ▁, ▁max S ▁) ▁; ▁} ▁if ▁( ▁( ▁sum ▁- ▁max S ▁) ▁> ▁max S ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁if ▁( ▁isP ossible ▁( ▁a ▁, ▁n ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁pair ▁< ▁int ▁, ▁int ▁> ▁find Four th Vertex ▁( ▁int ▁n ▁, ▁int ▁m ▁, ▁string ▁s ▁[ ▁] ▁) ▁{ ▁map ▁< ▁int ▁, ▁int ▁> ▁row ▁, ▁col ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁m ▁; ▁j ▁++ ▁) ▁if ▁( ▁s ▁[ ▁i ▁] ▁[ ▁j ▁] ▁== ▁' ▁* ▁' ▁) ▁{ ▁row ▁[ ▁i ▁] ▁++ ▁; ▁col ▁[ ▁j ▁] ▁++ ▁; ▁} ▁int ▁x ▁, ▁y ▁; ▁for ▁( ▁auto ▁tm ▁: ▁row ▁) ▁if ▁( ▁tm ▁. ▁second ▁== ▁1 ▁) ▁x ▁= ▁tm ▁. ▁first ▁; ▁for ▁( ▁auto ▁tm ▁: ▁col ▁) ▁if ▁( ▁tm ▁. ▁second ▁== ▁1 ▁) ▁y ▁= ▁tm ▁. ▁first ▁; ▁return ▁make _ pair ▁( ▁x ▁+ ▁1 ▁, ▁y ▁+ ▁1 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁[ ▁] ▁= ▁{ ▁" ▁* ▁. ▁* ▁" ▁, ▁" ▁* ▁. ▁. ▁" ▁, ▁" ▁. ▁. ▁. ▁" ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁s ▁) ▁/ ▁sizeof ▁( ▁s ▁[ ▁0 ▁] ▁) ▁; ▁int ▁m ▁= ▁s ▁[ ▁0 ▁] ▁. ▁length ▁( ▁) ▁; ▁auto ▁rs ▁= ▁find Four th Vertex ▁( ▁n ▁, ▁m ▁, ▁s ▁) ▁; ▁c out ▁<< ▁rs ▁. ▁first ▁<< ▁" ▁" ▁<< ▁rs ▁. ▁second ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁float ▁con e ▁( ▁float ▁a ▁) ▁{ ▁if ▁( ▁a ▁< ▁0 ▁) ▁return ▁-1 ▁; ▁float ▁r ▁= ▁( ▁a ▁* ▁sqrt ▁( ▁2 ▁) ▁) ▁/ ▁3 ▁; ▁float ▁h ▁= ▁( ▁2 ▁* ▁a ▁) ▁/ ▁3 ▁; ▁float ▁V ▁= ▁3.14 ▁* ▁pow ▁( ▁r ▁, ▁2 ▁) ▁* ▁h ▁; ▁return ▁V ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁float ▁a ▁= ▁5 ▁; ▁c out ▁<< ▁con e ▁( ▁a ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁float ▁square Area ▁( ▁float ▁a ▁) ▁{ ▁if ▁( ▁a ▁< ▁0 ▁) ▁return ▁-1 ▁; ▁float ▁area ▁= ▁pow ▁( ▁1. 268 ▁, ▁2 ▁) ▁* ▁pow ▁( ▁a ▁, ▁2 ▁) ▁; ▁return ▁area ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁float ▁a ▁= ▁6 ▁; ▁c out ▁<< ▁square Area ▁( ▁a ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁PI ▁3.14 159 265 ▁NEW _ LINE ▁float ▁length _ ro pe ▁( ▁float ▁r ▁) ▁{ ▁return ▁( ▁( ▁2 ▁* ▁PI ▁* ▁r ▁) ▁+ ▁6 ▁* ▁r ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁float ▁r ▁= ▁7 ▁; ▁c out ▁<< ▁ceil ▁( ▁length _ ro pe ▁( ▁r ▁) ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁float ▁s ph ▁( ▁float ▁r ▁, ▁float ▁h ▁) ▁{ ▁if ▁( ▁r ▁< ▁0 ▁&& ▁h ▁< ▁0 ▁) ▁return ▁-1 ▁; ▁float ▁R ▁= ▁r ▁; ▁return ▁R ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁float ▁r ▁= ▁4 ▁, ▁h ▁= ▁8 ▁; ▁c out ▁<< ▁s ph ▁( ▁r ▁, ▁h ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁numberOf C uts ▁( ▁int ▁M ▁, ▁int ▁N ▁) ▁{ ▁int ▁result ▁= ▁0 ▁; ▁result ▁= ▁( ▁M ▁- ▁1 ▁) ▁* ▁( ▁N ▁- ▁1 ▁) ▁; ▁return ▁result ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁M ▁= ▁4 ▁, ▁N ▁= ▁4 ▁; ▁int ▁C uts ▁= ▁numberOf C uts ▁( ▁M ▁, ▁N ▁) ▁; ▁c out ▁<< ▁" ▁Maximum ▁c uts ▁= ▁" ▁<< ▁C uts ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁# include ▁< iom an ip > ▁NEW _ LINE ▁# include ▁< i ost ream > ▁NEW _ LINE ▁# include ▁< math . h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁equation _ par ab ola ▁( ▁float ▁x 1 ▁, ▁float ▁y 1 ▁, ▁float ▁a ▁, ▁float ▁b ▁, ▁float ▁c ▁) ▁{ ▁float ▁t ▁= ▁a ▁* ▁a ▁+ ▁b ▁* ▁b ▁; ▁float ▁a 1 ▁= ▁t ▁- ▁( ▁a ▁* ▁a ▁) ▁; ▁float ▁b 1 ▁= ▁t ▁- ▁( ▁b ▁* ▁b ▁) ▁; ▁float ▁c 1 ▁= ▁( ▁-2 ▁* ▁t ▁* ▁x 1 ▁) ▁- ▁( ▁2 ▁* ▁c ▁* ▁a ▁) ▁; ▁float ▁d 1 ▁= ▁( ▁-2 ▁* ▁t ▁* ▁y 1 ▁) ▁- ▁( ▁2 ▁* ▁c ▁* ▁b ▁) ▁; ▁float ▁e 1 ▁= ▁-2 ▁* ▁a ▁* ▁b ▁; ▁float ▁f 1 ▁= ▁( ▁- ▁c ▁* ▁c ▁) ▁+ ▁( ▁t ▁* ▁x 1 ▁* ▁x 1 ▁) ▁+ ▁( ▁t ▁* ▁y 1 ▁* ▁y 1 ▁) ▁; ▁std ▁:: ▁c out ▁<< ▁std ▁:: ▁fixed ▁; ▁std ▁:: ▁c out ▁<< ▁std ▁:: ▁set precision ▁( ▁1 ▁) ▁; ▁c out ▁<< ▁" ▁equation ▁of ▁par ab ola ▁is ▁" ▁<< ▁a 1 ▁<< ▁" ▁x ▁^ ▁2 ▁+ ▁" ▁<< ▁b 1 ▁<< ▁" ▁y ▁^ ▁2 ▁+ ▁" ▁<< ▁c 1 ▁<< ▁" ▁x ▁+ ▁" ▁<< ▁d 1 ▁<< ▁" ▁y ▁+ ▁" ▁<< ▁e 1 ▁<< ▁" ▁xy ▁+ ▁" ▁<< ▁f 1 ▁<< ▁" ▁= ▁0 ▁. ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁float ▁x 1 ▁= ▁0 ▁; ▁float ▁y 1 ▁= ▁0 ▁; ▁float ▁a ▁= ▁3 ▁; ▁float ▁b ▁= ▁-4 ▁; ▁float ▁c ▁= ▁2 ▁; ▁equation _ par ab ola ▁( ▁x 1 ▁, ▁y 1 ▁, ▁a ▁, ▁b ▁, ▁c ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁float ▁area ▁( ▁float ▁r ▁) ▁{ ▁return ▁( ▁0.5 ▁) ▁* ▁( ▁3.14 ▁) ▁* ▁( ▁r ▁* ▁r ▁) ▁; ▁} ▁float ▁per imeter ▁( ▁float ▁r ▁) ▁{ ▁return ▁( ▁3.14 ▁) ▁* ▁( ▁r ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁r ▁= ▁10 ▁; ▁c out ▁<< ▁" ▁The ▁Area ▁of ▁Sem ic ircle ▁: ▁" ▁<< ▁area ▁( ▁r ▁) ▁<< ▁end l ▁; ▁c out ▁<< ▁" ▁The ▁Per imeter ▁of ▁Sem ic ircle ▁: ▁" ▁<< ▁per imeter ▁( ▁r ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁Ar rive ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁>= ▁abs ▁( ▁a ▁) ▁+ ▁abs ▁( ▁b ▁) ▁and ▁( ▁n ▁- ▁( ▁abs ▁( ▁a ▁) ▁+ ▁abs ▁( ▁b ▁) ▁) ▁) ▁% ▁2 ▁== ▁0 ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁= ▁5 ▁, ▁b ▁= ▁5 ▁, ▁n ▁= ▁11 ▁; ▁if ▁( ▁Ar rive ▁( ▁a ▁, ▁b ▁, ▁n ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁float ▁triangle area ▁( ▁float ▁l ▁, ▁float ▁b ▁) ▁{ ▁if ▁( ▁l ▁< ▁0 ▁b ▁< ▁0 ▁) ▁return ▁-1 ▁; ▁float ▁area ▁= ▁( ▁l ▁* ▁b ▁) ▁/ ▁2 ▁; ▁return ▁area ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁float ▁l ▁= ▁5 ▁, ▁b ▁= ▁4 ▁; ▁c out ▁<< ▁triangle area ▁( ▁l ▁, ▁b ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁float ▁square Area ▁( ▁float ▁l ▁, ▁float ▁b ▁, ▁float ▁h ▁) ▁{ ▁if ▁( ▁l ▁< ▁0 ▁b ▁< ▁0 ▁h ▁< ▁0 ▁) ▁return ▁-1 ▁; ▁float ▁a ▁= ▁( ▁l ▁* ▁b ▁) ▁/ ▁( ▁l ▁+ ▁b ▁) ▁; ▁return ▁a ▁* ▁a ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁float ▁l ▁= ▁5 ▁, ▁b ▁= ▁12 ▁, ▁h ▁= ▁13 ▁; ▁c out ▁<< ▁square Area ▁( ▁l ▁, ▁b ▁, ▁h ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁Find Points ▁( ▁int ▁x 1 ▁, ▁int ▁y 1 ▁, ▁int ▁x 2 ▁, ▁int ▁y 2 ▁, ▁int ▁x 3 ▁, ▁int ▁y 3 ▁, ▁int ▁x 4 ▁, ▁int ▁y 4 ▁) ▁{ ▁int ▁x 5 ▁= ▁max ▁( ▁x 1 ▁, ▁x 3 ▁) ▁; ▁int ▁y 5 ▁= ▁max ▁( ▁y 1 ▁, ▁y 3 ▁) ▁; ▁int ▁x 6 ▁= ▁min ▁( ▁x 2 ▁, ▁x 4 ▁) ▁; ▁int ▁y 6 ▁= ▁min ▁( ▁y 2 ▁, ▁y 4 ▁) ▁; ▁if ▁( ▁x 5 ▁> ▁x 6 ▁y 5 ▁> ▁y 6 ▁) ▁{ ▁c out ▁<< ▁" ▁No ▁intersection ▁" ▁; ▁return ▁; ▁} ▁c out ▁<< ▁" ▁( ▁" ▁<< ▁x 5 ▁<< ▁" ▁, ▁" ▁<< ▁y 5 ▁<< ▁" ▁) ▁" ▁; ▁c out ▁<< ▁" ▁( ▁" ▁<< ▁x 6 ▁<< ▁" ▁, ▁" ▁<< ▁y 6 ▁<< ▁" ▁) ▁" ▁; ▁int ▁x 7 ▁= ▁x 5 ▁; ▁int ▁y 7 ▁= ▁y 6 ▁; ▁c out ▁<< ▁" ▁( ▁" ▁<< ▁x 7 ▁<< ▁" ▁, ▁" ▁<< ▁y 7 ▁<< ▁" ▁) ▁" ▁; ▁int ▁x 8 ▁= ▁x 6 ▁; ▁int ▁y 8 ▁= ▁y 5 ▁; ▁c out ▁<< ▁" ▁( ▁" ▁<< ▁x 8 ▁<< ▁" ▁, ▁" ▁<< ▁y 8 ▁<< ▁" ▁) ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁x 1 ▁= ▁0 ▁, ▁y 1 ▁= ▁0 ▁, ▁x 2 ▁= ▁10 ▁, ▁y 2 ▁= ▁8 ▁; ▁int ▁x 3 ▁= ▁2 ▁, ▁y 3 ▁= ▁3 ▁, ▁x 4 ▁= ▁7 ▁, ▁y 4 ▁= ▁9 ▁; ▁Find Points ▁( ▁x 1 ▁, ▁y 1 ▁, ▁x 2 ▁, ▁y 2 ▁, ▁x 3 ▁, ▁y 3 ▁, ▁x 4 ▁, ▁y 4 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁# include ▁< math . h > ▁NEW _ LINE ▁# include ▁< i ost ream > ▁NEW _ LINE ▁# include ▁< iom an ip > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁equation _ plane ▁( ▁float ▁x 1 ▁, ▁float ▁y 1 ▁, ▁float ▁z 1 ▁, ▁float ▁x 2 ▁, ▁float ▁y 2 ▁, ▁float ▁z 2 ▁, ▁float ▁x 3 ▁, ▁float ▁y 3 ▁, ▁float ▁z 3 ▁) ▁{ ▁float ▁a 1 ▁= ▁x 2 ▁- ▁x 1 ▁; ▁float ▁b 1 ▁= ▁y 2 ▁- ▁y 1 ▁; ▁float ▁c 1 ▁= ▁z 2 ▁- ▁z 1 ▁; ▁float ▁a 2 ▁= ▁x 3 ▁- ▁x 1 ▁; ▁float ▁b 2 ▁= ▁y 3 ▁- ▁y 1 ▁; ▁float ▁c 2 ▁= ▁z 3 ▁- ▁z 1 ▁; ▁float ▁a ▁= ▁b 1 ▁* ▁c 2 ▁- ▁b 2 ▁* ▁c 1 ▁; ▁float ▁b ▁= ▁a 2 ▁* ▁c 1 ▁- ▁a 1 ▁* ▁c 2 ▁; ▁float ▁c ▁= ▁a 1 ▁* ▁b 2 ▁- ▁b 1 ▁* ▁a 2 ▁; ▁float ▁d ▁= ▁( ▁- ▁a ▁* ▁x 1 ▁- ▁b ▁* ▁y 1 ▁- ▁c ▁* ▁z 1 ▁) ▁; ▁std ▁:: ▁c out ▁<< ▁std ▁:: ▁fixed ▁; ▁std ▁:: ▁c out ▁<< ▁std ▁:: ▁set precision ▁( ▁2 ▁) ▁; ▁c out ▁<< ▁" ▁equation ▁of ▁plane ▁is ▁" ▁<< ▁a ▁<< ▁" ▁x ▁+ ▁" ▁<< ▁b ▁<< ▁" ▁y ▁+ ▁" ▁<< ▁c ▁<< ▁" ▁z ▁+ ▁" ▁<< ▁d ▁<< ▁" ▁= ▁0 ▁. ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁float ▁x 1 ▁= ▁-1 ▁; ▁float ▁y 1 ▁= ▁2 ▁; ▁float ▁z 1 ▁= ▁1 ▁; ▁float ▁x 2 ▁= ▁0 ▁; ▁float ▁y 2 ▁= ▁-3 ▁; ▁float ▁z 2 ▁= ▁2 ▁; ▁float ▁x 3 ▁= ▁1 ▁; ▁float ▁y 3 ▁= ▁1 ▁; ▁float ▁z 3 ▁= ▁-4 ▁; ▁equation _ plane ▁( ▁x 1 ▁, ▁y 1 ▁, ▁z 1 ▁, ▁x 2 ▁, ▁y 2 ▁, ▁z 2 ▁, ▁x 3 ▁, ▁y 3 ▁, ▁z 3 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁# include ▁< math . h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁oct ant ▁( ▁float ▁x ▁, ▁float ▁y ▁, ▁float ▁z ▁) ▁{ ▁if ▁( ▁x ▁>= ▁0 ▁&& ▁y ▁>= ▁0 ▁&& ▁z ▁>= ▁0 ▁) ▁c out ▁<< ▁" ▁Point ▁lies ▁in ▁1 st ▁oct ant ▁STRNEWLINE ▁" ▁; ▁else ▁if ▁( ▁x ▁< ▁0 ▁&& ▁y ▁>= ▁0 ▁&& ▁z ▁>= ▁0 ▁) ▁c out ▁<< ▁" ▁Point ▁lies ▁in ▁2 nd ▁oct ant ▁STRNEWLINE ▁" ▁; ▁else ▁if ▁( ▁x ▁< ▁0 ▁&& ▁y ▁< ▁0 ▁&& ▁z ▁>= ▁0 ▁) ▁c out ▁<< ▁" ▁Point ▁lies ▁in ▁3 rd ▁oct ant ▁STRNEWLINE ▁" ▁; ▁else ▁if ▁( ▁x ▁>= ▁0 ▁&& ▁y ▁< ▁0 ▁&& ▁z ▁>= ▁0 ▁) ▁c out ▁<< ▁" ▁Point ▁lies ▁in ▁4 th ▁oct ant ▁STRNEWLINE ▁" ▁; ▁else ▁if ▁( ▁x ▁>= ▁0 ▁&& ▁y ▁>= ▁0 ▁&& ▁z ▁< ▁0 ▁) ▁c out ▁<< ▁" ▁Point ▁lies ▁in ▁5 th ▁oct ant ▁STRNEWLINE ▁" ▁; ▁else ▁if ▁( ▁x ▁< ▁0 ▁&& ▁y ▁>= ▁0 ▁&& ▁z ▁< ▁0 ▁) ▁c out ▁<< ▁" ▁Point ▁lies ▁in ▁6 th ▁oct ant ▁STRNEWLINE ▁" ▁; ▁else ▁if ▁( ▁x ▁< ▁0 ▁&& ▁y ▁< ▁0 ▁&& ▁z ▁< ▁0 ▁) ▁c out ▁<< ▁" ▁Point ▁lies ▁in ▁7 th ▁oct ant ▁STRNEWLINE ▁" ▁; ▁else ▁if ▁( ▁x ▁>= ▁0 ▁&& ▁y ▁< ▁0 ▁&& ▁z ▁< ▁0 ▁) ▁c out ▁<< ▁" ▁Point ▁lies ▁in ▁8 th ▁oct ant ▁STRNEWLINE ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁float ▁x ▁= ▁2 ▁, ▁y ▁= ▁3 ▁, ▁z ▁= ▁4 ▁; ▁oct ant ▁( ▁x ▁, ▁y ▁, ▁z ▁) ▁; ▁x ▁= ▁-4 ▁, ▁y ▁= ▁2 ▁, ▁z ▁= ▁- 8 ▁; ▁oct ant ▁( ▁x ▁, ▁y ▁, ▁z ▁) ▁; ▁x ▁= ▁- 6 ▁, ▁y ▁= ▁-2 ▁, ▁z ▁= ▁8 ▁; ▁oct ant ▁( ▁x ▁, ▁y ▁, ▁z ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁p ent agon _ py ramid al ▁( ▁int ▁n ▁) ▁{ ▁return ▁n ▁* ▁n ▁* ▁( ▁n ▁+ ▁1 ▁) ▁/ ▁2 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁4 ▁; ▁c out ▁<< ▁p ent agon _ py ramid al ▁( ▁n ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁other EndPoint ▁( ▁int ▁x 1 ▁, ▁int ▁y 1 ▁, ▁int ▁m 1 ▁, ▁int ▁m 2 ▁) ▁{ ▁float ▁x 2 ▁= ▁( ▁float ▁) ▁( ▁2 ▁* ▁m 1 ▁- ▁x 1 ▁) ▁; ▁float ▁y 2 ▁= ▁( ▁float ▁) ▁( ▁2 ▁* ▁m 2 ▁- ▁y 1 ▁) ▁; ▁c out ▁<< ▁" ▁x 2 ▁= ▁" ▁<< ▁x 2 ▁<< ▁" ▁, ▁" ▁<< ▁" ▁y 2 ▁= ▁" ▁<< ▁y 2 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁x 1 ▁= ▁-4 ▁, ▁y 1 ▁= ▁-1 ▁, ▁m 1 ▁= ▁3 ▁, ▁m 2 ▁= ▁5 ▁; ▁other EndPoint ▁( ▁x 1 ▁, ▁y 1 ▁, ▁m 1 ▁, ▁m 2 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find Triangle ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁b ▁[ ▁n ▁+ ▁2 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁b ▁[ ▁i ▁] ▁= ▁a ▁[ ▁i ▁] ▁* ▁a ▁[ ▁i ▁] ▁; ▁sort ▁( ▁a ▁, ▁a ▁+ ▁n ▁) ▁; ▁sort ▁( ▁b ▁, ▁b ▁+ ▁n ▁) ▁; ▁int ▁x ▁= ▁0 ▁, ▁y ▁= ▁0 ▁, ▁z ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁p ▁= ▁i ▁+ ▁1 ▁; ▁int ▁q ▁= ▁i ▁+ ▁1 ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁while ▁( ▁p ▁< ▁n ▁- ▁1 ▁&& ▁b ▁[ ▁i ▁] ▁+ ▁b ▁[ ▁j ▁] ▁>= ▁b ▁[ ▁p ▁+ ▁1 ▁] ▁) ▁p ▁++ ▁; ▁q ▁= ▁max ▁( ▁q ▁, ▁p ▁) ▁; ▁while ▁( ▁q ▁< ▁n ▁- ▁1 ▁&& ▁a ▁[ ▁i ▁] ▁+ ▁a ▁[ ▁j ▁] ▁> ▁a ▁[ ▁q ▁+ ▁1 ▁] ▁) ▁q ▁++ ▁; ▁if ▁( ▁b ▁[ ▁i ▁] ▁+ ▁b ▁[ ▁j ▁] ▁== ▁b ▁[ ▁p ▁] ▁) ▁{ ▁x ▁+= ▁max ▁( ▁p ▁- ▁j ▁- ▁1 ▁, ▁0 ▁) ▁; ▁y ▁++ ▁; ▁z ▁+= ▁q ▁- ▁p ▁; ▁} ▁else ▁{ ▁x ▁+= ▁max ▁( ▁p ▁- ▁j ▁, ▁0 ▁) ▁; ▁z ▁+= ▁q ▁- ▁p ▁; ▁} ▁} ▁} ▁c out ▁<< ▁" ▁Ac ute ▁Triangle ▁: ▁" ▁<< ▁x ▁<< ▁end l ▁; ▁c out ▁<< ▁" ▁Right ▁Triangle ▁: ▁" ▁<< ▁y ▁<< ▁end l ▁; ▁c out ▁<< ▁" ▁Ob t use ▁Triangle ▁: ▁" ▁<< ▁z ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁9 ▁, ▁10 ▁, ▁12 ▁, ▁15 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁find Triangle ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁double ▁polygon Area ▁( ▁double ▁X ▁[ ▁] ▁, ▁double ▁Y ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁double ▁area ▁= ▁0.0 ▁; ▁int ▁j ▁= ▁n ▁- ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁area ▁+= ▁( ▁X ▁[ ▁j ▁] ▁+ ▁X ▁[ ▁i ▁] ▁) ▁* ▁( ▁Y ▁[ ▁j ▁] ▁- ▁Y ▁[ ▁i ▁] ▁) ▁; ▁} ▁return ▁abs ▁( ▁area ▁/ ▁2.0 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁double ▁X ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁2 ▁, ▁4 ▁} ▁; ▁double ▁Y ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁7 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁X ▁) ▁/ ▁sizeof ▁( ▁X ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁polygon Area ▁( ▁X ▁, ▁Y ▁, ▁n ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁double ▁polygon Area ▁( ▁double ▁X ▁[ ▁] ▁, ▁double ▁Y ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁double ▁area ▁= ▁0.0 ▁; ▁int ▁j ▁= ▁n ▁- ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁area ▁+= ▁( ▁X ▁[ ▁j ▁] ▁+ ▁X ▁[ ▁i ▁] ▁) ▁* ▁( ▁Y ▁[ ▁j ▁] ▁- ▁Y ▁[ ▁i ▁] ▁) ▁; ▁} ▁return ▁abs ▁( ▁area ▁/ ▁2.0 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁double ▁X ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁2 ▁, ▁4 ▁} ▁; ▁double ▁Y ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁7 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁X ▁) ▁/ ▁sizeof ▁( ▁X ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁polygon Area ▁( ▁X ▁, ▁Y ▁, ▁n ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁int ▁max n ▁= ▁10000 1 ▁; ▁int ▁gp f ▁[ ▁max n ▁] ▁; ▁void ▁modified S ieve ▁( ▁) ▁{ ▁mem set ▁( ▁gp f ▁, ▁0 ▁, ▁sizeof ▁( ▁gp f ▁) ▁) ▁; ▁gp f ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁gp f ▁[ ▁1 ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁< ▁max n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁gp f ▁[ ▁i ▁] ▁> ▁0 ▁) ▁continue ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁< ▁max n ▁; ▁j ▁+= ▁i ▁) ▁{ ▁gp f ▁[ ▁j ▁] ▁= ▁max ▁( ▁i ▁, ▁gp f ▁[ ▁j ▁] ▁) ▁; ▁} ▁} ▁} ▁int ▁greatest Valid Int ▁( ▁int ▁N ▁) ▁{ ▁modified S ieve ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁N ▁; ▁i ▁> ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁gp f ▁[ ▁i ▁] ▁> ▁sqrt ▁( ▁i ▁) ▁) ▁{ ▁return ▁i ▁; ▁} ▁} ▁return ▁-1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁25 ▁; ▁c out ▁<< ▁greatest Valid Int ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁double ▁sub factor ial ▁( ▁int ▁N ▁) ▁{ ▁double ▁res ▁= ▁0 ▁, ▁fact ▁= ▁1 ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁fact ▁= ▁fact ▁* ▁i ▁; ▁if ▁( ▁count ▁% ▁2 ▁== ▁0 ▁) ▁res ▁= ▁res ▁- ▁( ▁1 ▁/ ▁fact ▁) ▁; ▁else ▁res ▁= ▁res ▁+ ▁( ▁1 ▁/ ▁fact ▁) ▁; ▁count ▁++ ▁; ▁} ▁return ▁fact ▁* ▁( ▁1 ▁+ ▁res ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁4 ▁; ▁c out ▁<< ▁sub factor ial ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Pairs ▁( ▁int ▁N ▁) ▁{ ▁int ▁res ▁= ▁0 ▁; ▁for ▁( ▁int ▁q ▁= ▁1 ▁; ▁q ▁* ▁q ▁<= ▁N ▁; ▁q ▁++ ▁) ▁{ ▁int ▁max P ▁= ▁min ▁( ▁2 ▁* ▁N ▁- ▁q ▁, ▁N ▁/ ▁q ▁) ▁; ▁if ▁( ▁max P ▁< ▁q ▁) ▁continue ▁; ▁int ▁cnt ▁= ▁max P ▁- ▁q ▁+ ▁1 ▁; ▁res ▁+= ▁( ▁cnt ▁/ ▁2 ▁+ ▁( ▁cnt ▁& ▁1 ▁) ▁) ▁; ▁} ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁3 ▁; ▁c out ▁<< ▁count Pairs ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁last Positive Element ▁( ▁vector ▁< ▁int ▁> ▁arr ▁) ▁{ ▁int ▁N ▁= ▁arr ▁. ▁size ▁( ▁) ▁; ▁if ▁( ▁N ▁== ▁1 ▁) ▁return ▁arr ▁[ ▁0 ▁] ▁; ▁int ▁greatest ▁= ▁-1 ▁, ▁second Gre at est ▁= ▁-1 ▁; ▁for ▁( ▁int ▁x ▁: ▁arr ▁) ▁{ ▁if ▁( ▁x ▁>= ▁greatest ▁) ▁{ ▁second Gre at est ▁= ▁greatest ▁; ▁greatest ▁= ▁x ▁; ▁} ▁else ▁if ▁( ▁x ▁>= ▁second Gre at est ▁) ▁{ ▁second Gre at est ▁= ▁x ▁; ▁} ▁} ▁return ▁greatest ▁- ▁second Gre at est ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁int ▁> ▁arr ▁= ▁{ ▁3 ▁, ▁5 ▁, ▁4 ▁, ▁7 ▁} ▁; ▁c out ▁<< ▁last Positive Element ▁( ▁arr ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find Sum Of All Sub sets ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁factorial _ N ▁= ▁1 ▁, ▁factorial _ d ▁= ▁1 ▁, ▁factorial _ D ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁factorial _ N ▁*= ▁i ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁k ▁- ▁1 ▁; ▁i ▁++ ▁) ▁factorial _ d ▁*= ▁i ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁- ▁k ▁; ▁i ▁++ ▁) ▁factorial _ D ▁*= ▁i ▁; ▁int ▁freq ▁= ▁factorial _ N ▁/ ▁( ▁factorial _ d ▁* ▁factorial _ D ▁) ▁; ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁sum ▁= ▁sum ▁* ▁freq ▁; ▁c out ▁<< ▁" ▁Sum ▁of ▁all ▁subsets ▁of ▁size ▁= ▁" ▁<< ▁k ▁<< ▁" ▁is ▁= ▁> ▁" ▁<< ▁sum ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁4 ▁, ▁k ▁= ▁2 ▁; ▁find Sum Of All Sub sets ▁( ▁arr ▁, ▁n ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁maximum Tri plet X OR ▁( ▁int ▁A ▁, ▁int ▁B ▁, ▁int ▁C ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁30 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁int ▁cur ▁= ▁1 ▁<< ▁i ▁; ▁if ▁( ▁A ▁>= ▁cur ▁) ▁{ ▁ans ▁+= ▁cur ▁; ▁A ▁-= ▁cur ▁; ▁} ▁else ▁if ▁( ▁B ▁>= ▁cur ▁) ▁{ ▁ans ▁+= ▁cur ▁; ▁B ▁-= ▁cur ▁; ▁} ▁else ▁if ▁( ▁C ▁>= ▁cur ▁) ▁{ ▁ans ▁+= ▁cur ▁; ▁C ▁-= ▁cur ▁; ▁} ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁= ▁6 ▁; ▁int ▁B ▁= ▁2 ▁; ▁int ▁C ▁= ▁10 ▁; ▁c out ▁<< ▁maximum Tri plet X OR ▁( ▁A ▁, ▁B ▁, ▁C ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max Unique Elements ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁unordered _ map ▁< ▁int ▁, ▁int ▁> ▁mp ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁mp ▁[ ▁A ▁[ ▁i ▁] ▁] ▁++ ▁; ▁} ▁int ▁cnt ▁= ▁0 ▁; ▁for ▁( ▁auto ▁x ▁: ▁mp ▁) ▁{ ▁if ▁( ▁x ▁. ▁second ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁cnt ▁++ ▁; ▁} ▁} ▁int ▁ans ▁= ▁mp ▁. ▁size ▁( ▁) ▁; ▁if ▁( ▁cnt ▁% ▁2 ▁== ▁1 ▁) ▁{ ▁ans ▁-- ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁5 ▁; ▁int ▁A ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁1 ▁, ▁3 ▁, ▁7 ▁} ▁; ▁c out ▁<< ▁max Unique Elements ▁( ▁A ▁, ▁N ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁m ▁= ▁100 000000 7 ▁; ▁int ▁power ▁( ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁int ▁res ▁= ▁1 ▁; ▁while ▁( ▁y ▁> ▁0 ▁) ▁{ ▁if ▁( ▁( ▁y ▁& ▁1 ▁) ▁!= ▁0 ▁) ▁res ▁= ▁( ▁res ▁* ▁x ▁) ▁% ▁m ▁; ▁y ▁= ▁y ▁>> ▁1 ▁; ▁x ▁= ▁( ▁x ▁* ▁x ▁) ▁% ▁m ▁; ▁} ▁return ▁res ▁; ▁} ▁int ▁count ND ig it Number ▁( ▁int ▁N ▁) ▁{ ▁int ▁ne ▁= ▁N ▁/ ▁2 ▁+ ▁N ▁% ▁2 ▁; ▁int ▁no ▁= ▁floor ▁( ▁N ▁/ ▁2 ▁) ▁; ▁return ▁power ▁( ▁4 ▁, ▁ne ▁) ▁* ▁power ▁( ▁5 ▁, ▁no ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁5 ▁; ▁c out ▁<< ▁count ND ig it Number ▁( ▁N ▁) ▁% ▁m ▁<< ▁end l ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find Pairs ▁( ▁int ▁p ▁, ▁int ▁q ▁, ▁int ▁r ▁) ▁{ ▁vector ▁< ▁int ▁> ▁v ▁; ▁for ▁( ▁int ▁i ▁= ▁p ▁; ▁i ▁<= ▁q ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁% ▁r ▁== ▁0 ▁) ▁{ ▁v ▁. ▁push _ back ▁( ▁i ▁) ▁; ▁} ▁} ▁vector ▁< ▁pair ▁< ▁int ▁, ▁int ▁> ▁> ▁ans ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁v ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁v ▁. ▁size ▁( ▁) ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁v ▁[ ▁i ▁] ▁* ▁v ▁[ ▁j ▁] ▁>= ▁p ▁* ▁q ▁/ ▁4 ▁&& ▁v ▁[ ▁i ▁] ▁* ▁v ▁[ ▁j ▁] ▁<= ▁p ▁* ▁q ▁) ▁{ ▁ans ▁. ▁push _ back ▁( ▁{ ▁v ▁[ ▁i ▁] ▁, ▁v ▁[ ▁j ▁] ▁} ▁) ▁; ▁} ▁} ▁} ▁if ▁( ▁ans ▁. ▁size ▁( ▁) ▁== ▁0 ▁) ▁{ ▁c out ▁<< ▁-1 ▁<< ▁end l ▁; ▁} ▁else ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁ans ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁c out ▁<< ▁ans ▁[ ▁i ▁] ▁. ▁first ▁<< ▁" ▁" ▁<< ▁ans ▁[ ▁i ▁] ▁. ▁second ▁<< ▁end l ▁; ▁} ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁p ▁= ▁14 ▁, ▁q ▁= ▁30 ▁, ▁r ▁= ▁5 ▁; ▁find Pairs ▁( ▁p ▁, ▁q ▁, ▁r ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁K ad ane ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁largest Sum ▁= ▁0 ▁, ▁curr Max ▁= ▁0 ▁; ▁int ▁curr Sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁curr Sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁curr Max ▁= ▁max ▁( ▁curr Max ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁largest Sum ▁= ▁max ▁( ▁largest Sum ▁, ▁curr Max ▁* ▁curr Sum ▁) ▁; ▁if ▁( ▁curr Sum ▁< ▁0 ▁) ▁{ ▁curr Max ▁= ▁0 ▁; ▁curr Sum ▁= ▁0 ▁; ▁} ▁} ▁return ▁largest Sum ▁; ▁} ▁int ▁maximum Weight ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁largest Sum ▁= ▁K ad ane ▁( ▁arr ▁, ▁n ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁arr ▁[ ▁i ▁] ▁= ▁- ▁arr ▁[ ▁i ▁] ▁; ▁} ▁largest Sum ▁= ▁max ▁( ▁largest Sum ▁, ▁K ad ane ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁return ▁largest Sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁-3 ▁, ▁8 ▁, ▁-2 ▁, ▁5 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁maximum Weight ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁maximum Turn s ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁Count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁while ▁( ▁arr ▁[ ▁i ▁] ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁Count ▁++ ▁; ▁arr ▁[ ▁i ▁] ▁= ▁arr ▁[ ▁i ▁] ▁/ ▁2 ▁; ▁} ▁} ▁return ▁Count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁2 ▁, ▁4 ▁} ▁; ▁int ▁M ▁= ▁3 ▁, ▁K ▁= ▁2 ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁maximum Turn s ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁isP ossible ▁( ▁int ▁W ▁, ▁int ▁B ▁, ▁int ▁D ▁) ▁{ ▁if ▁( ▁W ▁> ▁B ▁) ▁swap ▁( ▁W ▁, ▁B ▁) ▁; ▁if ▁( ▁B ▁> ▁W ▁* ▁( ▁D ▁+ ▁1 ▁) ▁) ▁c out ▁<< ▁" ▁NO ▁" ▁<< ▁end l ▁; ▁else ▁c out ▁<< ▁" ▁YES ▁" ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁W ▁= ▁2 ▁; ▁int ▁B ▁= ▁5 ▁; ▁int ▁D ▁= ▁2 ▁; ▁isP ossible ▁( ▁W ▁, ▁B ▁, ▁D ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁GC D ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁if ▁( ▁b ▁== ▁0 ▁) ▁return ▁a ▁; ▁return ▁GC D ▁( ▁b ▁, ▁a ▁% ▁b ▁) ▁; ▁} ▁int ▁max G CD In Range ▁( ▁int ▁L ▁, ▁int ▁R ▁) ▁{ ▁int ▁ans ▁= ▁1 ▁; ▁for ▁( ▁int ▁Z ▁= ▁R ▁; ▁Z ▁>= ▁1 ▁; ▁Z ▁-- ▁) ▁{ ▁if ▁( ▁( ▁R ▁/ ▁Z ▁) ▁- ▁( ▁L ▁- ▁1 ▁) ▁/ ▁Z ▁> ▁1 ▁) ▁{ ▁ans ▁= ▁Z ▁; ▁break ▁; ▁} ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁L ▁= ▁102 ▁; ▁int ▁R ▁= ▁139 ▁; ▁c out ▁<< ▁max G CD In Range ▁( ▁L ▁, ▁R ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is Prime ▁( ▁int ▁X ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁* ▁i ▁<= ▁X ▁; ▁i ▁++ ▁) ▁return ▁false ▁; ▁return ▁true ▁; ▁} ▁void ▁print Pr imes ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁A ▁[ ▁i ▁] ▁- ▁1 ▁; ▁; ▁j ▁-- ▁) ▁{ ▁if ▁( ▁is Prime ▁( ▁j ▁) ▁) ▁{ ▁c out ▁<< ▁j ▁<< ▁" ▁" ▁; ▁break ▁; ▁} ▁} ▁for ▁( ▁int ▁j ▁= ▁A ▁[ ▁i ▁] ▁+ ▁1 ▁; ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁is Prime ▁( ▁j ▁) ▁) ▁{ ▁c out ▁<< ▁j ▁<< ▁" ▁" ▁; ▁break ▁; ▁} ▁} ▁c out ▁<< ▁end l ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁17 ▁, ▁28 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁A ▁) ▁/ ▁sizeof ▁( ▁A ▁[ ▁0 ▁] ▁) ▁; ▁print Pr imes ▁( ▁A ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Num ▁( ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁int ▁rem ▁= ▁( ▁N ▁+ ▁K ▁) ▁% ▁K ▁; ▁if ▁( ▁rem ▁== ▁0 ▁) ▁return ▁N ▁; ▁else ▁return ▁N ▁+ ▁K ▁- ▁rem ▁; ▁} ▁int ▁find Small est ▁( ▁int ▁M ▁, ▁int ▁N ▁) ▁{ ▁int ▁x ▁= ▁find Num ▁( ▁M ▁, ▁N ▁) ▁; ▁return ▁x ▁- ▁M ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁M ▁= ▁100 ▁, ▁N ▁= ▁28 ▁; ▁c out ▁<< ▁find Small est ▁( ▁M ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁min Time ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁K ▁) ▁{ ▁int ▁max _ ability ▁= ▁A ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁max _ ability ▁= ▁max ▁( ▁max _ ability ▁, ▁A ▁[ ▁i ▁] ▁) ▁; ▁} ▁int ▁tmp ▁[ ▁max _ ability ▁+ ▁1 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁tmp ▁[ ▁A ▁[ ▁i ▁] ▁] ▁++ ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁max _ ability ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁tmp ▁[ ▁i ▁] ▁!= ▁0 ▁) ▁{ ▁if ▁( ▁tmp ▁[ ▁i ▁] ▁* ▁i ▁< ▁K ▁) ▁{ ▁K ▁-= ▁( ▁i ▁* ▁tmp ▁[ ▁i ▁] ▁) ▁; ▁tmp ▁[ ▁i ▁/ ▁2 ▁] ▁+= ▁tmp ▁[ ▁i ▁] ▁; ▁count ▁+= ▁tmp ▁[ ▁i ▁] ▁; ▁if ▁( ▁K ▁<= ▁0 ▁) ▁{ ▁return ▁count ▁; ▁} ▁} ▁else ▁{ ▁if ▁( ▁K ▁% ▁i ▁!= ▁0 ▁) ▁{ ▁count ▁+= ▁( ▁K ▁/ ▁i ▁) ▁+ ▁1 ▁; ▁} ▁else ▁{ ▁count ▁+= ▁( ▁K ▁/ ▁i ▁) ▁; ▁} ▁return ▁count ▁; ▁} ▁} ▁} ▁return ▁-1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁1 ▁, ▁7 ▁, ▁2 ▁, ▁4 ▁} ▁; ▁int ▁N ▁= ▁5 ▁; ▁int ▁K ▁= ▁15 ▁; ▁c out ▁<< ▁min Time ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁min Operations ▁( ▁int ▁N ▁) ▁{ ▁int ▁arr ▁[ ▁N ▁] ▁; ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁arr ▁[ ▁i ▁] ▁= ▁( ▁2 ▁* ▁i ▁) ▁+ ▁1 ▁; ▁sum ▁= ▁sum ▁+ ▁arr ▁[ ▁i ▁] ▁; ▁} ▁int ▁mid ▁= ▁0 ▁; ▁if ▁( ▁N ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁mid ▁= ▁sum ▁/ ▁N ▁; ▁} ▁else ▁{ ▁mid ▁= ▁arr ▁[ ▁N ▁/ ▁2 ▁] ▁; ▁} ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁/ ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁ans ▁+= ▁mid ▁- ▁arr ▁[ ▁i ▁] ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁6 ▁; ▁c out ▁<< ▁min Operations ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁Query ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁Q ▁) ▁{ ▁int ▁mul ▁= ▁1 ▁; ▁int ▁add ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁Q ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁Q ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁== ▁0 ▁) ▁{ ▁add ▁= ▁add ▁+ ▁Q ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁; ▁} ▁else ▁if ▁( ▁Q ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁== ▁1 ▁) ▁{ ▁mul ▁= ▁mul ▁* ▁Q ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁; ▁add ▁= ▁add ▁* ▁Q ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁; ▁} ▁else ▁{ ▁int ▁ans ▁= ▁arr ▁[ ▁Q ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁] ▁* ▁mul ▁+ ▁add ▁; ▁c out ▁<< ▁ans ▁<< ▁" ▁" ▁; ▁} ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁1 ▁, ▁23 ▁, ▁45 ▁, ▁100 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁Q ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁} ▁, ▁{ ▁0 ▁, ▁10 ▁} ▁, ▁{ ▁2 ▁, ▁3 ▁} ▁, ▁{ ▁1 ▁, ▁5 ▁} ▁, ▁{ ▁2 ▁, ▁4 ▁} ▁} ▁; ▁Query ▁( ▁arr ▁, ▁N ▁, ▁Q ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁getMax Pair Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁int ▁pre Max ▁[ ▁N ▁] ▁; ▁pre Max ▁[ ▁0 ▁] ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁pre Max ▁[ ▁i ▁] ▁= ▁max ▁( ▁pre Max ▁[ ▁i ▁- ▁1 ▁] ▁, ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁int ▁res ▁= ▁INT _ MIN ▁; ▁for ▁( ▁int ▁i ▁= ▁K ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁res ▁= ▁max ▁( ▁res ▁, ▁arr ▁[ ▁i ▁] ▁+ ▁pre Max ▁[ ▁i ▁- ▁K ▁] ▁) ▁; ▁} ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁4 ▁, ▁8 ▁, ▁6 ▁, ▁3 ▁} ▁; ▁int ▁K ▁= ▁3 ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁getMax Pair Sum ▁( ▁arr ▁, ▁N ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁Count Pairs ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁res ▁= ▁0 ▁; ▁map ▁< ▁int ▁, ▁int ▁> ▁mp ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁mp ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁++ ▁; ▁} ▁for ▁( ▁auto ▁p ▁: ▁mp ▁) ▁{ ▁int ▁x ▁= ▁p ▁. ▁first ▁; ▁int ▁y ▁= ▁p ▁. ▁second ▁; ▁if ▁( ▁x ▁== ▁1 ▁) ▁{ ▁res ▁+= ▁N ▁- ▁1 ▁; ▁continue ▁; ▁} ▁res ▁+= ▁( ▁y ▁* ▁( ▁y ▁- ▁1 ▁) ▁) ▁/ ▁2 ▁; ▁for ▁( ▁int ▁j ▁= ▁2 ▁; ▁j ▁<= ▁sqrt ▁( ▁x ▁) ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁x ▁% ▁j ▁== ▁0 ▁) ▁{ ▁res ▁+= ▁mp ▁[ ▁j ▁] ▁; ▁if ▁( ▁j ▁!= ▁x ▁/ ▁j ▁) ▁res ▁+= ▁mp ▁[ ▁x ▁/ ▁j ▁] ▁; ▁} ▁} ▁} ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁1 ▁, ▁2 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁Count Pairs ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Min Sum ▁( ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁mat ▁, ▁int ▁N ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁int ▁res ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁i ▁!= ▁j ▁) ▁{ ▁res ▁|= ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁} ▁} ▁sum ▁+= ▁res ▁; ▁} ▁return ▁sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁mat ▁= ▁{ ▁{ ▁-1 ▁, ▁2 ▁, ▁3 ▁} ▁, ▁{ ▁9 ▁, ▁-1 ▁, ▁7 ▁} ▁, ▁{ ▁4 ▁, ▁5 ▁, ▁-1 ▁} ▁} ▁; ▁int ▁N ▁= ▁mat ▁. ▁size ▁( ▁) ▁; ▁c out ▁<< ▁find Min Sum ▁( ▁mat ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max Ad jacent Difference ▁( ▁vector ▁< ▁int ▁> ▁A ▁) ▁{ ▁int ▁diff ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁( ▁int ▁) ▁A ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁diff ▁= ▁max ▁( ▁diff ▁, ▁A ▁[ ▁i ▁] ▁- ▁A ▁[ ▁i ▁- ▁1 ▁] ▁) ▁; ▁} ▁return ▁diff ▁; ▁} ▁int ▁Minimum Value ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁Min Value ▁= ▁INT _ MAX ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁vector ▁< ▁int ▁> ▁new _ arr ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁i ▁== ▁j ▁) ▁continue ▁; ▁new _ arr ▁. ▁push _ back ▁( ▁arr ▁[ ▁j ▁] ▁) ▁; ▁} ▁Min Value ▁= ▁min ▁( ▁Min Value ▁, ▁max Ad jacent Difference ▁( ▁new _ arr ▁) ▁) ▁; ▁} ▁return ▁Min Value ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁7 ▁, ▁8 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁c out ▁<< ▁Minimum Value ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁int ▁mod ▁= ▁100 000000 7 ▁; ▁int ▁power ▁( ▁long ▁long ▁x ▁, ▁unsigned ▁int ▁y ▁) ▁{ ▁int ▁res ▁= ▁1 ▁; ▁x ▁= ▁x ▁% ▁mod ▁; ▁while ▁( ▁y ▁> ▁0 ▁) ▁{ ▁if ▁( ▁y ▁& ▁1 ▁) ▁res ▁= ▁( ▁res ▁* ▁x ▁) ▁% ▁mod ▁; ▁y ▁= ▁y ▁>> ▁1 ▁; ▁x ▁= ▁( ▁x ▁* ▁x ▁) ▁% ▁mod ▁; ▁} ▁return ▁res ▁; ▁} ▁int ▁ant is ym metric Relation ▁( ▁int ▁N ▁) ▁{ ▁return ▁( ▁power ▁( ▁2 ▁, ▁N ▁) ▁* ▁1 LL ▁* ▁power ▁( ▁3 ▁, ▁( ▁N ▁* ▁N ▁- ▁N ▁) ▁/ ▁2 ▁) ▁) ▁% ▁mod ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁2 ▁; ▁c out ▁<< ▁ant is ym metric Relation ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁count Pairs ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁even ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁% ▁2 ▁== ▁0 ▁) ▁even ▁++ ▁; ▁} ▁if ▁( ▁N ▁- ▁even ▁>= ▁1 ▁) ▁{ ▁c out ▁<< ▁even ▁; ▁return ▁; ▁} ▁c out ▁<< ▁0 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁4 ▁, ▁7 ▁, ▁2 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁count Pairs ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁check Perm utation ▁( ▁int ▁ans ▁[ ▁] ▁, ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁Max ▁= ▁INT _ MIN ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁Max ▁= ▁max ▁( ▁Max ▁, ▁ans ▁[ ▁i ▁] ▁) ▁; ▁if ▁( ▁Max ▁!= ▁a ▁[ ▁i ▁] ▁) ▁return ▁false ▁; ▁} ▁return ▁true ▁; ▁} ▁void ▁find Perm utation ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁ans ▁[ ▁n ▁] ▁= ▁{ ▁0 ▁} ▁; ▁unordered _ map ▁< ▁int ▁, ▁int ▁> ▁um ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁um ▁. ▁find ▁( ▁a ▁[ ▁i ▁] ▁) ▁== ▁um ▁. ▁end ▁( ▁) ▁) ▁{ ▁ans ▁[ ▁i ▁] ▁= ▁a ▁[ ▁i ▁] ▁; ▁um ▁[ ▁a ▁[ ▁i ▁] ▁] ▁= ▁i ▁; ▁} ▁} ▁vector ▁< ▁int ▁> ▁v ▁; ▁int ▁j ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁um ▁. ▁find ▁( ▁i ▁) ▁== ▁um ▁. ▁end ▁( ▁) ▁) ▁{ ▁v ▁. ▁push _ back ▁( ▁i ▁) ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁ans ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁ans ▁[ ▁i ▁] ▁= ▁v ▁[ ▁j ▁] ▁; ▁j ▁++ ▁; ▁} ▁} ▁if ▁( ▁check Perm utation ▁( ▁ans ▁, ▁a ▁, ▁n ▁) ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁c out ▁<< ▁ans ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁} ▁} ▁else ▁c out ▁<< ▁" ▁- ▁1" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁5 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁find Perm utation ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁Valid Pairs ▁( ▁int ▁X ▁, ▁int ▁K ▁) ▁{ ▁long ▁long ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁A ▁= ▁-1 000 ▁; ▁A ▁<= ▁1000 ▁; ▁A ▁++ ▁) ▁{ ▁for ▁( ▁int ▁B ▁= ▁-1 000 ▁; ▁B ▁<= ▁1000 ▁; ▁B ▁++ ▁) ▁{ ▁if ▁( ▁pow ▁( ▁A ▁, ▁K ▁) ▁- ▁pow ▁( ▁B ▁, ▁K ▁) ▁== ▁X ▁) ▁{ ▁count ▁++ ▁; ▁c out ▁<< ▁A ▁<< ▁" ▁" ▁<< ▁B ▁<< ▁end l ▁; ▁} ▁} ▁} ▁if ▁( ▁count ▁== ▁0 ▁) ▁{ ▁c out ▁<< ▁" ▁- ▁1" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁long ▁long ▁int ▁X ▁= ▁33 ▁; ▁int ▁K ▁= ▁5 ▁; ▁Valid Pairs ▁( ▁X ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find X OR ▁( ▁vector ▁< ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁> ▁& ▁mat ▁, ▁int ▁N ▁) ▁{ ▁int ▁XOR ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁XOR ▁^= ▁mat ▁[ ▁i ▁] ▁[ ▁i ▁] ▁[ ▁i ▁] ▁; ▁XOR ▁^= ▁mat ▁[ ▁i ▁] ▁[ ▁i ▁] ▁[ ▁N ▁- ▁i ▁- ▁1 ▁] ▁; ▁} ▁c out ▁<< ▁XOR ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁> ▁mat ▁= ▁{ ▁{ ▁{ ▁1 ▁, ▁2 ▁} ▁, ▁{ ▁3 ▁, ▁4 ▁} ▁} ▁, ▁{ ▁{ ▁5 ▁, ▁6 ▁} ▁, ▁{ ▁7 ▁, ▁8 ▁} ▁} ▁} ▁; ▁int ▁N ▁= ▁mat ▁. ▁size ▁( ▁) ▁; ▁find X OR ▁( ▁mat ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁check W inner ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁diff ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁diff ▁-= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁if ▁( ▁diff ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁c out ▁<< ▁" ▁A ▁" ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁" ▁B ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁check W inner ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁check Even Power ▁( ▁long ▁long ▁int ▁N ▁) ▁{ ▁if ▁( ▁( ▁N ▁& ▁( ▁N ▁- ▁1 ▁) ▁) ▁!= ▁0 ▁) ▁return ▁false ▁; ▁N ▁= ▁N ▁& ▁0 x 5555 5555 ▁; ▁return ▁( ▁N ▁> ▁0 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁4 ▁; ▁c out ▁<< ▁check Even Power ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁distinct ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁map ▁< ▁int ▁, ▁int ▁> ▁m pp ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁m pp ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁= ▁1 ▁; ▁} ▁return ▁m pp ▁. ▁size ▁( ▁) ▁; ▁} ▁int ▁max Sub Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁, ▁int ▁total Distinct ▁) ▁{ ▁if ▁( ▁k ▁> ▁n ▁) ▁return ▁0 ▁; ▁int ▁max m ▁= ▁0 ▁, ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁k ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁= ▁0 ▁; ▁set ▁< ▁int ▁> ▁st ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁< ▁i ▁+ ▁k ▁; ▁j ▁++ ▁) ▁{ ▁sum ▁+= ▁arr ▁[ ▁j ▁] ▁; ▁st ▁. ▁insert ▁( ▁arr ▁[ ▁j ▁] ▁) ▁; ▁} ▁if ▁( ▁( ▁int ▁) ▁st ▁. ▁size ▁( ▁) ▁== ▁total Distinct ▁) ▁max m ▁= ▁max ▁( ▁sum ▁, ▁max m ▁) ▁; ▁} ▁return ▁max m ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁7 ▁, ▁7 ▁, ▁2 ▁, ▁4 ▁, ▁2 ▁, ▁7 ▁, ▁4 ▁, ▁6 ▁, ▁6 ▁, ▁6 ▁} ▁; ▁int ▁K ▁= ▁6 ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁total Distinct ▁= ▁distinct ▁( ▁arr ▁, ▁N ▁) ▁; ▁c out ▁<< ▁( ▁max Sub Sum ▁( ▁arr ▁, ▁N ▁, ▁K ▁, ▁total Distinct ▁) ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁partition Array ▁( ▁int ▁* ▁a ▁, ▁int ▁n ▁) ▁{ ▁int ▁* ▁Min ▁= ▁new ▁int ▁[ ▁n ▁] ▁; ▁int ▁Mini ▁= ▁INT _ MAX ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁Mini ▁= ▁min ▁( ▁Mini ▁, ▁a ▁[ ▁i ▁] ▁) ▁; ▁Min ▁[ ▁i ▁] ▁= ▁Mini ▁; ▁} ▁int ▁Max i ▁= ▁INT _ MIN ▁; ▁int ▁ind ▁= ▁-1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁Max i ▁= ▁max ▁( ▁Max i ▁, ▁a ▁[ ▁i ▁] ▁) ▁; ▁if ▁( ▁Max i ▁< ▁Min ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁{ ▁ind ▁= ▁i ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁ind ▁!= ▁-1 ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁ind ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁a ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁c out ▁<< ▁end l ▁; ▁for ▁( ▁int ▁i ▁= ▁ind ▁+ ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁a ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁} ▁else ▁c out ▁<< ▁" ▁Imp ossible ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁3 ▁, ▁2 ▁, ▁7 ▁, ▁9 ▁} ▁; ▁int ▁N ▁= ▁5 ▁; ▁partition Array ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁long ▁long ▁int ▁gcd ▁( ▁long ▁long ▁int ▁a ▁, ▁long ▁long ▁int ▁b ▁) ▁{ ▁while ▁( ▁b ▁> ▁0 ▁) ▁{ ▁long ▁long ▁int ▁rem ▁= ▁a ▁% ▁b ▁; ▁a ▁= ▁b ▁; ▁b ▁= ▁rem ▁; ▁} ▁return ▁a ▁; ▁} ▁int ▁count NumberOf W ays ▁( ▁long ▁long ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁1 ▁) ▁return ▁-1 ▁; ▁long ▁long ▁int ▁g ▁= ▁0 ▁; ▁int ▁power ▁= ▁0 ▁; ▁while ▁( ▁n ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁power ▁++ ▁; ▁n ▁/= ▁2 ▁; ▁} ▁g ▁= ▁gcd ▁( ▁g ▁, ▁power ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁3 ▁; ▁i ▁<= ▁sqrt ▁( ▁n ▁) ▁; ▁i ▁+= ▁2 ▁) ▁{ ▁power ▁= ▁0 ▁; ▁while ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁{ ▁power ▁++ ▁; ▁n ▁/= ▁i ▁; ▁} ▁g ▁= ▁gcd ▁( ▁g ▁, ▁power ▁) ▁; ▁} ▁if ▁( ▁n ▁> ▁2 ▁) ▁g ▁= ▁gcd ▁( ▁g ▁, ▁1 ▁) ▁; ▁int ▁ways ▁= ▁1 ▁; ▁power ▁= ▁0 ▁; ▁while ▁( ▁g ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁g ▁/= ▁2 ▁; ▁power ▁++ ▁; ▁} ▁ways ▁*= ▁( ▁power ▁+ ▁1 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁3 ▁; ▁i ▁<= ▁sqrt ▁( ▁g ▁) ▁; ▁i ▁+= ▁2 ▁) ▁{ ▁power ▁= ▁0 ▁; ▁while ▁( ▁g ▁% ▁i ▁== ▁0 ▁) ▁{ ▁power ▁++ ▁; ▁g ▁/= ▁i ▁; ▁} ▁ways ▁*= ▁( ▁power ▁+ ▁1 ▁) ▁; ▁} ▁if ▁( ▁g ▁> ▁2 ▁) ▁ways ▁*= ▁2 ▁; ▁return ▁ways ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁64 ▁; ▁c out ▁<< ▁count NumberOf W ays ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count ▁( ▁int ▁N ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁7 ▁* ▁pow ▁( ▁8 ▁, ▁i ▁- ▁1 ▁) ▁; ▁} ▁return ▁sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁4 ▁; ▁c out ▁<< ▁count ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁maxValue ▁( ▁int ▁n ▁) ▁{ ▁return ▁n ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁1 ▁; ▁c out ▁<< ▁maxValue ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁using Binary Search ▁( ▁int ▁start ▁, ▁int ▁end ▁, ▁int ▁N ▁, ▁int ▁S ▁) ▁{ ▁if ▁( ▁start ▁>= ▁end ▁) ▁return ▁start ▁; ▁int ▁mid ▁= ▁start ▁+ ▁( ▁end ▁- ▁start ▁) ▁/ ▁2 ▁; ▁int ▁total Sum ▁= ▁( ▁N ▁* ▁( ▁N ▁+ ▁1 ▁) ▁) ▁/ ▁2 ▁; ▁int ▁mid Sum ▁= ▁( ▁mid ▁* ▁( ▁mid ▁+ ▁1 ▁) ▁) ▁/ ▁2 ▁; ▁if ▁( ▁( ▁total Sum ▁- ▁mid Sum ▁) ▁<= ▁S ▁) ▁{ ▁return ▁using Binary Search ▁( ▁start ▁, ▁mid ▁, ▁N ▁, ▁S ▁) ▁; ▁} ▁return ▁using Binary Search ▁( ▁mid ▁+ ▁1 ▁, ▁end ▁, ▁N ▁, ▁S ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁, ▁S ▁; ▁N ▁= ▁5 ▁; ▁S ▁= ▁11 ▁; ▁c out ▁<< ▁( ▁N ▁- ▁using Binary Search ▁( ▁1 ▁, ▁N ▁, ▁N ▁, ▁S ▁) ▁+ ▁1 ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁equal _ xor _ sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁Sum ▁= ▁0 ▁; ▁int ▁X or ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁Sum ▁= ▁Sum ▁+ ▁arr ▁[ ▁i ▁] ▁; ▁X or ▁= ▁X or ▁^ ▁arr ▁[ ▁i ▁] ▁; ▁} ▁if ▁( ▁Sum ▁== ▁X or ▁) ▁c out ▁<< ▁" ▁YES ▁" ▁; ▁else ▁c out ▁<< ▁" ▁NO ▁" ▁; ▁return ▁0 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁6 ▁, ▁3 ▁, ▁7 ▁, ▁10 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁equal _ xor _ sum ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁set _ bits ▁( ▁int ▁n ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁while ▁( ▁n ▁) ▁{ ▁count ▁+= ▁n ▁% ▁2 ▁; ▁n ▁/= ▁2 ▁; ▁} ▁return ▁count ▁; ▁} ▁int ▁min Steps ▁( ▁int ▁n ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁while ▁( ▁n ▁!= ▁1 ▁) ▁{ ▁if ▁( ▁n ▁% ▁2 ▁== ▁0 ▁) ▁n ▁/= ▁2 ▁; ▁else ▁if ▁( ▁n ▁== ▁3 ▁or ▁set _ bits ▁( ▁n ▁- ▁1 ▁) ▁< ▁set _ bits ▁( ▁n ▁+ ▁1 ▁) ▁) ▁n ▁-- ▁; ▁else ▁n ▁++ ▁; ▁ans ▁++ ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁15 ▁; ▁c out ▁<< ▁min Steps ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁l cm ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁return ▁( ▁a ▁/ ▁__ g cd ▁( ▁a ▁, ▁b ▁) ▁* ▁b ▁) ▁; ▁} ▁void ▁find Num s ▁( ▁int ▁x ▁) ▁{ ▁int ▁ans ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁sqrt ▁( ▁x ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁x ▁% ▁i ▁== ▁0 ▁&& ▁l cm ▁( ▁i ▁, ▁x ▁/ ▁i ▁) ▁== ▁x ▁) ▁{ ▁ans ▁= ▁i ▁; ▁} ▁} ▁c out ▁<< ▁ans ▁<< ▁" ▁" ▁<< ▁( ▁x ▁/ ▁ans ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁x ▁= ▁12 ▁; ▁find Num s ▁( ▁x ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁min OR ▁( ▁int ▁* ▁arr ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁1 ▁) ▁return ▁0 ▁; ▁int ▁pre ▁[ ▁n ▁] ▁, ▁suf ▁[ ▁n ▁] ▁; ▁pre ▁[ ▁0 ▁] ▁= ▁arr ▁[ ▁0 ▁] ▁, ▁suf ▁[ ▁n ▁- ▁1 ▁] ▁= ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁pre ▁[ ▁i ▁] ▁= ▁( ▁pre ▁[ ▁i ▁- ▁1 ▁] ▁arr ▁[ ▁i ▁] ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁2 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁suf ▁[ ▁i ▁] ▁= ▁( ▁suf ▁[ ▁i ▁+ ▁1 ▁] ▁arr ▁[ ▁i ▁] ▁) ▁; ▁int ▁ans ▁= ▁min ▁( ▁pre ▁[ ▁n ▁- ▁2 ▁] ▁, ▁suf ▁[ ▁1 ▁] ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁ans ▁= ▁min ▁( ▁ans ▁, ▁( ▁pre ▁[ ▁i ▁- ▁1 ▁] ▁suf ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁) ▁; ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁c out ▁<< ▁min OR ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Cnt ▁( ▁int ▁* ▁arr ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁ret ▁= ▁0 ▁; ▁int ▁i ▁= ▁0 ▁; ▁while ▁( ▁i ▁< ▁n ▁) ▁{ ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁while ▁( ▁j ▁< ▁n ▁and ▁arr ▁[ ▁j ▁] ▁> ▁= ▁arr ▁[ ▁j ▁- ▁1 ▁] ▁) ▁j ▁++ ▁; ▁int ▁x ▁= ▁max ▁( ▁0 ▁, ▁j ▁- ▁i ▁- ▁k ▁+ ▁1 ▁) ▁; ▁ret ▁+= ▁( ▁x ▁* ▁( ▁x ▁+ ▁1 ▁) ▁) ▁/ ▁2 ▁; ▁i ▁= ▁j ▁; ▁} ▁return ▁ret ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁4 ▁, ▁3 ▁, ▁2 ▁, ▁1 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁int ▁k ▁= ▁2 ▁; ▁c out ▁<< ▁find Cnt ▁( ▁arr ▁, ▁n ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁two _ sets ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁sort ▁( ▁a ▁, ▁a ▁+ ▁n ▁) ▁; ▁return ▁a ▁[ ▁n ▁/ ▁2 ▁] ▁- ▁a ▁[ ▁( ▁n ▁/ ▁2 ▁) ▁- ▁1 ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁4 ▁, ▁4 ▁, ▁6 ▁, ▁7 ▁, ▁9 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁two _ sets ▁( ▁a ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁k th Num ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁a ▁= ▁( ▁n ▁+ ▁1 ▁) ▁/ ▁2 ▁; ▁if ▁( ▁k ▁> ▁a ▁) ▁return ▁( ▁2 ▁* ▁( ▁k ▁- ▁a ▁) ▁) ▁; ▁return ▁( ▁2 ▁* ▁k ▁- ▁1 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁7 ▁, ▁k ▁= ▁7 ▁; ▁c out ▁<< ▁k th Num ▁( ▁n ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count ▁( ▁int ▁n ▁) ▁{ ▁return ▁n ▁* ▁( ▁3 ▁* ▁n ▁- ▁1 ▁) ▁/ ▁2 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁3 ▁; ▁c out ▁<< ▁count ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Missing ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁, ▁int ▁avg ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁int ▁num ▁= ▁( ▁avg ▁* ▁( ▁n ▁+ ▁k ▁) ▁) ▁- ▁sum ▁; ▁int ▁den ▁= ▁k ▁; ▁if ▁( ▁num ▁% ▁den ▁!= ▁0 ▁) ▁return ▁-1 ▁; ▁return ▁( ▁num ▁/ ▁den ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁k ▁= ▁3 ▁, ▁avg ▁= ▁4 ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁7 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁c out ▁<< ▁find Missing ▁( ▁arr ▁, ▁n ▁, ▁k ▁, ▁avg ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁sum ▁= ▁sum ▁* ▁pow ▁( ▁2 ▁, ▁n ▁- ▁1 ▁) ▁; ▁return ▁sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁1 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁c out ▁<< ▁sum ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁prev Power of 2 ▁( ▁int ▁n ▁) ▁{ ▁int ▁p ▁= ▁( ▁int ▁) ▁log 2 ▁( ▁n ▁) ▁; ▁return ▁( ▁int ▁) ▁pow ▁( ▁2 ▁, ▁p ▁) ▁; ▁} ▁int ▁next Power Of 2 ▁( ▁int ▁n ▁) ▁{ ▁int ▁p ▁= ▁1 ▁; ▁if ▁( ▁n ▁&& ▁! ▁( ▁n ▁& ▁( ▁n ▁- ▁1 ▁) ▁) ▁) ▁return ▁n ▁; ▁while ▁( ▁p ▁< ▁n ▁) ▁p ▁<<= ▁1 ▁; ▁return ▁p ▁; ▁} ▁int ▁min Diff ▁( ▁int ▁n ▁) ▁{ ▁int ▁low ▁= ▁prev Power of 2 ▁( ▁n ▁) ▁; ▁int ▁high ▁= ▁next Power Of 2 ▁( ▁n ▁) ▁; ▁return ▁min ▁( ▁n ▁- ▁low ▁, ▁high ▁- ▁n ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁6 ▁; ▁c out ▁<< ▁min Diff ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁MAX ▁10 ▁NEW _ LINE ▁bool ▁is Factor ion ▁( ▁int ▁n ▁) ▁{ ▁int ▁fact ▁[ ▁MAX ▁] ▁; ▁fact ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁MAX ▁; ▁i ▁++ ▁) ▁fact ▁[ ▁i ▁] ▁= ▁i ▁* ▁fact ▁[ ▁i ▁- ▁1 ▁] ▁; ▁int ▁org ▁= ▁n ▁; ▁int ▁sum ▁= ▁0 ▁; ▁while ▁( ▁n ▁> ▁0 ▁) ▁{ ▁int ▁d ▁= ▁n ▁% ▁10 ▁; ▁sum ▁+= ▁fact ▁[ ▁d ▁] ▁; ▁n ▁/= ▁10 ▁; ▁} ▁if ▁( ▁sum ▁== ▁org ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁405 85 ▁; ▁if ▁( ▁is Factor ion ▁( ▁n ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁MOD ▁100 000000 7 ▁NEW _ LINE ▁int ▁mod Fact ▁( ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁int ▁result ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁m ▁; ▁i ▁++ ▁) ▁result ▁= ▁( ▁result ▁* ▁i ▁) ▁% ▁MOD ▁; ▁return ▁result ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁3 ▁, ▁m ▁= ▁2 ▁; ▁c out ▁<< ▁mod Fact ▁( ▁n ▁, ▁m ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max Common Fact ors ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁int ▁gcd ▁= ▁__ g cd ▁( ▁a ▁, ▁b ▁) ▁; ▁int ▁ans ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁* ▁i ▁<= ▁gcd ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁gcd ▁% ▁i ▁== ▁0 ▁) ▁{ ▁ans ▁++ ▁; ▁while ▁( ▁gcd ▁% ▁i ▁== ▁0 ▁) ▁gcd ▁/= ▁i ▁; ▁} ▁} ▁if ▁( ▁gcd ▁!= ▁1 ▁) ▁ans ▁++ ▁; ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁= ▁12 ▁, ▁b ▁= ▁18 ▁; ▁c out ▁<< ▁max Common Fact ors ▁( ▁a ▁, ▁b ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Unset Bits ▁( ▁int ▁n ▁) ▁{ ▁int ▁cnt ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁temp ▁= ▁i ▁; ▁while ▁( ▁temp ▁) ▁{ ▁if ▁( ▁temp ▁% ▁2 ▁== ▁0 ▁) ▁cnt ▁++ ▁; ▁temp ▁= ▁temp ▁/ ▁2 ▁; ▁} ▁} ▁return ▁cnt ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁5 ▁; ▁c out ▁<< ▁count Unset Bits ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is Div isible ▁( ▁long ▁long ▁int ▁n ▁) ▁{ ▁long ▁long ▁int ▁temp ▁= ▁n ▁; ▁int ▁sum ▁= ▁0 ▁; ▁while ▁( ▁n ▁) ▁{ ▁int ▁digit ▁= ▁n ▁% ▁10 ▁; ▁sum ▁+= ▁digit ▁; ▁n ▁/= ▁10 ▁; ▁} ▁n ▁= ▁temp ▁; ▁while ▁( ▁n ▁) ▁{ ▁int ▁digit ▁= ▁n ▁% ▁10 ▁; ▁if ▁( ▁sum ▁% ▁digit ▁!= ▁0 ▁) ▁return ▁false ▁; ▁n ▁/= ▁10 ▁; ▁} ▁return ▁true ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁long ▁long ▁int ▁n ▁= ▁123 ▁; ▁if ▁( ▁is Div isible ▁( ▁n ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁int ▁C OST ▁= ▁3 ▁; ▁int ▁max Items ▁( ▁int ▁x ▁, ▁int ▁y ▁, ▁int ▁z ▁) ▁{ ▁int ▁type 1 ▁= ▁x ▁/ ▁C OST ▁; ▁x ▁% = ▁C OST ▁; ▁int ▁type 2 ▁= ▁y ▁/ ▁C OST ▁; ▁y ▁% = ▁C OST ▁; ▁int ▁type 3 ▁= ▁z ▁/ ▁C OST ▁; ▁z ▁% = ▁C OST ▁; ▁int ▁type 4 ▁= ▁min ▁( ▁x ▁, ▁min ▁( ▁y ▁, ▁z ▁) ▁) ▁; ▁int ▁max Items ▁= ▁type 1 ▁+ ▁type 2 ▁+ ▁type 3 ▁+ ▁type 4 ▁; ▁return ▁max Items ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁x ▁= ▁4 ▁, ▁y ▁= ▁5 ▁, ▁z ▁= ▁6 ▁; ▁c out ▁<< ▁max Items ▁( ▁x ▁, ▁y ▁, ▁z ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁pair ▁< ▁int ▁, ▁int ▁> ▁count Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁Number Of Odd s ▁= ▁0 ▁, ▁Number Of Ev ens ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁arr ▁[ ▁i ▁] ▁& ▁1 ▁) ▁Number Of Odd s ▁++ ▁; ▁Number Of Ev ens ▁= ▁n ▁- ▁Number Of Odd s ▁; ▁int ▁Number Of Odd Sub sequences ▁= ▁( ▁1 ▁<< ▁Number Of Ev ens ▁) ▁* ▁( ▁1 ▁<< ▁( ▁Number Of Odd s ▁- ▁1 ▁) ▁) ▁; ▁int ▁Number Of Even Sub sequences ▁= ▁( ▁1 ▁<< ▁n ▁) ▁- ▁1 ▁- ▁Number Of Odd Sub sequences ▁; ▁return ▁{ ▁Number Of Even Sub sequences ▁, ▁Number Of Odd Sub sequences ▁} ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁2 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁pair ▁< ▁int ▁, ▁int ▁> ▁ans ▁= ▁count Sum ▁( ▁arr ▁, ▁n ▁) ▁; ▁c out ▁<< ▁" ▁Even Sum ▁= ▁" ▁<< ▁ans ▁. ▁first ▁; ▁c out ▁<< ▁" ▁O dd Sum ▁= ▁" ▁<< ▁ans ▁. ▁second ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁prime ▁( ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁* ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁return ▁false ▁; ▁return ▁true ▁; ▁} ▁void ▁prime _ range ▁( ▁int ▁start ▁, ▁int ▁end ▁, ▁int ▁* ▁a ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁start ▁; ▁i ▁< ▁end ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁( ▁a ▁[ ▁i ▁] ▁) ▁) ▁c out ▁<< ▁a ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁} ▁} ▁void ▁Print ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁c out ▁<< ▁" ▁Prime ▁numbers ▁in ▁the ▁first ▁half ▁are ▁" ▁; ▁prime _ range ▁( ▁0 ▁, ▁n ▁/ ▁2 ▁, ▁arr ▁) ▁; ▁c out ▁<< ▁end l ▁; ▁c out ▁<< ▁" ▁Prime ▁numbers ▁in ▁the ▁second ▁half ▁are ▁" ▁; ▁prime _ range ▁( ▁n ▁/ ▁2 ▁, ▁n ▁, ▁arr ▁) ▁; ▁c out ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁5 ▁, ▁10 ▁, ▁15 ▁, ▁17 ▁, ▁21 ▁, ▁23 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁Print ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁Find Element ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁sum ▁= ▁sum ▁+ ▁a ▁[ ▁i ▁] ▁; ▁if ▁( ▁sum ▁% ▁n ▁== ▁0 ▁) ▁{ ▁int ▁m ▁= ▁sum ▁/ ▁n ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁a ▁[ ▁i ▁] ▁== ▁m ▁) ▁return ▁m ▁; ▁} ▁return ▁-1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁c out ▁<< ▁Find Element ▁( ▁a ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁fact ▁( ▁int ▁n ▁) ▁{ ▁int ▁res ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁res ▁= ▁res ▁* ▁i ▁; ▁return ▁res ▁; ▁} ▁int ▁Count _ number ▁( ▁int ▁N ▁) ▁{ ▁return ▁( ▁N ▁* ▁fact ▁( ▁N ▁) ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁2 ▁; ▁c out ▁<< ▁Count _ number ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Hours ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁int ▁k ▁) ▁{ ▁if ▁( ▁a ▁>= ▁b ▁) ▁return ▁-1 ▁; ▁int ▁time ▁= ▁k ▁/ ▁( ▁b ▁- ▁a ▁) ▁; ▁time ▁= ▁time ▁+ ▁1 ▁; ▁return ▁time ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁= ▁4 ▁, ▁b ▁= ▁5 ▁, ▁k ▁= ▁1 ▁; ▁c out ▁<< ▁find Hours ▁( ▁a ▁, ▁b ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁n cr ▁( ▁int ▁n ▁, ▁int ▁r ▁) ▁{ ▁int ▁ans ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁r ▁; ▁i ▁+= ▁1 ▁) ▁{ ▁ans ▁*= ▁( ▁n ▁- ▁r ▁+ ▁i ▁) ▁; ▁ans ▁/= ▁i ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁No Of Distribution s ▁( ▁int ▁N ▁, ▁int ▁R ▁) ▁{ ▁return ▁n cr ▁( ▁N ▁- ▁1 ▁, ▁R ▁- ▁1 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁4 ▁; ▁int ▁R ▁= ▁3 ▁; ▁c out ▁<< ▁No Of Distribution s ▁( ▁N ▁, ▁R ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁Min Remove ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁vector ▁< ▁int ▁> ▁cnt ▁( ▁k ▁, ▁0 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁== ▁0 ▁) ▁cnt ▁[ ▁0 ▁] ▁++ ▁; ▁else ▁if ▁( ▁cnt ▁[ ▁a ▁[ ▁i ▁] ▁- ▁1 ▁] ▁> ▁0 ▁) ▁{ ▁cnt ▁[ ▁a ▁[ ▁i ▁] ▁- ▁1 ▁] ▁-- ▁; ▁cnt ▁[ ▁a ▁[ ▁i ▁] ▁] ▁++ ▁; ▁} ▁} ▁return ▁n ▁- ▁( ▁k ▁* ▁cnt ▁[ ▁k ▁- ▁1 ▁] ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁, ▁k ▁= ▁5 ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁Min Remove ▁( ▁a ▁, ▁n ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁L ower H ess en berg Matrix ▁( ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁<= ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁j ▁> ▁i ▁+ ▁1 ▁) ▁c out ▁<< ▁'0' ▁<< ▁" ▁" ▁; ▁else ▁c out ▁<< ▁rand ▁( ▁) ▁% ▁10 ▁<< ▁" ▁" ▁; ▁} ▁c out ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁4 ▁; ▁L ower H ess en berg Matrix ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count ▁( ▁int ▁N ▁) ▁{ ▁int ▁a ▁= ▁0 ▁; ▁a ▁= ▁( ▁N ▁* ▁( ▁N ▁+ ▁1 ▁) ▁) ▁/ ▁2 ▁; ▁return ▁a ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁4 ▁; ▁c out ▁<< ▁count ▁( ▁N ▁) ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁isM ers en ne ▁( ▁int ▁n ▁) ▁{ ▁while ▁( ▁n ▁!= ▁0 ▁) ▁{ ▁int ▁r ▁= ▁n ▁% ▁2 ▁; ▁if ▁( ▁r ▁== ▁0 ▁) ▁return ▁false ▁; ▁n ▁/= ▁2 ▁; ▁} ▁return ▁true ▁; ▁} ▁int ▁sum Of M ers en ne ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁0 ▁&& ▁isM ers en ne ▁( ▁arr ▁[ ▁i ▁] ▁) ▁) ▁{ ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁} ▁return ▁sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁17 ▁, ▁6 ▁, ▁7 ▁, ▁63 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁c out ▁<< ▁( ▁sum Of M ers en ne ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁numberOf Days ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁int ▁n ▁) ▁{ ▁int ▁Days ▁= ▁b ▁* ▁( ▁n ▁+ ▁a ▁) ▁/ ▁( ▁a ▁+ ▁b ▁) ▁; ▁return ▁Days ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁= ▁10 ▁, ▁b ▁= ▁20 ▁, ▁n ▁= ▁5 ▁; ▁c out ▁<< ▁numberOf Days ▁( ▁a ▁, ▁b ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< algorithm > ▁NEW _ LINE ▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁long ▁square Series ▁( ▁long ▁n ▁) ▁{ ▁return ▁( ▁n ▁* ▁( ▁n ▁+ ▁1 ▁) ▁* ▁( ▁2 ▁* ▁n ▁+ ▁1 ▁) ▁) ▁/ ▁6 ▁; ▁} ▁long ▁max People ▁( ▁long ▁n ▁) ▁{ ▁long ▁low ▁= ▁0 ▁; ▁long ▁high ▁= ▁1000000 L ▁; ▁long ▁ans ▁= ▁0 L ▁; ▁while ▁( ▁low ▁<= ▁high ▁) ▁{ ▁long ▁mid ▁= ▁low ▁+ ▁( ▁( ▁high ▁- ▁low ▁) ▁/ ▁2 ▁) ▁; ▁long ▁value ▁= ▁square Series ▁( ▁mid ▁) ▁; ▁if ▁( ▁value ▁<= ▁n ▁) ▁{ ▁ans ▁= ▁mid ▁; ▁low ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁else ▁{ ▁high ▁= ▁mid ▁- ▁1 ▁; ▁} ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁long ▁p ▁= ▁14 ▁; ▁c out ▁<< ▁max People ▁( ▁p ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁solve ▁( ▁long ▁long ▁int ▁a ▁, ▁long ▁long ▁int ▁b ▁) ▁{ ▁if ▁( ▁a ▁> ▁0 ▁&& ▁b ▁> ▁0 ▁) ▁{ ▁c out ▁<< ▁" ▁Positive ▁" ▁; ▁} ▁else ▁if ▁( ▁a ▁<= ▁0 ▁&& ▁b ▁>= ▁0 ▁) ▁{ ▁c out ▁<< ▁" ▁Zero ▁" ▁<< ▁end l ▁; ▁} ▁else ▁{ ▁long ▁long ▁int ▁n ▁= ▁abs ▁( ▁a ▁- ▁b ▁) ▁+ ▁1 ▁; ▁if ▁( ▁n ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁c out ▁<< ▁" ▁Positive ▁" ▁<< ▁end l ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁" ▁Negative ▁" ▁<< ▁end l ▁; ▁} ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁= ▁-10 ▁, ▁b ▁= ▁-2 ▁; ▁solve ▁( ▁a ▁, ▁b ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁factorial ▁( ▁int ▁n ▁) ▁{ ▁int ▁f ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁f ▁*= ▁i ▁; ▁} ▁return ▁f ▁; ▁} ▁int ▁sum Factor ial ▁( ▁int ▁* ▁arr ▁, ▁int ▁n ▁) ▁{ ▁int ▁s ▁= ▁0 ▁, ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁s ▁+= ▁factorial ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁return ▁s ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁7 ▁, ▁3 ▁, ▁5 ▁, ▁4 ▁, ▁8 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁sum Factor ial ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁id str t ▁( ▁double ▁a 1 ▁, ▁double ▁b 1 ▁, ▁double ▁c 1 ▁, ▁double ▁a 2 ▁, ▁double ▁b 2 ▁, ▁double ▁c 2 ▁) ▁{ ▁if ▁( ▁( ▁a 1 ▁/ ▁a 2 ▁== ▁b 1 ▁/ ▁b 2 ▁) ▁&& ▁( ▁a 1 ▁/ ▁a 2 ▁== ▁c 1 ▁/ ▁c 2 ▁) ▁&& ▁( ▁b 1 ▁/ ▁b 2 ▁== ▁c 1 ▁/ ▁c 2 ▁) ▁) ▁c out ▁<< ▁" ▁The ▁given ▁straight ▁" ▁<< ▁" ▁lines ▁are ▁identical ▁" ▁<< ▁end l ▁; ▁else ▁c out ▁<< ▁" ▁The ▁given ▁straight ▁" ▁<< ▁" ▁lines ▁are ▁not ▁identical ▁" ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁double ▁a 1 ▁= ▁-2 ▁, ▁b 1 ▁= ▁4 ▁, ▁c 1 ▁= ▁3 ▁, ▁a 2 ▁= ▁- 6 ▁, ▁b 2 ▁= ▁12 ▁, ▁c 2 ▁= ▁9 ▁; ▁id str t ▁( ▁a 1 ▁, ▁b 1 ▁, ▁c 1 ▁, ▁a 2 ▁, ▁b 2 ▁, ▁c 2 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁smallest Multiple ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁1 ▁) ▁return ▁5 ▁; ▁return ▁pow ▁( ▁10 ▁, ▁n ▁- ▁1 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁4 ▁; ▁c out ▁<< ▁smallest Multiple ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁maxlen ▁100 ▁NEW _ LINE ▁void ▁generate Sub Strings ▁( ▁string ▁s ▁, ▁unordered _ map ▁< ▁string ▁, ▁int ▁> ▁& ▁m pp ▁) ▁{ ▁int ▁l ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁l ▁; ▁i ▁++ ▁) ▁{ ▁string ▁temp ▁= ▁" ▁" ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁< ▁l ▁; ▁j ▁++ ▁) ▁{ ▁temp ▁+= ▁s ▁[ ▁j ▁] ▁; ▁m pp ▁[ ▁temp ▁] ▁+= ▁1 ▁; ▁} ▁} ▁} ▁void ▁bin omial Co eff ▁( ▁int ▁C ▁[ ▁maxlen ▁] ▁[ ▁maxlen ▁] ▁) ▁{ ▁int ▁i ▁, ▁j ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁100 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁100 ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁j ▁== ▁0 ▁j ▁== ▁i ▁) ▁C ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁1 ▁; ▁else ▁C ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁C ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁- ▁1 ▁] ▁+ ▁C ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁; ▁} ▁} ▁} ▁int ▁answer Query ▁( ▁unordered _ map ▁< ▁string ▁, ▁int ▁> ▁& ▁m pp ▁, ▁int ▁C ▁[ ▁maxlen ▁] ▁[ ▁maxlen ▁] ▁, ▁int ▁k ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁auto ▁it ▁: ▁m pp ▁) ▁{ ▁if ▁( ▁it ▁. ▁second ▁>= ▁k ▁) ▁ans ▁+= ▁C ▁[ ▁it ▁. ▁second ▁] ▁[ ▁k ▁] ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁" ▁a aba ab ▁" ▁; ▁unordered _ map ▁< ▁string ▁, ▁int ▁> ▁m pp ▁; ▁generate Sub Strings ▁( ▁s ▁, ▁m pp ▁) ▁; ▁int ▁C ▁[ ▁maxlen ▁] ▁[ ▁maxlen ▁] ▁; ▁mem set ▁( ▁C ▁, ▁0 ▁, ▁sizeof ▁C ▁) ▁; ▁bin omial Co eff ▁( ▁C ▁) ▁; ▁int ▁queries ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁q ▁= ▁sizeof ▁( ▁queries ▁) ▁/ ▁sizeof ▁( ▁queries ▁[ ▁0 ▁] ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁q ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁answer Query ▁( ▁m pp ▁, ▁C ▁, ▁queries ▁[ ▁i ▁] ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁long ▁compute X OR ▁( ▁const ▁int ▁n ▁) ▁{ ▁switch ▁( ▁n ▁& ▁3 ▁) ▁{ ▁case ▁0 ▁: ▁return ▁n ▁; ▁case ▁1 ▁: ▁return ▁1 ▁; ▁case ▁2 ▁: ▁return ▁n ▁+ ▁1 ▁; ▁case ▁3 ▁: ▁return ▁0 ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁l ▁= ▁1 ▁, ▁r ▁= ▁4 ▁; ▁c out ▁<< ▁( ▁compute X OR ▁( ▁r ▁) ▁^ ▁compute X OR ▁( ▁l ▁- ▁1 ▁) ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁ll ▁long ▁long ▁int ▁NEW _ LINE ▁int ▁fib ▁( ▁int ▁n ▁) ▁{ ▁double ▁phi ▁= ▁( ▁1 ▁+ ▁sqrt ▁( ▁5 ▁) ▁) ▁/ ▁2 ▁; ▁return ▁round ▁( ▁pow ▁( ▁phi ▁, ▁n ▁) ▁/ ▁sqrt ▁( ▁5 ▁) ▁) ▁; ▁} ▁ll ▁calculate Sum ▁( ▁int ▁l ▁, ▁int ▁r ▁) ▁{ ▁ll ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁l ▁; ▁i ▁<= ▁r ▁; ▁i ▁++ ▁) ▁sum ▁+= ▁fib ▁( ▁i ▁) ▁; ▁return ▁sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁l ▁= ▁4 ▁, ▁r ▁= ▁8 ▁; ▁c out ▁<< ▁calculate Sum ▁( ▁l ▁, ▁r ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Numbers ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁% ▁2 ▁== ▁1 ▁) ▁return ▁0 ▁; ▁return ▁( ▁9 ▁* ▁pow ▁( ▁10 ▁, ▁n ▁/ ▁2 ▁- ▁1 ▁) ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁2 ▁; ▁c out ▁<< ▁count Numbers ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁double ▁get Probability ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁int ▁c ▁, ▁int ▁d ▁) ▁{ ▁double ▁p ▁= ▁( ▁double ▁) ▁a ▁/ ▁( ▁double ▁) ▁b ▁; ▁double ▁q ▁= ▁( ▁double ▁) ▁c ▁/ ▁( ▁double ▁) ▁d ▁; ▁double ▁ans ▁= ▁p ▁* ▁( ▁1 ▁/ ▁( ▁1 ▁- ▁( ▁1 ▁- ▁q ▁) ▁* ▁( ▁1 ▁- ▁p ▁) ▁) ▁) ▁; ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁= ▁1 ▁, ▁b ▁= ▁2 ▁, ▁c ▁= ▁10 ▁, ▁d ▁= ▁11 ▁; ▁c out ▁<< ▁get Probability ▁( ▁a ▁, ▁b ▁, ▁c ▁, ▁d ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Min Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁occ ▁= ▁n ▁- ▁1 ▁, ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁arr ▁[ ▁i ▁] ▁* ▁pow ▁( ▁2 ▁, ▁occ ▁) ▁; ▁occ ▁-- ▁; ▁} ▁return ▁sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁find Min Sum ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁# define ▁n ▁3 ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁matrix Sum ▁( ▁int ▁arr ▁[ ▁] ▁[ ▁n ▁] ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁int ▁top _ left ▁= ▁( ▁i ▁+ ▁1 ▁) ▁* ▁( ▁j ▁+ ▁1 ▁) ▁; ▁int ▁bottom _ right ▁= ▁( ▁n ▁- ▁i ▁) ▁* ▁( ▁n ▁- ▁j ▁) ▁; ▁sum ▁+= ▁( ▁top _ left ▁* ▁bottom _ right ▁* ▁arr ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁; ▁} ▁return ▁sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁[ ▁n ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁1 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁1 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁1 ▁, ▁1 ▁} ▁} ▁; ▁c out ▁<< ▁matrix Sum ▁( ▁arr ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁N ▁10000 5 ▁NEW _ LINE ▁bool ▁is prime ▁[ ▁N ▁] ▁; ▁bool ▁can ▁[ ▁N ▁] ▁; ▁vector ▁< ▁int ▁> ▁S ieve Of E rat ost hen es ▁( ▁) ▁{ ▁mem set ▁( ▁is prime ▁, ▁true ▁, ▁sizeof ▁( ▁is prime ▁) ▁) ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁* ▁p ▁< ▁N ▁; ▁p ▁++ ▁) ▁{ ▁if ▁( ▁is prime ▁[ ▁p ▁] ▁== ▁true ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁p ▁* ▁p ▁; ▁i ▁< ▁N ▁; ▁i ▁+= ▁p ▁) ▁is prime ▁[ ▁i ▁] ▁= ▁false ▁; ▁} ▁} ▁vector ▁< ▁int ▁> ▁primes ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁if ▁( ▁is prime ▁[ ▁i ▁] ▁) ▁primes ▁. ▁push _ back ▁( ▁i ▁) ▁; ▁return ▁primes ▁; ▁} ▁int ▁Prime _ Numbers ▁( ▁int ▁n ▁) ▁{ ▁vector ▁< ▁int ▁> ▁primes ▁= ▁S ieve Of E rat ost hen es ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁( ▁int ▁) ▁( ▁primes ▁. ▁size ▁( ▁) ▁) ▁- ▁1 ▁; ▁i ▁++ ▁) ▁if ▁( ▁primes ▁[ ▁i ▁] ▁+ ▁primes ▁[ ▁i ▁+ ▁1 ▁] ▁+ ▁1 ▁< ▁N ▁) ▁can ▁[ ▁primes ▁[ ▁i ▁] ▁+ ▁primes ▁[ ▁i ▁+ ▁1 ▁] ▁+ ▁1 ▁] ▁= ▁true ▁; ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁can ▁[ ▁i ▁] ▁and ▁is prime ▁[ ▁i ▁] ▁) ▁{ ▁ans ▁++ ▁; ▁} ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁50 ▁; ▁c out ▁<< ▁Prime _ Numbers ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁mid pt el lipse ▁( ▁int ▁rx ▁, ▁int ▁ry ▁, ▁int ▁xc ▁, ▁int ▁y c ▁) ▁{ ▁float ▁dx ▁, ▁dy ▁, ▁d 1 ▁, ▁d 2 ▁, ▁x ▁, ▁y ▁; ▁x ▁= ▁0 ▁; ▁y ▁= ▁ry ▁; ▁d 1 ▁= ▁( ▁ry ▁* ▁ry ▁) ▁- ▁( ▁rx ▁* ▁rx ▁* ▁ry ▁) ▁+ ▁( ▁0.25 ▁* ▁rx ▁* ▁rx ▁) ▁; ▁dx ▁= ▁2 ▁* ▁ry ▁* ▁ry ▁* ▁x ▁; ▁dy ▁= ▁2 ▁* ▁rx ▁* ▁rx ▁* ▁y ▁; ▁while ▁( ▁dx ▁< ▁dy ▁) ▁{ ▁c out ▁<< ▁x ▁+ ▁xc ▁<< ▁" ▁, ▁" ▁<< ▁y ▁+ ▁y c ▁<< ▁end l ▁; ▁c out ▁<< ▁- ▁x ▁+ ▁xc ▁<< ▁" ▁, ▁" ▁<< ▁y ▁+ ▁y c ▁<< ▁end l ▁; ▁c out ▁<< ▁x ▁+ ▁xc ▁<< ▁" ▁, ▁" ▁<< ▁- ▁y ▁+ ▁y c ▁<< ▁end l ▁; ▁c out ▁<< ▁- ▁x ▁+ ▁xc ▁<< ▁" ▁, ▁" ▁<< ▁- ▁y ▁+ ▁y c ▁<< ▁end l ▁; ▁if ▁( ▁d 1 ▁< ▁0 ▁) ▁{ ▁x ▁++ ▁; ▁dx ▁= ▁dx ▁+ ▁( ▁2 ▁* ▁ry ▁* ▁ry ▁) ▁; ▁d 1 ▁= ▁d 1 ▁+ ▁dx ▁+ ▁( ▁ry ▁* ▁ry ▁) ▁; ▁} ▁else ▁{ ▁x ▁++ ▁; ▁y ▁-- ▁; ▁dx ▁= ▁dx ▁+ ▁( ▁2 ▁* ▁ry ▁* ▁ry ▁) ▁; ▁dy ▁= ▁dy ▁- ▁( ▁2 ▁* ▁rx ▁* ▁rx ▁) ▁; ▁d 1 ▁= ▁d 1 ▁+ ▁dx ▁- ▁dy ▁+ ▁( ▁ry ▁* ▁ry ▁) ▁; ▁} ▁} ▁d 2 ▁= ▁( ▁( ▁ry ▁* ▁ry ▁) ▁* ▁( ▁( ▁x ▁+ ▁0.5 ▁) ▁* ▁( ▁x ▁+ ▁0.5 ▁) ▁) ▁) ▁+ ▁( ▁( ▁rx ▁* ▁rx ▁) ▁* ▁( ▁( ▁y ▁- ▁1 ▁) ▁* ▁( ▁y ▁- ▁1 ▁) ▁) ▁) ▁- ▁( ▁rx ▁* ▁rx ▁* ▁ry ▁* ▁ry ▁) ▁; ▁while ▁( ▁y ▁>= ▁0 ▁) ▁{ ▁c out ▁<< ▁x ▁+ ▁xc ▁<< ▁" ▁, ▁" ▁<< ▁y ▁+ ▁y c ▁<< ▁end l ▁; ▁c out ▁<< ▁- ▁x ▁+ ▁xc ▁<< ▁" ▁, ▁" ▁<< ▁y ▁+ ▁y c ▁<< ▁end l ▁; ▁c out ▁<< ▁x ▁+ ▁xc ▁<< ▁" ▁, ▁" ▁<< ▁- ▁y ▁+ ▁y c ▁<< ▁end l ▁; ▁c out ▁<< ▁- ▁x ▁+ ▁xc ▁<< ▁" ▁, ▁" ▁<< ▁- ▁y ▁+ ▁y c ▁<< ▁end l ▁; ▁if ▁( ▁d 2 ▁> ▁0 ▁) ▁{ ▁y ▁-- ▁; ▁dy ▁= ▁dy ▁- ▁( ▁2 ▁* ▁rx ▁* ▁rx ▁) ▁; ▁d 2 ▁= ▁d 2 ▁+ ▁( ▁rx ▁* ▁rx ▁) ▁- ▁dy ▁; ▁} ▁else ▁{ ▁y ▁-- ▁; ▁x ▁++ ▁; ▁dx ▁= ▁dx ▁+ ▁( ▁2 ▁* ▁ry ▁* ▁ry ▁) ▁; ▁dy ▁= ▁dy ▁- ▁( ▁2 ▁* ▁rx ▁* ▁rx ▁) ▁; ▁d 2 ▁= ▁d 2 ▁+ ▁dx ▁- ▁dy ▁+ ▁( ▁rx ▁* ▁rx ▁) ▁; ▁} ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁mid pt el lipse ▁( ▁10 ▁, ▁15 ▁, ▁50 ▁, ▁50 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁alter ▁( ▁long ▁long ▁int ▁x ▁, ▁long ▁long ▁int ▁y ▁) ▁{ ▁while ▁( ▁true ▁) ▁{ ▁if ▁( ▁x ▁== ▁0 ▁y ▁== ▁0 ▁) ▁break ▁; ▁if ▁( ▁x ▁>= ▁2 ▁* ▁y ▁) ▁x ▁= ▁x ▁% ▁( ▁2 ▁* ▁y ▁) ▁; ▁else ▁if ▁( ▁y ▁>= ▁2 ▁* ▁x ▁) ▁y ▁= ▁y ▁% ▁( ▁2 ▁* ▁x ▁) ▁; ▁else ▁break ▁; ▁} ▁c out ▁<< ▁" ▁X ▁= ▁" ▁<< ▁x ▁<< ▁" ▁, ▁" ▁<< ▁" ▁Y ▁= ▁" ▁<< ▁y ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁long ▁long ▁int ▁x ▁= ▁12 ▁, ▁y ▁= ▁5 ▁; ▁alter ▁( ▁x ▁, ▁y ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁factorial ▁( ▁int ▁n ▁) ▁{ ▁int ▁fact ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁fact ▁= ▁fact ▁* ▁i ▁; ▁return ▁fact ▁; ▁} ▁int ▁n cr ▁( ▁int ▁n ▁, ▁int ▁r ▁) ▁{ ▁return ▁factorial ▁( ▁n ▁) ▁/ ▁( ▁factorial ▁( ▁r ▁) ▁* ▁factorial ▁( ▁n ▁- ▁r ▁) ▁) ▁; ▁} ▁int ▁count W ays ▁( ▁string ▁str ▁) ▁{ ▁int ▁freq ▁[ ▁26 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁int ▁nv ow els ▁= ▁0 ▁, ▁n con son ants ▁= ▁0 ▁; ▁int ▁v places ▁, ▁c ways ▁, ▁v ways ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁str ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁++ ▁freq ▁[ ▁str ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁26 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁== ▁0 ▁i ▁== ▁4 ▁i ▁== ▁8 ▁i ▁== ▁14 ▁i ▁== ▁20 ▁) ▁nv ow els ▁+= ▁freq ▁[ ▁i ▁] ▁; ▁else ▁n con son ants ▁+= ▁freq ▁[ ▁i ▁] ▁; ▁} ▁v places ▁= ▁n con son ants ▁+ ▁1 ▁; ▁c ways ▁= ▁factorial ▁( ▁n con son ants ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁26 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁!= ▁0 ▁&& ▁i ▁!= ▁4 ▁&& ▁i ▁!= ▁8 ▁&& ▁i ▁!= ▁14 ▁&& ▁i ▁!= ▁20 ▁&& ▁freq ▁[ ▁i ▁] ▁> ▁1 ▁) ▁{ ▁c ways ▁= ▁c ways ▁/ ▁factorial ▁( ▁freq ▁[ ▁i ▁] ▁) ▁; ▁} ▁} ▁v ways ▁= ▁n cr ▁( ▁v places ▁, ▁nv ow els ▁) ▁* ▁factorial ▁( ▁nv ow els ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁26 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁== ▁0 ▁i ▁== ▁4 ▁i ▁== ▁8 ▁i ▁== ▁14 ▁i ▁== ▁20 ▁&& ▁freq ▁[ ▁i ▁] ▁> ▁1 ▁) ▁{ ▁v ways ▁= ▁v ways ▁/ ▁factorial ▁( ▁freq ▁[ ▁i ▁] ▁) ▁; ▁} ▁} ▁return ▁c ways ▁* ▁v ways ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁permutation ▁" ▁; ▁c out ▁<< ▁count W ays ▁( ▁str ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁S ieve Of E rat ost hen es ▁( ▁bool ▁prime ▁[ ▁] ▁, ▁int ▁p _ size ▁) ▁{ ▁prime ▁[ ▁0 ▁] ▁= ▁false ▁; ▁prime ▁[ ▁1 ▁] ▁= ▁false ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁* ▁p ▁<= ▁p _ size ▁; ▁p ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁p ▁] ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁p ▁* ▁2 ▁; ▁i ▁<= ▁p _ size ▁; ▁i ▁+= ▁p ▁) ▁prime ▁[ ▁i ▁] ▁= ▁false ▁; ▁} ▁} ▁} ▁int ▁sum Of Elements ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁bool ▁prime ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁mem set ▁( ▁prime ▁, ▁true ▁, ▁sizeof ▁( ▁prime ▁) ▁) ▁; ▁S ieve Of E rat ost hen es ▁( ▁prime ▁, ▁n ▁+ ▁1 ▁) ▁; ▁int ▁i ▁, ▁j ▁; ▁unordered _ map ▁< ▁int ▁, ▁int ▁> ▁m ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁m ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁++ ▁; ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁auto ▁it ▁= ▁m ▁. ▁begin ▁( ▁) ▁; ▁it ▁!= ▁m ▁. ▁end ▁( ▁) ▁; ▁it ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁it ▁-> ▁second ▁] ▁) ▁{ ▁sum ▁+= ▁( ▁it ▁-> ▁first ▁) ▁; ▁} ▁} ▁return ▁sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁4 ▁, ▁6 ▁, ▁5 ▁, ▁4 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁sum Of Elements ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁total Pairs ▁( ▁int ▁arr 1 ▁[ ▁] ▁, ▁int ▁arr 2 ▁[ ▁] ▁, ▁int ▁K ▁, ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁set ▁< ▁pair ▁< ▁int ▁, ▁int ▁> ▁> ▁s ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁m ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁arr 1 ▁[ ▁i ▁] ▁> ▁arr 2 ▁[ ▁j ▁] ▁) ▁{ ▁if ▁( ▁arr 1 ▁[ ▁i ▁] ▁% ▁arr 2 ▁[ ▁j ▁] ▁== ▁K ▁) ▁s ▁. ▁insert ▁( ▁make _ pair ▁( ▁arr 1 ▁[ ▁i ▁] ▁, ▁arr 2 ▁[ ▁j ▁] ▁) ▁) ▁; ▁} ▁else ▁{ ▁if ▁( ▁arr 2 ▁[ ▁j ▁] ▁% ▁arr 1 ▁[ ▁i ▁] ▁== ▁K ▁) ▁s ▁. ▁insert ▁( ▁make _ pair ▁( ▁arr 2 ▁[ ▁j ▁] ▁, ▁arr 1 ▁[ ▁i ▁] ▁) ▁) ▁; ▁} ▁} ▁} ▁return ▁s ▁. ▁size ▁( ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr 1 ▁[ ▁] ▁= ▁{ ▁8 ▁, ▁3 ▁, ▁7 ▁, ▁50 ▁} ▁; ▁int ▁arr 2 ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁1 ▁, ▁10 ▁, ▁4 ▁} ▁; ▁int ▁K ▁= ▁3 ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr 1 ▁) ▁/ ▁sizeof ▁( ▁arr 1 ▁[ ▁0 ▁] ▁) ▁; ▁int ▁m ▁= ▁sizeof ▁( ▁arr 2 ▁) ▁/ ▁sizeof ▁( ▁arr 2 ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁total Pairs ▁( ▁arr 1 ▁, ▁arr 2 ▁, ▁K ▁, ▁n ▁, ▁m ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁ll ▁long ▁long ▁int ▁NEW _ LINE ▁vector ▁< ▁ll ▁> ▁find Prime ▁( ▁int ▁MAX ▁) ▁{ ▁bool ▁pm ▁[ ▁MAX ▁+ ▁1 ▁] ▁; ▁mem set ▁( ▁pm ▁, ▁true ▁, ▁sizeof ▁( ▁pm ▁) ▁) ▁; ▁pm ▁[ ▁0 ▁] ▁= ▁pm ▁[ ▁1 ▁] ▁= ▁false ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁MAX ▁; ▁i ▁++ ▁) ▁if ▁( ▁pm ▁[ ▁i ▁] ▁) ▁for ▁( ▁int ▁j ▁= ▁2 ▁* ▁i ▁; ▁j ▁<= ▁MAX ▁; ▁j ▁+= ▁i ▁) ▁pm ▁[ ▁j ▁] ▁= ▁false ▁; ▁vector ▁< ▁ll ▁> ▁prime ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁MAX ▁; ▁i ▁++ ▁) ▁if ▁( ▁pm ▁[ ▁i ▁] ▁) ▁prime ▁. ▁push _ back ▁( ▁i ▁) ▁; ▁return ▁prime ▁; ▁} ▁int ▁find Small est ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁MAX ▁= ▁* ▁max _ element ▁( ▁arr ▁, ▁arr ▁+ ▁n ▁) ▁; ▁vector ▁< ▁ll ▁> ▁prime ▁= ▁find Prime ▁( ▁MAX ▁) ▁; ▁unordered _ set ▁< ▁int ▁> ▁s ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁s ▁. ▁insert ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁int ▁ans ▁= ▁-1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁prime ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁if ▁( ▁s ▁. ▁find ▁( ▁prime ▁[ ▁i ▁] ▁) ▁== ▁s ▁. ▁end ▁( ▁) ▁) ▁{ ▁ans ▁= ▁prime ▁[ ▁i ▁] ▁; ▁break ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁0 ▁, ▁1 ▁, ▁2 ▁, ▁7 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁if ▁( ▁find Small est ▁( ▁arr ▁, ▁n ▁) ▁== ▁-1 ▁) ▁c out ▁<< ▁" ▁No ▁prime ▁number ▁missing ▁" ▁; ▁else ▁c out ▁<< ▁find Small est ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁profit Loss ▁( ▁int ▁N ▁, ▁int ▁M ▁) ▁{ ▁if ▁( ▁N ▁== ▁M ▁) ▁c out ▁<< ▁" ▁No ▁Pro fit ▁nor ▁Loss ▁" ▁; ▁else ▁{ ▁float ▁result ▁= ▁0.0 ▁; ▁result ▁= ▁float ▁( ▁abs ▁( ▁N ▁- ▁M ▁) ▁) ▁/ ▁M ▁; ▁if ▁( ▁N ▁- ▁M ▁< ▁0 ▁) ▁c out ▁<< ▁" ▁Loss ▁= ▁- ▁" ▁<< ▁result ▁* ▁100 ▁<< ▁" ▁% ▁" ▁; ▁else ▁c out ▁<< ▁" ▁Pro fit ▁= ▁" ▁<< ▁result ▁* ▁100 ▁<< ▁" ▁% ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁8 ▁, ▁M ▁= ▁9 ▁; ▁profit Loss ▁( ▁N ▁, ▁M ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁Sum Div isible ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁, ▁position ▁= ▁1 ▁; ▁while ▁( ▁n ▁> ▁0 ▁) ▁{ ▁if ▁( ▁position ▁% ▁2 ▁== ▁1 ▁) ▁sum ▁+= ▁n ▁% ▁10 ▁; ▁n ▁= ▁n ▁/ ▁10 ▁; ▁position ▁++ ▁; ▁} ▁if ▁( ▁sum ▁% ▁k ▁== ▁0 ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁59 24 52 ▁; ▁int ▁k ▁= ▁3 ▁; ▁if ▁( ▁Sum Div isible ▁( ▁n ▁, ▁k ▁) ▁) ▁c out ▁<< ▁" ▁YES ▁" ▁; ▁else ▁c out ▁<< ▁" ▁NO ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁sum Div isible ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁string ▁num ▁= ▁to _ string ▁( ▁n ▁) ▁; ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁num ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁% ▁2 ▁!= ▁0 ▁) ▁{ ▁sum ▁= ▁sum ▁+ ▁( ▁num ▁[ ▁i ▁] ▁- ▁'0' ▁) ▁; ▁} ▁} ▁if ▁( ▁sum ▁% ▁k ▁== ▁0 ▁) ▁{ ▁return ▁true ▁; ▁} ▁else ▁{ ▁return ▁false ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁59 24 52 ▁; ▁int ▁k ▁= ▁3 ▁; ▁if ▁( ▁sum Div isible ▁( ▁n ▁, ▁k ▁) ▁) ▁{ ▁c out ▁<< ▁( ▁" ▁YES ▁" ▁) ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁( ▁" ▁NO ▁" ▁) ▁; ▁} ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁Equal Numbers ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁sum ▁+= ▁a ▁[ ▁i ▁] ▁; ▁if ▁( ▁sum ▁% ▁n ▁) ▁return ▁n ▁- ▁1 ▁; ▁return ▁n ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁4 ▁, ▁1 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁Equal Numbers ▁( ▁a ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁Possible Values ▁( ▁int ▁b ▁, ▁int ▁x ▁, ▁int ▁n ▁) ▁{ ▁int ▁least div isible ▁= ▁( ▁b ▁/ ▁x ▁+ ▁1 ▁) ▁* ▁x ▁; ▁int ▁flag ▁= ▁1 ▁; ▁while ▁( ▁least div isible ▁<= ▁n ▁) ▁{ ▁if ▁( ▁least div isible ▁- ▁b ▁>= ▁1 ▁) ▁{ ▁c out ▁<< ▁least div isible ▁- ▁b ▁<< ▁" ▁" ▁; ▁least div isible ▁+= ▁x ▁; ▁flag ▁= ▁0 ▁; ▁} ▁else ▁break ▁; ▁} ▁if ▁( ▁flag ▁) ▁c out ▁<< ▁-1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁b ▁= ▁10 ▁, ▁x ▁= ▁6 ▁, ▁n ▁= ▁40 ▁; ▁Possible Values ▁( ▁b ▁, ▁x ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁MAX ▁10000 ▁NEW _ LINE ▁unordered _ set ▁< ▁long ▁long ▁int ▁> ▁s ▁; ▁void ▁S ieve Of E rat ost hen es ▁( ▁) ▁{ ▁bool ▁prime ▁[ ▁MAX ▁] ▁; ▁mem set ▁( ▁prime ▁, ▁true ▁, ▁sizeof ▁( ▁prime ▁) ▁) ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁* ▁p ▁< ▁MAX ▁; ▁p ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁p ▁] ▁== ▁true ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁p ▁* ▁2 ▁; ▁i ▁< ▁MAX ▁; ▁i ▁+= ▁p ▁) ▁prime ▁[ ▁i ▁] ▁= ▁false ▁; ▁} ▁} ▁long ▁long ▁int ▁product ▁= ▁1 ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁< ▁MAX ▁; ▁p ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁p ▁] ▁) ▁{ ▁product ▁= ▁product ▁* ▁p ▁; ▁s ▁. ▁insert ▁( ▁product ▁+ ▁1 ▁) ▁; ▁} ▁} ▁} ▁bool ▁is E u cl id ▁( ▁long ▁n ▁) ▁{ ▁if ▁( ▁s ▁. ▁find ▁( ▁n ▁) ▁!= ▁s ▁. ▁end ▁( ▁) ▁) ▁return ▁true ▁; ▁else ▁return ▁false ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁S ieve Of E rat ost hen es ▁( ▁) ▁; ▁long ▁n ▁= ▁31 ▁; ▁if ▁( ▁is E u cl id ▁( ▁n ▁) ▁) ▁c out ▁<< ▁" ▁YES ▁STRNEWLINE ▁" ▁; ▁else ▁c out ▁<< ▁" ▁NO ▁STRNEWLINE ▁" ▁; ▁n ▁= ▁42 ▁; ▁if ▁( ▁is E u cl id ▁( ▁n ▁) ▁) ▁c out ▁<< ▁" ▁YES ▁STRNEWLINE ▁" ▁; ▁else ▁c out ▁<< ▁" ▁NO ▁STRNEWLINE ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁Number Of Solution s ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁int ▁c ▁, ▁int ▁d ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁a ▁; ▁i ▁<= ▁b ▁; ▁i ▁++ ▁) ▁if ▁( ▁d ▁>= ▁max ▁( ▁c ▁, ▁i ▁+ ▁1 ▁) ▁) ▁ans ▁+= ▁d ▁- ▁max ▁( ▁c ▁, ▁i ▁+ ▁1 ▁) ▁+ ▁1 ▁; ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁= ▁2 ▁, ▁b ▁= ▁3 ▁, ▁c ▁= ▁3 ▁, ▁d ▁= ▁4 ▁; ▁c out ▁<< ▁Number Of Solution s ▁( ▁a ▁, ▁b ▁, ▁c ▁, ▁d ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁# include ▁< math . h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁nth Term ▁( ▁int ▁n ▁) ▁{ ▁return ▁2 ▁* ▁pow ▁( ▁n ▁, ▁2 ▁) ▁+ ▁4 ▁* ▁n ▁- ▁2 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁4 ▁; ▁c out ▁<< ▁nth Term ▁( ▁N ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁calculate Area Sum ▁( ▁int ▁l ▁, ▁int ▁b ▁) ▁{ ▁int ▁size ▁= ▁1 ▁; ▁int ▁maxSize ▁= ▁min ▁( ▁l ▁, ▁b ▁) ▁; ▁int ▁total Area ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁maxSize ▁; ▁i ▁++ ▁) ▁{ ▁int ▁total Square s ▁= ▁( ▁l ▁- ▁size ▁+ ▁1 ▁) ▁* ▁( ▁b ▁- ▁size ▁+ ▁1 ▁) ▁; ▁int ▁area ▁= ▁total Square s ▁* ▁size ▁* ▁size ▁; ▁total Area ▁+= ▁area ▁; ▁size ▁++ ▁; ▁} ▁return ▁total Area ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁l ▁= ▁4 ▁, ▁b ▁= ▁3 ▁; ▁c out ▁<< ▁calculate Area Sum ▁( ▁l ▁, ▁b ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁check ▁( ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁while ▁( ▁n ▁!= ▁0 ▁) ▁{ ▁sum ▁+= ▁n ▁% ▁10 ▁; ▁n ▁= ▁n ▁/ ▁10 ▁; ▁} ▁if ▁( ▁sum ▁% ▁7 ▁== ▁0 ▁) ▁return ▁1 ▁; ▁else ▁return ▁0 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁25 ▁; ▁( ▁check ▁( ▁n ▁) ▁== ▁1 ▁) ▁? ▁c out ▁<< ▁" ▁YES ▁" ▁: ▁c out ▁<< ▁" ▁NO ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁bin omial Co eff ▁( ▁int ▁x ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁, ▁term ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁++ ▁i ▁) ▁{ ▁term ▁*= ▁x ▁- ▁i ▁+ ▁1 ▁; ▁term ▁/= ▁i ▁; ▁sum ▁+= ▁term ▁; ▁if ▁( ▁sum ▁> ▁k ▁) ▁return ▁sum ▁; ▁} ▁return ▁sum ▁; ▁} ▁int ▁min Tri als ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁low ▁= ▁1 ▁, ▁high ▁= ▁k ▁; ▁while ▁( ▁low ▁< ▁high ▁) ▁{ ▁int ▁mid ▁= ▁( ▁low ▁+ ▁high ▁) ▁/ ▁2 ▁; ▁if ▁( ▁bin omial Co eff ▁( ▁mid ▁, ▁n ▁, ▁k ▁) ▁< ▁k ▁) ▁low ▁= ▁mid ▁+ ▁1 ▁; ▁else ▁high ▁= ▁mid ▁; ▁} ▁return ▁low ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁c out ▁<< ▁min Tri als ▁( ▁2 ▁, ▁10 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁# include ▁< string > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is Prime ▁( ▁int ▁num ▁) ▁{ ▁if ▁( ▁num ▁< ▁2 ▁num ▁% ▁2 ▁== ▁0 ▁) ▁return ▁num ▁== ▁2 ▁; ▁for ▁( ▁int ▁i ▁= ▁3 ▁; ▁i ▁* ▁i ▁<= ▁num ▁; ▁i ▁+= ▁2 ▁) ▁if ▁( ▁num ▁% ▁i ▁== ▁0 ▁) ▁return ▁false ▁; ▁return ▁true ▁; ▁} ▁int ▁prime Pal indrome ▁( ▁int ▁N ▁) ▁{ ▁if ▁( ▁8 ▁<= ▁N ▁&& ▁N ▁<= ▁11 ▁) ▁return ▁11 ▁; ▁for ▁( ▁int ▁x ▁= ▁1 ▁; ▁x ▁< ▁100000 ▁; ▁++ ▁x ▁) ▁{ ▁string ▁s ▁= ▁to _ string ▁( ▁x ▁) ▁, ▁r ▁( ▁s ▁. ▁rb egin ▁( ▁) ▁, ▁s ▁. ▁rend ▁( ▁) ▁) ▁; ▁int ▁y ▁= ▁sto i ▁( ▁s ▁+ ▁r ▁. ▁substr ▁( ▁1 ▁) ▁) ▁; ▁if ▁( ▁y ▁>= ▁N ▁&& ▁is Prime ▁( ▁y ▁) ▁) ▁return ▁y ▁; ▁} ▁return ▁-1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁c out ▁<< ▁prime Pal indrome ▁( ▁112 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁# include ▁< boost / multip recision / cpp _ int . h pp > ▁NEW _ LINE ▁using ▁namespace ▁boost ▁:: ▁multip recision ▁; ▁using ▁namespace ▁std ▁; ▁int 1024 _ t ▁boost _ hyper factor ial ▁( ▁int ▁num ▁) ▁{ ▁int 1024 _ t ▁val ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁num ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁<= ▁i ▁; ▁j ▁++ ▁) ▁{ ▁val ▁*= ▁i ▁; ▁} ▁} ▁return ▁val ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁num ▁= ▁5 ▁; ▁c out ▁<< ▁boost _ hyper factor ial ▁( ▁num ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Odd Sum ▁( ▁int ▁ar ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁temp ▁[ ▁2 ▁] ▁= ▁{ ▁1 ▁, ▁0 ▁} ▁; ▁int ▁result ▁= ▁0 ▁, ▁val ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁val ▁= ▁( ▁( ▁val ▁+ ▁ar ▁[ ▁i ▁] ▁) ▁% ▁2 ▁+ ▁2 ▁) ▁% ▁2 ▁; ▁temp ▁[ ▁val ▁] ▁++ ▁; ▁} ▁result ▁= ▁( ▁temp ▁[ ▁0 ▁] ▁* ▁temp ▁[ ▁1 ▁] ▁) ▁; ▁return ▁( ▁result ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁ar ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁4 ▁, ▁4 ▁, ▁5 ▁, ▁1 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁ar ▁) ▁/ ▁sizeof ▁( ▁ar ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁The ▁Number ▁of ▁Sub arrays ▁with ▁odd ▁" ▁" ▁sum ▁is ▁" ▁<< ▁count Odd Sum ▁( ▁ar ▁, ▁n ▁) ▁; ▁return ▁( ▁0 ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁center _ hex ad ec ag onal _ num ▁( ▁long ▁int ▁n ▁) ▁{ ▁return ▁8 ▁* ▁n ▁* ▁n ▁- ▁8 ▁* ▁n ▁+ ▁1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁long ▁int ▁n ▁= ▁2 ▁; ▁c out ▁<< ▁n ▁<< ▁" ▁th ▁centered ▁hex ad ec ag onal ▁number ▁: ▁" ▁<< ▁center _ hex ad ec ag onal _ num ▁( ▁n ▁) ▁; ▁c out ▁<< ▁end l ▁; ▁n ▁= ▁12 ▁; ▁c out ▁<< ▁n ▁<< ▁" ▁th ▁centered ▁hex ad ec ag onal ▁num be ▁: ▁" ▁<< ▁center _ hex ad ec ag onal _ num ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁check ▁( ▁unsigned ▁long ▁long ▁m ▁, ▁unsigned ▁long ▁long ▁int ▁n ▁) ▁{ ▁double ▁R HS ▁= ▁m ▁* ▁( ▁double ▁) ▁log ▁( ▁n ▁) ▁; ▁double ▁L HS ▁= ▁n ▁* ▁( ▁double ▁) ▁log ▁( ▁m ▁) ▁; ▁if ▁( ▁L HS ▁> ▁R HS ▁) ▁c out ▁<< ▁" ▁m ▁^ ▁n ▁> ▁n ▁^ ▁m ▁" ▁; ▁else ▁if ▁( ▁L HS ▁< ▁R HS ▁) ▁c out ▁<< ▁" ▁m ▁^ ▁n ▁< ▁n ▁^ ▁m ▁" ▁; ▁else ▁c out ▁<< ▁" ▁m ▁^ ▁n ▁= ▁n ▁^ ▁m ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁unsigned ▁long ▁long ▁m ▁= ▁98 7654 321 ▁, ▁n ▁= ▁123456 98 7 ▁; ▁check ▁( ▁m ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁factorial ▁( ▁int ▁n ▁) ▁{ ▁int ▁res ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁res ▁= ▁res ▁* ▁i ▁; ▁return ▁res ▁; ▁} ▁int ▁calculate Series ▁( ▁int ▁n ▁) ▁{ ▁return ▁2 ▁+ ▁( ▁n ▁* ▁n ▁+ ▁n ▁- ▁2 ▁) ▁* ▁factorial ▁( ▁n ▁+ ▁1 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁3 ▁; ▁c out ▁<< ▁calculate Series ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Sum ▁( ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁sum ▁+= ▁( ▁( ▁i ▁* ▁( ▁i ▁+ ▁1 ▁) ▁* ▁( ▁2 ▁* ▁i ▁+ ▁1 ▁) ▁) ▁/ ▁6 ▁) ▁; ▁return ▁sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁3 ▁; ▁c out ▁<< ▁find Sum ▁( ▁n ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁vector ▁< ▁long ▁long ▁int ▁> ▁gen ▁( ▁long ▁long ▁int ▁n ▁, ▁vector ▁< ▁long ▁long ▁int ▁> ▁r ▁) ▁{ ▁long ▁long ▁int ▁a ▁= ▁r ▁[ ▁r ▁. ▁size ▁( ▁) ▁- ▁1 ▁] ▁; ▁a ▁++ ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁a ▁+= ▁2 ▁, ▁i ▁++ ▁) ▁r ▁. ▁push _ back ▁( ▁a ▁) ▁; ▁return ▁r ▁; ▁} ▁vector ▁< ▁long ▁long ▁int ▁> ▁con ell ▁( ▁long ▁long ▁int ▁n ▁) ▁{ ▁vector ▁< ▁long ▁long ▁int ▁> ▁res ▁; ▁long ▁long ▁int ▁k ▁= ▁1 ▁; ▁res ▁. ▁push _ back ▁( ▁0 ▁) ▁; ▁while ▁( ▁1 ▁) ▁{ ▁res ▁= ▁gen ▁( ▁k ▁, ▁res ▁) ▁; ▁k ▁++ ▁; ▁int ▁j ▁= ▁res ▁. ▁size ▁( ▁) ▁- ▁1 ▁; ▁while ▁( ▁j ▁!= ▁n ▁&& ▁j ▁+ ▁k ▁> ▁n ▁) ▁k ▁-- ▁; ▁if ▁( ▁j ▁>= ▁n ▁) ▁break ▁; ▁} ▁res ▁. ▁erase ▁( ▁res ▁. ▁begin ▁( ▁) ▁) ▁; ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁long ▁long ▁int ▁n ▁= ▁10 ▁; ▁c out ▁<< ▁" ▁The ▁first ▁" ▁<< ▁n ▁<< ▁" ▁terms ▁are ▁" ▁<< ▁end l ▁; ▁vector ▁< ▁long ▁long ▁int ▁> ▁res ▁= ▁con ell ▁( ▁n ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁res ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁res ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁c out ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁N ic om ach u The orum _ sum ▁( ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁k ▁= ▁1 ▁; ▁k ▁<= ▁n ▁; ▁k ▁++ ▁) ▁sum ▁+= ▁k ▁* ▁k ▁* ▁k ▁; ▁int ▁tri No ▁= ▁n ▁* ▁( ▁n ▁+ ▁1 ▁) ▁/ ▁2 ▁; ▁if ▁( ▁sum ▁== ▁tri No ▁* ▁tri No ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁5 ▁; ▁N ic om ach u The orum _ sum ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁unsigned ▁int ▁factorial ▁( ▁unsigned ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁0 ▁) ▁return ▁1 ▁; ▁return ▁n ▁* ▁factorial ▁( ▁n ▁- ▁1 ▁) ▁; ▁} ▁int ▁L CM Of Ne ighb our Fact ▁( ▁int ▁n ▁) ▁{ ▁return ▁factorial ▁( ▁n ▁+ ▁1 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁5 ▁; ▁c out ▁<< ▁L CM Of Ne ighb our Fact ▁( ▁N ▁) ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁# include ▁< cm ath > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is Prime ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁0 ▁n ▁== ▁1 ▁) ▁return ▁false ▁; ▁int ▁root ▁= ▁sqrt ▁( ▁n ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁root ▁; ▁i ▁++ ▁) ▁if ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁return ▁false ▁; ▁return ▁true ▁; ▁} ▁bool ▁isS and witch ed ▁( ▁int ▁n ▁) ▁{ ▁return ▁( ▁is Prime ▁( ▁n ▁- ▁1 ▁) ▁&& ▁is Prime ▁( ▁n ▁+ ▁1 ▁) ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁64 2 ▁; ▁c out ▁<< ▁n ▁<< ▁" ▁: ▁" ▁; ▁if ▁( ▁isS and witch ed ▁( ▁n ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁STRNEWLINE ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁STRNEWLINE ▁" ▁; ▁n ▁= ▁9 ▁; ▁c out ▁<< ▁n ▁<< ▁" ▁: ▁" ▁; ▁if ▁( ▁isS and witch ed ▁( ▁n ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁STRNEWLINE ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁STRNEWLINE ▁" ▁; ▁return ▁0 ▁; ▁}
▁# ▁include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is Square Free ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁% ▁2 ▁== ▁0 ▁) ▁n ▁= ▁n ▁/ ▁2 ▁; ▁if ▁( ▁n ▁% ▁2 ▁== ▁0 ▁) ▁return ▁false ▁; ▁for ▁( ▁int ▁i ▁= ▁3 ▁; ▁i ▁<= ▁sqrt ▁( ▁n ▁) ▁; ▁i ▁= ▁i ▁+ ▁2 ▁) ▁{ ▁if ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁{ ▁n ▁= ▁n ▁/ ▁i ▁; ▁if ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁return ▁false ▁; ▁} ▁} ▁return ▁true ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁10 ▁; ▁if ▁( ▁is Square Free ▁( ▁n ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁sum of odd Fact ors ▁( ▁int ▁n ▁) ▁{ ▁int ▁res ▁= ▁1 ▁; ▁while ▁( ▁n ▁% ▁2 ▁== ▁0 ▁) ▁n ▁= ▁n ▁/ ▁2 ▁; ▁for ▁( ▁int ▁i ▁= ▁3 ▁; ▁i ▁<= ▁sqrt ▁( ▁n ▁) ▁; ▁i ▁++ ▁) ▁{ ▁int ▁count ▁= ▁0 ▁, ▁curr _ sum ▁= ▁1 ▁; ▁int ▁curr _ term ▁= ▁1 ▁; ▁while ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁{ ▁count ▁++ ▁; ▁n ▁= ▁n ▁/ ▁i ▁; ▁curr _ term ▁*= ▁i ▁; ▁curr _ sum ▁+= ▁curr _ term ▁; ▁} ▁res ▁*= ▁curr _ sum ▁; ▁} ▁if ▁( ▁n ▁>= ▁2 ▁) ▁res ▁*= ▁( ▁1 ▁+ ▁n ▁) ▁; ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁30 ▁; ▁c out ▁<< ▁sum of odd Fact ors ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Solution s ▁( ▁int ▁n ▁, ▁int ▁val ▁) ▁{ ▁int ▁total ▁= ▁0 ▁; ▁if ▁( ▁n ▁== ▁1 ▁&& ▁val ▁>= ▁0 ▁) ▁return ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁val ▁; ▁i ▁++ ▁) ▁{ ▁total ▁+= ▁count Solution s ▁( ▁n ▁- ▁1 ▁, ▁val ▁- ▁i ▁) ▁; ▁} ▁return ▁total ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁5 ▁; ▁int ▁val ▁= ▁20 ▁; ▁c out ▁<< ▁count Solution s ▁( ▁n ▁, ▁val ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Digit ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁0 ▁) ▁return ▁0 ▁; ▁return ▁1 ▁+ ▁count Digit ▁( ▁n ▁/ ▁10 ▁) ▁; ▁} ▁bool ▁check ▁( ▁int ▁n ▁) ▁{ ▁int ▁l ▁= ▁count Digit ▁( ▁n ▁) ▁; ▁int ▁dup ▁= ▁n ▁; ▁int ▁sum ▁= ▁0 ▁; ▁while ▁( ▁dup ▁) ▁{ ▁sum ▁+= ▁pow ▁( ▁dup ▁% ▁10 ▁, ▁l ▁) ▁; ▁dup ▁/= ▁10 ▁; ▁} ▁return ▁( ▁n ▁== ▁sum ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁16 34 ▁; ▁if ▁( ▁check ▁( ▁n ▁) ▁) ▁c out ▁<< ▁" ▁yes ▁" ▁; ▁else ▁c out ▁<< ▁" ▁no ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁gcd ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁if ▁( ▁a ▁== ▁0 ▁) ▁return ▁b ▁; ▁return ▁gcd ▁( ▁b ▁% ▁a ▁, ▁a ▁) ▁; ▁} ▁int ▁same Rem ainder ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁int ▁c ▁) ▁{ ▁int ▁a 1 ▁= ▁( ▁b ▁- ▁a ▁) ▁, ▁b 1 ▁= ▁( ▁c ▁- ▁b ▁) ▁, ▁c 1 ▁= ▁( ▁c ▁- ▁a ▁) ▁; ▁return ▁gcd ▁( ▁a 1 ▁, ▁gcd ▁( ▁b 1 ▁, ▁c 1 ▁) ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁= ▁62 ▁, ▁b ▁= ▁132 ▁, ▁c ▁= ▁2 37 ▁; ▁c out ▁<< ▁same Rem ainder ▁( ▁a ▁, ▁b ▁, ▁c ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁char ▁* ▁Prime Digit Number ▁( ▁char ▁N ▁[ ▁] ▁, ▁int ▁size ▁) ▁{ ▁char ▁* ▁ans ▁= ▁( ▁char ▁* ▁) ▁m alloc ▁( ▁size ▁* ▁sizeof ▁( ▁char ▁) ▁) ▁; ▁int ▁ns ▁= ▁0 ▁; ▁int ▁small ▁= ▁0 ▁; ▁int ▁i ▁; ▁int ▁p ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁0 ▁} ▁; ▁int ▁prev prime ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁2 ▁, ▁3 ▁, ▁3 ▁, ▁5 ▁, ▁5 ▁, ▁7 ▁, ▁7 ▁} ▁; ▁if ▁( ▁size ▁== ▁1 ▁) ▁{ ▁ans ▁[ ▁0 ▁] ▁= ▁prev prime ▁[ ▁N ▁[ ▁0 ▁] ▁- ▁'0' ▁] ▁+ ▁'0' ▁; ▁ans ▁[ ▁1 ▁] ▁= ▁' ▁\0' ▁; ▁return ▁ans ▁; ▁} ▁if ▁( ▁N ▁[ ▁0 ▁] ▁== ▁'1' ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁- ▁1 ▁; ▁i ▁++ ▁) ▁ans ▁[ ▁i ▁] ▁= ▁'7' ▁; ▁ans ▁[ ▁size ▁- ▁1 ▁] ▁= ▁' ▁\0' ▁; ▁return ▁ans ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁&& ▁small ▁== ▁0 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁p ▁[ ▁N ▁[ ▁i ▁] ▁- ▁'0' ▁] ▁== ▁1 ▁) ▁{ ▁ans ▁[ ▁ns ▁++ ▁] ▁= ▁N ▁[ ▁i ▁] ▁; ▁} ▁else ▁{ ▁if ▁( ▁p ▁[ ▁N ▁[ ▁i ▁] ▁- ▁'0' ▁] ▁== ▁0 ▁&& ▁prev prime ▁[ ▁N ▁[ ▁i ▁] ▁- ▁'0' ▁] ▁!= ▁0 ▁) ▁{ ▁ans ▁[ ▁ns ▁++ ▁] ▁= ▁prev prime ▁[ ▁N ▁[ ▁i ▁] ▁- ▁'0' ▁] ▁+ ▁'0' ▁; ▁small ▁= ▁1 ▁; ▁} ▁else ▁if ▁( ▁p ▁[ ▁N ▁[ ▁i ▁] ▁- ▁'0' ▁] ▁== ▁0 ▁&& ▁prev prime ▁[ ▁N ▁[ ▁i ▁] ▁- ▁'0' ▁] ▁== ▁0 ▁) ▁{ ▁int ▁j ▁= ▁i ▁; ▁while ▁( ▁j ▁> ▁0 ▁&& ▁p ▁[ ▁N ▁[ ▁j ▁] ▁- ▁'0' ▁] ▁== ▁0 ▁&& ▁prev prime ▁[ ▁N ▁[ ▁j ▁] ▁- ▁'0' ▁] ▁== ▁0 ▁) ▁{ ▁ans ▁[ ▁j ▁] ▁= ▁N ▁[ ▁j ▁] ▁= ▁'7' ▁; ▁N ▁[ ▁j ▁- ▁1 ▁] ▁= ▁prev prime ▁[ ▁N ▁[ ▁j ▁- ▁1 ▁] ▁- ▁'0' ▁] ▁+ ▁'0' ▁; ▁ans ▁[ ▁j ▁- ▁1 ▁] ▁= ▁N ▁[ ▁j ▁- ▁1 ▁] ▁; ▁small ▁= ▁1 ▁; ▁j ▁-- ▁; ▁} ▁i ▁= ▁ns ▁; ▁} ▁} ▁} ▁if ▁( ▁small ▁== ▁0 ▁) ▁{ ▁if ▁( ▁prev prime ▁[ ▁N ▁[ ▁size ▁- ▁1 ▁] ▁- ▁'0' ▁] ▁+ ▁'0' ▁!= ▁'0' ▁) ▁ans ▁[ ▁size ▁- ▁1 ▁] ▁= ▁prev prime ▁[ ▁N ▁[ ▁size ▁- ▁1 ▁] ▁- ▁'0' ▁] ▁+ ▁'0' ▁; ▁else ▁{ ▁int ▁j ▁= ▁size ▁- ▁1 ▁; ▁while ▁( ▁j ▁> ▁0 ▁&& ▁prev prime ▁[ ▁N ▁[ ▁j ▁] ▁- ▁'0' ▁] ▁== ▁0 ▁) ▁{ ▁ans ▁[ ▁j ▁] ▁= ▁N ▁[ ▁j ▁] ▁= ▁'7' ▁; ▁N ▁[ ▁j ▁- ▁1 ▁] ▁= ▁prev prime ▁[ ▁N ▁[ ▁j ▁- ▁1 ▁] ▁- ▁'0' ▁] ▁+ ▁'0' ▁; ▁ans ▁[ ▁j ▁- ▁1 ▁] ▁= ▁N ▁[ ▁j ▁- ▁1 ▁] ▁; ▁small ▁= ▁1 ▁; ▁j ▁-- ▁; ▁} ▁} ▁} ▁for ▁( ▁; ▁ns ▁< ▁size ▁; ▁ns ▁++ ▁) ▁ans ▁[ ▁ns ▁] ▁= ▁'7' ▁; ▁ans ▁[ ▁ns ▁] ▁= ▁' ▁\0' ▁; ▁int ▁k ▁= ▁0 ▁; ▁while ▁( ▁ans ▁[ ▁k ▁] ▁== ▁'0' ▁) ▁k ▁++ ▁; ▁return ▁ans ▁+ ▁k ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁char ▁N ▁[ ▁] ▁= ▁"1 000" ▁; ▁int ▁size ▁= ▁str len ▁( ▁N ▁) ▁; ▁c out ▁<< ▁Prime Digit Number ▁( ▁N ▁, ▁size ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁# include ▁< algorithm > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is Power Of K ▁( ▁unsigned ▁int ▁n ▁, ▁unsigned ▁int ▁k ▁) ▁{ ▁bool ▁one Seen ▁= ▁false ▁; ▁while ▁( ▁n ▁> ▁0 ▁) ▁{ ▁int ▁digit ▁= ▁n ▁% ▁k ▁; ▁if ▁( ▁digit ▁> ▁1 ▁) ▁return ▁false ▁; ▁if ▁( ▁digit ▁== ▁1 ▁) ▁{ ▁if ▁( ▁one Seen ▁) ▁return ▁false ▁; ▁one Seen ▁= ▁true ▁; ▁} ▁n ▁/= ▁k ▁; ▁} ▁return ▁true ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁64 ▁, ▁k ▁= ▁4 ▁; ▁if ▁( ▁is Power Of K ▁( ▁n ▁, ▁k ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁calc Scr ▁( ▁vector ▁< ▁int ▁> ▁arr ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁arr ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁ans ▁+= ▁( ▁i ▁^ ▁arr ▁[ ▁i ▁] ▁) ▁; ▁return ▁ans ▁; ▁} ▁int ▁getMax ▁( ▁vector ▁< ▁int ▁> ▁arr ▁, ▁int ▁ans ▁, ▁vector ▁< ▁bool ▁> ▁chosen ▁, ▁int ▁N ▁) ▁{ ▁if ▁( ▁arr ▁. ▁size ▁( ▁) ▁== ▁N ▁) ▁{ ▁ans ▁= ▁max ▁( ▁ans ▁, ▁calc Scr ▁( ▁arr ▁) ▁) ▁; ▁return ▁ans ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁chosen ▁[ ▁i ▁] ▁) ▁continue ▁; ▁chosen ▁[ ▁i ▁] ▁= ▁true ▁; ▁arr ▁. ▁push _ back ▁( ▁i ▁) ▁; ▁ans ▁= ▁getMax ▁( ▁arr ▁, ▁ans ▁, ▁chosen ▁, ▁N ▁) ▁; ▁chosen ▁[ ▁i ▁] ▁= ▁false ▁; ▁arr ▁. ▁pop _ back ▁( ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁2 ▁; ▁vector ▁< ▁int ▁> ▁arr ▁; ▁int ▁ans ▁= ▁-1 ▁; ▁vector ▁< ▁bool ▁> ▁chosen ▁( ▁N ▁, ▁false ▁) ▁; ▁ans ▁= ▁getMax ▁( ▁arr ▁, ▁ans ▁, ▁chosen ▁, ▁N ▁) ▁; ▁c out ▁<< ▁ans ▁<< ▁end l ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find Prime N os ▁( ▁int ▁L ▁, ▁int ▁R ▁, ▁unordered _ map ▁< ▁int ▁, ▁int ▁> ▁& ▁M ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁L ▁; ▁i ▁<= ▁R ▁; ▁i ▁++ ▁) ▁{ ▁M ▁[ ▁i ▁] ▁++ ▁; ▁} ▁if ▁( ▁M ▁. ▁find ▁( ▁1 ▁) ▁!= ▁M ▁. ▁end ▁( ▁) ▁) ▁{ ▁M ▁. ▁erase ▁( ▁1 ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁sqrt ▁( ▁R ▁) ▁; ▁i ▁++ ▁) ▁{ ▁int ▁multiple ▁= ▁2 ▁; ▁while ▁( ▁( ▁i ▁* ▁multiple ▁) ▁<= ▁R ▁) ▁{ ▁if ▁( ▁M ▁. ▁find ▁( ▁i ▁* ▁multiple ▁) ▁!= ▁M ▁. ▁end ▁( ▁) ▁) ▁{ ▁M ▁. ▁erase ▁( ▁i ▁* ▁multiple ▁) ▁; ▁} ▁multiple ▁++ ▁; ▁} ▁} ▁} ▁void ▁getPr ime Pairs ▁( ▁int ▁L ▁, ▁int ▁R ▁, ▁int ▁K ▁) ▁{ ▁unordered _ map ▁< ▁int ▁, ▁int ▁> ▁M ▁; ▁find Prime N os ▁( ▁L ▁, ▁R ▁, ▁M ▁) ▁; ▁for ▁( ▁auto ▁& ▁it ▁: ▁M ▁) ▁{ ▁if ▁( ▁M ▁. ▁find ▁( ▁it ▁. ▁first ▁+ ▁K ▁) ▁!= ▁M ▁. ▁end ▁( ▁) ▁) ▁{ ▁c out ▁<< ▁" ▁( ▁" ▁<< ▁it ▁. ▁first ▁<< ▁" ▁, ▁" ▁<< ▁it ▁. ▁first ▁+ ▁K ▁<< ▁" ▁) ▁" ▁; ▁} ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁L ▁= ▁1 ▁, ▁R ▁= ▁19 ▁; ▁int ▁K ▁= ▁6 ▁; ▁getPr ime Pairs ▁( ▁L ▁, ▁R ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁gon Num 6 55 37 ▁( ▁int ▁n ▁) ▁{ ▁return ▁( ▁65535 ▁* ▁n ▁* ▁n ▁- ▁655 33 ▁* ▁n ▁) ▁/ ▁2 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁3 ▁; ▁c out ▁<< ▁gon Num 6 55 37 ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁sort ▁( ▁arr ▁, ▁arr ▁+ ▁n ▁) ▁; ▁int ▁cnt ▁= ▁0 ▁; ▁int ▁i ▁= ▁0 ▁, ▁j ▁= ▁1 ▁; ▁while ▁( ▁i ▁< ▁n ▁&& ▁j ▁< ▁n ▁) ▁{ ▁j ▁= ▁( ▁j ▁<= ▁i ▁) ▁? ▁( ▁i ▁+ ▁1 ▁) ▁: ▁j ▁; ▁while ▁( ▁j ▁< ▁n ▁&& ▁( ▁arr ▁[ ▁j ▁] ▁- ▁arr ▁[ ▁i ▁] ▁) ▁< ▁k ▁) ▁j ▁++ ▁; ▁cnt ▁+= ▁( ▁n ▁- ▁j ▁) ▁; ▁i ▁++ ▁; ▁} ▁return ▁cnt ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁k ▁= ▁2 ▁; ▁c out ▁<< ▁count ▁( ▁arr ▁, ▁n ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁maximum Factor ▁( ▁vector ▁< ▁int ▁> ▁arr ▁) ▁{ ▁int ▁n ▁= ▁arr ▁. ▁size ▁( ▁) ▁; ▁vector ▁< ▁int ▁> ▁rank ▁; ▁vector ▁< ▁int ▁> ▁factors ▁; ▁int ▁max ▁= ▁* ▁max _ element ▁( ▁arr ▁. ▁begin ▁( ▁) ▁, ▁arr ▁. ▁end ▁( ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁max ▁; ▁i ▁++ ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁j ▁] ▁% ▁i ▁== ▁0 ▁) ▁count ▁+= ▁1 ▁; ▁rank ▁. ▁push _ back ▁( ▁count ▁) ▁; ▁factors ▁. ▁push _ back ▁( ▁i ▁) ▁; ▁} ▁} ▁int ▁m ▁= ▁* ▁max _ element ▁( ▁rank ▁. ▁begin ▁( ▁) ▁, ▁rank ▁. ▁end ▁( ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁rank ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁rank ▁[ ▁i ▁] ▁== ▁m ▁) ▁c out ▁<< ▁factors ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁int ▁> ▁arr ▁= ▁{ ▁120 ▁, ▁15 ▁, ▁24 ▁, ▁63 ▁, ▁18 ▁} ▁; ▁maximum Factor ▁( ▁arr ▁) ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Sum ▁( ▁int ▁n ▁, ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁i ▁% ▁a ▁== ▁0 ▁i ▁% ▁b ▁== ▁0 ▁) ▁sum ▁+= ▁i ▁; ▁return ▁sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁10 ▁, ▁a ▁= ▁3 ▁, ▁b ▁= ▁5 ▁; ▁c out ▁<< ▁find Sum ▁( ▁n ▁, ▁a ▁, ▁b ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁double ▁find Medi an ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁sort ▁( ▁a ▁, ▁a ▁+ ▁n ▁) ▁; ▁if ▁( ▁n ▁% ▁2 ▁!= ▁0 ▁) ▁return ▁( ▁double ▁) ▁a ▁[ ▁n ▁/ ▁2 ▁] ▁; ▁return ▁( ▁double ▁) ▁( ▁a ▁[ ▁( ▁n ▁- ▁1 ▁) ▁/ ▁2 ▁] ▁+ ▁a ▁[ ▁n ▁/ ▁2 ▁] ▁) ▁/ ▁2.0 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁4 ▁, ▁2 ▁, ▁7 ▁, ▁5 ▁, ▁8 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁Medi an ▁= ▁" ▁<< ▁find Medi an ▁( ▁a ▁, ▁n ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁centered I cos ah ed ral Num ▁( ▁int ▁n ▁) ▁{ ▁return ▁( ▁2 ▁* ▁n ▁+ ▁1 ▁) ▁* ▁( ▁5 ▁* ▁n ▁* ▁n ▁+ ▁5 ▁* ▁n ▁+ ▁3 ▁) ▁/ ▁3 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁10 ▁; ▁c out ▁<< ▁centered I cos ah ed ral Num ▁( ▁n ▁) ▁<< ▁end l ▁; ▁n ▁= ▁12 ▁; ▁c out ▁<< ▁centered I cos ah ed ral Num ▁( ▁n ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁D ode c ag onal _ number ▁( ▁int ▁n ▁) ▁{ ▁return ▁5 ▁* ▁n ▁* ▁n ▁- ▁4 ▁* ▁n ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁7 ▁; ▁c out ▁<< ▁D ode c ag onal _ number ▁( ▁n ▁) ▁<< ▁end l ▁; ▁n ▁= ▁12 ▁; ▁c out ▁<< ▁D ode c ag onal _ number ▁( ▁n ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁average Even ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁% ▁2 ▁!= ▁0 ▁) ▁{ ▁c out ▁<< ▁" ▁Invalid ▁Input ▁" ▁; ▁return ▁-1 ▁; ▁} ▁return ▁( ▁n ▁+ ▁2 ▁) ▁/ ▁2 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁16 ▁; ▁c out ▁<< ▁average Even ▁( ▁n ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁double ▁compute ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁double ▁AM ▁, ▁G M ▁, ▁H M ▁; ▁AM ▁= ▁( ▁a ▁+ ▁b ▁) ▁/ ▁2 ▁; ▁G M ▁= ▁sqrt ▁( ▁a ▁* ▁b ▁) ▁; ▁H M ▁= ▁( ▁G M ▁* ▁G M ▁) ▁/ ▁AM ▁; ▁return ▁H M ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁= ▁5 ▁, ▁b ▁= ▁15 ▁; ▁double ▁H M ▁= ▁compute ▁( ▁a ▁, ▁b ▁) ▁; ▁c out ▁<< ▁" ▁Har mon ic ▁Mean ▁between ▁" ▁<< ▁a ▁<< ▁" ▁and ▁" ▁<< ▁b ▁<< ▁" ▁is ▁" ▁<< ▁H M ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁EPS ▁1 e -9 ▁NEW _ LINE ▁void ▁product P uzz le ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁long ▁double ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁sum ▁+= ▁( ▁long ▁double ▁) ▁log 10 ▁( ▁a ▁[ ▁i ▁] ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁( ▁int ▁) ▁( ▁EPS ▁+ ▁pow ▁( ▁( ▁long ▁double ▁) ▁10. 00 ▁, ▁sum ▁- ▁log 10 ▁( ▁a ▁[ ▁i ▁] ▁) ▁) ▁) ▁<< ▁" ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁3 ▁, ▁5 ▁, ▁6 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁The ▁product ▁array ▁is ▁: ▁STRNEWLINE ▁" ▁; ▁product P uzz le ▁( ▁a ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁p ell ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁<= ▁2 ▁) ▁return ▁n ▁; ▁return ▁2 ▁* ▁p ell ▁( ▁n ▁- ▁1 ▁) ▁+ ▁p ell ▁( ▁n ▁- ▁2 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁4 ▁; ▁c out ▁<< ▁" ▁" ▁<< ▁p ell ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁# define ▁ll ▁long ▁long ▁NEW _ LINE ▁# define ▁ld ▁long ▁double ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁ll ▁find Min Value ▁( ▁ll ▁arr ▁[ ▁] ▁, ▁ll ▁n ▁) ▁{ ▁sort ▁( ▁arr ▁, ▁arr ▁+ ▁n ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁val ▁+= ▁( ▁ld ▁) ▁( ▁log ▁( ▁( ▁ld ▁) ▁( ▁arr ▁[ ▁i ▁] ▁) ▁) ▁) ▁; ▁ll ▁left ▁= ▁arr ▁[ ▁0 ▁] ▁, ▁right ▁= ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁+ ▁1 ▁; ▁ll ▁ans ▁; ▁while ▁( ▁left ▁<= ▁right ▁) ▁{ ▁ll ▁mid ▁= ▁( ▁left ▁+ ▁right ▁) ▁/ ▁2 ▁; ▁ld ▁temp ▁= ▁( ▁ld ▁) ▁n ▁* ▁( ▁ld ▁) ▁( ▁log ▁( ▁( ▁ld ▁) ▁( ▁mid ▁) ▁) ▁) ▁; ▁if ▁( ▁val ▁< ▁temp ▁) ▁{ ▁ans ▁= ▁mid ▁; ▁right ▁= ▁mid ▁- ▁1 ▁; ▁} ▁else ▁left ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁ll ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁2 ▁, ▁1 ▁, ▁10 ▁, ▁6 ▁} ▁; ▁ll ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁find Min Value ▁( ▁arr ▁, ▁n ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print Other S ides ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁& ▁1 ▁) ▁{ ▁if ▁( ▁n ▁== ▁1 ▁) ▁c out ▁<< ▁-1 ▁<< ▁end l ▁; ▁else ▁{ ▁int ▁b ▁= ▁( ▁n ▁* ▁n ▁- ▁1 ▁) ▁/ ▁2 ▁; ▁int ▁c ▁= ▁( ▁n ▁* ▁n ▁+ ▁1 ▁) ▁/ ▁2 ▁; ▁c out ▁<< ▁" ▁b ▁= ▁" ▁<< ▁b ▁<< ▁" ▁, ▁c ▁= ▁" ▁<< ▁c ▁<< ▁end l ▁; ▁} ▁} ▁else ▁{ ▁if ▁( ▁n ▁== ▁2 ▁) ▁c out ▁<< ▁-1 ▁<< ▁end l ▁; ▁else ▁{ ▁int ▁b ▁= ▁n ▁* ▁n ▁/ ▁4 ▁- ▁1 ▁; ▁int ▁c ▁= ▁n ▁* ▁n ▁/ ▁4 ▁+ ▁1 ▁; ▁c out ▁<< ▁" ▁b ▁= ▁" ▁<< ▁b ▁<< ▁" ▁, ▁c ▁= ▁" ▁<< ▁c ▁<< ▁end l ▁; ▁} ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁= ▁3 ▁; ▁print Other S ides ▁( ▁a ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁fact ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁0 ▁) ▁return ▁1 ▁; ▁return ▁n ▁* ▁fact ▁( ▁n ▁- ▁1 ▁) ▁; ▁} ▁int ▁div ▁( ▁int ▁x ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁x ▁; ▁i ▁++ ▁) ▁if ▁( ▁x ▁% ▁i ▁== ▁0 ▁) ▁ans ▁+= ▁i ▁; ▁return ▁ans ▁; ▁} ▁int ▁sum Fact Div ▁( ▁int ▁n ▁) ▁{ ▁return ▁div ▁( ▁fact ▁( ▁n ▁) ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁4 ▁; ▁c out ▁<< ▁sum Fact Div ▁( ▁n ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁# include ▁< math . h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁vector ▁< ▁int ▁> ▁all Pr imes ▁; ▁void ▁s ieve ▁( ▁int ▁n ▁) ▁{ ▁vector ▁< ▁bool ▁> ▁prime ▁( ▁n ▁+ ▁1 ▁, ▁true ▁) ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁* ▁p ▁<= ▁n ▁; ▁p ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁p ▁] ▁== ▁true ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁p ▁* ▁2 ▁; ▁i ▁<= ▁n ▁; ▁i ▁+= ▁p ▁) ▁prime ▁[ ▁i ▁] ▁= ▁false ▁; ▁} ▁} ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁<= ▁n ▁; ▁p ▁++ ▁) ▁if ▁( ▁prime ▁[ ▁p ▁] ▁) ▁all Pr imes ▁. ▁push _ back ▁( ▁p ▁) ▁; ▁} ▁int ▁factorial Div is ors ▁( ▁int ▁n ▁) ▁{ ▁int ▁result ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁all Pr imes ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁int ▁p ▁= ▁all Pr imes ▁[ ▁i ▁] ▁; ▁int ▁exp ▁= ▁0 ▁; ▁while ▁( ▁p ▁<= ▁n ▁) ▁{ ▁exp ▁= ▁exp ▁+ ▁( ▁n ▁/ ▁p ▁) ▁; ▁p ▁= ▁p ▁* ▁all Pr imes ▁[ ▁i ▁] ▁; ▁} ▁result ▁= ▁result ▁* ▁( ▁pow ▁( ▁all Pr imes ▁[ ▁i ▁] ▁, ▁exp ▁+ ▁1 ▁) ▁- ▁1 ▁) ▁/ ▁( ▁all Pr imes ▁[ ▁i ▁] ▁- ▁1 ▁) ▁; ▁} ▁return ▁result ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁c out ▁<< ▁factorial Div is ors ▁( ▁4 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁check P and ig ital ▁( ▁int ▁b ▁, ▁char ▁n ▁[ ▁] ▁) ▁{ ▁if ▁( ▁str len ▁( ▁n ▁) ▁< ▁b ▁) ▁return ▁false ▁; ▁bool ▁hash ▁[ ▁b ▁] ▁; ▁mem set ▁( ▁hash ▁, ▁false ▁, ▁sizeof ▁( ▁hash ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁str len ▁( ▁n ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁n ▁[ ▁i ▁] ▁>= ▁'0' ▁&& ▁n ▁[ ▁i ▁] ▁<= ▁'9' ▁) ▁hash ▁[ ▁n ▁[ ▁i ▁] ▁- ▁'0' ▁] ▁= ▁true ▁; ▁else ▁if ▁( ▁n ▁[ ▁i ▁] ▁- ▁' ▁A ▁' ▁<= ▁b ▁- ▁11 ▁) ▁hash ▁[ ▁n ▁[ ▁i ▁] ▁- ▁' ▁A ▁' ▁+ ▁10 ▁] ▁= ▁true ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁b ▁; ▁i ▁++ ▁) ▁if ▁( ▁hash ▁[ ▁i ▁] ▁== ▁false ▁) ▁return ▁false ▁; ▁return ▁true ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁b ▁= ▁13 ▁; ▁char ▁n ▁[ ▁] ▁= ▁"12 98 4 50 376 ABC ▁" ▁; ▁( ▁check P and ig ital ▁( ▁b ▁, ▁n ▁) ▁) ▁? ▁( ▁c out ▁<< ▁" ▁Yes ▁" ▁<< ▁end l ▁) ▁: ▁( ▁c out ▁<< ▁" ▁No ▁" ▁<< ▁end l ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁numberOf 2 sin Range ▁( ▁int ▁n ▁) ▁{ ▁string ▁s ▁= ▁" ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁s ▁+= ▁to _ string ▁( ▁i ▁) ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁[ ▁i ▁] ▁== ▁'2' ▁) ▁{ ▁count ▁++ ▁; ▁} ▁} ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁30 ▁; ▁c out ▁<< ▁numberOf 2 sin Range ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁power ▁( ▁int ▁num ▁, ▁unsigned ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁0 ▁) ▁return ▁1 ▁; ▁else ▁if ▁( ▁n ▁% ▁2 ▁== ▁0 ▁) ▁return ▁power ▁( ▁num ▁, ▁n ▁/ ▁2 ▁) ▁* ▁power ▁( ▁num ▁, ▁n ▁/ ▁2 ▁) ▁; ▁else ▁return ▁num ▁* ▁power ▁( ▁num ▁, ▁n ▁/ ▁2 ▁) ▁* ▁power ▁( ▁num ▁, ▁n ▁/ ▁2 ▁) ▁; ▁} ▁int ▁check Recursive ▁( ▁int ▁x ▁, ▁int ▁n ▁, ▁int ▁curr _ num ▁= ▁1 ▁, ▁int ▁curr _ sum ▁= ▁0 ▁) ▁{ ▁int ▁results ▁= ▁0 ▁; ▁int ▁p ▁= ▁power ▁( ▁curr _ num ▁, ▁n ▁) ▁; ▁while ▁( ▁p ▁+ ▁curr _ sum ▁< ▁x ▁) ▁{ ▁results ▁+= ▁check Recursive ▁( ▁x ▁, ▁n ▁, ▁curr _ num ▁+ ▁1 ▁, ▁p ▁+ ▁curr _ sum ▁) ▁; ▁curr _ num ▁++ ▁; ▁p ▁= ▁power ▁( ▁curr _ num ▁, ▁n ▁) ▁; ▁} ▁if ▁( ▁p ▁+ ▁curr _ sum ▁== ▁x ▁) ▁results ▁++ ▁; ▁return ▁results ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁x ▁= ▁10 ▁, ▁n ▁= ▁2 ▁; ▁c out ▁<< ▁check Recursive ▁( ▁x ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁gcd ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁if ▁( ▁a ▁== ▁0 ▁) ▁return ▁b ▁; ▁return ▁gcd ▁( ▁b ▁% ▁a ▁, ▁a ▁) ▁; ▁} ▁int ▁print Gener ators ▁( ▁unsigned ▁int ▁n ▁) ▁{ ▁c out ▁<< ▁"1 ▁" ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁gcd ▁( ▁i ▁, ▁n ▁) ▁== ▁1 ▁) ▁c out ▁<< ▁i ▁<< ▁" ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁10 ▁; ▁print Gener ators ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁sum Div is ors Of Div is ors ▁( ▁int ▁n ▁) ▁{ ▁map ▁< ▁int ▁, ▁int ▁> ▁mp ▁; ▁for ▁( ▁int ▁j ▁= ▁2 ▁; ▁j ▁<= ▁sqrt ▁( ▁n ▁) ▁; ▁j ▁++ ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁while ▁( ▁n ▁% ▁j ▁== ▁0 ▁) ▁{ ▁n ▁/= ▁j ▁; ▁count ▁++ ▁; ▁} ▁if ▁( ▁count ▁) ▁mp ▁[ ▁j ▁] ▁= ▁count ▁; ▁} ▁if ▁( ▁n ▁!= ▁1 ▁) ▁mp ▁[ ▁n ▁] ▁= ▁1 ▁; ▁int ▁ans ▁= ▁1 ▁; ▁for ▁( ▁auto ▁it ▁: ▁mp ▁) ▁{ ▁int ▁pw ▁= ▁1 ▁; ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁it ▁. ▁second ▁+ ▁1 ▁; ▁i ▁>= ▁1 ▁; ▁i ▁-- ▁) ▁{ ▁sum ▁+= ▁( ▁i ▁* ▁pw ▁) ▁; ▁pw ▁*= ▁it ▁. ▁first ▁; ▁} ▁ans ▁*= ▁sum ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁10 ▁; ▁c out ▁<< ▁sum Div is ors Of Div is ors ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Sum ▁( ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁ans ▁+= ▁( ▁i ▁% ▁K ▁) ▁; ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁10 ▁, ▁K ▁= ▁2 ▁; ▁c out ▁<< ▁find Sum ▁( ▁N ▁, ▁K ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁pow ▁( ▁int ▁base ▁, ▁int ▁exponent ▁, ▁int ▁modulus ▁) ▁{ ▁int ▁result ▁= ▁1 ▁; ▁base ▁= ▁base ▁% ▁modulus ▁; ▁while ▁( ▁exponent ▁> ▁0 ▁) ▁{ ▁if ▁( ▁exponent ▁% ▁2 ▁== ▁1 ▁) ▁result ▁= ▁( ▁result ▁* ▁base ▁) ▁% ▁modulus ▁; ▁exponent ▁= ▁exponent ▁>> ▁1 ▁; ▁base ▁= ▁( ▁base ▁* ▁base ▁) ▁% ▁modulus ▁; ▁} ▁return ▁result ▁; ▁} ▁int ▁gcd ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁if ▁( ▁b ▁== ▁0 ▁) ▁return ▁a ▁; ▁else ▁return ▁gcd ▁( ▁b ▁, ▁a ▁% ▁b ▁) ▁; ▁} ▁int ▁order ▁( ▁int ▁p ▁, ▁int ▁b ▁) ▁{ ▁if ▁( ▁gcd ▁( ▁p ▁, ▁b ▁) ▁!= ▁1 ▁) ▁{ ▁printf ▁( ▁" ▁p ▁and ▁b ▁are ▁not ▁co ▁- ▁prime ▁. ▁STRNEWLINE ▁" ▁) ▁; ▁return ▁-1 ▁; ▁} ▁int ▁k ▁= ▁3 ▁; ▁while ▁( ▁1 ▁) ▁{ ▁if ▁( ▁pow ▁( ▁b ▁, ▁k ▁, ▁p ▁) ▁== ▁1 ▁) ▁return ▁k ▁; ▁k ▁++ ▁; ▁} ▁} ▁int ▁convert x 2 e ▁( ▁int ▁x ▁, ▁int ▁& ▁e ▁) ▁{ ▁e ▁= ▁0 ▁; ▁while ▁( ▁x ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁x ▁/= ▁2 ▁; ▁e ▁++ ▁; ▁} ▁return ▁x ▁; ▁} ▁int ▁ST on elli ▁( ▁int ▁n ▁, ▁int ▁p ▁) ▁{ ▁if ▁( ▁gcd ▁( ▁n ▁, ▁p ▁) ▁!= ▁1 ▁) ▁{ ▁printf ▁( ▁" ▁a ▁and ▁p ▁are ▁not ▁cop r ime ▁STRNEWLINE ▁" ▁) ▁; ▁return ▁-1 ▁; ▁} ▁if ▁( ▁pow ▁( ▁n ▁, ▁( ▁p ▁- ▁1 ▁) ▁/ ▁2 ▁, ▁p ▁) ▁== ▁( ▁p ▁- ▁1 ▁) ▁) ▁{ ▁printf ▁( ▁" ▁no ▁sqrt ▁possible ▁STRNEWLINE ▁" ▁) ▁; ▁return ▁-1 ▁; ▁} ▁int ▁s ▁, ▁e ▁; ▁s ▁= ▁convert x 2 e ▁( ▁p ▁- ▁1 ▁, ▁e ▁) ▁; ▁int ▁q ▁; ▁for ▁( ▁q ▁= ▁2 ▁; ▁; ▁q ▁++ ▁) ▁{ ▁if ▁( ▁pow ▁( ▁q ▁, ▁( ▁p ▁- ▁1 ▁) ▁/ ▁2 ▁, ▁p ▁) ▁== ▁( ▁p ▁- ▁1 ▁) ▁) ▁break ▁; ▁} ▁int ▁x ▁= ▁pow ▁( ▁n ▁, ▁( ▁s ▁+ ▁1 ▁) ▁/ ▁2 ▁, ▁p ▁) ▁; ▁int ▁b ▁= ▁pow ▁( ▁n ▁, ▁s ▁, ▁p ▁) ▁; ▁int ▁g ▁= ▁pow ▁( ▁q ▁, ▁s ▁, ▁p ▁) ▁; ▁int ▁r ▁= ▁e ▁; ▁while ▁( ▁1 ▁) ▁{ ▁int ▁m ▁; ▁for ▁( ▁m ▁= ▁0 ▁; ▁m ▁< ▁r ▁; ▁m ▁++ ▁) ▁{ ▁if ▁( ▁order ▁( ▁p ▁, ▁b ▁) ▁== ▁-1 ▁) ▁return ▁-1 ▁; ▁if ▁( ▁order ▁( ▁p ▁, ▁b ▁) ▁== ▁pow ▁( ▁2 ▁, ▁m ▁) ▁) ▁break ▁; ▁} ▁if ▁( ▁m ▁== ▁0 ▁) ▁return ▁x ▁; ▁x ▁= ▁( ▁x ▁* ▁pow ▁( ▁g ▁, ▁pow ▁( ▁2 ▁, ▁r ▁- ▁m ▁- ▁1 ▁) ▁, ▁p ▁) ▁) ▁% ▁p ▁; ▁g ▁= ▁pow ▁( ▁g ▁, ▁pow ▁( ▁2 ▁, ▁r ▁- ▁m ▁) ▁, ▁p ▁) ▁; ▁b ▁= ▁( ▁b ▁* ▁g ▁) ▁% ▁p ▁; ▁if ▁( ▁b ▁== ▁1 ▁) ▁return ▁x ▁; ▁r ▁= ▁m ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁2 ▁; ▁int ▁p ▁= ▁11 3 ▁; ▁int ▁x ▁= ▁ST on elli ▁( ▁n ▁, ▁p ▁) ▁; ▁if ▁( ▁x ▁== ▁-1 ▁) ▁printf ▁( ▁" ▁Mod ular ▁square ▁root ▁is ▁not ▁exist ▁STRNEWLINE ▁" ▁) ▁; ▁else ▁printf ▁( ▁" ▁Mod ular ▁square ▁root ▁of ▁% ▁d ▁and ▁% ▁d ▁is ▁% ▁d ▁STRNEWLINE ▁" ▁, ▁n ▁, ▁p ▁, ▁x ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find Roots ▁( ▁int ▁a ▁, ▁int ▁b ▁, ▁int ▁c ▁) ▁{ ▁if ▁( ▁a ▁== ▁0 ▁) ▁{ ▁c out ▁<< ▁" ▁Invalid ▁" ▁; ▁return ▁; ▁} ▁int ▁d ▁= ▁b ▁* ▁b ▁- ▁4 ▁* ▁a ▁* ▁c ▁; ▁double ▁sqrt _ val ▁= ▁sqrt ▁( ▁abs ▁( ▁d ▁) ▁) ▁; ▁if ▁( ▁d ▁> ▁0 ▁) ▁{ ▁c out ▁<< ▁" ▁Root s ▁are ▁real ▁and ▁different ▁STRNEWLINE ▁" ▁; ▁c out ▁<< ▁( ▁double ▁) ▁( ▁- ▁b ▁+ ▁sqrt _ val ▁) ▁/ ▁( ▁2 ▁* ▁a ▁) ▁<< ▁" ▁STRNEWLINE ▁" ▁<< ▁( ▁double ▁) ▁( ▁- ▁b ▁- ▁sqrt _ val ▁) ▁/ ▁( ▁2 ▁* ▁a ▁) ▁; ▁} ▁else ▁if ▁( ▁d ▁== ▁0 ▁) ▁{ ▁c out ▁<< ▁" ▁Root s ▁are ▁real ▁and ▁same ▁STRNEWLINE ▁" ▁; ▁c out ▁<< ▁- ▁( ▁double ▁) ▁b ▁/ ▁( ▁2 ▁* ▁a ▁) ▁; ▁} ▁{ ▁c out ▁<< ▁" ▁Root s ▁are ▁complex ▁STRNEWLINE ▁" ▁; ▁c out ▁<< ▁- ▁( ▁double ▁) ▁b ▁/ ▁( ▁2 ▁* ▁a ▁) ▁<< ▁" ▁+ ▁i ▁" ▁<< ▁sqrt _ val ▁<< ▁" ▁STRNEWLINE ▁" ▁<< ▁- ▁( ▁double ▁) ▁b ▁/ ▁( ▁2 ▁* ▁a ▁) ▁<< ▁" ▁- ▁i ▁" ▁<< ▁sqrt _ val ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁= ▁1 ▁, ▁b ▁= ▁- 7 ▁, ▁c ▁= ▁12 ▁; ▁find Roots ▁( ▁a ▁, ▁b ▁, ▁c ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print Div is ors ▁( ▁int ▁n ▁) ▁{ ▁vector ▁< ▁int ▁> ▁v ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁sqrt ▁( ▁n ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁{ ▁if ▁( ▁n ▁/ ▁i ▁== ▁i ▁) ▁printf ▁( ▁" ▁% ▁d ▁" ▁, ▁i ▁) ▁; ▁else ▁{ ▁printf ▁( ▁" ▁% ▁d ▁" ▁, ▁i ▁) ▁; ▁v ▁. ▁push _ back ▁( ▁n ▁/ ▁i ▁) ▁; ▁} ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁v ▁. ▁size ▁( ▁) ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁printf ▁( ▁" ▁% ▁d ▁" ▁, ▁v ▁[ ▁i ▁] ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁printf ▁( ▁" ▁The ▁div is ors ▁of ▁100 ▁are ▁: ▁n ▁" ▁) ▁; ▁print Div is ors ▁( ▁100 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print Div is ors ▁( ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁c out ▁<< ▁" ▁" ▁<< ▁i ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁c out ▁<< ▁" ▁The ▁div is ors ▁of ▁100 ▁are ▁: ▁STRNEWLINE ▁" ▁; ▁print Div is ors ▁( ▁100 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁# include ▁< math . h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print Div is ors ▁( ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁sqrt ▁( ▁n ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁{ ▁if ▁( ▁n ▁/ ▁i ▁== ▁i ▁) ▁c out ▁<< ▁" ▁" ▁<< ▁i ▁; ▁c out ▁<< ▁" ▁" ▁<< ▁i ▁<< ▁" ▁" ▁<< ▁n ▁/ ▁i ▁; ▁} ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁c out ▁<< ▁" ▁The ▁div is ors ▁of ▁100 ▁are ▁: ▁STRNEWLINE ▁" ▁; ▁print Div is ors ▁( ▁100 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁series Sum ▁( ▁int ▁calculated ▁, ▁int ▁current ▁, ▁int ▁N ▁) ▁{ ▁int ▁i ▁, ▁cur ▁= ▁1 ▁; ▁if ▁( ▁current ▁== ▁N ▁+ ▁1 ▁) ▁return ▁0 ▁; ▁for ▁( ▁i ▁= ▁calculated ▁; ▁i ▁< ▁calculated ▁+ ▁current ▁; ▁i ▁++ ▁) ▁cur ▁*= ▁i ▁; ▁return ▁cur ▁+ ▁series Sum ▁( ▁i ▁, ▁current ▁+ ▁1 ▁, ▁N ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁5 ▁; ▁c out ▁<< ▁series Sum ▁( ▁1 ▁, ▁1 ▁, ▁N ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁n Cr Mod p DP ▁( ▁int ▁n ▁, ▁int ▁r ▁, ▁int ▁p ▁) ▁{ ▁int ▁C ▁[ ▁r ▁+ ▁1 ▁] ▁; ▁mem set ▁( ▁C ▁, ▁0 ▁, ▁sizeof ▁( ▁C ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁min ▁( ▁i ▁, ▁r ▁) ▁; ▁j ▁> ▁0 ▁; ▁j ▁-- ▁) ▁C ▁[ ▁j ▁] ▁= ▁( ▁C ▁[ ▁j ▁] ▁+ ▁C ▁[ ▁j ▁- ▁1 ▁] ▁) ▁% ▁p ▁; ▁} ▁return ▁C ▁[ ▁r ▁] ▁; ▁} ▁int ▁n Cr Mod p L uc as ▁( ▁int ▁n ▁, ▁int ▁r ▁, ▁int ▁p ▁) ▁{ ▁if ▁( ▁r ▁== ▁0 ▁) ▁return ▁1 ▁; ▁int ▁ni ▁= ▁n ▁% ▁p ▁, ▁ri ▁= ▁r ▁% ▁p ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁1000 ▁, ▁r ▁= ▁900 ▁, ▁p ▁= ▁13 ▁; ▁c out ▁<< ▁" ▁Value ▁of ▁n Cr ▁% ▁p ▁is ▁" ▁<< ▁n Cr Mod p L uc as ▁( ▁n ▁, ▁r ▁, ▁p ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁mod Inverse ▁( ▁int ▁a ▁, ▁int ▁m ▁) ▁{ ▁int ▁m 0 ▁= ▁m ▁; ▁int ▁y ▁= ▁0 ▁, ▁x ▁= ▁1 ▁; ▁if ▁( ▁m ▁== ▁1 ▁) ▁return ▁0 ▁; ▁while ▁( ▁a ▁> ▁1 ▁) ▁{ ▁int ▁q ▁= ▁a ▁/ ▁m ▁; ▁int ▁t ▁= ▁m ▁; ▁m ▁= ▁a ▁% ▁m ▁, ▁a ▁= ▁t ▁; ▁t ▁= ▁y ▁; ▁y ▁= ▁x ▁- ▁q ▁* ▁y ▁; ▁x ▁= ▁t ▁; ▁} ▁if ▁( ▁x ▁< ▁0 ▁) ▁x ▁+= ▁m 0 ▁; ▁return ▁x ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁= ▁3 ▁, ▁m ▁= ▁11 ▁; ▁c out ▁<< ▁" ▁Mod ular ▁multip lic ative ▁inverse ▁is ▁" ▁<< ▁mod Inverse ▁( ▁a ▁, ▁m ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁gcd ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁if ▁( ▁a ▁== ▁0 ▁) ▁return ▁b ▁; ▁return ▁gcd ▁( ▁b ▁% ▁a ▁, ▁a ▁) ▁; ▁} ▁int ▁phi ▁( ▁unsigned ▁int ▁n ▁) ▁{ ▁unsigned ▁int ▁result ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁gcd ▁( ▁i ▁, ▁n ▁) ▁== ▁1 ▁) ▁result ▁++ ▁; ▁return ▁result ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁; ▁for ▁( ▁n ▁= ▁1 ▁; ▁n ▁<= ▁10 ▁; ▁n ▁++ ▁) ▁c out ▁<< ▁" ▁phi ▁( ▁" ▁<< ▁n ▁<< ▁" ▁) ▁= ▁" ▁<< ▁phi ▁( ▁n ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print F ib onacci Numbers ▁( ▁int ▁n ▁) ▁{ ▁int ▁f 1 ▁= ▁0 ▁, ▁f 2 ▁= ▁1 ▁, ▁i ▁; ▁if ▁( ▁n ▁< ▁1 ▁) ▁return ▁; ▁c out ▁<< ▁f 1 ▁<< ▁" ▁" ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁c out ▁<< ▁f 2 ▁<< ▁" ▁" ▁; ▁int ▁next ▁= ▁f 1 ▁+ ▁f 2 ▁; ▁f 1 ▁= ▁f 2 ▁; ▁f 2 ▁= ▁next ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁print F ib onacci Numbers ▁( ▁7 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁long ▁long ▁gcd ▁( ▁long ▁long ▁int ▁a ▁, ▁long ▁long ▁int ▁b ▁) ▁{ ▁if ▁( ▁b ▁== ▁0 ▁) ▁return ▁a ▁; ▁return ▁gcd ▁( ▁b ▁, ▁a ▁% ▁b ▁) ▁; ▁} ▁long ▁long ▁l cm ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁return ▁( ▁a ▁/ ▁gcd ▁( ▁a ▁, ▁b ▁) ▁) ▁* ▁b ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁= ▁15 ▁, ▁b ▁= ▁20 ▁; ▁c out ▁<< ▁" ▁L CM ▁of ▁" ▁<< ▁a ▁<< ▁" ▁and ▁" ▁<< ▁b ▁<< ▁" ▁is ▁" ▁<< ▁l cm ▁( ▁a ▁, ▁b ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# ▁define ▁MAX ▁11 ▁NEW _ LINE ▁bool ▁is Multiple of 5 ▁( ▁int ▁n ▁) ▁{ ▁char ▁str ▁[ ▁MAX ▁] ▁; ▁int ▁len ▁= ▁str len ▁( ▁str ▁) ▁; ▁if ▁( ▁str ▁[ ▁len ▁- ▁1 ▁] ▁== ▁'5' ▁str ▁[ ▁len ▁- ▁1 ▁] ▁== ▁'0' ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁19 ▁; ▁if ▁( ▁is Multiple of 5 ▁( ▁n ▁) ▁== ▁true ▁) ▁c out ▁<< ▁n ▁<< ▁" ▁is ▁multiple ▁of ▁5" ▁<< ▁end l ▁; ▁else ▁c out ▁<< ▁n ▁<< ▁" ▁is ▁not ▁multiple ▁of ▁5" ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁re vers Digits ▁( ▁int ▁num ▁) ▁{ ▁static ▁int ▁rev _ num ▁= ▁0 ▁; ▁static ▁int ▁base _ pos ▁= ▁1 ▁; ▁if ▁( ▁num ▁> ▁0 ▁) ▁{ ▁re vers Digits ▁( ▁num ▁/ ▁10 ▁) ▁; ▁rev _ num ▁+= ▁( ▁num ▁% ▁10 ▁) ▁* ▁base _ pos ▁; ▁base _ pos ▁*= ▁10 ▁; ▁} ▁return ▁rev _ num ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁num ▁= ▁456 2 ▁; ▁c out ▁<< ▁" ▁Reverse ▁of ▁no ▁. ▁is ▁" ▁<< ▁re vers Digits ▁( ▁num ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁int ▁M ▁= ▁3 ▁; ▁const ▁int ▁N ▁= ▁3 ▁; ▁int ▁find X OR ▁( ▁int ▁X ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁; ▁while ▁( ▁X ▁) ▁{ ▁ans ▁^= ▁( ▁X ▁% ▁10 ▁) ▁; ▁X ▁/= ▁10 ▁; ▁} ▁return ▁ans ▁; ▁} ▁void ▁print X OR matrix ▁( ▁int ▁arr ▁[ ▁M ▁] ▁[ ▁N ▁] ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁M ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁c out ▁<< ▁arr ▁[ ▁i ▁] ▁[ ▁j ▁] ▁<< ▁" ▁" ▁; ▁} ▁c out ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁} ▁} ▁void ▁convert X OR ▁( ▁int ▁arr ▁[ ▁M ▁] ▁[ ▁N ▁] ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁M ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁int ▁X ▁= ▁arr ▁[ ▁i ▁] ▁[ ▁j ▁] ▁; ▁int ▁temp ▁= ▁find X OR ▁( ▁X ▁) ▁; ▁arr ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁temp ▁; ▁} ▁} ▁print X OR matrix ▁( ▁arr ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁[ ▁3 ▁] ▁= ▁{ ▁{ ▁27 ▁, ▁17 3 ▁, ▁5 ▁} ▁, ▁{ ▁21 ▁, ▁6 ▁, ▁6 24 ▁} ▁, ▁{ ▁5 ▁, ▁32 1 ▁, ▁49 ▁} ▁} ▁; ▁convert X OR ▁( ▁arr ▁) ▁; ▁return ▁0 ▁; ▁}
▁int ▁set Bit ▁( ▁int ▁num ▁, ▁int ▁i ▁) ▁{ ▁return ▁num ▁| ▁( ▁1 ▁<< ▁i ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print OR Sum forEach Element ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁int ▁req _ sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁req _ sum ▁+= ▁( ▁arr ▁[ ▁i ▁] ▁arr ▁[ ▁j ▁] ▁) ▁; ▁} ▁c out ▁<< ▁req _ sum ▁<< ▁" ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁print OR Sum forEach Element ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find L argest Number ▁( ▁vector ▁< ▁int ▁> ▁& ▁arr ▁) ▁{ ▁for ▁( ▁auto ▁n ▁: ▁arr ▁) ▁{ ▁n ▁&= ▁0 xFFFF ▁; ▁if ▁( ▁n ▁<= ▁arr ▁. ▁size ▁( ▁) ▁) ▁{ ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁+= ▁0 x 10000 ▁; ▁} ▁} ▁for ▁( ▁auto ▁i ▁= ▁arr ▁. ▁size ▁( ▁) ▁; ▁i ▁> ▁0 ▁; ▁-- ▁i ▁) ▁{ ▁if ▁( ▁( ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁>> ▁16 ▁) ▁== ▁i ▁) ▁return ▁i ▁; ▁} ▁return ▁-1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁int ▁> ▁arr ▁= ▁{ ▁3 ▁, ▁2 ▁, ▁5 ▁, ▁5 ▁, ▁2 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁c out ▁<< ▁find L argest Number ▁( ▁arr ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁Recursive Function ▁( ▁vector ▁< ▁int ▁> ▁ref ▁, ▁int ▁bit ▁) ▁{ ▁if ▁( ▁ref ▁. ▁size ▁( ▁) ▁== ▁0 ▁bit ▁< ▁0 ▁) ▁return ▁0 ▁; ▁vector ▁< ▁int ▁> ▁curr _ on ▁, ▁curr _ off ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁ref ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁( ▁ref ▁[ ▁i ▁] ▁>> ▁bit ▁) ▁& ▁1 ▁) ▁== ▁0 ▁) ▁curr _ off ▁. ▁push _ back ▁( ▁ref ▁[ ▁i ▁] ▁) ▁; ▁else ▁curr _ on ▁. ▁push _ back ▁( ▁ref ▁[ ▁i ▁] ▁) ▁; ▁} ▁if ▁( ▁curr _ off ▁. ▁size ▁( ▁) ▁== ▁0 ▁) ▁return ▁Recursive Function ▁( ▁curr _ on ▁, ▁bit ▁- ▁1 ▁) ▁; ▁if ▁( ▁curr _ on ▁. ▁size ▁( ▁) ▁== ▁0 ▁) ▁return ▁Recursive Function ▁( ▁curr _ off ▁, ▁bit ▁- ▁1 ▁) ▁; ▁return ▁min ▁( ▁Recursive Function ▁( ▁curr _ off ▁, ▁bit ▁- ▁1 ▁) ▁, ▁Recursive Function ▁( ▁curr _ on ▁, ▁bit ▁- ▁1 ▁) ▁) ▁+ ▁( ▁1 ▁<< ▁bit ▁) ▁; ▁} ▁void ▁Print Minimum ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁vector ▁< ▁int ▁> ▁v ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁v ▁. ▁push _ back ▁( ▁a ▁[ ▁i ▁] ▁) ▁; ▁c out ▁<< ▁Recursive Function ▁( ▁v ▁, ▁30 ▁) ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁2 ▁, ▁1 ▁} ▁; ▁int ▁size ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁Print Minimum ▁( ▁arr ▁, ▁size ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁MAX ▁100000 5 ▁NEW _ LINE ▁void ▁S ieve Of E rat ost hen es ▁( ▁vector ▁< ▁bool ▁> ▁& ▁prime ▁) ▁{ ▁prime ▁[ ▁1 ▁] ▁= ▁false ▁; ▁prime ▁[ ▁0 ▁] ▁= ▁false ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁* ▁p ▁< ▁MAX ▁; ▁p ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁p ▁] ▁== ▁true ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁p ▁* ▁2 ▁; ▁i ▁< ▁MAX ▁; ▁i ▁+= ▁p ▁) ▁prime ▁[ ▁i ▁] ▁= ▁false ▁; ▁} ▁} ▁} ▁void ▁prime _ xor ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁vector ▁< ▁bool ▁> ▁prime ▁( ▁MAX ▁, ▁true ▁) ▁; ▁S ieve Of E rat ost hen es ▁( ▁prime ▁) ▁; ▁long ▁long ▁int ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁arr ▁[ ▁i ▁] ▁] ▁) ▁{ ▁if ▁( ▁( ▁i ▁+ ▁1 ▁) ▁% ▁k ▁== ▁0 ▁) ▁{ ▁ans ▁^= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁} ▁} ▁c out ▁<< ▁ans ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁5 ▁, ▁7 ▁, ▁11 ▁, ▁8 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁K ▁= ▁2 ▁; ▁prime _ xor ▁( ▁arr ▁, ▁n ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is Power Of Two ▁( ▁int ▁x ▁) ▁{ ▁if ▁( ▁x ▁== ▁0 ▁) ▁return ▁false ▁; ▁if ▁( ▁! ▁( ▁x ▁& ▁( ▁x ▁- ▁1 ▁) ▁) ▁) ▁return ▁true ▁; ▁else ▁return ▁false ▁; ▁} ▁int ▁count Num ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁is Power Of Two ▁( ▁a ▁[ ▁i ▁] ▁) ▁|| ▁is Power Of Two ▁( ▁a ▁[ ▁i ▁] ▁+ ▁1 ▁) ▁) ▁count ▁++ ▁; ▁} ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁6 ▁, ▁9 ▁, ▁3 ▁, ▁1 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁count Num ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁xor Given Set Bits ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁vector ▁< ▁int ▁> ▁v ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁__ builtin _ pop count ▁( ▁arr ▁[ ▁i ▁] ▁) ▁== ▁k ▁) ▁{ ▁v ▁. ▁push _ back ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁} ▁int ▁result ▁= ▁v ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁v ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁result ▁= ▁result ▁^ ▁v ▁[ ▁i ▁] ▁; ▁return ▁result ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁13 ▁, ▁1 ▁, ▁19 ▁, ▁7 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁k ▁= ▁3 ▁; ▁c out ▁<< ▁xor Given Set Bits ▁( ▁arr ▁, ▁n ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Zeros ▁( ▁int ▁x ▁) ▁{ ▁unsigned ▁y ▁; ▁int ▁n ▁= ▁32 ▁; ▁y ▁= ▁x ▁>> ▁16 ▁; ▁if ▁( ▁y ▁!= ▁0 ▁) ▁{ ▁n ▁= ▁n ▁- ▁16 ▁; ▁x ▁= ▁y ▁; ▁} ▁y ▁= ▁x ▁>> ▁8 ▁; ▁if ▁( ▁y ▁!= ▁0 ▁) ▁{ ▁n ▁= ▁n ▁- ▁8 ▁; ▁x ▁= ▁y ▁; ▁} ▁y ▁= ▁x ▁>> ▁4 ▁; ▁if ▁( ▁y ▁!= ▁0 ▁) ▁{ ▁n ▁= ▁n ▁- ▁4 ▁; ▁x ▁= ▁y ▁; ▁} ▁y ▁= ▁x ▁>> ▁2 ▁; ▁if ▁( ▁y ▁!= ▁0 ▁) ▁{ ▁n ▁= ▁n ▁- ▁2 ▁; ▁x ▁= ▁y ▁; ▁} ▁y ▁= ▁x ▁>> ▁1 ▁; ▁if ▁( ▁y ▁!= ▁0 ▁) ▁return ▁n ▁- ▁2 ▁; ▁return ▁n ▁- ▁x ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁x ▁= ▁101 ▁; ▁c out ▁<< ▁count Zeros ▁( ▁x ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Even Pair ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁if ▁( ▁! ▁( ▁A ▁[ ▁i ▁] ▁& ▁1 ▁) ▁) ▁count ▁++ ▁; ▁return ▁count ▁* ▁( ▁count ▁- ▁1 ▁) ▁/ ▁2 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁6 ▁, ▁2 ▁, ▁8 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁A ▁) ▁/ ▁sizeof ▁( ▁A ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁find Even Pair ▁( ▁A ▁, ▁N ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁N ▁1000 ▁NEW _ LINE ▁int ▁last Element ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁steps ▁= ▁1 ▁; ▁vector ▁< ▁int ▁> ▁v ▁[ ▁N ▁] ▁; ▁if ▁( ▁n ▁== ▁1 ▁) ▁return ▁a ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁+= ▁2 ▁) ▁v ▁[ ▁steps ▁] ▁. ▁push _ back ▁( ▁a ▁[ ▁i ▁] ▁a ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁; ▁while ▁( ▁v ▁[ ▁steps ▁] ▁. ▁size ▁( ▁) ▁> ▁1 ▁) ▁{ ▁steps ▁+= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁v ▁[ ▁steps ▁- ▁1 ▁] ▁. ▁size ▁( ▁) ▁; ▁i ▁+= ▁2 ▁) ▁{ ▁if ▁( ▁steps ▁& ▁1 ▁) ▁v ▁[ ▁steps ▁] ▁. ▁push _ back ▁( ▁v ▁[ ▁steps ▁- ▁1 ▁] ▁[ ▁i ▁] ▁v ▁[ ▁steps ▁- ▁1 ▁] ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁; ▁v ▁[ ▁steps ▁] ▁. ▁push _ back ▁( ▁v ▁[ ▁steps ▁- ▁1 ▁] ▁[ ▁i ▁] ▁^ ▁v ▁[ ▁steps ▁- ▁1 ▁] ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁; ▁} ▁} ▁return ▁v ▁[ ▁steps ▁] ▁[ ▁0 ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁int ▁index ▁= ▁0 ▁; ▁int ▁value ▁= ▁2 ▁; ▁a ▁[ ▁0 ▁] ▁= ▁2 ▁; ▁c out ▁<< ▁last Element ▁( ▁a ▁, ▁n ▁) ▁<< ▁end l ▁; ▁index ▁= ▁3 ▁; ▁value ▁= ▁5 ▁; ▁a ▁[ ▁index ▁] ▁= ▁value ▁; ▁c out ▁<< ▁last Element ▁( ▁a ▁, ▁n ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁x n or ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁if ▁( ▁a ▁< ▁b ▁) ▁swap ▁( ▁a ▁, ▁b ▁) ▁; ▁if ▁( ▁a ▁== ▁0 ▁&& ▁b ▁== ▁0 ▁) ▁return ▁1 ▁; ▁int ▁a _ rem ▁= ▁0 ▁; ▁int ▁b _ rem ▁= ▁0 ▁; ▁int ▁count ▁= ▁0 ▁; ▁int ▁x n or num ▁= ▁0 ▁; ▁while ▁( ▁a ▁) ▁{ ▁a _ rem ▁= ▁a ▁& ▁1 ▁; ▁b _ rem ▁= ▁b ▁& ▁1 ▁; ▁if ▁( ▁a _ rem ▁== ▁b _ rem ▁) ▁x n or num ▁|= ▁( ▁1 ▁<< ▁count ▁) ▁; ▁count ▁++ ▁; ▁a ▁= ▁a ▁>> ▁1 ▁; ▁b ▁= ▁b ▁>> ▁1 ▁; ▁} ▁return ▁x n or num ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁= ▁10 ▁, ▁b ▁= ▁50 ▁; ▁c out ▁<< ▁x n or ▁( ▁a ▁, ▁b ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁divide ▁( ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁c out ▁<< ▁" ▁Rem ainder ▁= ▁" ▁<< ▁( ▁( ▁n ▁) ▁& ▁( ▁m ▁- ▁1 ▁) ▁) ▁; ▁c out ▁<< ▁" ▁Qu ot ient ▁= ▁" ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁43 ▁, ▁m ▁= ▁8 ▁; ▁divide ▁( ▁n ▁, ▁m ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁are All Bits Set ▁( ▁unsigned ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁0 ▁) ▁return ▁false ▁; ▁if ▁( ▁( ▁( ▁n ▁+ ▁1 ▁) ▁& ▁n ▁) ▁== ▁0 ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁bool ▁isOn es Com plement Of Other ▁( ▁unsigned ▁int ▁a ▁, ▁unsigned ▁int ▁b ▁) ▁{ ▁return ▁are All Bits Set ▁( ▁a ▁^ ▁b ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁unsigned ▁int ▁a ▁= ▁10 ▁, ▁b ▁= ▁5 ▁; ▁if ▁( ▁isOn es Com plement Of Other ▁( ▁a ▁, ▁b ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁# include ▁< cm ath > ▁NEW _ LINE ▁unsigned ▁count Bits ▁( ▁unsigned ▁int ▁number ▁) ▁{ ▁return ▁( ▁int ▁) ▁log 2 ▁( ▁number ▁) ▁+ ▁1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁unsigned ▁int ▁num ▁= ▁65 ▁; ▁std ▁:: ▁c out ▁<< ▁count Bits ▁( ▁num ▁) ▁<< ▁' ▁' ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁bit Extract ed ▁( ▁int ▁number ▁, ▁int ▁k ▁, ▁int ▁p ▁) ▁{ ▁return ▁( ▁( ▁( ▁1 ▁<< ▁k ▁) ▁- ▁1 ▁) ▁& ▁( ▁number ▁>> ▁( ▁p ▁- ▁1 ▁) ▁) ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁number ▁= ▁17 1 ▁, ▁k ▁= ▁5 ▁, ▁p ▁= ▁2 ▁; ▁c out ▁<< ▁" ▁The ▁extracted ▁number ▁is ▁" ▁<< ▁bit Extract ed ▁( ▁number ▁, ▁k ▁, ▁p ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁multiply ▁( ▁int ▁F ▁[ ▁2 ▁] ▁[ ▁2 ▁] ▁, ▁int ▁M ▁[ ▁2 ▁] ▁[ ▁2 ▁] ▁) ▁{ ▁int ▁x ▁= ▁F ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁* ▁M ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁+ ▁F ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁* ▁M ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁; ▁int ▁y ▁= ▁F ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁* ▁M ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁+ ▁F ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁* ▁M ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁; ▁int ▁z ▁= ▁F ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁* ▁M ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁+ ▁F ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁* ▁M ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁; ▁int ▁w ▁= ▁F ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁* ▁M ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁+ ▁F ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁* ▁M ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁; ▁F ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁= ▁x ▁; ▁F ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁= ▁y ▁; ▁F ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁= ▁z ▁; ▁F ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁= ▁w ▁; ▁} ▁void ▁power ▁( ▁int ▁F ▁[ ▁2 ▁] ▁[ ▁2 ▁] ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁0 ▁n ▁== ▁1 ▁) ▁return ▁; ▁int ▁M ▁[ ▁2 ▁] ▁[ ▁2 ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁0 ▁} ▁} ▁; ▁power ▁( ▁F ▁, ▁n ▁/ ▁2 ▁) ▁; ▁multiply ▁( ▁F ▁, ▁F ▁) ▁; ▁if ▁( ▁n ▁% ▁2 ▁!= ▁0 ▁) ▁multiply ▁( ▁F ▁, ▁M ▁) ▁; ▁} ▁int ▁count W ays ▁( ▁int ▁n ▁) ▁{ ▁int ▁F ▁[ ▁2 ▁] ▁[ ▁2 ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁0 ▁} ▁} ▁; ▁if ▁( ▁n ▁== ▁0 ▁) ▁return ▁0 ▁; ▁power ▁( ▁F ▁, ▁n ▁) ▁; ▁return ▁F ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁5 ▁; ▁c out ▁<< ▁count W ays ▁( ▁n ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count X OR ▁( ▁int ▁n ▁) ▁{ ▁int ▁count 0 ▁= ▁0 ▁, ▁count 1 ▁= ▁0 ▁; ▁while ▁( ▁n ▁) ▁{ ▁( ▁n ▁% ▁2 ▁== ▁0 ▁) ▁? ▁count 0 ▁++ ▁: ▁count 1 ▁++ ▁; ▁n ▁/= ▁2 ▁; ▁} ▁return ▁( ▁count 0 ▁^ ▁count 1 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁31 ▁; ▁c out ▁<< ▁count X OR ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Values ▁( ▁int ▁n ▁) ▁{ ▁int ▁count V ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁( ▁n ▁+ ▁i ▁) ▁== ▁( ▁n ▁^ ▁i ▁) ▁) ▁count V ▁++ ▁; ▁return ▁count V ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁12 ▁; ▁c out ▁<< ▁count Values ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁multiply By S even By E ight ▁( ▁int ▁n ▁) ▁{ ▁return ▁( ▁n ▁- ▁( ▁n ▁>> ▁3 ▁) ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁9 ▁; ▁c out ▁<< ▁multiply By S even By E ight ▁( ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁isP al indrome ▁( ▁string ▁S ▁, ▁int ▁i ▁, ▁int ▁j ▁) ▁{ ▁while ▁( ▁i ▁< ▁j ▁) ▁{ ▁if ▁( ▁S ▁[ ▁i ▁] ▁!= ▁S ▁[ ▁j ▁] ▁) ▁return ▁false ▁; ▁i ▁++ ▁; ▁j ▁-- ▁; ▁} ▁return ▁true ▁; ▁} ▁void ▁print Long est Pal indrome ▁( ▁string ▁S ▁, ▁int ▁N ▁) ▁{ ▁int ▁pal Length ▁[ ▁N ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁int ▁maxlength ▁= ▁1 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁i ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁S ▁[ ▁j ▁] ▁== ▁S ▁[ ▁i ▁] ▁) ▁{ ▁if ▁( ▁isP al indrome ▁( ▁S ▁, ▁j ▁, ▁i ▁) ▁) ▁{ ▁maxlength ▁= ▁i ▁- ▁j ▁+ ▁1 ▁; ▁break ▁; ▁} ▁} ▁} ▁for ▁( ▁int ▁j ▁= ▁N ▁- ▁1 ▁; ▁j ▁> ▁i ▁; ▁j ▁-- ▁) ▁{ ▁if ▁( ▁S ▁[ ▁j ▁] ▁== ▁S ▁[ ▁i ▁] ▁) ▁{ ▁if ▁( ▁isP al indrome ▁( ▁S ▁, ▁i ▁, ▁j ▁) ▁) ▁{ ▁maxlength ▁= ▁max ▁( ▁j ▁- ▁i ▁+ ▁1 ▁, ▁maxlength ▁) ▁; ▁break ▁; ▁} ▁} ▁} ▁pal Length ▁[ ▁i ▁] ▁= ▁maxlength ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁c out ▁<< ▁pal Length ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁S ▁= ▁" ▁b ab aba ▁" ▁; ▁int ▁N ▁= ▁S ▁. ▁length ▁( ▁) ▁; ▁print Long est Pal indrome ▁( ▁S ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁check Sorted ▁( ▁int ▁n ▁, ▁int ▁arr ▁[ ▁] ▁) ▁{ ▁int ▁b ▁[ ▁n ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁b ▁[ ▁i ▁] ▁= ▁arr ▁[ ▁i ▁] ▁; ▁sort ▁( ▁b ▁, ▁b ▁+ ▁n ▁) ▁; ▁int ▁ct ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁arr ▁[ ▁i ▁] ▁!= ▁b ▁[ ▁i ▁] ▁) ▁ct ▁++ ▁; ▁if ▁( ▁ct ▁== ▁0 ▁ct ▁== ▁2 ▁) ▁return ▁true ▁; ▁else ▁return ▁false ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁5 ▁, ▁3 ▁, ▁4 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁if ▁( ▁check Sorted ▁( ▁n ▁, ▁arr ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁min Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁) ▁{ ▁int ▁j ▁= ▁i ▁; ▁while ▁( ▁j ▁< ▁n ▁&& ▁arr ▁[ ▁j ▁] ▁<= ▁arr ▁[ ▁j ▁- ▁1 ▁] ▁) ▁{ ▁arr ▁[ ▁j ▁] ▁= ▁arr ▁[ ▁j ▁] ▁+ ▁1 ▁; ▁j ▁++ ▁; ▁} ▁} ▁sum ▁= ▁sum ▁+ ▁arr ▁[ ▁i ▁] ▁; ▁} ▁return ▁sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁2 ▁, ▁3 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁min Sum ▁( ▁arr ▁, ▁n ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁min Sum ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁arr ▁[ ▁0 ▁] ▁, ▁prev ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁<= ▁prev ▁) ▁{ ▁prev ▁= ▁prev ▁+ ▁1 ▁; ▁sum ▁= ▁sum ▁+ ▁prev ▁; ▁} ▁else ▁{ ▁sum ▁= ▁sum ▁+ ▁arr ▁[ ▁i ▁] ▁; ▁prev ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁} ▁return ▁sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁2 ▁, ▁3 ▁, ▁5 ▁, ▁6 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁min Sum ▁( ▁arr ▁, ▁n ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁valid Perm utations ▁( ▁string ▁str ▁) ▁{ ▁unordered _ map ▁< ▁char ▁, ▁int ▁> ▁m ▁; ▁int ▁count ▁= ▁str ▁. ▁length ▁( ▁) ▁, ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁str ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁m ▁[ ▁str ▁[ ▁i ▁] ▁] ▁++ ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁str ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁ans ▁+= ▁count ▁- ▁m ▁[ ▁str ▁[ ▁i ▁] ▁] ▁; ▁m ▁[ ▁str ▁[ ▁i ▁] ▁] ▁-- ▁; ▁count ▁-- ▁; ▁} ▁return ▁ans ▁+ ▁1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁sst t ▁" ▁; ▁c out ▁<< ▁valid Perm utations ▁( ▁str ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁if Possible ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁cp ▁[ ▁n ▁] ▁; ▁copy ▁( ▁arr ▁, ▁arr ▁+ ▁n ▁, ▁cp ▁) ▁; ▁sort ▁( ▁cp ▁, ▁cp ▁+ ▁n ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁! ▁( ▁arr ▁[ ▁i ▁] ▁== ▁cp ▁[ ▁i ▁] ▁) ▁&& ▁! ▁( ▁arr ▁[ ▁n ▁- ▁1 ▁- ▁i ▁] ▁== ▁cp ▁[ ▁i ▁] ▁) ▁) ▁return ▁false ▁; ▁} ▁return ▁true ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁7 ▁, ▁6 ▁, ▁4 ▁, ▁5 ▁, ▁3 ▁, ▁2 ▁, ▁8 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁if ▁( ▁if Possible ▁( ▁arr ▁, ▁n ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁int ▁M ▁= ▁20 ▁; ▁int ▁dp ▁[ ▁M ▁] ▁[ ▁16 5 ▁] ▁[ ▁M ▁] ▁[ ▁2 ▁] ▁; ▁int ▁n ▁, ▁m ▁; ▁int ▁count ▁( ▁int ▁pos ▁, ▁int ▁sum ▁, ▁int ▁rem ▁, ▁int ▁tight ▁, ▁int ▁non z ▁, ▁vector ▁< ▁int ▁> ▁num ▁) ▁{ ▁if ▁( ▁pos ▁== ▁num ▁. ▁size ▁( ▁) ▁) ▁{ ▁if ▁( ▁rem ▁== ▁0 ▁&& ▁sum ▁== ▁n ▁) ▁return ▁1 ▁; ▁return ▁0 ▁; ▁} ▁if ▁( ▁dp ▁[ ▁pos ▁] ▁[ ▁sum ▁] ▁[ ▁rem ▁] ▁[ ▁tight ▁] ▁!= ▁-1 ▁) ▁return ▁dp ▁[ ▁pos ▁] ▁[ ▁sum ▁] ▁[ ▁rem ▁] ▁[ ▁tight ▁] ▁; ▁int ▁ans ▁= ▁0 ▁; ▁int ▁limit ▁= ▁( ▁tight ▁? ▁9 ▁: ▁num ▁[ ▁pos ▁] ▁) ▁; ▁for ▁( ▁int ▁d ▁= ▁0 ▁; ▁d ▁<= ▁limit ▁; ▁d ▁++ ▁) ▁{ ▁if ▁( ▁d ▁== ▁0 ▁&& ▁non z ▁) ▁continue ▁; ▁int ▁curr Sum ▁= ▁sum ▁+ ▁d ▁; ▁int ▁curr Rem ▁= ▁( ▁rem ▁* ▁10 ▁+ ▁d ▁) ▁% ▁m ▁; ▁int ▁curr F ▁= ▁tight ▁|| ▁( ▁d ▁< ▁num ▁[ ▁pos ▁] ▁) ▁; ▁ans ▁+= ▁count ▁( ▁pos ▁+ ▁1 ▁, ▁curr Sum ▁, ▁curr Rem ▁, ▁curr F ▁, ▁non z ▁d ▁, ▁num ▁) ▁; ▁} ▁return ▁dp ▁[ ▁pos ▁] ▁[ ▁sum ▁] ▁[ ▁rem ▁] ▁[ ▁tight ▁] ▁= ▁ans ▁; ▁} ▁int ▁solve ▁( ▁int ▁x ▁) ▁{ ▁vector ▁< ▁int ▁> ▁num ▁; ▁while ▁( ▁x ▁) ▁{ ▁num ▁. ▁push _ back ▁( ▁x ▁% ▁10 ▁) ▁; ▁x ▁/= ▁10 ▁; ▁} ▁reverse ▁( ▁num ▁. ▁begin ▁( ▁) ▁, ▁num ▁. ▁end ▁( ▁) ▁) ▁; ▁mem set ▁( ▁dp ▁, ▁-1 ▁, ▁sizeof ▁( ▁dp ▁) ▁) ▁; ▁return ▁count ▁( ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁num ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁L ▁= ▁1 ▁, ▁R ▁= ▁100 ▁; ▁n ▁= ▁8 ▁, ▁m ▁= ▁2 ▁; ▁c out ▁<< ▁solve ▁( ▁R ▁) ▁- ▁solve ▁( ▁L ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁# include ▁< limits > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁maximum Sum Sub array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁min _ prefix _ sum ▁= ▁0 ▁; ▁int ▁res ▁= ▁numeric _ limits ▁< ▁int ▁> ▁:: ▁min ▁( ▁) ▁; ▁int ▁prefix _ sum ▁[ ▁n ▁] ▁; ▁prefix _ sum ▁[ ▁0 ▁] ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁prefix _ sum ▁[ ▁i ▁] ▁= ▁prefix _ sum ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁arr ▁[ ▁i ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁res ▁= ▁max ▁( ▁res ▁, ▁prefix _ sum ▁[ ▁i ▁] ▁- ▁min _ prefix _ sum ▁) ▁; ▁min _ prefix _ sum ▁= ▁min ▁( ▁min _ prefix _ sum ▁, ▁prefix _ sum ▁[ ▁i ▁] ▁) ▁; ▁} ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr 1 ▁[ ▁] ▁= ▁{ ▁-2 ▁, ▁-3 ▁, ▁4 ▁, ▁-1 ▁, ▁-2 ▁, ▁1 ▁, ▁5 ▁, ▁-3 ▁} ▁; ▁int ▁n 1 ▁= ▁sizeof ▁( ▁arr 1 ▁) ▁/ ▁sizeof ▁( ▁arr 1 ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁maximum Sum Sub array ▁( ▁arr 1 ▁, ▁n 1 ▁) ▁<< ▁end l ▁; ▁int ▁arr 2 ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁- 8 ▁, ▁9 ▁, ▁-4 ▁, ▁1 ▁, ▁- 8 ▁, ▁-1 ▁, ▁6 ▁} ▁; ▁int ▁n 2 ▁= ▁sizeof ▁( ▁arr 2 ▁) ▁/ ▁sizeof ▁( ▁arr 2 ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁maximum Sum Sub array ▁( ▁arr 2 ▁, ▁n 2 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Paths ▁( ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁int ▁dp ▁[ ▁n ▁+ ▁1 ▁] ▁[ ▁m ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁dp ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁m ▁; ▁i ▁++ ▁) ▁dp ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁<= ▁m ▁; ▁j ▁++ ▁) ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁+ ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁; ▁return ▁dp ▁[ ▁n ▁] ▁[ ▁m ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁3 ▁, ▁m ▁= ▁2 ▁; ▁c out ▁<< ▁" ▁Number ▁of ▁Paths ▁" ▁<< ▁count Paths ▁( ▁n ▁, ▁m ▁) ▁; ▁return ▁0 ▁; ▁}
▁int ▁dp ▁[ ▁MAX N ▁] ▁; ▁int ▁solve ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁< ▁0 ▁) ▁return ▁0 ▁; ▁if ▁( ▁n ▁== ▁0 ▁) ▁return ▁1 ▁; ▁if ▁( ▁dp ▁[ ▁n ▁] ▁!= ▁-1 ▁) ▁return ▁dp ▁[ ▁n ▁] ▁; ▁return ▁dp ▁[ ▁n ▁] ▁= ▁solve ▁( ▁n ▁- ▁1 ▁) ▁+ ▁solve ▁( ▁n ▁- ▁3 ▁) ▁+ ▁solve ▁( ▁n ▁- ▁5 ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁string ▁print Short est Super Seq ▁( ▁string ▁X ▁, ▁string ▁Y ▁) ▁{ ▁int ▁m ▁= ▁X ▁. ▁length ▁( ▁) ▁; ▁int ▁n ▁= ▁Y ▁. ▁length ▁( ▁) ▁; ▁int ▁dp ▁[ ▁m ▁+ ▁1 ▁] ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁m ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁<= ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁i ▁== ▁0 ▁) ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁j ▁; ▁else ▁if ▁( ▁j ▁== ▁0 ▁) ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁i ▁; ▁else ▁if ▁( ▁X ▁[ ▁i ▁- ▁1 ▁] ▁== ▁Y ▁[ ▁j ▁- ▁1 ▁] ▁) ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁1 ▁+ ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁- ▁1 ▁] ▁; ▁else ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁1 ▁+ ▁min ▁( ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁, ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁) ▁; ▁} ▁} ▁string ▁str ▁; ▁int ▁i ▁= ▁m ▁, ▁j ▁= ▁n ▁; ▁while ▁( ▁i ▁> ▁0 ▁&& ▁j ▁> ▁0 ▁) ▁{ ▁if ▁( ▁X ▁[ ▁i ▁- ▁1 ▁] ▁== ▁Y ▁[ ▁j ▁- ▁1 ▁] ▁) ▁{ ▁str ▁. ▁push _ back ▁( ▁X ▁[ ▁i ▁- ▁1 ▁] ▁) ▁; ▁i ▁-- ▁, ▁j ▁-- ▁; ▁} ▁else ▁if ▁( ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁> ▁dp ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁) ▁{ ▁str ▁. ▁push _ back ▁( ▁Y ▁[ ▁j ▁- ▁1 ▁] ▁) ▁; ▁j ▁-- ▁; ▁} ▁else ▁{ ▁str ▁. ▁push _ back ▁( ▁X ▁[ ▁i ▁- ▁1 ▁] ▁) ▁; ▁i ▁-- ▁; ▁} ▁} ▁while ▁( ▁i ▁> ▁0 ▁) ▁{ ▁str ▁. ▁push _ back ▁( ▁X ▁[ ▁i ▁- ▁1 ▁] ▁) ▁; ▁i ▁-- ▁; ▁} ▁while ▁( ▁j ▁> ▁0 ▁) ▁{ ▁str ▁. ▁push _ back ▁( ▁Y ▁[ ▁j ▁- ▁1 ▁] ▁) ▁; ▁j ▁-- ▁; ▁} ▁reverse ▁( ▁str ▁. ▁begin ▁( ▁) ▁, ▁str ▁. ▁end ▁( ▁) ▁) ▁; ▁return ▁str ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁X ▁= ▁" ▁A GG TAB ▁" ▁; ▁string ▁Y ▁= ▁" ▁G XT X AY B ▁" ▁; ▁c out ▁<< ▁print Short est Super Seq ▁( ▁X ▁, ▁Y ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁Matrix Chain Order ▁( ▁int ▁p ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁m ▁[ ▁n ▁] ▁[ ▁n ▁] ▁; ▁int ▁i ▁, ▁j ▁, ▁k ▁, ▁L ▁, ▁q ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁m ▁[ ▁i ▁] ▁[ ▁i ▁] ▁= ▁0 ▁; ▁for ▁( ▁L ▁= ▁2 ▁; ▁L ▁< ▁n ▁; ▁L ▁++ ▁) ▁{ ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁- ▁L ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁j ▁= ▁i ▁+ ▁L ▁- ▁1 ▁; ▁m ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁INT _ MAX ▁; ▁for ▁( ▁k ▁= ▁i ▁; ▁k ▁<= ▁j ▁- ▁1 ▁; ▁k ▁++ ▁) ▁{ ▁q ▁= ▁m ▁[ ▁i ▁] ▁[ ▁k ▁] ▁+ ▁m ▁[ ▁k ▁+ ▁1 ▁] ▁[ ▁j ▁] ▁+ ▁p ▁[ ▁i ▁- ▁1 ▁] ▁* ▁p ▁[ ▁k ▁] ▁* ▁p ▁[ ▁j ▁] ▁; ▁if ▁( ▁q ▁< ▁m ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁m ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁q ▁; ▁} ▁} ▁} ▁return ▁m ▁[ ▁1 ▁] ▁[ ▁n ▁- ▁1 ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁size ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁Minimum ▁number ▁of ▁multiplication s ▁is ▁" ▁<< ▁Matrix Chain Order ▁( ▁arr ▁, ▁size ▁) ▁; ▁get char ▁( ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count ▁( ▁int ▁S ▁[ ▁] ▁, ▁int ▁m ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁== ▁0 ▁) ▁return ▁1 ▁; ▁if ▁( ▁n ▁< ▁0 ▁) ▁return ▁0 ▁; ▁if ▁( ▁m ▁<= ▁0 ▁&& ▁n ▁>= ▁1 ▁) ▁return ▁0 ▁; ▁return ▁count ▁( ▁S ▁, ▁m ▁- ▁1 ▁, ▁n ▁) ▁+ ▁count ▁( ▁S ▁, ▁m ▁, ▁n ▁- ▁S ▁[ ▁m ▁- ▁1 ▁] ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁i ▁, ▁j ▁; ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁} ▁; ▁int ▁m ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁" ▁<< ▁count ▁( ▁arr ▁, ▁m ▁, ▁4 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Sub string Count ▁( ▁string ▁str ▁) ▁{ ▁int ▁result ▁= ▁0 ▁; ▁int ▁n ▁= ▁str ▁. ▁size ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁str ▁[ ▁i ▁] ▁+ ▁1 ▁== ▁str ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁{ ▁result ▁++ ▁; ▁while ▁( ▁str ▁[ ▁i ▁] ▁+ ▁1 ▁== ▁str ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁{ ▁i ▁++ ▁; ▁} ▁} ▁} ▁return ▁result ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁alphabet ▁" ▁; ▁c out ▁<< ▁find Sub string Count ▁( ▁str ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁round ▁( ▁int ▁n ▁) ▁{ ▁int ▁a ▁= ▁( ▁n ▁/ ▁10 ▁) ▁* ▁10 ▁; ▁int ▁b ▁= ▁a ▁+ ▁10 ▁; ▁return ▁( ▁n ▁- ▁a ▁> ▁b ▁- ▁n ▁) ▁? ▁b ▁: ▁a ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁47 22 ▁; ▁c out ▁<< ▁round ▁( ▁n ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is V ow el ▁( ▁char ▁c ▁) ▁{ ▁return ▁( ▁c ▁== ▁' ▁a ▁' ▁c ▁== ▁' ▁e ▁' ▁c ▁== ▁' ▁i ▁' ▁c ▁== ▁' ▁o ▁' ▁c ▁== ▁' ▁u ▁' ▁) ▁; ▁} ▁string ▁encrypt String ▁( ▁string ▁s ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁count V ow els ▁= ▁0 ▁; ▁int ▁count Con son ants ▁= ▁0 ▁; ▁string ▁ans ▁= ▁" ▁" ▁; ▁for ▁( ▁int ▁l ▁= ▁0 ▁; ▁l ▁<= ▁n ▁- ▁k ▁; ▁l ▁++ ▁) ▁{ ▁count V ow els ▁= ▁0 ▁; ▁count Con son ants ▁= ▁0 ▁; ▁for ▁( ▁int ▁r ▁= ▁l ▁; ▁r ▁<= ▁l ▁+ ▁k ▁- ▁1 ▁; ▁r ▁++ ▁) ▁{ ▁if ▁( ▁is V ow el ▁( ▁s ▁[ ▁r ▁] ▁) ▁== ▁true ▁) ▁count V ow els ▁++ ▁; ▁else ▁count Con son ants ▁++ ▁; ▁} ▁ans ▁+= ▁to _ string ▁( ▁count V ow els ▁* ▁count Con son ants ▁) ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁" ▁hello ▁" ▁; ▁int ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁int ▁k ▁= ▁2 ▁; ▁c out ▁<< ▁encrypt String ▁( ▁s ▁, ▁n ▁, ▁k ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁ham ming Dist ▁( ▁char ▁* ▁str 1 ▁, ▁char ▁* ▁str 2 ▁) ▁{ ▁int ▁i ▁= ▁0 ▁, ▁count ▁= ▁0 ▁; ▁while ▁( ▁str 1 ▁[ ▁i ▁] ▁!= ▁' ▁\0' ▁) ▁{ ▁if ▁( ▁str 1 ▁[ ▁i ▁] ▁!= ▁str 2 ▁[ ▁i ▁] ▁) ▁count ▁++ ▁; ▁i ▁++ ▁; ▁} ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁char ▁str 1 ▁[ ▁] ▁= ▁" ▁g eek sp ractice ▁" ▁; ▁char ▁str 2 ▁[ ▁] ▁= ▁" ▁n er d sp ract ise ▁" ▁; ▁c out ▁<< ▁ham ming Dist ▁( ▁str 1 ▁, ▁str 2 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁float ▁surface Area ▁( ▁float ▁a ▁, ▁float ▁b ▁, ▁float ▁h ▁) ▁{ ▁return ▁5 ▁* ▁a ▁* ▁b ▁+ ▁5 ▁* ▁b ▁* ▁h ▁; ▁} ▁float ▁volume ▁( ▁float ▁b ▁, ▁float ▁h ▁) ▁{ ▁return ▁( ▁5 ▁* ▁b ▁* ▁h ▁) ▁/ ▁2 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁float ▁a ▁= ▁5 ▁; ▁float ▁b ▁= ▁3 ▁; ▁float ▁h ▁= ▁7 ▁; ▁c out ▁<< ▁" ▁surface ▁area ▁= ▁" ▁<< ▁surface Area ▁( ▁a ▁, ▁b ▁, ▁h ▁) ▁<< ▁" ▁, ▁" ▁; ▁c out ▁<< ▁" ▁volume ▁= ▁" ▁<< ▁volume ▁( ▁b ▁, ▁h ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁form Quad ru pl ets ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁ans ▁= ▁0 ▁, ▁pairs ▁= ▁0 ▁; ▁pairs ▁= ▁n ▁/ ▁4 ▁; ▁sort ▁( ▁arr ▁, ▁arr ▁+ ▁n ▁, ▁greater ▁< ▁int ▁> ▁( ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁pairs ▁; ▁i ▁+= ▁3 ▁) ▁{ ▁ans ▁+= ▁arr ▁[ ▁i ▁+ ▁2 ▁] ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁1 ▁, ▁7 ▁, ▁5 ▁, ▁5 ▁, ▁4 ▁, ▁1 ▁, ▁1 ▁, ▁3 ▁, ▁3 ▁, ▁2 ▁, ▁2 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁form Quad ru pl ets ▁( ▁arr ▁, ▁n ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁Count ▁( ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁if ▁( ▁K ▁== ▁0 ▁) ▁return ▁0 ▁; ▁int ▁res ▁= ▁0 ▁; ▁int ▁low ▁= ▁1 ▁, ▁high ▁= ▁N ▁; ▁while ▁( ▁low ▁<= ▁high ▁) ▁{ ▁int ▁mid ▁= ▁( ▁low ▁+ ▁high ▁) ▁/ ▁2 ▁; ▁int ▁sum ▁= ▁( ▁mid ▁* ▁mid ▁+ ▁mid ▁) ▁/ ▁2 ▁; ▁if ▁( ▁sum ▁<= ▁K ▁) ▁{ ▁res ▁= ▁max ▁( ▁res ▁, ▁mid ▁) ▁; ▁low ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁else ▁{ ▁high ▁= ▁mid ▁- ▁1 ▁; ▁} ▁} ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁6 ▁, ▁K ▁= ▁14 ▁; ▁c out ▁<< ▁Count ▁( ▁N ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁max Items ▁( ▁int ▁n ▁, ▁int ▁m ▁, ▁int ▁a ▁[ ▁] ▁, ▁int ▁b ▁[ ▁] ▁, ▁int ▁K ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁int ▁A ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁int ▁B ▁[ ▁m ▁+ ▁1 ▁] ▁; ▁A ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁B ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁A ▁[ ▁i ▁] ▁= ▁a ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁A ▁[ ▁i ▁- ▁1 ▁] ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁m ▁; ▁i ▁++ ▁) ▁{ ▁B ▁[ ▁i ▁] ▁= ▁b ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁B ▁[ ▁i ▁- ▁1 ▁] ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁A ▁[ ▁i ▁] ▁> ▁K ▁) ▁break ▁; ▁int ▁rem ▁= ▁K ▁- ▁A ▁[ ▁i ▁] ▁; ▁int ▁j ▁= ▁0 ▁; ▁int ▁lo ▁= ▁0 ▁, ▁hi ▁= ▁m ▁; ▁while ▁( ▁lo ▁<= ▁hi ▁) ▁{ ▁int ▁mid ▁= ▁( ▁lo ▁+ ▁hi ▁) ▁/ ▁2 ▁; ▁if ▁( ▁B ▁[ ▁mid ▁] ▁<= ▁rem ▁) ▁{ ▁j ▁= ▁mid ▁; ▁lo ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁else ▁{ ▁hi ▁= ▁mid ▁- ▁1 ▁; ▁} ▁} ▁count ▁= ▁max ▁( ▁j ▁+ ▁i ▁, ▁count ▁) ▁; ▁} ▁c out ▁<< ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁4 ▁, ▁m ▁= ▁5 ▁, ▁K ▁= ▁7 ▁; ▁int ▁A ▁[ ▁n ▁] ▁= ▁{ ▁2 ▁, ▁4 ▁, ▁7 ▁, ▁3 ▁} ▁; ▁int ▁B ▁[ ▁m ▁] ▁= ▁{ ▁1 ▁, ▁9 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁max Items ▁( ▁n ▁, ▁m ▁, ▁A ▁, ▁B ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁is Prime ▁( ▁int ▁N ▁) ▁{ ▁if ▁( ▁N ▁== ▁1 ▁) ▁return ▁false ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁* ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁N ▁% ▁i ▁== ▁0 ▁) ▁return ▁false ▁; ▁} ▁return ▁true ▁; ▁} ▁int ▁find Co Prime ▁( ▁int ▁L ▁, ▁int ▁R ▁) ▁{ ▁int ▁co Prime ▁; ▁for ▁( ▁int ▁i ▁= ▁R ▁+ ▁1 ▁; ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁is Prime ▁( ▁i ▁) ▁) ▁{ ▁co Prime ▁= ▁i ▁; ▁break ▁; ▁} ▁} ▁return ▁co Prime ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁L ▁= ▁16 ▁, ▁R ▁= ▁17 ▁; ▁c out ▁<< ▁find Co Prime ▁( ▁L ▁, ▁R ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁K th Character ▁( ▁string ▁S ▁, ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁char ▁str array ▁[ ▁N ▁+ ▁1 ▁] ▁; ▁str c py ▁( ▁str array ▁, ▁S ▁. ▁c _ str ▁( ▁) ▁) ▁; ▁sort ▁( ▁str array ▁, ▁str array ▁+ ▁N ▁) ▁; ▁char ▁ch ▁= ▁str array ▁[ ▁K ▁- ▁1 ▁] ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁auto ▁c ▁: ▁str array ▁) ▁{ ▁if ▁( ▁c ▁== ▁ch ▁) ▁count ▁++ ▁; ▁} ▁c out ▁<< ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁S ▁= ▁" ▁g eek s forge ek s ▁" ▁; ▁int ▁N ▁= ▁S ▁. ▁length ▁( ▁) ▁; ▁int ▁K ▁= ▁3 ▁; ▁K th Character ▁( ▁S ▁, ▁N ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find Sub string ▁( ▁string ▁S ▁) ▁{ ▁string ▁T ▁= ▁" ▁" ▁; ▁string ▁ans ▁= ▁" ▁" ▁; ▁int ▁l ▁= ▁0 ▁; ▁T ▁+= ▁S ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁S ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁abs ▁( ▁S ▁[ ▁i ▁] ▁- ▁S ▁[ ▁i ▁- ▁1 ▁] ▁) ▁== ▁1 ▁) ▁{ ▁l ▁= ▁T ▁. ▁length ▁( ▁) ▁; ▁if ▁( ▁l ▁> ▁ans ▁. ▁length ▁( ▁) ▁) ▁{ ▁ans ▁= ▁T ▁; ▁} ▁T ▁= ▁" ▁" ▁; ▁T ▁+= ▁S ▁[ ▁i ▁] ▁; ▁} ▁else ▁{ ▁T ▁+= ▁S ▁[ ▁i ▁] ▁; ▁} ▁} ▁l ▁= ▁( ▁int ▁) ▁T ▁. ▁length ▁( ▁) ▁; ▁if ▁( ▁l ▁> ▁( ▁int ▁) ▁ans ▁. ▁length ▁( ▁) ▁) ▁{ ▁ans ▁= ▁T ▁; ▁} ▁c out ▁<< ▁ans ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁S ▁= ▁" ▁a ab d ml ▁" ▁; ▁find Sub string ▁( ▁S ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁static ▁int ▁no Of Valid K bers ▁( ▁int ▁K ▁, ▁vector ▁< ▁int ▁> ▁arr ▁) ▁{ ▁map ▁< ▁int ▁, ▁int ▁> ▁set ▁; ▁while ▁( ▁K ▁!= ▁0 ▁) ▁{ ▁set ▁[ ▁K ▁% ▁10 ▁] ▁= ▁1 ▁; ▁K ▁= ▁K ▁/ ▁10 ▁; ▁} ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁arr ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁int ▁no ▁= ▁arr ▁[ ▁i ▁] ▁; ▁bool ▁flag ▁= ▁true ▁; ▁while ▁( ▁no ▁!= ▁0 ▁) ▁{ ▁int ▁digit ▁= ▁no ▁% ▁10 ▁; ▁if ▁( ▁set ▁. ▁find ▁( ▁digit ▁) ▁== ▁set ▁. ▁end ▁( ▁) ▁) ▁{ ▁flag ▁= ▁false ▁; ▁break ▁; ▁} ▁no ▁= ▁no ▁/ ▁10 ▁; ▁} ▁if ▁( ▁flag ▁== ▁true ▁) ▁{ ▁count ▁++ ▁; ▁} ▁} ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁K ▁= ▁12 ▁; ▁vector ▁< ▁int ▁> ▁arr ▁= ▁{ ▁1 ▁, ▁12 ▁, ▁12 22 ▁, ▁13 ▁, ▁2 ▁} ▁; ▁c out ▁<< ▁( ▁no Of Valid K bers ▁( ▁K ▁, ▁arr ▁) ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁MAX ▁10000 ▁NEW _ LINE ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁div is ors ▁( ▁MAX ▁+ ▁1 ▁) ▁; ▁void ▁compute Div is ors ▁( ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁MAX ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁<= ▁MAX ▁; ▁j ▁+= ▁i ▁) ▁{ ▁div is ors ▁[ ▁j ▁] ▁. ▁push _ back ▁( ▁i ▁) ▁; ▁} ▁} ▁} ▁int ▁getC lo sest ▁( ▁int ▁val 1 ▁, ▁int ▁val 2 ▁, ▁int ▁target ▁) ▁{ ▁if ▁( ▁target ▁- ▁val 1 ▁>= ▁val 2 ▁- ▁target ▁) ▁return ▁val 2 ▁; ▁else ▁return ▁val 1 ▁; ▁} ▁int ▁find Clo sest ▁( ▁vector ▁< ▁int ▁> ▁& ▁arr ▁, ▁int ▁n ▁, ▁int ▁target ▁) ▁{ ▁if ▁( ▁target ▁<= ▁arr ▁[ ▁0 ▁] ▁) ▁return ▁arr ▁[ ▁0 ▁] ▁; ▁if ▁( ▁target ▁>= ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁) ▁return ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁; ▁int ▁i ▁= ▁0 ▁, ▁j ▁= ▁n ▁, ▁mid ▁= ▁0 ▁; ▁while ▁( ▁i ▁< ▁j ▁) ▁{ ▁mid ▁= ▁( ▁i ▁+ ▁j ▁) ▁/ ▁2 ▁; ▁if ▁( ▁arr ▁[ ▁mid ▁] ▁== ▁target ▁) ▁return ▁arr ▁[ ▁mid ▁] ▁; ▁if ▁( ▁target ▁< ▁arr ▁[ ▁mid ▁] ▁) ▁{ ▁if ▁( ▁mid ▁> ▁0 ▁&& ▁target ▁> ▁arr ▁[ ▁mid ▁- ▁1 ▁] ▁) ▁return ▁getC lo sest ▁( ▁arr ▁[ ▁mid ▁- ▁1 ▁] ▁, ▁arr ▁[ ▁mid ▁] ▁, ▁target ▁) ▁; ▁j ▁= ▁mid ▁; ▁} ▁else ▁{ ▁if ▁( ▁mid ▁< ▁n ▁- ▁1 ▁&& ▁target ▁< ▁arr ▁[ ▁mid ▁+ ▁1 ▁] ▁) ▁return ▁getC lo sest ▁( ▁arr ▁[ ▁mid ▁] ▁, ▁arr ▁[ ▁mid ▁+ ▁1 ▁] ▁, ▁target ▁) ▁; ▁i ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁} ▁return ▁arr ▁[ ▁mid ▁] ▁; ▁} ▁void ▁print Clo sest ▁( ▁int ▁N ▁, ▁int ▁X ▁) ▁{ ▁compute Div is ors ▁( ▁) ▁; ▁int ▁ans ▁= ▁find Clo sest ▁( ▁div is ors ▁[ ▁N ▁] ▁, ▁div is ors ▁[ ▁N ▁] ▁. ▁size ▁( ▁) ▁, ▁X ▁) ▁; ▁c out ▁<< ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁16 ▁, ▁X ▁= ▁5 ▁; ▁print Clo sest ▁( ▁N ▁, ▁X ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count Div ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁rem 0 ▁= ▁0 ▁; ▁int ▁rem 1 ▁= ▁0 ▁; ▁int ▁rem 2 ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁digit Sum ▁= ▁0 ▁; ▁digit Sum ▁+= ▁arr ▁[ ▁i ▁] ▁; ▁if ▁( ▁digit Sum ▁% ▁3 ▁== ▁0 ▁) ▁{ ▁rem 0 ▁+= ▁1 ▁; ▁} ▁else ▁if ▁( ▁digit Sum ▁% ▁3 ▁== ▁1 ▁) ▁{ ▁rem 1 ▁+= ▁1 ▁; ▁} ▁else ▁{ ▁rem 2 ▁+= ▁1 ▁; ▁} ▁} ▁return ▁( ▁rem 0 ▁/ ▁2 ▁+ ▁min ▁( ▁rem 1 ▁, ▁rem 2 ▁) ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁3 ▁, ▁2 ▁, ▁8 ▁, ▁7 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁( ▁count Div ▁( ▁arr ▁, ▁n ▁) ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁# include ▁< set > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁N ▁10000 5 ▁NEW _ LINE ▁void ▁S ieve Of E rat ost hen es ▁( ▁bool ▁prime ▁[ ▁] ▁, ▁int ▁p _ size ▁) ▁{ ▁prime ▁[ ▁0 ▁] ▁= ▁false ▁; ▁prime ▁[ ▁1 ▁] ▁= ▁false ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁* ▁p ▁<= ▁p _ size ▁; ▁p ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁p ▁] ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁p ▁* ▁2 ▁; ▁i ▁<= ▁p _ size ▁; ▁i ▁+= ▁p ▁) ▁prime ▁[ ▁i ▁] ▁= ▁false ▁; ▁} ▁} ▁} ▁long ▁long ▁int ▁digit Product ▁( ▁int ▁number ▁) ▁{ ▁long ▁long ▁int ▁res ▁= ▁1 ▁; ▁while ▁( ▁number ▁> ▁0 ▁) ▁{ ▁res ▁*= ▁( ▁number ▁% ▁10 ▁) ▁; ▁number ▁/= ▁10 ▁; ▁} ▁return ▁res ▁; ▁} ▁void ▁Dist inct Composite Digit Product ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁set ▁< ▁int ▁> ▁output ▁; ▁bool ▁prime ▁[ ▁N ▁+ ▁1 ▁] ▁; ▁mem set ▁( ▁prime ▁, ▁true ▁, ▁sizeof ▁( ▁prime ▁) ▁) ▁; ▁S ieve Of E rat ost hen es ▁( ▁prime ▁, ▁N ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁long ▁long ▁int ▁ans ▁= ▁digit Product ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁if ▁( ▁ans ▁<= ▁1 ▁) ▁{ ▁continue ▁; ▁} ▁if ▁( ▁! ▁prime ▁[ ▁ans ▁] ▁) ▁{ ▁output ▁. ▁insert ▁( ▁ans ▁) ▁; ▁} ▁} ▁c out ▁<< ▁output ▁. ▁size ▁( ▁) ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁13 ▁, ▁55 ▁, ▁7 ▁, ▁13 ▁, ▁11 ▁, ▁71 ▁, ▁2 33 ▁, ▁2 33 ▁, ▁144 ▁, ▁89 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁Dist inct Composite Digit Product ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁simple S ieve ▁( ▁int ▁l mt ▁, ▁vector ▁< ▁int ▁> ▁& ▁prime ▁) ▁{ ▁bool ▁S ieve ▁[ ▁l mt ▁+ ▁1 ▁] ▁; ▁mem set ▁( ▁S ieve ▁, ▁true ▁, ▁sizeof ▁( ▁S ieve ▁) ▁) ▁; ▁S ieve ▁[ ▁0 ▁] ▁= ▁S ieve ▁[ ▁1 ▁] ▁= ▁false ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁<= ▁l mt ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁S ieve ▁[ ▁i ▁] ▁== ▁true ▁) ▁{ ▁prime ▁. ▁push _ back ▁( ▁i ▁) ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁* ▁i ▁; ▁j ▁<= ▁l mt ▁; ▁j ▁+= ▁i ▁) ▁{ ▁S ieve ▁[ ▁j ▁] ▁= ▁false ▁; ▁} ▁} ▁} ▁} ▁vector ▁< ▁bool ▁> ▁Segment ed S ieve Fn ▁( ▁int ▁low ▁, ▁int ▁high ▁) ▁{ ▁int ▁l mt ▁= ▁floor ▁( ▁sqrt ▁( ▁high ▁) ▁) ▁+ ▁1 ▁; ▁vector ▁< ▁int ▁> ▁prime ▁; ▁simple S ieve ▁( ▁l mt ▁, ▁prime ▁) ▁; ▁int ▁n ▁= ▁high ▁- ▁low ▁+ ▁1 ▁; ▁vector ▁< ▁bool ▁> ▁segment ed S ieve ▁( ▁n ▁+ ▁1 ▁, ▁true ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁prime ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁int ▁low L im ▁= ▁floor ▁( ▁low ▁/ ▁prime ▁[ ▁i ▁] ▁) ▁* ▁prime ▁[ ▁i ▁] ▁; ▁if ▁( ▁low L im ▁< ▁low ▁) ▁{ ▁low L im ▁+= ▁prime ▁[ ▁i ▁] ▁; ▁} ▁for ▁( ▁int ▁j ▁= ▁low L im ▁; ▁j ▁<= ▁high ▁; ▁j ▁+= ▁prime ▁[ ▁i ▁] ▁) ▁{ ▁if ▁( ▁j ▁!= ▁prime ▁[ ▁i ▁] ▁) ▁{ ▁segment ed S ieve ▁[ ▁j ▁- ▁low ▁] ▁= ▁false ▁; ▁} ▁} ▁} ▁return ▁segment ed S ieve ▁; ▁} ▁int ▁count Pairs Wh ose Sum Prime L _ R ▁( ▁int ▁L ▁, ▁int ▁R ▁) ▁{ ▁vector ▁< ▁bool ▁> ▁segment ed S ieve ▁= ▁Segment ed S ieve Fn ▁( ▁L ▁, ▁R ▁) ▁; ▁int ▁cnt Pairs ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁L ▁; ▁i ▁<= ▁R ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁segment ed S ieve ▁[ ▁i ▁- ▁L ▁] ▁) ▁{ ▁cnt Pairs ▁+= ▁i ▁/ ▁2 ▁; ▁} ▁} ▁return ▁cnt Pairs ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁L ▁= ▁1 ▁, ▁R ▁= ▁5 ▁; ▁c out ▁<< ▁count Pairs Wh ose Sum Prime L _ R ▁( ▁L ▁, ▁R ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁int ▁max N ▁= ▁2002 ▁; ▁int ▁count Sub se que ce ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁i ▁, ▁j ▁, ▁k ▁, ▁l ▁; ▁int ▁answer ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁for ▁( ▁k ▁= ▁j ▁+ ▁1 ▁; ▁k ▁< ▁n ▁; ▁k ▁++ ▁) ▁{ ▁for ▁( ▁l ▁= ▁k ▁+ ▁1 ▁; ▁l ▁< ▁n ▁; ▁l ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁j ▁] ▁== ▁a ▁[ ▁l ▁] ▁&& ▁a ▁[ ▁i ▁] ▁== ▁a ▁[ ▁k ▁] ▁) ▁{ ▁answer ▁++ ▁; ▁} ▁} ▁} ▁} ▁} ▁return ▁answer ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁7 ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁2 ▁, ▁1 ▁, ▁3 ▁, ▁2 ▁} ▁; ▁c out ▁<< ▁count Sub se que ce ▁( ▁a ▁, ▁7 ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁MAX ▁10000 000 ▁NEW _ LINE ▁bool ▁is Prime ▁[ ▁MAX ▁] ▁; ▁vector ▁< ▁int ▁> ▁primes ▁; ▁void ▁S ieve Of E rat ost hen es ▁( ▁) ▁{ ▁mem set ▁( ▁is Prime ▁, ▁true ▁, ▁sizeof ▁( ▁is Prime ▁) ▁) ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁* ▁p ▁<= ▁MAX ▁; ▁p ▁++ ▁) ▁{ ▁if ▁( ▁is Prime ▁[ ▁p ▁] ▁== ▁true ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁p ▁* ▁p ▁; ▁i ▁<= ▁MAX ▁; ▁i ▁+= ▁p ▁) ▁is Prime ▁[ ▁i ▁] ▁= ▁false ▁; ▁} ▁} ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁<= ▁MAX ▁; ▁p ▁++ ▁) ▁if ▁( ▁is Prime ▁[ ▁p ▁] ▁) ▁primes ▁. ▁push _ back ▁( ▁p ▁) ▁; ▁} ▁int ▁prime _ search ▁( ▁vector ▁< ▁int ▁> ▁primes ▁, ▁int ▁diff ▁) ▁{ ▁int ▁low ▁= ▁0 ▁; ▁int ▁high ▁= ▁primes ▁. ▁size ▁( ▁) ▁- ▁1 ▁; ▁int ▁res ▁; ▁while ▁( ▁low ▁<= ▁high ▁) ▁{ ▁int ▁mid ▁= ▁( ▁low ▁+ ▁high ▁) ▁/ ▁2 ▁; ▁if ▁( ▁primes ▁[ ▁mid ▁] ▁== ▁diff ▁) ▁{ ▁return ▁primes ▁[ ▁mid ▁] ▁; ▁} ▁else ▁if ▁( ▁primes ▁[ ▁mid ▁] ▁< ▁diff ▁) ▁{ ▁low ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁else ▁{ ▁res ▁= ▁primes ▁[ ▁mid ▁] ▁; ▁high ▁= ▁mid ▁- ▁1 ▁; ▁} ▁} ▁return ▁res ▁; ▁} ▁int ▁min Cost ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁S ieve Of E rat ost hen es ▁( ▁) ▁; ▁int ▁res ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁) ▁{ ▁int ▁diff ▁= ▁arr ▁[ ▁i ▁- ▁1 ▁] ▁- ▁arr ▁[ ▁i ▁] ▁; ▁int ▁closest _ prime ▁= ▁prime _ search ▁( ▁primes ▁, ▁diff ▁) ▁; ▁res ▁+= ▁closest _ prime ▁; ▁arr ▁[ ▁i ▁] ▁+= ▁closest _ prime ▁; ▁} ▁} ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁1 ▁, ▁5 ▁, ▁4 ▁, ▁3 ▁} ▁; ▁int ▁n ▁= ▁5 ▁; ▁c out ▁<< ▁min Cost ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁char ▁min Dist Char ▁( ▁string ▁s ▁) ▁{ ▁int ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁int ▁* ▁first ▁= ▁new ▁int ▁[ ▁26 ▁] ▁; ▁int ▁* ▁last ▁= ▁new ▁int ▁[ ▁26 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁26 ▁; ▁i ▁++ ▁) ▁{ ▁first ▁[ ▁i ▁] ▁= ▁-1 ▁; ▁last ▁[ ▁i ▁] ▁= ▁-1 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁first ▁[ ▁s ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁] ▁== ▁-1 ▁) ▁{ ▁first ▁[ ▁s ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁] ▁= ▁i ▁; ▁} ▁last ▁[ ▁s ▁[ ▁i ▁] ▁- ▁' ▁a ▁' ▁] ▁= ▁i ▁; ▁} ▁int ▁min ▁= ▁INT _ MAX ▁; ▁char ▁ans ▁= ▁'1' ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁26 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁last ▁[ ▁i ▁] ▁== ▁first ▁[ ▁i ▁] ▁) ▁continue ▁; ▁if ▁( ▁min ▁> ▁last ▁[ ▁i ▁] ▁- ▁first ▁[ ▁i ▁] ▁) ▁{ ▁min ▁= ▁last ▁[ ▁i ▁] ▁- ▁first ▁[ ▁i ▁] ▁; ▁ans ▁= ▁i ▁+ ▁' ▁a ▁' ▁; ▁} ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁str ▁= ▁" ▁g eek s forge ek s ▁" ▁; ▁c out ▁<< ▁min Dist Char ▁( ▁str ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁unique Element ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁unordered _ set ▁< ▁int ▁> ▁set ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁set ▁. ▁insert ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁if ▁( ▁set ▁. ▁size ▁( ▁) ▁== ▁1 ▁) ▁{ ▁c out ▁<< ▁" ▁YES ▁" ▁<< ▁end l ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁" ▁NO ▁" ▁<< ▁end l ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁9 ▁, ▁9 ▁, ▁9 ▁, ▁9 ▁, ▁9 ▁, ▁9 ▁, ▁9 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁unique Element ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁vector ▁< ▁int ▁> ▁adj ▁[ ▁10000 5 ▁] ▁; ▁int ▁visited ▁[ ▁10000 5 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁int ▁ans ▁= ▁0 ▁; ▁void ▁dfs ▁( ▁int ▁node ▁, ▁int ▁count ▁, ▁int ▁m ▁, ▁int ▁arr ▁[ ▁] ▁, ▁int ▁k ▁) ▁{ ▁visited ▁[ ▁node ▁] ▁= ▁1 ▁; ▁if ▁( ▁arr ▁[ ▁node ▁- ▁1 ▁] ▁== ▁k ▁) ▁{ ▁count ▁++ ▁; ▁} ▁else ▁{ ▁count ▁= ▁0 ▁; ▁} ▁if ▁( ▁count ▁> ▁m ▁) ▁{ ▁return ▁; ▁} ▁if ▁( ▁adj ▁[ ▁node ▁] ▁. ▁size ▁( ▁) ▁== ▁1 ▁&& ▁node ▁!= ▁1 ▁) ▁{ ▁ans ▁++ ▁; ▁} ▁for ▁( ▁auto ▁x ▁: ▁adj ▁[ ▁node ▁] ▁) ▁{ ▁if ▁( ▁! ▁visited ▁[ ▁x ▁] ▁) ▁{ ▁dfs ▁( ▁x ▁, ▁count ▁, ▁m ▁, ▁arr ▁, ▁k ▁) ▁; ▁} ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁1 ▁, ▁3 ▁, ▁2 ▁, ▁1 ▁, ▁2 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁7 ▁, ▁K ▁= ▁2 ▁, ▁M ▁= ▁2 ▁; ▁adj ▁[ ▁1 ▁] ▁. ▁push _ back ▁( ▁2 ▁) ▁; ▁adj ▁[ ▁2 ▁] ▁. ▁push _ back ▁( ▁1 ▁) ▁; ▁adj ▁[ ▁1 ▁] ▁. ▁push _ back ▁( ▁3 ▁) ▁; ▁adj ▁[ ▁3 ▁] ▁. ▁push _ back ▁( ▁1 ▁) ▁; ▁adj ▁[ ▁2 ▁] ▁. ▁push _ back ▁( ▁4 ▁) ▁; ▁adj ▁[ ▁4 ▁] ▁. ▁push _ back ▁( ▁2 ▁) ▁; ▁adj ▁[ ▁2 ▁] ▁. ▁push _ back ▁( ▁5 ▁) ▁; ▁adj ▁[ ▁5 ▁] ▁. ▁push _ back ▁( ▁2 ▁) ▁; ▁adj ▁[ ▁3 ▁] ▁. ▁push _ back ▁( ▁6 ▁) ▁; ▁adj ▁[ ▁6 ▁] ▁. ▁push _ back ▁( ▁3 ▁) ▁; ▁adj ▁[ ▁3 ▁] ▁. ▁push _ back ▁( ▁7 ▁) ▁; ▁adj ▁[ ▁7 ▁] ▁. ▁push _ back ▁( ▁3 ▁) ▁; ▁int ▁counter ▁= ▁0 ▁; ▁dfs ▁( ▁1 ▁, ▁counter ▁, ▁M ▁, ▁arr ▁, ▁K ▁) ▁; ▁c out ▁<< ▁ans ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁calc _ distance ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁B ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁distance _ tr avel ed _ A ▁= ▁0 ▁; ▁int ▁distance _ tr avel ed _ B ▁= ▁0 ▁; ▁int ▁answer ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁5 ▁; ▁i ▁++ ▁) ▁{ ▁distance _ tr avel ed _ A ▁+= ▁A ▁[ ▁i ▁] ▁; ▁distance _ tr avel ed _ B ▁+= ▁B ▁[ ▁i ▁] ▁; ▁if ▁( ▁( ▁distance _ tr avel ed _ A ▁== ▁distance _ tr avel ed _ B ▁) ▁&& ▁( ▁A ▁[ ▁i ▁] ▁== ▁B ▁[ ▁i ▁] ▁) ▁) ▁{ ▁answer ▁+= ▁A ▁[ ▁i ▁] ▁; ▁} ▁} ▁return ▁answer ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁[ ▁5 ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁2 ▁, ▁4 ▁} ▁; ▁int ▁B ▁[ ▁5 ▁] ▁= ▁{ ▁2 ▁, ▁1 ▁, ▁3 ▁, ▁1 ▁, ▁4 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁A ▁) ▁/ ▁sizeof ▁( ▁A ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁calc _ distance ▁( ▁A ▁, ▁B ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁max Product ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁if ▁( ▁N ▁< ▁3 ▁) ▁{ ▁return ▁; ▁} ▁int ▁a ▁= ▁arr ▁[ ▁0 ▁] ▁, ▁b ▁= ▁arr ▁[ ▁1 ▁] ▁; ▁int ▁c ▁= ▁0 ▁, ▁d ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁* ▁arr ▁[ ▁j ▁] ▁> ▁a ▁* ▁b ▁) ▁{ ▁c ▁= ▁a ▁, ▁d ▁= ▁b ▁; ▁a ▁= ▁arr ▁[ ▁i ▁] ▁, ▁b ▁= ▁arr ▁[ ▁j ▁] ▁; ▁} ▁if ▁( ▁arr ▁[ ▁i ▁] ▁* ▁arr ▁[ ▁j ▁] ▁< ▁a ▁* ▁b ▁&& ▁arr ▁[ ▁i ▁] ▁* ▁arr ▁[ ▁j ▁] ▁> ▁c ▁* ▁d ▁) ▁c ▁= ▁arr ▁[ ▁i ▁] ▁, ▁d ▁= ▁arr ▁[ ▁j ▁] ▁; ▁} ▁c out ▁<< ▁c ▁<< ▁" ▁" ▁<< ▁d ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁2 ▁, ▁67 ▁, ▁45 ▁, ▁160 ▁, ▁78 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁max Product ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find Max Value ▁( ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁int ▁packages ▁; ▁int ▁max i ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁K ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁N ▁% ▁i ▁== ▁0 ▁) ▁max i ▁= ▁max ▁( ▁max i ▁, ▁i ▁) ▁; ▁} ▁packages ▁= ▁N ▁/ ▁max i ▁; ▁c out ▁<< ▁packages ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁8 ▁, ▁K ▁= ▁7 ▁; ▁find Max Value ▁( ▁N ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁make Groups ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁vector ▁< ▁int ▁> ▁v ▁( ▁n ▁+ ▁1 ▁, ▁0 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁v ▁[ ▁a ▁[ ▁i ▁] ▁] ▁++ ▁; ▁} ▁int ▁no _ of _ groups ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁no _ of _ groups ▁+= ▁v ▁[ ▁i ▁] ▁/ ▁i ▁; ▁v ▁[ ▁i ▁] ▁= ▁v ▁[ ▁i ▁] ▁% ▁i ▁; ▁} ▁int ▁i ▁= ▁1 ▁; ▁int ▁total ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁v ▁[ ▁i ▁] ▁!= ▁0 ▁) ▁{ ▁total ▁= ▁v ▁[ ▁i ▁] ▁; ▁break ▁; ▁} ▁} ▁i ▁++ ▁; ▁while ▁( ▁i ▁<= ▁n ▁) ▁{ ▁if ▁( ▁v ▁[ ▁i ▁] ▁!= ▁0 ▁) ▁{ ▁total ▁+= ▁v ▁[ ▁i ▁] ▁; ▁if ▁( ▁total ▁>= ▁i ▁) ▁{ ▁int ▁rem ▁= ▁total ▁- ▁i ▁; ▁no _ of _ groups ▁++ ▁; ▁total ▁= ▁rem ▁; ▁} ▁} ▁i ▁++ ▁; ▁} ▁c out ▁<< ▁no _ of _ groups ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁1 ▁, ▁2 ▁, ▁2 ▁} ▁; ▁int ▁size ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁make Groups ▁( ▁arr ▁, ▁size ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁N ▁4 ▁NEW _ LINE ▁# define ▁M ▁5 ▁NEW _ LINE ▁void ▁pre Process ▁( ▁int ▁mat ▁[ ▁N ▁] ▁[ ▁M ▁] ▁, ▁int ▁aux ▁[ ▁N ▁] ▁[ ▁M ▁] ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁M ▁; ▁i ▁++ ▁) ▁aux ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁= ▁mat ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁M ▁; ▁j ▁++ ▁) ▁aux ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁mat ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+ ▁aux ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁< ▁M ▁; ▁j ▁++ ▁) ▁aux ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+= ▁aux ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁; ▁} ▁int ▁sum Query ▁( ▁int ▁aux ▁[ ▁N ▁] ▁[ ▁M ▁] ▁, ▁int ▁t li ▁, ▁int ▁tl j ▁, ▁int ▁rb i ▁, ▁int ▁rb j ▁) ▁{ ▁int ▁res ▁= ▁aux ▁[ ▁rb i ▁] ▁[ ▁rb j ▁] ▁; ▁if ▁( ▁t li ▁> ▁0 ▁) ▁res ▁= ▁res ▁- ▁aux ▁[ ▁t li ▁- ▁1 ▁] ▁[ ▁rb j ▁] ▁; ▁if ▁( ▁tl j ▁> ▁0 ▁) ▁res ▁= ▁res ▁- ▁aux ▁[ ▁rb i ▁] ▁[ ▁tl j ▁- ▁1 ▁] ▁; ▁if ▁( ▁t li ▁> ▁0 ▁&& ▁tl j ▁> ▁0 ▁) ▁res ▁= ▁res ▁+ ▁aux ▁[ ▁t li ▁- ▁1 ▁] ▁[ ▁tl j ▁- ▁1 ▁] ▁; ▁return ▁res ▁; ▁} ▁bool ▁check ▁( ▁int ▁mid ▁, ▁int ▁aux ▁[ ▁N ▁] ▁[ ▁M ▁] ▁, ▁int ▁K ▁) ▁{ ▁bool ▁satisfies ▁= ▁true ▁; ▁for ▁( ▁int ▁x ▁= ▁0 ▁; ▁x ▁< ▁N ▁; ▁x ▁++ ▁) ▁{ ▁for ▁( ▁int ▁y ▁= ▁0 ▁; ▁y ▁< ▁M ▁; ▁y ▁++ ▁) ▁{ ▁if ▁( ▁x ▁+ ▁mid ▁- ▁1 ▁<= ▁N ▁- ▁1 ▁&& ▁y ▁+ ▁mid ▁- ▁1 ▁<= ▁M ▁- ▁1 ▁) ▁{ ▁if ▁( ▁sum Query ▁( ▁aux ▁, ▁x ▁, ▁y ▁, ▁x ▁+ ▁mid ▁- ▁1 ▁, ▁y ▁+ ▁mid ▁- ▁1 ▁) ▁> ▁K ▁) ▁satisfies ▁= ▁false ▁; ▁} ▁} ▁} ▁return ▁( ▁satisfies ▁== ▁true ▁) ▁; ▁} ▁int ▁maximum Square Size ▁( ▁int ▁mat ▁[ ▁N ▁] ▁[ ▁M ▁] ▁, ▁int ▁K ▁) ▁{ ▁int ▁aux ▁[ ▁N ▁] ▁[ ▁M ▁] ▁; ▁pre Process ▁( ▁mat ▁, ▁aux ▁) ▁; ▁int ▁low ▁= ▁1 ▁, ▁high ▁= ▁min ▁( ▁N ▁, ▁M ▁) ▁; ▁int ▁mid ▁; ▁while ▁( ▁high ▁- ▁low ▁> ▁1 ▁) ▁{ ▁mid ▁= ▁( ▁low ▁+ ▁high ▁) ▁/ ▁2 ▁; ▁if ▁( ▁check ▁( ▁mid ▁, ▁aux ▁, ▁K ▁) ▁) ▁{ ▁low ▁= ▁mid ▁; ▁} ▁else ▁high ▁= ▁mid ▁; ▁} ▁if ▁( ▁check ▁( ▁high ▁, ▁aux ▁, ▁K ▁) ▁) ▁return ▁high ▁; ▁return ▁low ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁K ▁= ▁30 ▁; ▁int ▁mat ▁[ ▁N ▁] ▁[ ▁M ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁6 ▁} ▁, ▁{ ▁5 ▁, ▁3 ▁, ▁8 ▁, ▁1 ▁, ▁2 ▁} ▁, ▁{ ▁4 ▁, ▁6 ▁, ▁7 ▁, ▁5 ▁, ▁5 ▁} ▁, ▁{ ▁2 ▁, ▁4 ▁, ▁8 ▁, ▁9 ▁, ▁4 ▁} ▁} ▁; ▁c out ▁<< ▁maximum Square Size ▁( ▁mat ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find Sub Array ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁int ▁maxsize ▁= ▁-1 ▁, ▁start index ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁is alpha ▁( ▁arr ▁[ ▁i ▁] ▁) ▁) ▁{ ▁arr ▁[ ▁i ▁] ▁= ▁0 ▁; ▁} ▁else ▁{ ▁arr ▁[ ▁i ▁] ▁= ▁1 ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁= ▁( ▁arr ▁[ ▁i ▁] ▁== ▁0 ▁) ▁? ▁-1 ▁: ▁1 ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁( ▁arr ▁[ ▁j ▁] ▁== ▁0 ▁) ▁? ▁( ▁sum ▁+= ▁-1 ▁) ▁: ▁( ▁sum ▁+= ▁1 ▁) ▁; ▁if ▁( ▁sum ▁== ▁0 ▁&& ▁maxsize ▁< ▁j ▁- ▁i ▁+ ▁1 ▁) ▁{ ▁maxsize ▁= ▁j ▁- ▁i ▁+ ▁1 ▁; ▁start index ▁= ▁i ▁; ▁} ▁} ▁} ▁if ▁( ▁maxsize ▁== ▁-1 ▁) ▁c out ▁<< ▁maxsize ▁; ▁else ▁c out ▁<< ▁start index ▁<< ▁" ▁" ▁<< ▁( ▁start index ▁+ ▁maxsize ▁- ▁1 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁' ▁A ▁' ▁, ▁' ▁B ▁' ▁, ▁' ▁X ▁' ▁, ▁4 ▁, ▁6 ▁, ▁' ▁X ▁' ▁, ▁' ▁a ▁' ▁} ▁; ▁int ▁size ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁find Sub Array ▁( ▁arr ▁, ▁size ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁# define ▁n ▁3 ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁min Steps ▁( ▁int ▁arr ▁[ ▁] ▁[ ▁n ▁] ▁) ▁{ ▁bool ▁v ▁[ ▁n ▁] ▁[ ▁n ▁] ▁= ▁{ ▁0 ▁} ▁; ▁queue ▁< ▁pair ▁< ▁int ▁, ▁int ▁> ▁> ▁q ▁; ▁q ▁. ▁push ▁( ▁{ ▁0 ▁, ▁0 ▁} ▁) ▁; ▁int ▁depth ▁= ▁0 ▁; ▁while ▁( ▁q ▁. ▁size ▁( ▁) ▁!= ▁0 ▁) ▁{ ▁int ▁x ▁= ▁q ▁. ▁size ▁( ▁) ▁; ▁while ▁( ▁x ▁-- ▁) ▁{ ▁pair ▁< ▁int ▁, ▁int ▁> ▁y ▁= ▁q ▁. ▁front ▁( ▁) ▁; ▁int ▁i ▁= ▁y ▁. ▁first ▁, ▁j ▁= ▁y ▁. ▁second ▁; ▁q ▁. ▁pop ▁( ▁) ▁; ▁if ▁( ▁v ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁continue ▁; ▁if ▁( ▁i ▁== ▁n ▁- ▁1 ▁&& ▁j ▁== ▁n ▁- ▁1 ▁) ▁return ▁depth ▁; ▁v ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁1 ▁; ▁if ▁( ▁i ▁+ ▁arr ▁[ ▁i ▁] ▁[ ▁j ▁] ▁< ▁n ▁) ▁q ▁. ▁push ▁( ▁{ ▁i ▁+ ▁arr ▁[ ▁i ▁] ▁[ ▁j ▁] ▁, ▁j ▁} ▁) ▁; ▁if ▁( ▁j ▁+ ▁arr ▁[ ▁i ▁] ▁[ ▁j ▁] ▁< ▁n ▁) ▁q ▁. ▁push ▁( ▁{ ▁i ▁, ▁j ▁+ ▁arr ▁[ ▁i ▁] ▁[ ▁j ▁] ▁} ▁) ▁; ▁} ▁depth ▁++ ▁; ▁} ▁return ▁-1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁n ▁] ▁[ ▁n ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁1 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁1 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁1 ▁, ▁1 ▁} ▁} ▁; ▁c out ▁<< ▁min Steps ▁( ▁arr ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁check Distinct ▁( ▁int ▁x ▁) ▁{ ▁int ▁last ▁= ▁x ▁% ▁10 ▁; ▁while ▁( ▁x ▁) ▁{ ▁if ▁( ▁x ▁% ▁10 ▁!= ▁last ▁) ▁return ▁false ▁; ▁x ▁= ▁x ▁/ ▁10 ▁; ▁} ▁return ▁true ▁; ▁} ▁int ▁find Count ▁( ▁int ▁L ▁, ▁int ▁R ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁L ▁; ▁i ▁<= ▁R ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁check Distinct ▁( ▁i ▁) ▁) ▁count ▁+= ▁1 ▁; ▁} ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁L ▁= ▁10 ▁, ▁R ▁= ▁50 ▁; ▁c out ▁<< ▁find Count ▁( ▁L ▁, ▁R ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁L ower Insertion Point ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁X ▁) ▁{ ▁if ▁( ▁X ▁< ▁arr ▁[ ▁0 ▁] ▁) ▁return ▁0 ▁; ▁else ▁if ▁( ▁X ▁> ▁arr ▁[ ▁n ▁- ▁1 ▁] ▁) ▁return ▁n ▁; ▁int ▁lower P nt ▁= ▁0 ▁; ▁int ▁i ▁= ▁1 ▁; ▁while ▁( ▁i ▁< ▁n ▁&& ▁arr ▁[ ▁i ▁] ▁< ▁X ▁) ▁{ ▁lower P nt ▁= ▁i ▁; ▁i ▁= ▁i ▁* ▁2 ▁; ▁} ▁while ▁( ▁lower P nt ▁< ▁n ▁&& ▁arr ▁[ ▁lower P nt ▁] ▁< ▁X ▁) ▁lower P nt ▁++ ▁; ▁return ▁lower P nt ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁, ▁7 ▁, ▁9 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁X ▁= ▁4 ▁; ▁c out ▁<< ▁L ower Insertion Point ▁( ▁arr ▁, ▁n ▁, ▁X ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁check ▁( ▁string ▁s ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁. ▁length ▁( ▁) ▁- ▁1 ▁; ▁i ▁++ ▁) ▁if ▁( ▁s ▁[ ▁i ▁] ▁== ▁s ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁return ▁true ▁; ▁return ▁false ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁" ▁x z yy z ▁" ▁; ▁if ▁( ▁check ▁( ▁s ▁) ▁) ▁c out ▁<< ▁" ▁YES ▁" ▁<< ▁end l ▁; ▁else ▁c out ▁<< ▁" ▁NO ▁" ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁count An om al ies ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁res ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁j ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁if ▁( ▁i ▁!= ▁j ▁&& ▁abs ▁( ▁arr ▁[ ▁i ▁] ▁- ▁arr ▁[ ▁j ▁] ▁) ▁<= ▁k ▁) ▁break ▁; ▁if ▁( ▁j ▁== ▁n ▁) ▁res ▁++ ▁; ▁} ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁7 ▁, ▁1 ▁, ▁8 ▁} ▁, ▁k ▁= ▁5 ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁count An om al ies ▁( ▁arr ▁, ▁n ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁col Max Diff ▁( ▁int ▁mat ▁[ ▁N ▁] ▁[ ▁N ▁] ▁) ▁{ ▁int ▁max _ diff ▁= ▁INT _ MIN ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁int ▁max _ val ▁= ▁mat ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁, ▁min _ val ▁= ▁mat ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁; ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁< ▁N ▁; ▁j ▁++ ▁) ▁{ ▁max _ val ▁= ▁max ▁( ▁max _ val ▁, ▁mat ▁[ ▁j ▁] ▁[ ▁i ▁] ▁) ▁; ▁min _ val ▁= ▁min ▁( ▁min _ val ▁, ▁mat ▁[ ▁j ▁] ▁[ ▁i ▁] ▁) ▁; ▁} ▁max _ diff ▁= ▁max ▁( ▁max _ diff ▁, ▁max _ val ▁- ▁min _ val ▁) ▁; ▁} ▁return ▁max _ diff ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁mat ▁[ ▁N ▁] ▁[ ▁N ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁, ▁{ ▁5 ▁, ▁3 ▁, ▁5 ▁, ▁4 ▁, ▁0 ▁} ▁, ▁{ ▁5 ▁, ▁6 ▁, ▁7 ▁, ▁8 ▁, ▁9 ▁} ▁, ▁{ ▁0 ▁, ▁6 ▁, ▁3 ▁, ▁4 ▁, ▁12 ▁} ▁, ▁{ ▁9 ▁, ▁7 ▁, ▁12 ▁, ▁4 ▁, ▁3 ▁} ▁, ▁} ▁; ▁c out ▁<< ▁" ▁Max ▁difference ▁: ▁" ▁<< ▁col Max Diff ▁( ▁mat ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find missing ▁( ▁int ▁ar ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁l ▁= ▁0 ▁, ▁r ▁= ▁N ▁- ▁1 ▁; ▁while ▁( ▁l ▁<= ▁r ▁) ▁{ ▁int ▁mid ▁= ▁( ▁l ▁+ ▁r ▁) ▁/ ▁2 ▁; ▁if ▁( ▁ar ▁[ ▁mid ▁] ▁!= ▁mid ▁+ ▁1 ▁&& ▁ar ▁[ ▁mid ▁- ▁1 ▁] ▁== ▁mid ▁) ▁return ▁mid ▁+ ▁1 ▁; ▁if ▁( ▁ar ▁[ ▁mid ▁] ▁!= ▁mid ▁+ ▁1 ▁) ▁r ▁= ▁mid ▁- ▁1 ▁; ▁else ▁l ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁return ▁-1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁7 ▁, ▁8 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁find missing ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁solve ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁max 1 ▁= ▁INT _ MIN ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁abs ▁( ▁a ▁[ ▁i ▁] ▁- ▁a ▁[ ▁j ▁] ▁) ▁> ▁max 1 ▁) ▁{ ▁max 1 ▁= ▁abs ▁( ▁a ▁[ ▁i ▁] ▁- ▁a ▁[ ▁j ▁] ▁) ▁; ▁} ▁} ▁} ▁return ▁max 1 ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁-1 ▁, ▁2 ▁, ▁3 ▁, ▁-4 ▁, ▁-10 ▁, ▁22 ▁} ▁; ▁int ▁size ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁" ▁L argest ▁gap ▁is ▁: ▁" ▁<< ▁solve ▁( ▁arr ▁, ▁size ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max Product ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁< ▁4 ▁) ▁return ▁-1 ▁; ▁int ▁max A ▁= ▁INT _ MIN ▁, ▁max B ▁= ▁INT _ MIN ▁, ▁max C ▁= ▁INT _ MIN ▁, ▁max D ▁= ▁INT _ MIN ▁; ▁int ▁min A ▁= ▁INT _ MAX ▁, ▁min B ▁= ▁INT _ MAX ▁, ▁min C ▁= ▁INT _ MAX ▁, ▁min D ▁= ▁INT _ MAX ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁max A ▁) ▁{ ▁max D ▁= ▁max C ▁; ▁max C ▁= ▁max B ▁; ▁max B ▁= ▁max A ▁; ▁max A ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁else ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁max B ▁) ▁{ ▁max D ▁= ▁max C ▁; ▁max C ▁= ▁max B ▁; ▁max B ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁else ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁max C ▁) ▁{ ▁max D ▁= ▁max C ▁; ▁max C ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁else ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁max D ▁) ▁max D ▁= ▁arr ▁[ ▁i ▁] ▁; ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁min A ▁) ▁{ ▁min D ▁= ▁min C ▁; ▁min C ▁= ▁min B ▁; ▁min B ▁= ▁min A ▁; ▁min A ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁else ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁min B ▁) ▁{ ▁min D ▁= ▁min C ▁; ▁min C ▁= ▁min B ▁; ▁min B ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁else ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁min C ▁) ▁{ ▁min D ▁= ▁min C ▁; ▁min C ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁else ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁min D ▁) ▁min D ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁int ▁x ▁= ▁max A ▁* ▁max B ▁* ▁max C ▁* ▁max D ▁; ▁int ▁y ▁= ▁min A ▁* ▁min B ▁* ▁min C ▁* ▁min D ▁; ▁int ▁z ▁= ▁min A ▁* ▁min B ▁* ▁max A ▁* ▁max B ▁; ▁return ▁max ▁( ▁x ▁, ▁max ▁( ▁y ▁, ▁z ▁) ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁-4 ▁, ▁3 ▁, ▁- 6 ▁, ▁7 ▁, ▁0 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁int ▁max ▁= ▁max Product ▁( ▁arr ▁, ▁n ▁) ▁; ▁if ▁( ▁max ▁== ▁-1 ▁) ▁c out ▁<< ▁" ▁No ▁Quad r uple ▁Exists ▁" ▁; ▁else ▁c out ▁<< ▁" ▁Maximum ▁product ▁is ▁" ▁<< ▁max ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print Matrix ▁( ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁a ▁) ▁{ ▁for ▁( ▁auto ▁x ▁: ▁a ▁) ▁{ ▁for ▁( ▁auto ▁y ▁: ▁x ▁) ▁{ ▁c out ▁<< ▁y ▁<< ▁" ▁" ▁; ▁} ▁c out ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁} ▁} ▁void ▁sort Boundary W ise ▁( ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁a ▁) ▁{ ▁int ▁i ▁, ▁k ▁= ▁0 ▁, ▁l ▁= ▁0 ▁; ▁int ▁m ▁= ▁a ▁. ▁size ▁( ▁) ▁, ▁n ▁= ▁a ▁[ ▁0 ▁] ▁. ▁size ▁( ▁) ▁; ▁int ▁n _ i ▁, ▁n _ k ▁= ▁0 ▁, ▁n _ l ▁= ▁0 ▁, ▁n _ m ▁= ▁m ▁, ▁n _ n ▁= ▁n ▁; ▁while ▁( ▁k ▁< ▁m ▁&& ▁l ▁< ▁n ▁) ▁{ ▁vector ▁< ▁int ▁> ▁boundary ▁; ▁for ▁( ▁i ▁= ▁l ▁; ▁i ▁< ▁n ▁; ▁++ ▁i ▁) ▁{ ▁boundary ▁. ▁push _ back ▁( ▁a ▁[ ▁k ▁] ▁[ ▁i ▁] ▁) ▁; ▁} ▁k ▁++ ▁; ▁for ▁( ▁i ▁= ▁k ▁; ▁i ▁< ▁m ▁; ▁++ ▁i ▁) ▁{ ▁boundary ▁. ▁push _ back ▁( ▁a ▁[ ▁i ▁] ▁[ ▁n ▁- ▁1 ▁] ▁) ▁; ▁} ▁n ▁-- ▁; ▁if ▁( ▁k ▁< ▁m ▁) ▁{ ▁for ▁( ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁l ▁; ▁-- ▁i ▁) ▁{ ▁boundary ▁. ▁push _ back ▁( ▁a ▁[ ▁m ▁- ▁1 ▁] ▁[ ▁i ▁] ▁) ▁; ▁} ▁m ▁-- ▁; ▁} ▁if ▁( ▁l ▁< ▁n ▁) ▁{ ▁for ▁( ▁i ▁= ▁m ▁- ▁1 ▁; ▁i ▁>= ▁k ▁; ▁-- ▁i ▁) ▁{ ▁boundary ▁. ▁push _ back ▁( ▁a ▁[ ▁i ▁] ▁[ ▁l ▁] ▁) ▁; ▁} ▁l ▁++ ▁; ▁} ▁sort ▁( ▁boundary ▁. ▁begin ▁( ▁) ▁, ▁boundary ▁. ▁end ▁( ▁) ▁) ▁; ▁int ▁ind ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁n _ l ▁; ▁i ▁< ▁n _ n ▁; ▁++ ▁i ▁) ▁{ ▁a ▁[ ▁n _ k ▁] ▁[ ▁i ▁] ▁= ▁boundary ▁[ ▁ind ▁++ ▁] ▁; ▁} ▁n _ k ▁++ ▁; ▁for ▁( ▁i ▁= ▁n _ k ▁; ▁i ▁< ▁n _ m ▁; ▁++ ▁i ▁) ▁{ ▁a ▁[ ▁i ▁] ▁[ ▁n _ n ▁- ▁1 ▁] ▁= ▁boundary ▁[ ▁ind ▁++ ▁] ▁; ▁} ▁n _ n ▁-- ▁; ▁if ▁( ▁n _ k ▁< ▁n _ m ▁) ▁{ ▁for ▁( ▁i ▁= ▁n _ n ▁- ▁1 ▁; ▁i ▁>= ▁n _ l ▁; ▁-- ▁i ▁) ▁{ ▁a ▁[ ▁n _ m ▁- ▁1 ▁] ▁[ ▁i ▁] ▁= ▁boundary ▁[ ▁ind ▁++ ▁] ▁; ▁} ▁n _ m ▁-- ▁; ▁} ▁if ▁( ▁n _ l ▁< ▁n _ n ▁) ▁{ ▁for ▁( ▁i ▁= ▁n _ m ▁- ▁1 ▁; ▁i ▁>= ▁n _ k ▁; ▁-- ▁i ▁) ▁{ ▁a ▁[ ▁i ▁] ▁[ ▁n _ l ▁] ▁= ▁boundary ▁[ ▁ind ▁++ ▁] ▁; ▁} ▁n _ l ▁++ ▁; ▁} ▁} ▁print Matrix ▁( ▁a ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁matrix ▁= ▁{ ▁{ ▁9 ▁, ▁7 ▁, ▁4 ▁, ▁5 ▁} ▁, ▁{ ▁1 ▁, ▁6 ▁, ▁2 ▁, ▁- 6 ▁} ▁, ▁{ ▁12 ▁, ▁20 ▁, ▁2 ▁, ▁0 ▁} ▁, ▁{ ▁-5 ▁, ▁- 6 ▁, ▁7 ▁, ▁-2 ▁} ▁} ▁; ▁sort Boundary W ise ▁( ▁matrix ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max Score ▁( ▁int ▁i ▁, ▁int ▁A ▁[ ▁] ▁, ▁int ▁K ▁, ▁int ▁N ▁, ▁int ▁dp ▁[ ▁] ▁) ▁{ ▁if ▁( ▁i ▁>= ▁N ▁- ▁1 ▁) ▁return ▁A ▁[ ▁N ▁- ▁1 ▁] ▁; ▁if ▁( ▁dp ▁[ ▁i ▁] ▁!= ▁-1 ▁) ▁return ▁dp ▁[ ▁i ▁] ▁; ▁int ▁score ▁= ▁INT _ MIN ▁; ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁<= ▁K ▁; ▁j ▁++ ▁) ▁{ ▁score ▁= ▁max ▁( ▁score ▁, ▁max Score ▁( ▁i ▁+ ▁j ▁, ▁A ▁, ▁K ▁, ▁N ▁, ▁dp ▁) ▁) ▁; ▁} ▁return ▁dp ▁[ ▁i ▁] ▁= ▁score ▁+ ▁A ▁[ ▁i ▁] ▁; ▁} ▁int ▁getScore ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁int ▁dp ▁[ ▁N ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁dp ▁[ ▁i ▁] ▁= ▁-1 ▁; ▁c out ▁<< ▁max Score ▁( ▁0 ▁, ▁A ▁, ▁K ▁, ▁N ▁, ▁dp ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁100 ▁, ▁- 30 ▁, ▁- 50 ▁, ▁- 15 ▁, ▁- 20 ▁, ▁- 30 ▁} ▁; ▁int ▁K ▁= ▁3 ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁A ▁) ▁/ ▁sizeof ▁( ▁A ▁[ ▁0 ▁] ▁) ▁; ▁getScore ▁( ▁A ▁, ▁N ▁, ▁K ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁check if Sorted ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁B ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁bool ▁flag ▁= ▁false ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁A ▁[ ▁i ▁] ▁> ▁A ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁{ ▁flag ▁= ▁true ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁! ▁flag ▁) ▁{ ▁return ▁true ▁; ▁} ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁B ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁count ▁++ ▁; ▁break ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁B ▁[ ▁i ▁] ▁== ▁1 ▁) ▁{ ▁count ▁++ ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁count ▁== ▁2 ▁) ▁{ ▁return ▁true ▁; ▁} ▁return ▁false ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁1 ▁, ▁2 ▁} ▁; ▁int ▁B ▁[ ▁] ▁= ▁{ ▁0 ▁, ▁1 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁A ▁) ▁/ ▁sizeof ▁( ▁A ▁[ ▁0 ▁] ▁) ▁; ▁bool ▁check ▁= ▁check if Sorted ▁( ▁A ▁, ▁B ▁, ▁N ▁) ▁; ▁if ▁( ▁check ▁) ▁{ ▁c out ▁<< ▁" ▁YES ▁" ▁<< ▁end l ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁" ▁NO ▁" ▁<< ▁end l ▁; ▁} ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁isIn cre asing ▁( ▁vector ▁< ▁int ▁> ▁arr ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁arr ▁. ▁size ▁( ▁) ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁arr ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁return ▁false ▁; ▁} ▁return ▁true ▁; ▁} ▁vector ▁< ▁int ▁> ▁sort Arr ▁( ▁vector ▁< ▁int ▁> ▁arr ▁) ▁{ ▁int ▁prev ▁= ▁-1 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁arr ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁int ▁opt Ele ▁= ▁arr ▁[ ▁i ▁] ▁; ▁string ▁str Ele ▁= ▁to _ string ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁for ▁( ▁int ▁idx ▁= ▁0 ▁; ▁idx ▁< ▁str Ele ▁. ▁size ▁( ▁) ▁; ▁idx ▁++ ▁) ▁{ ▁string ▁str Ele 2 ▁= ▁str Ele ▁. ▁substr ▁( ▁idx ▁) ▁+ ▁str Ele ▁. ▁substr ▁( ▁0 ▁, ▁idx ▁) ▁; ▁int ▁temp ▁= ▁sto i ▁( ▁str Ele 2 ▁) ▁; ▁if ▁( ▁temp ▁>= ▁prev ▁&& ▁temp ▁< ▁opt Ele ▁) ▁opt Ele ▁= ▁temp ▁; ▁} ▁arr ▁[ ▁i ▁] ▁= ▁opt Ele ▁; ▁prev ▁= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁if ▁( ▁isIn cre asing ▁( ▁arr ▁) ▁) ▁return ▁arr ▁; ▁else ▁{ ▁arr ▁= ▁{ ▁-1 ▁} ▁; ▁return ▁arr ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁vector ▁< ▁int ▁> ▁arr ▁= ▁{ ▁5 11 ▁, ▁32 1 ▁, ▁3 23 ▁, ▁4 32 ▁, ▁4 33 ▁} ▁; ▁vector ▁< ▁int ▁> ▁res ▁= ▁sort Arr ▁( ▁arr ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁res ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁res ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁N ▁100 ▁NEW _ LINE ▁# define ▁INF ▁1000000 ▁NEW _ LINE ▁int ▁dp ▁[ ▁N ▁] ▁[ ▁N ▁] ▁; ▁bool ▁vis ▁[ ▁N ▁] ▁[ ▁N ▁] ▁; ▁int ▁find Sum ▁( ▁int ▁* ▁arr ▁, ▁int ▁n ▁, ▁int ▁k ▁, ▁int ▁l ▁, ▁int ▁r ▁) ▁{ ▁if ▁( ▁( ▁l ▁) ▁+ ▁( ▁n ▁- ▁1 ▁- ▁r ▁) ▁== ▁k ▁) ▁return ▁arr ▁[ ▁r ▁] ▁- ▁arr ▁[ ▁l ▁] ▁; ▁if ▁( ▁vis ▁[ ▁l ▁] ▁[ ▁r ▁] ▁) ▁return ▁dp ▁[ ▁l ▁] ▁[ ▁r ▁] ▁; ▁vis ▁[ ▁l ▁] ▁[ ▁r ▁] ▁= ▁1 ▁; ▁return ▁dp ▁[ ▁l ▁] ▁[ ▁r ▁] ▁= ▁min ▁( ▁find Sum ▁( ▁arr ▁, ▁n ▁, ▁k ▁, ▁l ▁, ▁r ▁- ▁1 ▁) ▁, ▁find Sum ▁( ▁arr ▁, ▁n ▁, ▁k ▁, ▁l ▁+ ▁1 ▁, ▁r ▁) ▁) ▁; ▁} ▁int 32_ t ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁100 ▁, ▁120 ▁, ▁140 ▁} ▁; ▁int ▁k ▁= ▁2 ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁c out ▁<< ▁find Sum ▁( ▁arr ▁, ▁n ▁, ▁k ▁, ▁0 ▁, ▁n ▁- ▁1 ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁string ▁getS orted String ▁( ▁string ▁s ▁, ▁int ▁n ▁) ▁{ ▁vector ▁< ▁char ▁> ▁v 1 ▁, ▁v 2 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁[ ▁i ▁] ▁>= ▁' ▁a ▁' ▁&& ▁s ▁[ ▁i ▁] ▁<= ▁' ▁z ▁' ▁) ▁v 1 ▁. ▁push _ back ▁( ▁s ▁[ ▁i ▁] ▁) ▁; ▁if ▁( ▁s ▁[ ▁i ▁] ▁>= ▁' ▁A ▁' ▁&& ▁s ▁[ ▁i ▁] ▁<= ▁' ▁Z ▁' ▁) ▁v 2 ▁. ▁push _ back ▁( ▁s ▁[ ▁i ▁] ▁) ▁; ▁} ▁sort ▁( ▁v 1 ▁. ▁begin ▁( ▁) ▁, ▁v 1 ▁. ▁end ▁( ▁) ▁) ▁; ▁sort ▁( ▁v 2 ▁. ▁begin ▁( ▁) ▁, ▁v 2 ▁. ▁end ▁( ▁) ▁) ▁; ▁int ▁i ▁= ▁0 ▁, ▁j ▁= ▁0 ▁; ▁for ▁( ▁int ▁k ▁= ▁0 ▁; ▁k ▁< ▁n ▁; ▁k ▁++ ▁) ▁{ ▁if ▁( ▁s ▁[ ▁k ▁] ▁>= ▁' ▁a ▁' ▁&& ▁s ▁[ ▁k ▁] ▁<= ▁' ▁z ▁' ▁) ▁{ ▁s ▁[ ▁k ▁] ▁= ▁v 1 ▁[ ▁i ▁] ▁; ▁++ ▁i ▁; ▁} ▁else ▁if ▁( ▁s ▁[ ▁k ▁] ▁>= ▁' ▁A ▁' ▁&& ▁s ▁[ ▁k ▁] ▁<= ▁' ▁Z ▁' ▁) ▁{ ▁s ▁[ ▁k ▁] ▁= ▁v 2 ▁[ ▁j ▁] ▁; ▁++ ▁j ▁; ▁} ▁} ▁return ▁s ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁" ▁g E ek sf Org EE k S ▁" ▁; ▁int ▁n ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁c out ▁<< ▁getS orted String ▁( ▁s ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁remove Elements ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁br r ▁[ ▁n ▁] ▁, ▁l ▁= ▁1 ▁; ▁br r ▁[ ▁0 ▁] ▁= ▁arr ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁br r ▁[ ▁l ▁- ▁1 ▁] ▁<= ▁arr ▁[ ▁i ▁] ▁) ▁{ ▁br r ▁[ ▁l ▁] ▁= ▁arr ▁[ ▁i ▁] ▁; ▁l ▁++ ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁l ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁br r ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁10 ▁, ▁12 ▁, ▁9 ▁, ▁10 ▁, ▁2 ▁, ▁13 ▁, ▁14 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁remove Elements ▁( ▁arr ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find X ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁sort ▁( ▁a ▁, ▁a ▁+ ▁n ▁) ▁; ▁int ▁x ▁= ▁a ▁[ ▁0 ▁] ▁* ▁a ▁[ ▁n ▁- ▁1 ▁] ▁; ▁vector ▁< ▁int ▁> ▁vec ▁; ▁for ▁( ▁int ▁i ▁= ▁2 ▁; ▁i ▁* ▁i ▁<= ▁x ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁x ▁% ▁i ▁== ▁0 ▁) ▁{ ▁vec ▁. ▁push _ back ▁( ▁i ▁) ▁; ▁if ▁( ▁( ▁x ▁/ ▁i ▁) ▁!= ▁i ▁) ▁vec ▁. ▁push _ back ▁( ▁x ▁/ ▁i ▁) ▁; ▁} ▁} ▁sort ▁( ▁vec ▁. ▁begin ▁( ▁) ▁, ▁vec ▁. ▁end ▁( ▁) ▁) ▁; ▁if ▁( ▁vec ▁. ▁size ▁( ▁) ▁!= ▁n ▁) ▁return ▁-1 ▁; ▁else ▁{ ▁int ▁i ▁= ▁0 ▁; ▁for ▁( ▁auto ▁it ▁: ▁vec ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁++ ▁] ▁!= ▁it ▁) ▁return ▁-1 ▁; ▁} ▁} ▁return ▁x ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁5 ▁, ▁4 ▁, ▁10 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁find X ▁( ▁a ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁# define ▁MOD ▁100 000000 7 ▁NEW _ LINE ▁# define ▁ll ▁long ▁long ▁NEW _ LINE ▁# define ▁max ▁101 ▁NEW _ LINE ▁ll ▁C ▁[ ▁max ▁- ▁1 ▁] ▁[ ▁max ▁- ▁1 ▁] ▁; ▁ll ▁power ▁( ▁ll ▁x ▁, ▁unsigned ▁ll ▁y ▁) ▁{ ▁unsigned ▁ll ▁res ▁= ▁1 ▁; ▁x ▁= ▁x ▁% ▁MOD ▁; ▁while ▁( ▁y ▁> ▁0 ▁) ▁{ ▁if ▁( ▁y ▁& ▁1 ▁) ▁{ ▁res ▁= ▁( ▁res ▁* ▁x ▁) ▁% ▁MOD ▁; ▁} ▁y ▁= ▁y ▁>> ▁1 ▁; ▁x ▁= ▁( ▁x ▁* ▁x ▁) ▁% ▁MOD ▁; ▁} ▁return ▁res ▁% ▁MOD ▁; ▁} ▁void ▁comb i ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁int ▁i ▁, ▁j ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁<= ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁<= ▁min ▁( ▁i ▁, ▁k ▁) ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁j ▁== ▁0 ▁j ▁== ▁i ▁) ▁C ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁1 ▁; ▁else ▁C ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁( ▁C ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁- ▁1 ▁] ▁% ▁MOD ▁+ ▁C ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁% ▁MOD ▁) ▁% ▁MOD ▁; ▁} ▁} ▁} ▁unsigned ▁ll ▁product ▁( ▁ll ▁a ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁unsigned ▁ll ▁ans ▁= ▁1 ▁; ▁sort ▁( ▁a ▁, ▁a ▁+ ▁n ▁) ▁; ▁ll ▁pow a ▁= ▁C ▁[ ▁n ▁- ▁1 ▁] ▁[ ▁k ▁- ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁ll ▁pow la ▁= ▁C ▁[ ▁i ▁] ▁[ ▁k ▁- ▁1 ▁] ▁; ▁ll ▁pow fa ▁= ▁C ▁[ ▁n ▁- ▁i ▁- ▁1 ▁] ▁[ ▁k ▁- ▁1 ▁] ▁; ▁ll ▁pow e ▁= ▁( ▁( ▁pow a ▁% ▁MOD ▁) ▁- ▁( ▁pow la ▁+ ▁pow fa ▁) ▁% ▁MOD ▁+ ▁MOD ▁) ▁% ▁MOD ▁; ▁unsigned ▁ll ▁mul ▁= ▁power ▁( ▁a ▁[ ▁i ▁] ▁, ▁pow e ▁) ▁% ▁MOD ▁; ▁ans ▁= ▁( ▁( ▁ans ▁% ▁MOD ▁) ▁* ▁( ▁mul ▁% ▁MOD ▁) ▁) ▁% ▁MOD ▁; ▁} ▁return ▁ans ▁% ▁MOD ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁comb i ▁( ▁100 ▁, ▁100 ▁) ▁; ▁ll ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁arr ▁[ ▁0 ▁] ▁; ▁int ▁k ▁= ▁3 ▁; ▁unsigned ▁ll ▁ans ▁= ▁product ▁( ▁arr ▁, ▁n ▁, ▁k ▁) ▁; ▁c out ▁<< ▁ans ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁distribution ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁set ▁< ▁int ▁, ▁greater ▁< ▁int ▁> ▁> ▁resources ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁resources ▁. ▁insert ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁int ▁m ▁= ▁resources ▁. ▁size ▁( ▁) ▁; ▁return ▁min ▁( ▁m ▁, ▁n ▁/ ▁2 ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁1 ▁, ▁2 ▁, ▁1 ▁, ▁3 ▁, ▁4 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁distribution ▁( ▁arr ▁, ▁n ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁print Sorted ▁( ▁string ▁s ▁, ▁int ▁l ▁) ▁{ ▁stack ▁< ▁char ▁> ▁Stack ▁; ▁stack ▁< ▁char ▁> ▁temp stack ▁; ▁Stack ▁. ▁push ▁( ▁s ▁[ ▁0 ▁] ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁l ▁; ▁i ▁++ ▁) ▁{ ▁int ▁a ▁= ▁s ▁[ ▁i ▁] ▁; ▁int ▁b ▁= ▁Stack ▁. ▁top ▁( ▁) ▁; ▁if ▁( ▁( ▁a ▁- ▁b ▁) ▁>= ▁1 ▁or ▁( ▁a ▁== ▁b ▁) ▁) ▁Stack ▁. ▁push ▁( ▁s ▁[ ▁i ▁] ▁) ▁; ▁else ▁if ▁( ▁( ▁b ▁- ▁a ▁) ▁>= ▁1 ▁) ▁{ ▁while ▁( ▁( ▁b ▁- ▁a ▁) ▁>= ▁1 ▁) ▁{ ▁temp stack ▁. ▁push ▁( ▁Stack ▁. ▁top ▁( ▁) ▁) ▁; ▁Stack ▁. ▁pop ▁( ▁) ▁; ▁if ▁( ▁Stack ▁. ▁size ▁( ▁) ▁> ▁0 ▁) ▁b ▁= ▁Stack ▁. ▁top ▁( ▁) ▁; ▁else ▁break ▁; ▁} ▁Stack ▁. ▁push ▁( ▁s ▁[ ▁i ▁] ▁) ▁; ▁while ▁( ▁temp stack ▁. ▁size ▁( ▁) ▁> ▁0 ▁) ▁{ ▁Stack ▁. ▁push ▁( ▁temp stack ▁. ▁top ▁( ▁) ▁) ▁; ▁temp stack ▁. ▁pop ▁( ▁) ▁; ▁} ▁} ▁} ▁string ▁answer ▁; ▁while ▁( ▁Stack ▁. ▁size ▁( ▁) ▁> ▁0 ▁) ▁{ ▁answer ▁= ▁Stack ▁. ▁top ▁( ▁) ▁+ ▁answer ▁; ▁Stack ▁. ▁pop ▁( ▁) ▁; ▁} ▁c out ▁<< ▁answer ▁<< ▁end l ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁" ▁g eek s forge ek s ▁" ▁; ▁int ▁l ▁= ▁s ▁. ▁length ▁( ▁) ▁; ▁print Sorted ▁( ▁s ▁, ▁l ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁maximum _ to ys ▁( ▁int ▁cost ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁int ▁count ▁= ▁0 ▁, ▁sum ▁= ▁0 ▁; ▁sort ▁( ▁cost ▁, ▁cost ▁+ ▁N ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁sum ▁+ ▁cost ▁[ ▁i ▁] ▁<= ▁K ▁) ▁{ ▁sum ▁= ▁sum ▁+ ▁cost ▁[ ▁i ▁] ▁; ▁count ▁++ ▁; ▁} ▁} ▁return ▁count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁K ▁= ▁50 ▁; ▁int ▁cost ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁12 ▁, ▁5 ▁, ▁111 ▁, ▁200 ▁, ▁1000 ▁, ▁10 ▁, ▁9 ▁, ▁12 ▁, ▁15 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁cost ▁) ▁/ ▁sizeof ▁( ▁cost ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁maximum _ to ys ▁( ▁cost ▁, ▁N ▁, ▁K ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁almost Sort ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁A ▁[ ▁i ▁] ▁> ▁A ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁{ ▁swap ▁( ▁A ▁[ ▁i ▁] ▁, ▁A ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁; ▁i ▁++ ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁if ▁( ▁A ▁[ ▁i ▁] ▁> ▁A ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁return ▁false ▁; ▁return ▁true ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁2 ▁, ▁4 ▁, ▁6 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁A ▁) ▁/ ▁sizeof ▁( ▁A ▁[ ▁0 ▁] ▁) ▁; ▁if ▁( ▁almost Sort ▁( ▁A ▁, ▁n ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁merge Two Half ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁temp ▁[ ▁n ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁A ▁[ ▁i ▁] ▁> ▁A ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁{ ▁half _ i ▁= ▁i ▁+ ▁1 ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁half _ i ▁== ▁0 ▁) ▁return ▁; ▁int ▁i ▁= ▁0 ▁, ▁j ▁= ▁half _ i ▁, ▁k ▁= ▁0 ▁; ▁while ▁( ▁i ▁< ▁half _ i ▁&& ▁j ▁< ▁n ▁) ▁{ ▁if ▁( ▁A ▁[ ▁i ▁] ▁< ▁A ▁[ ▁j ▁] ▁) ▁temp ▁[ ▁k ▁++ ▁] ▁= ▁A ▁[ ▁i ▁++ ▁] ▁; ▁else ▁temp ▁[ ▁k ▁++ ▁] ▁= ▁A ▁[ ▁j ▁++ ▁] ▁; ▁} ▁while ▁( ▁i ▁< ▁half _ i ▁) ▁temp ▁[ ▁k ▁++ ▁] ▁= ▁A ▁[ ▁i ▁++ ▁] ▁; ▁while ▁( ▁j ▁< ▁n ▁) ▁temp ▁[ ▁k ▁++ ▁] ▁= ▁A ▁[ ▁j ▁++ ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁A ▁[ ▁i ▁] ▁= ▁temp ▁[ ▁i ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁8 ▁, ▁-1 ▁, ▁7 ▁, ▁10 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁A ▁) ▁/ ▁sizeof ▁( ▁A ▁[ ▁0 ▁] ▁) ▁; ▁merge Two Half ▁( ▁A ▁, ▁n ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁c out ▁<< ▁A ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁double ▁Pi ▁= ▁3.14 15 92 ▁; ▁int ▁Max Build ings Cover ed ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁, ▁int ▁L ▁) ▁{ ▁double ▁curr _ sum ▁= ▁0 ▁; ▁int ▁start ▁= ▁0 ▁, ▁curr _ count ▁= ▁0 ▁, ▁max _ count ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁curr _ sum ▁= ▁curr _ sum ▁+ ▁( ▁( ▁double ▁) ▁arr ▁[ ▁i ▁] ▁* ▁Pi ▁) ▁; ▁if ▁( ▁i ▁!= ▁0 ▁) ▁curr _ sum ▁+= ▁1 ▁; ▁if ▁( ▁curr _ sum ▁<= ▁L ▁) ▁{ ▁curr _ count ▁++ ▁; ▁} ▁else ▁if ▁( ▁curr _ sum ▁> ▁L ▁) ▁{ ▁curr _ sum ▁= ▁curr _ sum ▁- ▁( ▁( ▁double ▁) ▁arr ▁[ ▁start ▁] ▁* ▁Pi ▁) ▁; ▁curr _ sum ▁-= ▁1 ▁; ▁start ▁++ ▁; ▁curr _ count ▁-- ▁; ▁} ▁max _ count ▁= ▁max ▁( ▁curr _ count ▁, ▁max _ count ▁) ▁; ▁} ▁return ▁max _ count ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁4 ▁, ▁1 ▁, ▁6 ▁, ▁2 ▁} ▁; ▁int ▁L ▁= ▁24 ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁Max Build ings Cover ed ▁( ▁arr ▁, ▁N ▁, ▁L ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁isP ossible ▁( ▁string ▁s ▁) ▁{ ▁int ▁n ▁= ▁s ▁. ▁size ▁( ▁) ▁; ▁int ▁count _0 ▁= ▁0 ▁, ▁count _1 ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁[ ▁i ▁] ▁== ▁'0' ▁) ▁++ ▁count _0 ▁; ▁else ▁++ ▁count _1 ▁; ▁if ▁( ▁count _1 ▁> ▁count _0 ▁) ▁return ▁false ▁; ▁} ▁if ▁( ▁count _0 ▁!= ▁( ▁2 ▁* ▁count _1 ▁) ▁) ▁return ▁false ▁; ▁count _0 ▁= ▁0 ▁, ▁count _1 ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁-- ▁i ▁) ▁{ ▁if ▁( ▁s ▁[ ▁i ▁] ▁== ▁'0' ▁) ▁++ ▁count _0 ▁; ▁else ▁++ ▁count _1 ▁; ▁if ▁( ▁count _1 ▁> ▁count _0 ▁) ▁return ▁false ▁; ▁} ▁return ▁true ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁" 0101 00" ▁; ▁if ▁( ▁isP ossible ▁( ▁s ▁) ▁) ▁c out ▁<< ▁" ▁Yes ▁" ▁; ▁else ▁c out ▁<< ▁" ▁No ▁" ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁find Max Val By Re arr Arr ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁res ▁= ▁0 ▁; ▁res ▁= ▁( ▁N ▁* ▁( ▁N ▁+ ▁1 ▁) ▁) ▁/ ▁2 ▁; ▁return ▁res ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁3 ▁, ▁2 ▁, ▁1 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁find Max Val By Re arr Arr ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁float ▁pair Product Mean ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁suffix Sum Array ▁[ ▁N ▁] ▁; ▁suffix Sum Array ▁[ ▁N ▁- ▁1 ▁] ▁= ▁arr ▁[ ▁N ▁- ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁N ▁- ▁2 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁suffix Sum Array ▁[ ▁i ▁] ▁= ▁suffix Sum Array ▁[ ▁i ▁+ ▁1 ▁] ▁+ ▁arr ▁[ ▁i ▁] ▁; ▁} ▁int ▁length ▁= ▁( ▁N ▁* ▁( ▁N ▁- ▁1 ▁) ▁) ▁/ ▁2 ▁; ▁float ▁res ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁res ▁+= ▁arr ▁[ ▁i ▁] ▁* ▁suffix Sum Array ▁[ ▁i ▁+ ▁1 ▁] ▁; ▁} ▁float ▁mean ▁; ▁if ▁( ▁length ▁!= ▁0 ▁) ▁mean ▁= ▁res ▁/ ▁length ▁; ▁else ▁mean ▁= ▁0 ▁; ▁return ▁mean ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁4 ▁, ▁8 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁fixed ▁<< ▁set precision ▁( ▁2 ▁) ▁<< ▁pair Product Mean ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁values _ of _ Q ▁( ▁int ▁X ▁) ▁{ ▁vector ▁< ▁int ▁> ▁val _ Q ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁X ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁( ▁( ▁X ▁+ ▁i ▁) ▁* ▁X ▁) ▁) ▁% ▁i ▁== ▁0 ▁) ▁{ ▁val _ Q ▁. ▁push _ back ▁( ▁X ▁+ ▁i ▁) ▁; ▁} ▁} ▁c out ▁<< ▁val _ Q ▁. ▁size ▁( ▁) ▁<< ▁end l ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁val _ Q ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁c out ▁<< ▁val _ Q ▁[ ▁i ▁] ▁<< ▁" ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁X ▁= ▁3 ▁; ▁values _ of _ Q ▁( ▁X ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁long ▁long ▁sum Of Fact ors ▁( ▁int ▁N ▁) ▁{ ▁long ▁long ▁ans ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁long ▁long ▁first ▁= ▁i ▁; ▁long ▁long ▁last ▁= ▁( ▁N ▁/ ▁i ▁) ▁* ▁i ▁; ▁long ▁long ▁factors ▁= ▁( ▁last ▁- ▁first ▁) ▁/ ▁i ▁+ ▁1 ▁; ▁long ▁long ▁total Contrib ution ▁= ▁( ▁( ▁( ▁factors ▁) ▁* ▁( ▁factors ▁+ ▁1 ▁) ▁) ▁/ ▁2 ▁) ▁* ▁i ▁; ▁ans ▁+= ▁total Contrib ution ▁; ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁3 ▁; ▁c out ▁<< ▁sum Of Fact ors ▁( ▁N ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max Pro fit ▁( ▁vector ▁< ▁int ▁> ▁value ▁, ▁int ▁N ▁, ▁int ▁K ▁) ▁{ ▁sort ▁( ▁value ▁. ▁begin ▁( ▁) ▁, ▁value ▁. ▁end ▁( ▁) ▁) ▁; ▁int ▁maxval ▁= ▁value ▁[ ▁N ▁- ▁1 ▁] ▁; ▁int ▁max Pro fit ▁= ▁0 ▁; ▁int ▁curr _ val ▁; ▁do ▁{ ▁curr _ val ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁curr _ val ▁+= ▁value ▁[ ▁i ▁] ▁; ▁if ▁( ▁curr _ val ▁<= ▁K ▁) ▁{ ▁max Pro fit ▁= ▁max ▁( ▁curr _ val ▁+ ▁maxval ▁* ▁( ▁i ▁+ ▁1 ▁) ▁, ▁max Pro fit ▁) ▁; ▁} ▁} ▁} ▁while ▁( ▁next _ perm utation ▁( ▁value ▁. ▁begin ▁( ▁) ▁, ▁value ▁. ▁end ▁( ▁) ▁) ▁) ▁; ▁return ▁max Pro fit ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁4 ▁, ▁K ▁= ▁6 ▁; ▁vector ▁< ▁int ▁> ▁values ▁{ ▁5 ▁, ▁2 ▁, ▁7 ▁, ▁3 ▁} ▁; ▁c out ▁<< ▁max Pro fit ▁( ▁values ▁, ▁N ▁, ▁K ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁minValue ▁( ▁int ▁n ▁) ▁{ ▁while ▁( ▁int ▁( ▁sqrt ▁( ▁n ▁) ▁) ▁== ▁sqrt ▁( ▁n ▁) ▁&& ▁n ▁> ▁1 ▁) ▁{ ▁n ▁= ▁sqrt ▁( ▁n ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁sqrt ▁( ▁n ▁) ▁; ▁i ▁> ▁1 ▁; ▁i ▁-- ▁) ▁{ ▁while ▁( ▁n ▁% ▁( ▁i ▁* ▁i ▁) ▁== ▁0 ▁) ▁n ▁/= ▁i ▁; ▁} ▁c out ▁<< ▁n ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁20 ▁; ▁minValue ▁( ▁N ▁) ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁find Direction ▁( ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁if ▁( ▁n ▁> ▁m ▁) ▁{ ▁if ▁( ▁m ▁% ▁2 ▁== ▁0 ▁) ▁printf ▁( ▁" ▁Up ▁STRNEWLINE ▁" ▁) ▁; ▁else ▁printf ▁( ▁" ▁Down ▁STRNEWLINE ▁" ▁) ▁; ▁} ▁else ▁{ ▁if ▁( ▁n ▁% ▁2 ▁== ▁0 ▁) ▁printf ▁( ▁" ▁Left ▁STRNEWLINE ▁" ▁) ▁; ▁else ▁printf ▁( ▁" ▁Right ▁STRNEWLINE ▁" ▁) ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁3 ▁, ▁m ▁= ▁3 ▁; ▁find Direction ▁( ▁n ▁, ▁m ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁int ▁N ▁= ▁1 e 5 ▁+ ▁5 ▁; ▁vector ▁< ▁vector ▁< ▁int ▁> ▁> ▁v ▁( ▁N ▁) ▁; ▁vector ▁< ▁int ▁> ▁val ▁( ▁N ▁) ▁; ▁vector ▁< ▁int ▁> ▁answer ▁( ▁N ▁) ▁; ▁int ▁n ▁; ▁int ▁gcd ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁if ▁( ▁b ▁== ▁0 ▁) ▁return ▁a ▁; ▁return ▁gcd ▁( ▁b ▁, ▁a ▁% ▁b ▁) ▁; ▁} ▁void ▁DFS ▁( ▁int ▁node ▁, ▁int ▁parent ▁) ▁{ ▁answer ▁[ ▁node ▁] ▁= ▁val ▁[ ▁node ▁] ▁; ▁for ▁( ▁int ▁child ▁: ▁v ▁[ ▁node ▁] ▁) ▁{ ▁if ▁( ▁child ▁== ▁parent ▁) ▁continue ▁; ▁DFS ▁( ▁child ▁, ▁node ▁) ▁; ▁answer ▁[ ▁node ▁] ▁= ▁gcd ▁( ▁answer ▁[ ▁node ▁] ▁, ▁answer ▁[ ▁child ▁] ▁) ▁; ▁} ▁} ▁void ▁preprocess ▁( ▁) ▁{ ▁DFS ▁( ▁1 ▁, ▁-1 ▁) ▁; ▁} ▁void ▁find G CD ▁( ▁int ▁queries ▁[ ▁] ▁, ▁int ▁q ▁) ▁{ ▁preprocess ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁q ▁; ▁i ▁++ ▁) ▁{ ▁int ▁GC D ▁= ▁answer ▁[ ▁queries ▁[ ▁i ▁] ▁] ▁; ▁c out ▁<< ▁" ▁For ▁subtree ▁of ▁" ▁<< ▁queries ▁[ ▁i ▁] ▁<< ▁" ▁, ▁GC D ▁= ▁" ▁<< ▁GC D ▁<< ▁end l ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁n ▁= ▁5 ▁; ▁v ▁[ ▁1 ▁] ▁. ▁push _ back ▁( ▁2 ▁) ▁; ▁v ▁[ ▁2 ▁] ▁. ▁push _ back ▁( ▁1 ▁) ▁; ▁v ▁[ ▁1 ▁] ▁. ▁push _ back ▁( ▁3 ▁) ▁; ▁v ▁[ ▁3 ▁] ▁. ▁push _ back ▁( ▁1 ▁) ▁; ▁v ▁[ ▁3 ▁] ▁. ▁push _ back ▁( ▁4 ▁) ▁; ▁v ▁[ ▁4 ▁] ▁. ▁push _ back ▁( ▁3 ▁) ▁; ▁v ▁[ ▁3 ▁] ▁. ▁push _ back ▁( ▁5 ▁) ▁; ▁v ▁[ ▁5 ▁] ▁. ▁push _ back ▁( ▁3 ▁) ▁; ▁val ▁[ ▁1 ▁] ▁= ▁2 ▁; ▁val ▁[ ▁2 ▁] ▁= ▁3 ▁; ▁val ▁[ ▁3 ▁] ▁= ▁4 ▁; ▁val ▁[ ▁4 ▁] ▁= ▁8 ▁; ▁val ▁[ ▁5 ▁] ▁= ▁16 ▁; ▁int ▁queries ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁3 ▁, ▁1 ▁} ▁; ▁int ▁q ▁= ▁sizeof ▁( ▁queries ▁) ▁/ ▁sizeof ▁( ▁queries ▁[ ▁0 ▁] ▁) ▁; ▁find G CD ▁( ▁queries ▁, ▁q ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁check ▁( ▁int ▁* ▁arr ▁, ▁int ▁n ▁) ▁{ ▁bool ▁flag ▁= ▁true ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁n ▁- ▁i ▁) ▁{ ▁flag ▁= ▁false ▁; ▁} ▁} ▁if ▁( ▁flag ▁) ▁{ ▁return ▁true ▁; ▁} ▁else ▁{ ▁return ▁false ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr 1 ▁[ ▁] ▁= ▁{ ▁11 ▁, ▁11 ▁, ▁11 ▁, ▁11 ▁} ▁; ▁int ▁n 1 ▁= ▁sizeof ▁( ▁arr 1 ▁) ▁/ ▁sizeof ▁( ▁arr 1 ▁[ ▁0 ▁] ▁) ▁; ▁if ▁( ▁check ▁( ▁arr 1 ▁, ▁n 1 ▁) ▁) ▁{ ▁c out ▁<< ▁" ▁Yes ▁" ▁<< ▁end l ▁; ▁} ▁else ▁{ ▁c out ▁<< ▁" ▁No ▁" ▁<< ▁end l ▁; ▁} ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁getL argest Sum ▁( ▁int ▁N ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁* ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1 ▁; ▁j ▁* ▁j ▁<= ▁N ▁; ▁j ▁++ ▁) ▁{ ▁int ▁k ▁= ▁N ▁/ ▁j ▁; ▁int ▁a ▁= ▁k ▁* ▁i ▁; ▁int ▁b ▁= ▁k ▁* ▁j ▁; ▁if ▁( ▁a ▁<= ▁N ▁&& ▁b ▁<= ▁N ▁&& ▁a ▁* ▁b ▁% ▁( ▁a ▁+ ▁b ▁) ▁== ▁0 ▁) ▁max _ sum ▁= ▁max ▁( ▁max _ sum ▁, ▁a ▁+ ▁b ▁) ▁; ▁} ▁} ▁return ▁max _ sum ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁25 ▁; ▁int ▁max _ sum ▁= ▁getL argest Sum ▁( ▁N ▁) ▁; ▁c out ▁<< ▁max _ sum ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁gcd ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁if ▁( ▁a ▁== ▁0 ▁) ▁return ▁b ▁; ▁return ▁gcd ▁( ▁b ▁% ▁a ▁, ▁a ▁) ▁; ▁} ▁int ▁l cm ▁( ▁int ▁n ▁, ▁int ▁m ▁) ▁{ ▁return ▁( ▁n ▁* ▁m ▁) ▁/ ▁gcd ▁( ▁n ▁, ▁m ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁2 ▁, ▁m ▁= ▁3 ▁, ▁k ▁= ▁5 ▁; ▁c out ▁<< ▁k ▁/ ▁l cm ▁( ▁n ▁, ▁m ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< i ost ream > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁Check For Sequence ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁n ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁k ▁>= ▁arr ▁[ ▁i ▁] ▁) ▁k ▁-= ▁arr ▁[ ▁i ▁] ▁; ▁} ▁if ▁( ▁k ▁!= ▁0 ▁) ▁return ▁false ▁; ▁else ▁return ▁true ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁3 ▁, ▁7 ▁, ▁15 ▁, ▁31 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁A ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁c out ▁<< ▁( ▁Check For Sequence ▁( ▁A ▁, ▁n ▁, ▁18 ▁) ▁? ▁" ▁True ▁" ▁: ▁" ▁False ▁" ▁) ▁<< ▁end l ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁Sub array Sum ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁x ▁) ▁{ ▁int ▁ans ▁= ▁-1 0000 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁int ▁cur ans ▁= ▁0 ▁; ▁priority _ queue ▁< ▁int ▁, ▁vector ▁< ▁int ▁> ▁> ▁pq ▁; ▁priority _ queue ▁< ▁int ▁, ▁vector ▁< ▁int ▁> ▁, ▁greater ▁< ▁int ▁> ▁> ▁pq 2 ▁; ▁for ▁( ▁int ▁k ▁= ▁0 ▁; ▁k ▁< ▁n ▁; ▁k ▁++ ▁) ▁{ ▁if ▁( ▁k ▁>= ▁i ▁&& ▁k ▁<= ▁j ▁) ▁{ ▁cur ans ▁+= ▁a ▁[ ▁k ▁] ▁; ▁pq 2 ▁. ▁push ▁( ▁a ▁[ ▁k ▁] ▁) ▁; ▁} ▁else ▁pq ▁. ▁push ▁( ▁a ▁[ ▁k ▁] ▁) ▁; ▁} ▁ans ▁= ▁max ▁( ▁ans ▁, ▁cur ans ▁) ▁; ▁for ▁( ▁int ▁k ▁= ▁1 ▁; ▁k ▁<= ▁x ▁; ▁k ▁++ ▁) ▁{ ▁if ▁( ▁pq ▁. ▁empty ▁( ▁) ▁|| ▁pq 2 ▁. ▁empty ▁( ▁) ▁|| ▁pq 2 ▁. ▁top ▁( ▁) ▁>= ▁pq ▁. ▁top ▁( ▁) ▁) ▁break ▁; ▁cur ans ▁-= ▁pq 2 ▁. ▁top ▁( ▁) ▁; ▁pq 2 ▁. ▁pop ▁( ▁) ▁; ▁cur ans ▁+= ▁pq ▁. ▁top ▁( ▁) ▁; ▁pq ▁. ▁pop ▁( ▁) ▁; ▁ans ▁= ▁max ▁( ▁ans ▁, ▁cur ans ▁) ▁; ▁} ▁} ▁} ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁5 ▁, ▁-1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁-2 ▁, ▁5 ▁} ▁, ▁x ▁= ▁2 ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁Sub array Sum ▁( ▁a ▁, ▁n ▁, ▁x ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁generate Array ▁( ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁vector ▁< ▁int ▁> ▁array ▁( ▁k ▁, ▁0 ▁) ▁; ▁int ▁remaining ▁= ▁n ▁- ▁int ▁( ▁k ▁* ▁( ▁k ▁+ ▁1 ▁) ▁/ ▁2 ▁) ▁; ▁if ▁( ▁remaining ▁< ▁0 ▁) ▁c out ▁<< ▁( ▁" ▁NO ▁" ▁) ▁; ▁int ▁right _ most ▁= ▁remaining ▁% ▁k ▁; ▁int ▁high ▁= ▁ceil ▁( ▁remaining ▁/ ▁( ▁k ▁* ▁1.0 ▁) ▁) ▁; ▁int ▁low ▁= ▁floor ▁( ▁remaining ▁/ ▁( ▁k ▁* ▁1.0 ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁k ▁- ▁right _ most ▁; ▁i ▁< ▁k ▁; ▁i ▁++ ▁) ▁array ▁[ ▁i ▁] ▁= ▁high ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁( ▁k ▁- ▁right _ most ▁) ▁; ▁i ▁++ ▁) ▁array ▁[ ▁i ▁] ▁= ▁low ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁k ▁; ▁i ▁++ ▁) ▁array ▁[ ▁i ▁] ▁+= ▁i ▁+ ▁1 ▁; ▁if ▁( ▁k ▁- ▁1 ▁!= ▁remaining ▁or ▁k ▁== ▁1 ▁) ▁{ ▁for ▁( ▁int ▁u ▁: ▁array ▁) ▁c out ▁<< ▁u ▁<< ▁" ▁" ▁; ▁} ▁else ▁if ▁( ▁k ▁== ▁2 ▁or ▁k ▁== ▁3 ▁) ▁printf ▁( ▁" ▁- ▁1 ▁STRNEWLINE ▁" ▁) ▁; ▁else ▁{ ▁array ▁[ ▁1 ▁] ▁-= ▁1 ▁; ▁array ▁[ ▁k ▁- ▁1 ▁] ▁+= ▁1 ▁; ▁for ▁( ▁int ▁u ▁: ▁array ▁) ▁c out ▁<< ▁u ▁<< ▁" ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁n ▁= ▁26 ▁, ▁k ▁= ▁6 ▁; ▁generate Array ▁( ▁n ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁max Sub Strings ▁( ▁string ▁s ▁, ▁int ▁k ▁) ▁{ ▁int ▁max Sub Str ▁= ▁0 ▁, ▁n ▁= ▁s ▁. ▁size ▁( ▁) ▁; ▁for ▁( ▁int ▁c ▁= ▁0 ▁; ▁c ▁< ▁26 ▁; ▁c ▁++ ▁) ▁{ ▁char ▁ch ▁= ▁' ▁a ▁' ▁+ ▁c ▁; ▁int ▁curr ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁n ▁- ▁k ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁[ ▁i ▁] ▁!= ▁ch ▁) ▁continue ▁; ▁int ▁cnt ▁= ▁0 ▁; ▁while ▁( ▁i ▁< ▁n ▁&& ▁s ▁[ ▁i ▁] ▁== ▁ch ▁&& ▁cnt ▁!= ▁k ▁) ▁{ ▁i ▁++ ▁; ▁cnt ▁++ ▁; ▁} ▁i ▁-- ▁; ▁if ▁( ▁cnt ▁== ▁k ▁) ▁curr ▁++ ▁; ▁} ▁max Sub Str ▁= ▁max ▁( ▁max Sub Str ▁, ▁curr ▁) ▁; ▁} ▁return ▁max Sub Str ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁string ▁s ▁= ▁" ▁aa ac a abb aa ▁" ▁; ▁int ▁k ▁= ▁2 ▁; ▁c out ▁<< ▁max Sub Strings ▁( ▁s ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁min Cost ▁( ▁int ▁N ▁, ▁int ▁P ▁, ▁int ▁Q ▁) ▁{ ▁int ▁cost ▁= ▁0 ▁; ▁while ▁( ▁N ▁> ▁0 ▁) ▁{ ▁if ▁( ▁N ▁& ▁1 ▁) ▁{ ▁cost ▁+= ▁P ▁; ▁N ▁-- ▁; ▁} ▁else ▁{ ▁int ▁temp ▁= ▁N ▁/ ▁2 ▁; ▁if ▁( ▁temp ▁* ▁P ▁> ▁Q ▁) ▁cost ▁+= ▁Q ▁; ▁else ▁cost ▁+= ▁P ▁* ▁temp ▁; ▁N ▁/= ▁2 ▁; ▁} ▁} ▁return ▁cost ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁9 ▁, ▁P ▁= ▁5 ▁, ▁Q ▁= ▁1 ▁; ▁c out ▁<< ▁min Cost ▁( ▁N ▁, ▁P ▁, ▁Q ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁solve ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁b ▁[ ▁] ▁, ▁int ▁n ▁) ▁{ ▁int ▁i ▁; ▁long ▁long ▁int ▁s ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁s ▁+= ▁( ▁a ▁[ ▁i ▁] ▁+ ▁b ▁[ ▁i ▁] ▁) ▁; ▁if ▁( ▁n ▁== ▁1 ▁) ▁return ▁a ▁[ ▁0 ▁] ▁+ ▁b ▁[ ▁0 ▁] ▁; ▁if ▁( ▁s ▁% ▁n ▁!= ▁0 ▁) ▁return ▁-1 ▁; ▁int ▁x ▁= ▁s ▁/ ▁n ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁a ▁[ ▁i ▁] ▁> ▁x ▁) ▁return ▁-1 ▁; ▁if ▁( ▁i ▁> ▁0 ▁) ▁{ ▁a ▁[ ▁i ▁] ▁+= ▁b ▁[ ▁i ▁- ▁1 ▁] ▁; ▁b ▁[ ▁i ▁- ▁1 ▁] ▁= ▁0 ▁; ▁} ▁if ▁( ▁a ▁[ ▁i ▁] ▁== ▁x ▁) ▁continue ▁; ▁int ▁y ▁= ▁a ▁[ ▁i ▁] ▁+ ▁b ▁[ ▁i ▁] ▁; ▁if ▁( ▁i ▁+ ▁1 ▁< ▁n ▁) ▁y ▁+= ▁b ▁[ ▁i ▁+ ▁1 ▁] ▁; ▁if ▁( ▁y ▁== ▁x ▁) ▁{ ▁a ▁[ ▁i ▁] ▁= ▁y ▁; ▁b ▁[ ▁i ▁] ▁= ▁b ▁[ ▁i ▁+ ▁1 ▁] ▁= ▁0 ▁; ▁continue ▁; ▁} ▁if ▁( ▁a ▁[ ▁i ▁] ▁+ ▁b ▁[ ▁i ▁] ▁== ▁x ▁) ▁{ ▁a ▁[ ▁i ▁] ▁+= ▁b ▁[ ▁i ▁] ▁; ▁b ▁[ ▁i ▁] ▁= ▁0 ▁; ▁continue ▁; ▁} ▁if ▁( ▁i ▁+ ▁1 ▁< ▁n ▁&& ▁a ▁[ ▁i ▁] ▁+ ▁b ▁[ ▁i ▁+ ▁1 ▁] ▁== ▁x ▁) ▁{ ▁a ▁[ ▁i ▁] ▁+= ▁b ▁[ ▁i ▁+ ▁1 ▁] ▁; ▁b ▁[ ▁i ▁+ ▁1 ▁] ▁= ▁0 ▁; ▁continue ▁; ▁} ▁return ▁-1 ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁if ▁( ▁b ▁[ ▁i ▁] ▁!= ▁0 ▁) ▁return ▁-1 ▁; ▁return ▁x ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁6 ▁, ▁14 ▁, ▁21 ▁, ▁1 ▁} ▁; ▁int ▁b ▁[ ▁] ▁= ▁{ ▁15 ▁, ▁7 ▁, ▁10 ▁, ▁10 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁a ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁solve ▁( ▁a ▁, ▁b ▁, ▁n ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁void ▁surv ival ▁( ▁int ▁S ▁, ▁int ▁N ▁, ▁int ▁M ▁) ▁{ ▁if ▁( ▁( ▁( ▁N ▁* ▁6 ▁) ▁< ▁( ▁M ▁* ▁7 ▁) ▁&& ▁S ▁> ▁6 ▁) ▁M ▁> ▁N ▁) ▁c out ▁<< ▁" ▁No ▁STRNEWLINE ▁" ▁; ▁else ▁{ ▁int ▁days ▁= ▁( ▁M ▁* ▁S ▁) ▁/ ▁N ▁; ▁if ▁( ▁( ▁( ▁M ▁* ▁S ▁) ▁% ▁N ▁) ▁!= ▁0 ▁) ▁days ▁++ ▁; ▁c out ▁<< ▁" ▁Yes ▁" ▁<< ▁days ▁<< ▁end l ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁S ▁= ▁10 ▁, ▁N ▁= ▁16 ▁, ▁M ▁= ▁2 ▁; ▁surv ival ▁( ▁S ▁, ▁N ▁, ▁M ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁Long est Odd Even Sub array ▁( ▁int ▁A ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁dp ▁[ ▁N ▁] ▁; ▁dp ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁int ▁ans ▁= ▁1 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁A ▁[ ▁i ▁] ▁% ▁2 ▁== ▁0 ▁&& ▁A ▁[ ▁i ▁- ▁1 ▁] ▁% ▁2 ▁== ▁0 ▁) ▁|| ▁( ▁A ▁[ ▁i ▁] ▁% ▁2 ▁!= ▁0 ▁&& ▁A ▁[ ▁i ▁- ▁1 ▁] ▁% ▁2 ▁!= ▁0 ▁) ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁= ▁dp ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁1 ▁; ▁} ▁else ▁dp ▁[ ▁i ▁] ▁= ▁1 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁ans ▁= ▁max ▁( ▁ans ▁, ▁dp ▁[ ▁i ▁] ▁) ▁; ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁A ▁[ ▁] ▁= ▁{ ▁2 ▁, ▁5 ▁, ▁7 ▁, ▁2 ▁, ▁4 ▁, ▁6 ▁, ▁8 ▁, ▁3 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁A ▁) ▁/ ▁sizeof ▁( ▁A ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁Long est Odd Even Sub array ▁( ▁A ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁getValue ▁( ▁int ▁arr ▁[ ▁] ▁, ▁int ▁N ▁) ▁{ ▁int ▁dp ▁[ ▁N ▁] ▁; ▁mem set ▁( ▁dp ▁, ▁0 ▁, ▁sizeof ▁( ▁dp ▁) ▁) ▁; ▁dp ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁N ▁; ▁i ▁++ ▁) ▁{ ▁int ▁min n ▁= ▁arr ▁[ ▁i ▁] ▁; ▁int ▁max x ▁= ▁arr ▁[ ▁i ▁] ▁; ▁for ▁( ▁int ▁j ▁= ▁i ▁; ▁j ▁>= ▁0 ▁; ▁j ▁-- ▁) ▁{ ▁min n ▁= ▁min ▁( ▁arr ▁[ ▁j ▁] ▁, ▁min n ▁) ▁; ▁max x ▁= ▁max ▁( ▁arr ▁[ ▁j ▁] ▁, ▁max x ▁) ▁; ▁dp ▁[ ▁i ▁] ▁= ▁max ▁( ▁dp ▁[ ▁i ▁] ▁, ▁max x ▁- ▁min n ▁+ ▁( ▁( ▁j ▁>= ▁1 ▁) ▁? ▁dp ▁[ ▁j ▁- ▁1 ▁] ▁: ▁0 ▁) ▁) ▁; ▁} ▁} ▁return ▁dp ▁[ ▁N ▁- ▁1 ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁arr ▁[ ▁] ▁= ▁{ ▁8 ▁, ▁1 ▁, ▁7 ▁, ▁9 ▁, ▁2 ▁} ▁; ▁int ▁N ▁= ▁sizeof ▁( ▁arr ▁) ▁/ ▁sizeof ▁( ▁arr ▁[ ▁0 ▁] ▁) ▁; ▁c out ▁<< ▁getValue ▁( ▁arr ▁, ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁int ▁reduce Zero ▁( ▁int ▁N ▁) ▁{ ▁vector ▁< ▁int ▁> ▁dp ▁( ▁N ▁+ ▁1 ▁, ▁1 e 9 ▁) ▁; ▁dp ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁<= ▁N ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁char ▁c ▁: ▁to _ string ▁( ▁i ▁) ▁) ▁{ ▁dp ▁[ ▁i ▁] ▁= ▁min ▁( ▁dp ▁[ ▁i ▁] ▁, ▁dp ▁[ ▁i ▁- ▁( ▁c ▁- ▁'0' ▁) ▁] ▁+ ▁1 ▁) ▁; ▁} ▁} ▁return ▁dp ▁[ ▁N ▁] ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁25 ▁; ▁c out ▁<< ▁reduce Zero ▁( ▁N ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁bool ▁prime ▁[ ▁10000 1 ▁] ▁; ▁void ▁S ieve Of E rat ost hen es ▁( ▁) ▁{ ▁mem set ▁( ▁prime ▁, ▁true ▁, ▁sizeof ▁( ▁prime ▁) ▁) ▁; ▁prime ▁[ ▁0 ▁] ▁= ▁prime ▁[ ▁1 ▁] ▁= ▁false ▁; ▁for ▁( ▁int ▁p ▁= ▁2 ▁; ▁p ▁* ▁p ▁<= ▁100000 ▁; ▁p ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁p ▁] ▁== ▁true ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁p ▁* ▁p ▁; ▁i ▁<= ▁100000 ▁; ▁i ▁+= ▁p ▁) ▁prime ▁[ ▁i ▁] ▁= ▁false ▁; ▁} ▁} ▁} ▁int ▁distinct Prime Sub Seq ▁( ▁int ▁a ▁[ ▁] ▁, ▁int ▁n ▁, ▁int ▁k ▁) ▁{ ▁S ieve Of E rat ost hen es ▁( ▁) ▁; ▁vector ▁< ▁int ▁> ▁primes ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁prime ▁[ ▁a ▁[ ▁i ▁] ▁] ▁) ▁primes ▁. ▁push _ back ▁( ▁a ▁[ ▁i ▁] ▁) ▁; ▁} ▁int ▁l ▁= ▁primes ▁. ▁size ▁( ▁) ▁; ▁sort ▁( ▁primes ▁. ▁begin ▁( ▁) ▁, ▁primes ▁. ▁end ▁( ▁) ▁) ▁; ▁vector ▁< ▁int ▁> ▁b ▁; ▁vector ▁< ▁int ▁> ▁dp ▁; ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁l ▁; ▁) ▁{ ▁int ▁count ▁= ▁1 ▁, ▁x ▁= ▁a ▁[ ▁i ▁] ▁; ▁i ▁++ ▁; ▁while ▁( ▁i ▁< ▁l ▁&& ▁a ▁[ ▁i ▁] ▁== ▁x ▁) ▁{ ▁count ▁++ ▁; ▁i ▁++ ▁; ▁} ▁b ▁. ▁push _ back ▁( ▁count ▁) ▁; ▁dp ▁. ▁push _ back ▁( ▁count ▁) ▁; ▁sum ▁+= ▁count ▁; ▁} ▁int ▁of _ length ▁= ▁2 ▁; ▁int ▁len ▁= ▁dp ▁. ▁size ▁( ▁) ▁; ▁int ▁ans ▁= ▁0 ▁; ▁while ▁( ▁of _ length ▁<= ▁k ▁) ▁{ ▁int ▁freq ▁= ▁0 ▁; ▁int ▁prev ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁( ▁len ▁- ▁1 ▁) ▁; ▁i ▁++ ▁) ▁{ ▁freq ▁+= ▁dp ▁[ ▁i ▁] ▁; ▁int ▁j ▁= ▁sum ▁- ▁freq ▁; ▁int ▁sub seq ▁= ▁b ▁[ ▁i ▁] ▁* ▁j ▁; ▁ans ▁+= ▁sub seq ▁; ▁dp ▁[ ▁i ▁] ▁= ▁sub seq ▁; ▁prev ▁+= ▁dp ▁[ ▁i ▁] ▁; ▁} ▁len ▁-- ▁; ▁sum ▁= ▁prev ▁; ▁of _ length ▁++ ▁; ▁} ▁ans ▁+= ▁( ▁l ▁+ ▁1 ▁) ▁; ▁return ▁ans ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁a ▁[ ▁] ▁= ▁{ ▁1 ▁, ▁2 ▁, ▁2 ▁, ▁3 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁int ▁n ▁= ▁sizeof ▁( ▁a ▁) ▁/ ▁sizeof ▁( ▁int ▁) ▁; ▁int ▁k ▁= ▁3 ▁; ▁c out ▁<< ▁distinct Prime Sub Seq ▁( ▁a ▁, ▁n ▁, ▁k ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁int ▁mod ▁= ▁100 000000 7 ▁; ▁int ▁dp ▁[ ▁1000 ▁] ▁[ ▁1000 ▁] ▁; ▁int ▁calculate ▁( ▁int ▁pos ▁, ▁int ▁left ▁, ▁int ▁k ▁, ▁int ▁L ▁, ▁int ▁R ▁) ▁{ ▁if ▁( ▁pos ▁== ▁k ▁) ▁{ ▁if ▁( ▁left ▁== ▁0 ▁) ▁return ▁1 ▁; ▁else ▁return ▁0 ▁; ▁} ▁if ▁( ▁left ▁== ▁0 ▁) ▁return ▁0 ▁; ▁if ▁( ▁dp ▁[ ▁pos ▁] ▁[ ▁left ▁] ▁!= ▁-1 ▁) ▁return ▁dp ▁[ ▁pos ▁] ▁[ ▁left ▁] ▁; ▁int ▁answer ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁L ▁; ▁i ▁<= ▁R ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁> ▁left ▁) ▁break ▁; ▁answer ▁= ▁( ▁answer ▁+ ▁calculate ▁( ▁pos ▁+ ▁1 ▁, ▁left ▁- ▁i ▁, ▁k ▁, ▁L ▁, ▁R ▁) ▁) ▁% ▁mod ▁; ▁} ▁return ▁dp ▁[ ▁pos ▁] ▁[ ▁left ▁] ▁= ▁answer ▁; ▁} ▁int ▁count Way sto Div ide ▁( ▁int ▁n ▁, ▁int ▁k ▁, ▁int ▁L ▁, ▁int ▁R ▁) ▁{ ▁mem set ▁( ▁dp ▁, ▁-1 ▁, ▁sizeof ▁( ▁dp ▁) ▁) ▁; ▁return ▁calculate ▁( ▁0 ▁, ▁n ▁, ▁k ▁, ▁L ▁, ▁R ▁) ▁; ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁N ▁= ▁12 ▁; ▁int ▁K ▁= ▁3 ▁; ▁int ▁L ▁= ▁1 ▁; ▁int ▁R ▁= ▁5 ▁; ▁c out ▁<< ▁count Way sto Div ide ▁( ▁N ▁, ▁K ▁, ▁L ▁, ▁R ▁) ▁; ▁return ▁0 ▁; ▁}
▁# include ▁< bits / std c ++. h > ▁NEW _ LINE ▁using ▁namespace ▁std ▁; ▁const ▁int ▁MAX ▁= ▁100 ▁; ▁void ▁largest Square ▁( ▁int ▁matrix ▁[ ▁] ▁[ ▁MAX ▁] ▁, ▁int ▁R ▁, ▁int ▁C ▁, ▁int ▁q _ i ▁[ ▁] ▁, ▁int ▁q _ j ▁[ ▁] ▁, ▁int ▁K ▁, ▁int ▁Q ▁) ▁{ ▁int ▁count DP ▁[ ▁R ▁] ▁[ ▁C ▁] ▁; ▁mem set ▁( ▁count DP ▁, ▁0 ▁, ▁sizeof ▁( ▁count DP ▁) ▁) ▁; ▁count DP ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁= ▁matrix ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁R ▁; ▁i ▁++ ▁) ▁count DP ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁= ▁count DP ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁0 ▁] ▁+ ▁matrix ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁; ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁< ▁C ▁; ▁j ▁++ ▁) ▁count DP ▁[ ▁0 ▁] ▁[ ▁j ▁] ▁= ▁count DP ▁[ ▁0 ▁] ▁[ ▁j ▁- ▁1 ▁] ▁+ ▁matrix ▁[ ▁0 ▁] ▁[ ▁j ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁R ▁; ▁i ▁++ ▁) ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁< ▁C ▁; ▁j ▁++ ▁) ▁count DP ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁matrix ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+ ▁count DP ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁+ ▁count DP ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁- ▁count DP ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁- ▁1 ▁] ▁; ▁for ▁( ▁int ▁q ▁= ▁0 ▁; ▁q ▁< ▁Q ▁; ▁q ▁++ ▁) ▁{ ▁int ▁i ▁= ▁q _ i ▁[ ▁q ▁] ▁; ▁int ▁j ▁= ▁q _ j ▁[ ▁q ▁] ▁; ▁int ▁min _ dist ▁= ▁min ▁( ▁min ▁( ▁i ▁, ▁j ▁) ▁, ▁min ▁( ▁R ▁- ▁i ▁- ▁1 ▁, ▁C ▁- ▁j ▁- ▁1 ▁) ▁) ▁; ▁int ▁ans ▁= ▁-1 ▁, ▁l ▁= ▁0 ▁, ▁u ▁= ▁min _ dist ▁; ▁while ▁( ▁l ▁<= ▁u ▁) ▁{ ▁int ▁mid ▁= ▁( ▁l ▁+ ▁u ▁) ▁/ ▁2 ▁; ▁int ▁x 1 ▁= ▁i ▁- ▁mid ▁, ▁x 2 ▁= ▁i ▁+ ▁mid ▁; ▁int ▁y 1 ▁= ▁j ▁- ▁mid ▁, ▁y 2 ▁= ▁j ▁+ ▁mid ▁; ▁int ▁count ▁= ▁count DP ▁[ ▁x 2 ▁] ▁[ ▁y 2 ▁] ▁; ▁if ▁( ▁x 1 ▁> ▁0 ▁) ▁count ▁-= ▁count DP ▁[ ▁x 1 ▁- ▁1 ▁] ▁[ ▁y 2 ▁] ▁; ▁if ▁( ▁y 1 ▁> ▁0 ▁) ▁count ▁-= ▁count DP ▁[ ▁x 2 ▁] ▁[ ▁y 1 ▁- ▁1 ▁] ▁; ▁if ▁( ▁x 1 ▁> ▁0 ▁&& ▁y 1 ▁> ▁0 ▁) ▁count ▁+= ▁count DP ▁[ ▁x 1 ▁- ▁1 ▁] ▁[ ▁y 1 ▁- ▁1 ▁] ▁; ▁if ▁( ▁count ▁<= ▁K ▁) ▁{ ▁ans ▁= ▁2 ▁* ▁mid ▁+ ▁1 ▁; ▁l ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁else ▁u ▁= ▁mid ▁- ▁1 ▁; ▁} ▁c out ▁<< ▁ans ▁<< ▁" ▁STRNEWLINE ▁" ▁; ▁} ▁} ▁int ▁main ▁( ▁) ▁{ ▁int ▁matrix ▁[ ▁] ▁[ ▁MAX ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁} ▁, ▁{ ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁} ▁} ▁; ▁int ▁K ▁= ▁9 ▁, ▁Q ▁= ▁1 ▁; ▁int ▁q _ i ▁[ ▁] ▁= ▁{ ▁1 ▁} ▁; ▁int ▁q _ j ▁[ ▁] ▁= ▁{ ▁2 ▁} ▁; ▁largest Square ▁( ▁matrix ▁, ▁4 ▁, ▁5 ▁, ▁q _ i ▁, ▁q _ j ▁, ▁K ▁, ▁Q ▁) ▁; ▁return ▁0 ▁; ▁}
