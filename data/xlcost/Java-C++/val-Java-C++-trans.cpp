The Stock Span Problem 1010 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void calculate@@ Span ( int price [ ] , int n , int S [ ] ) { S [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { S [ i ] = 1 ; for ( int j = i - 1 ; ( j >= 0 ) && ( price [ i ] >= price [ j ] ) ; j -- ) S [ i ] ++ ; } } void print@@ Array ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; } int main ( ) { int price [ ] = { 10 , 4 , 5 , 90 , 120 , 80 } ; int n = sizeof ( price ) / sizeof ( price [ 0 ] ) ; int S [ n ] ; calculate@@ Span ( price , n , S ) ; print@@ Array ( S , n ) ; return 0 ; }
Next Greater Element 1015 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; void print@@ N@@ GE ( int arr [ ] , int n ) { int next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = -1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { next = arr [ j ] ; break ; } } cout << arr [ i ] << " ▁ - - ▁ " << next << endl ; } } int main ( ) { int arr [ ] = { 11 , 13 , 21 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; print@@ N@@ GE ( arr , n ) ; return 0 ; }
Form minimum number from given sequence 1074 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void Print@@ Min@@ Number@@ For@@ Pattern ( string seq ) { string result ; stack < int > stk ; for ( int i = 0 ; i <= seq . length ( ) ; i ++ ) { stk . push ( i + 1 ) ; if ( i == seq . length ( ) seq [ i ] == ' I ' ) { while ( ! stk . empty ( ) ) { result += to_string ( stk . top ( ) ) ; result += " ▁ " ; stk . pop ( ) ; } } } cout << result << endl ; } int main ( ) { Print@@ Min@@ Number@@ For@@ Pattern ( " ID@@ ID " ) ; Print@@ Min@@ Number@@ For@@ Pattern ( " I " ) ; Print@@ Min@@ Number@@ For@@ Pattern ( " DD " ) ; Print@@ Min@@ Number@@ For@@ Pattern ( " II " ) ; Print@@ Min@@ Number@@ For@@ Pattern ( " D@@ ID@@ I " ) ; Print@@ Min@@ Number@@ For@@ Pattern ( " I@@ ID@@ DD " ) ; Print@@ Min@@ Number@@ For@@ Pattern ( " DD@@ ID@@ DI@@ ID " ) ; return 0 ; }
Most frequ@@ ent element in an array 1222 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int most@@ Frequ@@ ent ( int arr [ ] , int n ) { unordered_map < int , int > hash ; for ( int i = 0 ; i < n ; i ++ ) hash [ arr [ i ] ] ++ ; int max_@@ count = 0 , res = -1 ; for ( auto i : hash ) { if ( max_@@ count < i . second ) { res = i . first ; max_@@ count = i . second ; } } return res ; } int main ( ) { int arr [ ] = { 1 , 5 , 2 , 1 , 3 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << most@@ Frequ@@ ent ( arr , n ) ; return 0 ; }
Find elements which are present in first array and not in second 1239 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ Missing ( int a [ ] , int b [ ] , int n , int m ) { unordered_@@ set < int > s ; for ( int i = 0 ; i < m ; i ++ ) s . insert ( b [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) if ( s . find ( a [ i ] ) == s . end ( ) ) cout << a [ i ] << " ▁ " ; } int main ( ) { int a [ ] = { 1 , 2 , 6 , 3 , 4 , 5 } ; int b [ ] = { 2 , 4 , 3 , 1 , 0 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int m = sizeof ( b ) / sizeof ( b [ 1 ] ) ; find@@ Missing ( a , b , n , m ) ; return 0 ; }
Minimum number of subsets with distinct elements 1252 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int subset ( int ar [ ] , int n ) { int res = 0 ; sort ( ar , ar + n ) ; for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ; for ( ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) count ++ ; else break ; } res = max ( res , count ) ; } return res ; } int main ( ) { int arr [ ] = { 5 , 6 , 9 , 3 , 4 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << subset ( arr , n ) ; return 0 ; }
Change the array into a permutation of numbers from 1 to n 1268 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void make@@ Permutation ( int a [ ] , int n ) { unordered_map < int , int > count ; for ( int i = 0 ; i < n ; i ++ ) count [ a [ i ] ] ++ ; int next_@@ missing = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( count [ a [ i ] ] != 1 a [ i ] > n a [ i ] < 1 ) { count [ a [ i ] ] -- ; while ( count . find ( next_@@ missing ) != count . end ( ) ) next_@@ missing ++ ; a [ i ] = next_@@ missing ; count [ next_@@ missing ] = 1 ; } } } int main ( ) { int A [ ] = { 2 , 2 , 3 , 3 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; make@@ Permutation ( A , n ) ; for ( int i = 0 ; i < n ; i ++ ) cout << A [ i ] << " ▁ " ; return 0 ; }
Number of sub@@ arrays having sum exactly equal to k 1282 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int main ( ) { int arr [ ] = { 10 , 2 , -2 , -@@ 20 , 10 } ; int k = -@@ 10 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = i ; j < n ; j ++ ) { sum += arr [ j ] ; if ( sum == k ) res ++ ; } } cout << ( res ) << endl ; }
Given two un@@ sorted arrays , find all pairs whose sum is x 1288 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ Pairs ( int ar@@ r1 [ ] , int ar@@ r2 [ ] , int n , int m , int x ) { unordered_@@ set < int > s ; for ( int i = 0 ; i < n ; i ++ ) s . insert ( ar@@ r1 [ i ] ) ; for ( int j = 0 ; j < m ; j ++ ) if ( s . find ( x - ar@@ r2 [ j ] ) != s . end ( ) ) cout << x - ar@@ r2 [ j ] << " ▁ " << ar@@ r2 [ j ] << endl ; } int main ( ) { int ar@@ r1 [ ] = { 1 , 0 , -@@ 4 , 7 , 6 , 4 } ; int ar@@ r2 [ ] = { 0 , 2 , 4 , -@@ 3 , 2 , 1 } ; int x = 8 ; int n = sizeof ( ar@@ r1 ) / sizeof ( int ) ; int m = sizeof ( ar@@ r2 ) / sizeof ( int ) ; find@@ Pairs ( ar@@ r1 , ar@@ r2 , n , m , x ) ; return 0 ; }
Find three element from different three arrays such that a + b + c = sum 1326 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool find@@ Trip@@ let ( int a1 [ ] , int a2 [ ] , int a3 [ ] , int n1 , int n2 , int n3 , int sum ) { for ( int i = 0 ; i < n1 ; i ++ ) for ( int j = 0 ; j < n2 ; j ++ ) for ( int k = 0 ; k < n3 ; k ++ ) if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) return true ; return false ; } int main ( ) { int a1 [ ] = { 1 , 2 , 3 , 4 , 5 } ; int a2 [ ] = { 2 , 3 , 6 , 1 , 2 } ; int a3 [ ] = { 3 , 2 , 4 , 5 , 6 } ; int sum = 9 ; int n1 = sizeof ( a1 ) / sizeof ( a1 [ 0 ] ) ; int n2 = sizeof ( a2 ) / sizeof ( a2 [ 0 ] ) ; int n3 = sizeof ( a3 ) / sizeof ( a3 [ 0 ] ) ; find@@ Trip@@ let ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) ? cout << " Yes " : cout << " No " ; return 0 ; }
Lon@@ gest sub@@ array not having more than K distinct elements 1366 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void longest ( int a [ ] , int n , int k ) { unordered_map < int , int > freq ; int start = 0 , end = 0 , now = 0 , l = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq [ a [ i ] ] ++ ; if ( freq [ a [ i ] ] == 1 ) now ++ ; while ( now > k ) { freq [ a [ l ] ] -- ; if ( freq [ a [ l ] ] == 0 ) now -- ; l ++ ; } if ( i - l + 1 >= end - start + 1 ) end = i , start = l ; } for ( int i = start ; i <= end ; i ++ ) cout << a [ i ] << " ▁ " ; } int main ( ) { int a [ ] = { 6 , 5 , 1 , 2 , 3 , 2 , 1 , 4 , 5 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int k = 3 ; longest ( a , n , k ) ; return 0 ; }
Lar@@ gest sub@@ array with equal number of 0 s and 1 s 1373 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Sub@@ Array ( int arr [ ] , int n ) { int sum = 0 ; int maxsize = -1 , start@@ index ; for ( int i = 0 ; i < n - 1 ; i ++ ) { sum = ( arr [ i ] == 0 ) ? -1 : 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { ( arr [ j ] == 0 ) ? ( sum += -1 ) : ( sum += 1 ) ; if ( sum == 0 && maxsize < j - i + 1 ) { maxsize = j - i + 1 ; start@@ index = i ; } } } if ( maxsize == -1 ) cout << " No ▁ such ▁ sub@@ array " ; else cout << start@@ index << " ▁ to ▁ " << start@@ index + maxsize - 1 ; return maxsize ; } int main ( ) { int arr [ ] = { 1 , 0 , 0 , 1 , 0 , 1 , 1 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; find@@ Sub@@ Array ( arr , size ) ; return 0 ; }
Print all trip@@ lets in sorted array that form AP 1379 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ All@@ AP@@ Trip@@ lets ( int arr [ ] , int n ) { for ( int i = 1 ; i < n - 1 ; i ++ ) { for ( int j = i - 1 , k = i + 1 ; j >= 0 && k < n ; ) { if ( arr [ j ] + arr [ k ] == 2 * arr [ i ] ) { cout << arr [ j ] << " ▁ " << arr [ i ] << " ▁ " << arr [ k ] << endl ; k ++ ; j -- ; } else if ( arr [ j ] + arr [ k ] < 2 * arr [ i ] ) k ++ ; else j -- ; } } } int main ( ) { int arr [ ] = { 2 , 6 , 9 , 12 , 17 , 22 , 31 , 32 , 35 , 42 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; print@@ All@@ AP@@ Trip@@ lets ( arr , n ) ; return 0 ; }
All unique trip@@ lets that sum up to a given value 1381 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ Trip@@ lets ( int a [ ] , int n , int sum ) { int i ; sort ( a , a + n ) ; bool flag = false ; for ( i = 0 ; i < n - 2 ; i ++ ) { if ( i == 0 a [ i ] > a [ i - 1 ] ) { int start = i + 1 ; int end = n - 1 ; int target = sum - a [ i ] ; while ( start < end ) { if ( start > i + 1 && a [ start ] == a [ start - 1 ] ) { start ++ ; continue ; } if ( end < n - 1 && a [ end ] == a [ end + 1 ] ) { end -- ; continue ; } if ( target == a [ start ] + a [ end ] ) { cout << " [ " << a [ i ] << " , " << a [ start ] << " , " << a [ end ] << " ] ▁ " ; flag = true ; start ++ ; end -- ; } else if ( target > ( a [ start ] + a [ end ] ) ) { start ++ ; } else { end -- ; } } } } if ( flag == false ) { cout << " No ▁ Such ▁ Trip@@ lets ▁ Exist " << " STRNEWLINE " ; } } int main ( ) { int a [ ] = { 12 , 3 , 6 , 1 , 6 , 9 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int sum = 24 ; find@@ Trip@@ lets ( a , n , sum ) ; return 0 ; }
Count number of trip@@ lets with product equal to given number 1385 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int count@@ Trip@@ lets ( int arr [ ] , int n , int m ) { int count = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) for ( int j = i + 1 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] * arr [ j ] * arr [ k ] == m ) count ++ ; return count ; } int main ( ) { int arr [ ] = { 1 , 4 , 6 , 2 , 3 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int m = 24 ; cout << count@@ Trip@@ lets ( arr , n , m ) ; return 0 ; }
Sub@@ arrays with distinct elements 1397 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int su@@ mo@@ f@@ length ( int arr [ ] , int n ) { unordered_@@ set < int > s ; int j = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( j < n && s . find ( arr [ j ] ) == s . end ( ) ) { s . insert ( arr [ j ] ) ; j ++ ; } ans += ( ( j - i ) * ( j - i + 1 ) ) / 2 ; s . erase ( arr [ i ] ) ; } return ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << su@@ mo@@ f@@ length ( arr , n ) << endl ; return 0 ; }
Program for array rotation 1428 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void left@@ Rotate@@ by@@ One ( int arr [ ] , int n ) { int temp = arr [ 0 ] , i ; for ( i = 0 ; i < n - 1 ; i ++ ) arr [ i ] = arr [ i + 1 ] ; arr [ n - 1 ] = temp ; } void left@@ Rotate ( int arr [ ] , int d , int n ) { for ( int i = 0 ; i < d ; i ++ ) left@@ Rotate@@ by@@ One ( arr , n ) ; } void print@@ Array ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; left@@ Rotate ( arr , 2 , n ) ; print@@ Array ( arr , n ) ; return 0 ; }
Search an element in a sorted and rotated array 1436 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int search ( int arr [ ] , int l , int h , int key ) { if ( l > h ) return -1 ; int mid = ( l + h ) / 2 ; if ( arr [ mid ] == key ) return mid ; if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ; return search ( arr , mid + 1 , h , key ) ; } if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; } int main ( ) { int arr [ ] = { 4 , 5 , 6 , 7 , 8 , 9 , 1 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int key = 6 ; int i = search ( arr , 0 , n - 1 , key ) ; if ( i != -1 ) cout << " Index : ▁ " << i << endl ; else cout << " Key ▁ not ▁ found " ; }
Given a sorted and rotated array , find if there is a pair with a given sum 1437 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; bool pair@@ In@@ Sorted@@ Rot@@ ated ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; int l = ( i + 1 ) % n ; int r = i ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) return true ; if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return false ; } int main ( ) { int arr [ ] = { 11 , 15 , 6 , 8 , 9 , 10 } ; int sum = 16 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( pair@@ In@@ Sorted@@ Rot@@ ated ( arr , n , sum ) ) cout << " Array ▁ has ▁ two ▁ elements ▁ with ▁ sum ▁ 16" ; else cout << " Array ▁ doesn ' t ▁ have ▁ two ▁ elements ▁ with ▁ sum ▁ 16 ▁ " ; return 0 ; }
Quick@@ ly find multiple left rot@@ ations of an array | Set 1 1446 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void left@@ Rotate ( int arr [ ] , int n , int k ) { for ( int i = k ; i < k + n ; i ++ ) cout << arr [ i % n ] << " ▁ " ; } int main ( ) { int arr [ ] = { 1 , 3 , 5 , 7 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ; left@@ Rotate ( arr , n , k ) ; cout << endl ; k = 3 ; left@@ Rotate ( arr , n , k ) ; cout << endl ; k = 4 ; left@@ Rotate ( arr , n , k ) ; cout << endl ; return 0 ; }
Find the minimum element in a sorted and rotated array 1447 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Min ( int arr [ ] , int low , int high ) { if ( high < low ) return arr [ 0 ] ; if ( high == low ) return arr [ low ] ; int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return arr [ mid + 1 ] ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ high ] > arr [ mid ] ) return find@@ Min ( arr , low , mid - 1 ) ; return find@@ Min ( arr , mid + 1 , high ) ; } int main ( ) { int ar@@ r1 [ ] = { 5 , 6 , 1 , 2 , 3 , 4 } ; int n1 = sizeof ( ar@@ r1 ) / sizeof ( ar@@ r1 [ 0 ] ) ; cout << " The ▁ minimum ▁ element ▁ is ▁ " << find@@ Min ( ar@@ r1 , 0 , n1 - 1 ) << endl ; int ar@@ r2 [ ] = { 1 , 2 , 3 , 4 } ; int n2 = sizeof ( ar@@ r2 ) / sizeof ( ar@@ r2 [ 0 ] ) ; cout << " The ▁ minimum ▁ element ▁ is ▁ " << find@@ Min ( ar@@ r2 , 0 , n2 - 1 ) << endl ; int arr@@ 3 [ ] = { 1 } ; int n3 = sizeof ( arr@@ 3 ) / sizeof ( arr@@ 3 [ 0 ] ) ; cout << " The ▁ minimum ▁ element ▁ is ▁ " << find@@ Min ( arr@@ 3 , 0 , n3 - 1 ) << endl ; int arr@@ 4 [ ] = { 1 , 2 } ; int n@@ 4 = sizeof ( arr@@ 4 ) / sizeof ( arr@@ 4 [ 0 ] ) ; cout << " The ▁ minimum ▁ element ▁ is ▁ " << find@@ Min ( arr@@ 4 , 0 , n@@ 4 - 1 ) << endl ; int arr@@ 5 [ ] = { 2 , 1 } ; int n@@ 5 = sizeof ( arr@@ 5 ) / sizeof ( arr@@ 5 [ 0 ] ) ; cout << " The ▁ minimum ▁ element ▁ is ▁ " << find@@ Min ( arr@@ 5 , 0 , n@@ 5 - 1 ) << endl ; int arr@@ 6 [ ] = { 5 , 6 , 7 , 1 , 2 , 3 , 4 } ; int n@@ 6 = sizeof ( arr@@ 6 ) / sizeof ( arr@@ 6 [ 0 ] ) ; cout << " The ▁ minimum ▁ element ▁ is ▁ " << find@@ Min ( arr@@ 6 , 0 , n@@ 6 - 1 ) << endl ; int arr@@ 7 [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int n@@ 7 = sizeof ( arr@@ 7 ) / sizeof ( arr@@ 7 [ 0 ] ) ; cout << " The ▁ minimum ▁ element ▁ is ▁ " << find@@ Min ( arr@@ 7 , 0 , n@@ 7 - 1 ) << endl ; int arr@@ 8 [ ] = { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 1 } ; int n@@ 8 = sizeof ( arr@@ 8 ) / sizeof ( arr@@ 8 [ 0 ] ) ; cout << " The ▁ minimum ▁ element ▁ is ▁ " << find@@ Min ( arr@@ 8 , 0 , n@@ 8 - 1 ) << endl ; int arr@@ 9 [ ] = { 3 , 4 , 5 , 1 , 2 } ; int n@@ 9 = sizeof ( arr@@ 9 ) / sizeof ( arr@@ 9 [ 0 ] ) ; cout << " The ▁ minimum ▁ element ▁ is ▁ " << find@@ Min ( arr@@ 9 , 0 , n@@ 9 - 1 ) << endl ; return 0 ; }
Split the array and add the first part to the end 1456 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void split@@ Arr ( int arr [ ] , int length , int rotation ) { int tmp [ length * 2 ] = { 0 } ; for ( int i = 0 ; i < length ; i ++ ) { tmp [ i ] = arr [ i ] ; tmp [ i + length ] = arr [ i ] ; } for ( int i = rotation ; i < rotation + length ; i ++ ) { arr [ i - rotation ] = tmp [ i ] ; } } int main ( ) { int arr [ ] = { 12 , 10 , 5 , 6 , 52 , 36 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int position = 2 ; split@@ Arr ( arr , n , position ) ; for ( int i = 0 ; i < n ; ++ i ) printf ( " % d ▁ " , arr [ i ] ) ; return 0 ; }
Re@@ arrange positive and negative numbers with constant extra space 1480 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ Array ( int A [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) cout << A [ i ] << " ▁ " ; cout << endl ; } void reverse ( int arr [ ] , int l , int r ) { if ( l < r ) { swap ( arr [ l ] , arr [ r ] ) ; reverse ( arr , ++ l , -- r ) ; } } void merge ( int arr [ ] , int l , int m , int r ) { int i = l ; int j = m + 1 ; while ( i <= m && arr [ i ] < 0 ) i ++ ; while ( j <= r && arr [ j ] < 0 ) j ++ ; reverse ( arr , i , m ) ; reverse ( arr , m + 1 , j - 1 ) ; reverse ( arr , i , j - 1 ) ; } void Re@@ arrange@@ Pos@@ Neg ( int arr [ ] , int l , int r ) { if ( l < r ) { int m = l + ( r - l ) / 2 ; Re@@ arrange@@ Pos@@ Neg ( arr , l , m ) ; Re@@ arrange@@ Pos@@ Neg ( arr , m + 1 , r ) ; merge ( arr , l , m , r ) ; } } int main ( ) { int arr [ ] = { -@@ 12 , 11 , -@@ 13 , -@@ 5 , 6 , -@@ 7 , 5 , -@@ 3 , -@@ 6 } ; int arr_@@ size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; Re@@ arrange@@ Pos@@ Neg ( arr , 0 , arr_@@ size - 1 ) ; print@@ Array ( arr , arr_@@ size ) ; return 0 ; }
Re@@ arrange an array in maximum minimum form | Set 1 1487 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void re@@ arrange ( int arr [ ] , int n ) { int temp [ n ] ; int small = 0 , large = n - 1 ; int flag = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( flag ) temp [ i ] = arr [ large -- ] ; else temp [ i ] = arr [ small ++ ] ; flag = ! flag ; } for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Original ▁ Array STRNEWLINE " ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; re@@ arrange ( arr , n ) ; cout << " Modified Array " for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
Re@@ arrange an array in maximum minimum form | Set 2 ( O ( 1 ) extra space ) 1489 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void re@@ arrange ( int arr [ ] , int n ) { int max_@@ ele = arr [ n - 1 ] ; int min_@@ ele = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { arr [ i ] = max_@@ ele ; max_@@ ele -= 1 ; } else { arr [ i ] = min_@@ ele ; min_@@ ele += 1 ; } } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Original ▁ Array STRNEWLINE " ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; re@@ arrange ( arr , n ) ; cout << " Modified Array " for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
Find sum of all left leaves in a given Binary Tree 148 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; struct Node { int key ; struct Node * left , * right ; } ; Node * newNode ( char k ) { Node * node = new Node ; node -> key = k ; node -> right = node -> left = NULL ; return node ; } bool is@@ Leaf ( Node * node ) { if ( node == NULL ) return false ; if ( node -> left == NULL && node -> right == NULL ) return true ; return false ; } int left@@ Le@@ av@@ es@@ Sum ( Node * root ) { int res = 0 ; if ( root != NULL ) { if ( is@@ Leaf ( root -> left ) ) res += root -> left -> key ; else res += left@@ Le@@ av@@ es@@ Sum ( root -> left ) ; res += left@@ Le@@ av@@ es@@ Sum ( root -> right ) ; } return res ; } int main ( ) { struct Node * root = newNode ( 20 ) ; root -> left = newNode ( 9 ) ; root -> right = newNode ( 49 ) ; root -> right -> left = newNode ( 23 ) ; root -> right -> right = newNode ( 52 ) ; root -> right -> right -> left = newNode ( 50 ) ; root -> left -> left = newNode ( 5 ) ; root -> left -> right = newNode ( 12 ) ; root -> left -> right -> right = newNode ( 12 ) ; cout << " Sum ▁ of ▁ left ▁ leaves ▁ is ▁ " << left@@ Le@@ av@@ es@@ Sum ( root ) ; return 0 ; }
Move all negative elements to end in order with extra space allowed 1492 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void se@@ greg@@ ate@@ Elements ( int arr [ ] , int n ) { int temp [ n ] ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= 0 ) temp [ j ++ ] = arr [ i ] ; if ( j == n j == 0 ) return ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < 0 ) temp [ j ++ ] = arr [ i ] ; memcpy ( arr , temp , sizeof ( temp ) ) ; } int main ( ) { int arr [ ] = { 1 , -1 , -@@ 3 , -2 , 7 , 5 , 11 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; se@@ greg@@ ate@@ Elements ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
Positive elements at even and negative at odd positions ( Relative order not maintained ) 1495 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; void swap ( int * a , int i , int j ) { int temp = a [ i ] ; a [ i ] = a [ j ] ; a [ j ] = temp ; return ; } void print@@ Array ( int * a , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << a [ i ] << " ▁ " ; cout << endl ; return ; } int main ( ) { int arr [ ] = { 1 , -@@ 3 , 5 , 6 , -@@ 3 , 6 , 7 , -@@ 4 , 9 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; print@@ Array ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= 0 && i % 2 == 1 ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] < 0 && j % 2 == 0 ) { swap ( arr , i , j ) ; break ; } } } else if ( arr [ i ] < 0 && i % 2 == 0 ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] >= 0 && j % 2 == 1 ) { swap ( arr , i , j ) ; break ; } } } } print@@ Array ( arr , n ) ; return 0 ; }
Program to find largest element in an array 1511 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int largest ( int arr [ ] , int n ) { return * max_@@ element ( arr , arr + n ) ; } int main ( ) { int arr [ ] = { 10 , 324 , 45 , 90 , 98@@ 08 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << largest ( arr , n ) ; return 0 ; }
Program for Mean and median of an un@@ sorted array 1518 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; double find@@ Mean ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; return ( double ) sum / ( double ) n ; } double find@@ Medi@@ an ( int a [ ] , int n ) { sort ( a , a + n ) ; if ( n % 2 != 0 ) return ( double ) a [ n / 2 ] ; return ( double ) ( a [ ( n - 1 ) / 2 ] + a [ n / 2 ] ) / 2.0 ; } int main ( ) { int a [ ] = { 1 , 3 , 4 , 2 , 7 , 5 , 8 , 6 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << " Mean ▁ = ▁ " << find@@ Mean ( a , n ) << endl ; cout << " Medi@@ an ▁ = ▁ " << find@@ Medi@@ an ( a , n ) << endl ; return 0 ; }
Find Second largest element in an array 1530 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ 2@@ largest ( int arr [ ] , int arr_@@ size ) { int i , first , second ; if ( arr_@@ size < 2 ) { printf ( " ▁ Invalid ▁ Input ▁ " ) ; return ; } int largest = second = INT_@@ MIN ; for ( int i = 0 ; i < arr_@@ size ; i ++ ) { largest = max ( largest , arr [ i ] ) ; } for ( int i = 0 ; i < arr_@@ size ; i ++ ) { if ( arr [ i ] != largest ) second = max ( second , arr [ i ] ) ; } if ( second == INT_@@ MIN ) printf ( " There ▁ is ▁ no ▁ second ▁ largest ▁ element STRNEWLINE " ) ; else printf ( " The ▁ second ▁ largest ▁ element ▁ is ▁ % d STRNEWLINE " , second ) ; } int main ( ) { int arr [ ] = { 12 , 35 , 1 , 10 , 34 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; print@@ 2@@ largest ( arr , n ) ; return 0 ; }
Find Second largest element in an array 1531 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ 2@@ largest ( int arr [ ] , int arr_@@ size ) { int i , first , second ; if ( arr_@@ size < 2 ) { cout << " ▁ Invalid ▁ Input ▁ " ; return ; } first = second = INT_@@ MIN ; for ( i = 0 ; i < arr_@@ size ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second && arr [ i ] != first ) { second = arr [ i ] ; } } if ( second == INT_@@ MIN ) cout << " There ▁ is ▁ no ▁ second ▁ largest " " element STRNEWLINE " ; else cout << " The ▁ second ▁ largest ▁ element ▁ is ▁ " << second ; } int main ( ) { int arr [ ] = { 12 , 35 , 1 , 10 , 34 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; print@@ 2@@ largest ( arr , n ) ; return 0 ; }
Maximum sum such that no two elements are adjacent 1537 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int Find@@ Max@@ Sum ( vector < int > arr , int n ) { int in@@ cl = arr [ 0 ] ; int ex@@ cl = 0 ; int ex@@ cl_@@ new ; int i ; for ( i = 1 ; i < n ; i ++ ) { ex@@ cl_@@ new = ( in@@ cl > ex@@ cl ) ? in@@ cl : ex@@ cl ; in@@ cl = ex@@ cl + arr [ i ] ; ex@@ cl = ex@@ cl_@@ new ; } return ( ( in@@ cl > ex@@ cl ) ? in@@ cl : ex@@ cl ) ; } int main ( ) { vector < int > arr = { 5 , 5 , 10 , 100 , 10 , 5 } ; cout << Find@@ Max@@ Sum ( arr , arr . size ( ) ) ; }
Lar@@ gest Sum Contigu@@ ous Sub@@ array 1576 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int max@@ Sub@@ Array@@ Sum ( int a [ ] , int size ) { int max_@@ so@@ _f@@ ar = a [ 0 ] ; int curr_@@ max = a [ 0 ] ; for ( int i = 1 ; i < size ; i ++ ) { curr_@@ max = max ( a [ i ] , curr_@@ max + a [ i ] ) ; max_@@ so@@ _f@@ ar = max ( max_@@ so@@ _f@@ ar , curr_@@ max ) ; } return max_@@ so@@ _f@@ ar ; } int main ( ) { int a [ ] = { -2 , -@@ 3 , 4 , -1 , -2 , 1 , 5 , -@@ 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int max_@@ sum = max@@ Sub@@ Array@@ Sum ( a , n ) ; cout << " Maximum ▁ contiguous ▁ sum ▁ is ▁ " << max_@@ sum ; return 0 ; }
Minimum number of jumps to reach end 1584 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int min@@ Jump@@ s ( int arr [ ] , int n ) { if ( n == 1 ) return 0 ; int res = INT_MAX ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( i + arr [ i ] >= n - 1 ) { int sub_@@ res = min@@ Jump@@ s ( arr , i + 1 ) ; if ( sub_@@ res != INT_MAX ) res = min ( res , sub_@@ res + 1 ) ; } } return res ; } int main ( ) { int arr [ ] = { 1 , 3 , 6 , 3 , 2 , 3 , 6 , 8 , 9 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Minimum ▁ number ▁ of ▁ jumps ▁ to " ; cout << " ▁ reach ▁ the ▁ end ▁ is ▁ " << min@@ Jump@@ s ( arr , n ) ; return 0 ; }
Size of The Sub@@ array With Maximum Sum 1596 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max@@ Sub@@ Array@@ Sum ( int a [ ] , int size ) { int max_@@ so@@ _f@@ ar = INT_@@ MIN , max_@@ ending_@@ here = 0 , start = 0 , end = 0 , s = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_@@ ending_@@ here += a [ i ] ; if ( max_@@ so@@ _f@@ ar < max_@@ ending_@@ here ) { max_@@ so@@ _f@@ ar = max_@@ ending_@@ here ; start = s ; end = i ; } if ( max_@@ ending_@@ here < 0 ) { max_@@ ending_@@ here = 0 ; s = i + 1 ; } } return ( end - start + 1 ) ; } int main ( ) { int a [ ] = { -2 , -@@ 3 , 4 , -1 , -2 , 1 , 5 , -@@ 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << max@@ Sub@@ Array@@ Sum ( a , n ) ; return 0 ; }
Sort 1 to N by sw@@ apping adjacent elements 1611 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool sorted@@ After@@ Swap ( int A [ ] , bool B [ ] , int n ) { int i , j ; for ( i = 0 ; i < n - 1 ; i ++ ) { if ( B [ i ] ) { j = i ; while ( B [ j ] ) j ++ ; sort ( A + i , A + 1 + j ) ; i = j ; } } for ( i = 0 ; i < n ; i ++ ) { if ( A [ i ] != i + 1 ) return false ; } return true ; } int main ( ) { int A [ ] = { 1 , 2 , 5 , 3 , 4 , 6 } ; bool B [ ] = { 0 , 1 , 1 , 1 , 0 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; if ( sorted@@ After@@ Swap ( A , B , n ) ) cout << " A ▁ can ▁ be ▁ sorted STRNEWLINE " ; else cout << " A ▁ can ▁ not ▁ be ▁ sorted STRNEWLINE " ; return 0 ; }
Count the number of possible triangles 1637 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ NumberOf@@ Triangles ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] + arr [ j ] > arr [ k ] && arr [ i ] + arr [ k ] > arr [ j ] && arr [ k ] + arr [ j ] > arr [ i ] ) count ++ ; } } return count ; } int main ( ) { int arr [ ] = { 10 , 21 , 22 , 100 , 101 , 200 , 300 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Total ▁ number ▁ of ▁ triangles ▁ possible ▁ is ▁ " << find@@ NumberOf@@ Triangles ( arr , size ) ; return 0 ; }
Count the number of possible triangles 1638 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int comp ( const void * a , const void * b ) { return * ( int * ) a > * ( int * ) b ; } int find@@ NumberOf@@ Triangles ( int arr [ ] , int n ) { q@@ sort ( arr , n , sizeof ( arr [ 0 ] ) , comp ) ; int count = 0 ; for ( int i = 0 ; i < n - 2 ; ++ i ) { int k = i + 2 ; for ( int j = i + 1 ; j < n ; ++ j ) { while ( k < n && arr [ i ] + arr [ j ] > arr [ k ] ) ++ k ; if ( k > j ) count += k - j - 1 ; } } return count ; } int main ( ) { int arr [ ] = { 10 , 21 , 22 , 100 , 101 , 200 , 300 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Total ▁ number ▁ of ▁ triangles ▁ possible ▁ is ▁ " << find@@ NumberOf@@ Triangles ( arr , size ) ; return 0 ; }
Equi@@ lib@@ ri@@ um index of an array 1682 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int equi@@ lib@@ ri@@ um ( int arr [ ] , int n ) { int i , j ; int left@@ sum , right@@ sum ; for ( i = 0 ; i < n ; ++ i ) { left@@ sum = 0 ; right@@ sum = 0 ; for ( j = 0 ; j < i ; j ++ ) left@@ sum += arr [ j ] ; for ( j = i + 1 ; j < n ; j ++ ) right@@ sum += arr [ j ] ; if ( left@@ sum == right@@ sum ) return i ; } return -1 ; } int main ( ) { int arr [ ] = { -@@ 7 , 1 , 5 , 2 , -@@ 4 , 3 , 0 } ; int arr_@@ size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << equi@@ lib@@ ri@@ um ( arr , arr_@@ size ) ; return 0 ; }
Ceil@@ ing in a sorted array 1687 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int ceil@@ Search ( int arr [ ] , int low , int high , int x ) { int i ; if ( x <= arr [ low ] ) return low ; for ( i = low ; i < high ; i ++ ) { if ( arr [ i ] == x ) return i ; if ( arr [ i ] < x && arr [ i + 1 ] >= x ) return i + 1 ; } return -1 ; } int main ( ) { int arr [ ] = { 1 , 2 , 8 , 10 , 10 , 12 , 19 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 3 ; int index = ceil@@ Search ( arr , 0 , n - 1 , x ) ; if ( index == -1 ) cout << " Ceil@@ ing ▁ of ▁ " << x << " ▁ doesn ' t ▁ exist ▁ in ▁ array ▁ " ; else cout << " ceiling ▁ of ▁ " << x << " ▁ is ▁ " << arr [ index ] ; return 0 ; }
Maj@@ ority Element 1691 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Candidate ( int a [ ] , int size ) { int maj@@ _index = 0 , count = 1 ; for ( int i = 1 ; i < size ; i ++ ) { if ( a [ maj@@ _index ] == a [ i ] ) count ++ ; else count -- ; if ( count == 0 ) { maj@@ _index = i ; count = 1 ; } } return a [ maj@@ _index ] ; } bool is@@ Maj@@ ority ( int a [ ] , int size , int c@@ and ) { int count = 0 ; for ( int i = 0 ; i < size ; i ++ ) if ( a [ i ] == c@@ and ) count ++ ; if ( count > size / 2 ) return 1 ; else return 0 ; } void print@@ Maj@@ ority ( int a [ ] , int size ) { int c@@ and = find@@ Candidate ( a , size ) ; if ( is@@ Maj@@ ority ( a , size , c@@ and ) ) cout << " ▁ " << c@@ and << " ▁ " ; else cout << " No ▁ Maj@@ ority ▁ Element " ; } int main ( ) { int a [ ] = { 1 , 3 , 3 , 1 , 2 } ; int size = ( sizeof ( a ) ) / sizeof ( a [ 0 ] ) ; print@@ Maj@@ ority ( a , size ) ; return 0 ; }
Find root of the tree where children id sum for every node is given 187 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Root ( pair < int , int > arr [ ] , int n ) { int root = 0 ; for ( int i = 0 ; i < n ; i ++ ) root += ( arr [ i ] . first - arr [ i ] . second ) ; return root ; } int main ( ) { pair < int , int > arr [ ] = { { 1 , 5 } , { 2 , 0 } , { 3 , 0 } , { 4 , 0 } , { 5 , 5 } , { 6 , 5 } } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( " % d STRNEWLINE " , find@@ Root ( arr , n ) ) ; return 0 ; }
Find Height of Binary Tree represented by Parent array 221 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void fill@@ Depth ( int parent [ ] , int i , int depth [ ] ) { if ( depth [ i ] ) return ; if ( parent [ i ] == -1 ) { depth [ i ] = 1 ; return ; } if ( depth [ parent [ i ] ] == 0 ) fill@@ Depth ( parent , parent [ i ] , depth ) ; depth [ i ] = depth [ parent [ i ] ] + 1 ; } int find@@ Height ( int parent [ ] , int n ) { int depth [ n ] ; for ( int i = 0 ; i < n ; i ++ ) depth [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) fill@@ Depth ( parent , i , depth ) ; int ht = depth [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( ht < depth [ i ] ) ht = depth [ i ] ; return ht ; } int main ( ) { int parent [ ] = { -1 , 0 , 0 , 1 , 1 , 3 , 5 } ; int n = sizeof ( parent ) / sizeof ( parent [ 0 ] ) ; cout << " Height ▁ is ▁ " << find@@ Height ( parent , n ) ; return 0 ; }
Find post@@ order traversal of B@@ ST from pre@@ order traversal 22 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; void getPost@@ Order@@ B@@ ST ( int pre [ ] , int N ) { int pivot@@ Point = 0 ; for ( int i = 1 ; i < N ; i ++ ) { if ( pre [ 0 ] <= pre [ i ] ) { pivot@@ Point = i ; break ; } } for ( int i = pivot@@ Point - 1 ; i > 0 ; i -- ) { cout << pre [ i ] << " ▁ " ; } for ( int i = N - 1 ; i >= pivot@@ Point ; i -- ) { cout << pre [ i ] << " ▁ " ; } cout << pre [ 0 ] ; }
Find Minimum Depth of a Binary Tree 241 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; int min@@ Depth ( Node * root ) { if ( root == NULL ) return 0 ; if ( root -> left == NULL && root -> right == NULL ) return 1 ; int l = INT_MAX , r = INT_MAX ; if ( root -> left ) l = min@@ Depth ( root -> left ) ; if ( root -> right ) r = min@@ Depth ( root -> right ) ; return min ( l , r ) + 1 ; } Node * newNode ( int data ) { Node * temp = new Node ; temp -> data = data ; temp -> left = temp -> right = NULL ; return ( temp ) ; } int main ( ) { Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; cout << " The ▁ minimum ▁ depth ▁ of ▁ binary ▁ tree ▁ is ▁ : ▁ " << min@@ Depth ( root ) ; return 0 ; }
Pri@@ m '@@ s algorithm using priority_@@ queue in STL 472 | if ( in@@ M@@ ST [ v ] == false && key [ v ] > weight ) { key [ v ] = weight ; pq . push ( make_pair ( key [ v ] , v ) ) ; parent [ v ] = u ; }
Check for star graph 494 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define size 4 NEW_LINE bool check@@ Star ( int mat [ ] [ size ] ) { int vertex@@ D1 = 0 , vertex@@ D@@ n_@@ 1 = 0 ; if ( size == 1 ) return ( mat [ 0 ] [ 0 ] == 0 ) ; if ( size == 2 ) return ( mat [ 0 ] [ 0 ] == 0 && mat [ 0 ] [ 1 ] == 1 && mat [ 1 ] [ 0 ] == 1 && mat [ 1 ] [ 1 ] == 0 ) ; for ( int i = 0 ; i < size ; i ++ ) { int degree@@ I = 0 ; for ( int j = 0 ; j < size ; j ++ ) if ( mat [ i ] [ j ] ) degree@@ I ++ ; if ( degree@@ I == 1 ) vertex@@ D1 ++ ; else if ( degree@@ I == size - 1 ) vertex@@ D@@ n_@@ 1 ++ ; } return ( vertex@@ D1 == ( size - 1 ) && vertex@@ D@@ n_@@ 1 == 1 ) ; } int main ( ) { int mat [ size ] [ size ] = { { 0 , 1 , 1 , 1 } , { 1 , 0 , 0 , 0 } , { 1 , 0 , 0 , 0 } , { 1 , 0 , 0 , 0 } } ; check@@ Star ( mat ) ? cout << " Star ▁ Graph " : cout << " Not ▁ a ▁ Star ▁ Graph " ; return 0 ; }
K '@@ th Lar@@ gest element in B@@ ST using constant extra space 694 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; Node * newNode ( int data ) { Node * temp = new Node ; temp -> data = data ; temp -> right = temp -> left = NULL ; return temp ; } Node * K@@ th@@ Largest@@ Using@@ Mor@@ ris@@ Traversal ( Node * root , int k ) { Node * curr = root ; Node * K@@ largest = NULL ; int count = 0 ; while ( curr != NULL ) { if ( curr -> right == NULL ) { if ( ++ count == k ) K@@ largest = curr ; curr = curr -> left ; } else { Node * succ = curr -> right ; while ( succ -> left != NULL && succ -> left != curr ) succ = succ -> left ; if ( succ -> left == NULL ) { succ -> left = curr ; curr = curr -> right ; } else { succ -> left = NULL ; if ( ++ count == k ) K@@ largest = curr ; curr = curr -> left ; } } } return K@@ largest ; } int main ( ) { Node * root = newNode ( 4 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 7 ) ; root -> left -> left = newNode ( 1 ) ; root -> left -> right = newNode ( 3 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 10 ) ; cout << " Fin@@ ding ▁ K - th ▁ largest ▁ Node ▁ in ▁ B@@ ST ▁ : ▁ " << K@@ th@@ Largest@@ Using@@ Mor@@ ris@@ Traversal ( root , 2 ) -> data ; return 0 ; }
Construct Tree from given In@@ order and Pre@@ order tra@@ vers@@ als 69 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; class TreeNode { public : int val ; TreeNode * left ; TreeNode * right ; TreeNode ( int x ) { val = x ; } } ; set < TreeNode * > s ; stack < TreeNode * > st ; TreeNode * build@@ Tree ( int pre@@ order [ ] , int in@@ order [ ] , int n ) { TreeNode * root = NULL ; for ( int pre = 0 , in = 0 ; pre < n ; ) { TreeNode * node = NULL ; do { node = new TreeNode ( pre@@ order [ pre ] ) ; if ( root == NULL ) { root = node ; } if ( st . size ( ) > 0 ) { if ( s . find ( st . top ( ) ) != s . end ( ) ) { s . erase ( st . top ( ) ) ; st . top ( ) -> right = node ; st . pop ( ) ; } else { st . top ( ) -> left = node ; } } st . push ( node ) ; } while ( pre@@ order [ pre ++ ] != in@@ order [ in ] && pre < n ) ; node = NULL ; while ( st . size ( ) > 0 && in < n && st . top ( ) -> val == in@@ order [ in ] ) { node = st . top ( ) ; st . pop ( ) ; in ++ ; } if ( node != NULL ) { s . insert ( node ) ; st . push ( node ) ; } } return root ; } void print@@ In@@ order ( TreeNode * node ) { if ( node == NULL ) return ; print@@ In@@ order ( node -> left ) ; cout << node -> val << " ▁ " ; print@@ In@@ order ( node -> right ) ; } int main ( ) { int in [ ] = { 9 , 8 , 4 , 2 , 10 , 5 , 10 , 1 , 6 , 3 , 13 , 12 , 7 } ; int pre [ ] = { 1 , 2 , 4 , 8 , 9 , 5 , 10 , 10 , 3 , 6 , 7 , 12 , 13 } ; int len = sizeof ( in ) / sizeof ( int ) ; TreeNode * root = build@@ Tree ( pre , in , len ) ; print@@ In@@ order ( root ) ; return 0 ; }
Maximum element between two nodes of B@@ ST 725 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; struct Node { struct Node * left , * right ; int data ; } ; Node * createNode ( int x ) { Node * p = new Node ; p -> data = x ; p -> left = p -> right = NULL ; return p ; } void insert@@ Node ( struct Node * root , int x ) { Node * p = root , * q = NULL ; while ( p != NULL ) { q = p ; if ( p -> data < x ) p = p -> right ; else p = p -> left ; } if ( q == NULL ) p = createNode ( x ) ; else { if ( q -> data < x ) q -> right = createNode ( x ) ; else q -> left = createNode ( x ) ; } } int max@@ el@@ path ( Node * q , int x ) { Node * p = q ; int mx = INT_@@ MIN ; while ( p -> data != x ) { if ( p -> data > x ) { mx = max ( mx , p -> data ) ; p = p -> left ; } else { mx = max ( mx , p -> data ) ; p = p -> right ; } } return max ( mx , x ) ; } int maximum@@ Element ( struct Node * root , int x , int y ) { Node * p = root ; while ( ( x < p -> data && y < p -> data ) || ( x > p -> data && y > p -> data ) ) { if ( x < p -> data && y < p -> data ) p = p -> left ; else if ( x > p -> data && y > p -> data ) p = p -> right ; } return max ( max@@ el@@ path ( p , x ) , max@@ el@@ path ( p , y ) ) ; } int main ( ) { int arr [ ] = { 18 , 36 , 9 , 6 , 12 , 10 , 1 , 8 } ; int a = 1 , b = 10 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; struct Node * root = createNode ( arr [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) insert@@ Node ( root , arr [ i ] ) ; cout << maximum@@ Element ( root , a , b ) << endl ; return 0 ; }
Leaf nodes from Pre@@ order of a Binary Search Tree ( Using Recur@@ sion ) 758 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Leaf ( int pre [ ] , int & i , int n , int min , int max ) { if ( i >= n ) return false ; if ( pre [ i ] > min && pre [ i ] < max ) { i ++ ; bool left = is@@ Leaf ( pre , i , n , min , pre [ i - 1 ] ) ; bool right = is@@ Leaf ( pre , i , n , pre [ i - 1 ] , max ) ; if ( ! left && ! right ) cout << pre [ i - 1 ] << " ▁ " ; return true ; } return false ; } void print@@ Leaves ( int pre@@ order [ ] , int n ) { int i = 0 ; is@@ Leaf ( pre@@ order , i , n , INT_@@ MIN , INT_MAX ) ; } int main ( ) { int pre@@ order [ ] = { 89@@ 0 , 325 , 29@@ 0 , 5@@ 30 , 96@@ 5 } ; int n = sizeof ( pre@@ order ) / sizeof ( pre@@ order [ 0 ] ) ; print@@ Leaves ( pre@@ order , n ) ; return 0 ; }
Inter@@ change elements of first and last rows in matrix 808 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; #@@ define n 4 NEW_LINE void inter@@ change@@ First@@ Last ( int m [ ] [ n ] ) { int rows = n ; for ( int i = 0 ; i < n ; i ++ ) { int t = m [ 0 ] [ i ] ; m [ 0 ] [ i ] = m [ rows - 1 ] [ i ] ; m [ rows - 1 ] [ i ] = t ; } } int main ( ) { int m [ n ] [ n ] = { { 8 , 9 , 7 , 6 } , { 4 , 7 , 6 , 5 } , { 3 , 2 , 1 , 8 } , { 9 , 9 , 7 , 7 } } ; inter@@ change@@ First@@ Last ( m ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) cout << m [ i ] [ j ] << " ▁ " ; cout << endl ; } }
Construct a Binary Tree from Post@@ order and In@@ order 81 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; Node * newNode ( int data ) ; int search ( int arr [ ] , int str@@ t , int end , int value ) ; Node * build@@ Util ( int in [ ] , int post [ ] , int in@@ Str@@ t , int in@@ End , int * p@@ Index ) { if ( in@@ Str@@ t > in@@ End ) return NULL ; Node * node = newNode ( post [ * p@@ Index ] ) ; ( * p@@ Index ) -- ; if ( in@@ Str@@ t == in@@ End ) return node ; int iIndex = search ( in , in@@ Str@@ t , in@@ End , node -> data ) ; node -> right = build@@ Util ( in , post , iIndex + 1 , in@@ End , p@@ Index ) ; node -> left = build@@ Util ( in , post , in@@ Str@@ t , iIndex - 1 , p@@ Index ) ; return node ; } Node * build@@ Tree ( int in [ ] , int post [ ] , int n ) { int p@@ Index = n - 1 ; return build@@ Util ( in , post , 0 , n - 1 , & p@@ Index ) ; } int search ( int arr [ ] , int str@@ t , int end , int value ) { int i ; for ( i = str@@ t ; i <= end ; i ++ ) { if ( arr [ i ] == value ) break ; } return i ; } Node * newNode ( int data ) { Node * node = ( Node * ) malloc ( sizeof ( Node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } void pre@@ Order ( Node * node ) { if ( node == NULL ) return ; printf ( " % d ▁ " , node -> data ) ; pre@@ Order ( node -> left ) ; pre@@ Order ( node -> right ) ; } int main ( ) { int in [ ] = { 4 , 8 , 2 , 5 , 1 , 6 , 3 , 7 } ; int post [ ] = { 8 , 4 , 5 , 2 , 6 , 7 , 3 , 1 } ; int n = sizeof ( in ) / sizeof ( in [ 0 ] ) ; Node * root = build@@ Tree ( in , post , n ) ; cout << " Pre@@ order ▁ of ▁ the ▁ constructed ▁ tree ▁ : ▁ STRNEWLINE " ; pre@@ Order ( root ) ; return 0 ; }
K@@ ron@@ ec@@ ker Product of two matrices 821 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; const int col@@ a = 2 , row@@ a = 3 , col@@ b = 3 , row@@ b = 2 ; void K@@ ron@@ ec@@ ker@@ product ( int A [ ] [ col@@ a ] , int B [ ] [ col@@ b ] ) { int C [ row@@ a * row@@ b ] [ col@@ a * col@@ b ] ; for ( int i = 0 ; i < row@@ a ; i ++ ) { for ( int k = 0 ; k < row@@ b ; k ++ ) { for ( int j = 0 ; j < col@@ a ; j ++ ) { for ( int l = 0 ; l < col@@ b ; l ++ ) { C [ i + l + 1 ] [ j + k + 1 ] = A [ i ] [ j ] * B [ k ] [ l ] ; cout << C [ i + l + 1 ] [ j + k + 1 ] << " ▁ " ; } } cout << endl ; } } } int main ( ) { int A [ 3 ] [ 2 ] = { { 1 , 2 } , { 3 , 4 } , { 1 , 0 } } , B [ 2 ] [ 3 ] = { { 0 , 5 , 2 } , { 6 , 7 , 3 } } ; K@@ ron@@ ec@@ ker@@ product ( A , B ) ; return 0 ; }
Count frequency of k in a matrix of size n where matrix ( i , j ) = i + j 824 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find ( int n , int k ) { if ( n + 1 >= k ) return ( k - 1 ) ; else return ( 2 * n + 1 - k ) ; } int main ( ) { int n = 4 , k = 7 ; int freq = find ( n , k ) ; if ( freq < 0 ) cout << " ▁ element ▁ not ▁ exist ▁ STRNEWLINE ▁ " ; else cout << " ▁ Frequency ▁ of ▁ " << k << " ▁ is ▁ " << freq << " STRNEWLINE " ; return 0 ; }
Program for Identity Matrix 836 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int Identity ( int num ) { int row , col ; for ( row = 0 ; row < num ; row ++ ) { for ( col = 0 ; col < num ; col ++ ) { if ( row == col ) cout << 1 << " ▁ " ; else cout << 0 << " ▁ " ; } cout << endl ; } return 0 ; } int main ( ) { int size = 5 ; Identity ( size ) ; return 0 ; }
Mirror of matrix across diagonal 840 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; const int MAX = 100 ; void image@@ Swap ( int mat [ ] [ MAX ] , int n ) { int row = 0 ; for ( int j = 0 ; j < n ; j ++ ) { stack < int > s ; int i = row , k = j ; while ( i < n && k >= 0 ) s . push ( mat [ i ++ ] [ k -- ] ) ; i = row , k = j ; while ( i < n && k >= 0 ) { mat [ i ++ ] [ k -- ] = s . top ( ) ; s . pop ( ) ; } } int column = n - 1 ; for ( int j = 1 ; j < n ; j ++ ) { stack < int > s ; int i = j , k = column ; while ( i < n && k >= 0 ) s . push ( mat [ i ++ ] [ k -- ] ) ; i = j ; k = column ; while ( i < n && k >= 0 ) { mat [ i ++ ] [ k -- ] = s . top ( ) ; s . pop ( ) ; } } } void print@@ Matrix ( int mat [ ] [ MAX ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) cout << mat [ i ] [ j ] << " ▁ " ; cout << endl ; } } int main ( ) { int mat [ ] [ MAX ] = { { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } , { 9 , 10 , 11 , 12 } , { 13 , 14 , 15 , 16 } } ; int n = 4 ; image@@ Swap ( mat , n ) ; print@@ Matrix ( mat , n ) ; return 0 ; }
Total coverage of all zeros in a binary matrix 906 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define R 4 NEW_LINE #@@ define C 4 NEW_LINE int getTotal@@ Coverage@@ Of@@ Matrix ( int mat [ R ] [ C ] ) { int res = 0 ; for ( int i = 0 ; i < R ; i ++ ) { bool is@@ One = false ; for ( int j = 0 ; j < C ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) is@@ One = true ; else if ( is@@ One ) res ++ ; } is@@ One = false ; for ( int j = C - 1 ; j >= 0 ; j -- ) { if ( mat [ i ] [ j ] == 1 ) is@@ One = true ; else if ( is@@ One ) res ++ ; } } for ( int j = 0 ; j < C ; j ++ ) { bool is@@ One = false ; for ( int i = 0 ; i < R ; i ++ ) { if ( mat [ i ] [ j ] == 1 ) is@@ One = true ; else if ( is@@ One ) res ++ ; } is@@ One = false ; for ( int i = R - 1 ; i >= 0 ; i -- ) { if ( mat [ i ] [ j ] == 1 ) is@@ One = true ; else if ( is@@ One ) res ++ ; } } return res ; } int main ( ) { int mat [ R ] [ C ] = { { 0 , 0 , 0 , 0 } , { 1 , 0 , 0 , 1 } , { 0 , 1 , 1 , 0 } , { 0 , 1 , 0 , 0 } } ; cout << getTotal@@ Coverage@@ Of@@ Matrix ( mat ) ; return 0 ; }
Print K '@@ th element in spir@@ al form of matrix 913 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define R 3 NEW_LINE #@@ define C 6 NEW_LINE void spir@@ al@@ Print ( int m , int n , int a [ R ] [ C ] , int c ) { int i , k = 0 , l = 0 ; int count = 0 ; while ( k < m && l < n ) { for ( i = l ; i < n ; ++ i ) { count ++ ; if ( count == c ) cout << a [ k ] [ i ] << " ▁ " ; } k ++ ; for ( i = k ; i < m ; ++ i ) { count ++ ; if ( count == c ) cout << a [ i ] [ n - 1 ] << " ▁ " ; } n -- ; if ( k < m ) { for ( i = n - 1 ; i >= l ; -- i ) { count ++ ; if ( count == c ) cout << a [ m - 1 ] [ i ] << " ▁ " ; } m -- ; } if ( l < n ) { for ( i = m - 1 ; i >= k ; -- i ) { count ++ ; if ( count == c ) cout << a [ i ] [ l ] << " ▁ " ; } l ++ ; } } } int main ( ) { int a [ R ] [ C ] = { { 1 , 2 , 3 , 4 , 5 , 6 } , { 7 , 8 , 9 , 10 , 11 , 12 } , { 13 , 14 , 15 , 16 , 17 , 18 } } , k = 17 ; spir@@ al@@ Print ( R , C , a , k ) ; return 0 ; }
Count Negative Numbers in a Column 918 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Negative ( int M [ ] [ 4 ] , int n , int m ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( M [ i ] [ j ] < 0 ) count += 1 ; else break ; } } return count ; } int main ( ) { int M [ 3 ] [ 4 ] = { { -@@ 3 , -2 , -1 , 1 } , { -2 , 2 , 3 , 4 } , { 4 , 5 , 7 , 8 } } ; cout << count@@ Negative ( M , 3 , 4 ) ; return 0 ; }
Find size of the largest ' + ' formed by all ones in a binary matrix 921 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define N 10 NEW_LINE int find@@ Largest@@ Plus ( int mat [ N ] [ N ] ) { int left [ N ] [ N ] , right [ N ] [ N ] , top [ N ] [ N ] , bottom [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { top [ 0 ] [ i ] = mat [ 0 ] [ i ] ; bottom [ N - 1 ] [ i ] = mat [ N - 1 ] [ i ] ; left [ i ] [ 0 ] = mat [ i ] [ 0 ] ; right [ i ] [ N - 1 ] = mat [ i ] [ N - 1 ] ; } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 1 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) left [ i ] [ j ] = left [ i ] [ j - 1 ] + 1 ; else left [ i ] [ j ] = 0 ; if ( mat [ j ] [ i ] == 1 ) top [ j ] [ i ] = top [ j - 1 ] [ i ] + 1 ; else top [ j ] [ i ] = 0 ; j = N - 1 - j ; if ( mat [ j ] [ i ] == 1 ) bottom [ j ] [ i ] = bottom [ j + 1 ] [ i ] + 1 ; else bottom [ j ] [ i ] = 0 ; if ( mat [ i ] [ j ] == 1 ) right [ i ] [ j ] = right [ i ] [ j + 1 ] + 1 ; else right [ i ] [ j ] = 0 ; j = N - 1 - j ; } } int n = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int len = min ( min ( top [ i ] [ j ] , bottom [ i ] [ j ] ) , min ( left [ i ] [ j ] , right [ i ] [ j ] ) ) ; if ( len > n ) n = len ; } } if ( n ) return 4 * ( n - 1 ) + 1 ; return 0 ; } int main ( ) { int mat [ N ] [ N ] = { { 1 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 1 } , { 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 1 } , { 1 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 } , { 0 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 0 } , { 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 } , { 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 } , { 1 , 0 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 1 } , { 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 } , { 1 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 0 } } ; cout << find@@ Largest@@ Plus ( mat ) ; return 0 ; }
Program for addition of two matrices 960 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define N 4 NEW_LINE void add ( int A [ ] [ N ] , int B [ ] [ N ] , int C [ ] [ N ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] ; } int main ( ) { int A [ N ] [ N ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int B [ N ] [ N ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int C [ N ] [ N ] ; int i , j ; add ( A , B , C ) ; cout << " Result ▁ matrix ▁ is ▁ " << endl ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) cout << C [ i ] [ j ] << " ▁ " ; cout << endl ; } return 0 ; }
Program for subtraction of matrices 961 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define N 4 NEW_LINE void subtract ( int A [ ] [ N ] , int B [ ] [ N ] , int C [ ] [ N ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ; } int main ( ) { int A [ N ] [ N ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int B [ N ] [ N ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int C [ N ] [ N ] ; int i , j ; subtract ( A , B , C ) ; cout << " Result ▁ matrix ▁ is ▁ " << endl ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) cout << C [ i ] [ j ] << " ▁ " ; cout << endl ; } return 0 ; }
Find a peak element 1701 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Peak@@ Util ( int arr [ ] , int low , int high , int n ) { int mid = low + ( high - low ) / 2 ; if ( ( mid == 0 arr [ mid - 1 ] <= arr [ mid ] ) && ( mid == n - 1 arr [ mid + 1 ] <= arr [ mid ] ) ) return mid ; else if ( mid > 0 && arr [ mid - 1 ] > arr [ mid ] ) return find@@ Peak@@ Util ( arr , low , ( mid - 1 ) , n ) ; else return find@@ Peak@@ Util ( arr , ( mid + 1 ) , high , n ) ; } int find@@ Peak ( int arr [ ] , int n ) { return find@@ Peak@@ Util ( arr , 0 , n - 1 , n ) ; } int main ( ) { int arr [ ] = { 1 , 3 , 20 , 4 , 1 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Index ▁ of ▁ a ▁ peak ▁ point ▁ is ▁ " << find@@ Peak ( arr , n ) ; return 0 ; }
Find the two repe@@ ating elements in a given array 1702 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ Repe@@ ating ( int arr [ ] , int size ) { int i , j ; printf ( " ▁ Repe@@ ating ▁ elements ▁ are ▁ " ) ; for ( i = 0 ; i < size ; i ++ ) for ( j = i + 1 ; j < size ; j ++ ) if ( arr [ i ] == arr [ j ] ) cout << arr [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_@@ size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; print@@ Repe@@ ating ( arr , arr_@@ size ) ; }
Find the two repe@@ ating elements in a given array 1704 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int fact ( int n ) ; void print@@ Repe@@ ating ( int arr [ ] , int size ) { int S = 0 ; int P = 1 ; int x , y ; int D ; int n = size - 2 , i ; for ( i = 0 ; i < size ; i ++ ) { S = S + arr [ i ] ; P = P * arr [ i ] ; } S = S - n * ( n + 1 ) / 2 ; P = P / fact ( n ) ; D = sqrt ( S * S - 4 * P ) ; x = ( D + S ) / 2 ; y = ( S - D ) / 2 ; cout << " The ▁ two ▁ Repe@@ ating ▁ elements ▁ are ▁ " << x << " ▁ & ▁ " << y ; } int fact ( int n ) { return ( n == 0 ) ? 1 : n * fact ( n - 1 ) ; } int main ( ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_@@ size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; print@@ Repe@@ ating ( arr , arr_@@ size ) ; return 0 ; }
Find the two repe@@ ating elements in a given array 1705 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ Repe@@ ating ( int arr [ ] , int size ) { int Xor = arr [ 0 ] ; int set_@@ bit_@@ no ; int i ; int n = size - 2 ; int x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) Xor ^= arr [ i ] ; for ( i = 1 ; i <= n ; i ++ ) Xor ^= i ; set_@@ bit_@@ no = Xor & ~ ( Xor - 1 ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] & set_@@ bit_@@ no ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } for ( i = 1 ; i <= n ; i ++ ) { if ( i & set_@@ bit_@@ no ) x = x ^ i ; else y = y ^ i ; } cout << " The ▁ two ▁ repe@@ ating ▁ elements ▁ are ▁ " << y << " ▁ " << x ; } int main ( ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_@@ size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; print@@ Repe@@ ating ( arr , arr_@@ size ) ; return 0 ; }
Find a Fixed Point ( Value equal to index ) in a given array 1707 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int linear@@ Search ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == i ) return i ; } return -1 ; } int main ( ) { int arr [ ] = { -@@ 10 , -1 , 0 , 3 , 10 , 11 , 30 , 50 , 100 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Fixed ▁ Point ▁ is ▁ " << linear@@ Search ( arr , n ) ; return 0 ; }
Find sub@@ array with given sum | Set 1 ( Non@@ negative Numbers ) 1710 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int sub@@ Array@@ Sum ( int arr [ ] , int n , int sum ) { int curr_@@ sum = arr [ 0 ] , start = 0 , i ; for ( i = 1 ; i <= n ; i ++ ) { while ( curr_@@ sum > sum && start < i - 1 ) { curr_@@ sum = curr_@@ sum - arr [ start ] ; start ++ ; } if ( curr_@@ sum == sum ) { cout << " Sum ▁ found ▁ between ▁ indexes ▁ " << start << " ▁ and ▁ " << i - 1 ; return 1 ; } if ( i < n ) curr_@@ sum = curr_@@ sum + arr [ i ] ; } cout << " No ▁ sub@@ array ▁ found " ; return 0 ; } int main ( ) { int arr [ ] = { 15 , 2 , 4 , 8 , 9 , 5 , 10 , 23 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int sum = 23 ; sub@@ Array@@ Sum ( arr , n , sum ) ; return 0 ; }
S@@ malle@@ st Difference Trip@@ let from Three arrays 1714 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int maximum ( int a , int b , int c ) { return max ( max ( a , b ) , c ) ; } int minimum ( int a , int b , int c ) { return min ( min ( a , b ) , c ) ; } void smalle@@ st@@ Difference@@ Trip@@ let ( int ar@@ r1 [ ] , int ar@@ r2 [ ] , int arr@@ 3 [ ] , int n ) { sort ( ar@@ r1 , ar@@ r1 + n ) ; sort ( ar@@ r2 , ar@@ r2 + n ) ; sort ( arr@@ 3 , arr@@ 3 + n ) ; int res_@@ min , res_@@ max , res@@ _m@@ id ; int i = 0 , j = 0 , k = 0 ; int diff = INT_MAX ; while ( i < n && j < n && k < n ) { int sum = ar@@ r1 [ i ] + ar@@ r2 [ j ] + arr@@ 3 [ k ] ; int max = maximum ( ar@@ r1 [ i ] , ar@@ r2 [ j ] , arr@@ 3 [ k ] ) ; int min = minimum ( ar@@ r1 [ i ] , ar@@ r2 [ j ] , arr@@ 3 [ k ] ) ; if ( min == ar@@ r1 [ i ] ) i ++ ; else if ( min == ar@@ r2 [ j ] ) j ++ ; else k ++ ; if ( diff > ( max - min ) ) { diff = max - min ; res_@@ max = max ; res@@ _m@@ id = sum - ( max + min ) ; res_@@ min = min ; } } cout << res_@@ max << " , ▁ " << res@@ _m@@ id << " , ▁ " << res_@@ min ; } int main ( ) { int ar@@ r1 [ ] = { 5 , 2 , 8 } ; int ar@@ r2 [ ] = { 10 , 7 , 12 } ; int arr@@ 3 [ ] = { 9 , 14 , 6 } ; int n = sizeof ( ar@@ r1 ) / sizeof ( ar@@ r1 [ 0 ] ) ; smalle@@ st@@ Difference@@ Trip@@ let ( ar@@ r1 , ar@@ r2 , arr@@ 3 , n ) ; return 0 ; }
Find a trip@@ let that sum to a given value 1715 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool find@@ 3@@ Numbers ( int A [ ] , int arr_@@ size , int sum ) { int l , r ; for ( int i = 0 ; i < arr_@@ size - 2 ; i ++ ) { for ( int j = i + 1 ; j < arr_@@ size - 1 ; j ++ ) { for ( int k = j + 1 ; k < arr_@@ size ; k ++ ) { if ( A [ i ] + A [ j ] + A [ k ] == sum ) { cout << " Trip@@ let ▁ is ▁ " << A [ i ] << " , ▁ " << A [ j ] << " , ▁ " << A [ k ] ; return true ; } } } } return false ; } int main ( ) { int A [ ] = { 1 , 4 , 45 , 6 , 10 , 8 } ; int sum = 22 ; int arr_@@ size = sizeof ( A ) / sizeof ( A [ 0 ] ) ; find@@ 3@@ Numbers ( A , arr_@@ size , sum ) ; return 0 ; }
Sub@@ array / Sub@@ string vs Sub@@ sequence and Program@@ s to Generate them 1760 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void sub@@ Array ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { for ( int k = i ; k <= j ; k ++ ) cout << arr [ k ] << " ▁ " ; cout << endl ; } } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " All ▁ Non - empty ▁ Sub@@ arrays STRNEWLINE " ; sub@@ Array ( arr , n ) ; return 0 ; }
Check if array elements are consecutive | Added Method 3 1767 | #@@ include <@@ st@@ dio@@ .@@ h@@ > NEW_LINE #@@ include <@@ std@@ lib@@ .@@ h@@ > NEW_LINE int get@@ Min ( int arr [ ] , int n ) ; int getMax ( int arr [ ] , int n ) ; bool are@@ Con@@ sec@@ utive ( int arr [ ] , int n ) { if ( n < 1 ) return false ; int min = get@@ Min ( arr , n ) ; int max = getMax ( arr , n ) ; if ( max - min + 1 == n ) { bool * visited = ( bool * ) calloc ( n , sizeof ( bool ) ) ; int i ; for ( i = 0 ; i < n ; i ++ ) { if ( visited [ arr [ i ] - min ] != false ) return false ; visited [ arr [ i ] - min ] = true ; } return true ; } return false ; } int get@@ Min ( int arr [ ] , int n ) { int min = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] < min ) min = arr [ i ] ; return min ; } int getMax ( int arr [ ] , int n ) { int max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > max ) max = arr [ i ] ; return max ; } int main ( ) { int arr [ ] = { 5 , 4 , 2 , 3 , 1 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( are@@ Con@@ sec@@ utive ( arr , n ) == true ) printf ( " ▁ Array ▁ elements ▁ are ▁ consecutive ▁ " ) ; else printf ( " ▁ Array ▁ elements ▁ are ▁ not ▁ consecutive ▁ " ) ; get@@ char ( ) ; return 0 ; }
Linear Search 1786 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int search ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == x ) return i ; return -1 ; } int main ( void ) { int arr [ ] = { 2 , 3 , 4 , 10 , 40 } ; int x = 10 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int result = search ( arr , n , x ) ; ( result == -1 ) ? cout << " Element ▁ is ▁ not ▁ present ▁ in ▁ array " : cout << " Element ▁ is ▁ present ▁ at ▁ index ▁ " << result ; return 0 ; }
Binary Search 1788 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int binary@@ Search ( int arr [ ] , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binary@@ Search ( arr , l , mid - 1 , x ) ; return binary@@ Search ( arr , mid + 1 , r , x ) ; } return -1 ; } int main ( void ) { int arr [ ] = { 2 , 3 , 4 , 10 , 40 } ; int x = 10 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int result = binary@@ Search ( arr , 0 , n - 1 , x ) ; ( result == -1 ) ? cout << " Element ▁ is ▁ not ▁ present ▁ in ▁ array " : cout << " Element ▁ is ▁ present ▁ at ▁ index ▁ " << result ; return 0 ; }
Coun@@ ting Sort 1802 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE #@@ include <@@ string@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define RANGE 255 NEW_LINE void count@@ Sort ( char arr [ ] ) { char output [ strlen ( arr ) ] ; int count [ RANGE + 1 ] , i ; memset ( count , 0 , sizeof ( count ) ) ; for ( i = 0 ; arr [ i ] ; ++ i ) ++ count [ arr [ i ] ] ; for ( i = 1 ; i <= RANGE ; ++ i ) count [ i ] += count [ i - 1 ] ; for ( i = 0 ; arr [ i ] ; ++ i ) { output [ count [ arr [ i ] ] - 1 ] = arr [ i ] ; -- count [ arr [ i ] ] ; } for ( i = 0 ; arr [ i ] ; ++ i ) arr [ i ] = output [ i ] ; } int main ( ) { char arr [ ] = " ge@@ ek@@ s@@ forge@@ e@@ ks " ; count@@ Sort ( arr ) ; cout << " Sorted ▁ character ▁ array ▁ is ▁ " << arr ; return 0 ; }
Coun@@ ting Sort 1803 | #@@ include <@@ algorithm@@ > NEW_LINE #@@ include <@@ io@@ stream@@ > NEW_LINE #@@ include <@@ vector@@ > NEW_LINE using namespace std ; void count@@ Sort ( vector < int > & arr ) { int max = * max_@@ element ( arr . begin ( ) , arr . end ( ) ) ; int min = * min_@@ element ( arr . begin ( ) , arr . end ( ) ) ; int range = max - min + 1 ; vector < int > count ( range ) , output ( arr . size ( ) ) ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) count [ arr [ i ] - min ] ++ ; for ( int i = 1 ; i < count . size ( ) ; i ++ ) count [ i ] += count [ i - 1 ] ; for ( int i = arr . size ( ) - 1 ; i >= 0 ; i -- ) { output [ count [ arr [ i ] - min ] - 1 ] = arr [ i ] ; count [ arr [ i ] - min ] -- ; } for ( int i = 0 ; i < arr . size ( ) ; i ++ ) arr [ i ] = output [ i ] ; } void print@@ Array ( vector < int > & arr ) { for ( int i = 0 ; i < arr . size ( ) ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << " STRNEWLINE " ; } int main ( ) { vector < int > arr = { -@@ 5 , -@@ 10 , 0 , -@@ 3 , 8 , 5 , -1 , 10 } ; count@@ Sort ( arr ) ; print@@ Array ( arr ) ; return 0 ; }
Cycle Sort 1808 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; void cycle@@ Sort ( int arr [ ] , int n ) { int writes = 0 ; for ( int cycle@@ _start = 0 ; cycle@@ _start <= n - 2 ; cycle@@ _start ++ ) { int item = arr [ cycle@@ _start ] ; int pos = cycle@@ _start ; for ( int i = cycle@@ _start + 1 ; i < n ; i ++ ) if ( arr [ i ] < item ) pos ++ ; if ( pos == cycle@@ _start ) continue ; while ( item == arr [ pos ] ) pos += 1 ; if ( pos != cycle@@ _start ) { swap ( item , arr [ pos ] ) ; writes ++ ; } while ( pos != cycle@@ _start ) { pos = cycle@@ _start ; for ( int i = cycle@@ _start + 1 ; i < n ; i ++ ) if ( arr [ i ] < item ) pos += 1 ; while ( item == arr [ pos ] ) pos += 1 ; if ( item != arr [ pos ] ) { swap ( item , arr [ pos ] ) ; writes ++ ; } } } } int main ( ) { int arr [ ] = { 1 , 8 , 3 , 9 , 10 , 10 , 2 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cycle@@ Sort ( arr , n ) ; cout << " After ▁ sort ▁ : ▁ " << endl ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
Find the closest pair from two sorted arrays 1818 | #@@ include <@@ io@@ stream@@ > NEW_LINE #@@ include <@@ cli@@ mit@@ s@@ > NEW_LINE #@@ include <@@ c@@ std@@ lib@@ > NEW_LINE using namespace std ; void print@@ Close@@ st ( int ar@@ 1 [ ] , int ar@@ 2 [ ] , int m , int n , int x ) { int diff = INT_MAX ; int res_@@ l , res_@@ r ; int l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( abs ( ar@@ 1 [ l ] + ar@@ 2 [ r ] - x ) < diff ) { res_@@ l = l ; res_@@ r = r ; diff = abs ( ar@@ 1 [ l ] + ar@@ 2 [ r ] - x ) ; } if ( ar@@ 1 [ l ] + ar@@ 2 [ r ] > x ) r -- ; else l ++ ; } cout << " The ▁ closest ▁ pair ▁ is ▁ [ " << ar@@ 1 [ res_@@ l ] << " , ▁ " << ar@@ 2 [ res_@@ r ] << " ] ▁ STRNEWLINE " ; } int main ( ) { int ar@@ 1 [ ] = { 1 , 4 , 5 , 7 } ; int ar@@ 2 [ ] = { 10 , 20 , 30 , 40 } ; int m = sizeof ( ar@@ 1 ) / sizeof ( ar@@ 1 [ 0 ] ) ; int n = sizeof ( ar@@ 2 ) / sizeof ( ar@@ 2 [ 0 ] ) ; int x = 38 ; print@@ Close@@ st ( ar@@ 1 , ar@@ 2 , m , n , x ) ; return 0 ; }
Activity Selection Problem | Gre@@ edy Algo 1824 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ Max@@ Activities ( int s [ ] , int f [ ] , int n ) { int i , j ; cout << " Following ▁ activities ▁ are ▁ selected ▁ " << endl ; i = 0 ; cout << " ▁ " << i ; for ( j = 1 ; j < n ; j ++ ) { if ( s [ j ] >= f [ i ] ) { cout << " ▁ " << j ; i = j ; } } } int main ( ) { int s [ ] = { 1 , 3 , 0 , 5 , 8 , 5 } ; int f [ ] = { 2 , 4 , 6 , 7 , 9 , 9 } ; int n = sizeof ( s ) / sizeof ( s [ 0 ] ) ; print@@ Max@@ Activities ( s , f , n ) ; return 0 ; }
Bin@@ omial Coefficient | DP 1854 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int bin@@ omi@@ al@@ Coeff ( int n , int k ) { if ( k > n ) return 0 ; if ( k == 0 k == n ) return 1 ; return bin@@ omi@@ al@@ Coeff ( n - 1 , k - 1 ) + bin@@ omi@@ al@@ Coeff ( n - 1 , k ) ; } int main ( ) { int n = 5 , k = 2 ; cout << " Value ▁ of ▁ C ( " << n << " , ▁ " << k << " ) ▁ is ▁ " << bin@@ omi@@ al@@ Coeff ( n , k ) ; return 0 ; }
Mobile Numeric Keyp@@ ad Problem 1918 | #@@ include <@@ st@@ dio@@ .@@ h@@ > NEW_LINE int getCount ( char keyp@@ ad [ ] [ 3 ] , int n ) { if ( keyp@@ ad == NULL n <= 0 ) return 0 ; if ( n == 1 ) return 10 ; int row [ ] = { 0 , 0 , -1 , 0 , 1 } ; int col [ ] = { 0 , -1 , 0 , 1 , 0 } ; int count [ 10 ] [ n + 1 ] ; int i = 0 , j = 0 , k = 0 , move = 0 , ro = 0 , co = 0 , num = 0 ; int next@@ Num = 0 , totalCount = 0 ; for ( i = 0 ; i <= 9 ; i ++ ) { count [ i ] [ 0 ] = 0 ; count [ i ] [ 1 ] = 1 ; } for ( k = 2 ; k <= n ; k ++ ) { for ( i = 0 ; i < 4 ; i ++ ) { for ( j = 0 ; j < 3 ; j ++ ) { if ( keyp@@ ad [ i ] [ j ] != ' * ' && keyp@@ ad [ i ] [ j ] != ' # ' ) { num = keyp@@ ad [ i ] [ j ] - '0' ; count [ num ] [ k ] = 0 ; for ( move = 0 ; move < 5 ; move ++ ) { ro = i + row [ move ] ; co = j + col [ move ] ; if ( ro >= 0 && ro <= 3 && co >= 0 && co <= 2 && keyp@@ ad [ ro ] [ co ] != ' * ' && keyp@@ ad [ ro ] [ co ] != ' # ' ) { next@@ Num = keyp@@ ad [ ro ] [ co ] - '0' ; count [ num ] [ k ] += count [ next@@ Num ] [ k - 1 ] ; } } } } } } totalCount = 0 ; for ( i = 0 ; i <= 9 ; i ++ ) totalCount += count [ i ] [ n ] ; return totalCount ; } int main ( int argc , char * argv [ ] ) { char keyp@@ ad [ 4 ] [ 3 ] = { { '1' , '2' , '3' } , { '4' , '5' , '6' } , { '7' , '8' , '9' } , { ' * ' , '0' , ' # ' } } ; printf ( " Count ▁ for ▁ numbers ▁ of ▁ length ▁ % d : ▁ % dn " , 1 , getCount ( keyp@@ ad , 1 ) ) ; printf ( " Count ▁ for ▁ numbers ▁ of ▁ length ▁ % d : ▁ % dn " , 2 , getCount ( keyp@@ ad , 2 ) ) ; printf ( " Count ▁ for ▁ numbers ▁ of ▁ length ▁ % d : ▁ % dn " , 3 , getCount ( keyp@@ ad , 3 ) ) ; printf ( " Count ▁ for ▁ numbers ▁ of ▁ length ▁ % d : ▁ % dn " , 4 , getCount ( keyp@@ ad , 4 ) ) ; printf ( " Count ▁ for ▁ numbers ▁ of ▁ length ▁ % d : ▁ % dn " , 5 , getCount ( keyp@@ ad , 5 ) ) ; return 0 ; }
Count of n digit numbers whose sum of digits equals to given sum 1920 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; unsigned long long int count@@ Rec ( int n , int sum ) { if ( n == 0 ) return sum == 0 ; if ( sum == 0 ) return 1 ; unsigned long long int ans = 0 ; for ( int i = 0 ; i <= 9 ; i ++ ) if ( sum - i >= 0 ) ans += count@@ Rec ( n - 1 , sum - i ) ; return ans ; } unsigned long long int final@@ Count ( int n , int sum ) { unsigned long long int ans = 0 ; for ( int i = 1 ; i <= 9 ; i ++ ) if ( sum - i >= 0 ) ans += count@@ Rec ( n - 1 , sum - i ) ; return ans ; } int main ( ) { int n = 2 , sum = 5 ; cout << final@@ Count ( n , sum ) ; return 0 ; }
Count of n digit numbers whose sum of digits equals to given sum 1922 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; void find@@ Count ( int n , int sum ) { int start = pow ( 10 , n - 1 ) ; int end = pow ( 10 , n ) - 1 ; int count = 0 ; int i = start ; while ( i <= end ) { int cur = 0 ; int temp = i ; while ( temp != 0 ) { cur += temp % 10 ; temp = temp / 10 ; } if ( cur == sum ) { count ++ ; i += 9 ; } else i ++ ; } cout << count ; } int main ( ) { int n = 3 ; int sum = 5 ; find@@ Count ( n , sum ) ; return 0 ; }
Minimum number of squares whose sum equals to given number n 1926 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int getMin@@ Squ@@ ares ( unsigned int n ) { if ( sqrt ( n ) - floor ( sqrt ( n ) ) == 0 ) return 1 ; if ( n <= 3 ) return n ; int res = n ; for ( int x = 1 ; x <= n ; x ++ ) { int temp = x * x ; if ( temp > n ) break ; else res = min ( res , 1 + getMin@@ Squ@@ ares ( n - temp ) ) ; } return res ; } int main ( ) { cout << getMin@@ Squ@@ ares ( 6 ) ; return 0 ; }
Compute sum of digits in all numbers from 1 to n 1937 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int sum@@ Of@@ Digit@@ sFrom@@ 1@@ To@@ N@@ Util ( int n , int a [ ] ) { if ( n < 10 ) return ( n * ( n + 1 ) / 2 ) ; int d = ( int ) ( log10 ( n ) ) ; int p = ( int ) ( ceil ( pow ( 10 , d ) ) ) ; int ms@@ d = n / p ; return ( ms@@ d * a [ d ] + ( ms@@ d * ( ms@@ d - 1 ) / 2 ) * p + ms@@ d * ( 1 + n % p ) + sum@@ Of@@ Digit@@ sFrom@@ 1@@ To@@ N@@ Util ( n % p , a ) ) ; } int sum@@ Of@@ Digit@@ sFrom@@ 1@@ To@@ N ( int n ) { int d = ( int ) ( log10 ( n ) ) ; int a [ d + 1 ] ; a [ 0 ] = 0 ; a [ 1 ] = 45 ; for ( int i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 10 + 45 * ( int ) ( ceil ( pow ( 10 , i - 1 ) ) ) ; return sum@@ Of@@ Digit@@ sFrom@@ 1@@ To@@ N@@ Util ( n , a ) ; } int main ( ) { int n = 328 ; cout << " Sum ▁ of ▁ digits ▁ in ▁ numbers ▁ from ▁ 1 ▁ to ▁ " << n << " ▁ is ▁ " << sum@@ Of@@ Digit@@ sFrom@@ 1@@ To@@ N ( n ) ; }
How to print maximum number of A '@@ s using given four keys 1939 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ optimal ( int N ) { if ( N <= 6 ) return N ; int max = 0 ; int b ; for ( b = N - 3 ; b >= 1 ; b -- ) { int curr = ( N - b - 1 ) * find@@ optimal ( b ) ; if ( curr > max ) max = curr ; } return max ; } int main ( ) { int N ; for ( N = 1 ; N <= 20 ; N ++ ) cout << " Maximum ▁ Number ▁ of ▁ A ' s ▁ with ▁ " << N << " ▁ key@@ stro@@ kes ▁ is ▁ " << find@@ optimal ( N ) << endl ; }
Optim@@ ized Nai@@ ve Algorithm for Pattern Search@@ ing 1955 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void search ( string pat , string txt ) { int M = pat . size ( ) ; int N = txt . size ( ) ; int i = 0 ; while ( i <= N - M ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; if ( j == M ) { cout << " Pattern ▁ found ▁ at ▁ index ▁ " << i << endl ; i = i + M ; } else if ( j == 0 ) i = i + 1 ; else i = i + j ; } } int main ( ) { string txt = " AB@@ CE@@ AB@@ CD@@ AB@@ CE@@ ABC@@ D " ; string pat = " ABC@@ D " ; search ( pat , txt ) ; return 0 ; }
Write a program to calculate pow ( x , n ) 1978 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; float power ( float x , int y ) { float temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else { if ( y > 0 ) return x * temp * temp ; else return ( temp * temp ) / x ; } } int main ( ) { float x = 2 ; int y = -@@ 3 ; cout << power ( x , y ) ; return 0 ; }
Medi@@ an of two sorted arrays of same size 1981 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int get@@ Medi@@ an ( int ar@@ 1 [ ] , int ar@@ 2 [ ] , int n ) { int i = 0 ; int j = 0 ; int count ; int m1 = -1 , m2 = -1 ; for ( count = 0 ; count <= n ; count ++ ) { if ( i == n ) { m1 = m2 ; m2 = ar@@ 2 [ 0 ] ; break ; } else if ( j == n ) { m1 = m2 ; m2 = ar@@ 1 [ 0 ] ; break ; } if ( ar@@ 1 [ i ] <= ar@@ 2 [ j ] ) { m1 = m2 ; m2 = ar@@ 1 [ i ] ; i ++ ; } else { m1 = m2 ; m2 = ar@@ 2 [ j ] ; j ++ ; } } return ( m1 + m2 ) / 2 ; } int main ( ) { int ar@@ 1 [ ] = { 1 , 12 , 15 , 26 , 38 } ; int ar@@ 2 [ ] = { 2 , 13 , 17 , 30 , 45 } ; int n1 = sizeof ( ar@@ 1 ) / sizeof ( ar@@ 1 [ 0 ] ) ; int n2 = sizeof ( ar@@ 2 ) / sizeof ( ar@@ 2 [ 0 ] ) ; if ( n1 == n2 ) cout << " Medi@@ an ▁ is ▁ " << get@@ Medi@@ an ( ar@@ 1 , ar@@ 2 , n1 ) ; else cout << " Doesn ' t ▁ work ▁ for ▁ arrays " << " ▁ of ▁ un@@ equal ▁ size " ; get@@ char ( ) ; return 0 ; }
B@@ aby@@ lon@@ ian method for square root 1996 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; class g@@ fg { public : float square@@ Root ( float n ) { float x = n ; float y = 1 ; float e = 0.000001 ; while ( x - y > e ) { x = ( x + y ) / 2 ; y = n / x ; } return x ; } } ; int main ( ) { g@@ fg g ; int n = 50 ; cout << " Square ▁ root ▁ of ▁ " << n << " ▁ is ▁ " << g . square@@ Root ( n ) ; get@@ char ( ) ; }
Multiply two integers without using multiplication , division and bitwise operators , and no loops 1998 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; class GF@@ G { public : int multiply ( int x , int y ) { if ( y == 0 ) return 0 ; if ( y > 0 ) return ( x + multiply ( x , y - 1 ) ) ; if ( y < 0 ) return - multiply ( x , - y ) ; } } ; int main ( ) { GF@@ G g ; cout << endl << g . multiply ( 5 , -@@ 11 ) ; get@@ char ( ) ; return 0 ; }
Write you own Power without using multiplication ( * ) and division ( / ) operators 2000 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int pow ( int a , int b ) { if ( b == 0 ) return 1 ; int answer = a ; int increment = a ; int i , j ; for ( i = 1 ; i < b ; i ++ ) { for ( j = 1 ; j < a ; j ++ ) { answer += increment ; } increment = answer ; } return answer ; } int main ( ) { cout << pow ( 5 , 3 ) ; return 0 ; }
Write you own Power without using multiplication ( * ) and division ( / ) operators 2001 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int multiply ( int x , int y ) { if ( y ) return ( x + multiply ( x , y - 1 ) ) ; else return 0 ; } int pow ( int a , int b ) { if ( b ) return multiply ( a , pow ( a , b - 1 ) ) ; else return 1 ; } int main ( ) { cout << pow ( 5 , 3 ) ; get@@ char ( ) ; return 0 ; }
Average of a stream of numbers 2011 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; float get@@ Avg ( int x ) { static int sum , n ; sum += x ; return ( ( ( float ) sum ) / ++ n ) ; } void stream@@ Avg ( float arr [ ] , int n ) { float avg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { avg = get@@ Avg ( arr [ i ] ) ; cout << " Average ▁ of ▁ " << i + 1 << " ▁ numbers ▁ is ▁ " << fixed << setprecision ( 1 ) << avg << endl ; } return ; } int main ( ) { float arr [ ] = { 10 , 20 , 30 , 40 , 50 , 60 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; stream@@ Avg ( arr , n ) ; return 0 ; }
Count numbers that don '@@ t contain 3 2012 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count ( int n ) { if ( n < 3 ) return n ; if ( n >= 3 && n < 10 ) return n - 1 ; int po = 1 ; while ( n / po > 9 ) po = po * 10 ; int ms@@ d = n / po ; if ( ms@@ d != 3 ) return count ( ms@@ d ) * count ( po - 1 ) + count ( ms@@ d ) + count ( n % po ) ; else return count ( ms@@ d * po - 1 ) ; } int main ( ) { cout << count ( 57@@ 8 ) << " ▁ " ; return 0 ; }
Pas@@ cal '@@ s Triangle 2026 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ Pas@@ cal ( int n ) { for ( int line = 1 ; line <= n ; line ++ ) { int C = 1 ; for ( int i = 1 ; i <= line ; i ++ ) { cout << C << " ▁ " ; C = C * ( line - i ) / i ; } cout << " STRNEWLINE " ; } } int main ( ) { int n = 5 ; print@@ Pas@@ cal ( n ) ; return 0 ; }
Print all possible combinations of r elements in a given array of size n 2031 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void combin@@ ation@@ Util ( int arr [ ] , int data [ ] , int start , int end , int index , int r ) ; void print@@ Combination ( int arr [ ] , int n , int r ) { int data [ r ] ; combin@@ ation@@ Util ( arr , data , 0 , n - 1 , 0 , r ) ; } void combin@@ ation@@ Util ( int arr [ ] , int data [ ] , int start , int end , int index , int r ) { if ( index == r ) { for ( int j = 0 ; j < r ; j ++ ) cout << data [ j ] << " ▁ " ; cout << endl ; return ; } for ( int i = start ; i <= end && end - i + 1 >= r - index ; i ++ ) { data [ index ] = arr [ i ] ; combin@@ ation@@ Util ( arr , data , i + 1 , end , index + 1 , r ) ; } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int r = 3 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; print@@ Combination ( arr , n , r ) ; }
Count all possible groups of size 2 or 3 that have sum as multiple of 3 2035 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ groups ( int arr [ ] , int n ) { int c [ 3 ] = { 0 } , i ; int res = 0 ; for ( i = 0 ; i < n ; i ++ ) c [ arr [ i ] % 3 ] ++ ; res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) ; res += c [ 1 ] * c [ 2 ] ; res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 ; res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6 ; res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) ; res += c [ 0 ] * c [ 1 ] * c [ 2 ] ; return res ; } int main ( ) { int arr [ ] = { 3 , 6 , 7 , 2 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Required ▁ number ▁ of ▁ groups ▁ are ▁ " << find@@ groups ( arr , n ) << endl ; return 0 ; }
Calculate the angle between hour hand and minute hand 2048 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int min ( int x , int y ) { return ( x < y ) ? x : y ; } int calc@@ Angle ( double h , double m ) { if ( h < 0 m < 0 h > 12 m > 60 ) printf ( " Wrong ▁ input " ) ; if ( h == 12 ) h = 0 ; if ( m == 60 ) { m = 0 ; h += 1 ; if ( h > 12 ) h = h - 12 ; } float hour@@ _@@ angle = 0.5 * ( h * 60 + m ) ; float minu@@ te_@@ angle = 6 * m ; float angle = abs ( hour@@ _@@ angle - minu@@ te_@@ angle ) ; angle = min ( 360 - angle , angle ) ; return angle ; } int main ( ) { cout << calc@@ Angle ( 9 , 60 ) << endl ; cout << calc@@ Angle ( 3 , 30 ) << endl ; return 0 ; }
Birth@@ day Par@@ ado@@ x 2052 | #@@ include <@@ c@@ math@@ > NEW_LINE #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int find ( double p ) { return ceil ( sqrt ( 2 * 365 * log ( 1 / ( 1 - p ) ) ) ) ; } int main ( ) { cout << find ( 0.@@ 70 ) ; }
Program for Method Of False Position 2063 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define MAX_@@ ITER 1000000 NEW_LINE double func ( double x ) { return x * x * x - x * x + 2 ; } void reg@@ ula@@ Fal@@ si ( double a , double b ) { if ( func ( a ) * func ( b ) >= 0 ) { cout << " You ▁ have ▁ not ▁ assumed ▁ right ▁ a ▁ and ▁ b STRNEWLINE " ; return ; } double c = a ; for ( int i = 0 ; i < MAX_@@ ITER ; i ++ ) { c = ( a * func ( b ) - b * func ( a ) ) / ( func ( b ) - func ( a ) ) ; if ( func ( c ) == 0 ) break ; else if ( func ( c ) * func ( a ) < 0 ) b = c ; else a = c ; } cout << " The ▁ value ▁ of ▁ root ▁ is ▁ : ▁ " << c ; } int main ( ) { double a = -@@ 200 , b = 300 ; reg@@ ula@@ Fal@@ si ( a , b ) ; return 0 ; }
Swap bits in a given number 2076 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int swap@@ Bits ( unsigned int x , unsigned int p1 , unsigned int p2 , unsigned int n ) { unsigned int set1 = ( x >> p1 ) & ( ( 1U << n ) - 1 ) ; unsigned int set2 = ( x >> p2 ) & ( ( 1U << n ) - 1 ) ; unsigned int Xor = ( set1 ^ set2 ) ; Xor = ( Xor << p1 ) | ( Xor << p2 ) ; unsigned int result = x ^ Xor ; return result ; } int main ( ) { int res = swap@@ Bits ( 28 , 0 , 3 , 2 ) ; cout << " Result ▁ = ▁ " << res ; return 0 ; }
Turn off the right@@ most set bit 2095 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int fun ( unsigned int n ) { return n & ( n - 1 ) ; } int main ( ) { int n = 7 ; cout << " The ▁ number ▁ after ▁ un@@ setting ▁ the " ; cout << " ▁ right@@ most ▁ set ▁ bit ▁ " << fun ( n ) ; return 0 ; }
Find whether a given number is a power of 4 or not 2097 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ PowerOf@@ Four ( unsigned int n ) { int count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) { while ( n > 1 ) { n >>= 1 ; count += 1 ; } return ( count % 2 == 0 ) ? 1 : 0 ; } return 0 ; } int main ( ) { int test_@@ no = 64 ; if ( is@@ PowerOf@@ Four ( test_@@ no ) ) cout << test_@@ no << " ▁ is ▁ a ▁ power ▁ of ▁ 4" ; else cout << test_@@ no << " ▁ is ▁ not ▁ a ▁ power ▁ of ▁ 4" ; }
Compute the minimum or maximum of two integers without branch@@ ing 2103 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; class g@@ fg { public : int min ( int x , int y ) { return y ^ ( ( x ^ y ) & - ( x < y ) ) ; } int max ( int x , int y ) { return x ^ ( ( x ^ y ) & - ( x < y ) ) ; } } ; int main ( ) { g@@ fg g ; int x = 15 ; int y = 6 ; cout << " Minimum ▁ of ▁ " << x << " ▁ and ▁ " << y << " ▁ is ▁ " ; cout << g . min ( x , y ) ; cout << " Maximum of " ▁ < < ▁ x ▁ < < STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL " and " ▁ < < ▁ y ▁ < < ▁ " is " cout << g . max ( x , y ) ; get@@ char ( ) ; }
Find the Number Oc@@ curr@@ ing Odd Number of Times 2108 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int getO@@ dd@@ Occurren@@ ce ( int arr [ ] , int size ) { unordered_map < int , int > hash ; for ( int i = 0 ; i < size ; i ++ ) { hash [ arr [ i ] ] ++ ; } for ( auto i : hash ) { if ( i . second % 2 != 0 ) { return i . first ; } } return -1 ; } int main ( ) { int arr [ ] = { 2 , 3 , 5 , 4 , 5 , 2 , 4 , 3 , 5 , 2 , 4 , 4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << getO@@ dd@@ Occurren@@ ce ( arr , n ) ; return 0 ; }
Count set bits in an integer 2120 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int num_@@ to_@@ bits [ 16 ] = { 0 , 1 , 1 , 2 , 1 , 2 , 2 , 3 , 1 , 2 , 2 , 3 , 2 , 3 , 3 , 4 } ; unsigned int count@@ Set@@ Bits@@ Rec ( unsigned int num ) { int ni@@ bble = 0 ; if ( 0 == num ) return num_@@ to_@@ bits [ 0 ] ; ni@@ bble = num & 0xf ; return num_@@ to_@@ bits [ ni@@ bble ] + count@@ Set@@ Bits@@ Rec ( num >> 4 ) ; } int main ( ) { int num = 31 ; cout << count@@ Set@@ Bits@@ Rec ( num ) ; return 0 ; }
S@@ malle@@ st power of 2 greater than or equal to n 2125 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; unsigned int next@@ PowerOf@@ 2 ( unsigned int n ) { n -- ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n ++ ; return n ; } int main ( ) { unsigned int n = 5 ; cout << next@@ PowerOf@@ 2 ( n ) ; return 0 ; }
Program to find whether a no is power of two 2129 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ PowerOf@@ Two ( int n ) { if ( n == 0 ) return false ; return ( ceil ( log2 ( n ) ) == floor ( log2 ( n ) ) ) ; } int main ( ) { is@@ PowerOf@@ Two ( 31 ) ? cout << " Yes " << endl : cout << " No " << endl ; is@@ PowerOf@@ Two ( 64 ) ? cout << " Yes " << endl : cout << " No " << endl ; return 0 ; }
Program to find whether a no is power of two 2130 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ PowerOf@@ Two ( int n ) { if ( n == 0 ) return 0 ; while ( n != 1 ) { if ( n % 2 != 0 ) return 0 ; n = n / 2 ; } return 1 ; } int main ( ) { is@@ PowerOf@@ Two ( 31 ) ? cout << " Yes STRNEWLINE " : cout << " No STRNEWLINE " ; is@@ PowerOf@@ Two ( 64 ) ? cout << " Yes STRNEWLINE " : cout << " No STRNEWLINE " ; return 0 ; }
Position of right@@ most set bit 2133 | #@@ include <@@ io@@ stream@@ > NEW_LINE #@@ include <@@ math@@ .@@ h@@ > NEW_LINE using namespace std ; class g@@ fg { public : unsigned int getFirst@@ Set@@ Bit@@ Pos ( int n ) { return log2 ( n & - n ) + 1 ; } } ; int main ( ) { g@@ fg g ; int n = 12 ; cout << g . getFirst@@ Set@@ Bit@@ Pos ( n ) ; return 0 ; }
Swap all odd and even bits 2142 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; unsigned int swap@@ Bits ( unsigned int x ) { unsigned int even@@ _bits = x & 0x@@ AAAA@@ AAAA ; unsigned int od@@ d_@@ bits = x & 0x5@@ 5555@@ 555 ; even@@ _bits >>= 1 ; od@@ d_@@ bits <<= 1 ; return ( even@@ _bits od@@ d_@@ bits ) ; } int main ( ) { unsigned int x = 23 ; cout << swap@@ Bits ( x ) ; return 0 ; }
Find position of the only set bit 2144 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int is@@ PowerOf@@ Two ( unsigned n ) { return n && ( ! ( n & ( n - 1 ) ) ) ; } int find@@ Position ( unsigned n ) { if ( ! is@@ PowerOf@@ Two ( n ) ) return -1 ; unsigned count = 0 ; while ( n ) { n = n >> 1 ; ++ count ; } return count ; } int main ( void ) { int n = 0 ; int pos = find@@ Position ( n ) ; ( pos == -1 ) ? cout << " n ▁ = ▁ " << n << " , ▁ Invalid ▁ number STRNEWLINE " : cout << " n ▁ = ▁ " << n << " , ▁ Position ▁ " << pos << endl ; n = 12 ; pos = find@@ Position ( n ) ; ( pos == -1 ) ? cout << " n ▁ = ▁ " << n << " , ▁ Invalid ▁ number STRNEWLINE " : cout << " n ▁ = ▁ " << n << " , ▁ Position ▁ " << pos << endl ; n = 128 ; pos = find@@ Position ( n ) ; ( pos == -1 ) ? cout << " n ▁ = ▁ " << n << " , ▁ Invalid ▁ number STRNEWLINE " : cout << " n ▁ = ▁ " << n << " , ▁ Position ▁ " << pos << endl ; return 0 ; }
Replace every element with the gre@@ atest element on right side 2174 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void next@@ Gre@@ atest ( int arr [ ] , int size ) { int max_@@ from_@@ right = arr [ size - 1 ] ; arr [ size - 1 ] = -1 ; for ( int i = size - 2 ; i >= 0 ; i -- ) { int temp = arr [ i ] ; arr [ i ] = max_@@ from_@@ right ; if ( max_@@ from_@@ right < temp ) max_@@ from_@@ right = temp ; } } void print@@ Array ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << endl ; } int main ( ) { int arr [ ] = { 16 , 17 , 4 , 3 , 5 , 2 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; next@@ Gre@@ atest ( arr , size ) ; cout << " The ▁ modified ▁ array ▁ is : ▁ STRNEWLINE " ; print@@ Array ( arr , size ) ; return ( 0 ) ; }
Maximum circular sub@@ array sum 2176 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max@@ Circular@@ Sum ( int a [ ] , int n ) { if ( n == 1 ) return a [ 0 ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } int curr_@@ max = a [ 0 ] , max_@@ so@@ _f@@ ar = a [ 0 ] , curr_@@ min = a [ 0 ] , min_@@ so@@ _f@@ ar = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { curr_@@ max = max ( curr_@@ max + a [ i ] , a [ i ] ) ; max_@@ so@@ _f@@ ar = max ( max_@@ so@@ _f@@ ar , curr_@@ max ) ; curr_@@ min = min ( curr_@@ min + a [ i ] , a [ i ] ) ; min_@@ so@@ _f@@ ar = min ( min_@@ so@@ _f@@ ar , curr_@@ min ) ; } if ( min_@@ so@@ _f@@ ar == sum ) return max_@@ so@@ _f@@ ar ; return max ( max_@@ so@@ _f@@ ar , sum - min_@@ so@@ _f@@ ar ) ; } int main ( ) { int a [ ] = { 11 , 10 , -@@ 20 , 5 , -@@ 3 , -@@ 5 , 8 , -@@ 13 , 10 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << " Maximum ▁ circular ▁ sum ▁ is ▁ " << max@@ Circular@@ Sum ( a , n ) << endl ; return 0 ; }
Maximum difference between two elements such that larger element appears after the smaller number 2190 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max@@ Diff ( int arr [ ] , int arr_@@ size ) { int max_@@ diff = arr [ 1 ] - arr [ 0 ] ; for ( int i = 0 ; i < arr_@@ size ; i ++ ) { for ( int j = i + 1 ; j < arr_@@ size ; j ++ ) { if ( arr [ j ] - arr [ i ] > max_@@ diff ) max_@@ diff = arr [ j ] - arr [ i ] ; } } return max_@@ diff ; } int main ( ) { int arr [ ] = { 1 , 2 , 90 , 10 , 110 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Maximum ▁ difference ▁ is ▁ " << max@@ Diff ( arr , n ) ; return 0 ; }
Find the maximum element in an array which is first increasing and then decre@@ asing 2200 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Maximum ( int arr [ ] , int low , int high ) { if ( low == high ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] >= arr [ high ] ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] < arr [ high ] ) return arr [ high ] ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] > arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] < arr [ mid - 1 ] ) return find@@ Maximum ( arr , low , mid - 1 ) ; else return find@@ Maximum ( arr , mid + 1 , high ) ; } int main ( ) { int arr [ ] = { 1 , 3 , 50 , 10 , 9 , 7 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " The ▁ maximum ▁ element ▁ is ▁ " << find@@ Maximum ( arr , 0 , n - 1 ) ; return 0 ; }
Minimum adjacent sw@@ aps required to Sort Binary array 2258 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Min@@ Sw@@ aps ( int arr [ ] , int n ) { int noOf@@ Zero@@ es [ n ] ; memset ( noOf@@ Zero@@ es , 0 , sizeof ( noOf@@ Zero@@ es ) ) ; int i , count = 0 ; noOf@@ Zero@@ es [ n - 1 ] = 1 - arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) { noOf@@ Zero@@ es [ i ] = noOf@@ Zero@@ es [ i + 1 ] ; if ( arr [ i ] == 0 ) noOf@@ Zero@@ es [ i ] ++ ; } for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 1 ) count += noOf@@ Zero@@ es [ i ] ; } return count ; } int main ( ) { int arr [ ] = { 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << find@@ Min@@ Sw@@ aps ( arr , n ) ; return 0 ; }
Minimum sw@@ aps to make two arrays identical 2283 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int min@@ Swap@@ sTo@@ Sort ( int arr [ ] , int n ) { pair < int , int > arr@@ Pos [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr@@ Pos [ i ] . first = arr [ i ] ; arr@@ Pos [ i ] . second = i ; } sort ( arr@@ Pos , arr@@ Pos + n ) ; vector < bool > vis ( n , false ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( vis [ i ] arr@@ Pos [ i ] . second == i ) continue ; int cycle@@ _size = 0 ; int j = i ; while ( ! vis [ j ] ) { vis [ j ] = 1 ; j = arr@@ Pos [ j ] . second ; cycle@@ _size ++ ; } ans += ( cycle@@ _size - 1 ) ; } return ans ; } int min@@ Swap@@ To@@ Make@@ Array@@ Same ( int a [ ] , int b [ ] , int n ) { map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ b [ i ] ] = i ; for ( int i = 0 ; i < n ; i ++ ) b [ i ] = mp [ a [ i ] ] ; return min@@ Swap@@ sTo@@ Sort ( b , n ) ; } int main ( ) { int a [ ] = { 3 , 6 , 4 , 8 } ; int b [ ] = { 4 , 6 , 8 , 3 } ; int n = sizeof ( a ) / sizeof ( int ) ; cout << min@@ Swap@@ To@@ Make@@ Array@@ Same ( a , b , n ) ; return 0 ; }
Count trip@@ lets with sum smaller than a given value 2288 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Trip@@ lets ( int arr [ ] , int n , int sum ) { sort ( arr , arr + n ) ; int ans = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { int j = i + 1 , k = n - 1 ; while ( j < k ) { if ( arr [ i ] + arr [ j ] + arr [ k ] >= sum ) k -- ; else { ans += ( k - j ) ; j ++ ; } } } return ans ; } int main ( ) { int arr [ ] = { 5 , 1 , 3 , 4 , 7 } ; int n = sizeof arr / sizeof arr [ 0 ] ; int sum = 12 ; cout << count@@ Trip@@ lets ( arr , n , sum ) << endl ; return 0 ; }
Find the repe@@ ating and the missing | Added 3 new methods 2304 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ Two@@ Elements ( int arr [ ] , int size ) { int i ; cout << " ▁ The ▁ repe@@ ating ▁ element ▁ is ▁ " ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ abs ( arr [ i ] ) - 1 ] > 0 ) arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ] ; else cout << abs ( arr [ i ] ) << " STRNEWLINE " ; } cout << " and ▁ the ▁ missing ▁ element ▁ is ▁ " ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] > 0 ) cout << ( i + 1 ) ; } } int main ( ) { int arr [ ] = { 7 , 3 , 4 , 5 , 5 , 6 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; print@@ Two@@ Elements ( arr , n ) ; }
Find the two numbers with odd occurrences in an un@@ sorted array 2308 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ Two@@ Odd ( int arr [ ] , int size ) { int xor@@ 2 = arr [ 0 ] ; int set_@@ bit_@@ no ; int i ; int n = size - 2 ; int x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) xor@@ 2 = xor@@ 2 ^ arr [ i ] ; set_@@ bit_@@ no = xor@@ 2 & ~ ( xor@@ 2 - 1 ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] & set_@@ bit_@@ no ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } cout << " The ▁ two ▁ O@@ DD ▁ elements ▁ are ▁ " << x << " ▁ & ▁ " << y ; } int main ( ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 3 , 1 } ; int arr_@@ size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; print@@ Two@@ Odd ( arr , arr_@@ size ) ; return 0 ; }
Find a pair with the given difference 2310 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool find@@ Pair ( int arr [ ] , int size , int n ) { int i = 0 ; int j = 1 ; while ( i < size && j < size ) { if ( i != j && arr [ j ] - arr [ i ] == n ) { cout << " Pair ▁ Found : ▁ ( " << arr [ i ] << " , ▁ " << arr [ j ] << " ) " ; return true ; } else if ( arr [ j ] - arr [ i ] < n ) j ++ ; else i ++ ; } cout << " No ▁ such ▁ pair " ; return false ; } int main ( ) { int arr [ ] = { 1 , 8 , 30 , 40 , 100 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int n = 60 ; find@@ Pair ( arr , size , n ) ; return 0 ; }
Find four elements that sum to a given value | Set 2 2315 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void four@@ Sum ( int X , int arr [ ] , map < int , pair < int , int > > Map , int N ) { int temp [ N ] ; for ( int i = 0 ; i < N ; i ++ ) temp [ i ] = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { int curr_@@ sum = arr [ i ] + arr [ j ] ; if ( Map . find ( X - curr_@@ sum ) != Map . end ( ) ) { pair < int , int > p = Map [ X - curr_@@ sum ] ; if ( p . first != i && p . second != i && p . first != j && p . second != j && temp [ p . first ] == 0 && temp [ p . second ] == 0 && temp [ i ] == 0 && temp [ j ] == 0 ) { cout << arr [ i ] << " , " << arr [ j ] << " , " << arr [ p . first ] << " , " << arr [ p . second ] ; temp [ p . second ] = 1 ; temp [ i ] = 1 ; temp [ j ] = 1 ; break ; } } } } } map < int , pair < int , int > > two@@ Sum ( int nums [ ] , int N ) { map < int , pair < int , int > > Map ; for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { Map [ nums [ i ] + nums [ j ] ] . first = i ; Map [ nums [ i ] + nums [ j ] ] . second = j ; } } return Map ; } int main ( ) { int arr [ ] = { 10 , 20 , 30 , 40 , 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int X = 91 ; map < int , pair < int , int > > Map = two@@ Sum ( arr , n ) ; four@@ Sum ( X , arr , Map , n ) ; return 0 ; }
Delete an element from array ( Using two tra@@ vers@@ als and one traversal ) 2332 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int delete@@ Element ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == x ) break ; if ( i < n ) { n = n - 1 ; for ( int j = i ; j < n ; j ++ ) arr [ j ] = arr [ j + 1 ] ; } return n ; } int main ( ) { int arr [ ] = { 11 , 15 , 6 , 8 , 9 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 6 ; n = delete@@ Element ( arr , n , x ) ; cout << " Modified ▁ array ▁ is ▁ STRNEWLINE " ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
Maximum absolute difference of value and index sums 2367 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max@@ Distance ( int arr [ ] , int n ) { int max@@ 1 = INT_@@ MIN , min@@ 1 = INT_MAX ; int max@@ 2 = INT_@@ MIN , min@@ 2 = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { max@@ 1 = max ( max@@ 1 , arr [ i ] + i ) ; min@@ 1 = min ( min@@ 1 , arr [ i ] + i ) ; max@@ 2 = max ( max@@ 2 , arr [ i ] - i ) ; min@@ 2 = min ( min@@ 2 , arr [ i ] - i ) ; } return max ( max@@ 1 - min@@ 1 , max@@ 2 - min@@ 2 ) ; } int main ( ) { int arr [ ] = { -@@ 70 , -@@ 64 , -@@ 6 , -@@ 56 , 64 , 61 , -@@ 57 , 16 , 48 , -@@ 98 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << max@@ Distance ( arr , n ) << endl ; return 0 ; }
Find closest number in array 2369 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int get@@ Close@@ st ( int , int , int ) ; int find@@ Close@@ st ( int arr [ ] , int n , int target ) { if ( target <= arr [ 0 ] ) return arr [ 0 ] ; if ( target >= arr [ n - 1 ] ) return arr [ n - 1 ] ; int i = 0 , j = n , mid = 0 ; while ( i < j ) { mid = ( i + j ) / 2 ; if ( arr [ mid ] == target ) return arr [ mid ] ; if ( target < arr [ mid ] ) { if ( mid > 0 && target > arr [ mid - 1 ] ) return get@@ Close@@ st ( arr [ mid - 1 ] , arr [ mid ] , target ) ; j = mid ; } else { if ( mid < n - 1 && target < arr [ mid + 1 ] ) return get@@ Close@@ st ( arr [ mid ] , arr [ mid + 1 ] , target ) ; i = mid + 1 ; } } return arr [ mid ] ; } int get@@ Close@@ st ( int val1 , int val2 , int target ) { if ( target - val1 >= val2 - target ) return val2 ; else return val1 ; } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 5 , 6 , 6 , 8 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int target = 11 ; cout << ( find@@ Close@@ st ( arr , n , target ) ) ; }
Altern@@ ate Odd and Even Nodes in a Sing@@ ly Linked List 2409 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; void print@@ List ( struct Node * node ) { while ( node != NULL ) { cout << node -> data << " ▁ " ; node = node -> next ; } cout << endl ; } Node * newNode ( int key ) { Node * temp = new Node ; temp -> data = key ; temp -> next = NULL ; return temp ; } Node * insert@@ Be@@ g ( Node * head , int val ) { Node * temp = newNode ( val ) ; temp -> next = head ; head = temp ; return head ; } void re@@ arrange ( Node * * head ) { Node * even ; Node * temp , * prev_@@ temp ; Node * i , * j , * k , * l , * ptr ; temp = ( * head ) -> next ; prev_@@ temp = * head ; while ( temp != nullptr ) { Node * x = temp -> next ; if ( temp -> data % 2 != 0 ) { prev_@@ temp -> next = x ; temp -> next = ( * head ) ; ( * head ) = temp ; } else { prev_@@ temp = temp ; } temp = x ; } temp = ( * head ) -> next ; prev_@@ temp = ( * head ) ; while ( temp != nullptr && temp -> data % 2 != 0 ) { prev_@@ temp = temp ; temp = temp -> next ; } even = temp ; prev_@@ temp -> next = nullptr ; i = * head ; j = even ; while ( j != nullptr && i != nullptr ) { k = i -> next ; l = j -> next ; i -> next = j ; j -> next = k ; ptr = j ; i = k ; j = l ; } if ( i == nullptr ) { ptr -> next = j ; } } int main ( ) { Node * head = newNode ( 8 ) ; head = insert@@ Be@@ g ( head , 7 ) ; head = insert@@ Be@@ g ( head , 6 ) ; head = insert@@ Be@@ g ( head , 3 ) ; head = insert@@ Be@@ g ( head , 5 ) ; head = insert@@ Be@@ g ( head , 1 ) ; head = insert@@ Be@@ g ( head , 2 ) ; head = insert@@ Be@@ g ( head , 10 ) ; cout << " Linked ▁ List : " << endl ; print@@ List ( head ) ; cout << " Re@@ arrange@@ d ▁ List " << endl ; re@@ arrange ( & head ) ; print@@ List ( head ) ; }
Rotate a Linked List 2423 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; class Node { public : int data ; Node * next ; } ; void rotate ( Node * * head_@@ ref , int k ) { if ( k == 0 ) return ; Node * current = * head_@@ ref ; while ( current -> next != NULL ) current = current -> next ; current -> next = * head_@@ ref ; current = * head_@@ ref ; for ( int i = 0 ; i < k - 1 ; i ++ ) current = current -> next ; * head_@@ ref = current -> next ; current -> next = NULL ; } void push ( Node * * head_@@ ref , int new_data ) { Node * new_node = new Node ( ) ; new_node -> data = new_data ; new_node -> next = ( * head_@@ ref ) ; ( * head_@@ ref ) = new_node ; } void print@@ List ( Node * node ) { while ( node != NULL ) { cout << node -> data << " ▁ " ; node = node -> next ; } } int main ( void ) { Node * head = NULL ; for ( int i = 60 ; i > 0 ; i -= 10 ) push ( & head , i ) ; cout << " Given ▁ linked ▁ list ▁ STRNEWLINE " ; print@@ List ( head ) ; rotate ( & head , 4 ) ; cout << " Rot@@ ated Linked list " ; print@@ List ( head ) ; return ( 0 ) ; }
Implement@@ ing Iterator pattern of a single Linked List 2472 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int main ( ) { vector < int > list ; list . push_back ( 1 ) ; list . push_back ( 2 ) ; list . push_back ( 3 ) ; for ( vector < int > :: iterator it = list . begin ( ) ; it != list . end ( ) ; ++ it ) cout << * it << " ▁ " ; return 0 ; }
Move all occurrences of an element to end in a linked list 2475 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; struct Node * newNode ( int x ) { Node * temp = new Node ; temp -> data = x ; temp -> next = NULL ; } Node * key@@ To@@ End ( Node * head , int key ) { Node * tail = head ; if ( head == NULL ) { return NULL ; } while ( tail -> next != NULL ) { tail = tail -> next ; } Node * last = tail ; Node * current = head ; Node * prev = NULL ; Node * pre@@ v2 = NULL ; while ( current != tail ) { if ( current -> data == key && pre@@ v2 == NULL ) { prev = current ; current = current -> next ; head = current ; last -> next = prev ; last = last -> next ; last -> next = NULL ; prev = NULL ; } else { if ( current -> data == key && pre@@ v2 != NULL ) { prev = current ; current = current -> next ; pre@@ v2 -> next = current ; last -> next = prev ; last = last -> next ; last -> next = NULL ; } else if ( current != tail ) { pre@@ v2 = current ; current = current -> next ; } } } return head ; } void print@@ List ( Node * head ) { struct Node * temp = head ; while ( temp != NULL ) { printf ( " % d ▁ " , temp -> data ) ; temp = temp -> next ; } printf ( " STRNEWLINE " ) ; } int main ( ) { Node * root = newNode ( 5 ) ; root -> next = newNode ( 2 ) ; root -> next -> next = newNode ( 2 ) ; root -> next -> next -> next = newNode ( 7 ) ; root -> next -> next -> next -> next = newNode ( 2 ) ; root -> next -> next -> next -> next -> next = newNode ( 2 ) ; root -> next -> next -> next -> next -> next -> next = newNode ( 2 ) ; int key = 2 ; cout << " Linked ▁ List ▁ before ▁ operations ▁ : " ; print@@ List ( root ) ; cout << " Linked List after operations : " root = key@@ To@@ End ( root , key ) ; print@@ List ( root ) ; return 0 ; }
Find the sum of last n nodes of the given Linked List 2481 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; void push ( struct Node * * head_@@ ref , int new_data ) { struct Node * new_node = new Node ; new_node -> data = new_data ; new_node -> next = ( * head_@@ ref ) ; ( * head_@@ ref ) = new_node ; } int sum@@ Of@@ Last@@ N_@@ Nodes@@ Util ( struct Node * head , int n ) { if ( n <= 0 ) return 0 ; stack < int > st ; int sum = 0 ; while ( head != NULL ) { st . push ( head -> data ) ; head = head -> next ; } while ( n -- ) { sum += st . top ( ) ; st . pop ( ) ; } return sum ; } int main ( ) { struct Node * head = NULL ; push ( & head , 12 ) ; push ( & head , 4 ) ; push ( & head , 8 ) ; push ( & head , 6 ) ; push ( & head , 10 ) ; int n = 2 ; cout << " Sum ▁ of ▁ last ▁ " << n << " ▁ nodes ▁ = ▁ " << sum@@ Of@@ Last@@ N_@@ Nodes@@ Util ( head , n ) ; return 0 ; }
Find the sum of last n nodes of the given Linked List 2482 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; void push ( struct Node * * head_@@ ref , int new_data ) { struct Node * new_node = new Node ; new_node -> data = new_data ; new_node -> next = ( * head_@@ ref ) ; ( * head_@@ ref ) = new_node ; } void reverse@@ List ( struct Node * * head_@@ ref ) { struct Node * current , * prev , * next ; current = * head_@@ ref ; prev = NULL ; while ( current != NULL ) { next = current -> next ; current -> next = prev ; prev = current ; current = next ; } * head_@@ ref = prev ; } int sum@@ Of@@ Last@@ N_@@ Nodes@@ Util ( struct Node * head , int n ) { if ( n <= 0 ) return 0 ; reverse@@ List ( & head ) ; int sum = 0 ; struct Node * current = head ; while ( current != NULL && n -- ) { sum += current -> data ; current = current -> next ; } reverse@@ List ( & head ) ; return sum ; } int main ( ) { struct Node * head = NULL ; push ( & head , 12 ) ; push ( & head , 4 ) ; push ( & head , 8 ) ; push ( & head , 6 ) ; push ( & head , 10 ) ; int n = 2 ; cout << " Sum ▁ of ▁ last ▁ " << n << " ▁ nodes ▁ = ▁ " << sum@@ Of@@ Last@@ N_@@ Nodes@@ Util ( head , n ) ; return 0 ; }
Recursive selection sort for sing@@ ly linked list | Sw@@ apping node links 2500 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; void swap@@ Nodes ( struct Node * * head_@@ ref , struct Node * curr@@ X , struct Node * curr@@ Y , struct Node * prev@@ Y ) { * head_@@ ref = curr@@ Y ; prev@@ Y -> next = curr@@ X ; struct Node * temp = curr@@ Y -> next ; curr@@ Y -> next = curr@@ X -> next ; curr@@ X -> next = temp ; } struct Node * recur@@ Selection@@ Sort ( struct Node * head ) { if ( head -> next == NULL ) return head ; struct Node * min = head ; struct Node * before@@ Min = NULL ; struct Node * ptr ; for ( ptr = head ; ptr -> next != NULL ; ptr = ptr -> next ) { if ( ptr -> next -> data < min -> data ) { min = ptr -> next ; before@@ Min = ptr ; } } if ( min != head ) swap@@ Nodes ( & head , head , min , before@@ Min ) ; head -> next = recur@@ Selection@@ Sort ( head -> next ) ; return head ; } void sort ( struct Node * * head_@@ ref ) { if ( ( * head_@@ ref ) == NULL ) return ; * head_@@ ref = recur@@ Selection@@ Sort ( * head_@@ ref ) ; } void push ( struct Node * * head_@@ ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = ( * head_@@ ref ) ; ( * head_@@ ref ) = new_node ; } void print@@ List ( struct Node * head ) { while ( head != NULL ) { cout << head -> data << " ▁ " ; head = head -> next ; } } int main ( ) { struct Node * head = NULL ; push ( & head , 6 ) ; push ( & head , 4 ) ; push ( & head , 8 ) ; push ( & head , 12 ) ; push ( & head , 10 ) ; cout << " Linked ▁ list ▁ before ▁ sorting : n " ; print@@ List ( head ) ; sort ( & head ) ; cout << " Linked list after sorting : n " ; print@@ List ( head ) ; return 0 ; }
Sorted merge of two sorted dou@@ bly circular linked lists 2515 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; struct Node { int data ; Node * next , * prev ; } ; void insert ( Node * * head_@@ ref , int data ) { Node * new_node = new Node ; new_node -> data = data ; if ( * head_@@ ref == NULL ) { new_node -> next = new_node ; new_node -> prev = new_node ; } else { Node * last = ( * head_@@ ref ) -> prev ; new_node -> next = * head_@@ ref ; new_node -> prev = last ; last -> next = ( * head_@@ ref ) -> prev = new_node ; } * head_@@ ref = new_node ; } Node * merge ( Node * first , Node * second ) { if ( ! first ) return second ; if ( ! second ) return first ; if ( first -> data < second -> data ) { first -> next = merge ( first -> next , second ) ; first -> next -> prev = first ; first -> prev = NULL ; return first ; } else { second -> next = merge ( first , second -> next ) ; second -> next -> prev = second ; second -> prev = NULL ; return second ; } } Node * merge@@ Util ( Node * head@@ 1 , Node * head@@ 2 ) { if ( ! head@@ 1 ) return head@@ 2 ; if ( ! head@@ 2 ) return head@@ 1 ; Node * last_@@ node ; if ( head@@ 1 -> prev -> data < head@@ 2 -> prev -> data ) last_@@ node = head@@ 2 -> prev ; else last_@@ node = head@@ 1 -> prev ; head@@ 1 -> prev -> next = head@@ 2 -> prev -> next = NULL ; Node * final@@ Head = merge ( head@@ 1 , head@@ 2 ) ; final@@ Head -> prev = last_@@ node ; last_@@ node -> next = final@@ Head ; return final@@ Head ; } void print@@ List ( Node * head ) { Node * temp = head ; while ( temp -> next != head ) { cout << temp -> data << " ▁ " ; temp = temp -> next ; } cout << temp -> data << " ▁ " ; } int main ( ) { Node * head@@ 1 = NULL , * head@@ 2 = NULL ; insert ( & head@@ 1 , 8 ) ; insert ( & head@@ 1 , 5 ) ; insert ( & head@@ 1 , 3 ) ; insert ( & head@@ 1 , 1 ) ; insert ( & head@@ 2 , 11 ) ; insert ( & head@@ 2 , 9 ) ; insert ( & head@@ 2 , 7 ) ; insert ( & head@@ 2 , 2 ) ; Node * new@@ Head = merge@@ Util ( head@@ 1 , head@@ 2 ) ; cout << " Final ▁ Sorted ▁ List : ▁ " ; print@@ List ( new@@ Head ) ; return 0 ; }
Lex@@ ico@@ graphic@@ ally minimum string rotation | Set 1 2626 | #@@ include <@@ io@@ stream@@ > NEW_LINE #@@ include <@@ algorithm@@ > NEW_LINE using namespace std ; string min@@ Lex@@ Rotation ( string str ) { int n = str . length ( ) ; string arr [ n ] ; string concat = str + str ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = concat . substr ( i , n ) ; sort ( arr , arr + n ) ; return arr [ 0 ] ; } int main ( ) { cout << min@@ Lex@@ Rotation ( " GE@@ EK@@ S@@ FOR@@ GE@@ E@@ KS " ) << endl ; cout << min@@ Lex@@ Rotation ( " GE@@ EK@@ SQU@@ I@@ Z " ) << endl ; cout << min@@ Lex@@ Rotation ( " BC@@ AB@@ D@@ AD@@ AB " ) << endl ; }
Query to find the maximum and minimum weight between two nodes in the given tree using L@@ CA . 2683 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define MAX 1000 NEW_LINE #@@ define log 10 NEW_LINE int level [ MAX ] ; int l@@ ca [ MAX ] [ log ] ; int min@@ Weight [ MAX ] [ log ] ; int max@@ Weight [ MAX ] [ log ] ; vector < int > graph [ MAX ] ; int weight [ MAX ] ; void addEdge ( int u , int v ) { graph [ u ] . push_back ( v ) ; graph [ v ] . push_back ( u ) ; } void dfs ( int node , int parent , int h ) { l@@ ca [ node ] [ 0 ] = parent ; level [ node ] = h ; if ( parent != -1 ) { min@@ Weight [ node ] [ 0 ] = min ( weight [ node ] , weight [ parent ] ) ; max@@ Weight [ node ] [ 0 ] = max ( weight [ node ] , weight [ parent ] ) ; } for ( int i = 1 ; i < log ; i ++ ) { if ( l@@ ca [ node ] [ i - 1 ] != -1 ) { l@@ ca [ node ] [ i ] = l@@ ca [ l@@ ca [ node ] [ i - 1 ] ] [ i - 1 ] ; min@@ Weight [ node ] [ i ] = min ( min@@ Weight [ node ] [ i - 1 ] , min@@ Weight [ l@@ ca [ node ] [ i - 1 ] ] [ i - 1 ] ) ; max@@ Weight [ node ] [ i ] = max ( max@@ Weight [ node ] [ i - 1 ] , max@@ Weight [ l@@ ca [ node ] [ i - 1 ] ] [ i - 1 ] ) ; } } for ( int i : graph [ node ] ) { if ( i == parent ) continue ; dfs ( i , node , h + 1 ) ; } } void find@@ MinMax@@ Weight ( int u , int v ) { int min@@ We@@ i = INT_MAX ; int max@@ We@@ i = INT_@@ MIN ; if ( level [ u ] > level [ v ] ) swap ( u , v ) ; for ( int i = log - 1 ; i >= 0 ; i -- ) { if ( l@@ ca [ v ] [ i ] != -1 && level [ l@@ ca [ v ] [ i ] ] >= level [ u ] ) { min@@ We@@ i = min ( min@@ We@@ i , min@@ Weight [ v ] [ i ] ) ; max@@ We@@ i = max ( max@@ We@@ i , max@@ Weight [ v ] [ i ] ) ; v = l@@ ca [ v ] [ i ] ; } } if ( v == u ) { cout << min@@ We@@ i << " ▁ " << max@@ We@@ i << endl ; } else { for ( int i = log - 1 ; i >= 0 ; i -- ) { if ( l@@ ca [ v ] [ i ] != l@@ ca [ u ] [ i ] ) { min@@ We@@ i = min ( min@@ We@@ i , min ( min@@ Weight [ v ] [ i ] , min@@ Weight [ u ] [ i ] ) ) ; max@@ We@@ i = max ( max@@ We@@ i , max ( max@@ Weight [ v ] [ i ] , max@@ Weight [ u ] [ i ] ) ) ; v = l@@ ca [ v ] [ i ] ; u = l@@ ca [ u ] [ i ] ; } } min@@ We@@ i = min ( min@@ We@@ i , min ( min@@ Weight [ v ] [ 0 ] , min@@ Weight [ u ] [ 0 ] ) ) ; max@@ We@@ i = max ( max@@ We@@ i , max ( max@@ Weight [ v ] [ 0 ] , max@@ Weight [ u ] [ 0 ] ) ) ; cout << min@@ We@@ i << " ▁ " << max@@ We@@ i << endl ; } } int main ( ) { int n = 5 ; addEdge ( 1 , 2 ) ; addEdge ( 1 , 5 ) ; addEdge ( 2 , 4 ) ; addEdge ( 2 , 3 ) ; weight [ 1 ] = -1 ; weight [ 2 ] = 5 ; weight [ 3 ] = -1 ; weight [ 4 ] = 3 ; weight [ 5 ] = -2 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j < log ; j ++ ) { l@@ ca [ i ] [ j ] = -1 ; min@@ Weight [ i ] [ j ] = INT_MAX ; max@@ Weight [ i ] [ j ] = INT_@@ MIN ; } } dfs ( 1 , -1 , 0 ) ; find@@ MinMax@@ Weight ( 1 , 3 ) ; find@@ MinMax@@ Weight ( 2 , 4 ) ; find@@ MinMax@@ Weight ( 3 , 5 ) ; return 0 ; }
Lo@@ west Common Ancestor in Parent Array Representation 2691 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; const int MAX = 1000 ; int find@@ L@@ CA ( int n1 , int n2 , int parent [ ] ) { vector < bool > visited ( MAX , false ) ; visited [ n1 ] = true ; while ( parent [ n1 ] != -1 ) { visited [ n1 ] = true ; n1 = parent [ n1 ] ; } visited [ n1 ] = true ; while ( ! visited [ n2 ] ) n2 = parent [ n2 ] ; return n2 ; } void insert@@ Ad@@ j ( int parent [ ] , int i , int j ) { parent [ i ] = j ; } int main ( ) { int parent [ MAX ] ; parent [ 20 ] = -1 ; insert@@ Ad@@ j ( parent , 8 , 20 ) ; insert@@ Ad@@ j ( parent , 22 , 20 ) ; insert@@ Ad@@ j ( parent , 4 , 8 ) ; insert@@ Ad@@ j ( parent , 12 , 8 ) ; insert@@ Ad@@ j ( parent , 10 , 12 ) ; insert@@ Ad@@ j ( parent , 14 , 12 ) ; cout << find@@ L@@ CA ( 10 , 14 , parent ) ; return 0 ; }
Minimum spr@@ in@@ kl@@ ers required to water a rect@@ angular par@@ k 2737 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; typedef long long int ll ; void solve ( int N , int M ) { ll ans = ( N ) * ( M / 2 ) ; if ( M % 2 == 1 ) { ans += ( N + 1 ) / 2 ; } cout << ans << endl ; } int main ( ) { int N , M ; N = 5 ; M = 3 ; solve ( N , M ) ; }
Queries to find frequencies of a string within specified sub@@ strings 2739 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE #@@ define max_len 10000@@ 5 NEW_LINE using namespace std ; int cnt [ max_len ] ; void pre@@ compute ( string s , string K ) { int n = s . size ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { cnt [ i + 1 ] = cnt [ i ] + ( s . substr ( i , K . size ( ) ) == K ) ; } } int main ( ) { string s = " ABC@@ ABC@@ AB@@ ABC " ; string K = " ABC " ; pre@@ compute ( s , K ) ; vector < pair < int , int > > Q = { { 1 , 6 } , { 5 , 11 } } ; for ( auto it : Q ) { cout << cnt [ it . second - 1 ] - cnt [ it . first - 1 ] << endl ; } return 0 ; }
Count of integral coordinates that lies inside a Square 2757 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void count@@ Int@@ gr@@ al@@ Points ( int x1 , int y1 , int x2 , int y2 ) { cout << ( y2 - y1 - 1 ) * ( x2 - x1 - 1 ) ; } int main ( ) { int x1 = 1 , y1 = 1 ; int x2 = 4 , y2 = 4 ; count@@ Int@@ gr@@ al@@ Points ( x1 , y1 , x2 , y2 ) ; return 0 ; }
Minim@@ ize the sum of digits of A and B such that A + B = N 2795 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int min@@ Sum ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += ( n % 10 ) ; n /= 10 ; } if ( sum == 1 ) return 10 ; return sum ; } int main ( ) { int n = 18@@ 84 ; cout << min@@ Sum ( n ) ; return 0 ; }
Find the repe@@ ating element in an Array of size N consisting of first M natural numbers 2920 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int repe@@ ating@@ Element ( int arr [ ] , int N ) { int M = 0 , sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; M = max ( M , arr [ i ] ) ; } int sum@@ 1 = M * ( M + 1 ) / 2 ; int ans = ( sum - sum@@ 1 ) / ( N - M ) ; return ans ; } int main ( ) { int arr [ ] = { 2 , 6 , 4 , 3 , 1 , 5 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << repe@@ ating@@ Element ( arr , N ) << endl ; return 0 ; }
Maxim@@ ize value at K@@ th index to create N size array with adjacent difference 1 and sum less than M 2922 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int calculate@@ Max ( int N , int M , int K ) { int ans = -1 ; int low = 0 , high = M ; while ( low <= high ) { int mid = ( low + high ) / 2 ; int val = 0 ; int L = K - 1 ; int R = N - K ; val += mid ; if ( mid >= L ) { val += ( L ) * ( 2 * mid - L - 1 ) / 2 ; } else { val += mid * ( mid - 1 ) / 2 + ( L - mid ) ; } if ( mid >= R ) { val += ( R ) * ( 2 * mid - R - 1 ) / 2 ; } else { val += mid * ( mid - 1 ) / 2 + ( R - mid ) ; } if ( val <= M ) { ans = max ( ans , mid ) ; low = mid + 1 ; } else high = mid - 1 ; } return ans ; } int main ( ) { int N = 7 , M = 100 , K = 6 ; cout << calculate@@ Max ( N , M , K ) << endl ; return 0 ; }
Find the array element having equal sum of Prime Numbers on its left and right 2959 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find_@@ index ( int arr [ ] , int N ) { int max_value = INT_@@ MIN ; for ( int i = 0 ; i < N ; i ++ ) { max_value = max ( max_value , arr [ i ] ) ; } map < int , int > store ; for ( int i = 1 ; i <= max_value ; i ++ ) { store [ i ] ++ ; } if ( store . find ( 1 ) != store . end ( ) ) { store . erase ( 1 ) ; } for ( int i = 2 ; i <= sqrt ( max_value ) ; i ++ ) { int multiple = 2 ; while ( ( i * multiple ) <= max_value ) { if ( store . find ( i * multiple ) != store . end ( ) ) { store . erase ( i * multiple ) ; } multiple ++ ; } } int pri@@ me_@@ sum_@@ from_@@ left = 0 ; int first_@@ array [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { first_@@ array [ i ] = pri@@ me_@@ sum_@@ from_@@ left ; if ( store . find ( arr [ i ] ) != store . end ( ) ) { pri@@ me_@@ sum_@@ from_@@ left += arr [ i ] ; } } int pri@@ me_@@ sum_@@ from_@@ right = 0 ; int second_@@ array [ N ] ; for ( int i = N - 1 ; i >= 0 ; i -- ) { second_@@ array [ i ] = pri@@ me_@@ sum_@@ from_@@ right ; if ( store . find ( arr [ i ] ) != store . end ( ) ) { pri@@ me_@@ sum_@@ from_@@ right += arr [ i ] ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( first_@@ array [ i ] == second_@@ array [ i ] ) { return i ; } } return -1 ; } int main ( ) { int arr [ ] = { 11 , 4 , 7 , 6 , 13 , 1 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << find_@@ index ( arr , N ) ; return 0 ; }
Cost required to make all array elements equal to 1 2983 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Cost ( int A [ ] , int N ) { int total@@ Cost = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] == 0 ) { A [ i ] = 1 ; total@@ Cost += i ; } } return total@@ Cost ; } int main ( ) { int arr [ ] = { 1 , 0 , 1 , 0 , 1 , 0 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << find@@ Cost ( arr , N ) ; return 0 ; }
S@@ malle@@ st value of N such that the sum of all natural numbers from K to N is at least X 2999 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Greater@@ Equal ( int N , int K , int X ) { return ( ( N * 1@@ LL * ( N + 1 ) / 2 ) - ( ( K - 1 ) * 1@@ LL * K / 2 ) ) >= X ; } void minimum@@ Number ( int K , int X ) { if ( K > X ) { cout << " - 1" ; return ; } int low = K , high = X , res = -1 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( is@@ Greater@@ Equal ( mid , K , X ) ) { res = mid ; high = mid - 1 ; } else low = mid + 1 ; } cout << res ; } int main ( ) { int K = 5 , X = 13 ; minimum@@ Number ( K , X ) ; return 0 ; }
Calculate absolute difference between minimum and maximum sum of pairs in an array 3019 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int Get@@ Diff ( int A [ ] , int N ) { int Su@@ ff@@ Max@@ Arr [ N ] ; Su@@ ff@@ Max@@ Arr [ N - 1 ] = A [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; -- i ) { Su@@ ff@@ Max@@ Arr [ i ] = max ( Su@@ ff@@ Max@@ Arr [ i + 1 ] , A [ i + 1 ] ) ; } int Maximum@@ Sum = INT_@@ MIN ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] < Su@@ ff@@ Max@@ Arr [ i ] ) Maximum@@ Sum = max ( Maximum@@ Sum , A [ i ] + Su@@ ff@@ Max@@ Arr [ i ] ) ; } int Minimum@@ Sum = INT_MAX ; int Su@@ ff@@ Min@@ Arr [ N ] ; Su@@ ff@@ Min@@ Arr [ N - 1 ] = INT_MAX ; for ( int i = N - 2 ; i >= 0 ; -- i ) { Su@@ ff@@ Min@@ Arr [ i ] = min ( Su@@ ff@@ Min@@ Arr [ i + 1 ] , A [ i + 1 ] ) ; } for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] < Su@@ ff@@ Min@@ Arr [ i ] ) { Minimum@@ Sum = min ( Minimum@@ Sum , A [ i ] + Su@@ ff@@ Min@@ Arr [ i ] ) ; } } return abs ( Maximum@@ Sum - Minimum@@ Sum ) ; } int main ( ) { int arr [ ] = { 2 , 4 , 1 , 3 , 7 , 5 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << Get@@ Diff ( arr , N ) ; return 0 ; }
Sum of numbers formed by consecutive digits present in a given string 3033 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int sum@@ Of@@ Digits ( string s ) { int curr = 0 ; int ret = 0 ; for ( auto & ch : s ) { if ( isdigit ( ch ) ) { curr = curr * 10 + ch - '0' ; } else { ret += curr ; curr = 0 ; } } ret += curr ; return ret ; } int main ( ) { string S = "11@@ aa@@ 32@@ bb@@ b@@ 5" ; cout << sum@@ Of@@ Digits ( S ) ; return 0 ; }
Minim@@ ize increments required to make differences between all pairs of array elements even 3048 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void minimum@@ Operations ( int arr [ ] , int N ) { int odd@@ Cnt = 0 , even@@ Cnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { even@@ Cnt ++ ; } else { odd@@ Cnt ++ ; } } cout << min ( odd@@ Cnt , even@@ Cnt ) ; } int main ( ) { int arr [ ] = { 4 , 1 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; minimum@@ Operations ( arr , N ) ; return 0 ; }
Check if all disks can be placed at a single ro@@ d based on given conditions 3070 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool check ( int a [ ] , int n ) { bool flag = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( a [ i + 1 ] > a [ i ] && a [ i ] < a [ i - 1 ] ) flag = 1 ; } if ( flag ) return false ; else return true ; } int main ( ) { int arr [ ] = { 1 , 3 , 5 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( check ( arr , N ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
Minim@@ ize insertions required to make all characters of a given string equal 3073 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int min@@ Operations ( string & S ) { int count = 0 ; for ( int i = 1 ; i < S . length ( ) ; i ++ ) { if ( S [ i ] != S [ i - 1 ] ) { count += 1 ; } } cout << count ; } int main ( ) { string S = "@@ 0101@@ 0101@@ 01" ; min@@ Operations ( S ) ; return 0 ; }
Count pairs made up of an element di@@ visible by the other from an array consisting of powers of 2 3075 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void numberOf@@ Pairs ( int arr [ ] , int N ) { int set_@@ bits [ 31 ] = { 0 } ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int x = arr [ i ] ; int bit@@ pos = -1 ; while ( x > 0 ) { bit@@ pos ++ ; x /= 2 ; } for ( int j = 0 ; j <= bit@@ pos ; j ++ ) { count += set_@@ bits [ j ] ; } set_@@ bits [ bit@@ pos ] ++ ; } cout << count ; } int main ( ) { int arr [ ] = { 4 , 16 , 8 , 64 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; numberOf@@ Pairs ( arr , N ) ; return 0 ; }
Queries to find the maximum array element after removing elements from a given range 3078 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Maximum ( int arr [ ] , int N , int Q , int queries [ ] [ 2 ] ) { int prefix_@@ max [ N + 1 ] = { 0 } ; int suffix_@@ max [ N + 1 ] = { 0 } ; prefix_@@ max [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { prefix_@@ max [ i ] = max ( prefix_@@ max [ i - 1 ] , arr [ i ] ) ; } suffix_@@ max [ N - 1 ] = arr [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { suffix_@@ max [ i ] = max ( suffix_@@ max [ i + 1 ] , arr [ i ] ) ; } for ( int i = 0 ; i < Q ; i ++ ) { int l = queries [ i ] [ 0 ] ; int r = queries [ i ] [ 1 ] ; if ( l == 0 && r == ( N - 1 ) ) cout << "0 STRNEWLINE " ; else if ( l == 0 ) cout << suffix_@@ max [ r + 1 ] << " STRNEWLINE " ; else if ( r == ( N - 1 ) ) cout << prefix_@@ max [ l - 1 ] << " STRNEWLINE " ; else cout << max ( prefix_@@ max [ l - 1 ] , suffix_@@ max [ r + 1 ] ) << " STRNEWLINE " ; } } int main ( ) { int arr [ ] = { 5 , 6 , 8 , 10 , 15 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int queries [ ] [ 2 ] = { { 0 , 1 } , { 0 , 2 } , { 1 , 4 } } ; int Q = sizeof ( queries ) / sizeof ( queries [ 0 ] ) ; find@@ Maximum ( arr , N , Q , queries ) ; return 0 ; }
Reduce a string to a valid email address of minimum length by replacing specified sub@@ strings 3085 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; string min@@ Email ( string email ) { string ans = " " ; int len = email . length ( ) ; ans += email [ 0 ] ; int i = 1 ; bool not@@ At = true ; while ( i < len ) { if ( i < len - 3 && not@@ At && email [ i ] == ' a ' && email [ i + 1 ] == ' t ' ) { ans += ' @ ' ; i += 1 ; not@@ At = false ; } else if ( i < len - 4 && email [ i ] == ' d ' && email [ i + 1 ] == ' o ' && email [ i + 2 ] == ' t ' ) { ans += ' . ' ; i += 2 ; } else { ans += email [ i ] ; } i += 1 ; } return ans ; } int main ( ) { string email = " ge@@ ek@@ s@@ forge@@ ek@@ sat@@ g@@ mail@@ dot@@ com " ; cout << ( min@@ Email ( email ) ) ; }
Minim@@ ize remaining array sizes by removing equal pairs of first array elements 3100 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void count@@ Remaining@@ Elements ( int L1 [ ] , int L2 [ ] , int n ) { int one = 0 ; int zero = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( L1 [ i ] == 1 ) one ++ ; else zero ++ ; } int ans = n ; for ( int i = 0 ; i < n ; i ++ ) { if ( L2 [ i ] == 1 ) { one -- ; if ( one < 0 ) { ans = i ; break ; } } else { zero -- ; if ( zero < 0 ) { ans = i ; break ; } } } cout << n - ans ; } int main ( ) { int L1 [ ] = { 1 , 1 , 0 , 0 } ; int L2 [ ] = { 0 , 0 , 0 , 1 } ; int N = sizeof ( L1 ) / sizeof ( L1 [ 0 ] ) ; count@@ Remaining@@ Elements ( L1 , L2 , N ) ; return 0 ; }
S@@ malle@@ st number not less than N which is di@@ visible by all digits of N 3141 | #@@ include " bits / std@@ c + + . h " NEW_LINE using namespace std ; int LC@@ M ( int A , int B ) { return ( A * B / __@@ gcd ( A , B ) ) ; } int find@@ S@@ malle@@ st@@ Number ( int X ) { int l@@ cm = 1 ; int temp = X ; while ( temp ) { int last = temp % 10 ; temp /= 10 ; if ( ! last ) continue ; l@@ cm = LC@@ M ( l@@ cm , last ) ; } int answer = ( ( X + l@@ cm - 1 ) / l@@ cm ) * l@@ cm ; cout << answer ; } int main ( ) { int X = 280 ; find@@ S@@ malle@@ st@@ Number ( X ) ; return 0 ; }
Count numbers from a given range that are not di@@ visible by any of the array elements 3142 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Non@@ Multip@@ les ( int arr [ ] , int n , int k ) { set < int > multip@@ les ; for ( int i = 0 ; i < n ; ++ i ) { if ( multip@@ les . find ( arr [ i ] ) == multip@@ les . end ( ) ) { for ( int j = 1 ; j <= k / arr [ i ] ; j ++ ) { multip@@ les . insert ( arr [ i ] * j ) ; } } } return k - multip@@ les . size ( ) ; } int count@@ Values ( int arr [ ] , int N , int L , int R ) { return find@@ Non@@ Multip@@ les ( arr , N , R ) - find@@ Non@@ Multip@@ les ( arr , N , L - 1 ) ; } int main ( ) { int arr [ ] = { 2 , 3 , 4 , 5 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int L = 1 , R = 20 ; cout << count@@ Values ( arr , N , L , R ) ; return 0 ; }
Count number of trip@@ lets ( a , b , c ) from first N natural numbers such that a * b + c = N 3169 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Cnt@@ Trip@@ let ( int N ) { int cnt@@ Trip@@ let = 0 ; for ( int i = 1 ; i < N ; i ++ ) { if ( N % i != 0 ) { cnt@@ Trip@@ let += N / i ; } else { cnt@@ Trip@@ let += ( N / i ) - 1 ; } } return cnt@@ Trip@@ let ; } int main ( ) { int N = 3 ; cout << find@@ Cnt@@ Trip@@ let ( N ) ; return 0 ; }
Minimum number of coins to be collected per hour to empty N pi@@ les in at most H hours 3183 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int min@@ Collec@@ ting@@ Speed ( vector < int > & pi@@ les , int H ) { int ans = -1 ; int low = 1 , high ; high = * max_@@ element ( pi@@ les . begin ( ) , pi@@ les . end ( ) ) ; while ( low <= high ) { int K = low + ( high - low ) / 2 ; int time = 0 ; for ( int ai : pi@@ les ) { time += ( ai + K - 1 ) / K ; } if ( time <= H ) { ans = K ; high = K - 1 ; } else { low = K + 1 ; } } cout << ans ; } int main ( ) { vector < int > arr = { 3 , 6 , 7 , 11 } ; int H = 8 ; min@@ Collec@@ ting@@ Speed ( arr , H ) ; return 0 ; }
Count ways to split array into two equal sum sub@@ arrays by changing sign of any one array element 3215 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Sub@@ Array@@ Sign@@ Change ( int arr [ ] , int N ) { unordered_map < int , int > prefix@@ Count ; unordered_map < int , int > suffix@@ Count ; int total = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { total += arr [ i ] ; suffix@@ Count [ arr [ i ] ] ++ ; } int prefix@@ Sum = 0 ; int suffix@@ Sum = 0 ; int count = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { prefix@@ Sum += arr [ i ] ; prefix@@ Count [ arr [ i ] ] ++ ; suffix@@ Sum = total - prefix@@ Sum ; suffix@@ Count [ arr [ i ] ] -- ; int diff = prefix@@ Sum - suffix@@ Sum ; if ( diff % 2 == 0 ) { int x = prefix@@ Count + suffix@@ Count [ - diff / 2 ] ; count = count + x ; } } return count ; } int main ( ) { int arr [ ] = { 2 , 2 , -@@ 3 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << count@@ Sub@@ Array@@ Sign@@ Change ( arr , N ) ; return 0 ; }
Partition string into two sub@@ strings having maximum number of common non 3216 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Common@@ Char ( int ind , string & S ) { int cnt = 0 ; set < char > ls ; set < char > rs ; for ( int i = 0 ; i < ind ; ++ i ) { ls . insert ( S [ i ] ) ; } for ( int i = ind ; i < S . length ( ) ; ++ i ) { rs . insert ( S [ i ] ) ; } for ( auto v : ls ) { if ( rs . count ( v ) ) { ++ cnt ; } } return cnt ; } void partition@@ String@@ With@@ Max@@ Com ( string & S ) { int ans = 0 ; for ( int i = 1 ; i < S . length ( ) ; ++ i ) { ans = max ( ans , count@@ Common@@ Char ( i , S ) ) ; } cout << ans << " STRNEWLINE " ; } int main ( ) { string str = " aabb@@ ca " ; partition@@ String@@ With@@ Max@@ Com ( str ) ; return 0 ; }
Lex@@ ico@@ graphic@@ ally smallest string possible by inserting given character 3220 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; string S@@ malle@@ st@@ String ( string s , char c ) { for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] > c ) { s . insert ( i , 1 , c ) ; return s ; } } s += c ; return s ; } int main ( ) { string S = " ac@@ d " ; char C = ' b ' ; cout << S@@ malle@@ st@@ String ( S , C ) << endl ; return 0 ; }
Sum of nodes in the path from root to N 3252 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; typedef long long ll ; ll sum@@ Of@@ Path@@ Nodes ( ll N ) { if ( N == 1 ) { return 1 ; } else if ( N == 2 N == 3 ) { return N + 1 ; } vector < ll > arr ; arr . push_back ( 1 ) ; ll k = 1 ; bool flag = true ; while ( k < N ) { if ( flag == true ) { k *= 2 ; flag = false ; } else { k *= 4 ; flag = true ; } if ( k > N ) { break ; } arr . push_back ( k ) ; } ll len = arr . size ( ) ; vector < ll > prefix ( len ) ; prefix [ 0 ] = 1 ; for ( ll i = 1 ; i < len ; ++ i ) { prefix [ i ] = arr [ i ] + prefix [ i - 1 ] ; } vector < ll > :: iterator it = lower_bound ( prefix . begin ( ) , prefix . end ( ) , N ) ; ll ind = it - prefix . begin ( ) ; ll final_@@ ans = 0 ; ll temp = N ; while ( ind > 1 ) { ll val = temp - prefix [ ind - 1 ] ; if ( ind % 2 != 0 ) { temp = prefix [ ind - 2 ] + ( val + 1 ) / 2 ; } else { temp = prefix [ ind - 2 ] + ( val + 3 ) / 4 ; } -- ind ; final_@@ ans += temp ; } final_@@ ans += ( N + 1 ) ; return final_@@ ans ; } int main ( ) { ll N = 13 ; cout << sum@@ Of@@ Path@@ Nodes ( N ) << endl ; return 0 ; }
Re@@ arrange array to make sum of all sub@@ arrays starting from first index non 3275 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void re@@ arrange@@ Array ( int a [ ] , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += a [ i ] ; } if ( sum == 0 ) { cout << " - 1" ; return ; } sum = 0 ; int b = 0 ; sort ( a , a + N ) ; for ( int i = 0 ; i < N ; i ++ ) { sum += a [ i ] ; if ( sum == 0 ) { if ( a [ i ] != a [ N - 1 ] ) { sum -= a [ i ] ; swap ( a [ i ] , a [ N - 1 ] ) ; sum += a [ i ] ; } else { b = 1 ; break ; } } } if ( b == 1 ) { b = 0 ; sum = 0 ; sort ( a , a + N , greater < int > ( ) ) ; for ( int i = N - 1 ; i >= 0 ; i -- ) { sum += a [ i ] ; if ( sum == 0 ) { if ( a [ i ] != a [ 0 ] ) { sum -= a [ i ] ; swap ( a [ i ] , a [ 0 ] ) ; sum += a [ i ] ; } else { b = 1 ; break ; } } } } if ( b == 1 ) { cout << " - 1" ; return ; } for ( int i = 0 ; i < N ; i ++ ) { cout << a [ i ] << " ▁ " ; } } int main ( ) { int arr [ ] = { 1 , -1 , 2 , 4 , 0 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; re@@ arrange@@ Array ( arr , N ) ; return 0 ; }
Minimum substring fli@@ ps required to convert given binary string to another 3289 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ Minimum@@ Operations ( string a , string b ) { int step = 0 ; int last_@@ index ; while ( a != b ) { for ( int i = 0 ; i < a . length ( ) ; i ++ ) { if ( a [ i ] != b [ i ] ) { last_@@ index = i ; } } for ( int i = 0 ; i <= last_@@ index ; i ++ ) { a [ i ] = ( a [ i ] == '0' ) ? '1' : '0' ; } step ++ ; } cout << step ; } int main ( ) { string A = "@@ 101@@ 01@@ 0" , B = "11@@ 00@@ 11" ; find@@ Minimum@@ Operations ( A , B ) ; return 0 ; }
Count Full Prime numbers in a given range 3315 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Prime ( int num ) { if ( num <= 1 ) return false ; for ( int i = 2 ; i * i <= num ; i ++ ) if ( num % i == 0 ) return false ; return true ; } bool is@@ Ful@@ Prime ( int n ) { if ( ! is@@ Prime ( n ) ) return false ; else { while ( n > 0 ) { int rem = n % 10 ; if ( ! ( rem == 2 rem == 3 rem == 5 rem == 7 ) ) return false ; n = n / 10 ; } } return true ; } int count@@ Ful@@ Prime ( int L , int R ) { int cnt = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( ( i % 2 ) != 0 && is@@ Ful@@ Prime ( i ) ) { cnt ++ ; } } return cnt ; } int main ( ) { int L = 1 , R = 100 ; int ans = 0 ; if ( L < 3 ) ans ++ ; cout << ans + count@@ Ful@@ Prime ( L , R ) ; return 0 ; }
Count smaller primes on the right of each array element 3341 | #@@ include " bits / std@@ c + + . h " NEW_LINE using namespace std ; bool is_@@ prime ( int n ) { if ( n <= 1 ) return 0 ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return 0 ; } return 1 ; } void count@@ Small@@ er@@ Pri@@ mes ( int ar [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int count = 0 ; for ( int j = i + 1 ; j < N ; j ++ ) { if ( ar [ j ] <= ar [ i ] && is_@@ prime ( ar [ j ] ) ) { count ++ ; } } cout << count << " ▁ " ; } } int main ( ) { int ar [ ] = { 43 , 3 , 5 , 7 , 2 , 41 } ; int N = sizeof ar / sizeof ar [ 0 ] ; count@@ Small@@ er@@ Pri@@ mes ( ar , N ) ; return 0 ; }
S@@ malle@@ st array that can be obtained by replacing adjacent pairs with their products 3351 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int minLength ( int arr [ ] , int N ) { for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ 0 ] != arr [ i ] ) { return 1 ; } } return N ; } int main ( ) { int arr [ ] = { 2 , 1 , 3 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minLength ( arr , N ) ; return 0 ; }
Count 1 s in binary matrix having remaining indices of its row and column filled with 0 s 3380 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int num@@ Special ( vector < vector < int > > & mat ) { int m = mat . size ( ) , n = mat [ 0 ] . size ( ) ; int rows [ m ] ; int cols [ n ] ; int i , j ; for ( i = 0 ; i < m ; i ++ ) { rows [ i ] = 0 ; for ( j = 0 ; j < n ; j ++ ) rows [ i ] += mat [ i ] [ j ] ; } for ( i = 0 ; i < n ; i ++ ) { cols [ i ] = 0 ; for ( j = 0 ; j < m ; j ++ ) cols [ i ] += mat [ j ] [ i ] ; } int cnt = 0 ; for ( i = 0 ; i < m ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] == 1 && rows [ i ] == 1 && cols [ j ] == 1 ) cnt ++ ; } } return cnt ; } int main ( ) { vector < vector < int > > mat = { { 1 , 0 , 0 } , { 0 , 0 , 1 } , { 0 , 0 , 0 } } ; cout << num@@ Special ( mat ) << endl ; return 0 ; }
Find all matrix elements which are minimum in their row and maximum in their column 3382 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; vector < int > min@@ max@@ Numbers ( vector < vector < int > > & matrix , vector < int > & res ) { unordered_@@ set < int > set ; for ( int i = 0 ; i < matrix . size ( ) ; i ++ ) { int min@@ r = INT_MAX ; for ( int j = 0 ; j < matrix [ i ] . size ( ) ; j ++ ) { min@@ r = min ( min@@ r , matrix [ i ] [ j ] ) ; } set . insert ( min@@ r ) ; } for ( int j = 0 ; j < matrix [ 0 ] . size ( ) ; j ++ ) { int max@@ c = INT_@@ MIN ; for ( int i = 0 ; i < matrix . size ( ) ; i ++ ) { max@@ c = max ( max@@ c , matrix [ i ] [ j ] ) ; } if ( set . find ( max@@ c ) != set . end ( ) ) { res . push_back ( max@@ c ) ; } } return res ; } int main ( ) { vector < vector < int > > mat = { { 1 , 10 , 4 } , { 9 , 3 , 8 } , { 15 , 16 , 17 } } ; vector < int > ans ; min@@ max@@ Numbers ( mat , ans ) ; if ( ans . size ( ) == 0 ) cout << " - 1" << endl ; for ( int i = 0 ; i < ans . size ( ) ; i ++ ) cout << ans [ i ] << endl ; return 0 ; }
Count array elements exce@@ eding sum of preceding K elements 3391 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Pre@@ ce@@ ding@@ K ( int a [ ] , int n , int K ) { int prefix [ n ] ; prefix [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] + a [ i ] ; } int ctr = 0 ; if ( prefix [ K - 1 ] < a [ K ] ) ctr ++ ; for ( int i = K + 1 ; i < n ; i ++ ) { if ( prefix [ i - 1 ] - prefix [ i - K - 1 ] < a [ i ] ) ctr ++ ; } return ctr ; } int main ( ) { int arr [ ] = { 2 , 3 , 8 , 10 , -2 , 7 , 5 , 5 , 9 , 15 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 2 ; cout << count@@ Pre@@ ce@@ ding@@ K ( arr , N , K ) ; return 0 ; }
Count N digits numbers with sum di@@ visible by K 3397 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define M 1000 NEW_LINE int count@@ Num ( int N , int sum , int K , bool st , int dp [ M ] [ M ] [ 2 ] ) { if ( N == 0 and sum == 0 ) { return 1 ; } if ( N < 0 ) { return 0 ; } if ( dp [ N ] [ sum ] [ st ] != -1 ) { return dp [ N ] [ sum ] [ st ] ; } int res = 0 ; int start = st == 1 ? 0 : 1 ; for ( int i = start ; i <= 9 ; i ++ ) { res += count@@ Num ( N - 1 , ( sum + i ) % K , K , ( st i > 0 ) , dp ) ; } return dp [ N ] [ sum ] [ st ] = res ; } int main ( ) { int N = 2 , K = 7 ; int dp [ M ] [ M ] [ 2 ] ; memset ( dp , -1 , sizeof ( dp ) ) ; cout << count@@ Num ( N , 0 , K , 0 , dp ) ; }
Minimum characters required to be removed to sort binary string in ascending order 3401 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int min@@ Deletion ( string str ) { int n = str . length ( ) ; int first@@ Id@@ x1 = -1 ; int last@@ Id@@ x0 = -1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '1' ) { first@@ Id@@ x1 = i ; break ; } } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == '0' ) { last@@ Id@@ x0 = i ; break ; } } if ( first@@ Id@@ x1 == -1 last@@ Id@@ x0 == -1 ) return 0 ; int count@@ 1 = 0 , count@@ 0 = 0 ; for ( int i = 0 ; i < last@@ Id@@ x0 ; i ++ ) { if ( str [ i ] == '1' ) { count@@ 1 ++ ; } } for ( int i = first@@ Id@@ x1 + 1 ; i < n ; i ++ ) { if ( str [ i ] == '1' ) { count@@ 0 ++ ; } } return min ( count@@ 0 , count@@ 1 ) ; } int main ( ) { string str = "100@@ 01@@ 01" ; cout << min@@ Deletion ( str ) ; return 0 ; }
Maxim@@ ized partitions of a string such that each character of the string appears in one substring 3432 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print_@@ substring ( string s ) { int n = s . size ( ) ; string str = " " ; vector < int > ans ; if ( n == 0 ) { cout << " - 1" ; return ; } vector < int > last_@@ pos ( 26 , -1 ) ; for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( last_@@ pos [ s [ i ] - ' a ' ] == -1 ) { last_@@ pos [ s [ i ] - ' a ' ] = i ; } } int min@@ p = -1 ; for ( int i = 0 ; i < n ; ++ i ) { int lp = last_@@ pos [ s [ i ] - ' a ' ] ; min@@ p = max ( min@@ p , lp ) ; if ( i == min@@ p ) { str += s [ i ] ; cout << str << ' ▁ ' ; min@@ p = -1 ; str = " " ; } else { str += s [ i ] ; } } } int main ( ) { string S = " abab@@ cb@@ acade@@ fe@@ g@@ de@@ hi@@ jh@@ k@@ li@@ j " ; print_@@ substring ( S ) ; return 0 ; }
Lengths of maxim@@ ized partitions of a string such that each character of the string appears in one substring 3433 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void partition@@ String ( string s ) { int n = s . size ( ) ; vector < int > ans ; if ( n == 0 ) { cout << " - 1" ; return ; } vector < int > last_@@ pos ( 26 , -1 ) ; for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( last_@@ pos [ s [ i ] - ' a ' ] == -1 ) { last_@@ pos [ s [ i ] - ' a ' ] = i ; } } int min@@ p = -1 , p@@ len = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int lp = last_@@ pos [ s [ i ] - ' a ' ] ; min@@ p = max ( min@@ p , lp ) ; ++ p@@ len ; if ( i == min@@ p ) { ans . push_back ( p@@ len ) ; min@@ p = -1 ; p@@ len = 0 ; } } for ( int i = 0 ; i < ( int ) ans . size ( ) ; i ++ ) { cout << ans [ i ] << " ▁ " ; } } int main ( ) { string str = " ac@@ bb@@ cc " ; partition@@ String ( str ) ; return 0 ; }
Check if all sub@@ strings of length K of a Binary String has equal count of 0 s and 1 s 3495 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int check ( string & s , int k ) { int n = s . size ( ) ; for ( int i = 0 ; i < k ; i ++ ) { for ( int j = i ; j < n ; j += k ) { if ( s [ i ] != s [ j ] ) return false ; } } int c = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( s [ i ] == '0' ) c ++ ; else c -- ; } if ( c == 0 ) return true ; else return false ; } int main ( ) { string s = "@@ 101@@ 01@@ 0" ; int k = 2 ; if ( check ( s , k ) ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
Maximum GC@@ D among all pairs ( i , j ) of first N natural numbers 3500 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max@@ GC@@ D ( int n ) { int max@@ H@@ cf = INT_@@ MIN ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i + 1 ; j <= n ; j ++ ) { max@@ H@@ cf = max ( max@@ H@@ cf , __@@ gcd ( i , j ) ) ; } } return max@@ H@@ cf ; } int main ( ) { int n = 4 ; cout << max@@ GC@@ D ( n ) ; return 0 ; }
Find the root of given non decre@@ asing function between A and B 3540 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define eps 1e-6 NEW_LINE double func ( double a , double b , double c , double x ) { return a * x * x + b * x + c ; } double find@@ Root ( double a , double b , double c , double low , double high ) { double x ; while ( fabs ( high - low ) > eps ) { x = ( low + high ) / 2 ; if ( func ( a , b , c , low ) * func ( a , b , c , x ) <= 0 ) { high = x ; } else { low = x ; } } return x ; } void solve ( double a , double b , double c , double A , double B ) { if ( func ( a , b , c , A ) * func ( a , b , c , B ) > 0 ) { cout << " No ▁ solution " ; } else { cout << fixed << setprecision ( 4 ) << find@@ Root ( a , b , c , A , B ) ; } } int main ( ) { double a = 2 , b = -@@ 3 , c = -2 , A = 0 , B = 3 ; solve ( a , b , c , A , B ) ; return 0 ; }
Count of Rect@@ angles with area K made up of only 1 s from given Binary Arrays 3545 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; vector < int > find@@ Sub@@ arrays ( vector < int > & a ) { int n = a . size ( ) ; vector < int > freq ( n + 1 ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { if ( count == 0 ) continue ; else { int value = count ; for ( int j = 1 ; j <= count ; j ++ ) { freq [ j ] += value ; value -- ; } count = 0 ; } } else count ++ ; } if ( count > 0 ) { int value = count ; for ( int j = 1 ; j <= count ; j ++ ) { freq [ j ] += value ; value -- ; } } return freq ; } void count@@ Rect@@ angles ( vector < int > & a , vector < int > & b , int K ) { int n = a . size ( ) ; int m = b . size ( ) ; vector < int > sub@@ A = find@@ Sub@@ arrays ( a ) ; vector < int > sub@@ B = find@@ Sub@@ arrays ( b ) ; int total = 0 ; for ( int i = 1 ; i < sub@@ A . size ( ) ; i ++ ) { if ( K % i == 0 and ( K / i ) <= m ) { total = total + sub@@ A [ i ] * sub@@ B [ K / i ] ; } } cout << total ; } int main ( ) { vector < int > a = { 0 , 0 , 1 , 1 } ; vector < int > b = { 1 , 0 , 1 } ; int K = 2 ; count@@ Rect@@ angles ( a , b , K ) ; return 0 ; }
Print Lon@@ gest Bit@@ on@@ ic sub@@ sequence ( Space Optim@@ ized Appro@@ ach ) 3547 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ Res ( vector < int > & res ) { int n = res . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { cout << res [ i ] << " ▁ " ; } } void print@@ L@@ BS ( int arr [ ] , int N ) { int lis [ N ] ; int lds [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { lis [ i ] = lds [ i ] = 1 ; } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] < arr [ i ] ) { if ( lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; } } } for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = N - 1 ; j > i ; j -- ) { if ( arr [ j ] < arr [ i ] ) { if ( lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; } } } int Max@@ Val = arr [ 0 ] , inx = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( Max@@ Val < lis [ i ] + lds [ i ] - 1 ) { Max@@ Val = lis [ i ] + lds [ i ] - 1 ; inx = i ; } } int ct@@ 1 = lis [ inx ] ; vector < int > res ; for ( int i = inx ; i >= 0 && ct@@ 1 > 0 ; i -- ) { if ( lis [ i ] == ct@@ 1 ) { res . push_back ( arr [ i ] ) ; ct@@ 1 -- ; } } reverse ( res . begin ( ) , res . end ( ) ) ; int ct2 = lds [ inx ] - 1 ; for ( int i = inx ; i < N && ct2 > 0 ; i ++ ) { if ( lds [ i ] == ct2 ) { res . push_back ( arr [ i ] ) ; ct2 -- ; } } print@@ Res ( res ) ; } int main ( ) { int arr [ ] = { 80 , 60 , 30 , 40 , 20 , 10 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; print@@ L@@ BS ( arr , N ) ; }
Lon@@ gest Sub@@ arrays having each Array element as the maximum 3576 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void solve ( int n , int arr [ ] ) { int i , ans = 0 ; for ( i = 0 ; i < n ; i ++ ) { int left = max ( i - 1 , 0 ) ; int right = min ( n - 1 , i + 1 ) ; while ( left >= 0 ) { if ( arr [ left ] > arr [ i ] ) { left ++ ; break ; } left -- ; } if ( left < 0 ) left ++ ; while ( right < n ) { if ( arr [ right ] > arr [ i ] ) { right -- ; break ; } right ++ ; } if ( right >= n ) right -- ; ans = 1 + right - left ; cout << ans << " ▁ " ; } } int main ( ) { int arr [ ] = { 4 , 2 , 1 } ; int n = sizeof arr / sizeof arr [ 0 ] ; solve ( n , arr ) ; return 0 ; }
Queries to find the Lower Bound of K from Prefix Sum Array with updates using F@@ en@@ w@@ ick Tree 3627 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int getS@@ um ( int BIT@@ ree [ ] , int index ) { int ans = 0 ; index += 1 ; while ( index > 0 ) { ans += BIT@@ ree [ index ] ; index -= index & ( - index ) ; } return ans ; } static void update@@ BIT ( int BIT@@ ree [ ] , int n , int index , int val ) { index = index + 1 ; while ( index <= n ) { BIT@@ ree [ index ] += val ; index += index & ( - index ) ; } } int * construct@@ BIT@@ ree ( int arr [ ] , int n ) { int * BIT@@ ree = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) BIT@@ ree [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) update@@ BIT ( BIT@@ ree , n , i , arr [ i ] ) ; return BIT@@ ree ; } int get@@ LowerBound ( int BIT@@ ree [ ] , int arr [ ] , int n , int k ) { int lb = -1 ; int l = 0 , r = n - 1 ; while ( l <= r ) { int mid = l + ( r - l ) / 2 ; if ( getS@@ um ( BIT@@ ree , mid ) >= k ) { r = mid - 1 ; lb = mid ; } else l = mid + 1 ; } return lb ; } void perform@@ Queries ( int A [ ] , int n , int q [ ] [ 3 ] ) { int * BIT@@ ree = construct@@ BIT@@ ree ( A , n ) ; for ( int i = 0 ; i < sizeof ( q [ 0 ] ) / sizeof ( int ) ; i ++ ) { int id = q [ i ] [ 0 ] ; if ( id == 1 ) { int idx = q [ i ] [ 1 ] ; int val = q [ i ] [ 2 ] ; A [ idx ] += val ; update@@ BIT ( BIT@@ ree , n , idx , val ) ; } else { int k = q [ i ] [ 1 ] ; int lb = get@@ LowerBound ( BIT@@ ree , A , n , k ) ; cout << lb << endl ; } } } int main ( ) { int A [ ] = { 1 , 2 , 3 , 5 , 8 } ; int n = sizeof ( A ) / sizeof ( int ) ; int q [ ] [ 3 ] = { { 1 , 0 , 2 } , { 2 , 5 , 0 } , { 1 , 3 , 5 } } ; perform@@ Queries ( A , n , q ) ; }
Check if an Array is made up of Sub@@ arrays of continuous repeti@@ tions of every distinct element 3630 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool Continuous@@ Elements ( int a [ ] , int n ) { if ( n == 1 ) return false ; int curr = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] != a [ i - 1 ] ) { if ( curr == 1 ) return false ; else curr = 0 ; } curr ++ ; } if ( curr == 1 ) return false ; return true ; } int main ( ) { int a [ ] = { 1 , 1 , 2 , 2 , 1 , 3 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; if ( Continuous@@ Elements ( a , n ) ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
Count of array elements whose order of deletion prece@@ des order of insertion 3671 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int maximum@@ Count ( int A [ ] , int B [ ] , int n ) { queue < int > q ; unordered_@@ set < int > s ; for ( int i = 0 ; i < n ; i ++ ) { s . insert ( B [ i ] ) ; q . push ( B [ i ] ) ; } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . find ( A [ i ] ) == s . end ( ) ) continue ; while ( ! q . empty ( ) && q . front ( ) != A [ i ] ) { s . erase ( q . front ( ) ) ; q . pop ( ) ; count ++ ; } if ( A [ i ] == q . front ( ) ) { q . pop ( ) ; s . erase ( A [ i ] ) ; } if ( q . empty ( ) ) break ; } cout << count << endl ; } int main ( ) { int N = 4 ; int A [ ] = { 1 , 2 , 3 , 4 } ; int B [ ] = { 1 , 2 , 4 , 3 } ; maximum@@ Count ( A , B , N ) ; return 0 ; }
Count of array elements which are greater than all elements on its left 3691 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count_@@ elements ( int arr [ ] , int n ) { int count = 1 ; int max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { count += 1 ; max = arr [ i ] ; } } return count ; } int main ( ) { int arr [ ] = { 2 , 1 , 4 , 6 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ( count_@@ elements ( arr , n ) ) ; }
Lar@@ gest subset having with sum less than equal to sum of respective indices 3696 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Subset ( int * a , int n ) { int sum = 0 ; int cnt = 0 ; vector < int > v ; for ( int i = 1 ; i <= n ; i ++ ) { if ( a [ i - 1 ] - i <= 0 ) { sum += a [ i - 1 ] - i ; cnt += 1 ; } else { v . push_back ( a [ i - 1 ] - i ) ; } } sort ( v . begin ( ) , v . end ( ) ) ; int ptr = 0 ; while ( ptr < v . size ( ) && sum + v [ ptr ] <= 0 ) { cnt += 1 ; ptr += 1 ; sum += v [ ptr ] ; } return cnt ; } int main ( ) { int arr [ ] = { 4 , 1 , 6 , 7 , 8 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << find@@ Subset ( arr , n ) << endl ; }
Check if two arrays can be made equal by rever@@ sing any sub@@ array once 3711 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void check@@ Array ( int A [ ] , int B [ ] , int N ) { int start = 0 ; int end = N - 1 ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] != B [ i ] ) { start = i ; break ; } } for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( A [ i ] != B [ i ] ) { end = i ; break ; } } reverse ( A + start , A + end + 1 ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] != B [ i ] ) { cout << " No " << endl ; return ; } } cout << " Yes " << endl ; } int main ( ) { int A [ ] = { 1 , 3 , 2 , 4 } ; int B [ ] = { 1 , 2 , 3 , 4 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; check@@ Array ( A , B , N ) ; return 0 ; }
Count of subsets having sum of min and max element less than K 3755 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int get_@@ sub@@ set_@@ count ( int arr [ ] , int K , int N ) { sort ( arr , arr + N ) ; int left , right ; left = 0 ; right = N - 1 ; int ans = 0 ; while ( left <= right ) { if ( arr [ left ] + arr [ right ] < K ) { ans += 1 << ( right - left ) ; left ++ ; } else { right -- ; } } return ans ; } int main ( ) { int arr [ ] = { 2 , 4 , 5 , 7 } ; int K = 8 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << get_@@ sub@@ set_@@ count ( arr , K , N ) ; return 0 ; }
Minimum value of K such that sum of cub@@ es of first K natural number is greater than equal to N 3758 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int binary_@@ sear@@ ched_@@ find_@@ x ( int k ) { int l = 0 ; int r = k ; int ans = 0 ; while ( l <= r ) { int mid = l + ( r - l ) / 2 ; if ( pow ( ( ( mid * ( mid + 1 ) ) / 2 ) , 2 ) >= k ) { ans = mid ; r = mid - 1 ; } else { l = mid + 1 ; } } return ans ; } int main ( ) { int N = 100 ; cout << binary_@@ sear@@ ched_@@ find_@@ x ( N ) ; return 0 ; }
Length of the longest Z@@ ig@@ Z@@ ag sub@@ array of the given array 3759 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int len@@ Of@@ Long@@ Z@@ ig@@ Z@@ ag@@ Arr ( int a [ ] , int n ) { int max = 1 , len = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( i % 2 == 0 && ( a [ i ] < a [ i + 1 ] ) ) len ++ ; else if ( i % 2 == 1 && ( a [ i ] > a [ i + 1 ] ) ) len ++ ; else { if ( max < len ) max = len ; len = 1 ; } } if ( max < len ) max = len ; return max ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << len@@ Of@@ Long@@ Z@@ ig@@ Z@@ ag@@ Arr ( arr , n ) ; return 0 ; }
Check if a given number is a Perf@@ ect square using Binary Search 3761 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int check@@ Per@@ fec@@ t@@ Square ( long int N , long int start , long int last ) { long int mid = ( start + last ) / 2 ; if ( start > last ) { return -1 ; } if ( mid * mid == N ) { return mid ; } else if ( mid * mid > N ) { return check@@ Per@@ fec@@ t@@ Square ( N , start , mid - 1 ) ; } else { return check@@ Per@@ fec@@ t@@ Square ( N , mid + 1 , last ) ; } } int main ( ) { long int N = 65 ; cout << check@@ Per@@ fec@@ t@@ Square ( N , 1 , N ) ; return 0 ; }
Find sub@@ array of Length K with Maximum Peak 3776 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ Sub@@ Array ( int * a , int n , int k ) { int pref [ n ] ; pref [ 0 ] = 0 ; for ( int i = 1 ; i < n - 1 ; ++ i ) { pref [ i ] = pref [ i - 1 ] ; if ( a [ i ] > a [ i - 1 ] && a [ i ] > a [ i + 1 ] ) pref [ i ] ++ ; } int peak = 0 , left = 0 ; for ( int i = 0 ; i + k - 1 < n ; ++ i ) if ( pref [ i + k - 2 ] - pref [ i ] > peak ) { peak = pref [ i + k - 2 ] - pref [ i ] ; left = i ; } cout << " Left ▁ = ▁ " << left + 1 << endl ; cout << " Right ▁ = ▁ " << left + k << endl ; cout << " Peak ▁ = ▁ " << peak << endl ; } int main ( ) { int arr [ ] = { 3 , 2 , 3 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; find@@ Sub@@ Array ( arr , n , k ) ; return 0 ; }
Rank of all elements in a Stream in descending order when they arri@@ ve 3785 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; void Find@@ Rank ( int arr [ ] , int length ) { cout << "1" << " ▁ " ; for ( int i = 1 ; i < length ; i ++ ) { int rank = 1 ; for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] > arr [ i ] ) rank ++ ; } cout << rank << " ▁ " ; } } int main ( ) { int arr [ ] = { 88 , 14 , 69 , 30 , 29 , 89 } ; int len = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; Find@@ Rank ( arr , len ) ; return 0 ; }
Count of numbers whose difference with Fi@@ bon@@ ac@@ ci count upto them is at@@ least K 3791 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; const int MAX = 10000@@ 05 ; int fi@@ b@@ Up@@ to [ MAX + 1 ] ; void compute ( int sz ) { bool is@@ Fi@@ b [ sz + 1 ] ; memset ( is@@ Fi@@ b , false , sizeof ( is@@ Fi@@ b ) ) ; int prev = 0 , curr = 1 ; is@@ Fi@@ b [ prev ] = is@@ Fi@@ b [ curr ] = true ; while ( curr <= sz ) { int temp = curr + prev ; is@@ Fi@@ b [ temp ] = true ; prev = curr ; curr = temp ; } fi@@ b@@ Up@@ to [ 0 ] = 1 ; for ( int i = 1 ; i <= sz ; i ++ ) { fi@@ b@@ Up@@ to [ i ] = fi@@ b@@ Up@@ to [ i - 1 ] ; if ( is@@ Fi@@ b [ i ] ) fi@@ b@@ Up@@ to [ i ] ++ ; } } int count@@ Of@@ Numbers ( int N , int K ) { compute ( N ) ; int low = 1 , high = N , ans = 0 ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; if ( mid - fi@@ b@@ Up@@ to [ mid ] >= K ) { ans = mid ; high = mid - 1 ; } else low = mid + 1 ; } return ( ans ? N - ans + 1 : 0 ) ; } int main ( ) { int N = 10 , K = 3 ; cout << count@@ Of@@ Numbers ( N , K ) ; }
Count of strings in the first array which are smaller than every string in the second array 3849 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define MAX 26 NEW_LINE vector < int > find@@ Count ( string a [ ] , string b [ ] , int n , int m ) { int freq [ MAX ] = { 0 } ; vector < int > smalle@@ st@@ Freq ; for ( int i = 0 ; i < n ; i ++ ) { string s = a [ i ] ; memset ( freq , 0 , sizeof freq ) ; for ( int j = 0 ; j < s . size ( ) ; j ++ ) { freq [ s [ j ] - ' a ' ] ++ ; } for ( int j = 0 ; j < MAX ; j ++ ) { if ( freq [ j ] ) { smalle@@ st@@ Freq . push_back ( freq [ j ] ) ; break ; } } } sort ( smalle@@ st@@ Freq . begin ( ) , smalle@@ st@@ Freq . end ( ) ) ; vector < int > ans ; for ( int i = 0 ; i < m ; i ++ ) { string s = b [ i ] ; memset ( freq , 0 , sizeof freq ) ; for ( int j = 0 ; j < s . size ( ) ; j ++ ) { freq [ s [ j ] - ' a ' ] ++ ; } int frequency = 0 ; for ( int j = 0 ; j < MAX ; j ++ ) { if ( freq [ j ] ) { frequency = freq [ j ] ; break ; } } int ind = lower_bound ( smalle@@ st@@ Freq . begin ( ) , smalle@@ st@@ Freq . end ( ) , frequency ) - smalle@@ st@@ Freq . begin ( ) ; ans . push_back ( ind ) ; } return ans ; } void print@@ Answer ( string a [ ] , string b [ ] , int n , int m ) { vector < int > ans = find@@ Count ( a , b , n , m ) ; for ( auto it : ans ) { cout << it << " ▁ " ; } } int main ( ) { string A [ ] = { " aaa " , " aa " , " b@@ dc " } ; string B [ ] = { " cc@@ c@@ ch " , " cc@@ cd " } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int m = sizeof ( B ) / sizeof ( B [ 0 ] ) ; print@@ Answer ( A , B , n , m ) ; return 0 ; }
Count the trip@@ lets such that A [ i ] < B [ j ] < C [ k ] 3871 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ LessThan ( int arr [ ] , int n , int key ) { int l = 0 , r = n - 1 ; int index = -1 ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( arr [ m ] < key ) { l = m + 1 ; index = m ; } else { r = m - 1 ; } } return ( index + 1 ) ; } int count@@ GreaterThan ( int arr [ ] , int n , int key ) { int l = 0 , r = n - 1 ; int index = -1 ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( arr [ m ] <= key ) { l = m + 1 ; } else { r = m - 1 ; index = m ; } } if ( index == -1 ) return 0 ; return ( n - index ) ; } int count@@ Trip@@ lets ( int n , int * a , int * b , int * c ) { sort ( a , a + n ) ; sort ( b , b + n ) ; sort ( c , c + n ) ; int count = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int current = b [ i ] ; int a_@@ index = -1 , c_@@ index = -1 ; int low = count@@ LessThan ( a , n , current ) ; int high = count@@ GreaterThan ( c , n , current ) ; count += ( low * high ) ; } return count ; } int main ( ) { int a [ ] = { 1 , 5 } ; int b [ ] = { 2 , 4 } ; int c [ ] = { 3 , 6 } ; int size = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << count@@ Trip@@ lets ( size , a , b , c ) ; return 0 ; }
Find the winner of the game based on greater number of di@@ visors 3879 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define ll long long int NEW_LINE int di@@ visor@@ count ( int elem ) { int ans = 0 ; for ( int i = 1 ; i <= sqrt ( elem ) ; i ++ ) { if ( elem % i == 0 ) { if ( i * i == elem ) ans ++ ; else ans += 2 ; } } return ans ; } string find@@ winner ( int A [ ] , int B [ ] , int N , int M ) { for ( int i = 0 ; i < N ; i ++ ) { A [ i ] = di@@ visor@@ count ( A [ i ] ) ; } for ( int i = 0 ; i < M ; i ++ ) { B [ i ] = di@@ visor@@ count ( B [ i ] ) ; } sort ( A , A + N ) ; sort ( B , B + M ) ; int win@@ A = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int val = A [ i ] ; int start = 0 ; int end = M - 1 ; int index = -1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( B [ mid ] <= val ) { index = mid ; start = mid + 1 ; } else { end = mid - 1 ; } } win@@ A += ( index + 1 ) ; } int win@@ B = N * M - win@@ A ; if ( win@@ A > win@@ B ) { return " A " ; } else if ( win@@ B > win@@ A ) { return " B " ; } return " Draw " ; } int main ( ) { int A [ ] = { 4 , 12 , 24 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int B [ ] = { 25 , 28 , 13 , 45 } ; int M = sizeof ( B ) / sizeof ( B [ 0 ] ) ; cout << find@@ winner ( A , B , N , M ) ; return 0 ; }
Find the minimum of maximum length of a jump required to reach the last island in exactly k jumps 3882 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Possible ( int arr [ ] , int n , int dist , int k ) { int req = 0 ; int curr = 0 ; int prev = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( curr != n && arr [ curr ] - arr [ prev ] <= dist ) curr ++ ; req ++ ; if ( curr == n ) break ; prev = curr - 1 ; } if ( curr != n ) return false ; if ( req <= k ) return true ; return false ; } int min@@ Distance ( int arr [ ] , int n , int k ) { int l = 0 ; int h = arr [ n - 1 ] ; int ans = 0 ; while ( l <= h ) { int m = ( l + h ) / 2 ; if ( is@@ Possible ( arr , n , m , k ) ) { ans = m ; h = m - 1 ; } else l = m + 1 ; } return ans ; } int main ( ) { int arr [ ] = { 2 , 15 , 36 , 43 } ; int n = sizeof ( arr ) / sizeof ( int ) ; int k = 2 ; cout << min@@ Distance ( arr , n , k ) ; return 0 ; }
Find the smallest number X such that X ! contains at least Y trailing zeros . 3899 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Factor ( int P , int X ) { if ( X < P ) return 0 ; return ( X / P + count@@ Factor ( P , X / P ) ) ; } int find@@ S@@ malle@@ st@@ X ( int Y ) { int low = 0 , high = 5 * Y ; int N = 0 ; while ( low <= high ) { int mid = ( high + low ) / 2 ; if ( count@@ Factor ( 5 , mid ) < Y ) { low = mid + 1 ; } else { N = mid ; high = mid - 1 ; } } return N ; } int main ( ) { int Y = 10 ; cout << find@@ S@@ malle@@ st@@ X ( Y ) ; return 0 ; }
Length of largest sub 3988 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool prime [ 1000000 + 5 ] ; void find@@ Prime ( ) { memset ( prime , true , sizeof ( prime ) ) ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= 1000000 ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= 1000000 ; i += p ) prime [ i ] = false ; } } } int len@@ Of@@ Long@@ Sub@@ arr ( int arr [ ] , int n ) { unordered_map < int , int > um ; int sum = 0 , maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += prime [ arr [ i ] ] == 0 ? -1 : 1 ; if ( sum == 1 ) maxLen = i + 1 ; else if ( um . find ( sum ) == um . end ( ) ) um [ sum ] = i ; if ( um . find ( sum - 1 ) != um . end ( ) ) { if ( maxLen < ( i - um [ sum - 1 ] ) ) maxLen = i - um [ sum - 1 ] ; } } return maxLen ; } int main ( ) { find@@ Prime ( ) ; int arr [ ] = { 1 , 9 , 3 , 4 , 5 , 6 , 7 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << len@@ Of@@ Long@@ Sub@@ arr ( arr , n ) << endl ; return 0 ; }
Su@@ do Placement | Placement T@@ our 4020 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool canBe@@ Optim@@ al@@ Value ( int K , int arr [ ] , int N , int B , int & value ) { int tmp [ N ] ; for ( int i = 0 ; i < N ; i ++ ) tmp [ i ] = ( arr [ i ] + K * ( i + 1 ) ) ; sort ( tmp , tmp + N ) ; value = 0 ; for ( int i = 0 ; i < K ; i ++ ) value += tmp [ i ] ; return value <= B ; } void find@@ NoOf@@ Element@@ sand@@ Value ( int arr [ ] , int N , int B ) { int ans = 0 ; int cumulative@@ Value = 0 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( canBe@@ Optim@@ al@@ Value ( mid , arr , N , B , cumulative@@ Value ) ) { ans = mid ; start = mid + 1 ; } else end = mid - 1 ; } canBe@@ Optim@@ al@@ Value ( ans , arr , N , B , cumulative@@ Value ) ; cout << ans << " ▁ " << cumulative@@ Value << endl ; } int main ( ) { int arr [ ] = { 1 , 2 , 5 , 6 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int B = 90 ; find@@ NoOf@@ Element@@ sand@@ Value ( arr , N , B ) ; return 0 ; }
Permutation present at the middle of lex@@ ico@@ graphic ordering of permutations of at most length N made up integers up to K 4129 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void lex@@ i@@ Middle@@ S@@ malle@@ st ( int K , int N ) { if ( K % 2 == 0 ) { cout << K / 2 << " ▁ " ; for ( int i = 0 ; i < N - 1 ; ++ i ) { cout << K << " ▁ " ; } cout << " STRNEWLINE " ; exit ( 0 ) ; } vector < int > a ( N , ( K + 1 ) / 2 ) ; for ( int i = 0 ; i < N / 2 ; ++ i ) { if ( a . back ( ) == 1 ) { a . pop_back ( ) ; } else { -- a . back ( ) ; while ( ( int ) a . size ( ) < N ) { a . push_back ( K ) ; } } } for ( auto i : a ) { cout << i << " ▁ " ; } cout << " STRNEWLINE " ; } int main ( ) { int K = 2 , N = 4 ; lex@@ i@@ Middle@@ S@@ malle@@ st ( K , N ) ; return 0 ; }
Find any two pairs ( a , b ) and ( c , d ) such that a d 4204 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ Pair ( pair < int , int > * arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int a = arr [ i ] . first , b = arr [ i ] . second ; for ( int j = i + 1 ; j < N ; j ++ ) { int c = arr [ j ] . first , d = arr [ j ] . second ; if ( a < c && b > d ) { cout << " ( " << a << " ▁ " << b << " ) , ▁ ( " << c << " ▁ " << d << " ) STRNEWLINE " ; return ; } } } cout << " NO ▁ SUCH ▁ PAIR ▁ EXIST STRNEWLINE " ; } int main ( ) { pair < int , int > arr [ ] = { { 3 , 7 } , { 21 , 23 } , { 4 , 13 } , { 1 , 2 } , { 7 , -1 } } ; find@@ Pair ( arr , 5 ) ; }
Maxim@@ ize cost to empty given array by repeti@@ tively removing K array elements 4258 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max@@ Cost@@ ToRemove ( int arr [ ] , int N , int K ) { int max@@ Cost = 0 ; sort ( arr , arr + N ) ; for ( int i = 0 ; i < N ; i += K ) { max@@ Cost += arr [ i + 1 ] ; } return max@@ Cost ; } int main ( ) { int arr [ ] = { 1 , 3 , 4 , 1 , 5 , 1 , 5 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 4 ; cout << max@@ Cost@@ ToRemove ( arr , N , K ) ; }
Check if two sorted arrays can be merged to form a sorted array with no adjacent pair from the same array 4263 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool check@@ If@@ Possible@@ Merge ( int A [ ] , int B [ ] , int N ) { int i = 0 ; int j = 0 ; int prev = -1 ; int flag = 1 ; while ( i < N && j < N ) { if ( A [ i ] < B [ j ] && prev != 0 ) { prev = 0 ; i ++ ; } else if ( B [ j ] < A [ i ] && prev != 1 ) { prev = 1 ; j ++ ; } else if ( A [ i ] == B [ j ] ) { if ( prev != 1 ) { prev = 1 ; j ++ ; } else { prev = 0 ; i ++ ; } } else { flag = 0 ; break ; } } return flag ; } int main ( ) { int A [ 3 ] = { 3 , 5 , 8 } ; int B [ 3 ] = { 2 , 4 , 6 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; if ( check@@ If@@ Possible@@ Merge ( A , B , N ) ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
Re@@ arrange array elements excluded by given ranges to maxim@@ ize sum of sub@@ arrays starting from the first index 4266 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max@@ Sum ( int n , int a [ ] , int l [ ] [ 2 ] , int q ) { vector < int > v ; int d [ n ] = { 0 } ; for ( int i = 0 ; i < q ; i ++ ) { for ( int x = l [ i ] [ 0 ] ; x <= l [ i ] [ 1 ] ; x ++ ) { if ( d [ x ] == 0 ) { d [ x ] = 1 ; } } } set < int > st ; for ( int i = 0 ; i < n ; i ++ ) { if ( d [ i ] == 0 ) { v . push_back ( a [ i ] ) ; st . insert ( i ) ; } } sort ( v . begin ( ) , v . end ( ) , greater < int > ( ) ) ; int c = 0 ; for ( auto it : st ) { a [ it ] = v ; c ++ ; } int pref_@@ sum = 0 ; int temp_@@ sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { temp_@@ sum += a [ i ] ; pref_@@ sum += temp_@@ sum ; } return pref_@@ sum ; } int main ( ) { int arr [ ] = { -@@ 8 , 4 , -2 , -@@ 6 , 4 , 7 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int q [ ] [ 2 ] = { { 0 , 0 } , { 4 , 5 } } ; int queries = sizeof ( q ) / sizeof ( q [ 0 ] ) ; cout << max@@ Sum ( N , arr , q , queries ) ; return 0 ; }
Re@@ arrange two given arrays to maxim@@ ize sum of same indexed elements 4276 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int Max@@ Re@@ arr@@ n@@ ge@@ Sum ( int A [ ] , int B [ ] , int N ) { sort ( A , A + N ) ; sort ( B , B + N , greater < int > ( ) ) ; int max@@ Sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { max@@ Sum += abs ( A [ i ] - B [ i ] ) ; } return max@@ Sum ; } int main ( ) { int A [ ] = { 1 , 2 , 2 , 4 , 5 } ; int B [ ] = { 5 , 5 , 5 , 6 , 6 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << Max@@ Re@@ arr@@ n@@ ge@@ Sum ( A , B , N ) ; return 0 ; }
Merge two sorted arrays in O ( 1 ) extra space using Heap 4286 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void min@@ Heap@@ ify ( int br@@ r [ ] , int i , int M ) { int left = 2 * i + 1 ; int right = 2 * i + 2 ; int smallest = i ; if ( left < M && br@@ r [ left ] < br@@ r [ smallest ] ) { smallest = left ; } if ( right < M && br@@ r [ right ] < br@@ r [ smallest ] ) { smallest = right ; } if ( smallest != i ) { swap ( br@@ r [ i ] , br@@ r [ smallest ] ) ; min@@ Heap@@ ify ( br@@ r , smallest , M ) ; } } void merge ( int arr [ ] , int br@@ r [ ] , int N , int M ) { for ( int i = 0 ; i < N ; ++ i ) { if ( arr [ i ] > br@@ r [ 0 ] ) { swap ( arr [ i ] , br@@ r [ 0 ] ) ; min@@ Heap@@ ify ( br@@ r , 0 , M ) ; } } sort ( br@@ r , br@@ r + M ) ; } void print@@ Array ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) cout << arr [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 2 , 23 , 35 , 235 , 233@@ 5 } ; int br@@ r [ ] = { 3 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int M = sizeof ( br@@ r ) / sizeof ( br@@ r [ 0 ] ) ; merge ( arr , br@@ r , N , M ) ; print@@ Array ( arr , N ) ; print@@ Array ( br@@ r , M ) ; return 0 ; }
Lar@@ gest area in a grid unbounded by tow@@ ers 4308 | #@@ include <@@ algorithm@@ > NEW_LINE #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; void max@@ Area ( int point_@@ x [ ] , int point_@@ y [ ] , int n , int length , int width ) { sort ( point_@@ x , point_@@ x + n ) ; sort ( point_@@ y , point_@@ y + n ) ; int dx = point_@@ x [ 0 ] ; int dy = point_@@ y [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { dx = max ( dx , point_@@ x [ i ] - point_@@ x [ i - 1 ] ) ; dy = max ( dy , point_@@ y [ i ] - point_@@ y [ i - 1 ] ) ; } dx = max ( dx , ( length + 1 ) - point_@@ x [ n - 1 ] ) ; dy = max ( dy , ( width + 1 ) - point_@@ y [ n - 1 ] ) ; cout << ( dx - 1 ) * ( dy - 1 ) ; cout << endl ; } int main ( ) { int length = 15 , width = 8 ; int n = 3 ; int point_@@ x [ ] = { 3 , 11 , 8 } ; int point_@@ y [ ] = { 8 , 2 , 6 } ; max@@ Area ( point_@@ x , point_@@ y , n , length , width ) ; return 0 ; }
Maximum modified Array sum possible by choo@@ sing elements as per the given conditions 4331 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE #@@ define ll long long NEW_LINE using namespace std ; ll find@@ Max@@ Value ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; ll ans = arr [ n - 1 ] ; ll max@@ Possible = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; -- i ) { if ( max@@ Possible > 0 ) { if ( arr [ i ] >= max@@ Possible ) { ans += ( max@@ Possible - 1 ) ; max@@ Possible = max@@ Possible - 1 ; } else { max@@ Possible = arr [ i ] ; ans += max@@ Possible ; } } } return ans ; } int main ( ) { int arr [ ] = { 4 , 4 , 1 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << find@@ Max@@ Value ( arr , n ) ; }
Generate all numbers up to N in Lex@@ ico@@ graphical Order 4385 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void lex@@ Numbers ( int n ) { vector < string > s ; for ( int i = 1 ; i <= n ; i ++ ) { s . push_back ( to_string ( i ) ) ; } sort ( s . begin ( ) , s . end ( ) ) ; vector < int > ans ; for ( int i = 0 ; i < n ; i ++ ) ans . push_back ( sto@@ i ( s [ i ] ) ) ; for ( int i = 0 ; i < n ; i ++ ) cout << ans [ i ] << " ▁ " ; } int main ( ) { int n = 15 ; lex@@ Numbers ( n ) ; return 0 ; }
Sort an Array based on the absolute difference of adjacent elements 4430 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void sorted@@ Adjac@@ ent@@ Differen@@ ces ( int arr [ ] , int n ) { int ans [ n ] ; sort ( arr + 0 , arr + n ) ; int l = 0 , r = n - 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( i % 2 ) { ans [ i ] = arr [ l ] ; l ++ ; } else { ans [ i ] = arr [ r ] ; r -- ; } } for ( int i = 0 ; i < n ; i ++ ) { cout << ans [ i ] << " ▁ " ; } } int main ( ) { int arr [ ] = { 5 , -2 , 4 , 8 , 6 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sorted@@ Adjac@@ ent@@ Differen@@ ces ( arr , n ) ; return 0 ; }
Check if elements of array can be arrange@@ d in AP , GP or HP 4449 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool check@@ Is@@ AP ( double arr [ ] , int n ) { if ( n == 1 ) return true ; sort ( arr , arr + n ) ; double d = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] != d ) { return false ; } } return true ; } bool check@@ Is@@ GP ( double arr [ ] , int n ) { if ( n == 1 ) return true ; sort ( arr , arr + n ) ; double r = arr [ 1 ] / arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i ] / arr [ i - 1 ] != r ) return false ; } return true ; } bool check@@ Is@@ HP ( double arr [ ] , int n ) { if ( n == 1 ) { return true ; } double rec [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { rec [ i ] = ( ( 1 / arr [ i ] ) ) ; } if ( check@@ Is@@ AP ( rec , n ) ) return true ; else return false ; } int main ( ) { double arr [ ] = { 1.0 / 5.0 , 1.0 / 10.0 , 1.0 / 15.0 , 1.0 / 20.0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int flag = 0 ; if ( check@@ Is@@ AP ( arr , n ) ) { cout << " Yes , ▁ An ▁ AP ▁ can ▁ be ▁ formed " << endl ; flag = 1 ; } if ( check@@ Is@@ GP ( arr , n ) ) { cout << " Yes , ▁ A ▁ GP ▁ can ▁ be ▁ formed " << endl ; flag = 1 ; } if ( check@@ Is@@ HP ( arr , n ) ) { cout << " Yes , ▁ A ▁ HP ▁ can ▁ be ▁ formed " << endl ; flag = 1 ; } else if ( flag == 0 ) { cout << " No " ; } return 0 ; }
Sorting element of an array by frequency in decre@@ asing order 4458 | #@@ include " bits / std@@ c + + . h " NEW_LINE using namespace std ; int sort@@ By@@ Freq ( int * arr , int n ) { int max@@ E = -1 ; for ( int i = 0 ; i < n ; i ++ ) { max@@ E = max ( max@@ E , arr [ i ] ) ; } int freq [ max@@ E + 1 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; } int cnt = 0 ; for ( int i = 0 ; i <= max@@ E ; i ++ ) { if ( freq [ i ] > 0 ) { int value = 100000 - i ; arr [ cnt ] = 100000 * freq [ i ] + value ; cnt ++ ; } } return cnt ; } void print@@ Sorted@@ Array ( int * arr , int cnt ) { for ( int i = 0 ; i < cnt ; i ++ ) { int frequency = arr [ i ] / 100000 ; int value = 100000 - ( arr [ i ] % 100000 ) ; for ( int j = 0 ; j < frequency ; j ++ ) { cout << value << ' ▁ ' ; } } } int main ( ) { int arr [ ] = { 4 , 4 , 5 , 6 , 4 , 2 , 2 , 8 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int cnt = sort@@ By@@ Freq ( arr , n ) ; sort ( arr , arr + cnt , greater < int > ( ) ) ; print@@ Sorted@@ Array ( arr , cnt ) ; return 0 ; }
Maximum possible remainder when an element is divided by other element in the array 4482 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max@@ Mod ( int arr [ ] , int n ) { int maxVal = * max_@@ element ( arr , arr + n ) ; int second@@ Max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < maxVal && arr [ i ] > second@@ Max ) { second@@ Max = arr [ i ] ; } } return second@@ Max ; } int main ( ) { int arr [ ] = { 2 , 4 , 1 , 5 , 3 , 6 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << max@@ Mod ( arr , n ) ; return 0 ; }
Choose X elements from A [ ] and Y elements from B [ ] which satisfy the given condition 4493 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Possible ( int A [ ] , int B [ ] , int n , int m , int x , int y ) { if ( x > n y > m ) return false ; sort ( A , A + n ) ; sort ( B , B + m ) ; if ( A [ x - 1 ] < B [ m - y ] ) return true ; else return false ; } int main ( ) { int A [ ] = { 1 , 1 , 1 , 1 , 1 } ; int B [ ] = { 2 , 2 } ; int n = sizeof ( A ) / sizeof ( int ) ; int m = sizeof ( B ) / sizeof ( int ) ; int x = 3 , y = 1 ; if ( is@@ Possible ( A , B , n , m , x , y ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
Find K@@ th element in an array containing odd elements first and then even elements 4501 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int getNumber ( int n , int k ) { int arr [ n ] ; int i = 0 ; int odd = 1 ; while ( odd <= n ) { arr [ i ++ ] = odd ; odd += 2 ; } int even = 2 ; while ( even <= n ) { arr [ i ++ ] = even ; even += 2 ; } return arr [ k - 1 ] ; } int main ( ) { int n = 8 , k = 5 ; cout << getNumber ( n , k ) ; return 0 ; }
Find minimum changes required in an array for it to contain k distinct elements 4507 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define MAX 10000@@ 5 NEW_LINE int M@@ in_@@ Replace ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int freq [ MAX ] ; memset ( freq , 0 , sizeof freq ) ; int p = 0 ; freq [ p ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) ++ freq [ p ] ; else ++ freq [ ++ p ] ; } sort ( freq , freq + n , greater < int > ( ) ) ; int ans = 0 ; for ( int i = k ; i <= p ; i ++ ) ans += freq [ i ] ; return ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 7 , 8 , 2 , 3 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ; cout << M@@ in_@@ Replace ( arr , n , k ) ; return 0 ; }
Maximum number of elements without overlapping in a Line 4510 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int Segment ( int x [ ] , int l [ ] , int n ) { if ( n == 1 ) return 1 ; int ans = 2 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( x [ i ] - l [ i ] > x [ i - 1 ] ) ans ++ ; else if ( x [ i ] + l [ i ] < x [ i + 1 ] ) { x [ i ] = x [ i ] + l [ i ] ; ans ++ ; } } return ans ; } int main ( ) { int x [ ] = { 1 , 3 , 4 , 5 , 8 } , l [ ] = { 10 , 1 , 2 , 2 , 5 } ; int n = sizeof ( x ) / sizeof ( x [ 0 ] ) ; cout << Segment ( x , l , n ) ; return 0 ; }
Ar@@ range N elements in circular fashi@@ on such that all elements are strictly less than sum of adjacent elements 4520 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ Arrange@@ ment ( int a [ ] , int n ) { sort ( a , a + n ) ; int b [ n ] ; int low = 0 , high = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) b [ low ++ ] = a [ i ] ; else b [ high -- ] = a [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 ) { if ( b [ n - 1 ] + b [ 1 ] <= b [ i ] ) { cout << -1 ; return ; } } else if ( i == ( n - 1 ) ) { if ( b [ n - 2 ] + b [ 0 ] <= b [ i ] ) { cout << -1 ; return ; } } else { if ( b [ i - 1 ] + b [ i + 1 ] <= b [ i ] ) { cout << -1 ; return ; } } } for ( int i = 0 ; i < n ; i ++ ) cout << b [ i ] << " ▁ " ; } int main ( ) { int a [ ] = { 1 , 4 , 4 , 3 , 2 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; print@@ Arrange@@ ment ( a , n ) ; return 0 ; }
Check if the given matrix is increasing row and column wise 4551 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define N 2 NEW_LINE #@@ define M 2 NEW_LINE bool is@@ Matrix@@ Inc ( int a [ N ] [ M ] ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( i - 1 >= 0 ) { if ( a [ i ] [ j ] <= a [ i - 1 ] [ j ] ) return false ; } if ( j - 1 >= 0 ) { if ( a [ i ] [ j ] <= a [ i ] [ j - 1 ] ) return false ; } } } return true ; } int main ( ) { int a [ N ] [ M ] = { { 2 , 10 } , { 11 , 20 } } ; if ( is@@ Matrix@@ Inc ( a ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
Maxim@@ ize the size of array by deleting exactly k sub 4555 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; const int N = 1e@@ 7 + 5 ; bool prime [ N ] ; void se@@ ive ( ) { for ( int i = 2 ; i < N ; i ++ ) { if ( ! prime [ i ] ) { for ( int j = i + i ; j < N ; j += i ) { prime [ j ] = 1 ; } } } prime [ 1 ] = 1 ; } int max@@ Size@@ Arr ( int * arr , int n , int k ) { vector < int > v , diff ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) v . push_back ( i ) ; } for ( int i = 1 ; i < v . size ( ) ; i ++ ) { diff . push_back ( v [ i ] - v [ i - 1 ] - 1 ) ; } sort ( diff . begin ( ) , diff . end ( ) ) ; for ( int i = 1 ; i < diff . size ( ) ; i ++ ) { diff [ i ] += diff [ i - 1 ] ; } if ( k > n || ( k == 0 && v . size ( ) ) ) { return -1 ; } else if ( v . size ( ) <= k ) { return ( n - k ) ; } else if ( v . size ( ) > k ) { int tt = v . size ( ) - k ; int sum = 0 ; sum += diff [ tt - 1 ] ; int res = n - ( v . size ( ) + sum ) ; return res ; } } int main ( ) { se@@ ive ( ) ; int arr [ ] = { 2 , 4 , 2 , 2 , 4 , 2 , 4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ; cout << max@@ Size@@ Arr ( arr , n , k ) ; return 0 ; }
Sort Linked List containing values from 1 to N 4661 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; bool sort@@ List ( struct Node * head ) { int start@@ Val = 1 ; while ( head != NULL ) { head -> data = start@@ Val ; start@@ Val ++ ; head = head -> next ; } } void push ( struct Node * * head_@@ ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = ( * head_@@ ref ) ; ( * head_@@ ref ) = new_node ; } void print@@ List ( struct Node * node ) { while ( node != NULL ) { cout << node -> data << " ▁ " ; node = node -> next ; } } int main ( ) { struct Node * start = NULL ; push ( & start , 2 ) ; push ( & start , 1 ) ; push ( & start , 6 ) ; push ( & start , 4 ) ; push ( & start , 5 ) ; push ( & start , 3 ) ; sort@@ List ( start ) ; print@@ List ( start ) ; return 0 ; }
Count number of trip@@ lets in an array having sum in the range [ a , b ] 4694 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Trip@@ let@@ s@@ LessThan ( int arr [ ] , int n , int val ) { sort ( arr , arr + n ) ; int ans = 0 ; int j , k ; int sum ; for ( int i = 0 ; i < n - 2 ; i ++ ) { j = i + 1 ; k = n - 1 ; while ( j != k ) { sum = arr [ i ] + arr [ j ] + arr [ k ] ; if ( sum > val ) k -- ; else { ans += ( k - j ) ; j ++ ; } } } return ans ; } int count@@ Trip@@ lets ( int arr [ ] , int n , int a , int b ) { int res ; res = count@@ Trip@@ let@@ s@@ LessThan ( arr , n , b ) - count@@ Trip@@ let@@ s@@ LessThan ( arr , n , a - 1 ) ; return res ; } int main ( ) { int arr [ ] = { 2 , 7 , 5 , 3 , 8 , 4 , 1 , 9 } ; int n = sizeof arr / sizeof arr [ 0 ] ; int a = 8 , b = 16 ; cout << count@@ Trip@@ lets ( arr , n , a , b ) << endl ; return 0 ; }
Find maximum height pyram@@ id from the given array of objects 4777 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max@@ Level ( int boxes [ ] , int n ) { sort ( boxes , boxes + n ) ; int prev_@@ width = boxes [ 0 ] ; int prev_@@ count = 1 ; int curr_@@ count = 0 ; int curr_@@ width = 0 ; for ( int i = 1 ; i < n ; i ++ ) { curr_@@ width += boxes [ i ] ; curr_@@ count += 1 ; if ( curr_@@ width > prev_@@ width && curr_@@ count > prev_@@ count ) { prev_@@ width = curr_@@ width ; prev_@@ count = curr_@@ count ; curr_@@ count = 0 ; curr_@@ width = 0 ; ans ++ ; } } return ans ; } int main ( ) { int boxes [ ] = { 10 , 20 , 30 , 50 , 60 , 70 } ; int n = sizeof ( boxes ) / sizeof ( boxes [ 0 ] ) ; cout << max@@ Level ( boxes , n ) << endl ; return 0 ; }
Number of sw@@ aps to sort when only adjacent sw@@ apping allowed 4812 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE int merge ( int arr [ ] , int temp [ ] , int left , int mid , int right ) { int inv_@@ count = 0 ; int i = left ; int j = mid ; int k = left ; while ( ( i <= mid - 1 ) && ( j <= right ) ) { if ( arr [ i ] <= arr [ j ] ) temp [ k ++ ] = arr [ i ++ ] ; else { temp [ k ++ ] = arr [ j ++ ] ; inv_@@ count = inv_@@ count + ( mid - i ) ; } } while ( i <= mid - 1 ) temp [ k ++ ] = arr [ i ++ ] ; while ( j <= right ) temp [ k ++ ] = arr [ j ++ ] ; for ( i = left ; i <= right ; i ++ ) arr [ i ] = temp [ i ] ; return inv_@@ count ; } int _@@ merge@@ Sort ( int arr [ ] , int temp [ ] , int left , int right ) { int mid , inv_@@ count = 0 ; if ( right > left ) { mid = ( right + left ) / 2 ; inv_@@ count = _@@ merge@@ Sort ( arr , temp , left , mid ) ; inv_@@ count += _@@ merge@@ Sort ( arr , temp , mid + 1 , right ) ; inv_@@ count += merge ( arr , temp , left , mid + 1 , right ) ; } return inv_@@ count ; } int count@@ Sw@@ aps ( int arr [ ] , int n ) { int temp [ n ] ; return _@@ merge@@ Sort ( arr , temp , 0 , n - 1 ) ; } int main ( int argv , char * * args ) { int arr [ ] = { 1 , 20 , 6 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( " Number ▁ of ▁ sw@@ aps ▁ is ▁ % d ▁ STRNEWLINE " , count@@ Sw@@ aps ( arr , n ) ) ; return 0 ; }
Minimum size of Array possible with given sum and product values 4873 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int minimum@@ Size@@ Array ( int S , int P ) { if ( S == P ) { return 1 ; } for ( int i = 2 ; i <= S ; i ++ ) { double d = i ; if ( ( S / d ) >= pow ( P , 1.0 / d ) ) { return i ; } } return -1 ; } int main ( ) { int S = 5 , P = 6 ; cout << minimum@@ Size@@ Array ( S , P ) ; return 0 ; }
Find maximum sum of sub@@ sequence after fli@@ pping signs of at most K elements in given Array 4880 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max@@ Sub@@ seq ( int arr [ ] , int N , int K ) { int sum = 0 ; sort ( arr , arr + N ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( K == 0 ) break ; if ( arr [ i ] < 0 ) { arr [ i ] = - arr [ i ] ; K -- ; } } for ( int i = 0 ; i < N ; i ++ ) if ( arr [ i ] > 0 ) sum += arr [ i ] ; return sum ; } int main ( ) { int arr [ ] = { 6 , -@@ 10 , -1 , 0 , -@@ 4 , 2 } ; int K = 2 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << max@@ Sub@@ seq ( arr , N , K ) ; return 0 ; }
Re@@ arrange sorted array such that all odd indices elements comes before all even indices element 4887 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ The@@ Array ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) cout << arr [ i ] << " ▁ " ; } void re@@ arrange ( int arr [ ] , int N ) { if ( N & 1 ) N -- ; int od@@ d_@@ idx = 1 , ev@@ en_@@ idx = 0 ; int i , max_@@ elem = arr [ N - 1 ] + 1 ; for ( i = 0 ; i < N / 2 ; i ++ ) { arr [ i ] += ( arr [ od@@ d_@@ idx ] % max_@@ elem ) * max_@@ elem ; od@@ d_@@ idx += 2 ; } for ( ; i < N ; i ++ ) { arr [ i ] += ( arr [ ev@@ en_@@ idx ] % max_@@ elem ) * max_@@ elem ; ev@@ en_@@ idx += 2 ; } for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] = arr [ i ] / max_@@ elem ; } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 16 , 18 , 19 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; re@@ arrange ( arr , N ) ; print@@ The@@ Array ( arr , N ) ; return 0 ; }
Count of numbers in range [ L , R ] having sum of digits of its square equal to square of sum of digits 4899 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool check ( int num ) { int sm = 0 ; int num2 = num * num ; while ( num ) { sm += num % 10 ; num /= 10 ; } int sm@@ 2 = 0 ; while ( num2 ) { sm@@ 2 += num2 % 10 ; num2 /= 10 ; } return ( ( sm * sm ) == sm@@ 2 ) ; } int convert ( string s ) { int val = 0 ; reverse ( s . begin ( ) , s . end ( ) ) ; int cur = 1 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { val += ( s [ i ] - '0' ) * cur ; cur *= 10 ; } return val ; } void generate ( string s , int len , set < int > & uniq ) { if ( s . size ( ) == len ) { if ( check ( convert ( s ) ) ) { uniq . insert ( convert ( s ) ) ; } return ; } for ( int i = 0 ; i <= 3 ; i ++ ) { generate ( s + char ( i + '0' ) , len , uniq ) ; } } int total@@ Numbers ( int L , int R ) { int ans = 0 ; int max_len = log10 ( R ) + 1 ; set < int > uniq ; for ( int i = 1 ; i <= max_len ; i ++ ) { generate ( " " , i , uniq ) ; } for ( auto x : uniq ) { if ( x >= L && x <= R ) { ans ++ ; } } return ans ; } int main ( ) { int L = 22 , R = 22 ; cout << total@@ Numbers ( L , R ) ; }
Count of distinct N 4903 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Arrays ( int n , int k ) { vector < vector < int > > di@@ visors ( k + 1 ) ; for ( int i = 1 ; i <= k ; i ++ ) { for ( int j = 2 * i ; j <= k ; j += i ) { di@@ visors [ j ] . push_back ( i ) ; } } vector < vector < int > > dp ( n + 1 , vector < int > ( k + 1 ) ) ; for ( int j = 1 ; j <= k ; j ++ ) { dp [ 1 ] [ j ] = 1 ; } for ( int x = 2 ; x <= n ; x ++ ) { int sum = 0 ; for ( int j = 1 ; j <= k ; j ++ ) { sum += dp [ x - 1 ] [ j ] ; } for ( int y = 1 ; y <= k ; y ++ ) { dp [ x ] [ y ] = sum ; for ( int d : di@@ visors [ y ] ) { dp [ x ] [ y ] = ( dp [ x ] [ y ] - dp [ x - 1 ] [ d ] ) ; } } } int sum = 0 ; for ( int j = 1 ; j <= k ; j ++ ) { sum += dp [ n ] [ j ] ; } return sum ; } int main ( ) { int N = 2 , K = 3 ; cout << count@@ Arrays ( N , K ) ; return 0 ; }
Maximum ro@@ ds to put horizont@@ ally such that no two ro@@ ds overlap on X coordinate 4923 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Maximum@@ Points ( int N , int X [ ] , int H [ ] ) { int ans = 0 ; int prev = INT_@@ MIN ; for ( int i = 0 ; i < N ; ++ i ) { if ( prev < ( X [ i ] - H [ i ] ) ) { ++ ans ; prev = X [ i ] ; } else if ( i == N - 1 || ( X [ i ] + H [ i ] ) < X [ i + 1 ] ) { ++ ans ; prev = X [ i ] + H [ i ] ; } else { prev = X [ i ] ; } } return ans ; } int main ( ) { int X [ ] = { 1 , 2 , 3 } ; int H [ ] = { 2 , 5 , 5 } ; int N = sizeof ( X ) / sizeof ( X [ 0 ] ) ; cout << find@@ Maximum@@ Points ( N , X , H ) ; }
Print all numbers that can be obtained by adding A or B to N exactly M times 4956 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void possible@@ Numbers ( set < int > & numbers , int N , int M , int A , int B ) { if ( M == 0 ) { numbers . insert ( N ) ; return ; } possible@@ Numbers ( numbers , N + A , M - 1 , A , B ) ; possible@@ Numbers ( numbers , N + B , M - 1 , A , B ) ; } int main ( ) { int N = 5 , M = 3 , A = 4 , B = 6 ; set < int > numbers ; possible@@ Numbers ( numbers , N , M , A , B ) ; for ( int x : numbers ) { cout << x << " ▁ " ; } return 0 ; }
Minimum decre@@ ments or division by a proper divisor required to reduce N to 1 4978 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int reduce@@ To@@ One ( long long int N ) { int cnt = 0 ; while ( N != 1 ) { if ( N == 2 or ( N % 2 == 1 ) ) { N = N - 1 ; cnt ++ ; } else if ( N % 2 == 0 ) { N = N / ( N / 2 ) ; cnt ++ ; } } return cnt ; } int main ( ) { long long int N = 35 ; cout << reduce@@ To@@ One ( N ) ; return 0 ; }
Find K positive integers not exce@@ eding N and having sum S 4991 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void solve ( int S , int K , int N ) { if ( K > N ) { cout << " - 1" << endl ; return ; } int max_@@ sum = 0 , min_@@ sum = 0 ; for ( int i = 1 ; i <= K ; i ++ ) { min_@@ sum += i ; max_@@ sum += N - i + 1 ; } if ( S < min_@@ sum S > max_@@ sum ) { cout << " - 1" << endl ; return ; } int s1 = 0 ; vector < int > nums ; for ( int i = 1 ; i <= N ; i ++ ) { if ( s1 > S ) break ; s1 += i ; nums . push_back ( i ) ; } vector < int > answer ; int s2 = 0 ; for ( int i = 0 ; i < K - 1 ; i ++ ) { answer . push_back ( nums [ i ] ) ; s2 += nums [ i ] ; } answer . push_back ( S - s2 ) ; int Max = N ; for ( int i = answer . size ( ) - 1 ; i >= 0 ; i -- ) { if ( answer [ i ] > Max ) { int extra = answer [ i ] - Max ; if ( i - 1 >= 0 ) answer [ i - 1 ] += extra ; answer [ i ] = Max ; Max -- ; } else break ; } for ( auto x : answer ) cout << x << " ▁ " ; cout << endl ; } int main ( ) { int S = 15 , K = 4 , N = 8 ; solve ( S , K , N ) ; return 0 ; }
Minimum removal of elements from end of an array required to obtain sum K 4994 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void min@@ Size@@ Arr ( int A [ ] , int N , int K ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += A [ i ] ; if ( K > sum ) { cout << -1 ; return ; } if ( K == sum ) { for ( int i = 0 ; i < N ; i ++ ) { cout << A [ i ] << " ▁ " ; } return ; } int tar = sum - K ; unordered_map < int , int > um ; um [ 0 ] = -1 ; int left , right ; int cur = 0 , max@@ i = -1 ; for ( int i = 0 ; i < N ; i ++ ) { cur += A [ i ] ; if ( um . find ( cur - tar ) != um . end ( ) && i - um [ cur - tar ] > max@@ i ) { max@@ i = i - um [ cur - tar ] ; right = i ; left = um [ cur - tar ] ; } if ( um . find ( cur ) == um . end ( ) ) um [ cur ] = i ; } if ( max@@ i == -1 ) cout << -1 ; else { for ( int i = 0 ; i <= left ; i ++ ) cout << A [ i ] << " ▁ " ; for ( int i = 0 ; i < right ; i ++ ) cout << A [ N - i - 1 ] << " ▁ " ; } } int main ( ) { int N = 7 ; int A [ ] = { 3 , 2 , 1 , 1 , 1 , 1 , 3 } ; int K = 10 ; min@@ Size@@ Arr ( A , N , K ) ; return 0 ; }
Quadrati@@ c equation whose roots are K times the roots of given equation 5002 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ Equation ( int A , int B , int C , int K ) { cout << A << " ▁ " << K * B << " ▁ " << K * K * C ; } int main ( ) { int A = 1 , B = 2 , C = 1 , K = 2 ; find@@ Equation ( A , B , C , K ) ; return 0 ; }
Find the last remaining element after repeated removal of an element from pairs of increasing adjacent array elements 5084 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void can@@ Array@@ Be@@ Redu@@ ced ( int arr [ ] , int N ) { if ( N == 1 ) { cout << arr [ 0 ] ; return ; } if ( arr [ 0 ] < arr [ N - 1 ] ) { cout << arr [ N - 1 ] ; } else cout << " Not ▁ Possible " ; } int main ( ) { int arr [ ] = { 6 , 5 , 2 , 4 , 1 , 3 , 7 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; can@@ Array@@ Be@@ Redu@@ ced ( arr , N ) ; return 0 ; }
Find the player with least 0 s after empty@@ ing a Binary String by removing non 5110 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void construct@@ Array ( int arr [ ] , int N ) { int br@@ r [ N ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { int K = log ( arr [ i ] ) / log ( 2 ) ; int R = pow ( 2 , K ) ; br@@ r [ i ] = R ; } for ( int i = 0 ; i < N ; i ++ ) { cout << br@@ r [ i ] << " ▁ " ; } } int main ( ) { int arr [ ] = { 11 , 5 , 7 , 3 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; construct@@ Array ( arr , N ) ; return 0 ; }
Make all array elements equal to 0 by replacing minimum sub@@ sequences consisting of equal elements 5115 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void min@@ Op@@ sTo@@ Turn@@ Arr@@ To@@ Zero ( int arr [ ] , int N ) { unordered_@@ set < int > st ; for ( int i = 0 ; i < N ; i ++ ) { if ( st . find ( arr [ i ] ) != st . end ( ) arr [ i ] == 0 ) { continue ; } else { st . insert ( arr [ i ] ) ; } } cout << st . size ( ) << endl ; } int main ( ) { int arr [ ] = { 3 , 7 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; min@@ Op@@ sTo@@ Turn@@ Arr@@ To@@ Zero ( arr , N ) ; return 0 ; }
Minim@@ ize count of given operations required to be performed to make all array elements equal to 1 5121 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool Check@@ All@@ Equal ( int arr [ ] , int N ) { for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ 0 ] != arr [ i ] ) { return false ; } } return true ; } int min@@ Cnt@@ Operations ( int arr [ ] , int N ) { int Max = * max_@@ element ( arr , arr + N ) ; bool is@@ Power@@ 2 = ! ( Max && ( Max & ( Max - 1 ) ) ) ; if ( is@@ Power@@ 2 && Check@@ All@@ Equal ( arr , N ) ) { return log2 ( Max ) ; } else { return ceil ( log2 ( Max ) ) + 1 ; } } int main ( ) { int arr [ ] = { 2 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << min@@ Cnt@@ Operations ( arr , N ) ; }
Re@@ arrange array to maxim@@ ize sum of GC@@ D of array elements with their respective indices 5127 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Max@@ Val@@ By@@ Re@@ arr@@ Arr ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; int res = 0 ; do { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += __@@ gcd ( i + 1 , arr [ i ] ) ; } res = max ( res , sum ) ; } while ( next_@@ permutation ( arr , arr + N ) ) ; return res ; } int main ( ) { int arr [ ] = { 3 , 2 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << find@@ Max@@ Val@@ By@@ Re@@ arr@@ Arr ( arr , N ) ; return 0 ; }
Check if sum of the given array can be reduced to 0 by redu@@ cing array elements by K 5133 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int sum@@ zero ( int arr [ ] , int N , int K ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } if ( sum == 0 ) cout << " Yes " ; else if ( sum > 0 ) { if ( sum % K == 0 ) cout << " Yes " ; else cout << " No " ; } else cout << " No " ; return 0 ; } int main ( ) { int K , N ; int ar@@ r1 [ ] = { 1 , -@@ 6 , 2 , 2 } ; K = 1 ; N = sizeof ( ar@@ r1 ) / sizeof ( ar@@ r1 [ 0 ] ) ; sum@@ zero ( ar@@ r1 , N , K ) ; return 0 ; }
Print path from a node to root of given Complete Binary Tree 5146 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; void path_to_@@ root ( int node ) { while ( node >= 1 ) { cout << node << ' ▁ ' ; node /= 2 ; } } int main ( ) { int N = 7 ; path_to_@@ root ( N ) ; return 0 ; }
S@@ malle@@ st number whose sum of digits is N and every digit occur@@ ring at most K times 5148 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ S@@ malle@@ st@@ Number@@ Possible ( int N , int K ) { if ( N > 45 * K ) { cout << " - 1" ; return ; } string res = " " ; int count = 0 ; for ( int i = 9 ; i >= 1 ; ) { if ( count == K ) { i -- ; count = 0 ; } if ( N > i ) { N -= i ; res += ( char ) 48 + i ; } else { res += ( char ) N + 48 ; N = 0 ; break ; } count ++ ; } reverse ( res . begin ( ) , res . end ( ) ) ; cout << res ; } int main ( ) { int N = 25 , K = 3 ; find@@ S@@ malle@@ st@@ Number@@ Possible ( N , K ) ; return 0 ; }
S@@ malle@@ st positive number made up of non 5150 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void result ( int n ) { if ( n > 45 ) { cout << -1 ; return ; } string res ; int digit = 9 ; while ( n > digit ) { res = char ( '0' + digit ) + res ; n -= digit ; digit -= 1 ; } if ( n > 0 ) { res = char ( '0' + n ) + res ; } cout << res ; } int main ( ) { int N = 19 ; result ( N ) ; return 0 ; }
Find the trip@@ let from given Bit@@ wise XOR and Bit@@ wise AND values of all its pairs 5157 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ Numbers ( int a@@ X@@ OR@@ b , int a@@ AND@@ b , int a@@ X@@ OR@@ c , int a@@ AND@@ c , int b@@ X@@ OR@@ c , int b@@ AND@@ c ) { int a , b , c ; int a@@ SUM@@ b ; int a@@ SUM@@ c ; int b@@ SUM@@ c ; a@@ SUM@@ b = a@@ X@@ OR@@ b + a@@ AND@@ b * 2 ; a@@ SUM@@ c = a@@ X@@ OR@@ c + a@@ AND@@ c * 2 ; b@@ SUM@@ c = b@@ X@@ OR@@ c + b@@ AND@@ c * 2 ; a = ( a@@ SUM@@ b - b@@ SUM@@ c + a@@ SUM@@ c ) / 2 ; b = a@@ SUM@@ b - a ; c = a@@ SUM@@ c - a ; cout << " a ▁ = ▁ " << a ; cout << " , ▁ b ▁ = ▁ " << b ; cout << " , ▁ c ▁ = ▁ " << c ; } int main ( ) { int a@@ X@@ OR@@ b = 30 , a@@ AND@@ b = 0 , a@@ X@@ OR@@ c = 20 , a@@ AND@@ c = 10 , b@@ X@@ OR@@ c = 10 , b@@ AND@@ c = 20 ; find@@ Numbers ( a@@ X@@ OR@@ b , a@@ AND@@ b , a@@ X@@ OR@@ c , a@@ AND@@ c , b@@ X@@ OR@@ c , b@@ AND@@ c ) ; }
Flip consecutive set bits starting from LSB of a given number 5160 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Number ( int N ) { return N & ( N + 1 ) ; } int main ( ) { int N = 39 ; cout << find@@ Number ( N ) ; return 0 ; }
Calculate Bit@@ wise OR of two integers from their given Bit@@ wise AND and Bit@@ wise XOR values 5170 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Bit@@ wise@@ OR@@ Given@@ X@@ OR@@ AND ( int X , int Y ) { return X + Y ; } int main ( ) { int X = 5 , Y = 2 ; cout << find@@ Bit@@ wise@@ OR@@ Given@@ X@@ OR@@ AND ( X , Y ) ; }
Minimum fli@@ ps of odd indexed elements from odd length sub@@ arrays to make two given arrays equal 5171 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void min@@ Operation ( int X [ ] , int Y [ ] , int n ) { int C = 0 ; int count = 0 ; for ( int i = 1 ; i < n ; i = i + 2 ) { if ( X [ i ] != Y [ i ] ) { count ++ ; } else { if ( count != 0 ) C ++ ; count = 0 ; } } if ( count != 0 ) C ++ ; count = 0 ; for ( int i = 0 ; i < n ; i = i + 2 ) { if ( X [ i ] != Y [ i ] ) { count ++ ; } else { if ( count != 0 ) C ++ ; count = 0 ; } } if ( count != 0 ) C ++ ; cout << C ; } int main ( ) { int X [ ] = { 1 , 0 , 0 , 0 , 0 , 1 } ; int Y [ ] = { 1 , 1 , 0 , 1 , 1 , 1 } ; int N = sizeof ( X ) / sizeof ( X [ 0 ] ) ; min@@ Operation ( X , Y , N ) ; return 0 ; }
Count ways to make Bit@@ wise XOR of odd and even indexed elements equal by removing an array element 5175 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void Remo@@ ve_@@ one_@@ element ( int arr [ ] , int n ) { int post_@@ odd = 0 , post_@@ even = 0 ; int curr_@@ odd = 0 , curr_@@ even = 0 ; int res = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( i % 2 ) post_@@ odd ^= arr [ i ] ; else post_@@ even ^= arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 ) post_@@ odd ^= arr [ i ] ; else post_@@ even ^= arr [ i ] ; int X = curr_@@ odd ^ post_@@ even ; int Y = curr_@@ even ^ post_@@ odd ; if ( X == Y ) res ++ ; if ( i % 2 ) curr_@@ odd ^= arr [ i ] ; else curr_@@ even ^= arr [ i ] ; } cout << res << endl ; } int main ( ) { int arr [ ] = { 1 , 0 , 1 , 0 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; Remo@@ ve_@@ one_@@ element ( arr , N ) ; return 0 ; }
Minimum cost required to move all elements to the same position 5181 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int min@@ Cost ( int arr [ ] , int arr_@@ size ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < arr_@@ size ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } cout << min ( even , odd ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int arr_@@ size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; min@@ Cost ( arr , arr_@@ size ) ; }
Minimum index to split array into sub@@ arrays with co 5197 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int GC@@ D ( int a , int b ) { if ( b == 0 ) return a ; return GC@@ D ( b , a % b ) ; } int find@@ Partition ( int nums [ ] , int N ) { int prefix [ N ] , suffix [ N ] , i , k ; prefix [ 0 ] = nums [ 0 ] ; for ( i = 1 ; i < N ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] * nums [ i ] ; } suffix [ N - 1 ] = nums [ N - 1 ] ; for ( i = N - 2 ; i >= 0 ; i -- ) { suffix [ i ] = suffix [ i + 1 ] * nums [ i ] ; } for ( k = 0 ; k < N - 1 ; k ++ ) { if ( GC@@ D ( prefix [ k ] , suffix [ k + 1 ] ) == 1 ) { return k ; } } return -1 ; } int main ( ) { int arr [ ] = { 2 , 3 , 4 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << find@@ Partition ( arr , N ) ; return 0 ; }
Minimum increments required to make given matrix pal@@ ind@@ ro@@ mic 5212 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int pal@@ ind@@ ro@@ me@@ Matrix ( int N , int M , vector < vector < int > > arr ) { int ans = 0 ; for ( int i = 0 ; i < ( N + 1 ) / 2 ; i ++ ) { for ( int j = 0 ; j < ( M + 1 ) / 2 ; j ++ ) { set < pair < int , int > > s ; s . insert ( { i , j } ) ; s . insert ( { i , M - j - 1 } ) ; s . insert ( { N - i - 1 , j } ) ; s . insert ( { N - i - 1 , M - j - 1 } ) ; vector < int > values ; for ( pair < int , int > p : s ) { values . push_back ( arr [ p . first ] [ p . second ] ) ; } int max = * max_@@ element ( values . begin ( ) , values . end ( ) ) ; for ( int k = 0 ; k < values . size ( ) ; k ++ ) { ans += max - values [ k ] ; } } } cout << ans ; } int main ( ) { int N = 3 , M = 3 ; vector < vector < int > > arr = { { 1 , 2 , 1 } , { 3 , 4 , 1 } , { 1 , 2 , 1 } } ; pal@@ ind@@ ro@@ me@@ Matrix ( N , M , arr ) ; return 0 ; }
Re@@ arrange array to make Bit@@ wise XOR of similar indexed elements of two arrays is same 5217 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; vector < int > re@@ arrange@@ Array ( vector < int > & A , vector < int > & B , int N ) { map < int , int > m ; int xor_@@ value = 0 ; for ( int i = 0 ; i < N ; i ++ ) { xor_@@ value ^= A [ i ] ; xor_@@ value ^= B [ i ] ; m [ B [ i ] ] ++ ; } for ( int i = 0 ; i < N ; i ++ ) { B [ i ] = A [ i ] ^ xor_@@ value ; if ( m [ B [ i ] ] ) { m [ B [ i ] ] -- ; } else return vector < int > { } ; } return B ; } void re@@ arrange@@ ArrayUtil ( vector < int > & A , vector < int > & B , int N ) { vector < int > ans = re@@ arrange@@ Array ( A , B , N ) ; if ( ans . size ( ) ) { for ( auto x : ans ) { cout << x << " ▁ " ; } } else { cout << " - 1" ; } } int main ( ) { vector < int > A = { 13 , 21 , 33 , 49 , 53 } ; vector < int > B = { 54 , 50 , 34 , 22 , 14 } ; int N = ( int ) A . size ( ) ; re@@ arrange@@ ArrayUtil ( A , B , N ) ; return 0 ; }
Count of sub@@ arrays having sum equal to its length | Set 2 5218 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Of@@ Sub@@ array ( int arr [ ] , int N ) { unordered_map < int , int > mp ; int answer = 0 ; int sum = 0 ; mp [ 1 ] ++ ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; answer += mp [ sum - i ] ; mp [ sum - i ] ++ ; } cout << answer ; } int main ( ) { int arr [ ] = { 1 , 0 , 2 , 1 , 2 , -2 , 2 , 4 } ; int N = sizeof arr / sizeof arr [ 0 ] ; count@@ Of@@ Sub@@ array ( arr , N ) ; return 0 ; }
XOR of array elements whose mod@@ ular inverse with a given number exists 5220 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } void count@@ Inverse ( int arr [ ] , int N , int M ) { int XOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int g@@ cd@@ Of@@ Man@@ de@@ lement = gcd ( M , arr [ i ] ) ; if ( g@@ cd@@ Of@@ Man@@ de@@ lement == 1 ) { XOR ^= arr [ i ] ; } } cout << XOR << ' ▁ ' ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int M = 4 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; count@@ Inverse ( arr , N , M ) ; return 0 ; }
Bit@@ wise XOR of all unordered pairs from a given array 5231 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int Total@@ Xor@@ Pair ( int arr [ ] , int N ) { int total@@ XOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { total@@ XOR ^= arr [ i ] ^ arr [ j ] ; } } return total@@ XOR ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << Total@@ Xor@@ Pair ( arr , N ) ; }
Count permutations of all integers upto N that can form an acy@@ clic graph based on given conditions 5236 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void possible@@ Ac@@ y@@ clic@@ Graph ( int N ) { cout << pow ( 2 , N - 1 ) ; return ; } int main ( ) { int N = 4 ; possible@@ Ac@@ y@@ clic@@ Graph ( N ) ; return 0 ; }
Count pairs in an array whose product is composite number 5246 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Composite ( int N ) { for ( int i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { return true ; } } return false ; } int composite@@ Pair ( int arr [ ] , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { int prod = arr [ i ] * arr [ j ] ; if ( is@@ Composite ( prod ) ) { res ++ ; } } } return res ; } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 2 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << composite@@ Pair ( arr , N ) ; return 0 ; }
S@@ malle@@ st number exce@@ eding N whose K@@ th bit is set 5258 | #@@ include " bits / std@@ c + + . h " NEW_LINE using namespace std ; int find_@@ next ( int n , int k ) { int M = n + 1 ; while ( 1 ) { if ( M & ( 1@@ ll << k ) ) break ; M ++ ; } return M ; } int main ( ) { int N = 15 , K = 2 ; cout << find_@@ next ( N , K ) ; return 0 ; }
Count maximum non 5262 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int maximum@@ Sub@@ arrays ( int arr [ ] , int N , int target ) { int ans = 0 ; int avail@@ Idx = -1 ; int cur_@@ sum = 0 ; unordered_map < int , int > mp ; mp [ 0 ] = -1 ; for ( int i = 0 ; i < N ; i ++ ) { cur_@@ sum += arr [ i ] ; if ( mp . find ( cur_@@ sum - target ) != mp . end ( ) && mp [ cur_@@ sum - target ] >= avail@@ Idx ) { ans ++ ; avail@@ Idx = i ; } mp [ cur_@@ sum ] = i ; } return ans ; } int main ( ) { int arr [ ] = { 2 , -1 , 4 , 3 , 6 , 4 , 5 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int target = 6 ; cout << maximum@@ Sub@@ arrays ( arr , N , target ) ; return 0 ; }
Count all numbers up to N having M as the last digit 5292 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int getCount ( int N , int M ) { int total_@@ count = 0 ; total_@@ count += ( N / 10 ) ; int x = ( N / 10 ) * 10 ; if ( ( N - x ) >= M ) { total_@@ count = total_@@ count + 1 ; } return total_@@ count ; } int main ( ) { int N = 100 , M = 1 ; cout << getCount ( N , M ) ; return 0 ; }
Count of all possible numbers not exce@@ eding M having suffix N 5315 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int digit@@ s@@ Of ( int num ) { return to_string ( num ) . size ( ) ; } int count ( int a , int tn ) { int diff = pow ( 10 , digit@@ s@@ Of ( a ) ) ; return ( ( tn - a ) / diff ) + 1 ; } int main ( ) { int n , m ; n = 25 , m = 45@@ 00 ; cout << count ( n , m ) ; return 0 ; }
Minimum increment / decrement operations required on Array to satisfy given conditions 5317 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int min@@ Operations ( int a [ ] , int N ) { int num_@@ of_@@ op@@ s1 , num_@@ of_@@ op@@ s2 , sum ; num_@@ of_@@ op@@ s1 = num_@@ of_@@ op@@ s2 = sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += a [ i ] ; if ( i % 2 == 0 && sum >= 0 ) { num_@@ of_@@ op@@ s1 += ( 1 + abs ( sum ) ) ; sum = -1 ; } else if ( i % 2 == 1 && sum <= 0 ) { num_@@ of_@@ op@@ s1 += ( 1 + abs ( sum ) ) ; sum = 1 ; } } sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += a [ i ] ; if ( i % 2 == 1 && sum >= 0 ) { num_@@ of_@@ op@@ s2 += ( 1 + abs ( sum ) ) ; sum = -1 ; } else if ( i % 2 == 0 && sum <= 0 ) { num_@@ of_@@ op@@ s2 += ( 1 + abs ( sum ) ) ; sum = 1 ; } } return min ( num_@@ of_@@ op@@ s1 , num_@@ of_@@ op@@ s2 ) ; } int main ( ) { int arr [ ] = { 3 , -@@ 4 , 5 , 0 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << min@@ Operations ( arr , N ) ; return 0 ; }
Count total set bits in all numbers from range L to R 5347 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int count@@ Set@@ Bits ( int L , int R ) { int count = 0 ; for ( int i = L ; i <= R ; i ++ ) { count += __builtin@@ _pop@@ count ( i ) ; } return count ; } int main ( ) { int L = 3 , R = 5 ; cout << " Total ▁ set ▁ bit ▁ count ▁ is ▁ " << count@@ Set@@ Bits ( L , R ) ; return 0 ; }
Minim@@ ize sw@@ aps required to maxim@@ ize the count of elements replacing a greater element in an Array 5363 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Sw@@ aps ( int A [ ] , int n ) { sort ( A , A + n ) ; int ind = 1 , res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( ind < n and A [ ind ] == A [ i ] ) ind ++ ; if ( ind < n and A [ ind ] > A [ i ] ) { res ++ ; ind ++ ; } if ( ind >= n ) break ; } return res ; } int main ( ) { int A [ ] = { 4 , 3 , 3 , 2 , 5 } ; cout << count@@ Sw@@ aps ( A , 5 ) ; return 0 ; }
Count of pairs with sum N from first N natural numbers 5420 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int numberOf@@ Pairs ( int n ) { if ( n % 2 == 0 ) return n / 2 - 1 ; else return n / 2 ; } int main ( ) { int n = 8 ; cout << numberOf@@ Pairs ( n ) ; return 0 ; }
Maximum cost path in an Un@@ directed Graph such that no edge is visited twice in a row 5448 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; const int N = 100000 ; int can@@ Take ; int best ; int dp [ N ] ; bool vis [ N ] ; int dfs ( vector < vector < int > > & g , int * cost , int u , int pre ) { vis [ u ] = true ; dp [ u ] = cost [ u ] ; bool check = 1 ; int cur = cost [ u ] ; for ( auto & x : g [ u ] ) { if ( vis [ x ] && x != pre ) { check = 0 ; } else if ( ! vis [ x ] ) { check &= dfs ( g , cost , x , u ) ; cur = max ( cur , cost [ u ] + dp [ x ] ) ; } } dp [ u ] = cur ; if ( ! check ) { can@@ Take += cost [ u ] ; } else { best = max ( best , dp [ u ] ) ; } return check ; } int Find@@ Max@@ Cost ( vector < vector < int > > & g , int * cost , int source ) { dfs ( g , cost , source , -1 ) ; cout << can@@ Take + best ; } int main ( ) { int n = 5 , m = 5 ; int cost [ ] = { 2 , 2 , 8 , 6 , 9 } ; vector < vector < int > > g ( n ) ; g [ 0 ] . push_back ( 1 ) ; g [ 1 ] . push_back ( 0 ) ; g [ 0 ] . push_back ( 2 ) ; g [ 2 ] . push_back ( 0 ) ; g [ 0 ] . push_back ( 3 ) ; g [ 3 ] . push_back ( 0 ) ; g [ 1 ] . push_back ( 2 ) ; g [ 2 ] . push_back ( 1 ) ; g [ 1 ] . push_back ( 4 ) ; g [ 4 ] . push_back ( 1 ) ; int source = 1 ; Find@@ Max@@ Cost ( g , cost , source ) ; return 0 ; }
Minimum number of points required to cover all blocks of a 2 5455 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int min@@ Points ( int n , int m ) { int ans = 0 ; if ( ( n % 2 != 0 ) && ( m % 2 != 0 ) ) { ans = ( ( n * m ) / 2 ) + 1 ; } else { ans = ( n * m ) / 2 ; } return ans ; } int main ( ) { int N = 5 , M = 7 ; cout << min@@ Points ( N , M ) ; return 0 ; }
Create an array of size N with sum S such that no sub@@ array exists with sum S or S 5463 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void create@@ Array ( int n , int s ) { if ( 2 * n <= s ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { cout << "2" << " ▁ " ; s -= 2 ; } cout << s << endl ; cout << "1" << endl ; } else cout << " - 1" << endl ; } int main ( ) { int N = 1 ; int S = 4 ; create@@ Array ( N , S ) ; }
Sub@@ array with largest sum after excluding its maximum element 5487 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void maximum@@ Sum@@ Sub@@ array ( int arr [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= 0 && mp . find ( arr [ i ] ) == mp . end ( ) ) mp [ arr [ i ] ] = 1 ; } int first = 0 ; int last = 0 ; int ans = 0 ; int INF = 1e6 ; for ( auto i : mp ) { int mx = i . first ; int curr = 0 ; int curr_@@ start ; for ( int j = 0 ; j < n ; j ++ ) { if ( curr == 0 ) curr_@@ start = j ; int val = arr [ j ] > mx ? - INF : arr [ j ] ; curr += val ; if ( curr < 0 ) curr = 0 ; if ( curr > ans ) { ans = curr ; first = curr_@@ start ; last = j ; } } } cout << first + 1 << " ▁ " << last + 1 ; } int main ( ) { int arr [ ] = { 5 , -2 , 10 , -1 , 4 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; maximum@@ Sum@@ Sub@@ array ( arr , size ) ; return 0 ; }
Minimum number of sw@@ aps required to make the string K periodic 5496 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int min@@ Flip ( string s , int n , int k , char a [ ] , int p ) { bool allowed [ 26 ] = { 0 } ; for ( int i = 0 ; i < p ; i ++ ) { allowed [ a [ i ] - ' a ' ] = true ; } char freq [ k ] [ 26 ] ; for ( int i = 0 ; i < k ; i ++ ) for ( int j = 0 ; j < 26 ; j ++ ) freq [ i ] [ j ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq [ i % k ] [ s [ i ] - ' a ' ] += 1 ; } int ans = 0 ; int total@@ positions = n / k ; for ( int i = 0 ; i < k ; i ++ ) { int max@@ frequency = 0 ; for ( int j = 0 ; j < 26 ; j ++ ) { if ( freq [ i ] [ j ] > max@@ frequency and allowed [ j ] == true ) max@@ frequency = freq [ i ] [ j ] ; } ans += ( total@@ positions - max@@ frequency + ( ( i % k < n % k ) ? 1 : 0 ) ) ; } cout << ans << endl ; } int main ( ) { string S = " ni@@ h@@ si@@ ak@@ yt " ; int n = S . length ( ) ; int K = 3 ; char A [ 5 ] = { ' n ' , ' i ' , ' p ' , ' s ' , ' q ' } ; int p = sizeof ( A ) / sizeof ( A [ 0 ] ) ; min@@ Flip ( S , n , K , A , p ) ; return 0 ; }
Split N powers of 2 into two subsets such that their difference of sum is minimum 5508 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void Min@@ Diff ( int n ) { int val = pow ( 2 , n ) ; int sep = n / 2 ; int gr@@ p1 = 0 ; int gr@@ p2 = 0 ; gr@@ p1 = gr@@ p1 + val ; for ( int i = 1 ; i < sep ; i ++ ) gr@@ p1 = gr@@ p1 + pow ( 2 , i ) ; for ( int i = sep ; i < n ; i ++ ) gr@@ p2 = gr@@ p2 + pow ( 2 , i ) ; cout << ( abs ( gr@@ p1 - gr@@ p2 ) ) ; } int main ( ) { int n = 4 ; Min@@ Diff ( n ) ; }
Find the minimum value of the given expression over all pairs of the array 5522 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int Minimum@@ Value ( int a [ ] , int n ) { int answer = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { answer = min ( answer , ( ( a [ i ] & a [ j ] ) ^ ( a [ i ] a [ j ] ) ) ) ; } } return answer ; } int main ( ) { int N = 6 ; int A [ N ] = { 12 , 3 , 14 , 5 , 9 , 8 } ; cout << Minimum@@ Value ( A , N ) ; return 0 ; }
Number of sub@@ strings with length di@@ visible by the number of 1 '@@ s in it 5524 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Of@@ Sub@@ strings ( string s ) { int n = s . length ( ) ; int prefix_@@ sum [ n ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) prefix_@@ sum [ i ] = 1 ; } for ( int i = 1 ; i < n ; i ++ ) prefix_@@ sum [ i ] += prefix_@@ sum [ i - 1 ] ; int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int count@@ Of@@ Ones = prefix_@@ sum [ j ] - ( i - 1 >= 0 ? prefix_@@ sum [ i - 1 ] : 0 ) ; int length = j - i + 1 ; if ( count@@ Of@@ Ones > 0 && length % count@@ Of@@ Ones == 0 ) answer ++ ; } } return answer ; } int main ( ) { string S = "@@ 1111@@ 10000@@ 0" ; cout << count@@ Of@@ Sub@@ strings ( S ) ; return 0 ; }
Find the size of largest group where groups are according to the xor of digits 5529 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int dig@@ it_@@ xor ( int x ) { int xor@@ r = 0 ; while ( x ) { xor@@ r ^= x % 10 ; x = x / 10 ; } return xor@@ r ; } int find_@@ count ( int n ) { map < int , int > mp@@ p ; for ( int i = 1 ; i <= n ; i ++ ) { mp@@ p [ dig@@ it_@@ xor ( i ) ] += 1 ; } int max@@ m = 0 ; for ( auto x : mp@@ p ) { if ( x . second > max@@ m ) max@@ m = x . second ; } return max@@ m ; } int main ( ) { int N = 13 ; cout << find_@@ count ( N ) ; return 0 ; }
Transform N to Minimum possible value 5546 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int min_@@ val = INT_MAX ; int min_@@ steps = 0 ; int sum@@ Of@@ Digits ( int n ) { string s = to_string ( n ) ; int sum = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { sum += ( s [ i ] - '0' ) ; } return sum ; } void Transform ( int n , int d , int steps ) { if ( n < min_@@ val ) { min_@@ val = n ; min_@@ steps = steps ; } else if ( n == min_@@ val ) { min_@@ steps = min ( min_@@ steps , steps ) ; } if ( steps < 15 ) { Transform ( sum@@ Of@@ Digits ( n ) , d , steps + 1 ) ; Transform ( n + d , d , steps + 1 ) ; } } int main ( ) { int N = 9 , D = 3 ; Transform ( N , D , 0 ) ; cout << min_@@ val << " ▁ " << min_@@ steps ; return 0 ; }
Sum of all numbers in the given range which are di@@ visible by M 5552 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int sum@@ Di@@ visi@@ bles ( int A , int B , int M ) { int sum = 0 ; for ( int i = A ; i <= B ; i ++ ) if ( i % M == 0 ) sum += i ; return sum ; } int main ( ) { int A = 6 , B = 15 , M = 3 ; cout << sum@@ Di@@ visi@@ bles ( A , B , M ) << endl ; return 0 ; }
Number of pairs such that their H@@ CF and LC@@ M is equal 5560 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Pairs ( int a [ ] , int n ) { unordered_map < int , int > frequency ; for ( int i = 0 ; i < n ; i ++ ) { frequency [ a [ i ] ] ++ ; } int count = 0 ; for ( auto x : frequency ) { int f = x . second ; count += f * ( f - 1 ) / 2 ; } return count ; } int main ( ) { int arr [ ] = { 1 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << count@@ Pairs ( arr , n ) ; return 0 ; }
Maxim@@ ize the number by fli@@ pping at most K bits 5585 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void dec@@ Binary ( int arr [ ] , int n ) { int k = log2 ( n ) ; while ( n > 0 ) { arr [ k -- ] = n % 2 ; n /= 2 ; } } int binary@@ Dec ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += arr [ i ] << ( n - i - 1 ) ; return ans ; } int max@@ Num ( int n , int k ) { int l = log2 ( n ) + 1 ; int a [ l ] = { 0 } ; dec@@ Binary ( a , n ) ; int cn = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( a [ i ] == 0 && cn < k ) { a [ i ] = 1 ; cn ++ ; } } return binary@@ Dec ( a , l ) ; } int main ( ) { int n = 4 , k = 1 ; cout << max@@ Num ( n , k ) ; return 0 ; }
Find the most valued alphabet in the String 5594 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; const int MAX = 26 ; char max@@ Alpha ( string str , int len ) { int first [ MAX ] , last [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { first [ i ] = -1 ; last [ i ] = -1 ; } for ( int i = 0 ; i < len ; i ++ ) { int index = ( str [ i ] - ' a ' ) ; if ( first [ index ] == -1 ) first [ index ] = i ; last [ index ] = i ; } int ans = -1 , maxVal = -1 ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( first [ i ] == -1 ) continue ; if ( ( last [ i ] - first [ i ] ) > maxVal ) { maxVal = last [ i ] - first [ i ] ; ans = i ; } } return ( char ) ( ans + ' a ' ) ; } int main ( ) { string str = " ab@@ bb@@ a " ; int len = str . length ( ) ; cout << max@@ Alpha ( str , len ) ; return 0 ; }
Count the pairs of vo@@ w@@ els in the given string 5644 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Vo@@ wel ( char ch ) { switch ( ch ) { case ' a ' : case ' e ' : case ' i ' : case ' o ' : case ' u ' : return true ; default : return false ; } } int vo@@ wel@@ Pairs ( string s , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( is@@ Vo@@ wel ( s [ i ] ) && is@@ Vo@@ wel ( s [ i + 1 ] ) ) cnt ++ ; } return cnt ; } int main ( ) { string s = " ab@@ a@@ eb@@ io " ; int n = s . length ( ) ; cout << vo@@ wel@@ Pairs ( s , n ) ; return 0 ; }
Minimum elements to be removed such that sum of adjacent elements is always odd 5680 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int min_@@ elimin@@ ation ( int n , int arr [ ] ) { int count = 0 ; int prev_@@ val = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { int curr_@@ val = arr [ i ] ; if ( curr_@@ val % 2 == prev_@@ val % 2 ) count ++ ; prev_@@ val = curr_@@ val ; } return count ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 7 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << min_@@ elimin@@ ation ( n , arr ) ; return 0 ; }
Check if a cell can be visited more than once in a String 5738 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool check@@ If@@ Overlap ( string str ) { int len = str . length ( ) ; int visited [ len + 1 ] = { 0 } ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == ' . ' ) continue ; for ( int j = max ( 0 , i - str [ i ] ) ; j <= min ( len , i + str [ i ] ) ; j ++ ) visited [ j ] ++ ; } for ( int i = 0 ; i < len ; i ++ ) { if ( visited [ i ] > 1 ) { return true ; } } return false ; } int main ( ) { string str = " . 2 . . 2 . " ; if ( check@@ If@@ Overlap ( str ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
Check if a number has digits in the given Order 5740 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Correct@@ Order ( int n ) { bool flag = true ; int prev = -1 ; int type = -1 ; while ( n != 0 ) { if ( type == -1 ) { if ( prev == -1 ) { prev = n % 10 ; n = n / 10 ; continue ; } if ( prev == n % 10 ) { flag = false ; break ; } if ( prev > n % 10 ) { type = 1 ; prev = n % 10 ; n = n / 10 ; continue ; } prev = n % 10 ; n = n / 10 ; } else { if ( prev == n % 10 ) { flag = false ; break ; } if ( prev < n % 10 ) { flag = false ; break ; } prev = n % 10 ; n = n / 10 ; } } return flag ; } int main ( ) { int n = 12345@@ 432@@ 1 ; if ( is@@ Correct@@ Order ( n ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
Pri@@ m '@@ s Algorithm (@@ Simple Implementation for Adjac@@ ency Matrix Representation@@ ) 5749 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define V 5 NEW_LINE bool isValid@@ Edge ( int u , int v , vector < bool > in@@ M@@ ST ) { if ( u == v ) return false ; if ( in@@ M@@ ST [ u ] == false && in@@ M@@ ST [ v ] == false ) return false ; else if ( in@@ M@@ ST [ u ] == true && in@@ M@@ ST [ v ] == true ) return false ; return true ; } void prim@@ M@@ ST ( int cost [ ] [ V ] ) { vector < bool > in@@ M@@ ST ( V , false ) ; in@@ M@@ ST [ 0 ] = true ; int edge@@ _count = 0 , min@@ cost = 0 ; while ( edge@@ _count < V - 1 ) { int min = INT_MAX , a = -1 , b = -1 ; for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { if ( cost [ i ] [ j ] < min ) { if ( isValid@@ Edge ( i , j , in@@ M@@ ST ) ) { min = cost [ i ] [ j ] ; a = i ; b = j ; } } } } if ( a != -1 && b != -1 ) { printf ( " Edge ▁ % d : ( % d , ▁ % d ) ▁ cost : ▁ % d ▁ STRNEWLINE " , edge@@ _count ++ , a , b , min ) ; min@@ cost = min@@ cost + min ; in@@ M@@ ST [ b ] = in@@ M@@ ST [ a ] = true ; } } printf ( " Minimum cost = % d " , min@@ cost ) ; } int main ( ) { int cost [ ] [ V ] = { { INT_MAX , 2 , INT_MAX , 6 , INT_MAX } , { 2 , INT_MAX , 3 , 8 , 5 } , { INT_MAX , 3 , INT_MAX , INT_MAX , 7 } , { 6 , 8 , INT_MAX , INT_MAX , 9 } , { INT_MAX , 5 , 7 , 9 , INT_MAX } , } ; prim@@ M@@ ST ( cost ) ; return 0 ; }
Minimum number of operations to convert a given sequence into a Geo@@ metric Prog@@ ression 5761 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void construct ( int n , pair < double , double > an@@ s_@@ pair ) { if ( an@@ s_@@ pair . first == -1 ) { cout << " Not ▁ possible " ; return ; } double a1 = an@@ s_@@ pair . first ; double a2 = an@@ s_@@ pair . second ; double r = a2 / a1 ; cout << " The ▁ result@@ ant ▁ sequence ▁ is : STRNEWLINE " ; for ( int i = 1 ; i <= n ; i ++ ) { double ai = a1 * pow ( r , i - 1 ) ; cout << ai << " ▁ " ; } } void find@@ Minimum@@ Operations ( double * a , int n ) { int ans = INT_MAX ; int c [ ] = { -1 , 0 , 1 } ; int possi@@ bilities = 3 ; int pos1 = -1 , pos2 = -1 ; for ( int i = 0 ; i < possi@@ bilities ; i ++ ) { for ( int j = 0 ; j < possi@@ bilities ; j ++ ) { double a1 = a [ 1 ] + c [ i ] ; double a2 = a [ 2 ] + c [ j ] ; int temp = abs ( a1 - a [ 1 ] ) + abs ( a2 - a [ 2 ] ) ; if ( a1 == 0 a2 == 0 ) continue ; double r = a2 / a1 ; for ( int pos = 3 ; pos <= n ; pos ++ ) { double ai = a1 * pow ( r , pos - 1 ) ; if ( a [ pos ] == ai ) { continue ; } else if ( a [ pos ] + 1 == ai a [ pos ] - 1 == ai ) { temp ++ ; } else { temp = INT_MAX ; break ; } } if ( temp < ans ) { ans = temp ; pos1 = a1 ; pos2 = a2 ; } } } if ( ans == -1 ) { cout << " - 1" ; return ; } cout << " Minimum ▁ Number ▁ of ▁ Operations ▁ are ▁ " << ans << " STRNEWLINE " ; pair < double , double > an@@ s_@@ pair = { pos1 , pos2 } ; construct ( n , an@@ s_@@ pair ) ; } int main ( ) { double a [ ] = { 0 , 7 , 20 , 49 , 125 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; find@@ Minimum@@ Operations ( a , n - 1 ) ; return 0 ; }
Minimum number of adjacent sw@@ aps for arr@@ anging similar elements together 5762 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Minimum@@ Adjac@@ ent@@ Sw@@ aps ( int arr [ ] , int N ) { bool visited [ N + 1 ] ; int minimum@@ Sw@@ aps = 0 ; memset ( visited , false , sizeof ( visited ) ) ; for ( int i = 0 ; i < 2 * N ; i ++ ) { if ( visited [ arr [ i ] ] == false ) { visited [ arr [ i ] ] = true ; int count = 0 ; for ( int j = i + 1 ; j < 2 * N ; j ++ ) { if ( visited [ arr [ j ] ] == false ) count ++ ; else if ( arr [ i ] == arr [ j ] ) minimum@@ Sw@@ aps += count ; } } } return minimum@@ Sw@@ aps ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 3 , 1 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; N /= 2 ; cout << find@@ Minimum@@ Adjac@@ ent@@ Sw@@ aps ( arr , N ) << endl ; return 0 ; }
Minimum operations to make GC@@ D of array a multiple of k 5768 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int Min@@ Operation ( int a [ ] , int n , int k ) { int result = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( a [ i ] != 1 && a [ i ] > k ) { result = result + min ( a [ i ] % k , k - a [ i ] % k ) ; } else { result = result + k - a [ i ] ; } } return result ; } int main ( ) { int arr [ ] = { 4 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 5 ; cout << Min@@ Operation ( arr , n , k ) ; return 0 ; }
Divide 1 to n into two groups with minimum sum difference 5779 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ Vector ( vector < int > v ) { cout << v . size ( ) << endl ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) cout << v [ i ] << " ▁ " ; cout << endl ; } void find@@ Two@@ Group ( int n ) { int sum = n * ( n + 1 ) / 2 ; int group@@ 1@@ Sum = sum / 2 ; vector < int > group1 , group2 ; for ( int i = n ; i > 0 ; i -- ) { if ( group@@ 1@@ Sum - i >= 0 ) { group1 . push_back ( i ) ; group@@ 1@@ Sum -= i ; } else { group2 . push_back ( i ) ; } } print@@ Vector ( group1 ) ; print@@ Vector ( group2 ) ; } int main ( ) { int n = 5 ; find@@ Two@@ Group ( n ) ; return 0 ; }
Minimum Sw@@ aps for Bracket Balan@@ cing 5797 | #@@ include <@@ io@@ stream@@ > NEW_LINE #@@ include <@@ vector@@ > NEW_LINE #@@ include <@@ algorithm@@ > NEW_LINE using namespace std ; long swap@@ Count ( string s ) { vector < int > pos ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) if ( s [ i ] == ' [ ' ) pos . push_back ( i ) ; int count = 0 ; int p = 0 ; long sum = 0 ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { if ( s [ i ] == ' [ ' ) { ++ count ; ++ p ; } else if ( s [ i ] == ' ] ' ) -- count ; if ( count < 0 ) { sum += pos [ p ] - i ; swap ( s [ i ] , s [ pos [ p ] ] ) ; ++ p ; count = 1 ; } } return sum ; } int main ( ) { string s = " [ ] ] [ ] [ " ; cout << swap@@ Count ( s ) << " STRNEWLINE " ; s = " [ [ ] [ ] ] " ; cout << swap@@ Count ( s ) << " STRNEWLINE " ; return 0 ; }
Count N 5879 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; const int mod = 1e@@ 9 + 7 ; void count@@ Of@@ Numbers ( int N ) { int ans = 1 ; for ( int index = 1 ; index <= N ; ++ index ) { int choices = 0 ; for ( int digit = 1 ; digit <= 9 ; ++ digit ) { if ( index % digit == 0 ) { ++ choices ; } } ans = ( ans * 1@@ LL * choices ) % mod ; } cout << ans << endl ; } int main ( ) { int N = 5 ; count@@ Of@@ Numbers ( N ) ; return 0 ; }
Maximum number of groups that can receive fresh don@@ u@@ ts distributed in batches of size K 5882 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int dfs ( int arr [ ] , int left , int K ) { int q = 0 ; if ( left == 0 ) { for ( int i = 1 ; i < K ; ++ i ) { if ( arr [ i ] > 0 ) { arr [ i ] -- ; q = max ( q , 1 + dfs ( arr , K - i , K ) ) ; arr [ i ] ++ ; } } } else { for ( int i = 1 ; i < K ; ++ i ) { if ( arr [ i ] > 0 ) { arr [ i ] -- ; int n@@ left = ( i <= left ? left - i : K + left - i ) ; q = max ( q , dfs ( arr , n@@ left , K ) ) ; arr [ i ] ++ ; } } } return q ; } int max@@ Groups ( int K , int arr [ ] , int n ) { int V [ K ] = { 0 } ; for ( int x = 0 ; x < n ; x ++ ) V [ arr [ x ] % K ] ++ ; int ans = V [ 0 ] + dfs ( V , 0 , K ) ; return ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 3 ; cout << max@@ Groups ( K , arr , n ) ; return 0 ; }
Lon@@ gest sub@@ sequence with non negative prefix sum at each position 5889 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void lon@@ gest@@ Sub@@ sequence ( int * arr , int N ) { int dp [ N ] [ N + 1 ] ; memset ( dp , -1 , sizeof dp ) ; for ( int i = 0 ; i < N ; ++ i ) { dp [ i ] [ 0 ] = 0 ; } dp [ 0 ] [ 1 ] = ( arr [ 0 ] >= 0 ? arr [ 0 ] : -1 ) ; for ( int i = 1 ; i < N ; ++ i ) { for ( int j = 1 ; j <= ( i + 1 ) ; ++ j ) { if ( dp [ i - 1 ] [ j ] != -1 ) { dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j ] ) ; } if ( dp [ i - 1 ] [ j - 1 ] >= 0 && dp [ i - 1 ] [ j - 1 ] + arr [ i ] >= 0 ) { dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j - 1 ] + arr [ i ] ) ; } } } int ans = 0 ; for ( int j = 0 ; j <= N ; ++ j ) { if ( dp [ N - 1 ] [ j ] >= 0 ) { ans = j ; } } cout << ans << endl ; } int main ( ) { int arr [ ] = { 4 , -@@ 4 , 1 , -@@ 3 , 1 , -@@ 3 } ; int N = sizeof arr / sizeof arr [ 0 ] ; lon@@ gest@@ Sub@@ sequence ( arr , N ) ; return 0 ; }
Number of ways such that only K bars are visible from the left 5909 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int K@@ visible@@ From@@ Left ( int N , int K ) { if ( N == K ) return 1 ; if ( K == 1 ) { int ans = 1 ; for ( int i = 1 ; i < N ; i ++ ) ans *= i ; return ans ; } return K@@ visible@@ From@@ Left ( N - 1 , K - 1 ) + ( N - 1 ) * K@@ visible@@ From@@ Left ( N - 1 , K ) ; } int main ( ) { int N = 5 , K = 2 ; cout << K@@ visible@@ From@@ Left ( N , K ) << endl ; return 0 ; }
Count ways to select N pairs of candi@@ es of distinct colors ( Dynamic Programming + Bit@@ mask@@ ing ) 5957 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int numOf@@ W@@ ays ( vector < vector < int > > a , int n , int i , set < int > & blue ) { if ( i == n ) return 1 ; int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( a [ i ] [ j ] == 1 && blue . find ( j ) == blue . end ( ) ) { blue . insert ( j ) ; count += numOf@@ W@@ ays ( a , n , i + 1 , blue ) ; blue . erase ( j ) ; } } return count ; } int main ( ) { int n = 3 ; vector < vector < int > > mat = { { 0 , 1 , 1 } , { 1 , 0 , 1 } , { 1 , 1 , 1 } } ; set < int > mp@@ p ; cout << ( numOf@@ W@@ ays ( mat , n , 0 , mp@@ p ) ) ; }
Count all N 5992 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int total@@ Arrays ( int N , int M ) { int end_@@ with_@@ one [ N + 1 ] ; int end_@@ not_@@ with_@@ one [ N + 1 ] ; end_@@ with_@@ one [ 0 ] = 1 ; end_@@ not_@@ with_@@ one [ 0 ] = 0 ; end_@@ with_@@ one [ 1 ] = 0 ; end_@@ not_@@ with_@@ one [ 1 ] = M - 1 ; for ( int i = 2 ; i < N ; i ++ ) { end_@@ with_@@ one [ i ] = end_@@ not_@@ with_@@ one [ i - 1 ] ; end_@@ not_@@ with_@@ one [ i ] = end_@@ with_@@ one [ i - 1 ] * ( M - 1 ) + end_@@ not_@@ with_@@ one [ i - 1 ] * ( M - 2 ) ; } return end_@@ with_@@ one [ N - 1 ] ; } int main ( ) { int N = 3 , M = 3 ; int temp = total@@ Arrays ( N , M ) ; int ans = M * temp ; cout << ans << " STRNEWLINE " ; return 0 ; }
Calculate the value of 2 raised to the power of twice the binary representation of N 5995 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define M 100000000@@ 7 NEW_LINE long long power ( long long X , long long Y ) { long long res = 1 ; X = X % M ; if ( X == 0 ) return 0 ; while ( Y > 0 ) { if ( Y & 1 ) { res = ( res * X ) % M ; } Y = Y >> 1 ; X = ( X * X ) % M ; } return res ; } int find@@ Value ( long long int n ) { long long X = 0 ; long long pow_@@ 10 = 1 ; while ( n ) { if ( n & 1 ) { X += pow_@@ 10 ; } pow_@@ 10 *= 10 ; n /= 2 ; } X = ( X * 2 ) % M ; long long res = power ( 2 , X ) ; return res ; } int main ( ) { long long n = 2 ; cout << find@@ Value ( n ) ; return 0 ; }
Count ways to tile an N 6007 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; long count@@ Way@@ sTo@@ Tile@@ Board ( long N ) { long dp [ N + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 2 ; for ( int i = 2 ; i <= N ; i ++ ) { dp [ i ] = ( 2 * dp [ i - 1 ] + dp [ i - 2 ] ) ; } cout << dp [ N ] ; } int main ( ) { long N = 2 ; count@@ Way@@ sTo@@ Tile@@ Board ( N ) ; return 0 ; }
S@@ malle@@ st sub@@ matrix required to be removed such that sum of the remaining matrix is di@@ visible by K 6022 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int remove@@ S@@ malle@@ st@@ Sub@@ array ( int arr [ ] , int S , int n , int k ) { int target_@@ remainder = S % k ; unordered_map < int , int > map1 ; map1 [ 0 ] = -1 ; int curr_@@ remainder = 0 ; int res = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { curr_@@ remainder = ( curr_@@ remainder + arr [ i ] + k ) % k ; map1 [ curr_@@ remainder ] = i ; int mod = ( curr_@@ remainder - target_@@ remainder + k ) % k ; if ( map1 . find ( mod ) != map1 . end ( ) ) { res = min ( res , i - map1 [ mod ] ) ; } } if ( res == INT_MAX res == n ) { res = -1 ; } return res ; } int sm@@ st@@ Sub@@ mat@@ Deleted ( vector < vector < int > > & mat , int N , int M , int K ) { int S = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) S += mat [ i ] [ j ] ; } int min_@@ area = N * M ; int left = 0 ; int right = 0 ; int width ; int area ; int prefix@@ Row@@ Sum [ N ] ; for ( left = 0 ; left < M ; left ++ ) { memset ( prefix@@ Row@@ Sum , 0 , sizeof ( prefix@@ Row@@ Sum ) ) ; for ( right = left ; right < M ; right ++ ) { for ( int i = 0 ; i < N ; i ++ ) { prefix@@ Row@@ Sum [ i ] += mat [ i ] [ right ] ; } width = remove@@ S@@ malle@@ st@@ Sub@@ array ( prefix@@ Row@@ Sum , S , N , K ) ; if ( width != -1 ) { area = ( right - left + 1 ) * ( width ) ; if ( area < min_@@ area ) { min_@@ area = area ; } } } } return min_@@ area ; } int main ( ) { vector < vector < int > > mat = { { 6 , 2 , 6 } , { 3 , 2 , 8 } , { 2 , 5 , 3 } } ; int K = 3 ; int N = mat . size ( ) ; int M = mat [ 0 ] . size ( ) ; cout << sm@@ st@@ Sub@@ mat@@ Deleted ( mat , N , M , K ) ; return 0 ; }
S@@ malle@@ st sub@@ matrix required to be removed such that sum of the remaining matrix is di@@ visible by K 6023 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int count@@ strings ( int n , int start ) { if ( n == 0 ) { return 1 ; } int cnt = 0 ; for ( int i = start ; i < 5 ; i ++ ) { cnt += count@@ strings ( n - 1 , i ) ; } return cnt ; } int count@@ Vo@@ wel@@ Strings ( int n ) { return count@@ strings ( n , 0 ) ; } int main ( ) { int n = 2 ; cout << count@@ Vo@@ wel@@ Strings ( n ) ; return 0 ; }
S@@ malle@@ st sub@@ matrix required to be removed such that sum of the remaining matrix is di@@ visible by K 6026 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ NumberOf@@ Strings ( int n ) { return ( n + 1 ) * ( n + 2 ) * ( n + 3 ) * ( n + 4 ) / 24 ; } int main ( ) { int N = 2 ; cout << find@@ NumberOf@@ Strings ( N ) ; return 0 ; }
Count unique paths with given sum in an N 6030 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE #@@ define ll long long NEW_LINE using namespace std ; const int mod = ( int ) 1e@@ 9 + 7 ; ll find@@ Total@@ Path ( int X , int n , vector < int > & dp ) { if ( X == 0 ) { return 1 ; } ll ans = 0 ; if ( dp [ X ] != -1 ) { return dp [ X ] ; } for ( int i = 1 ; i <= min ( X , n ) ; ++ i ) { ans += find@@ Total@@ Path ( X - i , n , dp ) % mod ; ans %= mod ; } return dp [ X ] = ans ; } int main ( ) { int n = 3 , X = 2 ; vector < int > dp ( X + 1 , -1 ) ; cout << find@@ Total@@ Path ( X , n , dp ) ; }
Maximum sub@@ sequence sum obtained by concaten@@ ating disjoint sub@@ arrays whose lengths are prime 6041 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define MAX 10000@@ 5 NEW_LINE vector < int > Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( ) { bool se@@ ive [ MAX ] ; memset ( se@@ ive , true , sizeof ( se@@ ive ) ) ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( se@@ ive [ p ] == true ) { for ( int i = p * p ; i < MAX ; i += p ) { se@@ ive [ i ] = false ; } } } vector < int > v ; for ( int p = 2 ; p < MAX ; p ++ ) { if ( se@@ ive [ p ] ) { v . push_back ( p ) ; } } return v ; } void build ( int dp [ ] , int arr [ ] , int N ) { dp [ 0 ] = 0 ; dp [ 1 ] = 0 ; vector < int > prime = Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( ) ; int pref [ N + 1 ] ; pref [ 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { pref [ i ] = pref [ i - 1 ] + arr [ i - 1 ] ; } for ( int i = 2 ; i <= N ; i ++ ) { dp [ i ] = dp [ i - 1 ] ; for ( int j = 0 ; j <= prime . size ( ) ; j ++ ) { int r = i - 1 ; int l = r - prime [ j ] + 1 ; if ( l < 0 ) break ; int temp = 0 ; temp = pref [ r + 1 ] - pref [ l ] ; if ( l - 2 >= 0 ) temp += dp [ l - 2 + 1 ] ; dp [ i ] = max ( dp [ i ] , temp ) ; } } } void max@@ Sum@@ Sub@@ seq ( int arr [ ] , int N ) { int dp [ N + 1 ] ; build ( dp , arr , N ) ; cout << dp [ N ] ; } int main ( ) { int arr [ ] = { 10 , 10 , 7 , 10 , 10 , 10 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; max@@ Sum@@ Sub@@ seq ( arr , N ) ; return 0 ; }
Count possible permutations of given array satis@@ fying the given conditions 6057 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int bin@@ Co@@ ff ( int N , int R ) { int res = 1 ; if ( R > ( N - R ) ) { R = ( N - R ) ; } for ( int i = 0 ; i < R ; i ++ ) { res *= ( N - i ) ; res /= ( i + 1 ) ; } return res ; } int cnt@@ Permutation ( int N ) { int cnt@@ Perm ; int C_@@ 2@@ N_@@ N = bin@@ Co@@ ff ( 2 * N , N ) ; cnt@@ Perm = C_@@ 2@@ N_@@ N / ( N + 1 ) ; return cnt@@ Perm ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << cnt@@ Permutation ( N / 2 ) ; return 0 ; }
Check if an array can be split into 3 sub@@ sequences of equal sum or not 6082 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int check@@ Equal@@ Sum@@ Util ( int arr [ ] , int N , int sm@@ 1 , int sm@@ 2 , int sm@@ 3 , int j ) { if ( j == N ) { if ( sm@@ 1 == sm@@ 2 && sm@@ 2 == sm@@ 3 ) return 1 ; else return 0 ; } else { int l = check@@ Equal@@ Sum@@ Util ( arr , N , sm@@ 1 + arr [ j ] , sm@@ 2 , sm@@ 3 , j + 1 ) ; int m = check@@ Equal@@ Sum@@ Util ( arr , N , sm@@ 1 , sm@@ 2 + arr [ j ] , sm@@ 3 , j + 1 ) ; int r = check@@ Equal@@ Sum@@ Util ( arr , N , sm@@ 1 , sm@@ 2 , sm@@ 3 + arr [ j ] , j + 1 ) ; return max ( max ( l , m ) , r ) ; } } void check@@ Equal@@ Sum ( int arr [ ] , int N ) { int sum@@ 1 , sum@@ 2 , sum@@ 3 ; sum@@ 1 = sum@@ 2 = sum@@ 3 = 0 ; if ( check@@ Equal@@ Sum@@ Util ( arr , N , sum@@ 1 , sum@@ 2 , sum@@ 3 , 0 ) == 1 ) { cout << " Yes " ; } else { cout << " No " ; } } int main ( ) { int arr [ ] = { 17 , 34 , 59 , 23 , 17 , 67 , 57 , 2 , 18 , 59 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; check@@ Equal@@ Sum ( arr , N ) ; return 0 ; }
Print the Maximum Sub@@ array Sum 6106 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void Sub@@ array@@ With@@ Max@@ Sum ( vector < int > & nums ) { int endIndex , curr@@ Max = nums [ 0 ] ; int global@@ Max = nums [ 0 ] ; for ( int i = 1 ; i < nums . size ( ) ; ++ i ) { curr@@ Max = max ( nums [ i ] , nums [ i ] + curr@@ Max ) ; if ( curr@@ Max > global@@ Max ) { global@@ Max = curr@@ Max ; endIndex = i ; } } int startIndex = endIndex ; while ( startIndex >= 0 ) { global@@ Max -= nums [ startIndex ] ; if ( global@@ Max == 0 ) break ; startIndex -- ; } for ( int i = startIndex ; i <= endIndex ; ++ i ) { cout << nums [ i ] << " ▁ " ; } } int main ( ) { vector < int > arr = { -2 , -@@ 5 , 6 , -2 , -@@ 3 , 1 , 5 , -@@ 6 } ; Sub@@ array@@ With@@ Max@@ Sum ( arr ) ; return 0 ; }
Reverse a sub@@ array to maxim@@ ize sum of even 6126 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int maxim@@ ize@@ Sum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i = i + 2 ) sum += arr [ i ] ; int left@@ DP [ n / 2 ] ; int right@@ DP [ n / 2 ] ; int c = 0 ; for ( int i = 1 ; i < n ; i = i + 2 ) { int left@@ Diff = arr [ i ] - arr [ i - 1 ] ; if ( c - 1 < 0 ) left@@ DP = left@@ Diff ; else { if ( left@@ DP > 0 ) left@@ DP = left@@ Diff + left@@ DP ; else left@@ DP [ i ] = left@@ Diff ; } int right@@ Diff ; if ( i + 1 >= n ) right@@ Diff = 0 ; else right@@ Diff = arr [ i ] - arr [ i + 1 ] ; if ( c - 1 < 0 ) right@@ DP = right@@ Diff ; else { if ( right@@ DP > 0 ) right@@ DP = right@@ Diff + right@@ DP ; else right@@ DP = right@@ Diff ; } c ++ ; } int max@@ i = 0 ; for ( int i = 0 ; i < n / 2 ; i ++ ) { max@@ i = max ( max@@ i , max ( left@@ DP [ i ] , right@@ DP [ i ] ) ) ; } return max@@ i + sum ; } int main ( ) { int arr [ ] = { 7 , 8 , 4 , 5 , 7 , 6 , 8 , 9 , 7 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int ans = maxim@@ ize@@ Sum ( arr , n ) ; cout << ( ans ) ; }
Count of all sub@@ sequences having adjacent elements with different parity 6129 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int valid@@ sub@@ sequences ( int arr [ ] , int n ) { long long int dp [ n + 1 ] [ 2 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { dp [ i ] [ 0 ] = 0 ; dp [ i ] [ 1 ] = 0 ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( arr [ i - 1 ] % 2 ) { dp [ i ] [ 1 ] += 1 ; dp [ i ] [ 1 ] += dp [ i - 1 ] [ 0 ] ; dp [ i ] [ 1 ] += dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 0 ] += dp [ i - 1 ] [ 0 ] ; } else { dp [ i ] [ 0 ] += 1 ; dp [ i ] [ 0 ] += dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 0 ] += dp [ i - 1 ] [ 0 ] ; dp [ i ] [ 1 ] += dp [ i - 1 ] [ 1 ] ; } } return dp [ n ] [ 0 ] + dp [ n ] [ 1 ] ; } int main ( ) { int arr [ ] = { 5 , 6 , 9 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << valid@@ sub@@ sequences ( arr , n ) ; return 0 ; }
Count of elements having odd number of di@@ visors in index range [ L , R ] for Q queries 6140 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void O@@ dd@@ Di@@ visor@@ sCount ( int n , int q , int a [ ] , vector < pair < int , int > > Query ) { int DP [ n ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { int x = sqrt ( a [ i ] ) ; if ( x * x == a [ i ] ) DP [ i ] = 1 ; } for ( int i = 1 ; i < n ; i ++ ) { DP [ i ] = DP [ i - 1 ] + DP [ i ] ; } int l , r ; for ( int i = 0 ; i < q ; i ++ ) { l = Query [ i ] . first ; r = Query [ i ] . second ; if ( l == 0 ) { cout << DP [ r ] << endl ; } else { cout << DP [ r ] - DP [ l - 1 ] << endl ; } } } int main ( ) { int N = 5 ; int Q = 3 ; int arr [ ] = { 2 , 4 , 5 , 6 , 9 } ; vector < pair < int , int > > Query Query = { { 0 , 2 } , { 1 , 3 } , { 1 , 4 } } ; O@@ dd@@ Di@@ visor@@ sCount ( N , Q , arr , Query ) ; return 0 ; }
Count of sub@@ sequences of length 4 in form ( x , x , x + 1 , x + 1 ) | Set 2 6150 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Stable@@ Num ( string str , int N ) { int count@@ 1 [ N ] [ 10 ] ; int count2 [ N ] [ 10 ] ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < 10 ; j ++ ) count@@ 1 [ i ] [ j ] = count2 [ i ] [ j ] = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i != 0 ) { for ( int j = 0 ; j < 10 ; j ++ ) { count@@ 1 [ i ] [ j ] += count@@ 1 [ i - 1 ] [ j ] ; } } count@@ 1 [ i ] [ str [ i ] - '0' ] ++ ; } for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( i != N - 1 ) { for ( int j = 0 ; j < 10 ; j ++ ) { count2 [ i ] [ j ] += count2 [ i + 1 ] [ j ] ; } } count2 [ i ] [ str [ i ] - '0' ] ++ ; } int ans = 0 ; for ( int i = 1 ; i < N - 1 ; i ++ ) { if ( str [ i ] == '9' ) continue ; int c1 = count@@ 1 [ i - 1 ] [ str [ i ] - '0' ] ; int c2 = count2 [ i + 1 ] [ str [ i ] - '0' + 1 ] ; if ( c2 == 0 ) continue ; ans = ( ans + ( c1 * ( ( c2 * ( c2 - 1 ) / 2 ) ) ) ) ; } return ans ; } int main ( ) { string str = "@@ 224@@ 35@@ 3" ; int N = str . length ( ) ; cout << count@@ Stable@@ Num ( str , N ) ; return 0 ; }
Minimum cost path in a Matrix by moving only on value difference of X 6168 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; const long long MAX = 1e@@ 18 ; long long n , m ; vector < long long > v [ 151 ] ; long long dp [ 151 ] [ 151 ] ; long long min_@@ operation ( long long i , long long j , long long val , long long x ) { if ( i == n - 1 && j == m - 1 ) { if ( val > v [ i ] [ j ] ) { return dp [ i ] [ j ] = MAX ; } else { return dp [ i ] [ j ] = v [ i ] [ j ] - val ; } } if ( i == n j == m ) { return dp [ i ] [ j ] = MAX ; } if ( dp [ i ] [ j ] != -1 ) { return dp [ i ] [ j ] ; } if ( val > v [ i ] [ j ] ) { return dp [ i ] [ j ] = MAX ; } long long tmp = v [ i ] [ j ] - val ; tmp += min ( min_@@ operation ( i + 1 , j , val + x , x ) , min_@@ operation ( i , j + 1 , val + x , x ) ) ; return dp [ i ] [ j ] = tmp ; } long long solve ( long long x ) { long long ans = INT@@ 64_@@ MAX ; for ( long long i = 0 ; i < n ; i ++ ) { for ( long long j = 0 ; j < m ; j ++ ) { long long val = v [ i ] [ j ] - x * ( i + j ) ; memset ( dp , -1 , sizeof ( dp ) ) ; val = min_@@ operation ( 0 , 0 , val , x ) ; ans = min ( ans , val ) ; } } return ans ; } int main ( ) { n = 2 , m = 2 ; long long x = 3 ; v [ 0 ] = { 15 , 153 } ; v [ 1 ] = { 135 , 17 } ; cout << solve ( x ) << endl ; return 0 ; }
Count numbers in a range with digit sum di@@ visible by K having first and last digit different 6190 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define ll long long int NEW_LINE ll K ; ll N ; vector < int > v ; ll dp [ 20 ] [ 1000 ] [ 10 ] [ 2 ] [ 2 ] ; void init ( ll x ) { memset ( dp , -1 , sizeof ( dp ) ) ; v . clear ( ) ; while ( x > 0 ) { v . push_back ( x % 10 ) ; x /= 10 ; } reverse ( v . begin ( ) , v . end ( ) ) ; N = v . size ( ) ; } ll fun ( ll pos , ll sum , ll st , ll check , ll f ) { if ( pos == N ) { return ( sum == 0 and check == 1 ) ; } if ( dp [ pos ] [ sum ] [ st ] [ check ] [ f ] != -1 ) return dp [ pos ] [ sum ] [ st ] [ check ] [ f ] ; ll l@@ mt = 9 ; if ( ! f ) l@@ mt = v [ pos ] ; ll ans = 0 ; for ( int digit = 0 ; digit <= l@@ mt ; digit ++ ) { ll nf = f ; ll new_@@ sum = ( sum + digit ) % K ; ll new_@@ check = check ; ll new_@@ st = st ; if ( f == 0 and digit < l@@ mt ) nf = 1 ; if ( check == 0 and digit != 0 ) { new_@@ st = digit ; new_@@ check = 1 ; } if ( pos == N - 1 and new_@@ st == digit ) continue ; ans += fun ( pos + 1 , new_@@ sum , new_@@ st , new_@@ check , nf ) ; } return dp [ pos ] [ sum ] [ st ] [ check ] [ f ] = ans ; } void find@@ Count ( int L , int R , int K ) { init ( R ) ; ll r_@@ ans = fun ( 0 , 0 , 0 , 0 , 0 ) ; init ( L - 1 ) ; ll l_@@ ans = fun ( 0 , 0 , 0 , 0 , 0 ) ; cout << r_@@ ans - l_@@ ans ; } int main ( ) { ll L = 10 ; ll R = 20 ; K = 2 ; find@@ Count ( L , R , K ) ; return 0 ; }
Count of sub@@ arrays having exactly K perfect square numbers 6205 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Per@@ fec@@ t@@ Square ( long double x ) { long double sr = sqrt ( x ) ; return ( ( sr - floor ( sr ) ) == 0 ) ; } int find@@ Sub@@ array@@ Sum ( int arr [ ] , int n , int K ) { unordered_map < int , int > prev@@ Sum ; int res = 0 ; int curr@@ sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr@@ sum += arr [ i ] ; if ( curr@@ sum == K ) { res ++ ; } if ( prev@@ Sum . find ( curr@@ sum - K ) != prev@@ Sum . end ( ) ) res += ( prev@@ Sum [ curr@@ sum - K ] ) ; prev@@ Sum [ curr@@ sum ] ++ ; } return res ; } void count@@ Sub@@ array ( int arr [ ] , int n , int K ) { for ( int i = 0 ; i < n ; i ++ ) { if ( is@@ Per@@ fec@@ t@@ Square ( arr [ i ] ) ) { arr [ i ] = 1 ; } else { arr [ i ] = 0 ; } } cout << find@@ Sub@@ array@@ Sum ( arr , n , K ) ; } int main ( ) { int arr [ ] = { 2 , 4 , 9 , 2 } ; int K = 2 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; count@@ Sub@@ array ( arr , N , K ) ; return 0 ; }
Count all square sub 6219 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; #@@ define dim 5 NEW_LINE void createTable ( int m@@ trx [ ] [ dim ] , int k , int p , int dp [ ] [ dim ] ) { dp [ 0 ] [ 0 ] = m@@ trx [ 0 ] [ 0 ] ; for ( int j = 1 ; j < dim ; j ++ ) { dp [ 0 ] [ j ] = m@@ trx [ 0 ] [ j ] + dp [ 0 ] [ j - 1 ] ; } for ( int i = 1 ; i < dim ; i ++ ) { dp [ i ] [ 0 ] = m@@ trx [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] ; } for ( int i = 1 ; i < dim ; i ++ ) { for ( int j = 1 ; j < dim ; j ++ ) { dp [ i ] [ j ] = m@@ trx [ i ] [ j ] + dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] - dp [ i - 1 ] [ j - 1 ] ; } } } int count@@ Sub@@ Matrix@@ Util ( int dp [ ] [ dim ] , int k , int p ) { int count = 0 ; int sub@@ Mat@@ Sum = 0 ; for ( int i = k - 1 ; i < dim ; i ++ ) { for ( int j = k - 1 ; j < dim ; j ++ ) { if ( i == ( k - 1 ) || j == ( k - 1 ) ) { if ( i == ( k - 1 ) && j == ( k - 1 ) ) { sub@@ Mat@@ Sum = dp [ i ] [ j ] ; } else if ( i == ( k - 1 ) ) { sub@@ Mat@@ Sum = dp [ i ] [ j ] - dp [ i ] [ j - k ] ; } else { sub@@ Mat@@ Sum = dp [ i ] [ j ] - dp [ i - k ] [ j ] ; } } else { sub@@ Mat@@ Sum = dp [ i ] [ j ] - dp [ i - k ] [ j ] - dp [ i ] [ j - k ] + dp [ i - k ] [ j - k ] ; } if ( sub@@ Mat@@ Sum >= p ) { count ++ ; } } } return count ; } int count@@ Sub@@ Matrix ( int m@@ trx [ ] [ dim ] , int k , int p ) { int dp [ dim ] [ dim ] ; for ( int i = 0 ; i < dim ; i ++ ) { for ( int j = 0 ; j < dim ; j ++ ) { dp [ i ] [ j ] = 0 ; } } createTable ( m@@ trx , k , p , dp ) ; return count@@ Sub@@ Matrix@@ Util ( dp , k , p ) ; } int main ( ) { int m@@ trx [ dim ] [ dim ] = { { 1 , 7 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 , 2 } , { 3 , 9 , 6 , 7 , 3 } , { 4 , 3 , 2 , 4 , 5 } , { 5 , 1 , 5 , 3 , 1 } } ; int k = 3 ; int p = 35 ; cout << count@@ Sub@@ Matrix ( m@@ trx , k , p ) ; return 0 ; }
Number of ways to write N as a sum of K non 6231 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ W@@ ays ( int n , int m ) { int dp [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { dp [ 1 ] [ i ] = 1 ; if ( i != 0 ) { dp [ 1 ] [ i ] += dp [ 1 ] [ i - 1 ] ; } } for ( int i = 2 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( j == 0 ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } else { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; if ( i == m && j == n ) { return dp [ i ] [ j ] ; } dp [ i ] [ j ] += dp [ i ] [ j - 1 ] ; } } } } int main ( ) { int N = 2 , K = 3 ; cout << count@@ W@@ ays ( N , K ) ; return 0 ; }
Count of sub@@ arrays of an Array having all unique digits 6249 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool check ( vector < int > & v ) { set < int > digits ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { set < int > d ; while ( v [ i ] ) { d . insert ( v [ i ] % 10 ) ; v [ i ] /= 10 ; } for ( auto it : d ) { if ( digits . count ( it ) ) return false ; } for ( auto it : d ) digits . insert ( it ) ; } return true ; } int numberOf@@ Sub@@ arrays ( int a [ ] , int n ) { int answer = 0 ; for ( int i = 1 ; i < ( 1 << n ) ; i ++ ) { vector < int > temp ; for ( int j = 0 ; j < n ; j ++ ) { if ( i & ( 1 << j ) ) temp . push_back ( a [ j ] ) ; } if ( check ( temp ) ) answer ++ ; } return answer ; } int main ( ) { int N = 4 ; int A [ ] = { 1 , 12 , 23 , 34 } ; cout << numberOf@@ Sub@@ arrays ( A , N ) ; return 0 ; }
Count maximum occurrence of sub@@ sequence in string such that indices in sub@@ sequence is in A . P . 6267 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int maximum@@ Occurren@@ ce ( string s ) { int n = s . length ( ) ; map < string , int > freq ; for ( int i = 0 ; i < n ; i ++ ) { string temp = " " ; temp += s [ i ] ; freq [ temp ] ++ ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { string temp = " " ; temp += s [ i ] ; temp += s [ j ] ; freq [ temp ] ++ ; } } int answer = INT_@@ MIN ; for ( auto it : freq ) answer = max ( answer , it . second ) ; return answer ; } int main ( ) { string s = " xx@@ xy@@ y " ; cout << maximum@@ Occurren@@ ce ( s ) ; return 0 ; }
Maximum contiguous decre@@ asing sequence obtained by removing any one element 6296 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int maxLength ( int * a , int n ) { int maximum = 1 ; int left [ n ] ; int right [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { left [ i ] = 1 ; right [ i ] = 1 ; } for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( a [ i ] > a [ i + 1 ] ) { right [ i ] = right [ i + 1 ] + 1 ; } maximum = max ( maximum , right [ i ] ) ; } for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] < a [ i - 1 ] ) { left [ i ] = left [ i - 1 ] + 1 ; } } if ( n > 2 ) { for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( a [ i - 1 ] > a [ i + 1 ] ) { maximum = max ( maximum , left [ i - 1 ] + right [ i + 1 ] ) ; } } } return maximum ; } int main ( ) { int arr [ 6 ] = { 8 , 7 , 3 , 5 , 2 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxLength ( arr , n ) << endl ; return 0 ; }
Length of longest Pal@@ ind@@ ro@@ mic Sub@@ sequence of even length with no two adjacent characters same 6304 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define ll@@ i long long int NEW_LINE unordered_map < string , ll@@ i > dp ; ll@@ i solve ( string s , char c ) { if ( s . length ( ) == 1 ) return 0 ; if ( s . length ( ) == 2 ) { if ( s [ 0 ] == s [ 1 ] && s [ 0 ] == c ) return 1 ; else return 0 ; } if ( dp [ s + " ▁ " + c ] ) return dp [ s + " ▁ " + c ] ; ll@@ i ans = 0 ; if ( s [ 0 ] == s [ s . length ( ) - 1 ] && s [ 0 ] == c ) { for ( char c1 = ' a ' ; c1 <= ' z ' ; c1 ++ ) if ( c1 != c ) ans = max ( ans , 1 + solve ( s . substr ( 1 , s . length ( ) - 2 ) , c1 ) ) ; } else { for ( ll@@ i i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == c ) { for ( ll@@ i j = s . length ( ) - 1 ; j > i ; j -- ) if ( s [ j ] == c ) { if ( j == i ) break ; ans = solve ( s . substr ( i , j - i + 1 ) , c ) ; break ; } break ; } } } dp [ s + " ▁ " + c ] = ans ; return dp [ s + " ▁ " + c ] ; } int main ( ) { string s = " ab@@ sc@@ rc@@ db@@ a " ; ll@@ i ma = 0 ; for ( char c1 = ' a ' ; c1 <= ' z ' ; c1 ++ ) ma = max ( ma , solve ( s , c1 ) * 2 ) ; cout << ma << endl ; return 0 ; }
Maximum length of Strict@@ ly Incre@@ asing Sub 6307 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max@@ Inc@@ Sub@@ arr ( int a [ ] , int n ) { int pre [ n ] = { 0 } ; int pos [ n ] = { 0 } ; pre [ 0 ] = 1 ; pos [ n - 1 ] = 1 ; int l = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] > a [ i - 1 ] ) pre [ i ] = pre [ i - 1 ] + 1 ; else pre [ i ] = 1 ; } l = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( a [ i ] < a [ i + 1 ] ) pos [ i ] = pos [ i + 1 ] + 1 ; else pos [ i ] = 1 ; } int ans = 0 ; l = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] > a [ i - 1 ] ) l ++ ; else l = 1 ; ans = max ( ans , l ) ; } for ( int i = 1 ; i <= n - 2 ; i ++ ) { if ( a [ i - 1 ] < a [ i + 1 ] ) ans = max ( pre [ i - 1 ] + pos [ i + 1 ] , ans ) ; } return ans ; } int main ( ) { int arr [ ] = { 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << max@@ Inc@@ Sub@@ arr ( arr , n ) ; return 0 ; }
Lon@@ gest sub@@ sequence with a given OR value : Dynamic Programming Appro@@ ach 6356 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define max@@ N 20 NEW_LINE #@@ define max@@ M 64 NEW_LINE int dp [ max@@ N ] [ max@@ M ] ; bool v [ max@@ N ] [ max@@ M ] ; int find@@ Len ( int * arr , int i , int curr , int n , int m ) { if ( i == n ) { if ( curr == m ) return 0 ; else return -1 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = 1 ; int l = find@@ Len ( arr , i + 1 , curr , n , m ) ; int r = find@@ Len ( arr , i + 1 , curr arr [ i ] , n , m ) ; dp [ i ] [ curr ] = l ; if ( r != -1 ) dp [ i ] [ curr ] = max ( dp [ i ] [ curr ] , r + 1 ) ; return dp [ i ] [ curr ] ; } int main ( ) { int arr [ ] = { 3 , 7 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( int ) ; int m = 3 ; int ans = find@@ Len ( arr , 0 , 0 , n , m ) ; if ( ans == -1 ) cout << 0 ; else cout << ans ; return 0 ; }
Lon@@ gest sub@@ sequence whose sum is di@@ visible by a given number 6358 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define max@@ N 20 NEW_LINE #@@ define max@@ M 64 NEW_LINE int dp [ max@@ N ] [ max@@ M ] ; bool v [ max@@ N ] [ max@@ M ] ; int find@@ Len ( int * arr , int i , int curr , int n , int m ) { if ( i == n ) { if ( ! curr ) return 0 ; else return -1 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = 1 ; int l = find@@ Len ( arr , i + 1 , curr , n , m ) ; int r = find@@ Len ( arr , i + 1 , ( curr + arr [ i ] ) % m , n , m ) ; dp [ i ] [ curr ] = l ; if ( r != -1 ) dp [ i ] [ curr ] = max ( dp [ i ] [ curr ] , r + 1 ) ; return dp [ i ] [ curr ] ; } int main ( ) { int arr [ ] = { 3 , 2 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( int ) ; int m = 3 ; cout << find@@ Len ( arr , 0 , 0 , n , m ) ; return 0 ; }
Divide an array into K sub@@ array with the given condition 6373 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int divi@@ de@@ Array ( int arr [ ] , int n , int k ) { int dp [ 500 ] [ 500 ] = { 0 } ; k -= 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j <= k ; j ++ ) { dp [ i ] [ j ] = INT_MAX ; int max@@ _ = -1 , sum = 0 ; for ( int l = i ; l < n ; l ++ ) { max@@ _ = max ( max@@ _ , arr [ l ] ) ; sum += arr [ l ] ; int diff = ( l - i + 1 ) * max@@ _ - sum ; if ( j > 0 ) dp [ i ] [ j ] = min ( dp [ i ] [ j ] , diff + dp [ l + 1 ] [ j - 1 ] ) ; else dp [ i ] [ j ] = diff ; } } } return dp [ 0 ] [ k ] ; } int main ( ) { int arr [ ] = { 2 , 9 , 5 , 4 , 8 , 3 , 6 } ; int n = sizeof ( arr ) / sizeof ( int ) ; int k = 2 ; cout << divi@@ de@@ Array ( arr , n , k ) << " STRNEWLINE " ; return 0 ; }
Maxim@@ ize the happ@@ iness of the groups on the Trip 6417 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int Max@@ Happ@@ iness ( int A , int N , vector < string > v ) { string str ; int val [ N ] , wt [ N ] , c = 0 ; for ( int i = 0 ; i < N ; i ++ ) { str = v [ i ] ; c = 0 ; for ( int j = 0 ; str [ j ] ; j ++ ) { if ( str [ j ] == ' c ' ) c += 4 ; else if ( str [ j ] == ' w ' ) c += 3 ; else if ( str [ j ] == ' m ' ) c += 2 ; else c ++ ; } c *= str . length ( ) ; val [ i ] = c ; wt [ i ] = str . length ( ) ; } int k [ N + 1 ] [ A + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) { for ( int w = 0 ; w <= A ; w ++ ) { if ( i == 0 w == 0 ) k [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) k [ i ] [ w ] = max ( val [ i - 1 ] + k [ i - 1 ] [ w - wt [ i - 1 ] ] , k [ i - 1 ] [ w ] ) ; else k [ i ] [ w ] = k [ i - 1 ] [ w ] ; } } return k [ N ] [ A ] ; } int main ( ) { int A = 5 ; vector < string > v = { " mmo " , " oo " , " cm@@ w " , " cc " , " c " } ; int N = v . size ( ) ; cout << Max@@ Happ@@ iness ( A , N , v ) ; return 0 ; }
Length of the longest increasing sub@@ sequence such that no two adjacent elements are co@@ prime 6456 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define N 10000@@ 5 NEW_LINE int LI@@ S ( int a [ ] , int n ) { int dp [ N ] , d [ N ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { dp [ a [ i ] ] = 1 ; for ( int j = 2 ; j * j <= a [ i ] ; j ++ ) { if ( a [ i ] % j == 0 ) { dp [ a [ i ] ] = max ( dp [ a [ i ] ] , dp [ d [ j ] ] + 1 ) ; dp [ a [ i ] ] = max ( dp [ a [ i ] ] , dp [ d [ a [ i ] / j ] ] + 1 ) ; d [ j ] = a [ i ] ; d [ a [ i ] / j ] = a [ i ] ; } } ans = max ( ans , dp [ a [ i ] ] ) ; d [ a [ i ] ] = a [ i ] ; } return ans ; } int main ( ) { int a [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << LI@@ S ( a , n ) ; return 0 ; }
Check if it is possible to get back to 12 '0 clock only by adding or subtrac@@ ting given seconds 6503 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool check@@ Combin@@ ations ( int a [ ] , int n ) { int pow_@@ set_size = pow ( 2 , n ) ; int counter , j ; for ( counter = 0 ; counter < pow_@@ set_size ; counter ++ ) { int sum = 0 ; for ( j = 0 ; j < n ; j ++ ) { if ( counter & ( 1 << j ) ) else } if ( sum % ( 24 * 60 ) == 0 ) return true ; } return false ; } int main ( ) { int a [ ] = { 60 , 60 , 120 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; if ( check@@ Combin@@ ations ( a , n ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
Number of Co 6579 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int make@@ Pairs ( vector < int > & pairs , int a , int b ) { for ( int i = a ; i <= b ; i ++ ) { int sum@@ Of@@ Digits = 0 , k = i ; while ( k > 0 ) { sum@@ Of@@ Digits += k % 10 ; k /= 10 ; } if ( sum@@ Of@@ Digits <= 162 ) pairs . push_back ( sum@@ Of@@ Digits ) ; } } int count@@ Co@@ Prime ( int a , int b ) { vector < int > pairs ; make@@ Pairs ( pairs , a , b ) ; int count = 0 ; for ( int i = 0 ; i < pairs . size ( ) ; i ++ ) for ( int j = i + 1 ; j < pairs . size ( ) ; j ++ ) if ( __@@ gcd ( pairs [ i ] , pairs [ j ] ) == 1 ) count ++ ; return count ; } int main ( ) { int a = 12 , b = 15 ; cout << count@@ Co@@ Prime ( a , b ) ; return 0 ; }
Minimum remo@@ vals from array to make max 6661 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define MAX 100 NEW_LINE int dp [ MAX ] [ MAX ] ; int count@@ Remo@@ vals ( int a [ ] , int i , int j , int k ) { if ( i >= j ) return 0 ; else if ( ( a [ j ] - a [ i ] ) <= k ) return 0 ; else if ( dp [ i ] [ j ] != -1 ) return dp [ i ] [ j ] ; else if ( ( a [ j ] - a [ i ] ) > k ) { dp [ i ] [ j ] = 1 + min ( count@@ Remo@@ vals ( a , i + 1 , j , k ) , count@@ Remo@@ vals ( a , i , j - 1 , k ) ) ; } return dp [ i ] [ j ] ; } int remo@@ vals ( int a [ ] , int n , int k ) { sort ( a , a + n ) ; memset ( dp , -1 , sizeof ( dp ) ) ; if ( n == 1 ) return 0 ; else return count@@ Remo@@ vals ( a , 0 , n - 1 , k ) ; } int main ( ) { int a [ ] = { 1 , 3 , 4 , 9 , 10 , 11 , 12 , 17 , 20 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int k = 4 ; cout << remo@@ vals ( a , n , k ) ; return 0 ; }
Count ways to reach the nth st@@ air using step 1 , 2 or 3 6690 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; class GF@@ G { public : int find@@ Step ( int n ) { if ( n == 1 n == 0 ) return 1 ; else if ( n == 2 ) return 2 ; else return find@@ Step ( n - 3 ) + find@@ Step ( n - 2 ) + find@@ Step ( n - 1 ) ; } } ; int main ( ) { GF@@ G g ; int n = 4 ; cout << g . find@@ Step ( n ) ; return 0 ; }
Del@@ anno@@ y Number 6713 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int de@@ al@@ n@@ no@@ y ( int n , int m ) { if ( m == 0 n == 0 ) return 1 ; return de@@ al@@ n@@ no@@ y ( m - 1 , n ) + de@@ al@@ n@@ no@@ y ( m - 1 , n - 1 ) + de@@ al@@ n@@ no@@ y ( m , n - 1 ) ; } int main ( ) { int n = 3 , m = 4 ; cout << de@@ al@@ n@@ no@@ y ( n , m ) << endl ; return 0 ; }
Maximum difference of zeros and ones in binary string 6717 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE #@@ define MAX 100 NEW_LINE using namespace std ; bool all@@ ones ( string s , int n ) { int co = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) co += ( s [ i ] == '1' ) ; return ( co == n ) ; } int find@@ length ( int arr [ ] , string s , int n , int ind , int st , int dp [ ] [ 3 ] ) { if ( ind >= n ) return 0 ; if ( dp [ ind ] [ st ] != -1 ) return dp [ ind ] [ st ] ; if ( st == 0 ) return dp [ ind ] [ st ] = max ( arr [ ind ] + find@@ length ( arr , s , n , ind + 1 , 1 , dp ) , find@@ length ( arr , s , n , ind + 1 , 0 , dp ) ) ; else return dp [ ind ] [ st ] = max ( arr [ ind ] + find@@ length ( arr , s , n , ind + 1 , 1 , dp ) , 0 ) ; } int maxLen ( string s , int n ) { if ( all@@ ones ( s , n ) ) return -1 ; int arr [ MAX ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = ( s [ i ] == '0' ? 1 : -1 ) ; int dp [ MAX ] [ 3 ] ; memset ( dp , -1 , sizeof dp ) ; return find@@ length ( arr , s , n , 0 , 0 , dp ) ; } int main ( ) { string s = "11@@ 0000@@ 100@@ 01" ; int n = 11 ; cout << maxLen ( s , n ) << endl ; return 0 ; }
Minimum jumps to reach last building in a matrix 6727 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; # define R 4 NEW_LINE # define C 3 NEW_LINE bool is@@ Safe ( int x , int y ) { return ( x < R && y < C ) ; } int min@@ Jump ( int height [ R ] [ C ] , int x , int y ) { if ( x == R - 1 && y == C - 1 ) return 0 ; int diag = INT_MAX ; if ( is@@ Safe ( x + 1 , y + 1 ) ) diag = min@@ Jump ( height , x + 1 , y + 1 ) + abs ( height [ x ] [ y ] - height [ x + 1 ] [ y + 1 ] ) ; int down = INT_MAX ; if ( is@@ Safe ( x + 1 , y ) ) down = min@@ Jump ( height , x + 1 , y ) + abs ( height [ x ] [ y ] - height [ x + 1 ] [ y ] ) ; int right = INT_MAX ; if ( is@@ Safe ( x , y + 1 ) ) right = min@@ Jump ( height , x , y + 1 ) + abs ( height [ x ] [ y ] - height [ x ] [ y + 1 ] ) ; return min ( { down , right , diag } ) ; } int main ( ) { int height [ ] [ C ] = { { 5 , 4 , 2 } , { 9 , 2 , 1 } , { 2 , 5 , 9 } , { 1 , 3 , 11 } } ; cout << min@@ Jump ( height , 0 , 0 ) ; return 0 ; }
Count ways to build street under given constraints 6759 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; long count@@ W@@ ays ( int n ) { long dp [ 2 ] [ n + 1 ] ; dp [ 0 ] [ 1 ] = 1 ; dp [ 1 ] [ 1 ] = 2 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] ; dp [ 1 ] [ i ] = dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] ; } return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] ; } int main ( ) { int n = 5 ; cout << " Total ▁ no ▁ of ▁ ways ▁ with ▁ n ▁ = ▁ " << n << " ▁ are : ▁ " << count@@ W@@ ays ( n ) << endl ; }
Count number of ways to jump to reach end 6813 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void count@@ Way@@ sTo@@ Jump ( int arr [ ] , int n ) { int count_@@ jump [ n ] ; memset ( count_@@ jump , 0 , sizeof ( count_@@ jump ) ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] >= n - i - 1 ) count_@@ jump [ i ] ++ ; for ( int j = i + 1 ; j < n - 1 && j <= arr [ i ] + i ; j ++ ) if ( count_@@ jump [ j ] != -1 ) count_@@ jump [ i ] += count_@@ jump [ j ] ; if ( count_@@ jump [ i ] == 0 ) count_@@ jump [ i ] = -1 ; } for ( int i = 0 ; i < n ; i ++ ) cout << count_@@ jump [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 1 , 3 , 5 , 8 , 9 , 1 , 0 , 7 , 6 , 8 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; count@@ Way@@ sTo@@ Jump ( arr , n ) ; return 0 ; }
Maximum decimal value path in a binary matrix 6887 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define N 4 NEW_LINE long long int max@@ Decimal@@ Value ( int mat [ ] [ N ] , int i , int j , int p ) { if ( i >= N j >= N ) return 0 ; int result = max ( max@@ Decimal@@ Value ( mat , i , j + 1 , p + 1 ) , max@@ Decimal@@ Value ( mat , i + 1 , j , p + 1 ) ) ; if ( mat [ i ] [ j ] == 1 ) return pow ( 2 , p ) + result ; else return result ; } int main ( ) { int mat [ ] [ 4 ] = { { 1 , 1 , 0 , 1 } , { 0 , 1 , 1 , 0 } , { 1 , 0 , 0 , 1 } , { 1 , 0 , 1 , 1 } , } ; cout << max@@ Decimal@@ Value ( mat , 0 , 0 , 0 ) << endl ; return 0 ; }
Maximum decimal value path in a binary matrix 6888 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define N 4 NEW_LINE long long int Maximum@@ Decimal@@ Value ( int mat [ ] [ N ] , int n ) { int dp [ n ] [ n ] ; memset ( dp , 0 , sizeof ( dp ) ) ; if ( mat [ 0 ] [ 0 ] == 1 ) for ( int i = 1 ; i < n ; i ++ ) { if ( mat [ 0 ] [ i ] == 1 ) dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + pow ( 2 , i ) ; else dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] ; } for ( int i = 1 ; i < n ; i ++ ) { if ( mat [ i ] [ 0 ] == 1 ) dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + pow ( 2 , i ) ; else dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ; } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + pow ( 2 , i + j ) ; else dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; } } return dp [ n - 1 ] [ n - 1 ] ; } int main ( ) { int mat [ ] [ 4 ] = { { 1 , 1 , 0 , 1 } , { 0 , 1 , 1 , 0 } , { 1 , 0 , 0 , 1 } , { 1 , 0 , 1 , 1 } , } ; cout << Maximum@@ Decimal@@ Value ( mat , 4 ) << endl ; return 0 ; }
Maximum sum of pairs with specific difference 6898 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max@@ Sum@@ Pair@@ With@@ Difference@@ LessThan@@ K ( int arr [ ] , int N , int K ) { sort ( arr , arr + N ) ; int dp [ N ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i < N ; i ++ ) { dp [ i ] = dp [ i - 1 ] ; if ( arr [ i ] - arr [ i - 1 ] < K ) { if ( i >= 2 ) dp [ i ] = max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ) ; else dp [ i ] = max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] ) ; } } return dp [ N - 1 ] ; } int main ( ) { int arr [ ] = { 3 , 5 , 10 , 15 , 17 , 12 , 9 } ; int N = sizeof ( arr ) / sizeof ( int ) ; int K = 4 ; cout << max@@ Sum@@ Pair@@ With@@ Difference@@ LessThan@@ K ( arr , N , K ) ; return 0 ; }
Maximum Sum Incre@@ asing Sub@@ sequence | DP 7050 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max@@ Sum@@ IS ( int arr [ ] , int n ) { int i , j , max = 0 ; int m@@ sis [ n ] ; for ( i = 0 ; i < n ; i ++ ) m@@ sis [ i ] = arr [ i ] ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && m@@ sis [ i ] < m@@ sis [ j ] + arr [ i ] ) m@@ sis [ i ] = m@@ sis [ j ] + arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( max < m@@ sis [ i ] ) max = m@@ sis [ i ] ; return max ; } int main ( ) { int arr [ ] = { 1 , 101 , 2 , 3 , 100 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Sum ▁ of ▁ maximum ▁ sum ▁ increasing ▁ " " sub@@ sequence ▁ is ▁ " << max@@ Sum@@ IS ( arr , n ) << endl ; return 0 ; }
Maximum Sum Incre@@ asing Sub@@ sequence | DP 7068 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int Matrix@@ Chain@@ Order ( int p [ ] , int i , int j ) { if ( i == j ) return 0 ; int k ; int min = INT_MAX ; int count ; for ( k = i ; k < j ; k ++ ) { count = Matrix@@ Chain@@ Order ( p , i , k ) + Matrix@@ Chain@@ Order ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( count < min ) min = count ; } return min ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Minimum ▁ number ▁ of ▁ multiplic@@ ations ▁ is ▁ " << Matrix@@ Chain@@ Order ( arr , 1 , n - 1 ) ; }
Repeat last occurrence of each alphanumeric character to their position in character family times 7097 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void encode@@ String ( string str ) { string res = " " ; int small [ 26 ] = { 0 } , capital [ 26 ] = { 0 } , num [ 10 ] = { 0 } ; int n = str . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] >= '0' && str [ i ] <= '9' ) { num [ str [ i ] - 48 ] = i ; } else if ( str [ i ] >= ' a ' && str [ i ] <= ' z ' ) { small [ str [ i ] - 97 ] = i ; } else if ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) { capital [ str [ i ] - 65 ] = i ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( ( str [ i ] >= ' a ' && str [ i ] <= ' z ' ) && small [ str [ i ] - 97 ] == i ) { int oc@@ c = str [ i ] - 96 ; while ( oc@@ c -- ) { res += str [ i ] ; } } else if ( ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) && capital [ str [ i ] - 65 ] == i ) { int oc@@ c = str [ i ] - 64 ; while ( oc@@ c -- ) { res += str [ i ] ; } } else if ( ( str [ i ] >= '0' && str [ i ] <= '9' ) && num [ str [ i ] - 48 ] == i ) { int oc@@ c = str [ i ] - 48 ; while ( oc@@ c -- ) { res += str [ i ] ; } } else { res += str [ i ] ; } } cout << res ; } int main ( ) { string str = " E@@ a2 , ▁ 0 , ▁ E " ; encode@@ String ( str ) ; return 0 ; }
Check if elements of a Binary Matrix can be made altern@@ ating 7103 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void create@@ Grid ( char grid [ ] [ 1001 ] , bool is@@ 1 , int N , int M ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( is@@ 1 ) { grid [ i ] [ j ] = '0' ; is@@ 1 = false ; } else { grid [ i ] [ j ] = '1' ; is@@ 1 = true ; } } if ( M % 2 == 0 ) is@@ 1 = ! is@@ 1 ; } } bool test@@ Grid ( char test@@ Grid [ ] [ 1001 ] , char Grid [ ] [ 1001 ] , int N , int M ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( Grid [ i ] [ j ] != ' * ' ) { if ( Grid [ i ] [ j ] != test@@ Grid [ i ] [ j ] ) { return false ; } } } } return true ; } void print@@ Grid ( char grid [ ] [ 1001 ] , int N , int M ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { cout << grid [ i ] [ j ] << " ▁ " ; } cout << endl ; } } void find@@ Possible@@ Grid ( int N , int M , char grid [ ] [ 1001 ] ) { char grid@@ Test1 [ N ] [ 1001 ] , grid@@ Test2 [ N ] [ 1001 ] ; create@@ Grid ( grid@@ Test1 , true , N , M ) ; create@@ Grid ( grid@@ Test2 , false , N , M ) ; if ( test@@ Grid ( grid@@ Test1 , grid , N , M ) ) { cout << " Yes STRNEWLINE " ; print@@ Grid ( grid@@ Test1 , N , M ) ; } else if ( test@@ Grid ( grid@@ Test2 , grid , N , M ) ) { cout << " Yes STRNEWLINE " ; print@@ Grid ( grid@@ Test2 , N , M ) ; } else { cout << " No STRNEWLINE " ; } } int main ( ) { int N = 4 , M = 4 ; char grid [ ] [ 1001 ] = { { ' * ' , ' * ' , '1' , '0' } , { ' * ' , ' * ' , ' * ' , ' * ' } , { ' * ' , ' * ' , ' * ' , ' * ' } , { ' * ' , ' * ' , '0' , '1' } } ; find@@ Possible@@ Grid ( N , M , grid ) ; return 0 ; }
Minim@@ ize subtraction followed by increments of adjacent elements required to make all array elements equal 7117 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Min@@ Moves ( int arr [ ] , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; if ( sum % N != 0 ) return -1 ; int avg = sum / N ; int total = 0 ; int need@@ Count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { need@@ Count += ( arr [ i ] - avg ) ; total = max ( max ( abs ( need@@ Count ) , arr [ i ] - avg ) , total ) ; } return total ; } int main ( ) { int arr [ ] = { 1 , 0 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << find@@ Min@@ Moves ( arr , N ) ; return 0 ; }
Remove all occurrences of a word from a given string using Z 7127 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void getZ@@ arr ( string str , int Z [ ] ) { int n = str . length ( ) ; int k ; int L = 0 ; int R = 0 ; for ( int i = 1 ; i < n ; ++ i ) { if ( i > R ) { L = R = i ; while ( R < n && str [ R - L ] == str [ R ] ) { R ++ ; } Z [ i ] = R - L ; R -- ; } else { k = i - L ; if ( Z [ k ] < R - i + 1 ) { Z [ i ] = Z [ k ] ; } else { L = i ; while ( R < n && str [ R - L ] == str [ R ] ) { R ++ ; } Z [ i ] = R - L ; R -- ; } } } } string good@@ Str ( string str , string word ) { string concat = word + " $ " + str ; int l = concat . length ( ) ; int Z [ l ] ; getZ@@ arr ( concat , Z ) ; string res ; int p@@ Size = word . size ( ) ; for ( int i = 0 ; i < l ; ++ i ) { if ( i + p@@ Size < l - 1 && Z [ i + p@@ Size + 1 ] == p@@ Size ) { i += p@@ Size - 1 ; } else if ( i < str . length ( ) ) { res += str [ i ] ; } } return res ; } int main ( ) { string str = " Z - k@@ mal@@ gorith@@ mk@@ mis@@ k@@ mk@@ mk@@ m@@ help@@ ful@@ k@@ min@@ km@@ searching " ; string word = " km " ; cout << good@@ Str ( str , word ) ; return 0 ; }
Sum of products of all possible Sub@@ arrays 7145 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void sum@@ Of@@ Sub@@ array@@ Prod ( int arr [ ] , int n ) { int ans = 0 ; int res = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int incr = arr [ i ] * ( 1 + res ) ; ans += incr ; res = incr ; } cout << ( ans ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sum@@ Of@@ Sub@@ array@@ Prod ( arr , N ) ; }
Check if Eu@@ ler To@@ ti@@ ent Function is same for a given number and twice of that number 7151 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int phi ( int n ) { int result = 1 ; for ( int p = 2 ; p < n ; p ++ ) { if ( __@@ gcd ( p , n ) == 1 ) { result ++ ; } } return result ; } bool same@@ Euler@@ To@@ ti@@ ent ( int n ) { return phi ( n ) == phi ( 2 * n ) ; } int main ( ) { int N = 13 ; if ( same@@ Euler@@ To@@ ti@@ ent ( N ) ) cout << " Yes " ; else cout << " No " ; }
Find elements in a given range having at least one odd divisor 7185 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int print@@ O@@ dd@@ Factor@@ Number ( int n , int m ) { for ( int i = n ; i <= m ; i ++ ) { if ( ( i > 0 ) && ( ( i & ( i - 1 ) ) != 0 ) ) cout << i << " ▁ " ; } } int main ( ) { int N = 2 , M = 10 ; print@@ O@@ dd@@ Factor@@ Number ( N , M ) ; return 0 ; }
Print the first N terms of the series 6 , 28 , 66 , 120 , 190 , 27@@ 6 , ... 7186 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ Series ( int n ) { int k = 2 ; for ( int i = 0 ; i < n ; i ++ ) { cout << ( k * ( 2 * k - 1 ) ) << " ▁ " ; k += 2 ; } cout << endl ; } int main ( ) { int N = 12 ; print@@ Series ( N ) ; return 0 ; }
Find N values of X1 , X2 , ... X@@ n such that X1 < X2 < ... < X@@ N and sin ( X1 ) < sin ( X2 ) < ... < sin ( X@@ N ) 7218 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ Sin@@ X ( int N ) { int Xi = 0 ; int num = 1 ; while ( N -- ) { cout << " X " << num << " ▁ = ▁ " << Xi ; cout << " ▁ sin ( X " << num << " ) ▁ = ▁ " << fixed ; cout << setprecision ( 6 ) << sin ( Xi ) << endl ; num += 1 ; Xi += 7@@ 10 ; } } int main ( ) { int N = 5 ; print@@ Sin@@ X ( N ) ; return 0 ; }
Sum of all elements in an array between zeros 7219 | #@@ include " bits / std@@ c + + . h " NEW_LINE using namespace std ; void sum@@ Between@@ Zero ( int arr [ ] , int N ) { int i = 0 ; vector < int > A ; int sum = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) { i ++ ; break ; } } for ( ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) { A . push_back ( sum ) ; sum = 0 ; } else { sum += arr [ i ] ; } } for ( int i = 0 ; i < A . size ( ) ; i ++ ) { cout << A [ i ] << ' ▁ ' ; } if ( A . size ( ) == 0 ) cout << " - 1" ; } int main ( ) { int arr [ ] = { 1 , 0 , 3 , 4 , 0 , 4 , 4 , 0 , 2 , 1 , 4 , 0 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sum@@ Between@@ Zero ( arr , N ) ; return 0 ; }
Total length of string from given Array of strings composed using given characters 7222 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Characters ( vector < string > & strings , string chars ) { int res = 0 ; unordered_map < char , int > freq ; for ( int i = 0 ; i < chars . length ( ) ; i ++ ) freq [ chars [ i ] ] += 1 ; for ( auto st : strings ) { bool flag = true ; for ( auto c : st ) { if ( ! freq ) { flag = false ; break ; } } if ( flag ) res += st . length ( ) ; } return res ; } int main ( ) { vector < string > strings = { " hi " , " data " , " ge@@ ek@@ s@@ forge@@ e@@ ks " } ; string chars = " ti@@ ad@@ h@@ ae " ; cout << count@@ Characters ( strings , chars ) ; return 0 ; }
Print N numbers such that their sum is a Perf@@ ect Cube 7246 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ Numbers ( int n ) { int i = 1 ; while ( i <= n ) { cout << ( 3 * i * ( i - 1 ) + 1 ) << " ▁ " ; i ++ ; } } int main ( ) { int n = 4 ; find@@ Numbers ( n ) ; }
Length of the longest substring with consecutive characters 7275 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int getEnd@@ ing@@ Index ( string str , int n , int i ) { i ++ ; while ( i < n ) { char curr = str [ i ] ; char prev = str [ i - 1 ] ; if ( ( curr == ' a ' && prev == ' z ' ) || ( curr - prev == 1 ) ) i ++ ; else break ; } return i - 1 ; } int lar@@ gest@@ Sub@@ Str ( string str , int n ) { int len = 0 ; int i = 0 ; while ( i < n ) { int end = getEnd@@ ing@@ Index ( str , n , i ) ; len = max ( end - i + 1 , len ) ; i = end + 1 ; } return len ; } int main ( ) { string str = " abc@@ abcde@@ fab@@ c " ; int n = str . length ( ) ; cout << ( lar@@ gest@@ Sub@@ Str ( str , n ) ) ; }
Most frequ@@ ent word in first String which is not present in second String 7284 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; string smalle@@ st@@ Freq ( string S1 , string S2 ) { map < string , int > banned ; for ( int i = 0 ; i < S2 . length ( ) ; ++ i ) { string s = " " ; while ( i < S2 . length ( ) && S2 [ i ] != ' ▁ ' ) s += S2 [ i ++ ] ; banned [ s ] ++ ; } map < string , int > result ; string ans ; int freq = 0 ; for ( int i = 0 ; i < S1 . length ( ) ; ++ i ) { string s = " " ; while ( i < S1 . length ( ) && S1 [ i ] != ' ▁ ' ) s += S1 [ i ++ ] ; if ( banned [ s ] == 0 ) { result [ s ] ++ ; if ( result [ s ] > freq || ( result [ s ] == freq && s < ans ) ) { ans = s ; freq = result [ s ] ; } } } return ans ; } int main ( ) { string S1 = " ge@@ e@@ ks ▁ for ▁ ge@@ e@@ ks ▁ is ▁ best ▁ place ▁ to ▁ learn " ; string S2 = " bad ▁ place " ; cout << smalle@@ st@@ Freq ( S1 , S2 ) ; return 0 ; }
Check if a string is substring of another 7301 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int isSub@@ string ( string s1 , string s2 ) { int M = s1 . length ( ) ; int N = s2 . length ( ) ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( s2 [ i + j ] != s1 [ j ] ) break ; if ( j == M ) return i ; } return -1 ; } int main ( ) { string s1 = " for " ; string s2 = " ge@@ ek@@ s@@ forge@@ e@@ ks " ; int res = isSub@@ string ( s1 , s2 ) ; if ( res == -1 ) cout << " Not ▁ present " ; else cout << " Present ▁ at ▁ index ▁ " << res ; return 0 ; }
Find all the patterns of "1@@ (0 + ) 1" in a given string | SET 1 ( General Appro@@ ach ) 7310 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int pattern@@ Count ( string str ) { char last = str [ 0 ] ; int i = 1 , counter = 0 ; while ( i < str . size ( ) ) { if ( str [ i ] == '0' && last == '1' ) { while ( str [ i ] == '0' ) i ++ ; if ( str [ i ] == '1' ) counter ++ ; } last = str [ i ] ; i ++ ; } return counter ; } int main ( ) { string str = "100@@ 1@@ ab@@ 01@@ 0@@ abc@@ 0100@@ 1" ; cout << pattern@@ Count ( str ) << endl ; return 0 ; }
Maximum length of string formed by concatenation having even frequency of each character 7328 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max@@ i = 0 ; string ans@@ 1 = " " ; void calculate ( string ans ) { int dp [ 26 ] = { 0 } ; for ( int i = 0 ; i < ans . length ( ) ; ++ i ) { dp [ ans [ i ] - ' A ' ] ++ ; } for ( int i = 0 ; i < 26 ; ++ i ) { if ( dp [ i ] % 2 == 1 ) { return ; } } if ( max@@ i < ans . length ( ) ) { max@@ i = ans . length ( ) ; ans@@ 1 = ans ; } } void lon@@ gest@@ String ( vector < string > arr , int index , string str ) { if ( index == arr . size ( ) ) { return ; } lon@@ gest@@ String ( arr , index + 1 , str ) ; str += arr [ index ] ; calculate ( str ) ; lon@@ gest@@ String ( arr , index + 1 , str ) ; } int main ( ) { vector < string > A = { " AB@@ AB " , " AB@@ F " , " CD@@ A " , " AD " , " CC@@ C " } ; lon@@ gest@@ String ( A , 0 , " " ) ; cout << ans@@ 1 << " ▁ " << ans@@ 1 . length ( ) ; return 0 ; }
Divide given numeric string into at most two increasing sub@@ sequences which form an increasing string upon concatenation 7346 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ Sub@@ sequence ( string str ) { int n = str . size ( ) ; char res [ n ] ; for ( int i = 0 ; i < n ; i ++ ) res [ i ] = 0 ; for ( int pos = 0 ; pos <= 9 ; pos ++ ) { char lst@@ 1 = '0' ; bool flag = 1 ; char lst@@ 2 = pos + '0' ; for ( int i = 0 ; i < n ; i ++ ) { if ( lst@@ 2 <= str [ i ] ) { res [ i ] = '2' ; lst@@ 2 = str [ i ] ; } else if ( lst@@ 1 <= str [ i ] ) { res [ i ] = '1' ; lst@@ 1 = str [ i ] ; } else flag = 0 ; } if ( lst@@ 1 > pos + '0' ) flag = 0 ; if ( flag ) { string S1 = " " ; string S2 = " " ; for ( int i = 0 ; i < n ; i ++ ) { if ( res [ i ] == '1' ) { S1 += str [ i ] ; } else { S2 += str [ i ] ; } } cout << S1 << ' ▁ ' << S2 << endl ; return ; } } cout << " - 1" ; } int main ( ) { string S = "@@ 04@@ 04@@ 255@@ 24@@ 64@@ 4" ; find@@ Sub@@ sequence ( S ) ; S = "123456789@@ " ; find@@ Sub@@ sequence ( S ) ; return 0 ; }
Find K@@ th lex@@ ico@@ graphical ordered numeric string of length N with distinct products of each substring 7349 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void getString ( int cur@@ len , string & ans , string & s , int N , int & K , vector < int > & prod ) { if ( cur@@ len == N ) { K -- ; if ( K == 0 ) ans = s ; return ; } char ch ; int ok , t , i ; for ( ch = '2' ; ch <= '9' ; ch ++ ) { s += ch ; ok = 1 ; t = 1 ; for ( i = cur@@ len ; i >= 0 ; i -- ) { t *= s [ i ] - 48 ; if ( prod [ t ] ) ok = 0 ; prod [ t ] ++ ; } if ( ok ) getString ( cur@@ len + 1 , ans , s , N , K , prod ) ; t = 1 ; for ( i = cur@@ len ; i >= 0 ; i -- ) { t *= s [ i ] - 48 ; prod [ t ] -- ; } s . erase ( s . length ( ) - 1 ) ; } } string k@@ th@@ Valid@@ String ( int N , int K ) { if ( N > 10 ) { return " - 1" ; } if ( N == 1 ) { if ( K > 10 ) { return " - 1" ; } string s = " " ; K -- ; s += ( K + '0' ) ; return s ; } string ans = " - 1" ; string s = " " ; vector < int > prod ( 100@@ 05 , 0 ) ; getString ( 0 , ans , s , N , K , prod ) ; return ans ; } int main ( ) { int N = 3 , K = 4 ; cout << k@@ th@@ Valid@@ String ( N , K ) ; }
Convert given Strings into T by replacing characters in between strings any number of times 7382 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; string check@@ If@@ Possible ( int N , string arr [ ] , string T ) { int freq@@ S [ 256 ] = { 0 } ; int freq@@ T [ 256 ] = { 0 } ; for ( char ch : T ) { freq@@ T [ ch - ' a ' ] ++ ; } for ( int i = 0 ; i < N ; i ++ ) { for ( char ch : arr [ i ] ) { freq@@ S [ ch - ' a ' ] ++ ; } } for ( int i = 0 ; i < 256 ; i ++ ) { if ( freq@@ T [ i ] == 0 && freq@@ S [ i ] != 0 ) { return " No " ; } else if ( freq@@ S [ i ] == 0 && freq@@ T [ i ] != 0 ) { return " No " ; } else if ( freq@@ T [ i ] != 0 && freq@@ S [ i ] != ( freq@@ T [ i ] * N ) ) { return " No " ; } } return " Yes " ; } int main ( ) { string arr [ ] = { " abc " , " abb " , " acc " } ; string T = " abc " ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << check@@ If@@ Possible ( N , arr , T ) ; return 0 ; }
Count of groups of consecutive 1 s in a given Binary String 7401 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int group@@ sOf@@ Ones ( string S , int N ) { int count = 0 ; stack < int > st ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] == '1' ) st . push ( 1 ) ; else { if ( ! st . empty ( ) ) { count ++ ; while ( ! st . empty ( ) ) { st . pop ( ) ; } } } } if ( ! st . empty ( ) ) count ++ ; return count ; } int main ( ) { string S = "100@@ 1101@@ 11" ; int N = S . length ( ) ; cout << group@@ sOf@@ Ones ( S , N ) << endl ; return 0 ; }
Minim@@ ize cost of fli@@ pping or sw@@ aps to make a Binary String balanced 7421 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ Minimum@@ Cost ( string s , int N ) { int count_@@ 1 = 0 , count_@@ 0 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( s [ i ] == '1' ) count_@@ 1 ++ ; else count_@@ 0 ++ ; } int k = abs ( count_@@ 0 - count_@@ 1 ) ; if ( count_@@ 1 == N count_@@ 0 == N ) cout << -1 << endl ; else cout << k / 2 << endl ; } int main ( ) { string S = "11@@ 01@@ 10" ; int N = S . length ( ) ; find@@ Minimum@@ Cost ( S , N ) ; return 0 ; }
Minim@@ ize length of a string by removing pairs of consecutive increasing or decre@@ asing digits 7430 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int minLength ( string S ) { stack < char > st ; for ( auto ch : S ) { if ( st . empty ( ) ) st . push ( ch ) ; else { char top = st . top ( ) ; if ( abs ( ch - top ) == 1 ) st . pop ( ) ; else { st . push ( ch ) ; } } } return st . size ( ) ; } int main ( ) { string S = "12@@ 213@@ " ; cout << minLength ( S ) ; return 0 ; }
Minimum remo@@ vals required to place all 0 s before 1 s in a Binary String 7466 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int minimum@@ Dele@@ tions ( string s ) { int right_@@ 0 = count ( s . begin ( ) , s . end ( ) , '0' ) ; int left_@@ 1 = 0 ; int n = s . size ( ) ; int res = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '0' ) { right_@@ 0 -= 1 ; } else { left_@@ 1 += 1 ; } res = min ( res , right_@@ 0 + left_@@ 1 ) ; } return res ; } int main ( ) { string s = "00@@ 11@@ 01" ; int count = minimum@@ Dele@@ tions ( s ) ; cout << count ; return 0 ; }
Count removal of pairs required to be empty all Bal@@ anced Parenthe@@ sis sub@@ sequences 7515 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; void cnt@@ Bal@@ anced@@ Parenthe@@ sis ( string s , int N ) { int cnt@@ Pairs = 0 ; int cnt@@ Cur@@ ly = 0 ; int cnt@@ S@@ ml = 0 ; int cnt@@ Sqr = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( s [ i ] == ' { ' ) { cnt@@ Cur@@ ly ++ ; } else if ( s [ i ] == ' ( ' ) { cnt@@ S@@ ml ++ ; } else if ( s [ i ] == ' [ ' ) { cnt@@ Sqr ++ ; } else if ( s [ i ] == ' } ' && cnt@@ Cur@@ ly > 0 ) { cnt@@ Cur@@ ly -- ; cnt@@ Pairs ++ ; } else if ( s [ i ] == ' ) ' && cnt@@ S@@ ml > 0 ) { cnt@@ S@@ ml -- ; cnt@@ Pairs ++ ; } else if ( s [ i ] == ' ] ' && cnt@@ Sqr > 0 ) { cnt@@ Sqr -- ; cnt@@ Pairs ++ ; } } cout << cnt@@ Pairs ; } int main ( ) { string s = " { ( } ) " ; int N = s . length ( ) ; cnt@@ Bal@@ anced@@ Parenthe@@ sis ( s , N ) ; return 0 ; }
Check if a given string can be converted to a Bal@@ anced Bracket Sequence 7518 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool canBe@@ Bal@@ anced ( string sequence ) { if ( sequence . size ( ) % 2 ) return false ; stack < char > stack@@ _ , stack@@ 2_ ; int count@@ Open = 0 , count@@ Closed = 0 ; int count@@ Symbol = 0 ; for ( int i = 0 ; i < sequence . size ( ) ; i ++ ) { if ( sequence [ i ] == ' ) ' ) { count@@ Closed ++ ; if ( stack@@ _ . empty ( ) ) { return false ; } else { stack@@ _ . pop ( ) ; } } else { if ( sequence [ i ] == ' $ ' ) { count@@ Symbol ++ ; } else { count@@ Open ++ ; } stack@@ _ . push ( sequence [ i ] ) ; } } for ( int i = sequence . size ( ) - 1 ; i >= 0 ; i -- ) { if ( sequence [ i ] == ' ( ' ) { if ( stack@@ 2_ . empty ( ) ) { return false ; } else { stack@@ 2_ . pop ( ) ; } } else { stack@@ 2_ . push ( sequence [ i ] ) ; } } int extra = abs ( count@@ Closed - count@@ Open ) ; if ( count@@ Symbol < extra ) { return false ; } else { count@@ Symbol -= extra ; if ( count@@ Symbol % 2 == 0 ) { return true ; } } return false ; } int main ( ) { string S = " ( ) ( $ " ; if ( canBe@@ Bal@@ anced ( S ) ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
Queries to calculate difference between the frequencies of the most and least occur@@ ring characters in specified substring 7521 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void max@@ Diff@@ Freq ( vector < pair < int , int > > queries , string S ) { int N = S . size ( ) ; int Q = queries . size ( ) ; for ( int i = 0 ; i < Q ; ++ i ) { int l = queries [ i ] . first - 1 ; int r = queries [ i ] . second - 1 ; int freq [ 26 ] = { 0 } ; for ( int j = l ; j <= r ; j ++ ) { freq [ S [ j ] - ' a ' ] ++ ; } int mx = 0 ; int mn = 9999@@ 9999 ; for ( int j = 0 ; j < 26 ; j ++ ) { mx = max ( mx , freq [ j ] ) ; if ( freq [ j ] ) mn = min ( mn , freq [ j ] ) ; } cout << mx - mn << endl ; } } int main ( ) { string S = " ab@@ a@@ ab@@ ac " ; vector < pair < int , int > > queries { { 2 , 6 } , { 1 , 7 } } ; max@@ Diff@@ Freq ( queries , S ) ; }
Check if given strings can be made same by sw@@ apping two characters of same or different strings 7537 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Equal@@ Strings ( string arr [ ] , int N ) { int M = arr [ 0 ] . length ( ) ; int cnt@@ Freq [ 256 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { cnt@@ Freq [ arr [ i ] [ j ] - ' a ' ] ++ ; } } for ( int i = 0 ; i < 256 ; i ++ ) { if ( cnt@@ Freq [ i ] % N != 0 ) { return false ; } } return true ; } int main ( ) { string arr [ ] = { " aa@@ b " , " bb@@ c " , " cc@@ a " } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( is@@ Equal@@ Strings ( arr , N ) ) { cout << " YES " ; } else { cout << " NO " ; } return 0 ; }
Maximum repe@@ ating character for every index in given String 7555 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ Freq ( string str , int N ) { int freq [ 256 ] ; memset ( freq , 0 , sizeof ( freq ) ) ; int max = 0 ; char char@@ Max = '0' ; for ( int i = 0 ; i < N ; i ++ ) { char ch = str [ i ] ; freq [ ch ] ++ ; if ( freq [ ch ] >= max ) { max = freq [ ch ] ; char@@ Max = ch ; } cout << char@@ Max << " - > " << max << endl ; } } int main ( ) { string str = " ab@@ bc " ; int N = str . size ( ) ; find@@ Freq ( str , N ) ; }
Count of sub@@ strings of a Binary string containing only 1 s 7582 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Of@@ Sub@@ string@@ With@@ Only@@ Ones ( string s ) { int res = 0 , count = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { count = s [ i ] == '1' ? count + 1 : 0 ; res = ( res + count ) ; } return res ; } int main ( ) { string s = "01@@ 101@@ 11" ; cout << count@@ Of@@ Sub@@ string@@ With@@ Only@@ Ones ( s ) << endl ; return 0 ; }
Calculate Sum of ratio of special characters to length of sub@@ strings of the given string 7597 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; const int N = 1e@@ 5 + 5 ; vector < int > prefix ( N , 0 ) ; vector < int > sum ( N , 0 ) ; bool is@@ Special ( char c , vector < char > & special ) { for ( auto & i : special ) if ( i == c ) return true ; return false ; } double count@@ Ratio ( string & s , vector < char > & special ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { prefix [ i ] = int ( is@@ Special ( s [ i ] , special ) ) ; if ( i > 0 ) prefix [ i ] += prefix [ i - 1 ] ; } for ( int i = 0 ; i < n ; i ++ ) { sum [ i ] = prefix [ i ] ; if ( i > 0 ) sum [ i ] += sum [ i - 1 ] ; } double ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int count = sum [ n - 1 ] - ( i > 1 ? sum [ i - 2 ] : 0 ) ; count -= ( i < n ? sum [ n - i - 1 ] : 0 ) ; ans += double ( count ) / double ( i ) ; } return ans ; } int main ( ) { string s = " abcd " ; vector < char > special = { ' b ' , ' c ' } ; double ans = count@@ Ratio ( s , special ) ; cout << fixed << setprecision ( 6 ) << ans << endl ; return 0 ; }
Check given string is odd@@ ly pal@@ ind@@ ro@@ me or not 7612 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Pal@@ ind@@ ro@@ me ( string str ) { int l = 0 ; int h = str . size ( ) - 1 ; while ( h > l ) { if ( str [ l ++ ] != str [ h -- ] ) { return false ; } } return true ; } string make@@ O@@ dd@@ String ( string str ) { string odd = " " ; for ( int i = 1 ; i < str . size ( ) ; i += 2 ) { odd += str [ i ] ; } return odd ; } void check@@ O@@ dd@@ ly@@ Pal@@ ind@@ ro@@ me ( string str ) { string odd = make@@ O@@ dd@@ String ( str ) ; if ( is@@ Pal@@ ind@@ ro@@ me ( odd ) ) cout << " Yes " << endl ; else cout << " No " << endl ; } int main ( ) { string str = " d@@ dw@@ fe@@ fw@@ de " ; check@@ O@@ dd@@ ly@@ Pal@@ ind@@ ro@@ me ( str ) ; return 0 ; }
Check if a number ends with another number or not 7659 | #@@ include " bits / std@@ c + + . h " NEW_LINE using namespace std ; bool check@@ Suffix ( int A , int B ) { string s1 = to_string ( A ) ; string s2 = to_string ( B ) ; int n1 = s1 . length ( ) ; int n2 = s2 . length ( ) ; if ( n1 < n2 ) { return false ; } for ( int i = 0 ; i < n2 ; i ++ ) { if ( s1 [ n1 - i - 1 ] != s2 [ n2 - i - 1 ] ) { return false ; } } return true ; } int main ( ) { int A = 12345 , B = 45 ; bool result = check@@ Suffix ( A , B ) ; if ( result ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
Construct the C@@ yp@@ her string based on the given conditions 7675 | #@@ include " bits / std@@ c + + . h " NEW_LINE using namespace std ; bool is@@ Prime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } bool is@@ Possible@@ Sum ( int N ) { if ( is@@ Prime ( N ) && is@@ Prime ( N - 2 ) ) { return true ; } else { return false ; } } bool check@@ Semi@@ prime ( int num ) { int cnt = 0 ; for ( int i = 2 ; cnt < 2 && i * i <= num ; ++ i ) { while ( num % i == 0 ) { num /= i , ++ cnt ; } } if ( num > 1 ) { ++ cnt ; } return cnt == 2 ; } void make@@ C@@ yp@@ her@@ String ( int N ) { string semi@@ Prime = " " ; string sum@@ Of@@ Prime = " " ; string str = to_string ( N ) ; if ( check@@ Semi@@ prime ( N ) ) { for ( int i = 0 ; str [ i ] ; i ++ ) { if ( i & 1 ) { semi@@ Prime += str [ i ] ; } else { semi@@ Prime += char ( str [ i ] - '0' + 65 ) ; } } } if ( is@@ Possible@@ Sum ( N ) ) { for ( int i = 0 ; str [ i ] ; i ++ ) { if ( i & 1 ) { sum@@ Of@@ Prime += char ( str [ i ] - '0' + 65 ) ; } else { sum@@ Of@@ Prime += str [ i ] ; } } } if ( semi@@ Prime + sum@@ Of@@ Prime == " " ) { cout << " - 1" ; } else { cout << semi@@ Prime + sum@@ Of@@ Prime ; } } int main ( ) { int N = 101@@ 12@@ 43 ; make@@ C@@ yp@@ her@@ String ( N ) ; return 0 ; }
Find the k 7679 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void k@@ th_@@ string ( int n , int k ) { for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( k <= ( n - i - 1 ) ) { for ( int j = 0 ; j < n ; j ++ ) { if ( j == i or j == n - k ) cout << ' Y ' ; else cout << ' X ' ; } break ; } k -= ( n - i - 1 ) ; } } int main ( ) { int n = 5 , k = 7 ; k@@ th_@@ string ( n , k ) ; return 0 ; }
Remove duplicates from string keeping the order according to last occurrences 7707 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; string remove@@ Duplicates ( string str ) { int n = str . length ( ) ; string res = " " ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = i + 1 ; j < n ; j ++ ) if ( str [ i ] == str [ j ] ) break ; if ( j == n ) res = res + str [ i ] ; } return res ; } int main ( ) { string str = " ge@@ ek@@ s@@ forge@@ e@@ ks " ; cout << remove@@ Duplicates ( str ) ; return 0 ; }
Find the Sub@@ string with maximum product 7720 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int value ( char x ) { return ( int ) ( x - ' a ' ) ; } string maximum@@ Product ( string str , int n ) { string answer = " " , curr = " " ; long long max@@ Product = 0 , product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { product *= 1@@ LL * value ( str [ i ] ) ; curr += str [ i ] ; if ( product >= max@@ Product ) { max@@ Product = product ; answer = curr ; } if ( product == 0 ) { product = 1 ; curr = " " ; } } return answer ; } int main ( ) { string str = " sd@@ t@@ fa@@ k@@ dh@@ da@@ hd@@ zz " ; int n = str . size ( ) ; cout << maximum@@ Product ( str , n ) << endl ; return 0 ; }
Find K@@ th largest string from the permutations of the string with two characters 7744 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void k@@ th@@ String ( int n , int k ) { int total = 0 ; int i = 1 ; while ( total < k ) { total = total + n - i ; i ++ ; } int first_@@ y_@@ position = i - 1 ; int second_@@ y_@@ position = k - ( total - n + first_@@ y_@@ position ) ; for ( int j = 1 ; j < first_@@ y_@@ position ; j ++ ) cout << " x " ; cout << " y " ; int j = first_@@ y_@@ position + 1 ; while ( second_@@ y_@@ position > 1 ) { cout << " x " ; second_@@ y_@@ position -- ; j ++ ; } cout << " y " ; while ( j < n ) { cout << " x " ; j ++ ; } } int main ( ) { int n = 5 ; int k = 7 ; k@@ th@@ String ( n , k ) ; return 0 ; }
Program to find the XOR of ASCII values of characters in a string 7748 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int Xor@@ Ascii ( string str , int len ) { int ans = int ( str [ 0 ] ) ; for ( int i = 1 ; i < len ; i ++ ) { ans = ( ans ^ ( int ( str [ i ] ) ) ) ; } return ans ; } int main ( ) { string str = " ge@@ ek@@ s@@ forge@@ e@@ ks " ; int len = str . length ( ) ; cout << Xor@@ Ascii ( str , len ) << endl ; str = " Gf@@ G " ; len = str . length ( ) ; cout << Xor@@ Ascii ( str , len ) ; return 0 ; }
Product of nodes at k 7753 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int product@@ At@@ K@@ th@@ Level ( string tree , int k , int & i , int level ) { if ( tree [ i ++ ] == ' ( ' ) { if ( tree [ i ] == ' ) ' ) return 1 ; int product = 1 ; if ( level == k ) product = tree [ i ] - '0' ; int left@@ product = product@@ At@@ K@@ th@@ Level ( tree , k , ++ i , level + 1 ) ; int right@@ product = product@@ At@@ K@@ th@@ Level ( tree , k , ++ i , level + 1 ) ; ++ i ; return product * left@@ product * right@@ product ; } } int main ( ) { string tree = " ( 0@@ (@@ 5@@ (@@ 6 ( ) ( ) ) ( 4 ( ) " " ( 9 ( ) ( ) ) ) ) ( 7@@ (1 ( ) ( ) ) ( 3 ( ) ( ) ) ) ) " ; int k = 2 ; int i = 0 ; cout << product@@ At@@ K@@ th@@ Level ( tree , k , i , 0 ) ; return 0 ; }
Modify the string such that every character gets replaced with the next character in the keyboard 7817 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; const string CHARS = " q@@ wer@@ ty@@ ui@@ op@@ as@@ df@@ gh@@ jkl@@ zx@@ cv@@ bn@@ m " ; const int MAX = 26 ; string getString ( string str , int n ) { unordered_map < char , char > u@@ Map ; for ( int i = 0 ; i < MAX ; i ++ ) { u@@ Map [ CHARS [ i ] ] = CHARS [ ( i + 1 ) % MAX ] ; } for ( int i = 0 ; i < n ; i ++ ) { str [ i ] = u@@ Map [ str [ i ] ] ; } return str ; } int main ( ) { string str = " ge@@ e@@ ks " ; int n = str . length ( ) ; cout << getString ( str , n ) ; return 0 ; }
Count number of binary strings such that there is no substring of length greater than or equal to 3 with all 1 '@@ s 7831 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; const long MOD = 100000000@@ 7 ; long count@@ Strings ( long N ) { long dp [ N + 1 ] [ 3 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 1 ] [ 0 ] = 1 ; dp [ 1 ] [ 1 ] = 1 ; dp [ 1 ] [ 2 ] = 0 ; for ( int i = 2 ; i <= N ; i ++ ) { dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] + dp [ i - 1 ] [ 2 ] ) % MOD ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] % MOD ; dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] % MOD ; } long ans = ( dp [ N ] [ 0 ] + dp [ N ] [ 1 ] + dp [ N ] [ 2 ] ) % MOD ; return ans ; } int main ( ) { long N = 3 ; cout << count@@ Strings ( N ) ; return 0 ; }
Find the maximum possible Binary Number from given string 7833 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; string max@@ Number ( string str , int n ) { int freq [ 2 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' z ' ) { freq [ 0 ] ++ ; } else if ( str [ i ] == ' n ' ) { freq [ 1 ] ++ ; } } string num = " " ; for ( int i = 0 ; i < freq [ 1 ] ; i ++ ) num += '1' ; for ( int i = 0 ; i < freq [ 0 ] ; i ++ ) num += '0' ; return num ; } int main ( ) { string str = " ro@@ en@@ en@@ zoo@@ e " ; int n = str . length ( ) ; cout << max@@ Number ( str , n ) ; return 0 ; }
In@@ fy@@ T@@ Q 2019 : Find the position from where the parenthesis is not balanced 7864 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int main ( ) { string String = " { [ ( ) ] } [ ] " ; vector < char > lst@@ 1 = { ' { ' , ' ( ' , ' [ ' } ; vector < char > lst@@ 2 = { ' } ' , ' ) ' , ' ] ' } ; vector < char > lst ; int k ; map < char , char > Dict ; Dict . insert ( pair < int , int > ( ' ) ' , ' ( ' ) ) ; Dict . insert ( pair < int , int > ( ' } ' , ' { ' ) ) ; Dict . insert ( pair < int , int > ( ' ] ' , ' [ ' ) ) ; int a = 0 , b = 0 , c = 0 ; if ( count ( lst@@ 2 . begin ( ) , lst@@ 2 . end ( ) , String [ 0 ] ) ) { cout << 1 << endl ; } else { for ( int i = 0 ; i < String . size ( ) ; i ++ ) { if ( count ( lst@@ 1 . begin ( ) , lst@@ 1 . end ( ) , String [ i ] ) ) { lst . push_back ( String [ i ] ) ; k = i + 2 ; } else { if ( lst . size ( ) == 0 && ( count ( lst@@ 2 . begin ( ) , lst@@ 2 . end ( ) , String [ i ] ) ) ) { cout << ( i + 1 ) << endl ; c = 1 ; break ; } else { if ( Dict [ String [ i ] ] == lst [ lst . size ( ) - 1 ] ) { lst . pop_back ( ) ; } else { break ; cout << ( i + 1 ) << endl ; a = 1 ; } } } } if ( lst . size ( ) == 0 && c == 0 ) { cout << 0 << endl ; b = 1 ; } if ( a == 0 && b == 0 && c == 0 ) { cout << k << endl ; } } return 0 ; }
Encrypt the given string with the following operations 7868 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE #@@ define MAX 26 NEW_LINE using namespace std ; string encrypt@@ Str ( string str , int n , int x ) { x = x % MAX ; int freq [ MAX ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { freq [ str [ i ] - ' a ' ] ++ ; } for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str [ i ] - ' a ' ] % 2 == 0 ) { int pos = ( str [ i ] - ' a ' + x ) % MAX ; str [ i ] = ( char ) ( pos + ' a ' ) ; } else { int pos = ( str [ i ] - ' a ' - x ) ; if ( pos < 0 ) { pos += MAX ; } str [ i ] = ( char ) ( pos + ' a ' ) ; } } return str ; } int main ( ) { string s = " abc@@ da " ; int n = s . size ( ) ; int x = 3 ; cout << encrypt@@ Str ( s , n , x ) << endl ; return 0 ; }
Find the number of occurrences of a character upto preceding position 7877 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Occurren@@ ce ( string s , int position ) { int alpha [ 26 ] = { 0 } , b [ s . size ( ) ] = { 0 } ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { b [ i ] = alpha [ ( int ) s [ i ] - 97 ] ; alpha [ ( int ) s [ i ] - 97 ] ++ ; } return b [ position - 1 ] ; } int main ( ) { string s = " abab@@ abab@@ ab " ; int p = 9 ; cout << count@@ Occurren@@ ce ( s , p ) ; return 0 ; }
Re@@ arrange characters in a string such that no two adjacent are same using hashing 7892 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE #@@ include <@@ time@@ .@@ h@@ > NEW_LINE using namespace std ; int is@@ Possible ( string str ) { unordered_map < char , int > freq ; int max_@@ freq = 0 ; for ( int j = 0 ; j < ( str . length ( ) ) ; j ++ ) { freq [ str [ j ] ] ++ ; if ( freq [ str [ j ] ] > max_@@ freq ) max_@@ freq = freq [ str [ j ] ] ; } if ( max_@@ freq <= ( str . length ( ) - max_@@ freq + 1 ) ) return true ; return false ; } int main ( ) { string str = " ge@@ ek@@ s@@ forge@@ e@@ ks " ; if ( is@@ Possible ( str ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
Find un@@ common characters of the two strings | Set 2 7899 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ Un@@ common ( string str1 , string str2 ) { int a1 = 0 , a2 = 0 ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) { int ch = int ( str1 [ i ] ) - ' a ' ; a1 = a1 | ( 1 << ch ) ; } for ( int i = 0 ; i < str2 . length ( ) ; i ++ ) { int ch = int ( str2 [ i ] ) - ' a ' ; a2 = a2 | ( 1 << ch ) ; } int ans = a1 ^ a2 ; int i = 0 ; while ( i < 26 ) { if ( ans % 2 == 1 ) { cout << char ( ' a ' + i ) ; } ans = ans / 2 ; i ++ ; } } int main ( ) { string str1 = " ge@@ ek@@ s@@ forge@@ e@@ ks " ; string str2 = " ge@@ ek@@ s@@ qui@@ z " ; print@@ Un@@ common ( str1 , str2 ) ; return 0 ; }
Count the nodes of a tree whose weighted string does not contain any duplicate characters 7903 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int cnt = 0 ; vector < int > graph [ 100 ] ; vector < string > weight ( 100 ) ; bool unique@@ Chars ( string x ) { map < char , int > mp ; int n = x . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) mp [ x [ i ] ] ++ ; if ( mp . size ( ) == x . size ( ) ) return true ; else return false ; } void dfs ( int node , int parent ) { if ( unique@@ Chars ( weight [ node ] ) ) cnt += 1 ; for ( int to : graph [ node ] ) { if ( to == parent ) continue ; dfs ( to , node ) ; } } int main ( ) { weight [ 1 ] = " abc " ; weight [ 2 ] = " aba " ; weight [ 3 ] = " b@@ cb " ; weight [ 4 ] = " mo@@ h " ; weight [ 5 ] = " aa " ; graph [ 1 ] . push_back ( 2 ) ; graph [ 2 ] . push_back ( 3 ) ; graph [ 2 ] . push_back ( 4 ) ; graph [ 1 ] . push_back ( 5 ) ; dfs ( 1 , 1 ) ; cout << cnt ; return 0 ; }
Check if all the 1 '@@ s in a binary string are equi@@ di@@ stant or not 7937 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE #@@ include <@@ st@@ dio@@ .@@ h@@ > NEW_LINE using namespace std ; bool check ( string s , int l ) { vector < int > pos ; for ( int i = 0 ; i < l ; i ++ ) { if ( s [ i ] == '1' ) pos . push_back ( i ) ; } int t = pos . size ( ) ; for ( int i = 1 ; i < t ; i ++ ) { if ( ( pos [ i ] - pos [ i - 1 ] ) != ( pos [ 1 ] - pos [ 0 ] ) ) return false ; } return true ; } int main ( ) { string s = "100@@ 0100@@ 0100@@ 0" ; int l = s . length ( ) ; if ( check ( s , l ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
Check if the given string is K 7961 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Prefix ( string str , int len , int i , int k ) { if ( i + k > len ) return false ; for ( int j = 0 ; j < k ; j ++ ) { if ( str [ i ] != str [ j ] ) return false ; i ++ ; } return true ; } bool is@@ K@@ Periodic ( string str , int len , int k ) { for ( int i = k ; i < len ; i += k ) if ( ! is@@ Prefix ( str , len , i , k ) ) return false ; return true ; } int main ( ) { string str = " ge@@ ek@@ s@@ ge@@ e@@ ks " ; int len = str . length ( ) ; int k = 5 ; if ( is@@ K@@ Periodic ( str , len , k ) ) cout << ( " Yes " ) ; else cout << ( " No " ) ; }
Cost to make a string Pan@@ agram 8027 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int p@@ ang@@ ram@@ Cost ( int arr [ ] , string str ) { int cost = 0 ; bool occurred [ 26 ] = { false } ; for ( int i = 0 ; i < str . size ( ) ; i ++ ) occurred [ str [ i ] - ' a ' ] = true ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( ! occurred [ i ] ) cost += arr [ i ] ; } return cost ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 } ; string str = " abcdefghijkl@@ mo@@ pq@@ rstu@@ v@@ w@@ z " ; cout << p@@ ang@@ ram@@ Cost ( arr , str ) ; return 0 ; }
Minimum deletions from string to reduce it to string with at most 2 unique characters 8069 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int check ( string s ) { int i , j ; int fr [ 26 ] = { 0 } ; int n = s . size ( ) ; for ( i = 0 ; i < n ; i ++ ) { char x = s [ i ] ; fr [ x - ' a ' ] += 1 ; } int minimum = INT_MAX ; for ( i = 0 ; i < 26 ; i ++ ) { for ( j = i + 1 ; j < 26 ; j ++ ) { int z = fr [ i ] + fr [ j ] ; minimum = min ( minimum , n - z ) ; } } return minimum ; } int main ( ) { string s = " ge@@ ek@@ s@@ forge@@ e@@ ks " ; cout << check ( s ) ; }
Re@@ arrange a string in the form of integer sum followed by the minim@@ ized character 8079 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; string separ@@ ate@@ Char ( string str ) { int n = str . size ( ) , digit@@ Sum = 0 ; int alphab@@ et@@ Sum = 0 , j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isdigit ( str [ i ] ) ) digit@@ Sum += str [ i ] - '0' ; else { alphab@@ et@@ Sum += str [ i ] - ' a ' + 1 ; alphab@@ et@@ Sum %= 26 ; } } string sum@@ Str = to_string ( digit@@ Sum ) ; char alphab@@ et@@ Str = char ( alphab@@ et@@ Sum + ' a ' - 1 ) ; sum@@ Str += alphab@@ et@@ Str ; return sum@@ Str ; } int main ( ) { string str = "@@ 365@@ 2@@ ad@@ yz@@ 34@@ 23" ; cout << separ@@ ate@@ Char ( str ) ; return 0 ; }
Number of words in a camel@@ case sequence 8095 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Words ( string str ) { int count = 1 ; for ( int i = 1 ; i < str . length ( ) - 1 ; i ++ ) { if ( is@@ upper ( str [ i ] ) ) count ++ ; } return count ; } int main ( ) { string str = " ge@@ ek@@ sFor@@ Ge@@ e@@ ks " ; cout << count@@ Words ( str ) ; return 0 ; }
Maximum length sub@@ sequence possible of the form R ^ N K ^ N 8174 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find ( string s ) { int max = 0 , i , j = 0 , count@@ k = 0 , coun@@ tr = 0 ; int table [ s . length ( ) ] [ 2 ] ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == ' R ' ) coun@@ tr ++ ; else table [ j ++ ] [ 0 ] = coun@@ tr ; } j -- ; for ( i = s . length ( ) - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == ' K ' ) { count@@ k ++ ; table [ j -- ] [ 1 ] = count@@ k ; } if ( min ( table [ j + 1 ] [ 0 ] , table [ j + 1 ] [ 1 ] ) > max ) max = min ( table [ j + 1 ] [ 0 ] , table [ j + 1 ] [ 1 ] ) ; } return max ; } int main ( ) { string s = " R@@ K@@ RR@@ R@@ KK@@ RR@@ KK@@ KK@@ RR " ; int n = find ( s ) ; cout << ( n ) ; }
Maximum power of jump required to reach the end of string 8181 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int power@@ Of@@ Jump ( string s ) { int count = 1 ; int max_@@ so@@ _f@@ ar = INT_@@ MIN ; char ch = s [ s . length ( ) - 1 ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == ch ) { if ( count > max_@@ so@@ _f@@ ar ) { max_@@ so@@ _f@@ ar = count ; } count = 1 ; } else count ++ ; } return max_@@ so@@ _f@@ ar ; } int main ( ) { string st = "@@ 101@@ 01@@ 01" ; cout << power@@ Of@@ Jump ( st ) ; }
Square of large number represented as String 8201 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; string multiply ( string num1 , string num2 ) { int n1 = num1 . size ( ) ; int n2 = num2 . size ( ) ; if ( n1 == 0 n2 == 0 ) return "0" ; vector < int > result ( n1 + n2 , 0 ) ; int i_@@ n1 = 0 ; int i_@@ n2 = 0 ; for ( int i = n1 - 1 ; i >= 0 ; i -- ) { int carry = 0 ; int n1 = num1 [ i ] - '0' ; i_@@ n2 = 0 ; for ( int j = n2 - 1 ; j >= 0 ; j -- ) { int n2 = num2 [ j ] - '0' ; int sum = n1 * n2 + result [ i_@@ n1 + i_@@ n2 ] + carry ; carry = sum / 10 ; result [ i_@@ n1 + i_@@ n2 ] = sum % 10 ; i_@@ n2 ++ ; } if ( carry > 0 ) result [ i_@@ n1 + i_@@ n2 ] += carry ; i_@@ n1 ++ ; } int i = result . size ( ) - 1 ; while ( i >= 0 && result [ i ] == 0 ) i -- ; if ( i == -1 ) return "0" ; string s = " " ; while ( i >= 0 ) s += std :: to_string ( result [ i -- ] ) ; return s ; } int main ( ) { string str1 = "@@ 45@@ 45@@ 45@@ 45@@ 45@@ 45@@ 45@@ 45@@ 45@@ " ; cout << multiply ( str1 , str1 ) ; return 0 ; }
Check if the given string of words can be formed from words present in the dictionary 8209 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool match_@@ words ( string dictionary [ ] , string sentence [ ] , int n , int m ) { unordered_map < string , int > mp ; for ( int i = 0 ; i < n ; i ++ ) { mp [ dictionary [ i ] ] ++ ; } for ( int i = 0 ; i < m ; i ++ ) { if ( mp [ sentence [ i ] ] ) mp [ sentence [ i ] ] -= 1 ; else return false ; } return true ; } int main ( ) { string dictionary [ ] = { " find " , " a " , " ge@@ e@@ ks " , " all " , " for " , " on " , " ge@@ e@@ ks " , " answers " , " inter " } ; int n = sizeof ( dictionary ) / sizeof ( dictionary [ 0 ] ) ; string sentence [ ] = { " find " , " all " , " answers " , " on " , " ge@@ e@@ ks " , " for " , " ge@@ e@@ ks " } ; int m = sizeof ( sentence ) / sizeof ( sentence [ 0 ] ) ; if ( match_@@ words ( dictionary , sentence , n , m ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
Count sub@@ strings with each character occur@@ ring at most k times 8257 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find_@@ sub ( string s , int k ) { int len = s . length ( ) ; int lp = 0 , rp = 0 ; int ans = 0 ; int hash_@@ char [ 26 ] = { 0 } ; for ( ; rp < len ; rp ++ ) { hash_@@ char [ s [ rp ] - ' a ' ] ++ ; while ( hash_@@ char [ s [ rp ] - ' a ' ] > k ) { hash_@@ char [ s [ lp ] - ' a ' ] -- ; lp ++ ; } ans += rp - lp + 1 ; } return ans ; } int main ( ) { string s = " aa@@ abb " ; int k = 2 ; cout << find_@@ sub ( s , k ) << endl ; }
Transform a string such that it has abcd . . z as a sub@@ sequence 8267 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool transform@@ String ( string & s ) { char ch = ' a ' ; if ( s . size ( ) < 26 ) return false ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( int ( ch ) > int ( ' z ' ) ) break ; if ( s [ i ] <= ch ) { s [ i ] = ch ; ch = char ( int ( ch ) + 1 ) ; } } if ( ch <= ' z ' ) return false ; return true ; } int main ( ) { string str = " aaaaaaaaaaaaaaaa@@ aaaaaaaa@@ aa " ; if ( transform@@ String ( str ) ) cout << str << endl ; else cout << " Not ▁ Possible " << endl ; return 0 ; }
Remove all the pal@@ ind@@ ro@@ mic words from the given sentence 8296 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Pal@@ ind@@ ro@@ me ( string str ) { int i = 0 , j = str . size ( ) - 1 ; while ( i < j ) if ( str [ i ++ ] != str [ j -- ] ) return false ; return true ; } string remove@@ Pal@@ in@@ Words ( string str ) { string final_@@ str = " " , word = " " ; str = str + " ▁ " ; int n = str . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] != ' ▁ ' ) word = word + str [ i ] ; else { if ( ! ( is@@ Pal@@ ind@@ ro@@ me ( word ) ) ) final_@@ str += word + " ▁ " ; word = " " ; } } return final_@@ str ; } int main ( ) { string str = " Text ▁ contains ▁ mal@@ ay@@ al@@ am ▁ and ▁ level ▁ words " ; cout << remove@@ Pal@@ in@@ Words ( str ) ; return 0 ; }
Print given sentence into its equivalent ASCII form 8352 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void ASCI@@ IS@@ ent@@ ence ( std :: string str ) { int l = str . length ( ) ; int convert ; for ( int i = 0 ; i < l ; i ++ ) { convert = str [ i ] - NULL ; cout << convert ; } } int main ( ) { string str = " Ge@@ ek@@ s@@ for@@ Ge@@ e@@ ks " ; cout << " ASCII ▁ Sentence : " << std :: endl ; ASCI@@ IS@@ ent@@ ence ( str ) ; return 0 ; }
Sn@@ ake case of a given sentence 8354 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void convert ( string str ) { int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . at ( i ) == ' ▁ ' ) str . at ( i ) = ' _ ' ; else str . at ( i ) = tolower ( str . at ( i ) ) ; } cout << str ; } int main ( ) { string str = " I ▁ got ▁ intern ▁ at ▁ ge@@ ek@@ s@@ forge@@ e@@ ks " ; convert ( str ) ; return 0 ; }
Next word that does not contain a pal@@ ind@@ ro@@ me and has characters from first k 8363 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ Next@@ Word ( string s , int m ) { m += 97 ; int n = s . length ( ) ; int i = s . length ( ) - 1 ; s [ i ] ++ ; while ( i >= 0 && i <= n - 1 ) { if ( s [ i ] >= m ) { s [ i ] = ' a ' ; s [ -- i ] ++ ; } else if ( s [ i ] == s [ i - 1 ] s [ i ] == s [ i - 2 ] ) s [ i ] ++ ; else i ++ ; } if ( i <= -1 ) cout << " - 1" ; else cout << s ; } int main ( ) { string str = " abcd " ; int k = 4 ; find@@ Next@@ Word ( str , k ) ; return 0 ; }
Lex@@ ico@@ graphic@@ ally next string 8412 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; string next@@ Word ( string s ) { if ( s == " " ) return " a " ; int i = s . length ( ) - 1 ; while ( s [ i ] == ' z ' && i >= 0 ) i -- ; if ( i == -1 ) s = s + ' a ' ; else s [ i ] ++ ; return s ; } int main ( ) { string str = " same@@ z " ; cout << next@@ Word ( str ) ; return 0 ; }
Least number of manipul@@ ations needed to ensure two strings have identical characters 8472 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; const int MAX_@@ CHAR = 26 ; int least@@ Count ( string s1 , string s2 , int n ) { int count@@ 1 [ MAX_@@ CHAR ] = { 0 } ; int count2 [ MAX_@@ CHAR ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { count@@ 1 [ s1 [ i ] - ' a ' ] += 1 ; count2 [ s2 [ i ] - ' a ' ] += 1 ; } int res = 0 ; for ( int i = 0 ; i < MAX_@@ CHAR ; i ++ ) { if ( count@@ 1 [ i ] != 0 ) { res += abs ( count@@ 1 [ i ] - count2 [ i ] ) ; } } return res ; } int main ( ) { string s1 = " abc " ; string s2 = " c@@ dd " ; int len = s1 . length ( ) ; int res = least@@ Count ( s1 , s2 , len ) ; cout << res << endl ; return 0 ; }
Print the longest common substring 8479 | #@@ include <@@ io@@ stream@@ > NEW_LINE #@@ include <@@ std@@ lib@@ .@@ h@@ > NEW_LINE #@@ include <@@ string@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ LC@@ Sub@@ Str ( char * X , char * Y , int m , int n ) { int LC@@ Su@@ ff [ m + 1 ] [ n + 1 ] ; int len = 0 ; int row , col ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) LC@@ Su@@ ff [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) { LC@@ Su@@ ff [ i ] [ j ] = LC@@ Su@@ ff [ i - 1 ] [ j - 1 ] + 1 ; if ( len < LC@@ Su@@ ff [ i ] [ j ] ) { len = LC@@ Su@@ ff [ i ] [ j ] ; row = i ; col = j ; } } else LC@@ Su@@ ff [ i ] [ j ] = 0 ; } } if ( len == 0 ) { cout << " No ▁ Common ▁ Sub@@ string " ; return ; } char * result@@ Str = ( char * ) malloc ( ( len + 1 ) * sizeof ( char ) ) ; while ( LC@@ Su@@ ff [ row ] [ col ] != 0 ) { row -- ; col -- ; } cout << result@@ Str ; } int main ( ) { char X [ ] = " Old@@ Site : Ge@@ ek@@ s@@ for@@ Ge@@ e@@ ks . org " ; char Y [ ] = " New@@ Site : Ge@@ ek@@ s@@ Qu@@ iz . com " ; int m = strlen ( X ) ; int n = strlen ( Y ) ; print@@ LC@@ Sub@@ Str ( X , Y , m , n ) ; return 0 ; }
Convert all sub@@ strings of length ' k ' from base ' b ' to decimal 8488 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int sub@@ string@@ Conversions ( string str , int k , int b ) { for ( int i = 0 ; i + k <= str . size ( ) ; i ++ ) { string sub = str . substr ( i , k ) ; int sum = 0 , counter = 0 ; for ( int i = sub . size ( ) - 1 ; i >= 0 ; i -- ) { sum = sum + ( ( sub . at ( i ) - '0' ) * pow ( b , counter ) ) ; counter ++ ; } cout << sum << " ▁ " ; } } int main ( ) { string str = "12@@ 2@@ 12" ; int b = 3 , k = 3 ; sub@@ string@@ Conversions ( str , b , k ) ; return 0 ; }
Check if both hal@@ ves of the string have same set of characters 8513 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; const int MAX_@@ CHAR = 26 ; bool check@@ Correct@@ Or@@ Not ( string s ) { int count@@ 1 [ MAX_@@ CHAR ] = { 0 } ; int count2 [ MAX_@@ CHAR ] = { 0 } ; int n = s . length ( ) ; if ( n == 1 ) return true ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { count@@ 1 [ s [ i ] - ' a ' ] ++ ; count2 [ s [ j ] - ' a ' ] ++ ; } for ( int i = 0 ; i < MAX_@@ CHAR ; i ++ ) if ( count@@ 1 [ i ] != count2 [ i ] ) return false ; return true ; } int main ( ) { string s = " ab@@ ab " ; if ( check@@ Correct@@ Or@@ Not ( s ) ) cout << " Yes STRNEWLINE " ; else cout << " No STRNEWLINE " ; return 0 ; }
Remain@@ der with 7 for large numbers 8661 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int remain@@ der@@ With@@ 7 ( string num ) { int series [ ] = { 1 , 3 , 2 , -1 , -@@ 3 , -2 } ; int series_@@ index = 0 ; for ( int i = num . size ( ) - 1 ; i >= 0 ; i -- ) { int digit = num [ i ] - '0' ; result += digit * series [ series_@@ index ] ; series_@@ index = ( series_@@ index + 1 ) % 6 ; result %= 7 ; } if ( result < 0 ) result = ( result + 7 ) % 7 ; return result ; } int main ( ) { string str = "12345" ; cout << " Remain@@ der ▁ with ▁ 7 ▁ is ▁ " << remain@@ der@@ With@@ 7 ( str ) ; return 0 ; }
Check if a string has all characters with same frequency with one variation allowed 8663 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; const int CHARS = 26 ; bool isValid@@ String ( string str ) { int freq [ CHARS ] = { 0 } ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) freq [ str [ i ] - ' a ' ] ++ ; int i , fre@@ q1 = 0 , count_@@ fre@@ q1 = 0 ; for ( i = 0 ; i < CHARS ; i ++ ) { if ( freq [ i ] != 0 ) { fre@@ q1 = freq [ i ] ; count_@@ fre@@ q1 = 1 ; break ; } } int j , fre@@ q2 = 0 , count_@@ fre@@ q2 = 0 ; for ( j = i + 1 ; j < CHARS ; j ++ ) { if ( freq [ j ] != 0 ) { if ( freq [ j ] == fre@@ q1 ) count_@@ fre@@ q1 ++ ; else { count_@@ fre@@ q2 = 1 ; fre@@ q2 = freq [ j ] ; break ; } } } for ( int k = j + 1 ; k < CHARS ; k ++ ) { if ( freq [ k ] != 0 ) { if ( freq [ k ] == fre@@ q1 ) count_@@ fre@@ q1 ++ ; if ( freq [ k ] == fre@@ q2 ) count_@@ fre@@ q2 ++ ; return false ; } if ( count_@@ fre@@ q1 > 1 && count_@@ fre@@ q2 > 1 ) return false ; } return true ; } int main ( ) { char str [ ] = " ab@@ cbc " ; if ( isValid@@ String ( str ) ) cout << " YES " << endl ; else cout << " NO " << endl ; return 0 ; }
Perf@@ ect rever@@ sible string 8666 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Rever@@ sible ( string str ) { int i = 0 , j = str . length ( ) - 1 ; while ( i < j ) { if ( str [ i ] != str [ j ] ) return false ; i ++ ; j -- ; } return true ; } int main ( ) { string str = " aba " ; if ( is@@ Rever@@ sible ( str ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
Find all strings that match specific pattern in a dictionary 8675 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; string encode@@ String ( string str ) { unordered_map < char , int > map ; string res = " " ; int i = 0 ; for ( char ch : str ) { if ( map . find ( ch ) == map . end ( ) ) map [ ch ] = i ++ ; res += to_string ( map [ ch ] ) ; } return res ; } void find@@ Matched@@ Words ( unordered_@@ set < string > dict , string pattern ) { int len = pattern . length ( ) ; string hash = encode@@ String ( pattern ) ; for ( string word : dict ) { if ( word . length ( ) == len && encode@@ String ( word ) == hash ) cout << word << " ▁ " ; } } int main ( ) { unordered_@@ set < string > dict = { " abb " , " abc " , " xyz " , " xy@@ y " } ; string pattern = " foo " ; find@@ Matched@@ Words ( dict , pattern ) ; return 0 ; }
Find all strings that match specific pattern in a dictionary 8676 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool check ( string pattern , string word ) { if ( pattern . length ( ) != word . length ( ) ) return false ; char ch [ 128 ] = { 0 } ; int len = word . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( ch [ pattern [ i ] ] == 0 ) ch [ pattern [ i ] ] = word [ i ] ; else if ( ch [ pattern [ i ] ] != word [ i ] ) return false ; } return true ; } void find@@ Matched@@ Words ( unordered_@@ set < string > dict , string pattern ) { int len = pattern . length ( ) ; for ( string word : dict ) { if ( check ( pattern , word ) ) cout << word << " ▁ " ; } } int main ( ) { unordered_@@ set < string > dict = { " abb " , " abc " , " xyz " , " xy@@ y " } ; string pattern = " foo " ; find@@ Matched@@ Words ( dict , pattern ) ; return 0 ; }
Conver@@ ting Decimal Number ly@@ ing between 1 to 3@@ 999 to Roman Numer@@ als 8682 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; string int@@ To@@ Roman ( int num ) { string m [ ] = { " " , " M " , " MM " , " MMM " } ; string c [ ] = { " " , " C " , " CC " , " CC@@ C " , " CD " , " D " , " DC " , " D@@ CC " , " D@@ CC@@ C " , " CM " } ; string x [ ] = { " " , " X " , " XX " , " XXX " , " X@@ L " , " L " , " L@@ X " , " L@@ XX " , " L@@ XXX " , " X@@ C " } ; string i [ ] = { " " , " I " , " II " , " III " , " IV " , " V " , " VI " , " VI@@ I " , " VI@@ II " , " IX " } ; string thous@@ ands = m [ num / 1000 ] ; string hun@@ dere@@ ds = c [ ( num % 1000 ) / 100 ] ; string ten@@ s = x [ ( num % 100 ) / 10 ] ; string ones = i [ num % 10 ] ; string ans = thous@@ ands + hun@@ dere@@ ds + ten@@ s + ones ; return ans ; } int main ( ) { int number = 35@@ 49 ; cout << int@@ To@@ Roman ( number ) ; return 0 ; }
Print Concaten@@ ation of Z@@ ig 8708 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; string zig@@ Z@@ ag@@ Concat ( string s , int n ) { if ( n <= 1 ) { return s ; } string result = " " ; for ( int row@@ Num = 0 ; row@@ Num < n ; row@@ Num ++ ) { int i = row@@ Num ; bool up = true ; while ( i < s . length ( ) ) { result += s [ i ] ; if ( row@@ Num == 0 row@@ Num == n - 1 ) { i += ( 2 * n - 2 ) ; } else { if ( up ) { i += ( 2 * ( n - row@@ Num ) - 2 ) ; } else { i += row@@ Num * 2 ; } up ^= true ; } } } return result ; } int main ( ) { string str = " GE@@ EK@@ S@@ FOR@@ GE@@ E@@ KS " ; int n = 3 ; cout << zig@@ Z@@ ag@@ Concat ( str , n ) ; }
Maximum Bit@@ wise XOR of node values of an Ac@@ y@@ clic Graph made up of N given vertices using M edges 8815 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int maximum@@ XOR ( int arr [ ] , int n , int K ) { K ++ ; int max@@ Xor = INT_@@ MIN ; for ( int i = 0 ; i < ( 1 << n ) ; i ++ ) { if ( __builtin@@ _pop@@ count ( i ) == K ) { int cur_@@ xor = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( i & ( 1 << j ) ) cur_@@ xor = cur_@@ xor ^ arr [ j ] ; } max@@ Xor = max ( max@@ Xor , cur_@@ xor ) ; } } return max@@ Xor ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int N = sizeof ( arr ) / sizeof ( int ) ; int M = 2 ; cout << maximum@@ XOR ( arr , N , M ) ; return 0 ; }
To@@ wer of H@@ ano@@ i | Set 2 8817 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void Tower@@ Of@@ H@@ ano@@ i ( int N ) { for ( int x = 1 ; x <= pow ( 2 , N ) - 1 ; x ++ ) { cout << " Move ▁ from ▁ Ro@@ d ▁ " << ( ( x & x - 1 ) % 3 + 1 ) << " ▁ to ▁ Ro@@ d ▁ " << ( ( ( x x - 1 ) + 1 ) % 3 + 1 ) << endl ; } } int main ( ) { int N = 3 ; Tower@@ Of@@ H@@ ano@@ i ( N ) ; return 0 ; }
Check if a path exists from a given cell to any boundary element of the Matrix with sum of elements not exce@@ eding K 8818 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool isValid ( vector < vector < int > > & board , int i , int j , int K ) { if ( board [ i ] [ j ] <= K ) { return true ; } return false ; } bool find@@ Path ( vector < vector < int > > & board , int X , int Y , int M , int N , int K ) { if ( X < 0 X == M Y < 0 Y == N ) { return true ; } if ( isValid ( board , X , Y , K ) ) { int board_@@ XY = board [ X ] [ Y ] ; board [ X ] [ Y ] = INT_MAX ; if ( find@@ Path ( board , X + 1 , Y , M , N , K - board_@@ XY ) || find@@ Path ( board , X - 1 , Y , M , N , K - board_@@ XY ) || find@@ Path ( board , X , Y + 1 , M , N , K - board_@@ XY ) || find@@ Path ( board , X , Y - 1 , M , N , K - board_@@ XY ) ) { return true ; } board [ X ] [ Y ] = board_@@ XY ; } return false ; } int main ( ) { vector < vector < int > > grid = { { 25 , 5 , 25 , 25 , 25 , 25 } , { 25 , 1 , 1 , 5 , 12 , 25 } , { 25 , 1 , 12 , 0 , 15 , 25 } , { 22 , 1 , 11 , 2 , 19 , 15 } , { 25 , 2 , 2 , 1 , 12 , 15 } , { 25 , 9 , 10 , 1 , 11 , 25 } , { 25 , 25 , 25 , 25 , 25 , 25 } } ; int K = 17 ; int M = grid . size ( ) ; int N = grid [ 0 ] . size ( ) ; int X = 2 , Y = 3 ; if ( find@@ Path ( grid , X , Y , M , N , K ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
Pen Distribution Problem 8827 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void solve ( int & N , int & P1 , int & P2 , int & X , bool Move , bool Quit@@ P1 , bool Quit@@ P2 ) { if ( N == 0 or ( Quit@@ P1 and Quit@@ P2 ) ) { cout << " Number ▁ of ▁ p@@ ens ▁ remaining " << " ▁ in ▁ the ▁ box : ▁ " << N << endl ; cout << " Number ▁ of ▁ p@@ ens ▁ collected " << " ▁ by ▁ P1 : ▁ " << P1 << endl ; cout << " Number ▁ of ▁ p@@ ens ▁ collected " << " ▁ by ▁ P2 : ▁ " << P2 << endl ; return ; } if ( Move == 0 and Quit@@ P1 == false ) { int req_@@ P1 = pow ( 2 , X ) ; if ( req_@@ P1 <= N ) { P1 += req_@@ P1 ; N -= req_@@ P1 ; } else { Quit@@ P1 = true ; } } else if ( Move == 1 and Quit@@ P2 == false ) { int req_@@ P2 = pow ( 3 , X ) ; if ( req_@@ P2 <= N ) { P2 += req_@@ P2 ; N -= req_@@ P2 ; } else { Quit@@ P2 = true ; } } X ++ ; Move = ( ( Move == 1 ) ? 0 : 1 ) ; solve ( N , P1 , P2 , X , Move , Quit@@ P1 , Quit@@ P2 ) ; } void Pen@@ Game ( int N ) { int P1 = 0 ; int P2 = 0 ; int X = 0 ; bool Move = 0 ; bool Quit@@ P1 = 0 ; bool Quit@@ P2 = 0 ; solve ( N , P1 , P2 , X , Move , Quit@@ P1 , Quit@@ P2 ) ; } int main ( ) { int N = 22 ; Pen@@ Game ( N ) ; return 0 ; }
Place the pri@@ son@@ ers into cells to maxim@@ ize the minimum difference between any two 8922 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool can@@ Place ( int a [ ] , int n , int p , int sep ) { int pri@@ son@@ er@@ s_@@ placed = 1 ; int last_@@ pri@@ son@@ er_@@ placed = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { int current_@@ cell = a [ i ] ; if ( current_@@ cell - last_@@ pri@@ son@@ er_@@ placed >= sep ) { pri@@ son@@ er@@ s_@@ placed ++ ; last_@@ pri@@ son@@ er_@@ placed = current_@@ cell ; if ( pri@@ son@@ er@@ s_@@ placed == p ) { return true ; } } } return false ; } int max@@ Distance ( int cell [ ] , int n , int p ) { sort ( cell , cell + n ) ; int start = 0 ; int end = cell [ n - 1 ] - cell [ 0 ] ; int ans = 0 ; while ( start <= end ) { int mid = start + ( ( end - start ) / 2 ) ; if ( can@@ Place ( cell , n , p , mid ) ) { ans = mid ; start = mid + 1 ; } else { end = mid - 1 ; } } return ans ; } int main ( ) { int cell [ ] = { 1 , 2 , 8 , 4 , 9 } ; int n = sizeof ( cell ) / sizeof ( int ) ; int p = 3 ; cout << max@@ Distance ( cell , n , p ) ; return 0 ; }
S@@ malle@@ st sub@@ array with GC@@ D as 1 | Segment Tree 8925 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define maxLen 30 NEW_LINE int seg [ 3 * maxLen ] ; int build ( int l , int r , int in , int * arr ) { if ( l == r ) return seg [ in ] = arr [ l ] ; int mid = ( l + r ) / 2 ; return seg [ in ] = __@@ gcd ( build ( l , mid , 2 * in + 1 , arr ) , build ( mid + 1 , r , 2 * in + 2 , arr ) ) ; } int query ( int l , int r , int l1 , int r1 , int in ) { if ( l1 <= l and r <= r1 ) return seg [ in ] ; if ( l > r1 or r < l1 ) return 0 ; int mid = ( l + r ) / 2 ; return __@@ gcd ( query ( l , mid , l1 , r1 , 2 * in + 1 ) , query ( mid + 1 , r , l1 , r1 , 2 * in + 2 ) ) ; } int find@@ Len ( int * arr , int n ) { build ( 0 , n - 1 , 0 , arr ) ; int i = 0 , j = 0 ; int ans = INT_MAX ; while ( i < n ) { while ( j < n and query ( 0 , n - 1 , i , j , 0 ) != 1 ) j ++ ; if ( j == n ) break ; ans = min ( ( j - i + 1 ) , ans ) ; i ++ ; j = max ( j , i ) ; } if ( ans == INT_MAX ) return -1 ; else return ans ; } int main ( ) { int arr [ ] = { 2 , 2 , 2 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << find@@ Len ( arr , n ) ; return 0 ; }
Program to calculate Surface Area of Ellip@@ soid 8989 | #@@ include <@@ io@@ manip@@ > NEW_LINE #@@ include <@@ io@@ stream@@ > NEW_LINE #@@ include <@@ math@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ Area ( double a , double b , double c ) { double area = 4 * 3.1415@@ 9265@@ 3 * pow ( ( pow ( a * b , 1.6 ) + pow ( a * c , 1.6 ) + pow ( b * c , 1.6 ) ) / 3 , 1 / 1.6 ) ; cout << fixed << setprecision ( 2 ) << area ; } int main ( ) { double A = 11 , B = 12 , C = 13 ; find@@ Area ( A , B , C ) ; return 0 ; }
Desc@@ ar@@ tes ' Circle The@@ o@@ rem with implementation 8991 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; double find@@ Radius ( double r1 , double r2 , double r3 ) { double r4 = ( r1 * r2 * r3 ) / ( r1 * r2 + r2 * r3 + r1 * r3 + 2.0 * sqrt ( r1 * r2 * r3 * ( r1 + r2 + r3 ) ) ) ; return r4 ; } int main ( ) { double r1 = 1 ; double r2 = 1 ; double r3 = 1 ; double r4 = find@@ Radius ( r1 , r2 , r3 ) ; cout << " The ▁ radius ▁ of ▁ fourth ▁ circle : ▁ " << r4 ; return 0 ; }
Make N pairs from Array as ( X , Y ) coordinate point that are enclosed inside a minimum area rectangle 8995 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int minimum@@ Rectangle@@ Area ( int A [ ] , int N ) { int ans ; sort ( A , A + 2 * N ) ; ans = ( A [ N - 1 ] - A [ 0 ] ) * ( A [ 2 * N - 1 ] - A [ N ] ) ; for ( int i = 1 ; i < N ; i ++ ) ans = min ( ans , ( A [ 2 * N - 1 ] - A [ 0 ] ) * ( A [ i + N - 1 ] - A [ i ] ) ) ; return ans ; } int main ( ) { int A [ ] = { 2 , 4 , 1 , 5 , 3 , 6 , 7 , 8 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; N /= 2 ; cout << minimum@@ Rectangle@@ Area ( A , N ) << endl ; return 0 ; }
Program to find the E@@ cc@@ entri@@ city of a Hyper@@ bo@@ la 9009 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; double ec@@ c@@ Hyper@@ bo@@ la ( double A , double B ) { double r = ( double ) B * B / A * A ; r += 1 ; return sqrt ( r ) ; } int main ( ) { double A = 3.0 , B = 2.0 ; cout << ec@@ c@@ Hyper@@ bo@@ la ( A , B ) ; return 0 ; }
Calculate area of a cyclic quad@@ ri@@ later@@ al with given side lengths 9012 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; float calculate@@ Area ( float A , float B , float C , float D ) { float S = ( A + B + C + D ) / 2 ; float area = sqrt ( ( S - A ) * ( S - B ) * ( S - C ) * ( S - D ) ) ; return area ; } int main ( ) { float A = 10 ; float B = 15 ; float C = 20 ; float D = 25 ; cout << calculate@@ Area ( A , B , C , D ) ; return 0 ; }
Number of largest circ@@ les that can be in@@ scri@@ bed in a rectangle 9025 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int total@@ Cir@@ cles ( int L , int B ) { if ( L > B ) { int temp = L ; L = B ; B = temp ; } return B / L ; } int main ( ) { int L = 3 ; int B = 8 ; cout << total@@ Cir@@ cles ( L , B ) ; return 0 ; }
Radius of a circle having area equal to the sum of area of the circ@@ les having given radii 9043 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; double find@@ Radius ( double r1 , double r2 ) { double a1 , a2 , a3 , r3 ; a1 = 3.14 * r1 * r1 ; a2 = 3.14 * r2 * r2 ; a3 = a1 + a2 ; r3 = sqrt ( a3 / 3.14 ) ; return r3 ; } int main ( ) { double r1 = 8 , r2 = 6 ; cout << find@@ Radius ( r1 , r2 ) ; return 0 ; }
Minimum number of Cu@@ bo@@ ids required to form a Cube 9044 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find_@@ l@@ cm ( int a , int b , int c ) { int g = __@@ gcd ( a , b ) ; int L@@ CM@@ 1 = ( a * b ) / g ; g = __@@ gcd ( L@@ CM@@ 1 , c ) ; int LC@@ M = ( L@@ CM@@ 1 * c ) / g ; return LC@@ M ; } void minimum@@ Cu@@ bo@@ ids ( int L , int B , int H ) { int l@@ cm = find_@@ l@@ cm ( L , B , H ) ; int volume_@@ cube = l@@ cm * l@@ cm * l@@ cm ; int volume_@@ cu@@ bo@@ id = L * B * H ; cout << ( volume_@@ cube / volume_@@ cu@@ bo@@ id ) ; } int main ( ) { int L = 1 , B = 1 , H = 2 ; minimum@@ Cu@@ bo@@ ids ( L , B , H ) ; return 0 ; }
Check if given polygon is a convex polygon or not 9046 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int Cross@@ Product ( vector < vector < int > > & A ) { int X1 = ( A [ 1 ] [ 0 ] - A [ 0 ] [ 0 ] ) ; int Y1 = ( A [ 1 ] [ 1 ] - A [ 0 ] [ 1 ] ) ; int X2 = ( A [ 2 ] [ 0 ] - A [ 0 ] [ 0 ] ) ; int Y2 = ( A [ 2 ] [ 1 ] - A [ 0 ] [ 1 ] ) ; return ( X1 * Y2 - Y1 * X2 ) ; } bool is@@ Con@@ vex ( vector < vector < int > > & points ) { int N = points . size ( ) ; int prev = 0 ; int curr = 0 ; for ( int i = 0 ; i < N ; i ++ ) { vector < vector < int > > temp = { points [ i ] , points [ ( i + 1 ) % N ] , points [ ( i + 2 ) % N ] } ; curr = Cross@@ Product ( temp ) ; if ( curr != 0 ) { if ( curr * prev < 0 ) { return false ; } else { prev = curr ; } } } return true ; } int main ( ) { vector < vector < int > > points = { { 0 , 0 } , { 0 , 1 } , { 1 , 1 } , { 1 , 0 } } ; if ( is@@ Con@@ vex ( points ) ) { cout << " Yes " << " STRNEWLINE " ; } else { cout << " No " << " STRNEWLINE " ; } }
Distance between In@@ center and Cir@@ cum@@ center of a triangle using In@@ radius and Cir@@ cum@@ radius 9069 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; double distance ( int r , int R ) { double d = sqrt ( pow ( R , 2 ) - ( 2 * r * R ) ) ; return d ; } int main ( ) { int r = 2 ; int R = 5 ; cout << ( round ( distance ( r , R ) * 100.0 ) / 100.0 ) ; }
Find the angle of Rot@@ ational Sym@@ metry of an N 9078 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; double min@@ An@@ gl@@ Rot ( int N ) { double res ; res = 360 / ( double ) N ; return res ; } int main ( ) { int N = 4 ; cout << " Angle ▁ of ▁ Rot@@ ational ▁ Sym@@ metry : ▁ " << min@@ An@@ gl@@ Rot ( N ) ; return 0 ; }
Area of a Triangle from the given lengths of medi@@ ans 9080 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; double Area@@ _@@ of_@@ Triangle ( int a , int b , int c ) { int s = ( a + b + c ) / 2 ; int x = s * ( s - a ) ; x = x * ( s - b ) ; x = x * ( s - c ) ; double area = ( 4 / ( double ) 3 ) * sqrt ( x ) ; return area ; } int main ( ) { int a = 9 ; int b = 12 ; int c = 15 ; double ans = Area@@ _@@ of_@@ Triangle ( a , b , c ) ; cout << ans ; }
Program to check if N is a Tri@@ dec@@ ag@@ onal Number or not 9100 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Tri@@ dec@@ ag@@ on ( int N ) { float n = ( 9 + sqrt ( 88 * N + 81 ) ) / 22 ; return ( n - ( int ) n ) == 0 ; } int main ( ) { int i = 13 ; if ( is@@ Tri@@ dec@@ ag@@ on ( i ) ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
Check if any point overlaps the given Circle and Rectangle 9117 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool check@@ Overlap ( int R , int X@@ c , int Y@@ c , int X1 , int Y1 , int X2 , int Y2 ) { int X@@ n = max ( X1 , min ( X@@ c , X2 ) ) ; int Y@@ n = max ( Y1 , min ( Y@@ c , Y2 ) ) ; int D@@ x = X@@ n - X@@ c ; int D@@ y = Y@@ n - Y@@ c ; return ( D@@ x * D@@ x + D@@ y * D@@ y ) <= R * R ; } int main ( ) { int R = 1 ; int X@@ c = 0 , Y@@ c = 0 ; int X1 = 1 , Y1 = -1 ; int X2 = 3 , Y2 = 1 ; if ( check@@ Overlap ( R , X@@ c , Y@@ c , X1 , Y1 , X2 , Y2 ) ) { cout << " True " << endl ; } else { cout << " False " ; } }
Check if the tower of sig@@ ht issue occurs or not 9120 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int check@@ Intersection ( pair < int , int > p1 , pair < int , int > p2 , pair < int , int > p ) { int val ; if ( p1 . second == p2 . second && p1 . second == p . second ) { if ( p . first <= max ( p1 . first , p2 . first ) && ( p . first >= min ( p1 . first , p2 . first ) ) ) return 1 ; } if ( p1 . first == p2 . first && p1 . first == p . first ) { if ( p . second <= max ( p1 . second , p2 . second ) && ( p . second >= min ( p1 . second , p2 . second ) ) ) return 1 ; } else { val = ( p . second - p1 . second ) * ( p2 . first - p1 . first ) - ( p . first - p1 . first ) * ( p2 . second - p1 . second ) ; if ( val == 0 ) if ( ( p . first <= max ( p1 . first , p2 . first ) && ( p . first >= min ( p1 . first , p2 . first ) ) ) && ( p . second <= max ( p1 . second , p2 . second ) && ( p . second >= min ( p1 . second , p2 . second ) ) ) ) return 1 ; } return 0 ; } void to@@ wer@@ OfS@@ ight ( pair < int , int > a , pair < int , int > b , pair < int , int > c , pair < int , int > d ) { int flag = 0 ; if ( check@@ Intersection ( a , c , b ) ) flag = 1 ; else if ( check@@ Intersection ( a , c , d ) ) flag = 1 ; else if ( check@@ Intersection ( b , d , a ) ) flag = 1 ; else if ( check@@ Intersection ( b , d , c ) ) flag = 1 ; flag ? cout << " Yes STRNEWLINE " : cout << " No STRNEWLINE " ; } int main ( ) { pair < int , int > a = { 0 , 0 } ; pair < int , int > b = { 0 , -2 } ; pair < int , int > c = { 2 , 0 } ; pair < int , int > d = { 0 , 2 } ; to@@ wer@@ OfS@@ ight ( a , b , c , d ) ; return 0 ; }
Area of Equ@@ il@@ ater@@ al triangle in@@ scri@@ bed in a Circle of radius R 9129 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; double area ( int R ) { double base = 1.7@@ 32 * R ; double height = ( 1.5 ) * R ; double area = 0.5 * base * height ; return area ; } int main ( ) { int R = 7 ; cout << ( area ( R ) ) ; return 0 ; }
Number of pairs of lines having integer intersection points 9137 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Pairs ( int * P , int * Q , int N , int M ) { int A [ 2 ] = { 0 } , B [ 2 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) A [ P [ i ] % 2 ] ++ ; for ( int i = 0 ; i < M ; i ++ ) B [ Q [ i ] % 2 ] ++ ; return ( A [ 0 ] * B [ 0 ] + A [ 1 ] * B [ 1 ] ) ; } int main ( ) { int P [ ] = { 1 , 3 , 2 } , Q [ ] = { 3 , 0 } ; int N = sizeof ( P ) / sizeof ( P [ 0 ] ) ; int M = sizeof ( Q ) / sizeof ( Q [ 0 ] ) ; cout << count@@ Pairs ( P , Q , N , M ) ; return 0 ; }
Percentage change in He@@ mi@@ sphere volume if radius is changed 9138 | #@@ include <@@ io@@ stream@@ > NEW_LINE #@@ include <@@ math@@ .@@ h@@ > NEW_LINE using namespace std ; void new_@@ vol ( double x ) { if ( x > 0 ) { cout << " % ▁ change ▁ in ▁ the ▁ " << " volume ▁ of ▁ the ▁ he@@ mi@@ sphere : ▁ " << pow ( x , 3 ) / 10000 + 3 * x + ( 3 * pow ( x , 2 ) ) / 100 << " % " << " ▁ increase STRNEWLINE " ; } else if ( x < 0 ) { cout << " % ▁ change ▁ in ▁ the ▁ " << " volume ▁ of ▁ the ▁ he@@ mi@@ sphere : ▁ " << pow ( x , 3 ) / 10000 + 3 * x + ( 3 * pow ( x , 2 ) ) / 100 << " % ▁ decrease STRNEWLINE " ; } else { cout << " Volume ▁ remains ▁ the ▁ same . " ; } } int main ( ) { double x = -@@ 10.0 ; new_@@ vol ( x ) ; return 0 ; }
Maximum number of line intersections formed through intersection of N planes 9147 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Intersections ( int n ) { return n * ( n - 1 ) / 2 ; } int main ( ) { int n = 3 ; cout << count@@ Intersections ( n ) ; return 0 ; }
Find the area of quad@@ ri@@ later@@ al when diagonal and the per@@ pendic@@ ular@@ s to it from opposite vertices are given 9154 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; float Area ( int d , int h1 , int h2 ) { float area ; area = 0.5 * d * ( h1 + h2 ) ; return area ; } int main ( ) { int d = 6 , h1 = 4 , h2 = 3 ; cout << " Area ▁ of ▁ Quad@@ ri@@ later@@ al ▁ = ▁ " << ( Area ( d , h1 , h2 ) ) ; return 0 ; }
Exter@@ ior angle of a cyclic quad@@ ri@@ later@@ al when the opposite interior angle is given 9184 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void angle@@ ext@@ cy@@ c@@ quad ( int z ) { cout << " The ▁ exter@@ ior ▁ angle ▁ of ▁ the " << " ▁ cyclic ▁ quad@@ ri@@ later@@ al ▁ is ▁ " << z << " ▁ degrees " << endl ; } int main ( ) { int z = 48 ; angle@@ ext@@ cy@@ c@@ quad ( z ) ; return 0 ; }
Print all Perf@@ ect Numbers from an array whose sum of digits is also a Perf@@ ect Number 10000 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int is@@ Perf@@ ect ( int N ) { int sum@@ Of@@ Di@@ visors = 1 ; for ( int i = 2 ; i <= N / 2 ; ++ i ) { if ( N % i == 0 ) { sum@@ Of@@ Di@@ visors += i ; } } if ( sum@@ Of@@ Di@@ visors == N ) { return 1 ; } else return 0 ; } int sum@@ Of@@ Digits ( int N ) { int sum = 0 ; while ( N != 0 ) { sum += ( N % 10 ) ; N = N / 10 ; } return sum ; } void count@@ Per@@ fec@@ t@@ Numbers ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; ++ i ) { if ( is@@ Perf@@ ect ( arr [ i ] ) ) { int sum = sum@@ Of@@ Digits ( arr [ i ] ) ; if ( is@@ Perf@@ ect ( sum ) ) { cout << arr [ i ] << " ▁ " ; } } } } int main ( ) { int arr [ ] = { 3 , 8 , 12 , 28 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; count@@ Per@@ fec@@ t@@ Numbers ( arr , N ) ; return 0 ; }
Fi@@ zz Bu@@ zz Implementation | Set 2 10013 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void fi@@ zz@@ Bu@@ zz ( int N ) { int count@@ 3 = 0 ; int count@@ 5 = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { count@@ 3 ++ ; count@@ 5 ++ ; bool flag = false ; if ( count@@ 3 == 3 ) { cout << " Fi@@ zz " ; count@@ 3 = 0 ; flag = true ; } if ( count@@ 5 == 5 ) { cout << " Bu@@ zz " ; count@@ 5 = 0 ; flag = true ; } if ( ! flag ) { cout << i ; } cout << " ▁ " ; } } int main ( ) { int N = 15 ; fi@@ zz@@ Bu@@ zz ( N ) ; return 0 ; }
Count pairs from an array having equal sum and quotient 10016 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Pairs ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( a [ j ] != 0 && a [ i ] % a [ j ] == 0 ) { if ( ( a [ i ] + a [ j ] ) == ( a [ i ] / a [ j ] ) ) count ++ ; } } } return count ; } int main ( ) { int arr [ ] = { -@@ 4 , -@@ 3 , 0 , 2 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << count@@ Pairs ( arr , N ) ; return 0 ; }
Count tiles of dimensions 2 * 1 that can be placed in an M * N rect@@ angular board that satis@@ fies the given conditions 10021 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int numberOf@@ Tiles ( int N , int M ) { if ( N % 2 == 1 ) { return -1 ; } return ( N * 1@@ LL * M ) / 2 ; } int main ( ) { int N = 2 , M = 4 ; cout << numberOf@@ Tiles ( N , M ) ; return 0 ; }
Check if a pair of integers A and B can coin@@ ci@@ de by shift@@ ing them by distances arr [ ( A % N + N ) % N ] and arr [ ( B % N + N ) % N ] 10026 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void check@@ Same@@ Position ( int arr [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) { int temp = ( ( i + arr [ i ] ) % n + n ) % n ; if ( mp . find ( temp ) != mp . end ( ) ) { cout << " Yes " ; return ; } mp [ temp ] ++ ; } cout << " No " ; } int main ( ) { int arr [ ] = { 5 , 4 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; check@@ Same@@ Position ( arr , N ) ; return 0 ; }
Program to print ASCII Value of all digits of a given number 10041 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int convertTo@@ ASCII ( int N ) { string num = to_string ( N ) ; for ( char ch : num ) { cout << ch << " ▁ ( " << ( int ) ch << " ) STRNEWLINE " ; } } int main ( ) { int N = 36 ; convertTo@@ ASCII ( N ) ; return 0 ; }
Check if all array elements can be reduced to 0 by repeatedly redu@@ cing pairs of consecutive elements by their minimum 10050 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void check@@ Possible ( int * arr , int n ) { for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { cout << " No STRNEWLINE " ; return ; } else { arr [ i ] -= arr [ i - 1 ] ; arr [ i - 1 ] = 0 ; } } if ( arr [ n - 1 ] == 0 ) { cout << " Yes STRNEWLINE " ; } else { cout << " No STRNEWLINE " ; } } int main ( ) { int arr [ ] = { 2 , 3 , 3 , 4 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; check@@ Possible ( arr , N ) ; return 0 ; }
Count sub@@ arrays made up of single 10054 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int single@@ Digit@@ Sub@@ array@@ Count ( int arr [ ] , int N ) { int res = 0 ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] <= 9 ) { count ++ ; res += count ; } else { count = 0 ; } } cout << res ; } int main ( ) { int arr [ ] = { 0 , 1 , 14 , 2 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; single@@ Digit@@ Sub@@ array@@ Count ( arr , N ) ; return 0 ; }
Count ways to generate an array having distinct elements at M consecutive indices 10078 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; long long int Fact ( int N ) { long long int result = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { result = ( result * i ) ; } return result ; } void numberOf@@ W@@ ays ( int M , int arr [ ] , int N ) { int B [ M ] = { 0 } ; int counter [ M + 1 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] != 0 ) { if ( B [ i % M ] == 0 ) { B [ i % M ] = arr [ i ] ; counter [ arr [ i ] ] ++ ; if ( counter [ arr [ i ] ] > 1 ) { cout << 0 << endl ; return ; } } else if ( B [ i % M ] != arr [ i ] ) { cout << 0 << endl ; return ; } } } int cnt = 0 ; for ( int i = 0 ; i < M ; i ++ ) { if ( B [ i ] == 0 ) { cnt ++ ; } } cout << Fact ( cnt ) << endl ; } int main ( ) { int M = 4 ; int arr [ ] = { 1 , 0 , 3 , 0 , 0 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; numberOf@@ W@@ ays ( M , arr , N ) ; }
Difference between sum of odd and even frequ@@ ent elements in an Array 10130 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; typedef long long ll ; void noOf@@ Array@@ s@@ Possible ( ll N , ll M ) { ll ans = 1 ; for ( ll i = 0 ; i < N ; ++ i ) { ans = ans * ( M - i ) ; } cout << ans ; } int main ( ) { ll N = 2 , M = 3 ; noOf@@ Array@@ s@@ Possible ( N , M ) ; return 0 ; }
Minim@@ ize increments or decre@@ ments by 2 to convert given value to a perfect square 10184 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int Minimum@@ Operation@@ Req ( int N ) { int cnt@@ Dec@@ r = 0 ; int temp = N ; while ( temp > 0 ) { int X = sqrt ( temp ) ; if ( X * X == temp ) { break ; } temp = temp - 2 ; cnt@@ Dec@@ r += 1 ; } int cnt@@ In@@ cr = 0 ; while ( true ) { int X = sqrt ( N ) ; if ( X * X == N ) { break ; } N = N + 2 ; cnt@@ In@@ cr += 1 ; } return min ( cnt@@ In@@ cr , cnt@@ Dec@@ r ) ; } int main ( ) { int N = 15 ; cout << Minimum@@ Operation@@ Req ( N ) ; return 0 ; }
Maxim@@ ize count of nodes disconnected from all other nodes in a Graph 10199 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max@@ Disconnected ( int N , int E ) { int curr = 1 ; int rem = E ; while ( rem > 0 ) { rem = rem - min ( curr , rem ) ; curr ++ ; } if ( curr > 1 ) { return N - curr ; } else { return N ; } } int main ( ) { int N = 5 , E = 1 ; cout << max@@ Disconnected ( N , E ) ; return 0 ; }
Check if number can be made prime by deleting a single digit 10220 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Prime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } string delete@@ I@@ th ( string str , int i ) { str . erase ( str . begin ( ) + i ) ; return str ; } bool is@@ Prime@@ Possible ( int N ) { string s = to_string ( N ) ; int l = s . length ( ) ; if ( l < 2 ) return false ; for ( int i = 0 ; i < l ; i ++ ) { string str = delete@@ I@@ th ( s , i ) ; int num = sto@@ i ( str ) ; if ( is@@ Prime ( num ) ) return true ; } return false ; } int main ( ) { int N = 6@@ 10 ; is@@ Prime@@ Possible ( N ) ? cout << " Yes " : cout << " No " ; return 0 ; }
Minim@@ ize increment / decrement of Array elements to make each modulo K equal 10241 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int Fin@@ d_@@ min ( set < int > & diff_@@ mod , map < int , int > count_@@ mod , int k ) { int min_@@ op@@ rn = INT_MAX ; int op@@ rn = 0 ; for ( int x = 0 ; x < k ; x ++ ) { op@@ rn = 0 ; for ( auto w : diff_@@ mod ) { if ( w != x ) { if ( w == 0 ) { op@@ rn += min ( x , k - x ) * count_@@ mod [ w ] ; } else { op@@ rn += min ( abs ( x - w ) , k + x - w ) * count_@@ mod [ w ] ; } } } if ( op@@ rn < min_@@ op@@ rn ) min_@@ op@@ rn = op@@ rn ; } return min_@@ op@@ rn ; } int C@@ al_@@ min ( int arr [ ] , int n , int k ) { set < int > diff_@@ mod ; map < int , int > count_@@ mod ; for ( int i = 0 ; i < n ; i ++ ) { diff_@@ mod . insert ( arr [ i ] % k ) ; count_@@ mod [ arr [ i ] % k ] ++ ; } return Fin@@ d_@@ min ( diff_@@ mod , count_@@ mod , k ) ; } int main ( ) { int arr [ ] = { 2 , 35 , 48 , 23 , 52 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; cout << C@@ al_@@ min ( arr , n , k ) ; return 0 ; }
Check if the given array is same as its inverse permutation 10272 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; void inverse@@ Equal ( int arr [ ] , int n ) { int br@@ r [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int present_@@ index = arr [ i ] - 1 ; br@@ r [ present_@@ index ] = i + 1 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != br@@ r [ i ] ) { cout << " No " << endl ; return ; } } cout << " Yes " << endl ; } int main ( ) { int n = 4 ; int arr [ n ] = { 1 , 4 , 3 , 2 } ; inverse@@ Equal ( arr , n ) ; return 0 ; }
Square root of a number by Repe@@ ated Subtr@@ action method 10284 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int Square@@ Root ( int num ) { int count = 0 ; for ( int n = 1 ; n <= num ; n += 2 ) { num = num - n ; count += 1 ; if ( num == 0 ) break ; } return count ; } int main ( ) { int N = 81 ; cout << Square@@ Root ( N ) ; }
Lar@@ gest odd divisor Game to check which player wins 10295 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ Win@@ ner ( int n , int k ) { int cnt = 0 ; if ( n == 1 ) cout << " No " << endl ; else if ( ( n & 1 ) or n == 2 ) cout << " Yes " << endl ; else { int tmp = n ; int val = 1 ; while ( tmp > k and tmp % 2 == 0 ) { tmp /= 2 ; val *= 2 ; } for ( int i = 3 ; i <= sqrt ( tmp ) ; i ++ ) { while ( tmp % i == 0 ) { cnt ++ ; tmp /= i ; } } if ( tmp > 1 ) cnt ++ ; if ( val == n ) cout << " No " << endl ; else if ( n / tmp == 2 and cnt == 1 ) cout << " No " << endl ; else cout << " Yes " << endl ; } } int main ( ) { long long n = 1 , k = 1 ; find@@ Win@@ ner ( n , k ) ; return 0 ; }
Count of all values of N in [ L , R ] such that count of primes upto N is also prime 10305 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count_@@ cra@@ z@@ y_@@ primes ( int L , int R ) { int prime [ R + 1 ] = { 0 } ; int count@@ Prime [ R + 1 ] = { 0 } ; int freq@@ Prime [ R + 1 ] = { 0 } ; prime [ 0 ] = prime [ 1 ] = 1 ; for ( int p = 2 ; p * p <= R ; p ++ ) { if ( prime [ p ] == 0 ) { for ( int i = p * p ; i <= R ; i += p ) prime [ i ] = 1 ; } } for ( int i = 1 ; i <= R ; i ++ ) { count@@ Prime [ i ] = count@@ Prime [ i - 1 ] ; if ( ! prime [ i ] ) { count@@ Prime [ i ] ++ ; } } for ( int i = 1 ; i <= R ; i ++ ) { freq@@ Prime [ i ] = freq@@ Prime [ i - 1 ] ; if ( ! prime [ count@@ Prime [ i ] ] ) { freq@@ Prime [ i ] ++ ; } } return ( freq@@ Prime [ R ] - freq@@ Prime [ L - 1 ] ) ; } int main ( ) { int L = 4 , R = 12 ; cout << count_@@ cra@@ z@@ y_@@ primes ( L , R ) ; return 0 ; }
Minimum operations required to make all Array elements di@@ visible by K 10311 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void compute ( int a [ ] , int N , int K ) { map < long , long > eq@@ Val ; long maxX = 0 ; for ( int i = 0 ; i < N ; i ++ ) { long val = a [ i ] % K ; val = ( val == 0 ? 0 : K - val ) ; if ( val == 0 ) continue ; if ( eq@@ Val . find ( val ) != eq@@ Val . end ( ) ) { long num@@ Val = eq@@ Val [ val ] ; maxX = max ( maxX , val + ( K * num@@ Val ) ) ; eq@@ Val [ val ] ++ ; } else { eq@@ Val [ val ] ++ ; maxX = max ( maxX , val ) ; } } cout << ( maxX == 0 ? 0 : maxX + 1 ) << endl ; } int main ( ) { int K = 3 ; int a [ ] = { 1 , 2 , 2 , 18 } ; int N = sizeof ( a ) / sizeof ( a [ 0 ] ) ; compute ( a , N , K ) ; return 0 ; }
Self Numbers 10376 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int getS@@ um ( int n ) { int sum = 0 ; while ( n != 0 ) { sum = sum + n % 10 ; n = n / 10 ; } return sum ; } bool is@@ Self@@ Num ( int n ) { for ( int m = 1 ; m <= n ; m ++ ) { if ( m + getS@@ um ( m ) == n ) return false ; } return true ; } int main ( ) { int n = 20 ; if ( is@@ Self@@ Num ( n ) ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
Sum of series formed by difference between product and sum of N natural numbers 10393 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int series@@ Sum@@ Util ( int k , int n , int prev@@ Sum , int multi , int add ) { if ( k == n + 1 ) { return prev@@ Sum ; } multi = multi * k ; add = add + k ; prev@@ Sum = prev@@ Sum + multi - add ; return series@@ Sum@@ Util ( k + 1 , n , prev@@ Sum , multi , add ) ; } int series@@ Sum ( int n ) { if ( n == 1 ) return 0 ; int prev@@ Sum = 0 ; int multi = 1 ; int add = 1 ; return series@@ Sum@@ Util ( 2 , n , prev@@ Sum , multi , add ) ; } int main ( ) { int N = 5 ; cout << series@@ Sum ( N ) << " ▁ " ; }
Find the smallest number whose sum of digits is N 10415 | #@@ include <@@ io@@ stream@@ > NEW_LINE #@@ include <@@ math@@ .@@ h@@ > NEW_LINE using namespace std ; int getS@@ um ( int n ) { int sum = 0 ; while ( n != 0 ) { sum = sum + n % 10 ; n = n / 10 ; } return sum ; } void smalle@@ st@@ Number ( int N ) { int i = 1 ; while ( 1 ) { if ( getS@@ um ( i ) == N ) { cout << i ; break ; } i ++ ; } } int main ( ) { int N = 10 ; smalle@@ st@@ Number ( N ) ; return 0 ; }
Zy@@ go@@ dro@@ me Number 10441 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ zy@@ go@@ dro@@ me@@ Num ( int N ) { string s = to_string ( N ) ; s = ' ▁ ' + s + ' ▁ ' ; for ( int i = 1 ; i < s . size ( ) - 1 ; i ++ ) { if ( s [ i ] != s [ i - 1 ] && s [ i ] != s [ i + 1 ] ) { return false ; } } return true ; } int main ( ) { int n = 112@@ 2 ; if ( is@@ zy@@ go@@ dro@@ me@@ Num ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
Maximum number of 0 s that can be flipped such that Array has no adjacent 1 s 10467 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int can@@ Replace ( int array [ ] , int n ) { int i = 0 , count = 0 ; while ( i < n ) { if ( array [ i ] == 0 && ( i == 0 array [ i - 1 ] == 0 ) && ( i == n - 1 array [ i + 1 ] == 0 ) ) { array [ i ] = 1 ; count ++ ; } i ++ ; } return count ; } int main ( ) { int array [ 5 ] = { 1 , 0 , 0 , 0 , 1 } ; cout << can@@ Replace ( array , 5 ) ; }
Me@@ g@@ ag@@ on number 10475 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int Me@@ g@@ ag@@ on@@ Num ( int n ) { return ( 9999@@ 98 * n * n - 9999@@ 96 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << Me@@ g@@ ag@@ on@@ Num ( n ) ; return 0 ; }
Te@@ trac@@ on@@ ta@@ oct@@ ag@@ onal Number 10478 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int Te@@ trac@@ on@@ ta@@ oct@@ ag@@ onal@@ Num ( int n ) { return ( 46 * n * n - 44 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << Te@@ trac@@ on@@ ta@@ oct@@ ag@@ onal@@ Num ( n ) ; return 0 ; }
Index of smallest triangular number with N digits 10486 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Index ( int n ) { float x = sqrt ( 2 * pow ( 10 , ( n - 1 ) ) ) ; return round ( x ) ; } int main ( ) { int n = 3 ; cout << find@@ Index ( n ) ; return 0 ; }
Find the largest N digit multiple of N 10494 | #@@ include <@@ io@@ stream@@ > NEW_LINE #@@ include <@@ math@@ .@@ h@@ > NEW_LINE using namespace std ; void smalle@@ st@@ Number ( int N ) { cout << N * floor ( ( pow ( 10 , N ) - 1 ) / N ) ; } int main ( ) { int N = 2 ; smalle@@ st@@ Number ( N ) ; return 0 ; }
I@@ co@@ si@@ kai@@ he@@ p@@ tag@@ onal Number 10498 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int ico@@ si@@ kai@@ he@@ p@@ tag@@ onal@@ Num ( int n ) { return ( 25 * n * n - 23 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << "3@@ rd ▁ ico@@ si@@ kai@@ he@@ p@@ tag@@ onal ▁ Number ▁ is ▁ " << ico@@ si@@ kai@@ he@@ p@@ tag@@ onal@@ Num ( n ) ; return 0 ; }
Program to check if N is a tri@@ ac@@ ont@@ ag@@ onal number 10499 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool ist@@ ri@@ ac@@ ont@@ ag@@ onal ( int N ) { float n = ( 26 + sqrt ( 224 * N + 67@@ 6 ) ) / 56 ; return ( n - ( int ) n ) == 0 ; } int main ( ) { int i = 30 ; if ( ist@@ ri@@ ac@@ ont@@ ag@@ onal ( i ) ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
Length of maximum product sub@@ array 10507 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void Max@@ length ( int arr [ ] , int N ) { vector < int > zero@@ index ; int maxlen ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) zero@@ index . push_back ( i ) ; } if ( zero@@ index . size ( ) == 0 ) { maxlen = N ; } else { maxlen = zero@@ index [ 0 ] ; for ( int i = 0 ; i < zero@@ index . size ( ) - 1 ; i ++ ) { if ( zero@@ index [ i + 1 ] - zero@@ index [ i ] - 1 > maxlen ) { maxlen = zero@@ index [ i + 1 ] - zero@@ index [ i ] - 1 ; } } if ( N - zero@@ index [ zero@@ index . size ( ) - 1 ] - 1 > maxlen ) { maxlen = N - zero@@ index [ zero@@ index . size ( ) - 1 ] - 1 ; } } cout << maxlen << endl ; } int main ( ) { int N = 9 ; int arr [ ] = { 7 , 1 , 0 , 1 , 2 , 0 , 9 , 2 , 1 } ; Max@@ length ( arr , N ) ; }
Find two numbers such that difference of their squares equal to N 10513 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void solve ( int n ) { for ( int x = 1 ; x <= sqrt ( n ) ; x ++ ) { if ( n % x == 0 ) { int small = x ; int big = n / x ; if ( small % 2 == big % 2 ) { int a = ( small + big ) / 2 ; int b = ( big - small ) / 2 ; cout << a << " ▁ " << b << endl ; return ; } } } cout << -1 << endl ; } int main ( ) { int n = 7 ; solve ( n ) ; return 0 ; }
Hen@@ sel '@@ s Le@@ mma 10520 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int inv ( int a , int m ) { int m0 = m , t , q ; int x0 = 0 , x1 = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { q = a / m ; t = m ; m = a % m ; a = t ; t = x0 ; x0 = x1 - q * x0 ; x1 = t ; } if ( x1 < 0 ) x1 += m0 ; return x1 ; } int derivative ( int x ) { return 3 * x * x ; } int Image ( int x , int k ) { return x * x * x - k ; } int next_@@ power ( int a@@ _t , int t , int a1 , int prime , int k ) { int power_@@ p = ( int ) pow ( prime , t + 1 ) ; int next_@@ a = ( a@@ _t - Image ( a@@ _t , k ) * inv ( derivative ( a1 ) , prime ) ) % power_@@ p ; if ( next_@@ a < 0 ) return next_@@ a += power_@@ p ; return next_@@ a ; } int power@@ Of@@ Prime ( int prime , int power , int k , int a1 ) { if ( derivative ( a1 ) != 0 ) { int a@@ _t = a1 ; for ( int p = 1 ; p < power ; p ++ ) { a@@ _t = next_@@ power ( a@@ _t , p , a1 , prime , k ) ; } return a@@ _t ; } return -1 ; } int main ( ) { int prime = 7 , a1 = 3 ; int power = 2 , k = 3 ; cout << power@@ Of@@ Prime ( prime , power , k , a1 ) ; return 0 ; }
Product of all the pairs from the given array 10539 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define mod 100000000@@ 7 NEW_LINE int product@@ Pairs ( int arr [ ] , int n ) { int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { product *= ( arr [ i ] % mod * arr [ j ] % mod ) % mod ; product = product % mod ; } } return product % mod ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << product@@ Pairs ( arr , n ) ; return 0 ; }
Count the minimum steps to reach 0 from the given integer N 10614 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int getMin@@ Steps ( int n , int jump ) { int quotient = n / jump ; int remainder = n % jump ; int steps = quotient + remainder ; return steps ; } int main ( ) { int N = 6 , K = 3 ; cout << getMin@@ Steps ( N , K ) ; return 0 ; }
Program to check if N is a C@@ entered non@@ a@@ dec@@ ag@@ onal number 10637 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ C@@ en@@ tered@@ non@@ a@@ dec@@ ag@@ onal ( int N ) { float n = ( 19 + sqrt ( 152 * N + 209 ) ) / 38 ; return ( n - ( int ) n ) == 0 ; } int main ( ) { int n = 20 ; if ( is@@ C@@ en@@ tered@@ non@@ a@@ dec@@ ag@@ onal ( n ) ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
Count of sub@@ arrays which start and end with the same element 10646 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void cnt@@ Array ( int A [ ] , int N ) { int result = 0 ; int frequency [ N + 1 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { frequency [ A [ i ] ] ++ ; } for ( int i = 1 ; i <= N ; i ++ ) { int frequ@@ ency_@@ of_@@ i = frequency [ i ] ; result += + ( ( frequ@@ ency_@@ of_@@ i ) * ( frequ@@ ency_@@ of_@@ i + 1 ) ) / 2 ; } cout << result << endl ; } int main ( ) { int A [ ] = { 1 , 5 , 6 , 1 , 9 , 5 , 8 , 10 , 8 , 9 } ; int N = sizeof ( A ) / sizeof ( int ) ; cnt@@ Array ( A , N ) ; return 0 ; }
Lon@@ gest sub@@ array with all elements same 10648 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int sub@@ array ( int arr [ ] , int n ) { int ans = 1 , temp = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) { ++ temp ; } else { ans = max ( ans , temp ) ; temp = 1 ; } } ans = max ( ans , temp ) ; return ans ; } int main ( ) { int arr [ ] = { 2 , 2 , 1 , 1 , 2 , 2 , 2 , 3 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << sub@@ array ( arr , n ) ; return 0 ; }
Min and max length sub@@ array having adjacent element difference at@@ most K 10649 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; void find@@ Max@@ Min@@ Sub@@ Array ( int arr [ ] , int K , int n ) { int min = n ; int max = 0 ; int left ; int right ; int tmp ; for ( int i = 0 ; i < n ; i ++ ) { tmp = 1 ; left = i ; while ( left - 1 >= 0 && abs ( arr [ left ] - arr [ left - 1 ] ) <= K ) { left -- ; tmp ++ ; } right = i ; while ( right + 1 <= n - 1 && abs ( arr [ right ] - arr [ right + 1 ] ) <= K ) { right ++ ; tmp ++ ; } if ( min > tmp ) min = tmp ; if ( max < tmp ) max = tmp ; } cout << min << " , ▁ " << max << endl ; } int main ( ) { int arr [ ] = { 1 , 2 , 5 , 6 , 7 } ; int K = 2 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; find@@ Max@@ Min@@ Sub@@ Array ( arr , K , n ) ; return 0 ; }
Number of continuous redu@@ ctions of A from B or B from A to make them ( 1 , 1 ) 10656 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int minimum@@ Steps ( int a , int b , int c ) { if ( a < 1 b < 1 ) return -1 ; if ( a == 1 && b == 1 ) return c ; if ( a < b ) { a = a + b ; b = a - b ; a = a - b ; } return minimum@@ Steps ( a - b , b , c + 1 ) ; } int main ( ) { int a = 75 ; int b = 17 ; cout << minimum@@ Steps ( a , b , 0 ) << endl ; }
Count of perfect squares of given length 10663 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Per@@ fec@@ t@@ Square ( long double x ) { long double sr = sqrt ( x ) ; return ( ( sr - floor ( sr ) ) == 0 ) ; } int count@@ Squ@@ ares ( int n ) { int cnt = 0 ; for ( int i = pow ( 10 , ( n - 1 ) ) ; i < pow ( 10 , n ) ; i ++ ) { if ( i != 0 && is@@ Per@@ fec@@ t@@ Square ( i ) ) cnt ++ ; } return cnt ; } int main ( ) { int n = 3 ; cout << count@@ Squ@@ ares ( n ) ; return 0 ; }
Print N distinct numbers following the given operations 10692 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool print@@ Arr ( int n ) { if ( n % 4 == 0 ) { for ( int i = 1 ; i <= n / 2 ; i ++ ) cout << i * 2 << ' ▁ ' ; for ( int i = 1 ; i < n / 2 ; i ++ ) cout << i * 2 - 1 << ' ▁ ' ; cout << n + n / 2 - 1 << ' ' ; } else cout << " - 1" ; } int main ( ) { int n = 22 ; print@@ Arr ( n ) ; return 0 ; }
Calculate the C@@ GP@@ A and C@@ GP@@ A % of marks obtained by a Student in N subjects 10716 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; double Cg@@ pa@@ Calc ( double marks [ ] , int n ) { double grade [ n ] ; double c@@ gp@@ a , sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { grade [ i ] = ( marks [ i ] / 10 ) ; } for ( int i = 0 ; i < n ; i ++ ) { sum += grade [ i ] ; } c@@ gp@@ a = sum / n ; return c@@ gp@@ a ; } int main ( ) { int n = 5 ; double marks [ ] = { 90 , 80 , 70 , 80 , 90 } ; double c@@ gp@@ a = Cg@@ pa@@ Calc ( marks , n ) ; cout << " C@@ GP@@ A ▁ = ▁ " ; printf ( " % .1f STRNEWLINE " , c@@ gp@@ a ) ; cout << " C@@ GP@@ A ▁ Percentage ▁ = ▁ " ; printf ( " % .2f " , c@@ gp@@ a * 9.@@ 5 ) ; }
Check whether two numbers are in golden ratio 10720 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool check@@ Gold@@ en@@ Ratio ( float a , float b ) { if ( a <= b ) { float temp = a ; a = b ; b = temp ; } std :: stringstream rati@@ o1 ; rati@@ o1 << std :: fixed << std :: setprecision ( 3 ) << ( a / b ) ; std :: stringstream rati@@ o2 ; rati@@ o2 << std :: fixed << std :: setprecision ( 3 ) << ( a + b ) / a ; if ( ( rati@@ o1 . str ( ) == rati@@ o2 . str ( ) ) && rati@@ o1 . str ( ) == "1.@@ 618@@ " ) { cout << " Yes " << endl ; return true ; } else { cout << " No " << endl ; return false ; } } int main ( ) { float a = 0.6@@ 18 ; float b = 1 ; check@@ Gold@@ en@@ Ratio ( a , b ) ; return 0 ; }
Find the minimum number to be added to N to make it a power of K 10723 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE #@@ define ll long long int NEW_LINE using namespace std ; int min@@ Num ( int n , int k ) { int x = ( int ) ( log ( n ) / log ( k ) ) + 1 ; int mn = pow ( k , x ) - n ; return mn ; } int main ( ) { int n = 20 , k = 5 ; cout << min@@ Num ( n , k ) ; return 0 ; }
Count of sub@@ sequences whose product is a difference of square of two integers 10787 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int Cnt@@ cont@@ Sub@@ s ( int a [ ] , int n ) { int prod = 1 ; vector < pair < int , int > > vect ; vect . push_back ( make_pair ( 0 , 2 ) ) ; vector < int > two , zero ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = a [ i ] % 4 ; if ( a [ i ] < 0 ) a [ i ] = a [ i ] + 4 ; if ( a [ i ] == 2 ) two . push_back ( i + 1 ) ; if ( a [ i ] == 0 ) zero . push_back ( i + 1 ) ; if ( a [ i ] == 0 a [ i ] == 2 ) vect . push_back ( make_pair ( i + 1 , a [ i ] ) ) ; } vect . push_back ( make_pair ( n + 1 , 2 ) ) ; int total = ( n * ( n + 1 ) ) / 2 ; if ( two . empty ( ) ) return total ; else { int sum = 0 ; int pos1 = -1 , pos2 = -1 , pos@@ 3 = -1 ; int sz = vect . size ( ) ; for ( int i = 1 ; i + 1 < sz ; i ++ ) { if ( vect [ i ] . second == 2 ) { sum += ( vect [ i ] . first - vect [ i - 1 ] . first ) * ( vect [ i + 1 ] . first - vect [ i ] . first ) - 1 ; } } return total - sum - two . size ( ) ; } } int main ( ) { int a [ ] = { 5 , 4 , 2 , 9 , 8 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << Cnt@@ cont@@ Sub@@ s ( a , n ) ; return 0 ; }
Number of subsets with same AND , OR and XOR values in an Array 10791 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; const int mod = 100000000@@ 7 ; int count@@ Sub@@ sets ( int a [ ] , int n ) { int answer = 0 ; int power@@ Of@@ Two [ 10000@@ 5 ] ; power@@ Of@@ Two [ 0 ] = 1 ; for ( int i = 1 ; i < 10000@@ 5 ; i ++ ) power@@ Of@@ Two [ i ] = ( power@@ Of@@ Two [ i - 1 ] * 2 ) % mod ; unordered_map < int , int > frequency ; for ( int i = 0 ; i < n ; i ++ ) frequency [ a [ i ] ] ++ ; for ( auto el : frequency ) { if ( el . first != 0 ) answer = ( answer % mod + power@@ Of@@ Two [ el . second - 1 ] ) % mod ; else answer = ( answer % mod + power@@ Of@@ Two [ el . second ] - 1 + mod ) % mod ; } return answer ; } int main ( ) { int N = 6 ; int A [ N ] = { 1 , 3 , 2 , 1 , 2 , 1 } ; cout << count@@ Sub@@ sets ( A , N ) ; return 0 ; }
Find the product of sum of two diagon@@ als of a square Matrix 10798 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; long long product ( vector < vector < int > > & mat , int n ) { long long d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { d1 += mat [ i ] [ i ] ; d2 += mat [ i ] [ n - i - 1 ] ; } return 1@@ LL * d1 * d2 ; } int main ( ) { vector < vector < int > > mat = { { 5 , 8 , 1 } , { 5 , 10 , 3 } , { -@@ 6 , 17 , -@@ 9 } } ; int n = mat . size ( ) ; cout << product ( mat , n ) ; return 0 ; }
Sum of elements of an AP in the given range 10805 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Sum ( int * arr , int n , int left , int right ) { int k = right - left ; int d = arr [ 1 ] - arr [ 0 ] ; int ans = arr [ left - 1 ] * ( k + 1 ) ; ans = ans + ( d * ( k * ( k + 1 ) ) ) / 2 ; return ans ; } int main ( ) { int arr [ ] = { 2 , 4 , 6 , 8 , 10 , 12 , 14 , 16 } ; int queries = 3 ; int q [ queries ] [ 2 ] = { { 2 , 4 } , { 2 , 6 } , { 5 , 6 } } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; for ( int i = 0 ; i < queries ; i ++ ) cout << find@@ Sum ( arr , n , q [ i ] [ 0 ] , q [ i ] [ 1 ] ) << endl ; }
Check if a sub@@ array exists with sum greater than the given Array 10808 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int sub@@ array@@ Possible ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum <= 0 ) return 1 ; } sum = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { sum += arr [ i ] ; if ( sum <= 0 ) return 1 ; } return 0 ; } int main ( ) { int arr [ ] = { 10 , 5 , -@@ 12 , 7 , -@@ 10 , 20 , 30 , -@@ 10 , 50 , 60 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( sub@@ array@@ Possible ( arr , size ) ) cout << " Yes " << " STRNEWLINE " ; else cout << " No " << " STRNEWLINE " ; return 0 ; }
Find the position of the given Prime Number 10815 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE #@@ define limit 10000000 NEW_LINE using namespace std ; int position [ limit + 1 ] ; void si@@ eve ( ) { position [ 0 ] = -1 , position [ 1 ] = -1 ; int pos = 0 ; for ( int i = 2 ; i <= limit ; i ++ ) { if ( position [ i ] == 0 ) { position [ i ] = ++ pos ; for ( int j = i * 2 ; j <= limit ; j += i ) position [ j ] = -1 ; } } } int main ( ) { si@@ eve ( ) ; int n = 11 ; cout << position [ n ] ; return 0 ; }
Minimum possible sum of array elements after performing the given operation 10817 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; double max@@ Sub@@ Array@@ Sum ( double a [ ] , int size ) { double max_@@ so@@ _f@@ ar = INT_@@ MIN , max_@@ ending_@@ here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_@@ ending_@@ here = max_@@ ending_@@ here + a [ i ] ; if ( max_@@ so@@ _f@@ ar < max_@@ ending_@@ here ) max_@@ so@@ _f@@ ar = max_@@ ending_@@ here ; if ( max_@@ ending_@@ here < 0 ) max_@@ ending_@@ here = 0 ; } return max_@@ so@@ _f@@ ar ; } double min@@ Possible@@ Sum ( double a [ ] , int n , double x ) { double mx@@ Sum = max@@ Sub@@ Array@@ Sum ( a , n ) ; double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } sum = sum - mx@@ Sum + mx@@ Sum / x ; cout << setprecision ( 2 ) << sum << endl ; } int main ( ) { int N = 3 ; double X = 2 ; double A [ N ] = { 1 , -2 , 3 } ; min@@ Possible@@ Sum ( A , N , X ) ; }
Count pairs in array such that one element is reverse of another 10824 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int reverse ( int num ) { int rev_@@ num = 0 ; while ( num > 0 ) { rev_@@ num = rev_@@ num * 10 + num % 10 ; num = num / 10 ; } return rev_@@ num ; } int count@@ Reverse ( int arr [ ] , int n ) { unordered_map < int , int > freq ; for ( int i = 0 ; i < n ; ++ i ) ++ freq [ arr [ i ] ] ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { -- freq [ arr [ i ] ] ; res += freq [ reverse ( arr [ i ] ) ] ; } return res ; } int main ( ) { int a [ ] = { 16 , 61 , 12 , 21 , 25 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << count@@ Reverse ( a , n ) << ' ' ; return 0 ; }
Find if it is possible to choose sub@@ array that it contains exactly K even integers 10827 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void is@@ Possible ( int A [ ] , int n , int k ) { int count@@ Of@@ Two = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] % 2 == 0 ) { count@@ Of@@ Two ++ ; } } if ( k == 0 && count@@ Of@@ Two == n ) cout << " NO STRNEWLINE " ; else if ( count@@ Of@@ Two >= k ) { cout << " Yes STRNEWLINE " ; } else cout << " No STRNEWLINE " ; } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 5 } ; int K = 2 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; is@@ Possible ( arr , N , K ) ; return 0 ; }
Find the number of ordered pairs such that a * p + b * q = N , where p and q are primes 10834 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE #@@ define size 100@@ 01 NEW_LINE using namespace std ; int prime [ size ] ; int freq [ size ] ; void si@@ eve ( int a , int b ) { prime [ 1 ] = 1 ; for ( int i = 2 ; i * i < size ; i ++ ) { if ( prime [ i ] == 0 ) { for ( int j = i * 2 ; j < size ; j += i ) prime [ j ] = 1 ; } } for ( int p = 1 ; p < size ; p ++ ) { for ( int q = 1 ; q < size ; q ++ ) { if ( prime [ p ] == 0 && prime [ q ] == 0 && a * p + b * q < size ) { freq [ a * p + b * q ] ++ ; } } } } int main ( ) { int queries = 2 , a = 1 , b = 2 ; si@@ eve ( a , b ) ; int arr [ queries ] = { 15 , 25 } ; for ( int i = 0 ; i < queries ; i ++ ) { cout << freq [ arr [ i ] ] << " ▁ " ; } return 0 ; }
Find numbers that divide X and Y to produce the same remainder 10855 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; void print@@ Modul@@ us ( int X , int Y ) { int n = max ( X , Y ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( X % i == Y % i ) cout << i << " ▁ " ; } } int main ( ) { int X , Y ; X = 10 ; Y = 20 ; print@@ Modul@@ us ( X , Y ) ; return 0 ; }
Check if the XOR of an array of integers is Even or Odd 10865 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; string check ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 ) count ++ ; } if ( count & 1 ) return " Odd " ; else return " Even " ; } int main ( ) { int arr [ ] = { 3 , 9 , 12 , 13 , 15 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << check ( arr , n ) << endl ; return 0 ; }
Check if a number is di@@ visible by 47 or not 10875 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE #@@ include <@@ std@@ lib@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Di@@ visible ( int n ) { int d ; while ( n / 100 ) { d = n % 10 ; n /= 10 ; n = abs ( n - ( d * 14 ) ) ; } return ( n % 47 == 0 ) ; } int main ( ) { int N = 59@@ 173 ; if ( is@@ Di@@ visible ( N ) ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
Sum of all proper di@@ visors from 1 to N 10889 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int proper@@ Di@@ visor@@ Sum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j * j <= i ; ++ j ) { if ( i % j == 0 ) { if ( i / j == j ) sum += j ; else sum += j + i / j ; } } sum = sum - i ; } return sum ; } int main ( ) { int n = 4 ; cout << proper@@ Di@@ visor@@ Sum ( n ) << endl ; n = 5 ; cout << proper@@ Di@@ visor@@ Sum ( n ) << endl ; return 0 ; }
Sum of all proper di@@ visors from 1 to N 10890 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int proper@@ Di@@ visor@@ Sum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) sum += ( n / i ) * i ; return sum - n * ( n + 1 ) / 2 ; } int main ( ) { int n = 4 ; cout << proper@@ Di@@ visor@@ Sum ( n ) << endl ; n = 5 ; cout << proper@@ Di@@ visor@@ Sum ( n ) << endl ; return 0 ; }
Print all possible pair with prime XOR in the Array 10896 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; const int sz = 1e@@ 5 ; bool is@@ Prime [ sz + 1 ] ; void generate@@ Prime ( ) { int i , j ; memset ( is@@ Prime , true , sizeof ( is@@ Prime ) ) ; is@@ Prime [ 0 ] = is@@ Prime [ 1 ] = false ; for ( i = 2 ; i * i <= sz ; i ++ ) { if ( is@@ Prime [ i ] ) { for ( j = i * i ; j < sz ; j += i ) { is@@ Prime [ j ] = false ; } } } } void Pai@@ r_@@ of_@@ Prime@@ Xor ( int A [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( is@@ Prime [ ( A [ i ] ^ A [ j ] ) ] ) { cout << " ( " << A [ i ] << " , ▁ " << A [ j ] << " ) ▁ " ; } } } } int main ( ) { int A [ ] = { 1 , 3 , 6 , 11 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; generate@@ Prime ( ) ; Pai@@ r_@@ of_@@ Prime@@ Xor ( A , n ) ; return 0 ; }
Minimum number of primes required such that their sum is equal to N 10902 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Prime ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { return false ; } } return true ; } void print@@ Min@@ Count@@ Prime ( int N ) { int min@@ Count ; if ( is@@ Prime ( N ) ) { min@@ Count = 1 ; } else if ( N % 2 == 0 ) { min@@ Count = 2 ; } else { if ( is@@ Prime ( N - 2 ) ) { min@@ Count = 2 ; } else { min@@ Count = 3 ; } } cout << min@@ Count << endl ; } int main ( ) { int N = 100 ; print@@ Min@@ Count@@ Prime ( N ) ; return 0 ; }
Number of times the largest Perf@@ ect Cube can be subtrac@@ ted from N 10933 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Steps ( int n ) { int steps = 0 ; while ( n ) { int largest = c@@ br@@ t ( n ) ; n -= ( largest * largest * largest ) ; steps ++ ; } return steps ; } int main ( ) { int n = 150 ; cout << count@@ Steps ( n ) ; return 0 ; }
Radius of the circle when the width and height of an arc is given 9196 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void rad ( double d , double h ) { cout << " The ▁ radius ▁ of ▁ the ▁ circle ▁ is ▁ " << ( ( d * d ) / ( 8 * h ) + h / 2 ) << endl ; } int main ( ) { double d = 4 , h = 1 ; rad ( d , h ) ; return 0 ; }
Big@@ gest Re@@ u@@ le@@ aux Triangle in@@ sc@@ ir@@ bed within a square in@@ scri@@ bed in a sem@@ ic@@ ir@@ cle 9226 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; float Area ( float r ) { if ( r < 0 ) return -1 ; float x = ( 2 * r ) / sqrt ( 5 ) ; float A = 0.7@@ 04@@ 77 * pow ( x , 2 ) ; return A ; } int main ( ) { float r = 5 ; cout << Area ( r ) << endl ; return 0 ; }
Length of Diagonal of a n 9239 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; float poly@@ diagonal ( float n , float a ) { if ( a < 0 && n < 0 ) return -1 ; return 2 * a * sin ( ( ( ( n - 2 ) * 180 ) / ( 2 * n ) ) * 3.14@@ 159 / 180 ) ; } int main ( ) { float a = 9 , n = 10 ; cout << poly@@ diagonal ( n , a ) << endl ; return 0 ; }
Area of Cir@@ cum@@ circle of a Right Ang@@ led Triangle 9263 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE #@@ define PI 3.14@@ 159@@ 265 NEW_LINE using namespace std ; float area_@@ circum@@ scri@@ bed ( float c ) { return ( c * c * ( PI / 4 ) ) ; } int main ( ) { float c = 8 ; cout << area_@@ circum@@ scri@@ bed ( c ) ; return 0 ; }
Maximum area of rectangle possible with given per@@ imeter 9281 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max@@ Area ( float per@@ imeter ) { int length = ( int ) ceil ( per@@ imeter / 4 ) ; int bread@@ th = ( int ) floor ( per@@ imeter / 4 ) ; return length * bread@@ th ; } int main ( ) { float n = 38 ; cout << " Maximum ▁ Area ▁ = ▁ " << max@@ Area ( n ) ; return 0 ; }
Program to find the Per@@ imeter of a Regular Polygon 9290 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; float Per@@ imeter ( float s , int n ) { float per@@ imeter = 1 ; per@@ imeter = n * s ; return per@@ imeter ; } int main ( ) { int n = 5 ; float s = 2.5 , per@@ i ; per@@ i = Per@@ imeter ( s , n ) ; cout << " Per@@ imeter ▁ of ▁ Regular ▁ Polygon " << " ▁ with ▁ " << n << " ▁ sides ▁ of ▁ length ▁ " << s << " ▁ = ▁ " << per@@ i << endl ; return 0 ; }
Find length of Diagonal of Hexagon 9295 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; float hexa@@ diagonal ( float a ) { if ( a < 0 ) return -1 ; return 2 * a ; } int main ( ) { float a = 4 ; cout << hexa@@ diagonal ( a ) << endl ; return 0 ; }
Cir@@ cum@@ radius of the rectangle 9312 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; float find@@ Radius@@ Of@@ circum@@ circle ( float l , float b ) { if ( l < 0 b < 0 ) return -1 ; float radius = sqrt ( pow ( l , 2 ) + pow ( b , 2 ) ) / 2 ; return radius ; } int main ( ) { float l = 4 , b = 3 ; cout << find@@ Radius@@ Of@@ circum@@ circle ( l , b ) << endl ; return 0 ; }
Check if any square ( with one colored cell ) can be divided into two equal parts 9320 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void half@@ square ( int n , int x , int y ) { int half = n / 2 ; if ( ( half == x half == x - 1 ) && ( half == y half == y - 1 ) ) cout << " NO " << endl ; else cout << " YES " << endl ; } int main ( ) { int n = 100 ; int x = 51 , y = 100 ; half@@ square ( n , x , y ) ; return 0 ; }
Check if a point lies inside a rectangle | Set 9358 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool Find@@ Point ( int x1 , int y1 , int x2 , int y2 , int x , int y ) { if ( x > x1 and x < x2 and y > y1 and y < y2 ) return true ; return false ; } int main ( ) { int x1 = 0 , y1 = 0 , x2 = 10 , y2 = 8 ; int x = 1 , y = 5 ; if ( Find@@ Point ( x1 , y1 , x2 , y2 , x , y ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
Distance between a point and a Plane in 3 D 9362 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE #@@ include <@@ math@@ .@@ h@@ > NEW_LINE using namespace std ; void shor@@ test_@@ distance ( float x1 , float y1 , float z1 , float a , float b , float c , float d ) { d = fabs ( ( a * x1 + b * y1 + c * z1 + d ) ) ; float e = sqrt ( a * a + b * b + c * c ) ; cout << " Per@@ pendic@@ ular ▁ distance ▁ is ▁ " << ( d / e ) ; return ; } int main ( ) { float x1 = 4 ; float y1 = -@@ 4 ; float z1 = 3 ; float a = 2 ; float b = -2 ; float c = 5 ; float d = 8 ; shor@@ test_@@ distance ( x1 , y1 , z1 , a , b , c , d ) ; }
Pent@@ ag@@ onal Pyram@@ id@@ al Number 9379 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int pent@@ ag@@ on_@@ pyram@@ id@@ al ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int p = ( 3 * i * i - i ) / 2 ; sum = sum + p ; } return sum ; } int main ( ) { int n = 4 ; cout << pent@@ ag@@ on_@@ pyram@@ id@@ al ( n ) << endl ; return 0 ; }
Check if given four integers ( or sides ) make rectangle 9423 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; bool is@@ Rectangle ( int a , int b , int c , int d ) { if ( a == b == c == d ) return true ; else if ( a == b && c == d ) return true ; else if ( a == d && c == b ) return true ; else if ( a == c && d == b ) return true ; else return false ; } int main ( ) { int a , b , c , d ; a = 1 , b = 2 , c = 3 , d = 4 ; if ( is@@ Rectangle ( a , b , c , d ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
Maximum area of quad@@ ri@@ later@@ al 9466 | #@@ include <@@ io@@ stream@@ > NEW_LINE #@@ include <@@ math@@ .@@ h@@ > NEW_LINE using namespace std ; double max@@ Area ( double a , double b , double c , double d ) { double semi@@ per@@ imeter = ( a + b + c + d ) / 2 ; return sqrt ( ( semi@@ per@@ imeter - a ) * ( semi@@ per@@ imeter - b ) * ( semi@@ per@@ imeter - c ) * ( semi@@ per@@ imeter - d ) ) ; } int main ( ) { double a = 1 , b = 2 , c = 1 , d = 2 ; cout << max@@ Area ( a , b , c , d ) ; return 0 ; }
Check if a line touches or intersects a circle 9478 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void check@@ Collision ( int a , int b , int c , int x , int y , int radius ) { int dist = ( abs ( a * x + b * y + c ) ) / sqrt ( a * a + b * b ) ; if ( radius == dist ) cout << " Touch " << endl ; else if ( radius > dist ) cout << " Intersect " << endl ; else cout << " Outside " << endl ; } int main ( ) { int radius = 5 ; int x = 0 , y = 0 ; int a = 3 , b = 4 , c = 25 ; check@@ Collision ( a , b , c , x , y , radius ) ; return 0 ; }
Check if two given circ@@ les touch or intersect each other 9481 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int dist@@ Sq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; int rad@@ Sum@@ Sq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( dist@@ Sq == rad@@ Sum@@ Sq ) return 1 ; else if ( dist@@ Sq > rad@@ Sum@@ Sq ) return -1 ; else return 0 ; } int main ( ) { int x1 = -@@ 10 , y1 = 8 ; int x2 = 14 , y2 = -@@ 24 ; int r1 = 30 , r2 = 10 ; int t = circle ( x1 , y1 , x2 , y2 , r1 , r2 ) ; if ( t == 1 ) cout << " Circle ▁ touch ▁ to " << " ▁ each ▁ other . " ; else if ( t < 0 ) cout << " Circle ▁ not ▁ touch " << " ▁ to ▁ each ▁ other . " ; else cout << " Circle ▁ intersect " << " ▁ to ▁ each ▁ other . " ; return 0 ; }
Minim@@ ize cost to modify the Array such that even indices have even elements and vice versa 9530 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int minimum@@ Cost ( int arr [ ] , int N , int X , int Y ) { int ev@@ en_@@ count = 0 , od@@ d_@@ count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] & 1 ) && ( i % 2 == 0 ) ) { od@@ d_@@ count ++ ; } if ( ( arr [ i ] % 2 ) == 0 && ( i & 1 ) ) { ev@@ en_@@ count ++ ; } } int cost@@ 1 = X * min ( od@@ d_@@ count , ev@@ en_@@ count ) ; int cost@@ 2 = Y * ( max ( od@@ d_@@ count , ev@@ en_@@ count ) - min ( od@@ d_@@ count , ev@@ en_@@ count ) ) ; int cost@@ 3 = ( od@@ d_@@ count + ev@@ en_@@ count ) * Y ; return min ( cost@@ 1 + cost@@ 2 , cost@@ 3 ) ; } int main ( ) { int arr [ ] = { 5 , 3 , 7 , 2 , 1 } , X = 10 , Y = 2 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minimum@@ Cost ( arr , N , X , Y ) ; return 0 ; }
Maximum size of subset such that product of all subset elements is a factor of N 9550 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int maxim@@ ize@@ Subset ( int N , int arr [ ] , int M , int x = 0 ) { if ( x == M ) { return 0 ; } int ans = 0 ; for ( int i = x ; i < M ; i ++ ) { if ( N % arr [ i ] == 0 ) { ans = max ( ans , maxim@@ ize@@ Subset ( N / arr [ i ] , arr , M , x + 1 ) + 1 ) ; } } return ans ; } int main ( ) { int N = 64 ; int arr [ ] = { 1 , 2 , 4 , 8 , 16 , 32 } ; int M = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxim@@ ize@@ Subset ( N , arr , M ) ; return 0 ; }
Count of pairs in given range having their ratio equal to ratio of product of their digits 9568 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int get@@ Product ( int n ) { int product = 1 ; while ( n != 0 ) { product = product * ( n % 10 ) ; n = n / 10 ; } return product ; } int count@@ Pairs ( int L , int R ) { int cnt@@ Pair = 0 ; for ( int a = L ; a <= R ; a ++ ) { for ( int b = a + 1 ; b <= R ; b ++ ) { int x = get@@ Product ( a ) ; int y = get@@ Product ( b ) ; if ( x && y && ( a * y ) == ( b * x ) ) { cnt@@ Pair ++ ; } } } return cnt@@ Pair ; } int main ( ) { int L = 1 ; int R = 100 ; cout << count@@ Pairs ( 1 , 100 ) ; return 0 ; }
Maxim@@ ize matrix sum by fli@@ pping the sign of any adjacent pairs 9572 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max@@ Sum ( vector < vector < int > > & matrix ) { int r = matrix . size ( ) ; int c = matrix [ 0 ] . size ( ) ; int sum = 0 ; int mini = INT_MAX ; int count = 0 ; for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) { int k = matrix [ i ] [ j ] ; mini = min ( mini , abs ( k ) ) ; if ( k < 0 ) count ++ ; sum += abs ( k ) ; } } if ( count % 2 == 0 ) { return sum ; } else { return ( sum - 2 * mini ) ; } } int main ( ) { vector < vector < int > > matrix = { { 2 , -2 } , { -2 , 2 } } ; cout << max@@ Sum ( matrix ) ; return 0 ; }
Count of sub@@ sequences having odd Bit@@ wise AND values in the given array 9574 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Sub@@ sequences ( vector < int > arr ) { int odd = 0 ; for ( int x : arr ) { if ( x & 1 ) odd ++ ; } return ( 1 << odd ) - 1 ; } int main ( ) { vector < int > arr = { 1 , 3 , 3 } ; cout << count@@ Sub@@ sequences ( arr ) ; return 0 ; }
Reduce given array by replacing sub@@ arrays with values less than K with their sum 9576 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void update@@ Array ( vector < int > & arr , int K ) { int sum = 0 ; vector < int > res ; for ( int i = 0 ; i < ( int ) arr . size ( ) ; i ++ ) { if ( arr [ i ] < K ) { sum += arr [ i ] ; } else { if ( sum != 0 ) { res . push_back ( sum ) ; } sum = 0 ; res . push_back ( arr [ i ] ) ; } } if ( sum != 0 ) res . push_back ( sum ) ; for ( auto & it : res ) cout << it << ' ▁ ' ; } int main ( ) { vector < int > arr = { 200 , 6 , 36 , 6@@ 12 , 121 , 66 , 63 , 39 , 66@@ 8 , 108 } ; int K = 100 ; update@@ Array ( arr , K ) ; return 0 ; }
Count sub@@ sequence of length 4 having product of the first three elements equal to the fourth element 9618 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Quad@@ rup@@ les ( int A [ ] , int N ) { int ans = 0 ; unordered_map < int , int > freq ; for ( int i = 0 ; i < N ; i ++ ) { ans += freq [ A [ i ] ] ; for ( int j = 0 ; j < i ; j ++ ) { for ( int k = 0 ; k < j ; k ++ ) { freq [ A [ i ] * A [ j ] * A [ k ] ] ++ ; } } } return ans ; } int main ( ) { int arr [ ] = { 10 , 2 , 2 , 7 , 40 , 160 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << count@@ Quad@@ rup@@ les ( arr , N ) ; return 0 ; }
Count cells in a grid from which maximum number of cells can be reached by K vertical or horizontal jumps 9627 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; long long count@@ Cells ( int n , int m , int s ) { int m@@ x1 = -1 ; int cont@@ 1 = 0 ; for ( int i = 0 ; i < s && i < n ; ++ i ) { int aux = ( n - ( i + 1 ) ) / s + 1 ; if ( aux > m@@ x1 ) { m@@ x1 = cont@@ 1 = aux ; } else if ( aux == m@@ x1 ) cont@@ 1 += aux ; } int m@@ x2 = -1 ; int cont@@ 2 = 0 ; for ( int i = 0 ; i < s && i < m ; ++ i ) { int aux = ( m - ( i + 1 ) ) / s + 1 ; if ( aux > m@@ x2 ) m@@ x2 = cont@@ 2 = aux ; else if ( aux == m@@ x2 ) cont@@ 2 += aux ; } return ( long long ) ( cont@@ 1 * cont@@ 2 ) ; } int main ( ) { int N = 5 , M = 5 , K = 2 ; cout << count@@ Cells ( N , M , K ) ; return 0 ; }
Minimum length of the sub@@ array required to be replaced to make frequency of array elements equal to N / M 9647 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int minimum@@ Sub@@ array ( vector < int > arr , int n , int m ) { vector < int > map@@ u ( m + 1 , 0 ) ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { map@@ u [ arr [ i ] ] ++ ; if ( map@@ u [ arr [ i ] ] == ( n / m ) + 1 ) c ++ ; } if ( c == 0 ) return 0 ; int ans = n ; int l = 0 , r = 0 ; while ( r < n ) { if ( -- map@@ u [ arr [ r ] ] == ( n / m ) ) c -- ; if ( c == 0 ) { while ( l <= r && c == 0 ) { ans = min ( ans , r - l + 1 ) ; if ( ++ map@@ u [ arr [ l ] ] > ( n / m ) ) c ++ ; l ++ ; } } r ++ ; } return ans ; } int main ( ) { vector < int > arr = { 1 , 1 , 2 , 1 , 1 , 2 } ; int M = 2 ; int N = arr . size ( ) ; cout << minimum@@ Sub@@ array ( arr , N , M ) ; return 0 ; }
Count ways to replace ' ? ' in a Binary String to make the count of 0 s and 1 s same as that of another string 9658 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { res = res * i ; } return res ; } int n@@ Cr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; } void count@@ W@@ ays ( string s , string t ) { int n = s . length ( ) ; int sum@@ 1 = 0 , sum@@ 2 = 0 , K = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) { sum@@ 1 ++ ; } else sum@@ 1 -- ; } int m = t . length ( ) ; for ( int i = 0 ; i < m ; i ++ ) { if ( t [ i ] == '1' ) { sum@@ 2 ++ ; } else if ( t [ i ] == '0' ) { sum@@ 2 -- ; } else K ++ ; } int P = abs ( sum@@ 1 - sum@@ 2 ) ; if ( P > K or ( K - P ) % 2 ) { cout << 0 ; return ; } cout << n@@ Cr ( K , ( P + K ) / 2 ) ; } int main ( ) { string S1 = "@@ 101@@ 0" ; string S2 = "@@ 10 ? ? " ; count@@ W@@ ays ( S1 , S2 ) ; return 0 ; }
Find the closest Fraction to given fraction having minimum absolute difference 9667 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; long long ABS ( long long x ) { return max ( x , - x ) ; } void find@@ Fraction ( long long x , long long y , long long n ) { long long A = -1 , B = -1 ; for ( long long i = 1 ; i <= n ; i ++ ) { long long d = ( i * x ) / y ; if ( d >= 0 && ( A == -1 || ABS ( B * x - y * A ) * ABS ( i * y ) > ABS ( i * x - y * d ) * ABS ( B * y ) ) ) A = d , B = i ; d ++ ; if ( d >= 0 && ( A == -1 || ABS ( B * x - y * A ) * ABS ( i * y ) > ABS ( i * x - y * d ) * ABS ( B * y ) ) ) A = d , B = i ; } cout << A << " / " << B << endl ; } int main ( ) { long long x = 3 , y = 7 , n = 6 ; find@@ Fraction ( x , y , n ) ; return 0 ; }
Split the fraction into sum of multiple fractions having numerator as 1 9683 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; vector < string > Fraction@@ Split ( long long n , long long d ) { vector < string > Unit@@ Fac@@ tions ; while ( n > 0 ) { long long x = ( d + n - 1 ) / n ; string s = "1 / " + to_string ( x ) ; Unit@@ Fac@@ tions . push_back ( s ) ; n = n * x - d ; d = d * x ; } return Unit@@ Fac@@ tions ; } int main ( ) { long long n = 13 , d = 18 ; auto res = Fraction@@ Split ( n , d ) ; for ( string s : res ) cout << s << " , ▁ " ; return 0 ; }
Minimum absolute value of ( K – arr [ i ] ) for all possible values of K over the range [ 0 , N – 1 ] 9690 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void minimum@@ Distance ( vector < int > arr , int N ) { int ind = 0 ; int prev = arr [ ind ] ; int s = arr . size ( ) ; for ( int i = 0 ; i < N ; i ++ ) { int distance = INT_MAX ; if ( i < arr [ 0 ] ) { distance = arr [ 0 ] - i ; } else if ( i >= prev && ind + 1 < s && i <= arr [ ind + 1 ] ) { distance = min ( i - prev , arr [ ind + 1 ] - i ) ; if ( i == arr [ ind + 1 ] ) { distance = 0 ; prev = arr [ ind + 1 ] ; ind ++ ; } } else { distance = i - prev ; } cout << distance << " ▁ " ; } } int main ( ) { int N = 5 ; vector < int > arr = { 0 , 4 } ; minimum@@ Distance ( arr , N ) ; return 0 ; }
Count of pairs in Array such that bitwise AND of XOR of pair and X is 0 9692 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Of@@ Pairs ( int arr [ ] , int N , int X ) { int count = 0 ; unordered_map < int , int > M ; for ( int i = 0 ; i < N ; i ++ ) { M [ ( arr [ i ] & X ) ] ++ ; } for ( auto m : M ) { int p = m . second ; count += p * ( p - 1 ) / 2 ; } return count ; } int main ( ) { int arr [ ] = { 3 , 2 , 5 , 4 , 6 , 7 } ; int X = 6 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << count@@ Of@@ Pairs ( arr , N , X ) ; return 0 ; }
Find prime factors of Z such that Z is product of all even numbers till N that are product of two distinct prime numbers 9721 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void prime@@ Factor@@ ization ( int N ) { int si@@ eve [ N / 2 + 1 ] = { 0 } ; for ( int i = 2 ; i <= N / 2 ; i ++ ) { if ( si@@ eve [ i ] == 0 ) { for ( int j = i * i ; j <= N / 2 ; j += i ) { si@@ eve [ j ] = 1 ; } } } vector < int > prime ; for ( int i = 3 ; i <= N / 2 ; i ++ ) if ( si@@ eve [ i ] == 0 ) prime . push_back ( i ) ; int x = prime . size ( ) ; cout << "2 - > " << x << endl ; for ( int i : prime ) cout << i << " - > 1" << endl ; } int main ( ) { int N = 18 ; prime@@ Factor@@ ization ( N ) ; return 0 ; }
Number of ways to form a number with maximum K@@ s in it 9740 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int noOf@@ W@@ ays ( int N , int K ) { string S = to_string ( N ) ; int ans = 1 ; for ( int i = 1 ; i < S . length ( ) ; i ++ ) { int count = 1 ; while ( i < S . length ( ) && S [ i ] - '0' + S [ i - 1 ] - '0' == K ) { count ++ ; i ++ ; } if ( count % 2 ) ans *= ( count + 1 ) / 2 ; } return ans ; } int main ( ) { int N = 14@@ 547@@ 81 ; int K = 9 ; cout << noOf@@ W@@ ays ( N , K ) << endl ; }
Print all numbers that are di@@ visors of N and are co 9751 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ Unit@@ ary@@ Di@@ visors ( int n ) { for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i && __@@ gcd ( i , n / i ) == 1 ) { printf ( " % d ▁ " , i ) ; } else { if ( __@@ gcd ( i , n / i ) == 1 ) { printf ( " % d ▁ % d ▁ " , i , n / i ) ; } } } } } int main ( ) { int N = 12 ; print@@ Unit@@ ary@@ Di@@ visors ( N ) ; return 0 ; }
Print all numbers that are di@@ visors of N and are co 9761 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void get@@ Permutation ( int N ) { if ( N <= 3 ) { cout << -1 ; return ; } int i = N ; if ( N % 2 == 0 ) i -- ; while ( i >= 1 ) { cout << i << " ▁ " ; i -= 2 ; } cout << 4 << " ▁ " << 2 << " ▁ " ; i = 6 ; while ( i <= N ) { cout << i << " ▁ " ; i += 2 ; } } int main ( ) { int N = 9 ; get@@ Permutation ( N ) ; return 0 ; }
Maxim@@ ize score of same 9766 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void max@@ Score@@ Sub@@ Array ( int * a , int * b , int n ) { int res = 0 ; for ( int mid = 0 ; mid < n ; mid ++ ) { int straight@@ Score = a [ mid ] * b [ mid ] , reverse@@ Score = a [ mid ] * a [ mid ] ; int prev = mid - 1 , next = mid + 1 ; res = max ( res , max ( straight@@ Score , reverse@@ Score ) ) ; while ( prev >= 0 && next < n ) { straight@@ Score += ( a [ prev ] * b [ prev ] + a [ next ] * b [ next ] ) ; reverse@@ Score += ( a [ prev ] * b [ next ] + a [ next ] * b [ prev ] ) ; res = max ( res , max ( straight@@ Score , reverse@@ Score ) ) ; prev -- ; next ++ ; } straight@@ Score = 0 ; reverse@@ Score = 0 ; prev = mid - 1 , next = mid ; while ( prev >= 0 && next < n ) { straight@@ Score += ( a [ prev ] * b [ prev ] + a [ next ] * b [ next ] ) ; reverse@@ Score += ( a [ prev ] * b [ next ] + a [ next ] * b [ prev ] ) ; res = max ( res , max ( straight@@ Score , reverse@@ Score ) ) ; prev -- ; next ++ ; } } cout << res ; } int main ( ) { int A [ ] = { 13 , 4 , 5 } ; int B [ ] = { 10 , 22 , 2 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; max@@ Score@@ Sub@@ Array ( A , B , N ) ; return 0 ; }
Count numbers less than N whose modulo with A is equal to B 9769 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void count@@ Values ( int A , int B , int C ) { if ( B >= A ) { cout << 0 ; return ; } if ( B == 0 ) { cout << C / A ; return ; } int ans = C / A ; if ( ans * A + B <= C ) { ans ++ ; } cout << ans ; } int main ( ) { int A = 6 , B = 3 , N = 15 ; count@@ Values ( A , B , N ) ; return 0 ; }
Maximum frequency of any array element possible by at most K increments 9795 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void max@@ Frequency ( int arr [ ] , int N , int K ) { sort ( arr , arr + N ) ; int start = 0 , end = 0 ; int sum = 0 , res = 0 ; for ( end = 0 ; end < N ; end ++ ) { sum += arr [ end ] ; while ( ( end - start + 1 ) * arr [ end ] - sum > K ) { sum -= arr [ start ] ; start ++ ; } res = max ( res , end - start + 1 ) ; } cout << res << endl ; } int main ( ) { int arr [ ] = { 1 , 4 , 8 , 13 } ; int N = 4 ; int K = 5 ; max@@ Frequency ( arr , N , K ) ; return 0 ; }
Count pairs ( i , j ) from an array such that i < j and arr [ j ] 9796 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void count@@ Pairs ( int arr [ ] , int n , int x ) { int count = 0 ; map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) { mp [ arr [ i ] - x * i ] ++ ; } for ( auto x : mp ) { int n = x . second ; count += ( n * ( n - 1 ) ) / 2 ; } cout << count ; } int main ( ) { int n = 6 , x = 3 ; int arr [ ] = { 5 , 4 , 8 , 11 , 13 , 16 } ; count@@ Pairs ( arr , n , x ) ; return 0 ; }
Sum of Eu@@ ler To@@ ti@@ ent Functions obtained for each divisor of N 9806 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int sum@@ Of@@ Di@@ visors ( int N ) { return N ; } int main ( ) { int N = 5 ; cout << sum@@ Of@@ Di@@ visors ( N ) ; return 0 ; }
Bit@@ wise XOR of Bit@@ wise AND of all pairs from two given arrays 9828 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ X@@ ORS ( int ar@@ r1 [ ] , int ar@@ r2 [ ] , int N , int M ) { int X@@ OR@@ S1 = 0 ; int X@@ OR@@ S2 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { X@@ OR@@ S1 ^= ar@@ r1 [ i ] ; } for ( int i = 0 ; i < M ; i ++ ) { X@@ OR@@ S2 ^= ar@@ r2 [ i ] ; } return X@@ OR@@ S1 and X@@ OR@@ S2 ; } int main ( ) { int ar@@ r1 [ ] = { 1 , 2 , 3 } ; int ar@@ r2 [ ] = { 6 , 5 } ; int N = sizeof ( ar@@ r1 ) / sizeof ( ar@@ r1 [ 0 ] ) ; int M = sizeof ( ar@@ r2 ) / sizeof ( ar@@ r2 [ 0 ] ) ; cout << find@@ X@@ ORS ( ar@@ r1 , ar@@ r2 , N , M ) ; return 0 ; }
Difference between ceil of array sum divided by K and sum of ceil of array elements divided by K 9836 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int ceil@@ Difference ( int arr [ ] , int n , int x ) { int total@@ Sum = 0 ; int per@@ Element@@ Sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { total@@ Sum += arr [ i ] ; per@@ Element@@ Sum += ceil ( ( double ) ( arr [ i ] ) / ( double ) ( x ) ) ; } int total@@ Ceil@@ Sum = ceil ( ( double ) ( total@@ Sum ) / ( double ) ( x ) ) ; return abs ( per@@ Element@@ Sum - total@@ Ceil@@ Sum ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int K = 4 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ceil@@ Difference ( arr , N , K ) ; return 0 ; }
Count number of trip@@ lets with product not exce@@ eding a given number 9842 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int count@@ Trip@@ lets ( int N ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= N ; j ++ ) { if ( i * j > N ) break ; ans += N / ( i * j ) ; } } return ans ; } int main ( ) { int N = 10 ; cout << count@@ Trip@@ lets ( N ) ; return 0 ; }
Minim@@ ize Bit@@ wise XOR of array elements with 1 required to make sum of array at least K 9860 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int min@@ Step@@ K ( int arr [ ] , int N , int K ) { int E = 0 ; int S = 0 ; for ( int i = 0 ; i < N ; i ++ ) { S += arr [ i ] ; if ( arr [ i ] % 2 == 0 ) E += 1 ; } if ( S >= K ) return 0 ; else if ( S + E < K ) return -1 ; else return K - S ; } int main ( ) { int arr [ ] = { 0 , 1 , 1 , 0 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 4 ; cout << min@@ Step@@ K ( arr , N , K ) ; return 0 ; }
Count prime numbers up to N that can be represented as a sum of two prime numbers 9871 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( int n , bool prime [ ] ) { prime [ 0 ] = 0 ; prime [ 1 ] = 0 ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) { prime [ i ] = false ; } } } } void count@@ Prime ( int n ) { bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( n , prime ) ; int dp [ n + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 1 ] = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i ] += dp [ i - 1 ] ; if ( prime [ i ] == 1 && prime [ i - 2 ] == 1 ) { dp [ i ] ++ ; } } cout << dp [ n ] ; } int main ( ) { int N = 6 ; count@@ Prime ( N ) ; return 0 ; }
Sum of squares of differences between all pairs of an array 9901 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void sum@@ Of@@ Square@@ d@@ Differen@@ ces ( int arr [ ] , int N ) { int ans = 0 ; int sum@@ A = 0 , sum@@ B = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum@@ A += ( arr [ i ] * arr [ i ] ) ; sum@@ B += arr [ i ] ; } sum@@ A = N * sum@@ A ; sum@@ B = ( sum@@ B * sum@@ B ) ; ans = sum@@ A - sum@@ B ; cout << ans ; } int main ( ) { int arr [ ] = { 2 , 8 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sum@@ Of@@ Square@@ d@@ Differen@@ ces ( arr , N ) ; return 0 ; }
Count Arith@@ metic Progres@@ sions having sum S and common difference equal to D 9952 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ AP@@ s ( int S , int D ) { S = S * 2 ; int answer = 0 ; for ( int i = 1 ; i <= sqrt ( S ) ; i ++ ) { if ( S % i == 0 ) { if ( ( ( S / i ) - D * i + D ) % 2 == 0 ) answer ++ ; if ( ( D * i - ( S / i ) + D ) % 2 == 0 ) answer ++ ; } } return answer ; } int main ( ) { int S = 12 , D = 1 ; cout << count@@ AP@@ s ( S , D ) ; return 0 ; }
Maximum sum of K 9955 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int distinct ( vector < int > arr , int N ) { set < int > st ; for ( int i = 0 ; i < N ; i ++ ) { st . insert ( arr [ i ] ) ; } return st . size ( ) ; } int max@@ Sub@@ array@@ Sum@@ Util ( vector < int > arr , int N , int K , int total@@ Distin@@ ct ) { if ( K > N ) return 0 ; int mx = 0 ; int sum = 0 ; map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { mp [ arr [ i ] ] += 1 ; sum += arr [ i ] ; if ( i >= K ) { mp [ arr [ i - K ] ] -= 1 ; sum -= arr [ i - K ] ; if ( mp [ arr [ i - K ] ] == 0 ) mp . erase ( arr [ i - K ] ) ; } if ( mp . size ( ) == total@@ Distin@@ ct ) mx = max ( mx , sum ) ; } return mx ; } void max@@ Sub@@ array@@ Sum ( vector < int > arr , int K ) { int N = arr . size ( ) ; int total@@ Distin@@ ct = distinct ( arr , N ) ; cout << max@@ Sub@@ array@@ Sum@@ Util ( arr , N , K , total@@ Distin@@ ct ) ; } int main ( ) { vector < int > arr { 7 , 7 , 2 , 4 , 2 , 7 , 4 , 6 , 6 , 6 } ; int K = 6 ; max@@ Sub@@ array@@ Sum ( arr , K ) ; }
Sum of numbers obtained by the count of set and non 9998 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int process@@ Diagonal ( vector < int > arr ) { int ans = 0 ; int get@@ Bit = 1 ; for ( int i = 0 ; i < 32 ; i ++ ) { int S = 0 ; int NS = 0 ; for ( auto j : arr ) { if ( get@@ Bit & j ) S += 1 ; else NS += 1 ; } if ( S > NS ) ans += pow ( 2 , i ) ; get@@ Bit <<= 1 ; } return ans ; } int find@@ Sum ( vector < vector < int > > mat ) { int i = 0 ; int j = 0 ; vector < int > pri@@ Diag ; while ( i < mat . size ( ) ) { pri@@ Diag . push_back ( mat [ i ] [ j ] ) ; i += 1 ; j += 1 ; } i = 0 ; j = mat . size ( ) - 1 ; vector < int > sec@@ Diag ; while ( i < mat . size ( ) ) { sec@@ Diag . push_back ( mat [ i ] [ j ] ) ; i += 1 ; j -= 1 ; } return process@@ Diagonal ( pri@@ Diag ) + process@@ Diagonal ( sec@@ Diag ) ; } int main ( ) { vector < vector < int > > mat { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; cout << find@@ Sum ( mat ) << endl ; }
XOR and OR of all N 10948 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool isp@@ al@@ in ( int num ) { string s = to_string ( num ) ; int st = 0 , ed = s . size ( ) - 1 ; while ( st <= ed ) { if ( s [ st ] != s [ ed ] ) return false ; st ++ ; ed -- ; } return true ; } void Calculate@@ X@@ OR@@ and@@ OR ( int n ) { int Calculate@@ XOR = 0 ; int Calculate@@ OR = 0 ; int start = pow ( 10 , n - 1 ) ; int end = pow ( 10 , n ) - 1 ; for ( int i = start ; i <= end ; i ++ ) { if ( isp@@ al@@ in ( i ) ) { Calculate@@ XOR = Calculate@@ XOR ^ i ; Calculate@@ OR = Calculate@@ OR | i ; } } cout << " XOR ▁ = ▁ " << Calculate@@ XOR ; cout << " ▁ OR ▁ = ▁ " << Calculate@@ OR ; } int main ( ) { int n = 4 ; Calculate@@ X@@ OR@@ and@@ OR ( n ) ; return 0 ; }
Highe@@ st power of 2 less than or equal to given Integer 10952 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int pow@@ Of@@ Positive ( int n ) { int pos = floor ( log2 ( n ) ) ; return pow ( 2 , pos ) ; } int pow@@ Of@@ Negative ( int n ) { int pos = ceil ( log2 ( n ) ) ; return ( -1 * pow ( 2 , pos ) ) ; } void highest@@ PowerOf@@ 2 ( int n ) { if ( n > 0 ) { cout << pow@@ Of@@ Positive ( n ) ; } else { n = - n ; cout << pow@@ Of@@ Negative ( n ) ; } } int main ( ) { int n = -@@ 24 ; highest@@ PowerOf@@ 2 ( n ) ; return 0 ; }
Sum of altern@@ ating sign Squ@@ ares of first N natural numbers 10954 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int summ@@ ation ( int n ) { int abs_@@ sum = n * ( n + 1 ) / 2 ; int sign = n + 1 % 2 == 0 ? 1 : -1 ; int result_@@ sum = sign * abs_@@ sum ; return result_@@ sum ; } int main ( ) { int N = 2 ; cout << summ@@ ation ( N ) ; return 0 ; }
Count pairs in array such that one element is power of another 10956 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Power ( int x , int y ) { int res1 = log ( y ) / log ( x ) ; double res2 = log ( y ) / log ( x ) ; return ( res1 == res2 ) ; } int count@@ Power ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( is@@ Power ( arr [ i ] , arr [ j ] ) || is@@ Power ( arr [ j ] , arr [ i ] ) ) res ++ ; return res ; } int main ( ) { int a [ ] = { 16 , 2 , 3 , 9 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << count@@ Power ( a , n ) ; return 0 ; }
Number of cards needed build a House of Cards of a given level N 10960 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int noOf@@ Cards ( int n ) { return n * ( 3 * n + 1 ) / 2 ; } int main ( ) { int n = 3 ; cout << noOf@@ Cards ( n ) << " , ▁ " ; return 0 ; }
Pair of integers ( a , b ) which satisfy the given equations 10990 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int pair@@ Count ( int n , int m ) { int cnt = 0 , b , a ; for ( b = 0 ; b <= sqrt ( m ) ; b ++ ) { a = m - b * b ; if ( a * a + b == n ) { cnt ++ ; } } return cnt ; } int main ( ) { int n = 9 , m = 3 ; cout << pair@@ Count ( n , m ) << endl ; return 0 ; }
Count non decre@@ asing sub@@ arrays of size N from N Natur@@ al numbers 11003 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int bin@@ omi@@ al@@ Coeff ( int n , int k ) { int C [ k + 1 ] ; memset ( C , 0 , sizeof ( C ) ) ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; } int count_@@ of_@@ sub@@ arrays ( int N ) { int count = bin@@ omi@@ al@@ Coeff ( 2 * N - 1 , N ) ; return count ; } int main ( ) { int N = 3 ; cout << count_@@ of_@@ sub@@ arrays ( N ) << " STRNEWLINE " ; }
Divide N into K unique parts such that gcd of those parts is maximum 11028 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max@@ GC@@ D ( int N , int K ) { int min@@ Sum = ( K * ( K + 1 ) ) / 2 ; if ( N < min@@ Sum ) return -1 ; int i = sqrt ( N ) ; int res = 1 ; while ( i >= 1 ) { if ( N % i == 0 ) { if ( i >= min@@ Sum ) res = max ( res , N / i ) ; if ( N / i >= min@@ Sum ) res = max ( res , i ) ; } i -- ; } return res ; } int main ( ) { int N = 18 , K = 3 ; cout << max@@ GC@@ D ( N , K ) ; return 0 ; }
Sum of all N digit pal@@ ind@@ ro@@ me numbers 11037 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; long double getS@@ um ( int n ) { long double sum = 0 ; if ( n == 1 ) { sum = 45@@ .0 ; } else { sum = ( 99@@ .0 / 2.0 ) * pow ( 10 , n - 1 ) * pow ( 10 , ( n - 1 ) / 2 ) ; } return sum ; } int main ( ) { int n = 3 ; long double ans = getS@@ um ( n ) ; cout << setprecision ( 12 ) << ans << ' ' ; return 0 ; }
S@@ malle@@ st number divid@@ ing minimum number of elements in the array | Set 2 11047 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Min ( int * arr , int n ) { int m = 0 ; for ( int i = 0 ; i < n ; i ++ ) m = max ( m , arr [ i ] ) ; int freq [ m + 2 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; for ( int i = 1 ; i <= m + 1 ; i ++ ) { int j = i ; int cnt = 0 ; while ( j <= m ) { cnt += freq [ j ] ; j += i ; } if ( ! cnt ) return i ; } return m + 1 ; } int main ( ) { int arr [ ] = { 2 , 12 , 6 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << find@@ Min ( arr , n ) ; return 0 ; }
Remove minimum numbers from the array to get minimum OR value 11049 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Min@@ Del ( int * arr , int n ) { int min_@@ num = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) min_@@ num = min ( arr [ i ] , min_@@ num ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == min_@@ num ) cnt ++ ; return n - cnt ; } int main ( ) { int arr [ ] = { 3 , 3 , 2 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << find@@ Min@@ Del ( arr , n ) ; return 0 ; }
Count of numbers whose sum of increasing powers of digits is equal to the number itself 11062 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Digits ( int n ) { int cnt = 0 ; while ( n > 0 ) { cnt ++ ; n /= 10 ; } return cnt ; } int digit@@ Pow@@ Sum ( int n ) { int sum = 0 ; int pw = count@@ Digits ( n ) ; while ( n > 0 ) { int d = n % 10 ; sum += pow ( d , pw ) ; pw -- ; n /= 10 ; } return sum ; } int count@@ Num ( int n ) { int count = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i == digit@@ Pow@@ Sum ( i ) ) { count ++ ; } } return count ; } int main ( ) { int n = 200 ; cout << count@@ Num ( n ) ; return 0 ; }
Print all perfect squares from the given range 11063 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void perfec@@ t@@ Squ@@ ares ( float l , float r ) { for ( int i = l ; i <= r ; i ++ ) { if ( sqrt ( i ) == ( int ) sqrt ( i ) ) cout << i << " ▁ " ; } } int main ( ) { int l = 2 , r = 24 ; perfec@@ t@@ Squ@@ ares ( l , r ) ; return 0 ; }
Find the player who will win the Coin game 11075 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ Win@@ ner ( int n ) { if ( ( n - 1 ) % 6 == 0 ) { cout << " Second ▁ Player ▁ wins ▁ the ▁ game " ; } else { cout << " First ▁ Player ▁ wins ▁ the ▁ game " ; } } int main ( ) { int n = 7 ; find@@ Win@@ ner ( n ) ; }
Remove an element to minimize the LC@@ M of the given array 11094 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int l@@ cm ( int a , int b ) { int GC@@ D = __@@ gcd ( a , b ) ; return ( a * b ) / GC@@ D ; } int Min@@ LC@@ M ( int a [ ] , int n ) { int Prefix [ n + 2 ] ; int Suffix [ n + 2 ] ; Prefix [ 1 ] = a [ 0 ] ; for ( int i = 2 ; i <= n ; i += 1 ) { Prefix [ i ] = l@@ cm ( Prefix [ i - 1 ] , a [ i - 1 ] ) ; } Suffix [ n ] = a [ n - 1 ] ; for ( int i = n - 1 ; i >= 1 ; i -= 1 ) { Suffix [ i ] = l@@ cm ( Suffix [ i + 1 ] , a [ i - 1 ] ) ; } int ans = min ( Suffix [ 2 ] , Prefix [ n - 1 ] ) ; for ( int i = 2 ; i < n ; i += 1 ) { ans = min ( ans , l@@ cm ( Prefix [ i - 1 ] , Suffix [ i + 1 ] ) ) ; } return ans ; } int main ( ) { int a [ ] = { 5 , 15 , 9 , 36 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << Min@@ LC@@ M ( a , n ) ; return 0 ; }
Number of ways to distribute N P@@ aper Set among M students 11101 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; const int MOD = 100000000@@ 7 ; int fact@@ Mod ( int n ) { long fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { fact *= ( i % MOD ) ; fact %= MOD ; } return fact ; } int count@@ W@@ ays ( int n , int m ) { return fact@@ Mod ( m ) ; } int main ( ) { int n = 2 , m = 2 ; cout << count@@ W@@ ays ( n , m ) ; return 0 ; }
Check if a number is Eu@@ ler P@@ se@@ ud@@ op@@ ri@@ me 11104 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Composite ( int n ) { for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) return true ; } return false ; } int Power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) { res = ( res * x ) % p ; } x = ( x * x ) % p ; } return res ; } bool is@@ Euler@@ P@@ se@@ ud@@ op@@ ri@@ me ( int N , int A ) { if ( A <= 0 ) return false ; if ( N % 2 == 0 || ! is@@ Composite ( N ) ) return false ; if ( __@@ gcd ( A , N ) != 1 ) return false ; int mod = Power ( A , ( N - 1 ) / 2 , N ) ; if ( mod != 1 && mod != N - 1 ) return false ; return true ; } int main ( ) { int N = 121 , A = 3 ; if ( is@@ Euler@@ P@@ se@@ ud@@ op@@ ri@@ me ( N , A ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
Integer part of the geometric mean of the di@@ visors of N 11120 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int geo@@ metric@@ Mean ( int n ) { return sqrt ( n ) ; } int main ( ) { int n = 16 ; cout << geo@@ metric@@ Mean ( n ) ; return 0 ; }
Find K such that | A 11131 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find_@@ k ( int a , int b ) { if ( ( a + b ) % 2 == 0 ) return ( ( a + b ) / 2 ) ; return -1 ; } int main ( ) { int a = 2 , b = 16 ; cout << find_@@ k ( a , b ) ; return 0 ; }
Number of subsets whose mean is maximum 11136 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int cnt@@ Sub@@ Sets ( int arr [ ] , int n ) { int maxVal = * max_@@ element ( arr , arr + n ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == maxVal ) cnt ++ ; } return ( pow ( 2 , cnt ) - 1 ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << cnt@@ Sub@@ Sets ( arr , n ) ; return 0 ; }
Sum of all the numbers in the N@@ th row of the given triangle 11137 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int getS@@ um ( int n ) { return ( ( n - 1 ) + pow ( n , 2 ) ) ; } int main ( ) { int n = 3 ; cout << getS@@ um ( n ) ; return 0 ; }
Number of edges in a perfect binary tree with N levels 11138 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int cnt@@ Edges ( int n ) { int edges = pow ( 2 , n ) - 2 ; return edges ; } int main ( ) { int n = 4 ; cout << cnt@@ Edges ( n ) ; return 0 ; }
Find the count of natural Hex@@ a@@ decimal numbers of size N 11143 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count ( int n ) { return 15 * pow ( 16 , n - 1 ) ; } int main ( ) { int n = 2 ; cout << count ( n ) ; return 0 ; }
Probability that a random pair chosen from an array ( a [ i ] , a [ j ] ) has the maximum sum 11148 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; float find@@ Prob ( int arr [ ] , int n ) { long max@@ Sum = INT_@@ MIN , maxCount = 0 , total@@ Pairs = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int sum = arr [ i ] + arr [ j ] ; if ( sum == max@@ Sum ) { maxCount ++ ; } else if ( sum > max@@ Sum ) { max@@ Sum = sum ; maxCount = 1 ; } total@@ Pairs ++ ; } } float prob = ( float ) maxCount / ( float ) total@@ Pairs ; return prob ; } int main ( ) { int arr [ ] = { 1 , 1 , 1 , 2 , 2 , 2 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << find@@ Prob ( arr , n ) ; return 0 ; }
Find the previous fi@@ bon@@ ac@@ ci number 11153 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int previous@@ Fi@@ bon@@ ac@@ ci ( int n ) { double a = n / ( ( 1 + sqrt ( 5 ) ) / 2.0 ) ; return round ( a ) ; } int main ( ) { int n = 8 ; cout << ( previous@@ Fi@@ bon@@ ac@@ ci ( n ) ) ; }
Count of 0 s in an N 11156 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count ( int n ) { return 3 * n * ( n - 1 ) + 1 ; } int main ( ) { int n = 3 ; cout << count ( n ) ; return 0 ; }
Number of ways in which N can be represented as the sum of two positive integers 11171 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int ways ( int n ) { return n / 2 ; } int main ( ) { int n = 2 ; cout << ways ( n ) ; return 0 ; }
Minimum value to be assigned to the elements so that sum becomes greater than initial sum 11180 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Min@@ Value ( int arr [ ] , int n ) { long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return ( ( sum / n ) + 1 ) ; } int main ( ) { int arr [ ] = { 4 , 2 , 1 , 10 , 6 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << find@@ Min@@ Value ( arr , n ) ; return 0 ; }
Find the sum of all possible pairs in an array of N elements 11209 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int sum@@ Pairs ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ( arr [ i ] * ( 2 * n ) ) ; } return sum ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << sum@@ Pairs ( arr , n ) ; return 0 ; }
Minimum sum obtained from groups of four elements from the given array 11210 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int min@@ Sum ( int arr [ ] , int n ) { int sum = 0 ; sort ( arr , arr + n , greater < int > ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 4 < 2 ) sum = sum + arr [ i ] ; } return sum ; } int main ( ) { int arr [ ] = { 1 , 1 , 10 , 2 , 2 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << min@@ Sum ( arr , n ) ; return 0 ; }
Count of trip@@ les ( A , B , C ) where A * C is greater than B * B 11212 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; long long getCount ( int A , int B2 , int C ) { long long count = 0 ; for ( int i = 1 ; i <= A ; i ++ ) { long long j = ( B2 / i ) + 1 ; if ( C >= j ) count = ( count + C - j + 1 ) ; if ( A >= j && C >= i ) count = ( count + ( C - i + 1 ) * ( A - j + 1 ) ) ; if ( A >= j ) A = j - 1 ; } return count ; } long long count@@ Trip@@ lets ( int A , int B , int C ) { long long ans = 0 ; for ( int i = 1 ; i <= B ; i ++ ) { ans = ( ans + getCount ( A , i * i , C ) ) ; } return ans ; } int main ( ) { int A , B , C ; A = 3 , B = 2 , C = 2 ; cout << count@@ Trip@@ lets ( A , B , C ) ; }
Repe@@ ated sum of first N natural numbers 11221 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int sum ( int n ) { int sum = ( n * ( n + 1 ) ) / 2 ; return sum ; } int repeated@@ Sum ( int n , int k ) { for ( int i = 0 ; i < k ; i ++ ) { n = sum ( n ) ; } return n ; } int main ( ) { int n = 2 , k = 2 ; cout << repeated@@ Sum ( n , k ) ; return 0 ; }
Queries for the smallest and the largest prime number of given digit 11233 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define MAX 100000 NEW_LINE bool prime [ MAX + 1 ] ; void Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( ) { memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= MAX ; i += p ) prime [ i ] = false ; } } } int smalle@@ st@@ Prime ( int d ) { int l = pow ( 10 , d - 1 ) ; int r = pow ( 10 , d ) - 1 ; for ( int i = l ; i <= r ; i ++ ) { if ( prime [ i ] ) { return i ; } } return -1 ; } int lar@@ gest@@ Prime ( int d ) { int l = pow ( 10 , d - 1 ) ; int r = pow ( 10 , d ) - 1 ; for ( int i = r ; i >= l ; i -- ) { if ( prime [ i ] ) { return i ; } } return -1 ; } int main ( ) { Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( ) ; int queries [ ] = { 2 , 5 } ; int q = sizeof ( queries ) / sizeof ( queries [ 0 ] ) ; for ( int i = 0 ; i < q ; i ++ ) { cout << smalle@@ st@@ Prime ( queries [ i ] ) << " ▁ " << lar@@ gest@@ Prime ( queries [ i ] ) << endl ; } return 0 ; }
Divide first N natural numbers into 3 equal sum subsets 11236 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; bool possible ( int n ) { if ( n > 3 ) { int sum = ( n * ( n + 1 ) ) / 2 ; if ( sum % 3 == 0 ) { return true ; } } return false ; } int main ( ) { int n = 5 ; if ( possible ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
Check if an array is increasing or decre@@ asing 11240 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void check@@ Type ( int arr [ ] , int n ) { if ( arr [ 0 ] <= arr [ 1 ] && arr [ n - 2 ] <= arr [ n - 1 ] ) cout << " Incre@@ asing " ; else if ( arr [ 0 ] >= arr [ 1 ] && arr [ n - 2 ] >= arr [ n - 1 ] ) cout << " Decre@@ asing " ; else if ( arr [ 0 ] <= arr [ 1 ] && arr [ n - 2 ] >= arr [ n - 1 ] ) cout << " Incre@@ asing ▁ then ▁ decre@@ asing " ; else cout << " Decre@@ asing ▁ then ▁ increasing " ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; check@@ Type ( arr , n ) ; return 0 ; }
Sum of two numbers if the original ratio and new ratio obtained by adding a given number to each number is given 11284 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; double sum ( double a , double b , double c , double d , double x ) { double ans = ( x * ( a + b ) * ( c - d ) ) / ( ( a * d ) - ( b * c ) ) ; return ans ; } int main ( ) { double a = 1 , b = 2 , c = 9 , d = 13 , x = 5 ; cout << sum ( a , b , c , d , x ) ; return 0 ; }
Roots of the quadratic equation when a + b + c = 0 without using Sh@@ rid@@ har@@ ach@@ ary@@ a formula 11288 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ Roots ( long a , long b , long c ) { cout << 1 << " , ▁ " << c / ( a * 1.0 ) ; } int main ( ) { long a = 2 ; long b = 3 ; long c = -@@ 5 ; print@@ Roots ( a , b , c ) ; return 0 ; }
Maximum value after merging all elements in the array 11331 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int Ma@@ x_@@ sum ( int a [ ] , int n ) { int pos = 0 , neg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > 0 ) pos = 1 ; else if ( a [ i ] < 0 ) neg = 1 ; if ( pos == 1 and neg == 1 ) break ; } int sum = 0 ; if ( pos == 1 and neg == 1 ) { for ( int i = 0 ; i < n ; i ++ ) sum += abs ( a [ i ] ) ; } else if ( pos == 1 ) { int mini = a [ 0 ] ; sum = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { mini = min ( mini , a [ i ] ) ; sum += a [ i ] ; } sum -= 2 * mini ; } else if ( neg == 1 ) { for ( int i = 0 ; i < n ; i ++ ) a [ i ] = abs ( a [ i ] ) ; int mini = a [ 0 ] ; sum = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { mini = min ( mini , a [ i ] ) ; sum += a [ i ] ; } sum -= 2 * mini ; } return sum ; } int main ( ) { int a [ ] = { 1 , 3 , 5 , -2 , -@@ 6 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << Ma@@ x_@@ sum ( a , n ) ; return 0 ; }
Decimal to Binary using recursion and without using power operator 11342 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void decimal@@ To@@ Binary ( int n ) { if ( n == 0 ) { cout << "0" ; return ; } decimal@@ To@@ Binary ( n / 2 ) ; cout << n % 2 ; } int main ( ) { int n = 13 ; decimal@@ To@@ Binary ( n ) ; return 0 ; }
Find two vertices of an is@@ os@@ ce@@ les triangle in which there is rectangle with opposite corners ( 0 , 0 ) and ( X , Y ) 11358 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int Vertices ( int x , int y ) { int val = abs ( x ) + abs ( y ) ; cout << val * ( x < 0 ? -1 : 1 ) << " ▁ 0 ▁ " ; cout << "0 ▁ " << val * ( y < 0 ? -1 : 1 ) ; } int main ( ) { int x = 3 , y = 3 ; Vertices ( x , y ) ; return 0 ; }
Count pairs with set bits sum equal to K 11382 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define MAX 32 NEW_LINE unsigned int count@@ Set@@ Bits ( int n ) { unsigned int count = 0 ; while ( n ) { n &= ( n - 1 ) ; count ++ ; } return count ; } int pairs ( int arr [ ] , int n , int k ) { int count = 0 ; int f [ MAX + 1 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) f [ count@@ Set@@ Bits ( arr [ i ] ) ] ++ ; for ( int i = 0 ; i <= MAX ; i ++ ) { for ( int j = i ; j <= MAX ; j ++ ) { if ( i + j == k ) { if ( i == j ) count += ( ( f [ i ] * ( f [ i ] - 1 ) ) / 2 ) ; else count += ( f [ i ] * f [ j ] ) ; } } } return count ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 4 ; cout << pairs ( arr , n , k ) ; return 0 ; }
Queries to check whether all the elements can be made positive by fli@@ pping signs exactly K times 11393 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int cn@@ t_@@ neg ; bool exist@@ s_@@ zero ; void pre@@ Process ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 0 ) cn@@ t_@@ neg ++ ; if ( arr [ i ] == 0 ) exist@@ s_@@ zero = true ; } } bool is@@ Possible ( int k ) { if ( ! exist@@ s_@@ zero ) { if ( k >= cn@@ t_@@ neg and ( k - cn@@ t_@@ neg ) % 2 == 0 ) return true ; else return false ; } else { if ( k >= cn@@ t_@@ neg ) return true ; else return false ; } } int main ( ) { int arr [ ] = { -1 , 2 , -@@ 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( int ) ; pre@@ Process ( arr , n ) ; int queries [ ] = { 1 , 2 , 3 , 4 } ; int q = sizeof ( queries ) / sizeof ( int ) ; for ( int i = 0 ; i < q ; i ++ ) { if ( is@@ Possible ( queries [ i ] ) ) cout << " Yes " << endl ; else cout << " No " << endl ; } return 0 ; }
Queries for the difference between the count of composite and prime numbers in a given range 11401 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define MAX 1000000 NEW_LINE int prime [ MAX + 1 ] ; void update@@ Pri@@ mes ( ) { for ( int i = 2 ; i <= MAX ; i ++ ) { prime [ i ] = 1 ; } prime [ 0 ] = prime [ 1 ] = 0 ; for ( int i = 2 ; i * i <= MAX ; i ++ ) { if ( prime [ i ] == 1 ) { for ( int j = i * i ; j <= MAX ; j += i ) { prime [ j ] = 0 ; } } } for ( int i = 1 ; i <= MAX ; i ++ ) { prime [ i ] += prime [ i - 1 ] ; } } int get@@ Difference ( int l , int r ) { int total = r - l + 1 ; int primes = prime [ r ] - prime [ l - 1 ] ; int composi@@ tes = total - primes ; return ( abs ( primes - composi@@ tes ) ) ; } int main ( ) { int queries [ ] [ 2 ] = { { 1 , 10 } , { 5 , 30 } } ; int q = sizeof ( queries ) / sizeof ( queries [ 0 ] ) ; update@@ Pri@@ mes ( ) ; for ( int i = 0 ; i < q ; i ++ ) cout << get@@ Difference ( queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) << endl ; return 0 ; }
Find the index which is the last to be reduced to zero after performing a given operation 11420 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Index ( int a [ ] , int n , int k ) { int index = -1 , max_@@ ceil = INT_@@ MIN ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = ( a [ i ] + k - 1 ) / k ; } for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= max_@@ ceil ) { max_@@ ceil = a [ i ] ; index = i ; } } return index ; } int main ( ) { int arr [ ] = { 31 , 12 , 25 , 27 , 32 , 19 } ; int K = 5 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << find@@ Index ( arr , N , K ) ; return 0 ; }
Count index pairs which satisfy the given condition 11422 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int Count_@@ Segment ( int p [ ] , int n ) { int count = 0 ; int upto [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) upto [ i ] = 0 ; int j = 0 , curr = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { if ( p [ i ] > p [ i - 1 ] and p [ i ] > p [ i + 1 ] ) { curr = p [ i ] ; j = i - 1 ; while ( j >= 0 and p [ j ] < curr ) { upto [ p [ j ] ] = curr ; j -= 1 ; } j = i + 1 ; while ( j < n and p [ j ] < curr ) { if ( upto [ curr - p [ j ] ] == curr ) count += 1 ; j += 1 ; } } } return count ; } int main ( ) { int p [ ] = { 3 , 4 , 1 , 5 , 2 } ; int n = sizeof ( p ) / sizeof ( p [ 0 ] ) ; cout << ( Count_@@ Segment ( p , n ) ) ; return 0 ; }
Number of positions such that adding K to the element is greater than sum of all other elements 11451 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int valid@@ Position ( int arr [ ] , int N , int K ) { int count = 0 , sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] + K ) > ( sum - arr [ i ] ) ) count ++ ; } return count ; } int main ( ) { int arr [ ] = { 2 , 1 , 6 , 7 } , K = 4 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << valid@@ Position ( arr , N , K ) ; return 0 ; }
Count pairs with average present in the same array 11454 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; const int N = 1000 ; int count@@ Pairs ( int arr [ ] , int n ) { int size = ( 2 * N ) + 1 ; int freq [ size ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] ; freq [ x + N ] ++ ; } int ans = 0 ; for ( int i = 0 ; i < size ; i ++ ) { if ( freq [ i ] > 0 ) { ans += ( ( freq [ i ] ) * ( freq [ i ] - 1 ) ) / 2 ; for ( int j = i + 2 ; j < 2001 ; j += 2 ) { if ( freq [ j ] > 0 && ( freq [ ( i + j ) / 2 ] > 0 ) ) { ans += ( freq [ i ] * freq [ j ] ) ; } } } } return ans ; } int main ( ) { int arr [ ] = { 4 , 2 , 5 , 1 , 3 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << count@@ Pairs ( arr , n ) ; return 0 ; }
Highe@@ st power of 2 that divi@@ des a number represented in binary 11463 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int highest@@ Power ( string str , int len ) { int ans = 0 ; for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == '0' ) ans ++ ; else break ; } return ans ; } int main ( ) { string str = "100@@ 100" ; int len = str . length ( ) ; cout << highest@@ Power ( str , len ) ; return 0 ; }
Check if a given number divi@@ des the sum of the factor@@ i@@ als of its digits 11524 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Possible ( int n ) { int fac [ 10 ] ; fac [ 0 ] = fac [ 1 ] = 1 ; for ( int i = 2 ; i < 10 ; i ++ ) fac [ i ] = fac [ i - 1 ] * i ; int sum = 0 ; int x = n ; while ( x ) { sum += fac [ x % 10 ] ; x /= 10 ; } if ( sum % n == 0 ) return true ; return false ; } int main ( ) { int n = 19 ; if ( is@@ Possible ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
Check if product of array containing prime numbers is a perfect square 11538 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Per@@ fec@@ t@@ Square ( int arr [ ] , int n ) { unordered_map < int , int > u@@ map ; for ( int i = 0 ; i < n ; i ++ ) u@@ map [ arr [ i ] ] ++ ; unordered_map < int , int > :: iterator itr ; for ( itr = u@@ map . begin ( ) ; itr != u@@ map . end ( ) ; itr ++ ) if ( ( itr -> second ) % 2 == 1 ) return false ; return true ; } int main ( ) { int arr [ ] = { 2 , 2 , 7 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( is@@ Per@@ fec@@ t@@ Square ( arr , n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
Find a pair from the given array with maximum n@@ Cr value 11555 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ Max@@ Val@@ Pair ( vector < long long > & v , int n ) { sort ( v . begin ( ) , v . end ( ) ) ; long long N = v [ n - 1 ] ; if ( N % 2 == 1 ) { long long first_@@ maxim@@ a = N / 2 ; long long second_@@ maxim@@ a = first_@@ maxim@@ a + 1 ; long long ans@@ 1 = 3e@@ 18 , ans@@ 2 = 3e@@ 18 ; long long from_@@ left = -1 , from_@@ right = -1 ; long long from = -1 ; for ( long long i = 0 ; i < n ; ++ i ) { if ( v [ i ] > first_@@ maxim@@ a ) { from = i ; break ; } else { long long diff = first_@@ maxim@@ a - v [ i ] ; if ( diff < ans@@ 1 ) { ans@@ 1 = diff ; from_@@ left = v [ i ] ; } } } from_@@ right = v [ from ] ; long long diff@@ 1 = first_@@ maxim@@ a - from_@@ left ; long long diff@@ 2 = from_@@ right - second_@@ maxim@@ a ; if ( diff@@ 1 < diff@@ 2 ) cout << N << " ▁ " << from_@@ left ; else cout << N << " ▁ " << from_@@ right ; } else { long long maxim@@ a = N / 2 ; long long ans@@ 1 = 3e@@ 18 ; long long R = -1 ; for ( long long i = 0 ; i < n - 1 ; ++ i ) { long long diff = abs ( v [ i ] - maxim@@ a ) ; if ( diff < ans@@ 1 ) { ans@@ 1 = diff ; R = v [ i ] ; } } cout << N << " ▁ " << R ; } } int main ( ) { vector < long long > v = { 1 , 1 , 2 , 3 , 6 , 1 } ; int n = v . size ( ) ; print@@ Max@@ Val@@ Pair ( v , n ) ; return 0 ; }
Number of quad@@ rup@@ les where the first three terms are in AP and last three terms are in GP 11613 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Quad@@ rup@@ les ( int a [ ] , int n ) { unordered_map < int , int > mp@@ p ; for ( int i = 0 ; i < n ; i ++ ) mp@@ p [ a [ i ] ] ++ ; int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( j == k ) continue ; mp@@ p [ a [ j ] ] -- ; mp@@ p [ a [ k ] ] -- ; int first = a [ j ] - ( a [ k ] - a [ j ] ) ; int fourth = ( a [ k ] * a [ k ] ) / a [ j ] ; if ( ( a [ k ] * a [ k ] ) % a [ j ] == 0 ) { if ( a [ j ] != a [ k ] ) count += mp@@ p [ first ] * mp@@ p [ fourth ] ; else count += mp@@ p [ first ] * ( mp@@ p [ fourth ] - 1 ) ; } mp@@ p [ a [ j ] ] ++ ; mp@@ p [ a [ k ] ] ++ ; } } return count ; } int main ( ) { int a [ ] = { 2 , 6 , 4 , 9 , 2 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << count@@ Quad@@ rup@@ les ( a , n ) ; return 0 ; }
Position of a person di@@ am@@ etri@@ cally opposite on a circle 11636 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int getPosition ( int n , int m ) { if ( m > ( n / 2 ) ) return ( m - ( n / 2 ) ) ; return ( m + ( n / 2 ) ) ; } int main ( ) { int n = 8 , m = 5 ; cout << getPosition ( n , m ) ; return 0 ; }
Minimum operations required to modify the array such that parity of adjacent elements is different 11639 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int parity ( int a ) { return a % 3 ; } int solve ( int array [ ] , int size ) { int operations = 0 ; for ( int i = 0 ; i < size - 1 ; i ++ ) { if ( parity ( array [ i ] ) == parity ( array [ i + 1 ] ) ) { operations ++ ; if ( i + 2 < size ) { int par@@ i1 = parity ( array [ i ] ) ; int par@@ i2 = parity ( array [ i + 2 ] ) ; if ( par@@ i1 == par@@ i2 ) { if ( par@@ i1 == 0 ) array [ i + 1 ] = 1 ; else if ( par@@ i1 == 1 ) array [ i + 1 ] = 0 ; else array [ i + 1 ] = 1 ; } else { if ( ( par@@ i1 == 0 && par@@ i2 == 1 ) || ( par@@ i1 == 1 && par@@ i2 == 0 ) ) array [ i + 1 ] = 2 ; if ( ( par@@ i1 == 1 && par@@ i2 == 2 ) || ( par@@ i1 == 2 && par@@ i2 == 1 ) ) array [ i + 1 ] = 0 ; if ( ( par@@ i1 == 2 && par@@ i2 == 0 ) || ( par@@ i1 == 0 && par@@ i2 == 2 ) ) array [ i + 1 ] = 1 ; } } } } return operations ; } int main ( ) { int array [ ] = { 2 , 1 , 3 , 0 } ; int size = sizeof ( array ) / sizeof ( array [ 0 ] ) ; cout << solve ( array , size ) << endl ; return 0 ; }
Split the array into odd number of segments of odd lengths 11655 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool check@@ Array ( int arr [ ] , int n ) { return ( arr [ 0 ] % 2 ) && ( arr [ n - 1 ] % 2 ) && ( n % 2 ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ( int ) check@@ Array ( arr , n ) ; return 0 ; }
Count trip@@ let pairs ( A , B , C ) of points in 2 11688 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Trip@@ lets ( int n , vector < pair < int , int > > points ) { set < pair < int , int > > pts ; int ct = 0 ; for ( int i = 0 ; i < n ; i ++ ) pts . insert ( points [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) { int x = points [ i ] . first + points [ j ] . first ; int y = points [ i ] . second + points [ j ] . second ; if ( x % 2 == 0 && y % 2 == 0 ) if ( pts . find ( make_pair ( x / 2 , y / 2 ) ) != pts . end ( ) ) ct ++ ; } return ct ; } int main ( ) { vector < pair < int , int > > points = { { 1 , 1 } , { 2 , 2 } , { 3 , 3 } } ; int n = points . size ( ) ; cout << count@@ Trip@@ lets ( n , points ) ; }
S@@ malle@@ st perfect Cube di@@ visible by all elements of an array 11748 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define ll long long int NEW_LINE ll gcd ( ll a , ll b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; } ll l@@ cm@@ Of@@ Array ( int arr [ ] , int n ) { if ( n < 1 ) return 0 ; ll l@@ cm = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) l@@ cm = ( l@@ cm * arr [ i ] ) / gcd ( l@@ cm , arr [ i ] ) ; return l@@ cm ; } int min@@ Per@@ fec@@ t@@ Cube ( int arr [ ] , int n ) { ll min@@ Per@@ fec@@ t@@ Cube ; ll l@@ cm = l@@ cm@@ Of@@ Array ( arr , n ) ; min@@ Per@@ fec@@ t@@ Cube = ( long long ) l@@ cm ; int cnt = 0 ; while ( l@@ cm > 1 && l@@ cm % 2 == 0 ) { cnt ++ ; l@@ cm /= 2 ; } if ( cnt % 3 == 2 ) min@@ Per@@ fec@@ t@@ Cube *= 2 ; else if ( cnt % 3 == 1 ) min@@ Per@@ fec@@ t@@ Cube *= 4 ; int i = 3 ; while ( l@@ cm > 1 ) { cnt = 0 ; while ( l@@ cm % i == 0 ) { cnt ++ ; l@@ cm /= i ; } if ( cnt % 3 == 1 ) min@@ Per@@ fec@@ t@@ Cube *= i * i ; else if ( cnt % 3 == 2 ) min@@ Per@@ fec@@ t@@ Cube *= i ; i += 2 ; } return min@@ Per@@ fec@@ t@@ Cube ; } int main ( ) { int arr [ ] = { 10 , 125 , 14 , 42 , 100 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << min@@ Per@@ fec@@ t@@ Cube ( arr , n ) ; return 0 ; }
Maximum GC@@ D of N integers with given product 11792 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max@@ GC@@ D ( int N , int P ) { int ans = 1 ; unordered_map < int , int > pri@@ me_@@ factors ; for ( int i = 2 ; i * i <= P ; i ++ ) { while ( P % i == 0 ) { pri@@ me_@@ factors [ i ] ++ ; P /= i ; } } if ( P != 1 ) pri@@ me_@@ factors [ P ] ++ ; for ( auto v : pri@@ me_@@ factors ) ans *= pow ( v . first , v . second / N ) ; return ans ; } int main ( ) { int N = 3 , P = 24 ; cout << max@@ GC@@ D ( N , P ) ; return 0 ; }
Count number of trip@@ lets ( a , b , c ) such that a ^ 2 + b ^ 2 = c ^ 2 and 1 <= a <= b <= c <= n 11860 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; vector < int > get@@ Per@@ fec@@ t@@ Squ@@ ares ( int n ) { vector < int > perfec@@ t@@ Squ@@ ares ; int current = 1 , i = 1 ; while ( current <= n ) { perfec@@ t@@ Squ@@ ares . push_back ( current ) ; current = pow ( ++ i , 2 ) ; } return perfec@@ t@@ Squ@@ ares ; } int count@@ Trip@@ lets ( int n ) { vector < int > perfec@@ t@@ Squ@@ ares = get@@ Per@@ fec@@ t@@ Squ@@ ares ( pow ( n , 2 ) ) ; int count = 0 ; for ( int a = 1 ; a <= n ; a ++ ) { int a@@ Square = pow ( a , 2 ) ; for ( int i = 0 ; i < perfec@@ t@@ Squ@@ ares . size ( ) ; i ++ ) { int c@@ Square = perfec@@ t@@ Squ@@ ares [ i ] ; int b@@ Square = abs ( c@@ Square - a@@ Square ) ; int b = sqrt ( b@@ Square ) ; int c = sqrt ( c@@ Square ) ; if ( c < a || ( find ( perfec@@ t@@ Squ@@ ares . begin ( ) , perfec@@ t@@ Squ@@ ares . end ( ) , b@@ Square ) == perfec@@ t@@ Squ@@ ares . end ( ) ) ) continue ; if ( ( b >= a ) && ( b <= c ) && ( a@@ Square + b@@ Square == c@@ Square ) ) count ++ ; } } return count ; } int main ( ) { int n = 10 ; cout << count@@ Trip@@ lets ( n ) ; return 0 ; }
Minimum number of moves required to reach the destination by the king in a che@@ ss board 11874 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void Min@@ Steps ( int Source@@ X , int Source@@ Y , int Dest@@ X , int Dest@@ Y ) { cout << max ( abs ( Source@@ X - Dest@@ X ) , abs ( Source@@ Y - Dest@@ Y ) ) << endl ; while ( ( Source@@ X != Dest@@ X ) || ( Source@@ Y != Dest@@ Y ) ) { if ( Source@@ X < Dest@@ X ) { cout << ' U ' ; Source@@ X ++ ; } if ( Source@@ X > Dest@@ X ) { cout << ' D ' ; Source@@ X -- ; } if ( Source@@ Y > Dest@@ Y ) { cout << ' L ' ; Source@@ Y -- ; } if ( Source@@ Y < Dest@@ Y ) { cout << ' R ' ; Source@@ Y ++ ; } cout << endl ; } } int main ( ) { int source@@ X = 4 , source@@ Y = 4 ; int destination@@ X = 7 , destination@@ Y = 0 ; Min@@ Steps ( source@@ X , source@@ Y , destination@@ X , destination@@ Y ) ; return 0 ; }
Sum of all odd length pal@@ ind@@ ro@@ mic numbers within the range [ L , R ] 11887 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Pal@@ ind@@ ro@@ me ( int num ) { int reverse_@@ num = 0 , remainder , temp ; temp = num ; while ( temp != 0 ) { remainder = temp % 10 ; reverse_@@ num = reverse_@@ num * 10 + remainder ; temp /= 10 ; } if ( reverse_@@ num == num ) { return true ; } return false ; } bool is@@ O@@ dd@@ Length ( int num ) { int count = 0 ; while ( num > 0 ) { num /= 10 ; count ++ ; } if ( count % 2 != 0 ) { return true ; } return false ; } long sum@@ Of@@ All@@ Pal@@ ind@@ ro@@ me ( int L , int R ) { long sum = 0 ; if ( L <= R ) for ( int i = L ; i <= R ; i ++ ) { if ( is@@ Pal@@ ind@@ ro@@ me ( i ) && is@@ O@@ dd@@ Length ( i ) ) { sum += i ; } } return sum ; } int main ( ) { int L = 110 , R = 11@@ 30 ; cout << " ▁ " << sum@@ Of@@ All@@ Pal@@ ind@@ ro@@ me ( L , R ) << endl ; }
Check whether product of digits at even places is di@@ visible by sum of digits at odd place of a number 11929 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool product@@ Sum@@ Di@@ visible ( int n , int size ) { int sum = 0 , product = 1 ; while ( n > 0 ) { if ( size % 2 == 0 ) { product *= n % 10 ; } else { sum += n % 10 ; } n = n / 10 ; size -- ; } if ( product % sum == 0 ) return true ; return false ; } int main ( ) { int n = 1234 ; int len = 4 ; if ( product@@ Sum@@ Di@@ visible ( n , len ) ) cout << " TRUE " ; else cout << " FALSE " ; return 0 ; }
Sum and Product of digits in a number that divide the number 11939 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void count@@ Digit ( int n ) { int temp = n , sum = 0 , product = 1 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 ) { sum += d ; product *= d ; } } cout << " Sum ▁ = ▁ " << sum ; cout << " Product = " } int main ( ) { int n = 101@@ 2 ; count@@ Digit ( n ) ; return 0 ; }
Product of every K ’ th prime number in an array 11977 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define MAX 1000000 NEW_LINE bool prime [ MAX + 1 ] ; void Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( ) { memset ( prime , true , sizeof ( prime ) ) ; prime [ 1 ] = false ; prime [ 0 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } } void product@@ Of@@ K@@ th@@ Pri@@ mes ( int arr [ ] , int n , int k ) { int c = 0 ; long long int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { c ++ ; if ( c % k == 0 ) { product *= arr [ i ] ; c = 0 ; } } } cout << product << endl ; } int main ( ) { Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( ) ; int n = 5 , k = 2 ; int arr [ n ] = { 2 , 3 , 5 , 7 , 11 } ; product@@ Of@@ K@@ th@@ Pri@@ mes ( arr , n , k ) ; return 0 ; }
Program to find the nth Ky@@ ne@@ a number 12055 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; long n@@ th@@ Ky@@ ne@@ a@@ Number ( int n ) { return ( ( 1 << ( 2 * n ) ) + ( 1 << ( n + 1 ) ) - 1 ) ; } int main ( ) { int n = 2 ; cout << n@@ th@@ Ky@@ ne@@ a@@ Number ( n ) ; return 0 ; }
Value of the series ( 1 ^ 3 + 2 ^ 3 + 3 ^ 3 + ... + n ^ 3 ) mod 4 for a given n 12068 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int fn@@ Mod ( int n ) { int rem = n % 4 ; if ( rem == 0 rem == 3 ) return 0 ; else if ( rem == 1 rem == 2 ) return 1 ; } int main ( ) { int n = 6 ; cout << fn@@ Mod ( n ) ; return 0 ; }
Maxim@@ ize the product of four factors of a Number 12222 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int mod@@ Exp ( int a , int b ) { int result = 1 ; while ( b > 0 ) { if ( b & 1 ) result = result * a ; a = a * a ; b /= 2 ; } return result ; } int check ( int num ) { if ( num & 1 num < 3 ) return -1 ; else if ( num % 4 == 0 ) return mod@@ Exp ( num / 4 , 4 ) ; else if ( num % 6 == 0 ) return mod@@ Exp ( num / 3 , 2 ) * mod@@ Exp ( num / 6 , 2 ) ; else if ( num % 10 == 0 ) return mod@@ Exp ( num / 5 , 2 ) * ( num / 10 ) * ( num / 2 ) ; else return -1 ; } int main ( ) { int num = 10 ; cout << check ( num ) ; return 0 ; }
Program to find the head start in a race 12225 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int Race ( int B , int C ) { int result = 0 ; result = ( ( C * 100 ) / B ) ; return 100 - result ; } int main ( ) { int B = 10 , C = 28 ; B = 100 - B ; C = 100 - C ; cout << Race ( B , C ) << " ▁ meters " ; return 0 ; }
Number of Per@@ mutations such that no Three Terms forms Incre@@ asing Sub@@ sequence 12260 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; unsigned long int bin@@ omi@@ al@@ Coeff ( unsigned int n , unsigned int k ) { unsigned long int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } unsigned long int catal@@ an ( unsigned int n ) { unsigned long int c = bin@@ omi@@ al@@ Coeff ( 2 * n , n ) ; return c / ( n + 1 ) ; } int main ( ) { int n = 3 ; cout << catal@@ an ( n ) << endl ; return 0 ; }
Program to calculate distance between two points in 3 D 12321 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE #@@ include <@@ io@@ manip@@ > NEW_LINE #@@ include <@@ io@@ stream@@ > NEW_LINE #@@ include <@@ math@@ .@@ h@@ > NEW_LINE using namespace std ; void distance ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 ) { float d = sqrt ( pow ( x2 - x1 , 2 ) + pow ( y2 - y1 , 2 ) + pow ( z2 - z1 , 2 ) * 1.0 ) ; std :: cout << std :: fixed ; std :: cout << std :: setprecision ( 2 ) ; cout << " ▁ Distance ▁ is ▁ " << d ; return ; } int main ( ) { float x1 = 2 ; float y1 = -@@ 5 ; float z1 = 7 ; float x2 = 3 ; float y2 = 4 ; float z2 = 5 ; distance ( x1 , y1 , z1 , x2 , y2 , z2 ) ; return 0 ; }
Program to find greater value between a ^ n and b ^ n 12353 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ Greater ( int a , int b , int n ) { if ( ! ( n & 1 ) ) { a = abs ( a ) ; b = abs ( b ) ; } if ( a == b ) cout << " a ^ n ▁ is ▁ equal ▁ to ▁ b ^ n " ; else if ( a > b ) cout << " a ^ n ▁ is ▁ greater ▁ than ▁ b ^ n " ; else cout << " b ^ n ▁ is ▁ greater ▁ than ▁ a ^ n " ; } int main ( ) { int a = 12 , b = 24 , n = 5 ; find@@ Greater ( a , b , n ) ; return 0 ; }
Subtract 1 without arithmetic operators 12374 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int subtr@@ act@@ One ( int x ) { int m = 1 ; while ( ! ( x & m ) ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; } int main ( ) { cout << subtr@@ act@@ One ( 13 ) << endl ; return 0 ; }
Program for sum of cos ( x ) series 12455 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; const double PI = 3.14@@ 2 ; double cos@@ X@@ Ser@@ ties@@ Sum ( double x , int n ) { x = x * ( PI / 180.0 ) ; double res = 1 ; double sign = 1 , fact = 1 , pow = 1 ; for ( int i = 1 ; i < 5 ; i ++ ) { sign = sign * -1 ; fact = fact * ( 2 * i - 1 ) * ( 2 * i ) ; pow = pow * x * x ; res = res + sign * pow / fact ; } return res ; } int main ( ) { float x = 50 ; int n = 5 ; cout << cos@@ X@@ Ser@@ ties@@ Sum ( x , 5 ) ; return 0 ; }
S@@ malle@@ st triangular number larger than p 12513 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Bucket@@ No ( int p ) { return ceil ( ( sqrt ( 8 * p + 1 ) - 1 ) / 2 ) ; } int main ( ) { int p = 10 ; cout << find@@ Bucket@@ No ( p ) ; return 0 ; }
Expres@@ sing factorial n as sum of consecutive numbers 12518 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define MAX 500@@ 02 NEW_LINE vector < int > primes ; void si@@ eve ( ) { bool is@@ Prime [ MAX ] ; memset ( is@@ Prime , true , sizeof ( is@@ Prime ) ) ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( is@@ Prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) is@@ Prime [ i ] = false ; } } for ( int p = 2 ; p < MAX ; p ++ ) if ( is@@ Prime [ p ] ) primes . push_back ( p ) ; } long long int power ( long long int x , long long int y ) { long long int count = 0 ; long long int z = y ; while ( x >= z ) { count += ( x / z ) ; z *= y ; } return count ; } long long int mod@@ Mult ( long long int a , long long int b , long long int mod ) { long long int res = 0 ; a = a % mod ; while ( b > 0 ) { if ( b % 2 == 1 ) res = ( res + a ) % mod ; a = ( a * 2 ) % mod ; b /= 2 ; } return res % mod ; } long long int count@@ W@@ ays ( long long int n , long long int m ) { long long int ans = 1 ; for ( int i = 1 ; i < primes . size ( ) ; i ++ ) { long long int powers = power ( n , primes [ i ] ) ; if ( powers == 0 ) break ; ans = mod@@ Mult ( ans , powers + 1 , m ) % m ; } if ( ( ( ans - 1 ) % m ) < 0 ) return ( ans - 1 + m ) % m ; else return ( ans - 1 ) % m ; } int main ( ) { si@@ eve ( ) ; long long int n = 4 , m = 7 ; cout << count@@ W@@ ays ( n , m ) ; return 0 ; }
Py@@ th@@ ag@@ ore@@ an Trip@@ let with given sum 12523 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void py@@ th@@ ag@@ ore@@ an@@ Trip@@ let ( int n ) { for ( int i = 1 ; i <= n / 3 ; i ++ ) { for ( int j = i + 1 ; j <= n / 2 ; j ++ ) { int k = n - i - j ; if ( i * i + j * j == k * k ) { cout << i << " , ▁ " << j << " , ▁ " << k ; return ; } } } cout << " No ▁ Trip@@ let " ; } int main ( ) { int n = 12 ; py@@ th@@ ag@@ ore@@ an@@ Trip@@ let ( n ) ; return 0 ; }
Recursive sum of digits of a number formed by repeated appends 12538 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int dig@@ Sum ( int n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; } int repeated@@ Number@@ Sum ( int n , int x ) { int sum = x * dig@@ Sum ( n ) ; return dig@@ Sum ( sum ) ; } int main ( ) { int n = 24 , x = 3 ; cout << repeated@@ Number@@ Sum ( n , x ) << endl ; return 0 ; }
Writing power function for large numbers 12573 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; #@@ define MAX 100000 NEW_LINE int multiply ( int x , int res [ ] , int res@@ _size ) { int carry = 0 ; for ( int i = 0 ; i < res@@ _size ; i ++ ) { int prod = res [ i ] * x + carry ; res [ i ] = prod % 10 ; carry = prod / 10 ; } while ( carry ) { res [ res@@ _size ] = carry % 10 ; carry = carry / 10 ; res@@ _size ++ ; } return res@@ _size ; } void power ( int x , int n ) { if ( n == 0 ) { cout << "1" ; return ; } int res [ MAX ] ; int res@@ _size = 0 ; int temp = x ; while ( temp != 0 ) { res [ res@@ _size ++ ] = temp % 10 ; temp = temp / 10 ; } for ( int i = 2 ; i <= n ; i ++ ) res@@ _size = multiply ( x , res , res@@ _size ) ; cout << x << " ^ " << n << " ▁ = ▁ " ; for ( int i = res@@ _size - 1 ; i >= 0 ; i -- ) cout << res [ i ] ; } int main ( ) { int exponent = 100 ; int base = 20 ; power ( base , exponent ) ; return 0 ; }
Area of a square from diagonal length 12593 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; double find@@ Area ( double d ) { return ( d * d ) / 2.0 ; } int main ( ) { double d = 10 ; cout << ( find@@ Area ( d ) ) ; return 0 ; }
Find N integers with given difference between product and sum 12623 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; void find@@ Numbers ( int n , int d ) { for ( int i = 0 ; i < n - 2 ; i ++ ) cout << "1" << " ▁ " ; cout << "2" << " ▁ " ; cout << n + d << endl ; } int main ( ) { int N = 3 , D = 5 ; find@@ Numbers ( N , D ) ; return 0 ; }
Average of Squ@@ ares of Natur@@ al Numbers 12672 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; float Av@@ go@@ f@@ Square@@ N ( int n ) { float sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum / n ; } int main ( ) { int n = 2 ; cout << Av@@ go@@ f@@ Square@@ N ( n ) ; return 0 ; }
Find LC@@ M of rational numbers 12679 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int LC@@ M ( int a , int b ) { return ( a * b ) / ( __@@ gcd ( a , b ) ) ; } int l@@ cm@@ Of@@ Numer@@ ator ( vector < pair < int , int > > vect ) { int l@@ cm = vect [ 0 ] . first ; for ( int i = 1 ; i < vect . size ( ) ; i ++ ) l@@ cm = LC@@ M ( vect [ i ] . first , l@@ cm ) ; return l@@ cm ; } int g@@ cd@@ Of@@ De@@ mon@@ in@@ ators ( vector < pair < int , int > > vect ) { int gcd = vect [ 0 ] . second ; for ( int i = 1 ; i < vect . size ( ) ; i ++ ) gcd = __@@ gcd ( vect [ i ] . second , gcd ) ; return gcd ; } void l@@ cm@@ Of@@ R@@ ation@@ als ( vector < pair < int , int > > vect ) { cout << l@@ cm@@ Of@@ Numer@@ ator ( vect ) << " / " << g@@ cd@@ Of@@ De@@ mon@@ in@@ ators ( vect ) ; } int main ( ) { vector < pair < int , int > > vect ; vect . push_back ( make_pair ( 2 , 7 ) ) ; vect . push_back ( make_pair ( 3 , 14 ) ) ; vect . push_back ( make_pair ( 5 , 3 ) ) ; l@@ cm@@ Of@@ R@@ ation@@ als ( vect ) ; return 0 ; }
Sum of Arith@@ metic Geo@@ metric Sequence 12695 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int su@@ mo@@ f@@ N@@ term ( int a , int d , int b , int r , int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( ( a + ( i - 1 ) * d ) * ( b * pow ( r , i - 1 ) ) ) ; return sum ; } int main ( ) { int a = 1 , d = 1 , b = 2 , r = 2 , n = 3 ; cout << su@@ mo@@ f@@ N@@ term ( a , d , b , r , n ) << endl ; return 0 ; }
First occurrence of a digit in a given fraction 12724 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int first ( int a , int b , int c ) { a %= b ; for ( int i = 1 ; i <= b ; i ++ ) { a = a * 10 ; if ( a / b == c ) return i ; a %= b ; } return -1 ; } int main ( ) { int a = 1 , b = 4 , c = 5 ; cout << first ( a , b , c ) ; return 0 ; }
Break a number such that sum of maximum di@@ visors of all parts is minimum 12766 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; bool is@@ Prime ( int n ) { int i = 2 ; while ( i * i <= n ) { if ( n % i == 0 ) return false ; i ++ ; } return true ; } int minimum@@ Sum ( int n ) { if ( is@@ Prime ( n ) ) return 1 ; if ( n % 2 == 0 ) return 2 ; if ( is@@ Prime ( n - 2 ) ) return 2 ; return 3 ; } int main ( ) { int n = 27 ; cout << minimum@@ Sum ( n ) ; return 0 ; }
Find n 12808 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int term ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans += i ; return ans ; } int main ( ) { int n = 4 ; cout << term ( n ) ; return 0 ; }
Sum of the Series 1 + x / 1 + x ^ 2 / 2 + x ^ 3 / 3 + . . + x ^ n / n 12814 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; double sum ( int x , int n ) { double i , total = 1.0 , multi = x ; for ( i = 1 ; i <= n ; i ++ ) { total = total + multi / i ; multi = multi * x ; } return total ; } int main ( ) { int x = 2 ; int n = 5 ; cout << fixed << setprecision ( 2 ) << sum ( x , n ) ; return 0 ; }
Program to find GC@@ D of floating point numbers 12885 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; double gcd ( double a , double b ) { if ( a < b ) return gcd ( b , a ) ; if ( fabs ( b ) < 0.001 ) return a ; else return ( gcd ( b , a - floor ( a / b ) * b ) ) ; } int main ( ) { double a = 1.@@ 20 , b = 2@@ 2.5 ; cout << gcd ( a , b ) ; return 0 ; }
Pair with maximum GC@@ D from two arrays 12902 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void g@@ cd@@ Max ( int a [ ] , int b [ ] , int n , int N ) { int cnt [ N ] = { 0 } ; int first [ N ] = { 0 } , second [ N ] = { 0 } ; for ( int i = 0 ; i < n ; ++ i ) cnt [ a [ i ] ] = 1 ; for ( int i = 1 ; i < N ; ++ i ) for ( int j = i ; j < N ; j += i ) if ( cnt [ j ] ) first [ i ] = max ( first [ i ] , j ) ; memset ( cnt , 0 , sizeof ( cnt ) ) ; for ( int i = 0 ; i < n ; ++ i ) cnt [ b [ i ] ] = true ; for ( int i = 1 ; i < N ; ++ i ) for ( int j = i ; j < N ; j += i ) if ( cnt [ j ] ) second [ i ] = max ( second [ i ] , j ) ; int i ; for ( i = N - 1 ; i >= 0 ; i -- ) if ( first [ i ] && second [ i ] ) break ; cout << " Maximum ▁ GC@@ D ▁ pair ▁ with ▁ maximum ▁ " " sum ▁ is ▁ " << first [ i ] << " ▁ " << second [ i ] << endl ; } int main ( ) { int a [ ] = { 3 , 1 , 4 , 2 , 8 } ; int b [ ] = { 5 , 2 , 12 , 8 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int N = 20 ; g@@ cd@@ Max ( a , b , n , N ) ; return 0 ; }
Number of sub@@ arrays whose minimum and maximum are same 12929 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int calculate ( int a [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int r = i + 1 ; for ( int j = r ; j < n ; j ++ ) { if ( a [ i ] == a [ j ] ) r += 1 ; else break ; } int d = r - i ; ans += ( d * ( d + 1 ) / 2 ) ; i = r - 1 ; } return ans ; } int main ( ) { int a [ ] = { 2 , 4 , 5 , 3 , 3 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << calculate ( a , n ) ; return 0 ; }
Count of numbers satis@@ fying m + sum ( m ) + sum ( sum ( m ) ) = N 12930 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int sum ( int n ) { int rem = 0 ; int sum_@@ of_@@ digits = 0 ; while ( n > 0 ) { rem = n % 10 ; sum_@@ of_@@ digits += rem ; n = n / 10 ; } return sum_@@ of_@@ digits ; } int count ( int n ) { int c = 0 ; for ( int i = n - 97 ; i <= n ; i ++ ) { int a = sum ( i ) ; int b = sum ( a ) ; if ( ( i + a + b ) == n ) { c += 1 ; } } return c ; } int main ( ) { int n = 99@@ 39 ; cout << count ( n ) << endl ; return 0 ; }
Prime Number of Set Bits in Binary Representation | Set 2 12977 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ include <@@ c@@ math@@ > NEW_LINE vector < int > Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( int n ) { bool prime [ n + 1 ] ; memset ( prime , false , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == false ) for ( int i = p * 2 ; i < n + 1 ; i += p ) prime [ i ] = true ; } vector < int > lis ; for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] == false ) lis . push_back ( p ) ; return lis ; } int set@@ Bits ( int n ) { return __builtin@@ _pop@@ count ( n ) ; } int main ( ) { int x = 4 , y = 8 ; int count = 0 ; vector < int > prime@@ Arr = Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( ceil ( log2 ( y ) ) ) ; for ( int i = x ; i < y + 1 ; i ++ ) { int temp = set@@ Bits ( i ) ; for ( int j = 0 ; j < prime@@ Arr . size ( ) ; j ++ ) { if ( temp == prime@@ Arr [ j ] ) { count += 1 ; break ; } } } cout << count << endl ; return 0 ; }
Count trailing zeroes present in binary representation of a given number using XOR 10032 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Trailing@@ Zero@@ es ( int N ) { int res = log2 ( N ^ ( N - 1 ) ) ; return res >= 0 ? res : 0 ; } int main ( ) { int N = 12 ; cout << count@@ Trailing@@ Zero@@ es ( N ) ; return 0 ; }
Number formed by adding product of its max and min digit K times 10619 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int prod_@@ of_@@ max_@@ min ( int n ) { int largest = 0 ; int smallest = 10 ; while ( n ) { int r = n % 10 ; largest = max ( r , largest ) ; smallest = min ( r , smallest ) ; n = n / 10 ; } return largest * smallest ; } int formed_@@ no ( int N , int K ) { if ( K == 1 ) { return N ; } int answer = N ; while ( K -- ) { int a_@@ current = prod_@@ of_@@ max_@@ min ( answer ) ; if ( a_@@ current == 0 ) break ; answer += a_@@ current ; } return answer ; } int main ( ) { int N = 48@@ 7 , K = 1@@ 00000000 ; cout << formed_@@ no ( N , K ) << endl ; return 0 ; }
Count of subsets with sum equal to X using Recur@@ sion 10961 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int sub@@ set@@ Sum ( int arr [ ] , int n , int i , int sum , int count ) { if ( i == n ) { if ( sum == 0 ) { count ++ ; } return count ; } count = sub@@ set@@ Sum ( arr , n , i + 1 , sum - arr [ i ] , count ) ; count = sub@@ set@@ Sum ( arr , n , i + 1 , sum , count ) ; return count ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int sum = 10 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << sub@@ set@@ Sum ( arr , n , 0 , sum , 0 ) ; }
Find if the given number is present in the infinite sequence or not 11559 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool does@@ Contain@@ B ( int a , int b , int c ) { if ( a == b ) return true ; if ( ( b - a ) * c > 0 && ( b - a ) % c == 0 ) return true ; return false ; } int main ( ) { int a = 1 , b = 7 , c = 3 ; if ( does@@ Contain@@ B ( a , b , c ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
Medi@@ an 12375 | #@@ include <@@ st@@ dio@@ .@@ h@@ > NEW_LINE int subtr@@ act@@ One ( int x ) { return ( ( x << 1 ) + ( ~ x ) ) ; } int main ( ) { printf ( " % d " , subtr@@ act@@ One ( 13 ) ) ; return 0 ; }
Numbers having difference with digit sum more than s 12558 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int digit@@ Sum ( long long int n ) { int dig@@ Sum = 0 ; while ( n ) { dig@@ Sum += n % 10 ; n /= 10 ; } return dig@@ Sum ; } long long int count@@ Integer ( long long int n , long long int s ) { if ( n < s ) return 0 ; for ( long long int i = s ; i <= min ( n , s + 163 ) ; i ++ ) if ( ( i - digit@@ Sum ( i ) ) > s ) return ( n - i + 1 ) ; return 0 ; } int main ( ) { long long int n = 1000 , s = 100 ; cout << count@@ Integer ( n , s ) ; return 0 ; }
Sum of the sequence 2 , 22 , 222 , ... ... ... 12693 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; float sum@@ Of@@ Series ( int n ) { return 0.02@@ 46 * ( pow ( 10 , n ) - 1 - ( 9 * n ) ) ; } int main ( ) { int n = 3 ; cout << sum@@ Of@@ Series ( n ) ; return 0 ; }
Series with largest GC@@ D and sum equals to n 12941 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print_@@ sequence ( int n , int k ) { int b = n / ( k * ( k + 1 ) / 2 ) ; if ( b == 0 ) { cout << -1 << endl ; } else { int r = 1 ; for ( int x = 1 ; x * x <= n ; x ++ ) { if ( n % x != 0 ) continue ; if ( x <= b && x > r ) r = x ; if ( n / x <= b && n / x > r ) r = n / x ; } for ( int i = 1 ; i < k ; i ++ ) cout << r * i << " ▁ " ; int res = n - ( r * ( k * ( k - 1 ) / 2 ) ) ; cout << res << endl ; } } int main ( ) { int n = 24 ; int k = 4 ; print_@@ sequence ( n , k ) ; n = 24 , k = 5 ; print_@@ sequence ( n , k ) ; n = 6 , k = 4 ; print_@@ sequence ( n , k ) ; }
Program to count digits in an integer ( 4 Different Methods ) 12963 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Digit ( long long n ) { if ( n / 10 == 0 ) return 1 ; return 1 + count@@ Digit ( n / 10 ) ; } int main ( void ) { long long n = 345@@ 289@@ 46@@ 7 ; cout << " Number ▁ of ▁ digits ▁ : " << count@@ Digit ( n ) ; return 0 ; }
Decimal to binary conversion without using arithmetic operators 13008 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; string dec@@ To@@ Bin ( int n ) { if ( n == 0 ) return "0" ; string bin = " " ; while ( n > 0 ) { bin = ( ( n & 1 ) == 0 ? '0' : '1' ) + bin ; n >>= 1 ; } return bin ; } int main ( ) { int n = 38 ; cout << dec@@ To@@ Bin ( n ) ; return 0 ; }
Find if a number is di@@ visible by every number in a list 13112 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool find@@ No@@ Is@@ Di@@ visible@@ Or@@ Not ( int a [ ] , int n , int l ) { for ( int i = 0 ; i < l ; i ++ ) { if ( a [ i ] % n != 0 ) return false ; } return true ; } int main ( ) { int a [ ] = { 14 , 12 , 4 , 18 } ; int n = 2 ; int l = ( sizeof ( a ) / sizeof ( a [ 0 ] ) ) ; if ( find@@ No@@ Is@@ Di@@ visible@@ Or@@ Not ( a , n , l ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
XOR of all sub@@ array X@@ OR@@ s | Set 2 13139 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int getTotal@@ Xor@@ Of@@ Sub@@ array@@ X@@ ors ( int arr [ ] , int N ) { if ( N % 2 == 0 ) return 0 ; int res = 0 ; for ( int i = 0 ; i < N ; i += 2 ) res ^= arr [ i ] ; return res ; } int main ( ) { int arr [ ] = { 3 , 5 , 2 , 4 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << getTotal@@ Xor@@ Of@@ Sub@@ array@@ X@@ ors ( arr , N ) ; return 0 ; }
Find the n 13162 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ N@@ th@@ Even@@ Digit@@ Number ( int n ) { if ( n == 1 ) return 0 ; vector < int > v ; n = n - 1 ; while ( n > 0 ) { v . push_back ( n % 5 ) ; n = n / 5 ; } int result = 0 ; for ( int i = v . size ( ) - 1 ; i >= 0 ; i -- ) { result = result * 10 ; result = result + v [ i ] ; } return 2 * result ; } int main ( ) { cout << find@@ N@@ th@@ Even@@ Digit@@ Number ( 2 ) << endl ; cout << find@@ N@@ th@@ Even@@ Digit@@ Number ( 10 ) << endl ; return 0 ; }
Multiply large integers under large modulo 13186 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; long long modu@@ lo@@ Multiplic@@ ation ( long long a , long long b , long long mod ) { a %= mod ; while ( b ) { if ( b & 1 ) res = ( res + a ) % mod ; a = ( 2 * a ) % mod ; } return res ; } int main ( ) { long long a = 4@@ 26 ; long long b = 9@@ 64 ; long long m = 235 ; cout << modu@@ lo@@ Multiplic@@ ation ( a , b , m ) ; return 0 ; }
Find if n can be written as product of k numbers 13202 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void k@@ Factors ( int n , int k ) { vector < int > P ; while ( n % 2 == 0 ) { P . push_back ( 2 ) ; n /= 2 ; } for ( int i = 3 ; i * i <= n ; i = i + 2 ) { while ( n % i == 0 ) { n = n / i ; P . push_back ( i ) ; } } if ( n > 2 ) P . push_back ( n ) ; if ( P . size ( ) < k ) { cout << " - 1" << endl ; return ; } for ( int i = 0 ; i < k - 1 ; i ++ ) cout << P [ i ] << " , ▁ " ; int product = 1 ; for ( int i = k - 1 ; i < P . size ( ) ; i ++ ) product = product * P [ i ] ; cout << product << endl ; } int main ( ) { int n = 54 , k = 3 ; k@@ Factors ( n , k ) ; return 0 ; }
Count all perfect di@@ visors of a number 13233 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define MAX 10000@@ 1 NEW_LINE int perfec@@ t@@ Div [ MAX ] ; void pre@@ compute@@ Counts ( ) { for ( int i = 1 ; i * i < MAX ; ++ i ) { for ( int j = i * i ; j < MAX ; j += i * i ) ++ perfec@@ t@@ Div [ j ] ; } } int count@@ Per@@ fec@@ t@@ Di@@ visors ( int n ) { return perfec@@ t@@ Div [ n ] ; } int main ( ) { pre@@ compute@@ Counts ( ) ; int n = 16 ; cout << " Total ▁ perfect ▁ di@@ visors ▁ of ▁ " << n << " ▁ = ▁ " << count@@ Per@@ fec@@ t@@ Di@@ visors ( n ) << " STRNEWLINE " ; n = 12 ; cout << " Total ▁ perfect ▁ di@@ visors ▁ of ▁ " << n << " ▁ = ▁ " << count@@ Per@@ fec@@ t@@ Di@@ visors ( n ) ; return 0 ; }
Find minimum number to be divided to make a number a perfect square 13279 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Min@@ Number ( int n ) { int count = 0 , ans = 1 ; while ( n % 2 == 0 ) { count ++ ; n /= 2 ; } if ( count % 2 ) ans *= 2 ; for ( int i = 3 ; i <= sqrt ( n ) ; i += 2 ) { count = 0 ; while ( n % i == 0 ) { count ++ ; n /= i ; } if ( count % 2 ) ans *= i ; } if ( n > 2 ) ans *= n ; return ans ; } int main ( ) { int n = 72 ; cout << find@@ Min@@ Number ( n ) << endl ; return 0 ; }
Mer@@ sen@@ ne Prime 13296 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( int n , bool prime [ ] ) { for ( int i = 0 ; i <= n ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } } void mer@@ sen@@ ne@@ Pri@@ mes ( int n ) { bool prime [ n + 1 ] ; Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( n , prime ) ; for ( int k = 2 ; ( ( 1 << k ) - 1 ) <= n ; k ++ ) { long long num = ( 1 << k ) - 1 ; if ( prime [ num ] ) cout << num << " ▁ " ; } } int main ( ) { int n = 31 ; cout << " Mer@@ sen@@ ne ▁ prime ▁ numbers ▁ smaller ▁ " << " than ▁ or ▁ equal ▁ to ▁ " << n << endl ; mer@@ sen@@ ne@@ Pri@@ mes ( n ) ; return 0 ; }
Find numbers with K odd di@@ visors in a given range 13342 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Perf@@ ect ( int n ) { int s = sqrt ( n ) ; return ( s * s == n ) ; } int di@@ visor@@ sCount ( int n ) { int count = 0 ; for ( int i = 1 ; i <= sqrt ( n ) + 1 ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) count += 1 ; else count += 2 ; } } return count ; } int k@@ Di@@ visors ( int a , int b , int k ) { for ( int i = a ; i <= b ; i ++ ) { if ( is@@ Perf@@ ect ( i ) ) if ( di@@ visors ( i ) == k ) count ++ ; } return count ; } int main ( ) { int a = 2 , b = 49 , k = 3 ; cout << k@@ Di@@ visors ( a , b , k ) ; return 0 ; }
Count number of solutions of x ^ 2 = 1 ( mod p ) in given range 13351 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; typedef long long ll ; int find@@ Count@@ Of@@ Solutions ( int n , int p ) { ll ans = 0 ; for ( ll x = 1 ; x < p ; x ++ ) { if ( ( x * x ) % p == 1 ) { ll last = x + p * ( n / p ) ; if ( last > n ) last -= p ; ans += ( ( last - x ) / p + 1 ) ; } } return ans ; } int main ( ) { ll n = 10 , p = 5 ; printf ( " % lld STRNEWLINE " , find@@ Count@@ Of@@ Solutions ( n , p ) ) ; return 0 ; }
K@@ ap@@ re@@ k@@ ar Constant 13359 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int k@@ ap@@ re@@ kar@@ Rec ( int n , int & prev ) { if ( n == 0 ) return 0 ; prev = n ; int digits [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { digits [ i ] = n % 10 ; n = n / 10 ; } sort ( digits , digits + 4 ) ; int asc = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) asc = asc * 10 + digits [ i ] ; sort ( digits , digits + 4 , std :: greater < int > ( ) ) ; int desc = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) desc = desc * 10 + digits [ i ] ; int diff = abs ( asc - desc ) ; if ( diff == prev ) return diff ; return k@@ ap@@ re@@ kar@@ Rec ( diff , prev ) ; } int k@@ ap@@ re@@ k@@ ar ( int n ) { int prev = 0 ; return k@@ ap@@ re@@ kar@@ Rec ( n , prev ) ; } int main ( ) { cout << k@@ ap@@ re@@ k@@ ar ( 1000 ) << endl ; cout << k@@ ap@@ re@@ k@@ ar ( 11@@ 12 ) << endl ; cout << k@@ ap@@ re@@ k@@ ar ( 98@@ 12 ) << endl ; return 0 ; }
Gray to Binary and Binary to Gray conversion 13440 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; char xor_@@ c ( char a , char b ) { return ( a == b ) ? '0' : '1' ; } char flip ( char c ) { return ( c == '0' ) ? '1' : '0' ; } string binary@@ to@@ Gray ( string binary ) { string gray = " " ; gray += binary [ 0 ] ; for ( int i = 1 ; i < binary . length ( ) ; i ++ ) { gray += xor_@@ c ( binary [ i - 1 ] , binary [ i ] ) ; } return gray ; } string gray@@ to@@ Binary ( string gray ) { string binary = " " ; binary += gray [ 0 ] ; for ( int i = 1 ; i < gray . length ( ) ; i ++ ) { if ( gray [ i ] == '0' ) binary += binary [ i - 1 ] ; else binary += flip ( binary [ i - 1 ] ) ; } return binary ; } int main ( ) { string binary = "@@ 0100@@ 1" ; cout << " Gray ▁ code ▁ of ▁ " << binary << " ▁ is ▁ " << binary@@ to@@ Gray ( binary ) << endl ; string gray = "01@@ 101@@ " ; cout << " Binary ▁ code ▁ of ▁ " << gray << " ▁ is ▁ " << gray@@ to@@ Binary ( gray ) << endl ; return 0 ; }
Count in@@ versions in an array | Set 3 ( Using BIT ) 13464 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int getS@@ um ( int BIT@@ ree [ ] , int index ) { while ( index > 0 ) { sum += BIT@@ ree [ index ] ; index -= index & ( - index ) ; } return sum ; } void update@@ BIT ( int BIT@@ ree [ ] , int n , int index , int val ) { while ( index <= n ) { BIT@@ ree [ index ] += val ; index += index & ( - index ) ; } } void convert ( int arr [ ] , int n ) { int temp [ n ] ; for ( int i = 0 ; i < n ; i ++ ) temp [ i ] = arr [ i ] ; sort ( temp , temp + n ) ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = lower_bound ( temp , temp + n , arr [ i ] ) - temp + 1 ; } } int getIn@@ v@@ Count ( int arr [ ] , int n ) { convert ( arr , n ) ; int BIT [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) BIT [ i ] = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { inv@@ count += getS@@ um ( BIT , arr [ i ] - 1 ) ; update@@ BIT ( BIT , n , arr [ i ] , 1 ) ; } return inv@@ count ; } int main ( ) { int arr [ ] = { 8 , 4 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << " Number ▁ of ▁ in@@ versions ▁ are ▁ : ▁ " << getIn@@ v@@ Count ( arr , n ) ; return 0 ; }
How to compute mod of a big number ? 13506 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int mod ( string num , int a ) { int res = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) res = ( res * 10 + ( int ) num [ i ] - '0' ) % a ; return res ; } int main ( ) { string num = "12@@ 316@@ 767@@ 67@@ 867@@ 8" ; cout << mod ( num , 10 ) ; return 0 ; }
Eu@@ ler '@@ s To@@ ti@@ ent Function 13514 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int phi ( int n ) { float result = n ; for ( int p = 2 ; p * p <= n ; ++ p ) { if ( n % p == 0 ) { while ( n % p == 0 ) n /= p ; result *= ( 1.0 - ( 1.0 / ( float ) p ) ) ; } } if ( n > 1 ) result *= ( 1.0 - ( 1.0 / ( float ) n ) ) ; return ( int ) result ; } int main ( ) { int n ; for ( n = 1 ; n <= 10 ; n ++ ) { cout << " Phi " << " ( " << n << " ) " << " ▁ = ▁ " << phi ( n ) << endl ; } return 0 ; }
Legend@@ re '@@ s formula (@@ Given p and n@@ , find the largest x such that p@@ ^@@ x divi@@ des n@@ !@@ ) 13516 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int lar@@ gest@@ Power ( int n , int p ) { int x = 0 ; while ( n ) { n /= p ; x += n ; } return x ; } int main ( ) { int n = 10 , p = 3 ; cout << " The ▁ largest ▁ power ▁ of ▁ " << p << " ▁ that ▁ divi@@ des ▁ " << n << " ! ▁ is ▁ " << lar@@ gest@@ Power ( n , p ) << endl ; return 0 ; }
Print squares of first n natural numbers without using * , / and 13535 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; void print@@ Squ@@ ares ( int n ) { int square = 0 , odd = 1 ; for ( int x = 0 ; x < n ; x ++ ) { cout << square << " ▁ " ; square = square + odd ; odd = odd + 2 ; } } int main ( ) { int n = 5 ; print@@ Squ@@ ares ( n ) ; }
Program for factorial of a number 13543 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int factorial ( int n ) { return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; } int main ( ) { int num = 5 ; cout << " Fac@@ tori@@ al ▁ of ▁ " << num << " ▁ is ▁ " << factorial ( num ) ; return 0 ; }
Bit@@ wise OR of Bit@@ wise AND of all subsets of an Array for Q queries 13581 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void Or@@ _@@ of_@@ And@@ s_for_@@ each@@ _@@ query ( int arr [ ] , int n , int queries [ ] [ 2 ] , int q ) { int bits [ 32 ] = { 0 } ; for ( int i = 0 ; i < 32 ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( 1 << i ) & arr [ j ] ) { bits [ i ] ++ ; } } } for ( int p = 0 ; p < q ; p ++ ) { for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( 1 << i ) & arr [ queries [ p ] [ 0 ] ] ) { bits [ i ] -- ; } if ( queries [ p ] [ 1 ] & ( 1 << i ) ) { bits [ i ] ++ ; } } arr [ queries [ p ] [ 0 ] ] = queries [ p ] [ 1 ] ; int ans = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { if ( bits [ i ] != 0 ) { ans |= ( 1 << i ) ; } } cout << ans << endl ; } } int main ( ) { int n = 3 , q = 2 ; int arr [ ] = { 3 , 5 , 7 } ; int queries [ 2 ] [ 2 ] = { { 1 , 2 } , { 2 , 1 } } ; Or@@ _@@ of_@@ And@@ s_for_@@ each@@ _@@ query ( arr , n , queries , q ) ; return 0 ; }
Maximum number of consecutive 1 s after fli@@ pping all 0 s in a K length sub@@ array 13616 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ max ( int arr [ ] , int n , int k ) { int tra@@ v , i ; int c = 0 , maximum = 0 ; for ( i = 0 ; i < n - k + 1 ; i ++ ) { tra@@ v = i - 1 ; c = 0 ; while ( tra@@ v >= 0 && arr [ tra@@ v ] == 1 ) { tra@@ v -- ; c ++ ; } tra@@ v = i + k ; while ( tra@@ v < n && arr [ tra@@ v ] == 1 ) { tra@@ v ++ ; c ++ ; } c += k ; if ( c > maximum ) maximum = c ; } return maximum ; } int main ( ) { int k = 3 ; int arr [ ] = { 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 } ; int n = sizeof arr / sizeof arr [ 0 ] ; int ans = find@@ max ( arr , n , k ) ; cout << ans << ' ' ; }
Minimum XOR of OR and AND of any pair in the Array 13621 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max@@ And@@ Xor ( int arr [ ] , int n ) { int ans = INT_MAX ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { ans = min ( ans , arr [ i ] ^ arr [ i + 1 ] ) ; } return ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << max@@ And@@ Xor ( arr , N ) ; return 0 ; }
Count of sub@@ arrays of size K with elements having even frequencies 13623 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Sub@@ array ( int arr [ ] , int K , int N ) { if ( K % 2 != 0 ) return 0 ; if ( N < K ) return 0 ; int start = 0 ; int i = 0 ; int count = 0 ; int curr@@ Xor = arr [ i ++ ] ; while ( i < K ) { curr@@ Xor ^= arr [ i ] ; i ++ ; } if ( curr@@ Xor == 0 ) count ++ ; curr@@ Xor ^= arr [ start ++ ] ; while ( i < N ) { curr@@ Xor ^= arr [ i ] ; i ++ ; if ( curr@@ Xor == 0 ) count ++ ; curr@@ Xor ^= arr [ start ++ ] ; } return count ; } int main ( ) { int arr [ ] = { 2 , 4 , 4 , 2 , 2 , 4 } ; int K = 4 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ( count@@ Sub@@ array ( arr , K , N ) ) ; }
Minim@@ ize bits to be flipped in X and Y such that their Bit@@ wise OR is equal to Z 13634 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int minimum@@ Fli@@ ps ( int X , int Y , int Z ) { int res = 0 ; while ( X > 0 Y > 0 Z > 0 ) { if ( ( ( X & 1 ) || ( Y & 1 ) ) && ( Z & 1 ) ) { X = X >> 1 ; Y = Y >> 1 ; Z = Z >> 1 ; continue ; } else if ( ! ( X & 1 ) && ! ( Y & 1 ) && ( Z & 1 ) ) { res ++ ; } else if ( ( X & 1 ) || ( Y & 1 ) == 1 ) { if ( ( X & 1 ) && ( Y & 1 ) && ! ( Z & 1 ) ) { res += 2 ; } else if ( ( ( X & 1 ) || ( Y & 1 ) ) && ! ( Z & 1 ) ) { res ++ ; } } X = X >> 1 ; Y = Y >> 1 ; Z = Z >> 1 ; } return res ; } int main ( ) { int X = 5 , Y = 8 , Z = 6 ; cout << minimum@@ Fli@@ ps ( X , Y , Z ) ; return 0 ; }
Turn off the right@@ most set bit | Set 2 13635 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void Flip@@ Bits ( int n ) { for ( int bit = 0 ; bit < 32 ; bit ++ ) { if ( ( n >> bit ) & 1 ) { n = n ^ ( 1@@ ll << bit ) ; break ; } } cout << " The ▁ number ▁ after ▁ un@@ setting ▁ the " ; cout << " ▁ right@@ most ▁ set ▁ bit ▁ " << n ; } int main ( ) { int N = 12 ; Flip@@ Bits ( N ) ; return 0 ; }
Bit@@ wise AND of all the odd numbers from 1 to N 13651 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int bit@@ wise@@ And@@ Odd ( int n ) { int result = 1 ; for ( int i = 3 ; i <= n ; i = i + 2 ) { result = ( result & i ) ; } return result ; } int main ( ) { int n = 10 ; cout << bit@@ wise@@ And@@ Odd ( n ) ; return 0 ; }
Multiply a number by 15 without using * and / operators 13693 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; long multiply@@ By@@ Fi@@ f@@ te@@ en ( long n ) { long prod = ( n << 3 ) ; prod += ( n << 2 ) ; prod += ( n << 1 ) ; prod += n ; return prod ; } int main ( ) { long n = 7 ; cout << multiply@@ By@@ Fi@@ f@@ te@@ en ( n ) ; return 0 ; }
Count of values of x <= n for which ( n XOR x ) = ( n 13705 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ X ( int n ) { string binary = bitset < 8 > ( n ) . to_string ( ) ; int count = 0 ; for ( int i = 0 ; i < binary . length ( ) ; i ++ ) { if ( binary . at ( i ) == '1' ) count ++ ; } int answer = ( int ) pow ( 2 , count ) ; return answer ; } int main ( ) { int n = 5 ; int answer = count@@ X ( n ) ; cout << ( answer ) ; }
Assign other value to a variable from two possible values 13733 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void alternate ( int & a , int & b , int & x ) { x = a ^ b ^ x ; } int main ( ) { int a = -@@ 10 ; int b = 15 ; int x = a ; cout << " x ▁ is ▁ : ▁ " << x ; alternate ( a , b , x ) ; cout << " After exchange " cout << " STRNEWLINE x ▁ is ▁ : ▁ " << x ; return 0 ; }
Number of mis@@ matching bits in the binary representation of two integers 13743 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void solve ( int A , int B ) { int count = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( ( A >> i ) & 1 ) != ( ( B >> i ) & 1 ) ) { count ++ ; } } cout << " Number ▁ of ▁ different ▁ bits ▁ : ▁ " << count << endl ; } int main ( ) { int A = 12 , B = 15 ; solve ( A , B ) ; return 0 ; }
Print the number of set bits in each node of a Binary Tree 13754 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; Node * newNode ( int data ) { Node * node = new Node ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } void print@@ Set@@ Bit ( Node * root ) { if ( root == NULL ) return ; cout << " Set ▁ bits ▁ in ▁ Node ▁ " << root -> data << " ▁ = ▁ " << __builtin@@ _pop@@ count ( root -> data ) << " STRNEWLINE " ; print@@ Set@@ Bit ( root -> left ) ; print@@ Set@@ Bit ( root -> right ) ; } int main ( ) { Node * root = newNode ( 16 ) ; root -> left = newNode ( 13 ) ; root -> left -> left = newNode ( 14 ) ; root -> left -> right = newNode ( 12 ) ; root -> right = newNode ( 11 ) ; root -> right -> left = newNode ( 10 ) ; root -> right -> right = newNode ( 16 ) ; print@@ Set@@ Bit ( root ) ; return 0 ; }
First element greater than or equal to X in prefix sum of N numbers using Binary Li@@ ft@@ ing 13769 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void Make@@ Pre@@ Sum ( int arr [ ] , int pres@@ um [ ] , int n ) { pres@@ um [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) pres@@ um [ i ] = pres@@ um [ i - 1 ] + arr [ i ] ; } int Binary@@ Li@@ ft@@ ing ( int pres@@ um [ ] , int n , int x ) { int pos = 0 ; int LOG@@ N = log2 ( n ) ; if ( x <= pres@@ um [ 0 ] ) return 0 ; for ( int i = LOG@@ N ; i >= 0 ; i -- ) { if ( pos + ( 1 << i ) < n && pres@@ um [ pos + ( 1 << i ) ] < x ) { pos += ( 1 << i ) ; } } return pos + 1 ; } int main ( ) { int arr [ ] = { 2 , 5 , 7 , 1 , 6 , 9 , 12 , 4 , 6 } ; int x = 8 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int pres@@ um [ n ] = { 0 } ; Make@@ Pre@@ Sum ( arr , pres@@ um , n ) ; cout << Binary@@ Li@@ ft@@ ing ( pres@@ um , n , x ) ; return 0 ; }
Check whether all the bits are unset in the given range 13778 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool all@@ Bits@@ SetIn@@ The@@ Given@@ Range ( unsigned int n , unsigned int l , unsigned int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; int new_@@ num = n & num ; if ( new_@@ num == 0 ) return true ; return false ; } int main ( ) { unsigned int n = 17 ; unsigned int l = 2 , r = 4 ; if ( all@@ Bits@@ SetIn@@ The@@ Given@@ Range ( n , l , r ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
Check whether the number has only first and last bits set | Set 2 13788 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool only@@ First@@ And@@ Last@@ Are@@ Set ( unsigned int n ) { if ( n == 1 ) return true ; if ( n == 2 ) return false ; return ( ( ( n - 1 ) & ( n - 2 ) ) == 0 ) ; } int main ( ) { unsigned int n = 9 ; if ( only@@ First@@ And@@ Last@@ Are@@ Set ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
Minimum number using set bits of a given number 13810 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE #@@ define ll unsigned int NEW_LINE using namespace std ; ll minimize ( ll a ) { ll n = _pop@@ cnt@@ 32 ( a ) ; return ( pow ( 2 , n ) - 1 ) ; } int main ( ) { ll a = 11 ; cout << minimize ( a ) << endl ; return 0 ; }
Level@@ wise Altern@@ ating OR and XOR operations in Segment Tree 13825 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int getM@@ id ( int s , int e ) { return s + ( e - s ) / 2 ; } void construct@@ ST@@ Util ( int arr [ ] , int ss , int se , int * st , int si , int operation ) { if ( ss == se ) { st [ si ] = arr [ ss ] ; return ; } int mid = getM@@ id ( ss , se ) ; construct@@ ST@@ Util ( arr , ss , mid , st , si * 2 + 1 , ! operation ) ; construct@@ ST@@ Util ( arr , mid + 1 , se , st , si * 2 + 2 , ! operation ) ; if ( operation == 1 ) { st [ si ] = ( st [ 2 * si + 1 ] st [ 2 * si + 2 ] ) ; } else { st [ si ] = ( st [ 2 * si + 1 ] ^ st [ 2 * si + 2 ] ) ; } } int * construct@@ ST ( int arr [ ] , int n ) { int x = ( int ) ( ceil ( log2 ( n ) ) ) ; int max_size = 2 * ( int ) pow ( 2 , x ) - 1 ; int * st = new int [ max_size ] ; int operation@@ At@@ Root = ( x % 2 == 0 ? 0 : 1 ) ; construct@@ ST@@ Util ( arr , 0 , n - 1 , st , 0 , operation@@ At@@ Root ) ; return st ; } int main ( ) { int leaves [ ] = { 1 , 6 , 3 , 7 , 5 , 9 , 10 , 4 } ; int n = sizeof ( leaves ) / sizeof ( leaves [ 0 ] ) ; int * segment@@ Tree = construct@@ ST ( leaves , n ) ; int root@@ Index = 0 ; cout << " Value ▁ at ▁ Root ▁ Node ▁ = ▁ " << segment@@ Tree [ root@@ Index ] ; }
Fi@@ b@@ binary Numbers ( No consecutive 1 s in binary ) 13832 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Fi@@ b@@ binary@@ Num ( unsigned int n ) { if ( ( n & ( n >> 1 ) ) == 0 ) return true ; return false ; } int main ( ) { unsigned int n = 10 ; if ( is@@ Fi@@ b@@ binary@@ Num ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
Divide two integers without using multiplication , division and mod operator 13835 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int divide ( long long dividend , long long divisor ) { int sign = ( ( dividend < 0 ) ^ ( divisor < 0 ) ) ? -1 : 1 ; dividend = abs ( dividend ) ; divisor = abs ( divisor ) ; long long quotient = 0 , temp = 0 ; for ( int i = 31 ; i >= 0 ; -- i ) { if ( temp + ( divisor << i ) <= dividend ) { temp += divisor << i ; quotient |= 1@@ LL << i ; } } if ( sign == -1 ) quotient = - quotient ; return quotient ; } int main ( ) { int a = 10 , b = 3 ; cout << divide ( a , b ) << " STRNEWLINE " ; a = 43 , b = -@@ 8 ; cout << divide ( a , b ) ; return 0 ; }
Maximum AND value of a pair in an array 13877 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max@@ AND ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) res = max ( res , arr [ i ] & arr [ j ] ) ; return res ; } int main ( ) { int arr [ ] = { 4 , 8 , 6 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Maximum ▁ AND ▁ Value ▁ = ▁ " << max@@ AND ( arr , n ) ; return 0 ; }
Toggle all bits after most significant bit 13902 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int set@@ All@@ Bits@@ After@@ MSB ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return n ; } void toggle ( int & n ) { n = n ^ set@@ All@@ Bits@@ After@@ MSB ( n ) ; } int main ( ) { int n = 10 ; toggle ( n ) ; cout << n ; return 0 ; }
Toggle all bits after most significant bit 13913 | #@@ include <@@ io@@ stream@@ > NEW_LINE #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int construct@@ N@@ th@@ Number ( int group_@@ no , int aux_@@ num , int op ) { int INT_@@ SIZE = 32 ; int a [ INT_@@ SIZE ] = { 0 } ; int num = 0 , len_@@ f ; int i = 0 ; if ( op == 2 ) { len_@@ f = 2 * group_@@ no ; a [ len_@@ f - 1 ] = a [ 0 ] = 1 ; while ( aux_@@ num ) { a [ group_@@ no + i ] = a [ group_@@ no - 1 - i ] = aux_@@ num & 1 ; aux_@@ num = aux_@@ num >> 1 ; i ++ ; } } else if ( op == 0 ) { len_@@ f = 2 * group_@@ no + 1 ; a [ len_@@ f - 1 ] = a [ 0 ] = 1 ; a [ group_@@ no ] = 0 ; while ( aux_@@ num ) { a [ group_@@ no + 1 + i ] = a [ group_@@ no - 1 - i ] = aux_@@ num & 1 ; aux_@@ num = aux_@@ num >> 1 ; i ++ ; } } else { len_@@ f = 2 * group_@@ no + 1 ; a [ len_@@ f - 1 ] = a [ 0 ] = 1 ; a [ group_@@ no ] = 1 ; while ( aux_@@ num ) { a [ group_@@ no + 1 + i ] = a [ group_@@ no - 1 - i ] = aux_@@ num & 1 ; aux_@@ num = aux_@@ num >> 1 ; i ++ ; } } for ( i = 0 ; i < len_@@ f ; i ++ ) num += ( 1 << i ) * a [ i ] ; return num ; } int getN@@ th@@ Number ( int n ) { int group_@@ no = 0 , group_@@ offset ; int count_@@ up@@ to_@@ group = 0 , count_@@ temp = 1 ; int op , aux_@@ num ; while ( count_@@ temp < n ) { group_@@ no ++ ; count_@@ up@@ to_@@ group = count_@@ temp ; count_@@ temp += 3 * ( 1 << ( group_@@ no - 1 ) ) ; } group_@@ offset = n - count_@@ up@@ to_@@ group - 1 ; if ( ( group_@@ offset + 1 ) <= ( 1 << ( group_@@ no - 1 ) ) ) { op = 2 ; aux_@@ num = group_@@ offset ; } else { if ( ( ( group_@@ offset + 1 ) - ( 1 << ( group_@@ no - 1 ) ) ) % 2 ) op = 0 ; else op = 1 ; aux_@@ num = ( ( group_@@ offset ) - ( 1 << ( group_@@ no - 1 ) ) ) / 2 ; } return construct@@ N@@ th@@ Number ( group_@@ no , aux_@@ num , op ) ; } int main ( ) { int n = 9 ; cout << getN@@ th@@ Number ( n ) ; return 0 ; }
Toggle the last m bits 13931 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; unsigned int toggle@@ Last@@ MB@@ its ( unsigned int n , unsigned int m ) { unsigned int num = ( 1 << m ) - 1 ; return ( n ^ num ) ; } int main ( ) { unsigned int n = 107 ; unsigned int m = 4 ; cout << toggle@@ Last@@ MB@@ its ( n , m ) ; return 0 ; }
Count all pairs with given XOR 13979 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int xor@@ Pair@@ Count ( int arr [ ] , int n , int x ) { unordered_map < int , int > m ; for ( int i = 0 ; i < n ; i ++ ) { int curr_@@ xor = x ^ arr [ i ] ; if ( m . find ( curr_@@ xor ) != m . end ( ) ) result += m [ curr_@@ xor ] ; m [ arr [ i ] ] ++ ; } return result ; } int main ( ) { int arr [ ] = { 2 , 5 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 0 ; cout << " Count ▁ of ▁ pairs ▁ with ▁ given ▁ XOR ▁ = ▁ " << xor@@ Pair@@ Count ( arr , n , x ) ; return 0 ; }
Maximum length sub 14040 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int maxLength ( int arr [ ] , int n ) { int maxLen = 0 ; int i = 0 ; int j = i + 1 ; while ( j < n ) { if ( arr [ i ] != arr [ j ] ) { maxLen = max ( maxLen , 2 ) ; int l = i - 1 ; int r = j + 1 ; while ( l >= 0 && r < n && arr [ l ] == arr [ i ] && arr [ r ] == arr [ j ] ) { l -- ; r ++ ; } maxLen = max ( maxLen , 2 * ( r - j ) ) ; } i ++ ; j = i + 1 ; } return maxLen ; } int main ( ) { int arr [ ] = { 1 , 1 , 1 , 0 , 0 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxLength ( arr , n ) ; return 0 ; }
Minimum value of X that can be added to N to minimize sum of the digits to Ã ¢ â €@@ °@@ ¤ K 3392 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int min@@ Digits ( int N , int K ) { int digits_@@ num = floor ( log10 ( N ) + 1 ) ; int temp_@@ sum = 0 ; int temp = digits_@@ num ; int result ; int X , var ; int sum = 0 ; int num2 = N ; while ( num2 != 0 ) { sum += num2 % 10 ; num2 /= 10 ; } if ( sum <= K ) { X = 0 ; } else { while ( temp > 0 ) { var = ( N / ( pow ( 10 , temp - 1 ) ) ) ; temp_@@ sum += var % 10 ; if ( temp_@@ sum >= K ) { var /= 10 ; var ++ ; result = var * pow ( 10 , temp ) ; break ; } temp -- ; } X = result - N ; return X ; } } int main ( ) { int N = 11 , K = 1 ; cout << min@@ Digits ( N , K ) ; return 0 ; }
Print all array elements appearing more than N / K times 4243 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int upperBound ( int arr [ ] , int N , int K ) { int l = 0 ; int r = N ; while ( l < r ) { int mid = ( l + r ) / 2 ; if ( arr [ mid ] <= K ) { l = mid + 1 ; } else { r = mid ; } } return l ; } void N@@ Div@@ K@@ With@@ Freq ( int arr [ ] , int N , int K ) { sort ( arr , arr + N ) ; int i = 0 ; while ( i < N ) { int X = upperBound ( arr , N , arr [ i ] ) ; if ( ( X - i ) > N / 4 ) { cout << arr [ i ] << " ▁ " ; } i = X ; } } int main ( ) { int arr [ ] = { 1 , 2 , 2 , 6 , 6 , 6 , 6 , 7 , 10 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 4 ; N@@ Div@@ K@@ With@@ Freq ( arr , N , K ) ; return 0 ; }
Maxim@@ ize the median of the given array after adding K elements to the same array 4585 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; float getMax@@ Medi@@ an ( int arr [ ] , int n , int k ) { int size = n + k ; sort ( arr , arr + n ) ; if ( size % 2 == 0 ) { float median = ( float ) ( arr [ ( size / 2 ) - 1 ] + arr [ size / 2 ] ) / 2 ; return median ; } float median = arr [ size / 2 ] ; return median ; } int main ( ) { int arr [ ] = { 3 , 2 , 3 , 4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ; cout << getMax@@ Medi@@ an ( arr , n , k ) ; return 0 ; }
Check if both hal@@ ves of the string have at least one different character 4718 | #@@ include <@@ c@@ string@@ > NEW_LINE #@@ include <@@ io@@ stream@@ > NEW_LINE #@@ include <@@ string@@ > NEW_LINE using namespace std ; # define MAX 26 NEW_LINE bool function ( string str ) { int l = str . length ( ) ; int counter [ MAX ] ; memset ( counter , 0 , sizeof ( counter ) ) ; for ( int i = 0 ; i < l / 2 ; i ++ ) counter [ str [ i ] - ' a ' ] ++ ; for ( int i = l / 2 ; i < l ; i ++ ) counter [ str [ i ] - ' a ' ] -- ; for ( int i = 0 ; i < MAX ; i ++ ) if ( counter [ i ] != 0 ) return true ; return false ; } int main ( ) { string str = " abc@@ as@@ ds@@ ab@@ ca@@ e " ; if ( function ( str ) ) cout << " Yes , ▁ both ▁ hal@@ ves ▁ differ " << " ▁ by ▁ at ▁ least ▁ one ▁ character " ; else cout << " No , ▁ both ▁ hal@@ ves ▁ do " << " ▁ not ▁ differ ▁ at ▁ all " ; return 0 ; }
Sort 3 Inte@@ gers without using if condition or using only max ( ) function 4783 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void print@@ Sorted ( int a , int b , int c ) { int get_@@ max = max ( a , max ( b , c ) ) ; int get_@@ min = - max ( - a , max ( - b , - c ) ) ; int get_@@ mid = ( a + b + c ) - ( get_@@ max + get_@@ min ) ; cout << get_@@ min << " ▁ " << get_@@ mid << " ▁ " << get_@@ max ; } int main ( ) { int a = 4 , b = 1 , c = 9 ; print@@ Sorted ( a , b , c ) ; return 0 ; }
Insertion Sort 4855 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void insertion@@ Sort ( int arr [ ] , int n ) { int i , key , j ; for ( i = 1 ; i < n ; i ++ ) { key = arr [ i ] ; j = i - 1 ; while ( j >= 0 && arr [ j ] > key ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } arr [ j + 1 ] = key ; } } void print@@ Array ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << endl ; } int main ( ) { int arr [ ] = { 12 , 11 , 13 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; insertion@@ Sort ( arr , n ) ; print@@ Array ( arr , n ) ; return 0 ; }
Maxim@@ ize count of 3 5101 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int maxNum@@ Pal@@ ind@@ ro@@ me ( string S ) { int i = 0 ; int freq [ 26 ] = { 0 } ; int freq@@ Pair = 0 ; int len = S . length ( ) / 3 ; while ( i < S . length ( ) ) { freq [ S [ i ] - ' a ' ] ++ ; i ++ ; } for ( i = 0 ; i < 26 ; i ++ ) { freq@@ Pair += ( freq [ i ] / 2 ) ; } return min ( freq@@ Pair , len ) ; } int main ( ) { string S = " ge@@ ek@@ s@@ for@@ g " ; cout << maxNum@@ Pal@@ ind@@ ro@@ me ( S ) << endl ; return 0 ; }
Minimum Bi@@ parti@@ te Groups 5547 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int height ( int s , vector < int > adj [ ] , int * visited ) { visited [ s ] = 1 ; int h = 0 ; for ( auto & child : adj [ s ] ) { if ( visited [ child ] == 0 ) { h = max ( h , 1 + height ( child , adj , visited ) ) ; } } return h ; } int minimum@@ Groups ( vector < int > adj [ ] , int N ) { int visited [ N + 1 ] = { 0 } ; int groups = INT_@@ MIN ; for ( int i = 1 ; i <= N ; i ++ ) { if ( visited [ i ] == 0 ) { int com@@ Height ; com@@ Height = height ( i , adj , visited ) ; groups = max ( groups , com@@ Height ) ; } } return groups ; } void addEdge ( vector < int > adj [ ] , int u , int v ) { adj [ u ] . push_back ( v ) ; adj [ v ] . push_back ( u ) ; } int main ( ) { int N = 5 ; vector < int > adj [ N + 1 ] ; addEdge ( adj , 1 , 2 ) ; addEdge ( adj , 3 , 2 ) ; addEdge ( adj , 4 , 3 ) ; cout << minimum@@ Groups ( adj , N ) ; }
Sum of first N natural numbers which are not powers of K 5705 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find_@@ sum ( int n , int k ) { int total_@@ sum = ( n * ( n + 1 ) ) / 2 ; int power = k ; while ( power <= n ) { total_@@ sum -= power ; power *= k ; } return total_@@ sum ; } int main ( ) { int n = 11 , k = 2 ; cout << find_@@ sum ( n , k ) ; return 0 ; }
Coin Change | DP 7075 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define R 3 NEW_LINE #@@ define C 3 NEW_LINE int min ( int x , int y , int z ) ; int min@@ Cost ( int cost [ R ] [ C ] , int m , int n ) { if ( n < 0 m < 0 ) return INT_MAX ; else if ( m == 0 && n == 0 ) return cost [ m ] [ n ] ; else return cost [ m ] [ n ] + min ( min@@ Cost ( cost , m - 1 , n - 1 ) , min@@ Cost ( cost , m - 1 , n ) , min@@ Cost ( cost , m , n - 1 ) ) ; } int min ( int x , int y , int z ) { if ( x < y ) return ( x < z ) ? x : z ; else return ( y < z ) ? y : z ; } int main ( ) { int cost [ R ] [ C ] = { { 1 , 2 , 3 } , { 4 , 8 , 2 } , { 1 , 5 , 3 } } ; cout << min@@ Cost ( cost , 2 , 2 ) << endl ; return 0 ; }
Count of lex@@ ico@@ graphic@@ ally smaller characters on right 7767 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void count@@ S@@ mal@@ ler ( string str ) { int n = str . length ( ) ; int arr [ 26 ] = { 0 } ; int ans [ n ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { arr [ str [ i ] - ' a ' ] ++ ; int ct = 0 ; for ( int j = 0 ; j < str [ i ] - ' a ' ; j ++ ) { ct += arr [ j ] ; } ans [ i ] = ct ; } for ( int i = 0 ; i < n ; i ++ ) { cout << ans [ i ] << " ▁ " ; } } int main ( ) { string str = " ed@@ c@@ ba@@ a " ; count@@ S@@ mal@@ ler ( str ) ; return 0 ; }
String containing first letter of every word in a given string with spaces 8539 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; string process@@ Words ( char * input ) { char * p ; vector < string > s ; p = strtok ( input , " ▁ " ) ; while ( p != NULL ) { s . push_back ( p ) ; p = strtok ( NULL , " ▁ " ) ; } string char@@ Buffer ; for ( string values : s ) char@@ Buffer += values [ 0 ] ; return char@@ Buffer ; } int main ( ) { char input [ ] = " ge@@ e@@ ks ▁ for ▁ ge@@ e@@ ks " ; cout << process@@ Words ( input ) ; return 0 ; }
Generate n 8761 | #@@ include <@@ io@@ stream@@ > NEW_LINE #@@ include <@@ string@@ > NEW_LINE #@@ include <@@ vector@@ > NEW_LINE using namespace std ; void generate@@ Gray@@ arr ( int n ) { if ( n <= 0 ) return ; vector < string > arr ; arr . push_back ( "0" ) ; arr . push_back ( "1" ) ; int i , j ; for ( i = 2 ; i < ( 1 << n ) ; i = i << 1 ) { for ( j = i - 1 ; j >= 0 ; j -- ) arr . push_back ( arr [ j ] ) ; for ( j = 0 ; j < i ; j ++ ) arr [ j ] = "0" + arr [ j ] ; for ( j = i ; j < 2 * i ; j ++ ) arr [ j ] = "1" + arr [ j ] ; } for ( i = 0 ; i < arr . size ( ) ; i ++ ) cout << arr [ i ] << endl ; } int main ( ) { generate@@ Gray@@ arr ( 3 ) ; return 0 ; }
Rat in a Ma@@ ze Problem when movement in all possible directions is allowed 8853 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE #@@ define MAX 5 NEW_LINE using namespace std ; bool is@@ Safe ( int row , int col , int m [ ] [ MAX ] , int n , bool visited [ ] [ MAX ] ) { if ( row == -1 row == n col == -1 col == n visited [ row ] [ col ] m [ row ] [ col ] == 0 ) return false ; return true ; } void print@@ Path@@ Util ( int row , int col , int m [ ] [ MAX ] , int n , string & path , vector < string > & possible@@ Paths , bool visited [ ] [ MAX ] ) { if ( row == -1 row == n col == -1 col == n visited [ row ] [ col ] m [ row ] [ col ] == 0 ) return ; if ( row == n - 1 && col == n - 1 ) { possible@@ Paths . push_back ( path ) ; return ; } visited [ row ] [ col ] = true ; if ( is@@ Safe ( row + 1 , col , m , n , visited ) ) { path . push_back ( ' D ' ) ; print@@ Path@@ Util ( row + 1 , col , m , n , path , possible@@ Paths , visited ) ; path . pop_back ( ) ; } if ( is@@ Safe ( row , col - 1 , m , n , visited ) ) { path . push_back ( ' L ' ) ; print@@ Path@@ Util ( row , col - 1 , m , n , path , possible@@ Paths , visited ) ; path . pop_back ( ) ; } if ( is@@ Safe ( row , col + 1 , m , n , visited ) ) { path . push_back ( ' R ' ) ; print@@ Path@@ Util ( row , col + 1 , m , n , path , possible@@ Paths , visited ) ; path . pop_back ( ) ; } if ( is@@ Safe ( row - 1 , col , m , n , visited ) ) { path . push_back ( ' U ' ) ; print@@ Path@@ Util ( row - 1 , col , m , n , path , possible@@ Paths , visited ) ; path . pop_back ( ) ; } visited [ row ] [ col ] = false ; } void print@@ Path ( int m [ MAX ] [ MAX ] , int n ) { vector < string > possible@@ Paths ; string path ; bool visited [ n ] [ MAX ] ; memset ( visited , false , sizeof ( visited ) ) ; print@@ Path@@ Util ( 0 , 0 , m , n , path , possible@@ Paths , visited ) ; for ( int i = 0 ; i < possible@@ Paths . size ( ) ; i ++ ) cout << possible@@ Paths [ i ] << " ▁ " ; } int main ( ) { int m [ MAX ] [ MAX ] = { { 1 , 0 , 0 , 0 , 0 } , { 1 , 1 , 1 , 1 , 1 } , { 1 , 1 , 1 , 0 , 1 } , { 0 , 0 , 0 , 0 , 1 } , { 0 , 0 , 0 , 0 , 1 } } ; int n = sizeof ( m ) / sizeof ( m [ 0 ] ) ; print@@ Path ( m , n ) ; return 0 ; }
Count of Unique Direct Path Between N Points On a Plane 8981 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Direct@@ Path ( int N ) { return N + ( N * ( N - 3 ) ) / 2 ; } int main ( ) { int N = 5 ; cout << count@@ Direct@@ Path ( N ) ; return 0 ; }
Check if a point is inside , outside or on the ellipse 9323 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int checkpoint ( int h , int k , int x , int y , int a , int b ) { int p = ( pow ( ( x - h ) , 2 ) / pow ( a , 2 ) ) + ( pow ( ( y - k ) , 2 ) / pow ( b , 2 ) ) ; return p ; } int main ( ) { int h = 0 , k = 0 , x = 2 , y = 1 , a = 4 , b = 5 ; if ( checkpoint ( h , k , x , y , a , b ) > 1 ) cout << " Outside " << endl ; else if ( checkpoint ( h , k , x , y , a , b ) == 1 ) cout << " On ▁ the ▁ ellipse " << endl ; else cout << " Inside " << endl ; return 0 ; }
Find the center of the circle using endpoints of diameter 9428 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; void center ( int x1 , int x2 , int y1 , int y2 ) { cout << ( float ) ( x1 + x2 ) / 2 << " , ▁ " << ( float ) ( y1 + y2 ) / 2 ; } int main ( ) { int x1 = -@@ 9 , y1 = 3 , x2 = 5 , y2 = -@@ 7 ; center ( x1 , x2 , y1 , y2 ) ; return 0 ; }
Program to find area of a Tr@@ ape@@ z@@ oid 9457 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; double Area ( int b1 , int b2 , int h ) { return ( ( b1 + b2 ) / 2 ) * h ; } int main ( ) { int base@@ 1 = 8 , base@@ 2 = 10 , height = 6 ; double area = Area ( base@@ 1 , base@@ 2 , height ) ; cout << " Area ▁ is : ▁ " << area ; return 0 ; }
Program for Volume and Surface Area of Cube 9471 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; double area@@ Cube ( double a ) { return ( a * a * a ) ; } double surface@@ Cube ( double a ) { return ( 6 * a * a ) ; } int main ( ) { double a = 5 ; cout << " Area ▁ = ▁ " << area@@ Cube ( a ) << endl ; cout << " Total ▁ surface ▁ area ▁ = ▁ " << surface@@ Cube ( a ) ; return 0 ; }
Find mirror image of a point in 2 9488 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; pair < double , double > mirror@@ Image ( double a , double b , double c , double x1 , double y1 ) { double temp = -2 * ( a * x1 + b * y1 + c ) / ( a * a + b * b ) ; double x = temp * a + x1 ; double y = temp * b + y1 ; return make_pair ( x , y ) ; } int main ( ) { double a = -@@ 1.0 ; double b = 1.0 ; double c = 0.0 ; double x1 = 1.0 ; double y1 = 0.0 ; pair < double , double > image = mirror@@ Image ( a , b , c , x1 , y1 ) ; cout << " Image ▁ of ▁ point ▁ ( " << x1 << " , ▁ " << y1 << " ) ▁ " ; cout << " by ▁ mirror ▁ ( " << a << " ) x ▁ + ▁ ( " << b << " ) y ▁ + ▁ ( " << c << " ) ▁ = ▁ 0 , ▁ is ▁ : " ; cout << " ( " << image . first << " , ▁ " << image . second << " ) " << endl ; return 0 ; }
Program to find the value of P ( N + r ) for a polynomial of a degree N such that P ( i ) = 1 for 1 Ã ¢ â €@@ °@@ ¤ i Ã ¢ â €@@ °@@ ¤ N and P ( N + 1 ) = a 9872 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int fact ( int n ) { if ( n == 1 n == 0 ) return 1 ; else return n * fact ( n - 1 ) ; } int find@@ Value ( int n , int r , int a ) { int k = ( a - 1 ) / fact ( n ) ; int answer = k ; for ( int i = 1 ; i < n + 1 ; i ++ ) answer = answer * ( n + r - i ) ; answer = answer + 1 ; return answer ; } int main ( ) { int N = 1 ; int A = 2 ; int R = 3 ; cout << ( find@@ Value ( N , R , A ) ) ; return 0 ; }
Find N@@ th number in a sequence which is not a multiple of a given number 2721 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void count@@ No ( int A , int N , int L , int R ) { int ans = L - 1 + N + floor ( ( N - 1 ) / ( A - 1 ) ) ; if ( ans % A == 0 ) { ans = ans + 1 ; } cout << ans << endl ; } int main ( ) { int A = 5 , N = 10 , L = 4 , R = 20 ; count@@ No ( A , N , L , R ) ; return 0 ; }
Find the sum of prime numbers in the K@@ th array 2812 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define MAX 1000000 NEW_LINE bool prime [ MAX ] ; void Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( ) { for ( int i = 0 ; i < MAX ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * p ; i < MAX ; i += p ) prime [ i ] = false ; } } } int sum@@ Prime ( int k ) { Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( ) ; vector < int > v ; for ( int i = 2 ; i < MAX ; i ++ ) { if ( prime [ i ] ) v . push_back ( i ) ; } int sum = 0 ; int skip = ( k * ( k - 1 ) ) / 2 ; while ( k > 0 ) { sum += v [ skip ] ; skip ++ ; k -- ; } return sum ; } int main ( ) { int k = 3 ; cout << sum@@ Prime ( k ) ; return 0 ; }
Count all sub@@ strings having character K 2814 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int next@@ Occurren@@ ce ( string str , int n , int start , char ch ) { for ( int i = start ; i < n ; i ++ ) { if ( str [ i ] == ch ) return i ; } return -1 ; } int count@@ Sub@@ Str ( string str , int n , char ch ) { int cnt = 0 ; int j = next@@ Occurren@@ ce ( str , n , 0 , ch ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( j != -1 && j < i ) { j = next@@ Occurren@@ ce ( str , n , j + 1 , ch ) ; } if ( j == -1 ) break ; cnt += ( n - j ) ; } return cnt ; } int main ( ) { string str = " ge@@ ek@@ s@@ forge@@ e@@ ks " ; int n = str . length ( ) ; char ch = ' k ' ; cout << count@@ Sub@@ Str ( str , n , ch ) ; return 0 ; }
Find number of mag@@ ical pairs of string of length L 2836 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int power ( int x , unsigned int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } int main ( ) { int L = 2 , P = pow ( 10 , 9 ) ; int ans = power ( 325 , L , P ) ; cout << ans << " STRNEWLINE " ; return 0 ; }
In 2856 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void reve@@ re@@ se@@ Array ( int arr [ ] , int n ) { int rev [ n ] ; for ( int i = 0 ; i < n ; i ++ ) rev [ n - i - 1 ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = rev [ i ] ; } void print@@ Array ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << endl ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; print@@ Array ( arr , n ) ; reve@@ re@@ se@@ Array ( arr , n ) ; cout << " Reversed ▁ array ▁ is " << endl ; print@@ Array ( arr , n ) ; return 0 ; }
Find Binary string by converting all 01 or 10 to 11 after M iterations 2896 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ String ( string str , int M ) { int N = str . length ( ) ; M = min ( M , N ) ; string s1 = " " ; while ( M != 0 ) { s1 = " " ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == '0' ) { if ( ( str [ i - 1 ] == '1' && str [ i + 1 ] != '1' ) || ( str [ i - 1 ] != '1' && str [ i + 1 ] == '1' ) ) s1 += '1' ; else s1 += '0' ; } else s1 += '1' ; } if ( str == s1 ) break ; str = s1 ; M -- ; } cout << s1 ; } int main ( ) { string str = "01@@ 101@@ 00" ; int M = 3 ; find@@ String ( str , M ) ; return 0 ; }
Print digits for each array element that does not divide any digit of that element 3029 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void indi@@ visible@@ Digits ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int num = 0 ; cout << arr [ i ] << " : ▁ " ; for ( int j = 2 ; j < 10 ; j ++ ) { int temp = arr [ i ] ; bool flag = true ; while ( temp > 0 ) { if ( ( temp % 10 ) != 0 && ( temp % 10 ) % j == 0 ) { flag = false ; break ; } temp /= 10 ; } if ( flag ) { cout << j << ' ▁ ' ; } } cout << endl ; } } int main ( ) { int arr [ ] = { 4@@ 162 , 11@@ 52 , 99@@ 8@@ 42 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; indi@@ visible@@ Digits ( arr , N ) ; return 0 ; }
Check if two binary strings can be made equal by sw@@ apping pairs of un@@ equal characters 3104 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void check ( string s1 , string s2 ) { int s@@ 1_0 = 0 , s@@ 2_0 = 0 ; for ( int i = 0 ; i < s1 . size ( ) ; i ++ ) { if ( s1 [ i ] == '0' ) { s@@ 1_0 ++ ; } if ( s2 [ i ] == '0' ) { s@@ 2_0 ++ ; } } if ( s@@ 1_0 != s@@ 2_0 ) { cout << " NO " << endl ; return ; } else { int Coun@@ t1 = 0 , Count@@ 2 = 0 ; for ( int i = 0 ; i < s1 . size ( ) ; i ++ ) { if ( s1 [ i ] == '0' ) { Coun@@ t1 ++ ; } if ( s2 [ i ] == '0' ) { Count@@ 2 ++ ; } if ( Coun@@ t1 < Count@@ 2 ) { cout << " NO " << endl ; return ; } } cout << " YES " << endl ; } } int main ( ) { string s1 = "100@@ 11@@ 1" ; string s2 = "11@@ 101@@ 0" ; check ( s1 , s2 ) ; s1 = "11@@ 0100@@ " ; s2 = "@@ 0101@@ 01" ; check ( s1 , s2 ) ; return 0 ; }
Maximum even numbers present in any sub@@ array of size K 3158 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max@@ Even@@ Inte@@ gers ( int arr [ ] , int N , int M ) { int ans = 0 ; for ( int i = 0 ; i <= N - M ; i ++ ) { int cnt = 0 ; for ( int j = 0 ; j < M ; j ++ ) { if ( arr [ i + j ] % 2 == 0 ) cnt ++ ; } ans = max ( ans , cnt ) ; } return ans ; } int main ( ) { int arr [ ] = { 2 , 3 , 5 , 4 , 7 , 6 } ; int K = 3 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << max@@ Even@@ Inte@@ gers ( arr , N , K ) << endl ; return 0 ; }
Check if all sub@@ arrays contains at least one unique element 3290 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; string check ( int arr [ ] , int n ) { map < int , int > hm ; for ( int i = 0 ; i < n ; i ++ ) { hm [ arr [ i ] ] = 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { hm [ arr [ j ] ] ++ ; bool flag = false ; for ( auto x : hm ) { if ( x . second == 1 ) { flag = true ; break ; } } if ( ! flag ) return " No " ; } hm . clear ( ) ; } return " Yes " ; } int main ( ) { int arr [ ] = { 1 , 2 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << check ( arr , N ) ; }
Search insert position of K in a sorted array 3310 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find_@@ index ( int arr [ ] , int n , int K ) { int start = 0 ; int end = n - 1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( arr [ mid ] == K ) return mid ; else if ( arr [ mid ] < K ) start = mid + 1 ; else end = mid - 1 ; } return end + 1 ; } int main ( ) { int arr [ ] = { 1 , 3 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 2 ; cout << find_@@ index ( arr , n , K ) << endl ; return 0 ; }
Check if a pal@@ ind@@ ro@@ mic string can be obtained by concaten@@ ating sub@@ strings split from same indices of two given strings 3325 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Pal@@ ind@@ ro@@ me ( string str ) { int i = 0 , j = str . size ( ) - 1 ; while ( i < j ) { if ( str [ i ] != str [ j ] ) return false ; i ++ ; j -- ; } return true ; } void form@@ Pal@@ ind@@ ro@@ me ( string a , string b , int n ) { char aa [ n + 2 ] ; char bb [ n + 2 ] ; for ( int i = 0 ; i < n + 2 ; i ++ ) { aa [ i ] = ' ▁ ' ; bb [ i ] = ' ▁ ' ; } for ( int i = 1 ; i <= n ; i ++ ) { aa [ i ] = a [ i - 1 ] ; bb [ i ] = b [ i - 1 ] ; } bool ok = false ; for ( int i = 0 ; i <= n + 1 ; i ++ ) { string la = " " ; string ra = " " ; string lb = " " ; string rb = " " ; for ( int j = 1 ; j <= i - 1 ; j ++ ) { if ( aa [ j ] == ' ▁ ' ) la += " " ; else la += aa [ j ] ; if ( bb [ j ] == ' ▁ ' ) lb += " " ; else lb += bb [ j ] ; } for ( int j = i ; j <= n + 1 ; j ++ ) { if ( aa [ j ] == ' ▁ ' ) ra += " " ; else ra += aa [ j ] ; if ( bb [ j ] == ' ▁ ' ) rb += " " ; else rb += bb [ j ] ; } if ( is@@ Pal@@ ind@@ ro@@ me ( la + rb ) || is@@ Pal@@ ind@@ ro@@ me ( lb + ra ) ) { ok = true ; break ; } } if ( ok ) cout << ( " Yes " ) ; else cout << ( " No " ) ; } int main ( ) { string A = " b@@ de@@ a " ; string B = " ab@@ bb " ; int N = 4 ; form@@ Pal@@ ind@@ ro@@ me ( A , B , N ) ; }
Check if a sequence of path visi@@ ts any coordinate twice or not 3417 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Cro@@ ssed ( string path ) { if ( path . size ( ) == 0 ) return false ; bool ans = false ; set < pair < int , int > > set ; int x = 0 , y = 0 ; set . insert ( { x , y } ) ; for ( int i = 0 ; i < path . size ( ) ; i ++ ) { if ( path [ i ] == ' N ' ) set . insert ( { x , y ++ } ) ; if ( path [ i ] == ' S ' ) set . insert ( { x , y -- } ) ; if ( path [ i ] == ' E ' ) set . insert ( { x ++ , y } ) ; if ( path [ i ] == ' W ' ) set . insert ( { x -- , y } ) ; if ( set . find ( { x , y } ) != set . end ( ) ) { ans = true ; break ; } } if ( ans ) cout << " Cro@@ ssed " ; else cout << " Not ▁ Cro@@ ssed " ; } int main ( ) { string path = " NE@@ SW " ; is@@ Cro@@ ssed ( path ) ; return 0 ; }
Lon@@ gest sub@@ sequence form@@ ing an Arith@@ metic Prog@@ ression ( AP ) 3437 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int l@@ eng@@ ht@@ Of@@ Lon@@ gest@@ AP ( int A [ ] , int n ) { unordered_map < int , unordered_map < int , int > > dp ; int res = 2 ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { int d = A [ j ] - A [ i ] ; dp [ d ] [ j ] = dp [ d ] . count ( i ) ? dp [ d ] [ i ] + 1 : 2 ; res = max ( res , dp [ d ] [ j ] ) ; } } return res ; } int main ( ) { int arr [ ] = { 20 , 1 , 15 , 3 , 10 , 5 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << l@@ eng@@ ht@@ Of@@ Lon@@ gest@@ AP ( arr , N ) ; return 0 ; }
Check if a given number can be expressed as pair 3449 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void check@@ Sum@@ Of@@ Natur@@ al ( int n ) { int i = 1 ; bool flag = false ; while ( i * ( i + 1 ) < n * 2 ) { int X = i * ( i + 1 ) ; int t = n * 2 - X ; int k = sqrt ( t ) ; if ( k * ( k + 1 ) == t ) { flag = true ; break ; } i += 1 ; } if ( flag ) cout << " YES " ; else cout << " NO " ; } int main ( ) { int n = 25 ; check@@ Sum@@ Of@@ Natur@@ al ( n ) ; return 0 ; }
Find a sub@@ array of size K whose sum is a perfect square 3473 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Per@@ fec@@ t@@ Square ( int n ) { double sr = sqrt ( n ) ; return ( ( sr - floor ( sr ) ) == 0 ) ; } void Sub@@ array@@ H@@ av@@ ing@@ Per@@ fec@@ t@@ Square ( vector < int > arr , int k ) { pair < int , int > ans ; int sum = 0 , i ; for ( i = 0 ; i < k ; i ++ ) { sum += arr [ i ] ; } bool found = false ; if ( is@@ Per@@ fec@@ t@@ Square ( sum ) ) { ans . first = 0 ; ans . second = i - 1 ; } else { for ( int j = i ; j < arr . size ( ) ; j ++ ) { sum = sum + arr [ j ] - arr [ j - k ] ; if ( is@@ Per@@ fec@@ t@@ Square ( sum ) ) { found = true ; ans . first = j - k + 1 ; ans . second = j ; } } for ( int k = ans . first ; k <= ans . second ; k ++ ) { cout << arr [ k ] << " ▁ " ; } } if ( found == false ) { cout << " - 1" ; } } int main ( ) { vector < int > arr ; arr = { 20 , 34 , 51 , 10 , 99 , 87 , 23 , 45 } ; int K = 3 ; Sub@@ array@@ H@@ av@@ ing@@ Per@@ fec@@ t@@ Square ( arr , K ) ; return 0 ; }
Check if the given two matrices are mirror images of one another 3480 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void mirror@@ Matrix ( int mat@@ 1 [ ] [ 4 ] , int mat2 [ ] [ 4 ] , int N ) { int row = 0 ; int col = 0 ; bool is@@ Mirror@@ Image = true ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = N - 1 ; j >= 0 ; j -- ) { if ( mat2 [ row ] [ col ] != mat@@ 1 [ i ] [ j ] ) { is@@ Mirror@@ Image = false ; } col ++ ; } col = 0 ; row ++ ; } if ( is@@ Mirror@@ Image ) cout << " Yes " ; else cout << " No " ; } int main ( ) { int N = 4 ; int mat@@ 1 [ ] [ 4 ] = { { 1 , 2 , 3 , 4 } , { 0 , 6 , 7 , 8 } , { 9 , 10 , 11 , 12 } , { 13 , 14 , 15 , 16 } } ; int mat2 [ ] [ 4 ] = { { 4 , 3 , 2 , 1 } , { 8 , 7 , 6 , 0 } , { 12 , 11 , 10 , 9 } , { 16 , 15 , 14 , 13 } } ; mirror@@ Matrix ( mat@@ 1 , mat2 , N ) ; }
Count ways to split a Binary String into three sub@@ strings having equal count of zeros 3488 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int split@@ string ( string s ) { int n = s . length ( ) ; int zeros = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( s [ i ] == '0' ) zeros ++ ; if ( zeros % 3 != 0 ) return 0 ; if ( zeros == 0 ) return ( ( n - 1 ) * ( n - 2 ) ) / 2 ; int zer@@ os@@ In@@ Each@@ Sub@@ string = zeros / 3 ; int ways@@ Of@@ First@@ Cut = 0 , ways@@ Of@@ Second@@ Cut = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '0' ) count ++ ; if ( count == zer@@ os@@ In@@ Each@@ Sub@@ string ) ways@@ Of@@ First@@ Cut ++ ; else if ( count == 2 * zer@@ os@@ In@@ Each@@ Sub@@ string ) ways@@ Of@@ Second@@ Cut ++ ; } return ways@@ Of@@ First@@ Cut * ways@@ Of@@ Second@@ Cut ; } int main ( ) { string s = "@@ 0101@@ 0" ; cout << " The ▁ number ▁ of ▁ ways ▁ to ▁ split ▁ is ▁ " << split@@ string ( s ) << endl ; }
Check if a string can be converted to another by sw@@ apping of adjacent characters of given type 3531 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool can@@ Transform ( string str1 , string str2 ) { string s1 = " " ; string s2 = " " ; for ( char c : str1 ) { if ( c != ' C ' ) { s1 += c ; } } for ( char c : str2 ) { if ( c != ' C ' ) { s2 += c ; } } if ( s1 != s2 ) return false ; int i = 0 ; int j = 0 ; int n = str1 . length ( ) ; while ( i < n and j < n ) { if ( str1 [ i ] == ' C ' ) { i ++ ; } else if ( str2 [ j ] == ' C ' ) { j ++ ; } else { if ( ( str1 [ i ] == ' A ' and i < j ) or ( str1 [ i ] == ' B ' and i > j ) ) { return false ; } i ++ ; j ++ ; } } return true ; } int main ( ) { string str1 = " B@@ CC@@ AB@@ CB@@ CA " ; string str2 = " C@@ BAC@@ C@@ BB@@ AC " ; if ( can@@ Transform ( str1 , str2 ) ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
Di@@ am@@ eters for each node of Tree after connecting it with given disconnected component 3548 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int X = 1 ; int diameter = 0 ; map < int , bool > mp ; void dfs ( int current_@@ node , int prev_@@ node , int len , bool add_to_@@ map , vector < vector < int > > & adj ) { if ( len > diameter ) { diameter = len ; X = current_@@ node ; } if ( add_to_@@ map && len == diameter ) { mp [ current_@@ node ] = 1 ; } for ( auto & it : adj [ current_@@ node ] ) { if ( it != prev_@@ node ) dfs ( it , current_@@ node , len + 1 , add_to_@@ map , adj ) ; } } void dfs@@ Utility ( vector < vector < int > > & adj ) { dfs ( 1 , -1 , 0 , 0 , adj ) ; int far@@ the@@ st_@@ node = X ; dfs ( far@@ the@@ st_@@ node , -1 , 0 , 0 , adj ) ; dfs ( far@@ the@@ st_@@ node , -1 , 0 , 1 , adj ) ; dfs ( X , -1 , 0 , 1 , adj ) ; } void print@@ Di@@ am@@ eters ( vector < vector < int > > & adj ) { dfs@@ Utility ( adj ) ; for ( int i = 1 ; i <= 6 ; i ++ ) { if ( mp [ i ] == 1 ) cout << diameter + 1 << " , ▁ " ; else cout << diameter << " , ▁ " ; } } int main ( ) { vector < vector < int > > adj ( 7 ) ; adj [ 1 ] . push_back ( 2 ) ; adj [ 2 ] . push_back ( 1 ) ; adj [ 1 ] . push_back ( 3 ) ; adj [ 3 ] . push_back ( 1 ) ; adj [ 2 ] . push_back ( 4 ) ; adj [ 4 ] . push_back ( 2 ) ; adj [ 2 ] . push_back ( 5 ) ; adj [ 5 ] . push_back ( 2 ) ; adj [ 2 ] . push_back ( 6 ) ; adj [ 6 ] . push_back ( 2 ) ; print@@ Di@@ am@@ eters ( adj ) ; return 0 ; }
Count of W@@ ays to obtain given Sum from the given Array elements 3581 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int kn@@ ap@@ S@@ ack ( int nums [ ] , int S , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += nums [ i ] ; if ( sum < S || - sum > - S || ( S + sum ) % 2 == 1 ) return 0 ; int dp [ ( S + sum ) / 2 + 1 ] ; for ( int i = 0 ; i <= ( S + sum ) / 2 ; i ++ ) dp [ i ] = 0 ; dp [ 0 ] = 1 ; for ( int j = 0 ; j < n ; j ++ ) { for ( int i = ( S + sum ) / 2 ; i >= nums [ j ] ; i -- ) { dp [ i ] += dp [ i - nums [ j ] ] ; } } return dp [ ( S + sum ) / 2 ] ; } int main ( ) { int S = 3 ; int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int answer = kn@@ ap@@ S@@ ack ( arr , S , 5 ) ; cout << answer << endl ; }
Count of Sub@@ strings with at least K pairwise Distin@@ ct Characters having same Frequency 3590 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int no_@@ of_@@ substring ( string s , int N ) { int fr@@ e [ 26 ] ; int str_@@ len ; str_@@ len = ( int ) s . length ( ) ; int count = 0 ; for ( int i = 0 ; i < str_@@ len ; i ++ ) { memset ( fr@@ e , 0 , sizeof ( fr@@ e ) ) ; int max_@@ index = 0 ; int dist = 0 ; for ( int j = i ; j < str_@@ len ; j ++ ) { int x = s [ j ] - ' a ' ; if ( fr@@ e [ x ] == 0 ) dist ++ ; fr@@ e [ x ] ++ ; max_@@ index = max ( max_@@ index , fr@@ e [ x ] ) ; if ( dist >= N && ( ( max_@@ index * dist ) == ( j - i + 1 ) ) ) count ++ ; } } return count ; } int main ( ) { string s = " ab@@ h@@ ay " ; int N = 3 ; cout << no_@@ of_@@ substring ( s , N ) ; return 0 ; }
Minimum Distance from a given Cell to all other Cells of a Matrix 3605 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int mat [ 1001 ] [ 1001 ] ; int r , c , x , y ; int dx [ ] = { 0 , -1 , -1 , -1 , 0 , 1 , 1 , 1 } ; int dy [ ] = { 1 , 1 , 0 , -1 , -1 , -1 , 0 , 1 } ; void Find@@ Minimum@@ Distance ( ) { queue < pair < int , int > > q ; q . push ( { x , y } ) ; mat [ x ] [ y ] = 0 ; while ( ! q . empty ( ) ) { x = q . front ( ) . first ; y = q . front ( ) . second ; q . pop ( ) ; for ( int i = 0 ; i < 8 ; i ++ ) { int a = x + dx [ i ] ; int b = y + dy [ i ] ; if ( a < 0 a > = r b >= c b < 0 ) continue ; if ( mat [ a ] [ b ] == 0 ) { mat [ a ] [ b ] = mat [ x ] [ y ] + 1 ; q . push ( { a , b } ) ; } } } } int main ( ) { r = 5 , c = 5 , x = 1 , y = 1 ; int t = x ; int l = y ; mat [ x ] [ y ] = 0 ; Find@@ Minimum@@ Distance ( ) ; mat [ t ] [ l ] = 0 ; for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) { cout << mat [ i ] [ j ] << " ▁ " ; } cout << endl ; } }
Count of sub@@ strings consisting of even number of vo@@ w@@ els 3646 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Vo@@ wel ( char c ) { if ( c == ' a ' c == ' e ' c == ' i ' c == ' o ' c == ' u ' ) return true ; return false ; } void count@@ Sub@@ strings ( string s , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = i ; j < n ; j ++ ) { if ( is@@ Vo@@ wel ( s [ j ] ) ) { count ++ ; } if ( count % 2 == 0 ) result ++ ; } } cout << result ; } int main ( ) { int n = 5 ; string s = " abcde " ; count@@ Sub@@ strings ( s , n ) ; return 0 ; }
Check if both hal@@ ves of a string are Pal@@ ind@@ ro@@ me or not 3668 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void check@@ Pal@@ ind@@ ro@@ me ( string S ) { int N = S . size ( ) ; bool first_@@ half = true ; bool second_@@ half = true ; int cnt = ( N / 2 ) - 1 ; for ( int i = 0 ; i < ( ( N / 2 ) / 2 ) ; i ++ ) { if ( S [ i ] != S [ cnt ] ) { first_@@ half = false ; break ; } if ( S [ N / 2 + i ] != S [ N / 2 + cnt ] ) { second_@@ half - false ; break ; } cnt -- ; } if ( first_@@ half && second_@@ half ) { cout << " Yes " << endl ; } else { cout << " No " << endl ; } } int main ( ) { string S = " mo@@ md@@ ad " ; check@@ Pal@@ ind@@ ro@@ me ( S ) ; return 0 ; }
Lon@@ gest sub@@ array with difference exactly K between any two distinct values 3700 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int lon@@ gest@@ Sub@@ array ( int arr [ ] , int n , int k ) { int i , j , Max = 1 ; set < int > s ; for ( i = 0 ; i < n - 1 ; i ++ ) { s . insert ( arr [ i ] ) ; for ( j = i + 1 ; j < n ; j ++ ) { if ( abs ( arr [ i ] - arr [ j ] ) == 0 || abs ( arr [ i ] - arr [ j ] ) == k ) { if ( ! s . count ( arr [ j ] ) ) { if ( s . size ( ) == 2 ) break ; else s . insert ( arr [ j ] ) ; } } else break ; } if ( s . size ( ) == 2 ) { Max = max ( Max , j - i ) ; s . clear ( ) ; } else s . clear ( ) ; } return Max ; } int main ( ) { int arr [ ] = { 1 , 0 , 2 , 2 , 5 , 5 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 1 ; int length = lon@@ gest@@ Sub@@ array ( arr , N , K ) ; if ( length == 1 ) cout << -1 ; else cout << length ; return 0 ; }
Number of ways to select equal sized sub@@ arrays from two arrays having at@@ least K equal pairs of elements 3770 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int prefix_@@ 2D [ 2005 ] [ 2005 ] ; int sub@@ Matrix@@ Sum ( int i , int j , int len ) { return prefix_@@ 2D [ i ] [ j ] - prefix_@@ 2D [ i ] [ j - len ] - prefix_@@ 2D [ i - len ] [ j ] + prefix_@@ 2D [ i - len ] [ j - len ] ; } int numberOf@@ W@@ ays ( int a [ ] , int b [ ] , int n , int m , int k ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( a [ i - 1 ] == b [ j - 1 ] ) prefix_@@ 2D [ i ] [ j ] = 1 ; else prefix_@@ 2D [ i ] [ j ] = 0 ; } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { prefix_@@ 2D [ i ] [ j ] += prefix_@@ 2D [ i ] [ j - 1 ] ; } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { prefix_@@ 2D [ i ] [ j ] += prefix_@@ 2D [ i - 1 ] [ j ] ; } } int answer = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { int low = 1 ; int high = min ( i , j ) ; while ( low < high ) { int mid = ( low + high ) >> 1 ; if ( sub@@ Matrix@@ Sum ( i , j , mid ) >= k ) { high = mid ; } else { low = mid + 1 ; } } if ( sub@@ Matrix@@ Sum ( i , j , low ) >= k ) { answer += ( min ( i , j ) - low + 1 ) ; } } } return answer ; } int main ( ) { int N = 2 , M = 3 ; int A [ N ] = { 1 , 2 } ; int B [ M ] = { 1 , 2 , 3 } ; int K = 1 ; cout << numberOf@@ W@@ ays ( A , B , N , M , K ) ; return 0 ; }
Repe@@ ated Character W@@ ho@@ se First Appearance is Left@@ most 3874 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define NO_@@ OF_@@ CHARS 256 NEW_LINE int first@@ Repe@@ ating ( string & str ) { bool visited [ NO_@@ OF_@@ CHARS ] ; for ( int i = 0 ; i < NO_@@ OF_@@ CHARS ; i ++ ) visited [ i ] = false ; int res = -1 ; for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) { if ( visited [ str [ i ] ] == false ) visited [ str [ i ] ] = true ; else res = i ; } return res ; } int main ( ) { string str = " ge@@ ek@@ s@@ forge@@ e@@ ks " ; int index = first@@ Repe@@ ating ( str ) ; if ( index == -1 ) printf ( " Either ▁ all ▁ characters ▁ are ▁ " " distinct ▁ or ▁ string ▁ is ▁ empty " ) ; else printf ( " First ▁ Repe@@ ating ▁ character " " ▁ is ▁ % c " , str [ index ] ) ; return 0 ; }
Print all the sum pairs which occur maximum number of times 3908 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ Sum@@ Pairs ( int a [ ] , int n ) { unordered_map < int , int > mp@@ p ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { mp@@ p [ a [ i ] + a [ j ] ] ++ ; } } int occur = 0 ; for ( auto it : mp@@ p ) { if ( it . second > occur ) { occur = it . second ; } } for ( auto it : mp@@ p ) { if ( it . second == occur ) cout << it . first << endl ; } } int main ( ) { int a [ ] = { 1 , 8 , 3 , 11 , 4 , 9 , 2 , 7 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; find@@ Sum@@ Pairs ( a , n ) ; return 0 ; }
Find the smallest after deleting given elements 3963 | #@@ include " cli@@ mits " NEW_LINE #@@ include " iostream " NEW_LINE #@@ include " unordered _ map " NEW_LINE using namespace std ; int find@@ S@@ malle@@ st@@ After@@ Del ( int arr [ ] , int m , int del [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; ++ i ) { mp [ del [ i ] ] ++ ; } int smalle@@ st@@ Element = INT_MAX ; for ( int i = 0 ; i < m ; ++ i ) { if ( mp . find ( arr [ i ] ) != mp . end ( ) ) { mp [ arr [ i ] ] -- ; if ( mp [ arr [ i ] ] == 0 ) mp . erase ( arr [ i ] ) ; } else smalle@@ st@@ Element = min ( smalle@@ st@@ Element , arr [ i ] ) ; } return smalle@@ st@@ Element ; } int main ( ) { int array [ ] = { 5 , 12 , 33 , 4 , 56 , 12 , 20 } ; int m = sizeof ( array ) / sizeof ( array [ 0 ] ) ; int del [ ] = { 12 , 4 , 56 , 5 } ; int n = sizeof ( del ) / sizeof ( del [ 0 ] ) ; cout << find@@ S@@ malle@@ st@@ After@@ Del ( array , m , del , n ) ; return 0 ; }
Find the largest after deleting the given elements 3964 | #@@ include " cli@@ mits " NEW_LINE #@@ include " iostream " NEW_LINE #@@ include " unordered _ map " NEW_LINE using namespace std ; int find@@ lar@@ gest@@ After@@ Del ( int arr [ ] , int m , int del [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; ++ i ) { mp [ del [ i ] ] ++ ; } int lar@@ gest@@ Element = INT_@@ MIN ; for ( int i = 0 ; i < m ; ++ i ) { if ( mp . find ( arr [ i ] ) != mp . end ( ) ) { mp [ arr [ i ] ] -- ; if ( mp [ arr [ i ] ] == 0 ) mp . erase ( arr [ i ] ) ; } else lar@@ gest@@ Element = max ( lar@@ gest@@ Element , arr [ i ] ) ; } return lar@@ gest@@ Element ; } int main ( ) { int array [ ] = { 5 , 12 , 33 , 4 , 56 , 12 , 20 } ; int m = sizeof ( array ) / sizeof ( array [ 0 ] ) ; int del [ ] = { 12 , 33 , 56 , 5 } ; int n = sizeof ( del ) / sizeof ( del [ 0 ] ) ; cout << find@@ lar@@ gest@@ After@@ Del ( array , m , del , n ) ; return 0 ; }
Lar@@ gest gap in an array 4034 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int solve ( int a [ ] , int n ) { int min@@ 1 = a [ 0 ] ; int max@@ 1 = a [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > max@@ 1 ) max@@ 1 = a [ i ] ; if ( a [ i ] < min@@ 1 ) min@@ 1 = a [ i ] ; } return abs ( min@@ 1 - max@@ 1 ) ; } int main ( ) { int arr [ ] = { -1 , 2 , 3 , 4 , -@@ 10 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Lar@@ gest ▁ gap ▁ is ▁ : ▁ " << solve ( arr , size ) ; return 0 ; }
Minim@@ ize the sum of roots of a given polynomial 4049 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void getMinimum@@ Sum ( int arr [ ] , int n ) { vector < int > res ; vector < int > pos ; vector < int > neg ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) pos . push_back ( i ) ; else if ( arr [ i ] < 0 ) neg . push_back ( i ) ; } if ( pos . size ( ) >= 2 && neg . size ( ) >= 2 ) { int pos@@ Max = INT_@@ MIN , pos@@ Max@@ Idx = -1 ; int pos@@ Min = INT_MAX , pos@@ Min@@ Idx = -1 ; int neg@@ Max = INT_@@ MIN , neg@@ Max@@ Idx = -1 ; int neg@@ Min = INT_MAX , neg@@ Min@@ Idx = -1 ; for ( int i = 0 ; i < pos . size ( ) ; i ++ ) { if ( arr [ pos [ i ] ] > pos@@ Max ) { pos@@ Max@@ Idx = pos [ i ] ; pos@@ Max = arr [ pos@@ Max@@ Idx ] ; } } for ( int i = 0 ; i < pos . size ( ) ; i ++ ) { if ( arr [ pos [ i ] ] < pos@@ Min && pos [ i ] != pos@@ Max@@ Idx ) { pos@@ Min@@ Idx = pos [ i ] ; pos@@ Min = arr [ pos@@ Min@@ Idx ] ; } } for ( int i = 0 ; i < neg . size ( ) ; i ++ ) { if ( abs ( arr [ neg [ i ] ] ) > neg@@ Max ) { neg@@ Max@@ Idx = neg [ i ] ; neg@@ Max = abs ( arr [ neg@@ Max@@ Idx ] ) ; } } for ( int i = 0 ; i < neg . size ( ) ; i ++ ) { if ( abs ( arr [ neg [ i ] ] ) < neg@@ Min && neg [ i ] != neg@@ Max@@ Idx ) { neg@@ Min@@ Idx = neg [ i ] ; neg@@ Min = abs ( arr [ neg@@ Min@@ Idx ] ) ; } } double pos@@ Val = -@@ 1.0 * ( double ) pos@@ Max / ( double ) pos@@ Min ; double neg@@ Val = -@@ 1.0 * ( double ) neg@@ Max / ( double ) neg@@ Min ; if ( pos@@ Val < neg@@ Val ) { res . push_back ( arr [ pos@@ Min@@ Idx ] ) ; res . push_back ( arr [ pos@@ Max@@ Idx ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i != pos@@ Min@@ Idx && i != pos@@ Max@@ Idx ) { res . push_back ( arr [ i ] ) ; } } } else { res . push_back ( arr [ neg@@ Min@@ Idx ] ) ; res . push_back ( arr [ neg@@ Max@@ Idx ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i != neg@@ Min@@ Idx && i != neg@@ Max@@ Idx ) { res . push_back ( arr [ i ] ) ; } } } for ( int i = 0 ; i < res . size ( ) ; i ++ ) { cout << res [ i ] << " ▁ " ; } cout << " STRNEWLINE " ; } else if ( pos . size ( ) >= 2 ) { int pos@@ Max = INT_@@ MIN , pos@@ Max@@ Idx = -1 ; int pos@@ Min = INT_MAX , pos@@ Min@@ Idx = -1 ; for ( int i = 0 ; i < pos . size ( ) ; i ++ ) { if ( arr [ pos [ i ] ] > pos@@ Max ) { pos@@ Max@@ Idx = pos [ i ] ; pos@@ Max = arr [ pos@@ Max@@ Idx ] ; } } for ( int i = 0 ; i < pos . size ( ) ; i ++ ) { if ( arr [ pos [ i ] ] < pos@@ Min && pos [ i ] != pos@@ Max@@ Idx ) { pos@@ Min@@ Idx = pos [ i ] ; pos@@ Min = arr [ pos@@ Min@@ Idx ] ; } } res . push_back ( arr [ pos@@ Min@@ Idx ] ) ; res . push_back ( arr [ pos@@ Max@@ Idx ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i != pos@@ Min@@ Idx && i != pos@@ Max@@ Idx ) { res . push_back ( arr [ i ] ) ; } } for ( int i = 0 ; i < res . size ( ) ; i ++ ) { cout << res [ i ] << " ▁ " ; } cout << " STRNEWLINE " ; } else if ( neg . size ( ) >= 2 ) { int neg@@ Max = INT_@@ MIN , neg@@ Max@@ Idx = -1 ; int neg@@ Min = INT_MAX , neg@@ Min@@ Idx = -1 ; for ( int i = 0 ; i < neg . size ( ) ; i ++ ) { if ( abs ( arr [ neg [ i ] ] ) > neg@@ Max ) { neg@@ Max@@ Idx = neg [ i ] ; neg@@ Max = abs ( arr [ neg@@ Max@@ Idx ] ) ; } } for ( int i = 0 ; i < neg . size ( ) ; i ++ ) { if ( abs ( arr [ neg [ i ] ] ) < neg@@ Min && neg [ i ] != neg@@ Max@@ Idx ) { neg@@ Min@@ Idx = neg [ i ] ; neg@@ Min = abs ( arr [ neg@@ Min@@ Idx ] ) ; } } res . push_back ( arr [ neg@@ Min@@ Idx ] ) ; res . push_back ( arr [ neg@@ Max@@ Idx ] ) ; for ( int i = 0 ; i < n ; i ++ ) if ( i != neg@@ Min@@ Idx && i != neg@@ Max@@ Idx ) res . push_back ( arr [ i ] ) ; for ( int i = 0 ; i < res . size ( ) ; i ++ ) cout << res [ i ] << " ▁ " ; cout << " STRNEWLINE " ; } else { cout << " No ▁ swap ▁ required STRNEWLINE " ; } } int main ( ) { int arr [ ] = { -@@ 4 , 1 , 6 , -@@ 3 , -2 , -1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; getMinimum@@ Sum ( arr , n ) ; return 0 ; }
Find the one missing number in range 4069 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int missing@@ Num ( int arr [ ] , int n ) { int min@@ value = * min_@@ element ( arr , arr + n ) ; int xor@@ num = 0 ; for ( int i = 0 ; i < n ; i ++ ) { xor@@ num ^= ( min@@ value ) ^ arr [ i ] ; min@@ value ++ ; } return xor@@ num ^ min@@ value ; } int main ( ) { int arr [ ] = { 13 , 12 , 11 , 15 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << missing@@ Num ( arr , n ) ; return 0 ; }
Re@@ arrange array elements to maxim@@ ize the sum of ME@@ X of all prefix arrays 4151 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void maximum@@ Me@@ x ( int arr [ ] , int N ) { vector < int > ans ; sort ( arr , arr + N ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == 0 arr [ i ] != arr [ i - 1 ] ) ans . push_back ( arr [ i ] ) ; } for ( int i = 0 ; i < N ; i ++ ) { if ( i > 0 && arr [ i ] == arr [ i - 1 ] ) ans . push_back ( arr [ i ] ) ; } for ( int i = 0 ; i < N ; i ++ ) cout << ans [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 1 , 0 , 0 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; maximum@@ Me@@ x ( arr , N ) ; return 0 ; }
Sort an array using Bu@@ bble Sort without using loops 4160 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; vector < int > bu@@ bb@@ le_@@ sort ( vector < int > ar ) { if ( ar . size ( ) <= 1 ) return ar ; if ( ar . size ( ) == 2 ) { if ( ar [ 0 ] < ar [ 1 ] ) return ar ; else return { ar [ 1 ] , ar [ 0 ] } ; } int a = ar [ 0 ] ; int b = ar [ 1 ] ; vector < int > bs ; for ( int i = 2 ; i < ar . size ( ) ; i ++ ) bs . push_back ( ar [ i ] ) ; vector < int > res ; if ( a < b ) { vector < int > temp1 ; temp1 . push_back ( b ) ; for ( int i = 0 ; i < bs . size ( ) ; i ++ ) temp1 . push_back ( bs [ i ] ) ; vector < int > v = bu@@ bb@@ le_@@ sort ( temp1 ) ; v . insert ( v . begin ( ) , a ) ; res = v ; } else { vector < int > temp1 ; temp1 . push_back ( a ) ; for ( int i = 0 ; i < bs . size ( ) ; i ++ ) temp1 . push_back ( bs [ i ] ) ; vector < int > v = bu@@ bb@@ le_@@ sort ( temp1 ) ; v . insert ( v . begin ( ) , b ) ; res = v ; } vector < int > pass ; for ( int i = 0 ; i < res . size ( ) - 1 ; i ++ ) pass . push_back ( res [ i ] ) ; vector < int > ans = bu@@ bb@@ le_@@ sort ( pass ) ; ans . push_back ( res [ res . size ( ) - 1 ] ) ; return ans ; } int main ( ) { vector < int > arr { 1 , 3 , 4 , 5 , 6 , 2 } ; vector < int > res = bu@@ bb@@ le_@@ sort ( arr ) ; for ( int i = 0 ; i < res . size ( ) ; i ++ ) cout << res [ i ] << " ▁ " ; }
Reduce given three Numbers by decrement@@ ing in Pairs 4343 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int solution ( int A , int B , int C ) { int arr [ 3 ] ; arr [ 0 ] = A , arr [ 1 ] = B , arr [ 2 ] = C ; sort ( arr , arr + 3 ) ; if ( arr [ 2 ] < arr [ 0 ] + arr [ 1 ] ) return ( ( arr [ 0 ] + arr [ 1 ] + arr [ 2 ] ) / 2 ) ; else return ( arr [ 0 ] + arr [ 1 ] ) ; } int main ( ) { int A = 8 , B = 1 , C = 5 ; cout << solution ( A , B , C ) ; return 0 ; }
Maximum size subset with given sum using Back@@ tracking 4371 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max_length = 0 ; vector < int > store ; vector < int > ans ; void find_@@ max_length ( vector < int > & arr , int index , int sum , int k ) { sum = sum + arr [ index ] ; store . push_back ( arr [ index ] ) ; if ( sum == k ) { if ( max_length < store . size ( ) ) { max_length = store . size ( ) ; ans = store ; } } for ( int i = index + 1 ; i < arr . size ( ) ; i ++ ) { if ( sum + arr [ i ] <= k ) { find_@@ max_length ( arr , i , sum , k ) ; store . pop_back ( ) ; } else return ; } return ; } int lon@@ gest@@ Sub@@ sequence ( vector < int > arr , int n , int k ) { sort ( arr . begin ( ) , arr . end ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( max_length >= n - i ) break ; store . clear ( ) ; find_@@ max_length ( arr , i , 0 , k ) ; } return max_length ; } int main ( ) { vector < int > arr { -@@ 3 , 0 , 1 , 1 , 2 } ; int n = arr . size ( ) ; int k = 1 ; cout << lon@@ gest@@ Sub@@ sequence ( arr , n , k ) ; return 0 ; }
Minim@@ ize the sum of differences of consecutive elements after removing exactly K elements 4502 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int getNumber ( int n , int k ) { int pos ; if ( n % 2 == 0 ) { pos = n / 2 ; } else { pos = ( n / 2 ) + 1 ; } if ( k <= pos ) { return ( k * 2 - 1 ) ; } else return ( ( k - pos ) * 2 ) ; } int main ( ) { int n = 8 , k = 5 ; cout << getNumber ( n , k ) ; return 0 ; }
Minimum number of consecutive sequences that can be formed in an array 4618 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count@@ Sequences ( int arr [ ] , int n ) { int count = 1 ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] + 1 != arr [ i + 1 ] ) count ++ ; return count ; } int main ( ) { int arr [ ] = { 1 , 7 , 3 , 5 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << count@@ Sequences ( arr , n ) ; return 0 ; }
Check whether an array can be fit into another array re@@ arr@@ anging the elements in the array 4696 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool check@@ Fit@@ ting@@ Arrays ( int A [ ] , int B [ ] , int N ) { sort ( A , A + N ) ; sort ( B , B + N ) ; for ( int i = 0 ; i < N ; i ++ ) if ( A [ i ] > B [ i ] ) return false ; return true ; } int main ( ) { int A [ ] = { 7 , 5 , 3 , 2 } ; int B [ ] = { 5 , 4 , 8 , 7 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; if ( check@@ Fit@@ ting@@ Arrays ( A , B , N ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
Stable Selection Sort 4740 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; void stable@@ Selection@@ Sort ( int a [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { int min = i ; for ( int j = i + 1 ; j < n ; j ++ ) if ( a [ min ] > a [ j ] ) min = j ; int key = a [ min ] ; while ( min > i ) { a [ min ] = a [ min - 1 ] ; min -- ; } a [ i ] = key ; } } void print@@ Array ( int a [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << a [ i ] << " ▁ " ; cout << endl ; } int main ( ) { int a [ ] = { 4 , 5 , 3 , 2 , 4 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; stable@@ Selection@@ Sort ( a , n ) ; print@@ Array ( a , n ) ; return 0 ; }
Pan@@ ca@@ ke sorting 4857 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void flip ( int arr [ ] , int i ) { int temp , start = 0 ; while ( start < i ) { temp = arr [ start ] ; arr [ start ] = arr [ i ] ; arr [ i ] = temp ; start ++ ; i -- ; } } int find@@ Max ( int arr [ ] , int n ) { int mi , i ; for ( mi = 0 , i = 0 ; i < n ; ++ i ) if ( arr [ i ] > arr [ mi ] ) mi = i ; return mi ; } void pan@@ ca@@ ke@@ Sort ( int * arr , int n ) { for ( int curr_@@ size = n ; curr_@@ size > 1 ; -- curr_@@ size ) { int mi = find@@ Max ( arr , curr_@@ size ) ; if ( mi != curr_@@ size - 1 ) { flip ( arr , mi ) ; flip ( arr , curr_@@ size - 1 ) ; } } } void print@@ Array ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; ++ i ) cout << arr [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 23 , 10 , 20 , 11 , 12 , 6 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; pan@@ ca@@ ke@@ Sort ( arr , n ) ; cout << " Sorted ▁ Array ▁ " << endl ; print@@ Array ( arr , n ) ; return 0 ; }
Maxim@@ ize array product by changing any array element arr [ i ] to ( 5060 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void find@@ Array@@ With@@ Max@@ Product ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) if ( arr [ i ] >= 0 ) { arr [ i ] = - arr [ i ] - 1 ; } if ( N % 2 == 1 ) { int max_@@ element = -1 ; int index = -1 ; for ( int i = 0 ; i < N ; i ++ ) if ( abs ( arr [ i ] ) > max_@@ element ) { max_@@ element = abs ( arr [ i ] ) ; index = i ; } arr [ index ] = - arr [ index ] - 1 ; } for ( int i = 0 ; i < N ; i ++ ) printf ( " % d ▁ " , arr [ i ] ) ; } int main ( ) { int arr [ ] = { -@@ 3 , 0 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; find@@ Array@@ With@@ Max@@ Product ( arr , N ) ; return 0 ; }
Construct an N 5167 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; const int N = 1e@@ 5 + 5 ; int visited [ N ] ; void construct_@@ tree ( int weights [ ] , int n ) { int minimum = * min_@@ element ( weights , weights + n ) ; int maximum = * max_@@ element ( weights , weights + n ) ; if ( minimum == maximum ) { cout << " No " ; return ; } else { cout << " Yes " << endl ; } int root = weights [ 0 ] ; visited [ 1 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( weights [ i ] != root && visited [ i + 1 ] == 0 ) { cout << 1 << " ▁ " << i + 1 << " ▁ " << endl ; visited [ i + 1 ] = 1 ; } } int not@@ root = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( weights [ i ] != root ) { not@@ root = i + 1 ; break ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( weights [ i ] == root && visited [ i + 1 ] == 0 ) { cout << not@@ root << " ▁ " << i + 1 << endl ; visited [ i + 1 ] = 1 ; } } } int main ( ) { int weights [ ] = { 1 , 2 , 1 , 2 , 5 } ; int N = sizeof ( weights ) / sizeof ( weights [ 0 ] ) ; construct_@@ tree ( weights , N ) ; }
Minimum characters to be replaced to make a string concatenation of a K 5182 | #@@ include " bits / std@@ c + + . h " NEW_LINE using namespace std ; void addEdge ( vector < int > adj [ ] , int u , int v ) { adj [ u ] . push_back ( v ) ; adj [ v ] . push_back ( u ) ; } void DFS ( int u , vector < int > adj [ ] , int & cnt , vector < bool > & visited , int fr@@ e [ ] , string S ) { visited [ u ] = true ; cnt ++ ; fr@@ e [ S [ u ] - ' a ' ] ++ ; for ( int i = 0 ; i < adj [ u ] . size ( ) ; i ++ ) { if ( ! visited [ adj [ u ] [ i ] ] ) { DFS ( adj [ u ] [ i ] , adj , cnt , visited , fr@@ e , S ) ; } } } int minimum@@ Operations ( string & S , int m ) { int V = 100 ; vector < int > adj [ V ] ; int total = 0 , N = S . length ( ) ; for ( int i = 0 ; i < N ; i ++ ) { addEdge ( adj , i , N - i - 1 ) ; addEdge ( adj , N - i - 1 , i ) ; } for ( int i = 0 ; i < N - m ; i ++ ) { addEdge ( adj , i , i + m ) ; addEdge ( adj , i + m , i ) ; } vector < bool > visited ( V , 0 ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( ! visited [ i ] ) { int fr@@ e [ 26 ] = { 0 } ; int cnt = 0 , maxx = -1 ; DFS ( i , adj , cnt , visited , fr@@ e , S ) ; for ( int j = 0 ; j < 26 ; j ++ ) maxx = max ( maxx , fr@@ e [ j ] ) ; total += cnt - maxx ; } } cout << total ; } int main ( ) { string S = " ab@@ a@@ aba " ; int K = 2 ; minimum@@ Operations ( S , K ) ; return 0 ; }
Unset least significant K bits of a given number 5277 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int clear@@ Last@@ Bit ( int N , int K ) { int mask = ( -1 << K + 1 ) ; return N = N & mask ; } int main ( ) { int N = 7@@ 30 , K = 3 ; cout << clear@@ Last@@ Bit ( N , K ) ; return 0 ; }
Check if quanti@@ ties of 3 distinct colors can be converted to a single color by given merge 5280 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; bool is@@ Possible ( int r , int b , int g ) { r = r % 3 ; b = b % 3 ; g = g % 3 ; if ( r == b b == g g == r ) { return true ; } else { return false ; } } int main ( ) { int R = 1 , B = 3 , G = 6 ; if ( is@@ Possible ( R , B , G ) ) { cout << " Yes " << endl ; } else { cout << " No " << endl ; } return 0 ; }
Check if quanti@@ ties of 3 distinct colors can be converted to a single color by given merge 5343 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; unsigned int count@@ Set@@ Bits@@ Util ( unsigned int x ) { if ( x <= 0 ) return 0 ; return ( ( x % 2 == 0 ? 0 : 1 ) + count@@ Set@@ Bits@@ Util ( x / 2 ) ) ; } unsigned int count@@ Set@@ Bits ( unsigned int L , unsigned int R ) { int bit@@ Count = 0 ; for ( int i = L ; i <= R ; i ++ ) { bit@@ Count += count@@ Set@@ Bits@@ Util ( i ) ; } return bit@@ Count ; } int main ( ) { int L = 3 , R = 5 ; printf ( " Total ▁ set ▁ bit ▁ count ▁ is ▁ % d " , count@@ Set@@ Bits ( L , R ) ) ; return 0 ; }
Minim@@ ize cost to Swap two given Arrays 5361 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int getMin@@ Cost ( vector < int > A , vector < int > B , int N ) { int mini = INT_MAX ; for ( int i = 0 ; i < N ; i ++ ) { mini = min ( mini , min ( A [ i ] , B [ i ] ) ) ; } return mini * ( 2 * N - 1 ) ; } int main ( ) { int N = 3 ; vector < int > A = { 1 , 4 , 2 } ; vector < int > B = { 10 , 6 , 12 } ; cout << getMin@@ Cost ( A , B , N ) ; return 0 ; }
Find a number M < N such that difference between their XOR and AND is maximum 5379 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ M ( int N ) { int M = 0 ; int MSB = ( int ) log2 ( N ) ; for ( int i = 0 ; i < MSB ; i ++ ) { if ( ! ( N & ( 1 << i ) ) ) M += ( 1 << i ) ; } return M ; } int main ( ) { int N = 6 ; cout << find@@ M ( N ) ; return 0 ; }
Maxim@@ ize the sum of modulus with every Array element 5465 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int max@@ Modu@@ lo@@ sum ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } return sum - n ; } int main ( ) { int a [ ] = { 3 , 4 , 6 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << max@@ Modu@@ lo@@ sum ( a , n ) ; return 0 ; }
Minim@@ ize cost to convert given two integers to zero using given operations 5492 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int make@@ Zero ( int x , int y , int a , int b ) { if ( x > y ) x = y , y = x ; int tot_@@ cost = ( y - x ) * a ; int cost@@ 1 = 2 * x * a ; int cost@@ 2 = x * b ; tot_@@ cost += min ( cost@@ 1 , cost@@ 2 ) ; cout << tot_@@ cost ; } int main ( ) { int X = 1 , Y = 3 ; int cost@@ 1 = 39@@ 1 , cost@@ 2 = 555 ; make@@ Zero ( X , Y , cost@@ 1 , cost@@ 2 ) ; }
Find N fractions that sum upto a given fraction N / D 5494 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void split@@ Fraction ( int n , int d ) { int ar [ n ] ; int first = d + n - 1 ; ar [ 0 ] = first ; for ( int i = 1 ; i < n ; i ++ ) { int temp = -- first ; first ++ ; ar [ i ] = first * temp ; -- first ; } for ( int i = 0 ; i < n ; i ++ ) { if ( ar [ i ] % n == 0 ) { cout << "1 / " << ar [ i ] / n << " , ▁ " ; } else { cout << n << " / " << ar [ i ] << " , ▁ " ; } } } int main ( ) { int N = 4 ; int D = 2 ; split@@ Fraction ( N , D ) ; }
Minimum number of sub@@ sequences required to convert one string to another using Gre@@ edy Algorithm 5569 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int find@@ Minimum@@ Sub@@ sequences ( string A , string B ) { int numberOf@@ Sub@@ sequences = 1 ; int sizeOf@@ B = B . size ( ) ; int sizeOf@@ A = A . size ( ) ; int inf = 1000000 ; int next [ 26 ] [ sizeOf@@ B ] ; for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 0 ; j < sizeOf@@ B ; j ++ ) { next [ i ] [ j ] = inf ; } } for ( int i = 0 ; i < sizeOf@@ B ; i ++ ) { next [ B [ i ] - ' a ' ] [ i ] = i ; } for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = sizeOf@@ B - 2 ; j >= 0 ; j -- ) { if ( next [ i ] [ j ] == inf ) { next [ i ] [ j ] = next [ i ] [ j + 1 ] ; } } } int pos = 0 ; int i = 0 ; while ( i < sizeOf@@ A ) { if ( pos == 0 && next [ A [ i ] - ' a ' ] [ pos ] == inf ) { numberOf@@ Sub@@ sequences = -1 ; break ; } else if ( pos < sizeOf@@ B && next [ A [ i ] - ' a ' ] [ pos ] < inf ) { int nextIndex = next [ A [ i ] - ' a ' ] [ pos ] + 1 ; pos = nextIndex ; i ++ ; } else { numberOf@@ Sub@@ sequences ++ ; pos = 0 ; } } return numberOf@@ Sub@@ sequences ; } int main ( ) { string A = " a@@ ac@@ be " ; string B = " ace@@ ab " ; cout << find@@ Minimum@@ Sub@@ sequences ( A , B ) ; return 0 ; }
Minimum number of operations required to reduce N to 1 5720 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int count_@@ minimum_@@ operations ( long long n ) { if ( n == 2 ) { return 1 ; } else if ( n == 1 ) { return 0 ; } if ( n % 3 == 0 ) { return 1 + count_@@ minimum_@@ operations ( n / 3 ) ; } else if ( n % 3 == 1 ) { return 1 + count_@@ minimum_@@ operations ( n - 1 ) ; } else { return 1 + count_@@ minimum_@@ operations ( n + 1 ) ; } } int main ( ) { long long n = 4 ; long long ans = count_@@ minimum_@@ operations ( n ) ; cout << ans << endl ; return 0 ; }
Problems not solved at the end of N@@ th day 5734 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int problem@@ s@@ Left ( int K , int P , int N ) { if ( K <= P ) return 0 ; else return ( K - P ) * N ; } int main ( ) { int K , P , N ; K = 4 ; P = 1 ; N = 10 ; cout << problem@@ s@@ Left ( K , P , N ) ; return 0 ; }
Kr@@ us@@ k@@ al '@@ s Algorithm (@@ Simple Implementation for Adjac@@ ency Matrix@@ ) 5748 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; #@@ define V 5 NEW_LINE int parent [ V ] ; int find ( int i ) { while ( parent [ i ] != i ) i = parent [ i ] ; return i ; } void union@@ 1 ( int i , int j ) { int a = find ( i ) ; int b = find ( j ) ; parent [ a ] = b ; } void kr@@ us@@ kal@@ M@@ ST ( int cost [ ] [ V ] ) { for ( int i = 0 ; i < V ; i ++ ) parent [ i ] = i ; int edge@@ _count = 0 ; while ( edge@@ _count < V - 1 ) { int min = INT_MAX , a = -1 , b = -1 ; for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { if ( find ( i ) != find ( j ) && cost [ i ] [ j ] < min ) { min = cost [ i ] [ j ] ; a = i ; b = j ; } } } union@@ 1 ( a , b ) ; printf ( " Edge ▁ % d : ( % d , ▁ % d ) ▁ cost : % d ▁ STRNEWLINE " , edge@@ _count ++ , a , b , min ) ; min@@ cost += min ; } printf ( " Minimum cost = % d " , min@@ cost ) ; } int main ( ) { int cost [ ] [ V ] = { { INT_MAX , 2 , INT_MAX , 6 , INT_MAX } , { 2 , INT_MAX , 3 , 8 , 5 } , { INT_MAX , 3 , INT_MAX , INT_MAX , 7 } , { 6 , 8 , INT_MAX , INT_MAX , 9 } , { INT_MAX , 5 , 7 , 9 , INT_MAX } , } ; kr@@ us@@ kal@@ M@@ ST ( cost ) ; return 0 ; }
Minimum cost of purch@@ asing at least X cho@@ col@@ ates 5943 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Min@@ Cost ( pair < int , int > arr [ ] , int X , int n , int i = 0 ) { if ( X <= 0 ) return 0 ; if ( i >= n ) return INT_MAX ; int inc = find@@ Min@@ Cost ( arr , X - arr [ i ] . first , n , i + 1 ) ; if ( inc != INT_MAX ) inc += arr [ i ] . second ; int exc = find@@ Min@@ Cost ( arr , X , n , i + 1 ) ; return min ( inc , exc ) ; } int main ( ) { pair < int , int > arr [ ] = { { 4 , 3 } , { 3 , 2 } , { 2 , 4 } , { 1 , 3 } , { 4 , 2 } } ; int X = 7 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int ans = find@@ Min@@ Cost ( arr , X , n ) ; if ( ans != INT_MAX ) cout << ans ; else cout << -1 ; return 0 ; }
Maximum score possible by removing sub@@ strings made up of single distinct character 5953 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; map < string , int > dp ; int max@@ Score ( string s , vector < int > a ) { if ( dp . find ( s ) != dp . end ( ) ) return dp [ s ] ; int n = s . size ( ) ; if ( n == 0 ) return 0 ; if ( n == 1 ) return a [ 0 ] ; int head = 0 ; int mx = -1 ; while ( head < n ) { int tail = head ; while ( tail < n ) { if ( s [ tail ] != s [ head ] ) { head = tail ; break ; } string sub = s . substr ( head , tail + 1 ) ; mx = max ( mx , a [ sub . size ( ) - 1 ] + max@@ Score ( s . substr ( 0 , head ) + s . substr ( tail + 1 , s . size ( ) ) , a ) ) ; tail += 1 ; } if ( tail == n ) break ; } dp [ s ] = mx ; return mx ; } int main ( ) { string s = " abb " ; vector < int > a = { 1 , 3 , 1 } ; cout << ( max@@ Score ( s , a ) - 1 ) ; }
Maximum sum sub@@ matrix 5974 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int k@@ ad@@ ane ( vector < int > v ) { int curr@@ Sum = 0 ; int max@@ Sum = INT_@@ MIN ; for ( int i = 0 ; i < ( int ) v . size ( ) ; i ++ ) { curr@@ Sum += v [ i ] ; if ( curr@@ Sum > max@@ Sum ) { max@@ Sum = curr@@ Sum ; } if ( curr@@ Sum < 0 ) { curr@@ Sum = 0 ; } } return max@@ Sum ; } void max@@ Sub@@ matrix@@ Sum ( vector < vector < int > > A ) { int r = A . size ( ) ; int c = A [ 0 ] . size ( ) ; int * * prefix = new int * [ r ] ; for ( int i = 0 ; i < r ; i ++ ) { prefix [ i ] = new int ; for ( int j = 0 ; j < c ; j ++ ) { prefix [ i ] [ j ] = 0 ; } } for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) { if ( j == 0 ) prefix [ i ] [ j ] = A [ i ] [ j ] ; else prefix [ i ] [ j ] = A [ i ] [ j ] + prefix [ i ] [ j - 1 ] ; } } int max@@ Sum = INT_@@ MIN ; for ( int i = 0 ; i < c ; i ++ ) { for ( int j = i ; j < c ; j ++ ) { vector < int > v ; for ( int k = 0 ; k < r ; k ++ ) { int el = 0 ; if ( i == 0 ) el = prefix [ k ] [ j ] ; else el = prefix [ k ] [ j ] - prefix [ k ] [ i - 1 ] ; v . push_back ( el ) ; } max@@ Sum = max ( max@@ Sum , k@@ ad@@ ane ( v ) ) ; } } cout << max@@ Sum << " STRNEWLINE " ; } int main ( ) { vector < vector < int > > matrix = { { 0 , -2 , -@@ 7 , 0 } , { 9 , 2 , -@@ 6 , 2 } , { -@@ 4 , 1 , -@@ 4 , 1 } , { -1 , 8 , 0 , -2 } } ; max@@ Sub@@ matrix@@ Sum ( matrix ) ; return 0 ; }
Count ways to remove pairs from a matrix such that remaining elements can be grouped in vertical or horizontal pairs 5984 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void number@@ of@@ pairs ( vector < vector < int > > v , int k ) { int n = v . size ( ) ; if ( n % 2 == 1 ) { cout << 0 ; return ; } int ans = 0 ; int dp [ k ] [ 2 ] ; for ( int i = 0 ; i < k ; i ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( i + j ) % 2 == 0 ) dp [ v [ i ] [ j ] - 1 ] [ 0 ] ++ ; else dp [ v [ i ] [ j ] - 1 ] [ 1 ] ++ ; } } for ( int i = 0 ; i < k ; i ++ ) { for ( int j = i + 1 ; j < k ; j ++ ) { ans += dp [ i ] [ 0 ] * dp [ j ] [ 1 ] ; ans += dp [ i ] [ 1 ] * dp [ j ] [ 0 ] ; } } cout << ans ; } int main ( ) { vector < vector < int > > mat = { { 1 , 2 } , { 3 , 4 } } ; int K = 4 ; number@@ of@@ pairs ( mat , K ) ; return 0 ; }
Lon@@ gest sub@@ sequence having maximum GC@@ D between any pair of distinct elements 6036 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ Max@@ GC@@ D ( int arr [ ] , int N ) { int high = 0 ; for ( int i = 0 ; i < N ; i ++ ) { high = max ( high , arr [ i ] ) ; } int count [ high + 1 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { count [ arr [ i ] ] += 1 ; } int counter = 0 ; for ( int i = high ; i > 0 ; i -- ) { int j = i ; while ( j <= high ) { if ( count [ j ] > 0 ) counter += count [ j ] ; j += i ; if ( counter == 2 ) return i ; } counter = 0 ; } } int maxlen ( int i , int j , int arr [ ] , int ar@@ r1 [ ] , int N , int max@@ gcd ) { int a = 1 ; if ( i >= N or j >= N ) return 0 ; if ( __@@ gcd ( arr [ i ] , ar@@ r1 [ j ] ) == max@@ gcd && arr [ i ] != ar@@ r1 [ j ] ) { a = max ( a , 1 + maxlen ( i , j + 1 , arr , ar@@ r1 , N , max@@ gcd ) ) ; return a ; } return max ( maxlen ( i + 1 , j , arr , ar@@ r1 , N , max@@ gcd ) , maxlen ( i , j + 1 , arr , ar@@ r1 , N , max@@ gcd ) ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 8 , 5 , 6 } ; int ar@@ r1 [ ] = { 1 , 2 , 8 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sort ( arr , arr + n ) ; sort ( ar@@ r1 , ar@@ r1 + n ) ; int max@@ gcd = find@@ Max@@ GC@@ D ( arr , n ) ; cout << maxlen ( 0 , 0 , arr , ar@@ r1 , n , max@@ gcd ) + 1 ; }
Count ways to obtain given sum by repeated throws of a di@@ ce 6072 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int find@@ W@@ ays ( int N , int dp [ ] ) { if ( N == 0 ) { return 1 ; } if ( dp [ N ] != -1 ) { return dp [ N ] ; } int cnt = 0 ; for ( int i = 1 ; i <= 6 ; i ++ ) { if ( N - i >= 0 ) { cnt = cnt + find@@ W@@ ays ( N - i , dp ) ; } } return dp [ N ] = cnt ; } int main ( ) { int N = 4 ; int dp [ N + 1 ] ; memset ( dp , -1 , sizeof ( dp ) ) ; cout << find@@ W@@ ays ( N , dp ) ; return 0 ; }
Minimum steps to reduce N to 0 by given operations 6090 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; int min@@ Days ( int n ) { if ( n < 1 ) return n ; int cnt = 1 + min ( n % 2 + min@@ Days ( n / 2 ) , n % 3 + min@@ Days ( n / 3 ) ) ; return cnt ; } int main ( ) { int N = 6 ; cout << min@@ Days ( N ) ; return 0 ; }
Minimum steps to reduce N to 0 by given operations 6101 | #@@ include <@@ bit@@ s/@@ std@@ c@@ ++@@ .@@ h@@ > NEW_LINE using namespace std ; void count@@ Num@@ s ( int N ) { int dp [ N ] [ 16 ] ; memset ( dp , 0 , sizeof ( dp [ 0 ] [ 0 ] ) * N * 16 ) ; for ( int i = 1 ; i <= 9 ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { for ( int k = 0 ; k < 16 ; k ++ ) { int xo = j ^ k ; dp [ i ] [ xo ] += dp [ i - 1 ] [ k ] ; } } } int count = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) count += dp [ N - 1 ] [ i ] ; cout << ( count ) << endl ; } int main ( ) { int N = 1 ; count@@ Num@@ s ( N ) ; }
Count of numbers upto M di@@ visible by given Prime Numbers 6108 | #@@ include <@@ io@@ stream@@ > NEW_LINE using namespace std ; int count ( int a [ ] , int M , int N ) { int cnt = 0 ; for ( int i = 1 ; i <= M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( i % a [ j ] == 0 ) { cnt ++ ; break ; } } } return cnt ; } int main ( ) { int arr [ ] = { 2 , 3 , 5 , 7 } ; int m = 100 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << count ( arr , m , n ) ; return 0 ; }
